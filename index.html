<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/15/js设计模式-代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/js设计模式-代理模式/" itemprop="url">
                  js设计模式-代理模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T20:24:36+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/15/js设计模式-代理模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/15/js设计模式-代理模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  692
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><pre><code>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
    代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；
举例：
    图片预加载、图片懒加载、
    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、
    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、
    缓存代理（缓存请求结果、计算结果）
</code></pre><h1 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 先实现具体的两个算法</div><div class="line">const mult = function() &#123;</div><div class="line">	let a = 1;</div><div class="line">	for (let i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">		a *= arguments[i];</div><div class="line">	&#125;</div><div class="line">	return a;</div><div class="line">&#125;;</div><div class="line">const plus = function() &#123;</div><div class="line">	let a = 0;</div><div class="line">	for (let i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">		a += arguments[i];</div><div class="line">	&#125;</div><div class="line">	return a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建缓存代理</div><div class="line">const createProxyFactory = function(fn) &#123;</div><div class="line">	let cache = &#123;&#125;; // 保存计算的结果</div><div class="line">	// 使用闭包在内存中保留对cache的引用</div><div class="line">	return function() &#123;</div><div class="line">		let args = Array.from(arguments).join(&apos;,&apos;); // 将所有参数转化为字符串作为缓存的 key</div><div class="line">		if (args in cache) &#123;</div><div class="line">			return cache[args];</div><div class="line">		&#125; else &#123;</div><div class="line">			return cache[args] = fn.apply(this, arguments);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用代理对象</div><div class="line">const proxyMult = createProxyFactory(mult);</div><div class="line">const proxyPlus = createProxyFactory(plus);</div><div class="line">console.log(proxyMult(1,2,3,4)); // 24</div><div class="line">console.log(proxyPlus(1,2,3,4)); // 10</div></pre></td></tr></table></figure>

说明：这里每次进行同类的计算时（乘法和加法两类），先判断缓存对象cache中是否存在该参数连接成的字符串作为key的属性。
如果有，则直接从cache中读取，否则就进行计算并保存其结果。
</code></pre><h1 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h1><pre><code>虚拟代理：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建
例：使用虚拟代理实现图片懒加载
下面以虚拟代理来说明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 本体对象</div><div class="line">const imgFunc = (function() &#123;</div><div class="line">	const imgNode = document.createElement(&apos;img&apos;);</div><div class="line">	document.body.appendChild(imgNode);</div><div class="line">	return &#123;</div><div class="line">		setSrc(src)&#123;</div><div class="line">			imgNode.src = src;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 代理对象</div><div class="line">const proxyImage = (function() &#123;</div><div class="line">	const img = new Image();</div><div class="line">	img.onload = function() &#123;</div><div class="line">		imgFunc.setSrc(this.src);</div><div class="line">	&#125;;</div><div class="line">	return &#123;</div><div class="line">		setSrc(src)&#123;</div><div class="line">			imgFunc.setSrc(&apos;./loading.gif&apos;);</div><div class="line">			img.src = src;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 使用代理对象</div><div class="line">proxyImage.setSrc(&apos;./reality.png&apos;);</div></pre></td></tr></table></figure>

说明：图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。
这里讲述一下代理对象做了那些事：
    1.创建了一个 Image 对象，并为其绑定了 onload 事件。
    2.将 imgNode 先设置为 &apos;./loading.gif&apos; 加载的菊花图。
    3.当 Image 对象加载完真实的图片，也就是上文的 &apos;./reality.png&apos; ,将 imgNode 设置为 &apos;./reality.png&apos;。 
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/shamoguying1140/p/3169206.html" target="_blank" rel="external">js设计模式（9）—代理模式</a><br>    <a href="https://juejin.im/post/59df4f74f265da430f311909" target="_blank" rel="external">JavaScript设计模式</a><br>    <a href="http://blog.csdn.net/hi_xiexialing/article/details/54605065" target="_blank" rel="external"> js用高阶函数动态创建缓存代理</a></p>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4722696.html" target="_blank" rel="external">理解javascript中的策略模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/15/js设计模式-策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/js设计模式-策略模式/" itemprop="url">
                  js设计模式-策略模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T19:11:08+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/15/js设计模式-策略模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/15/js设计模式-策略模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  810
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><pre><code>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
举例：表单效验（是否为空、长度、手机号、邮箱等等）
    计算年终奖（工资、效绩）
下面以年终将做说明：
比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，
绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 一组策略类封装具体的算法</div><div class="line">const Bouns = &#123;</div><div class="line">	A (salary)&#123;</div><div class="line">		return salary * 4;</div><div class="line">	&#125;,</div><div class="line">	B (salary)&#123;</div><div class="line">		return salary * 3;</div><div class="line">	&#125;,</div><div class="line">	C (salary)&#123;</div><div class="line">		return salary * 2;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(Bouns);</div><div class="line"></div><div class="line">/*</div><div class="line">* 计算年终奖 环境类Context</div><div class="line">* @param &#123;String&#125; A 效绩等级</div><div class="line">* @param &#123;Number&#125; 10000 每月工资</div><div class="line">* @returns &#123;Number&#125; 40000 年终奖</div><div class="line">*/</div><div class="line">const calculateBouns = function (type, salary)&#123;</div><div class="line">	return Bouns[type](salary);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 测试年终奖计算方式</div><div class="line">const demo1 = calculateBouns(&apos;A&apos;, 10000);</div><div class="line">const demo2 = calculateBouns(&apos;B&apos;, 80000);</div><div class="line">console.log(demo1, demo2); // 40000, 240000</div></pre></td></tr></table></figure>

说明：
策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，
实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，
而算法的实现是根据绩效对应不同的绩效规则；
一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，
并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，
随后把请求委托给某一个策略类。
复合开放-封闭原则，可变的部分为策略类（一组算法），不变的部分为执行具体算法的方式。
</code></pre><h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">// 这里我们实现一组策略类封装具体的验证规则</div><div class="line">const strategy = &#123;</div><div class="line">	// 是否为空</div><div class="line">	isNotEmpty (value, errorMsg)&#123;</div><div class="line">		if (value === &apos;&apos;) &#123;</div><div class="line">			return errorMsg;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	// 最小长度</div><div class="line">	minLength (value, errorMsg, length)&#123;</div><div class="line">		if (value.length &lt; length) &#123;</div><div class="line">			return errorMsg;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	// 手机号码格式</div><div class="line">	mobileFormat (value,errorMsg)&#123;</div><div class="line">		if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;</div><div class="line">			return errorMsg;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(strategy);</div><div class="line"></div><div class="line">var Validator = function()&#123;</div><div class="line">	this.cache = [];  // 保存效验规则</div><div class="line">&#125;;</div><div class="line">Validator.prototype.add = function(dom,rules) &#123;</div><div class="line">	var self = this;</div><div class="line">	for(var i = 0, rule; rule = rules[i++]; )&#123;</div><div class="line">		(function(rule)&#123;</div><div class="line">			var strategyAry = rule.strategy.split(&quot;:&quot;);</div><div class="line">			var errorMsg = rule.errorMsg;</div><div class="line">			self.cache.push(function()&#123;</div><div class="line">				var strategy = strategyAry.shift();</div><div class="line">				strategyAry.unshift(dom.value);</div><div class="line">				strategyAry.push(errorMsg);</div><div class="line">				return strategys[strategy].apply(dom,strategyAry);</div><div class="line">			&#125;);</div><div class="line">		&#125;)(rule);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Validator.prototype.start = function()&#123;</div><div class="line">	for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;</div><div class="line">	var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息</div><div class="line">	if(msg) &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">// 代码调用</div><div class="line">var registerForm = document.getElementById(&quot;registerForm&quot;);</div><div class="line">var validateFunc = function()&#123;</div><div class="line">	var validator = new Validator(); // 创建一个Validator对象</div><div class="line">	/* 添加一些效验规则 */</div><div class="line">	validator.add(registerForm.userName,[</div><div class="line">		&#123;strategy: &apos;isNotEmpty&apos;,errorMsg:&apos;用户名不能为空&apos;&#125;,</div><div class="line">		&#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;用户名长度不能小于6位&apos;&#125;</div><div class="line">	]);</div><div class="line">	validator.add(registerForm.password,[</div><div class="line">		&#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;密码长度不能小于6位&apos;&#125;,</div><div class="line">	]);</div><div class="line">	validator.add(registerForm.phoneNumber,[</div><div class="line">		&#123;strategy: &apos;mobileFormat&apos;,errorMsg:&apos;手机号格式不正确&apos;&#125;,</div><div class="line">	]);</div><div class="line">	var errorMsg = validator.start(); // 获得效验结果</div><div class="line">	return errorMsg; // 返回效验结果</div><div class="line">&#125;;</div><div class="line">// 点击确定提交</div><div class="line">registerForm.onsubmit = function()&#123;</div><div class="line">	var errorMsg = validateFunc();</div><div class="line">	if(errorMsg)&#123;</div><div class="line">		alert(errorMsg);</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

说明：此处代码来源于--腾讯.曾探的《javascript设计模式》，这能很好的说明策略模式的用途。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4722696.html" target="_blank" rel="external">理解javascript中的策略模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/15/js设计模式-单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/js设计模式-单例模式/" itemprop="url">
                  js设计模式-单例模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T16:12:31+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/15/js设计模式-单例模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/15/js设计模式-单例模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  561
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><pre><code>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。
    在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。
举例：模态框、登录控件、注销控件
下面均以登录模态框做说明
</code></pre><h1 id="引入代理实现单例模式"><a href="#引入代理实现单例模式" class="headerlink" title="引入代理实现单例模式"></a>引入代理实现单例模式</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var CreateDiv = function(html) &#123;</div><div class="line">	this.html = html;</div><div class="line">	this.init();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CreateDiv.prototype.init = function() &#123;</div><div class="line">	var div = document.createElement(&apos;div&apos;);</div><div class="line">	div.innerHTML = this.html;</div><div class="line">	document.body.appendChild(div);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var ProxySingletonCreateDiv = (function() &#123;</div><div class="line">	var instance;</div><div class="line">	return function(html) &#123;</div><div class="line">		if (!instance) &#123;</div><div class="line">			instance = new CreateDiv(html);</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var a = new ProxySingletonCreateDiv(&apos;seven1&apos;);</div><div class="line">var b = new ProxySingletonCreateDiv(&apos;seven2&apos;);</div><div class="line"></div><div class="line">console.log(a === b); // true</div></pre></td></tr></table></figure>

说明：我们负责管理单例的逻辑移到了代理类ProxySingletonCreateDiv中。
这样一来，CreateDiv就变成了一个普通的类，他跟ProxySingletonCreateDiv组合起来可以达到单例模式的效果。
</code></pre><h1 id="通用的单例模式"><a href="#通用的单例模式" class="headerlink" title="通用的单例模式"></a>通用的单例模式</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 通用的单例验证方法</div><div class="line">const getSingle = function (fn)&#123;</div><div class="line">	let result;</div><div class="line">	return function ()&#123;</div><div class="line">		return result || (result = fn.apply(this, arguments));</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建登录模态框</div><div class="line">const createLoginLayer = function ()&#123;</div><div class="line">	const div = document.createElement(&apos;div&apos;);</div><div class="line">	div.innerHTML = &apos;我是登录模态框&apos;;</div><div class="line">	document.body.appendChild(div);</div><div class="line">	return div;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 为登录模态框使用单例模式</div><div class="line">const createSingleLoginLoyer = getSingle(createLoginLayer);</div><div class="line">const loginLayer1 = createSingleLoginLoyer(); // 第一个登录模态框</div><div class="line">const loginLayer2 = createSingleLoginLoyer(); // 还是第一个登录模态框</div><div class="line"></div><div class="line">console.log(loginLayer1 === loginLayer2); // true</div></pre></td></tr></table></figure>

这时不管你执行多少次 createSingleLoginLoyer() 方法，都只会生产一个 div 节点。
我们的通用单例模式就完成了。    
</code></pre><h1 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h1><pre><code>定义：惰性单例指的是在需要的时候才创建对象的实例。
以创建登录模态框为例
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const createLoginLayer = (function ()&#123;</div><div class="line">	let div;</div><div class="line">	return function ()&#123;</div><div class="line">		if (!div) &#123;</div><div class="line">			div = document.createElement(&apos;div&apos;);</div><div class="line">			div.innerHTML = &apos;我是登录模态框&apos;;</div><div class="line">		&#125;</div><div class="line">		return div;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 在点击按钮时才创建节点（惰性）</div><div class="line">document.getElementById(&apos;login-btn&apos;).onclick = function ()&#123;</div><div class="line">	var loginLayer = createLoginLayer();</div><div class="line">	loginLayer.style.display = &apos;block&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

这里的对惰性单例的实现主要是只有单例了网页上的登录按钮，才会去创建，登录框的dom节点，并且只是创建一次。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000006049548" target="_blank" rel="external">JavaScript设计模式—-单例模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html" target="_blank" rel="external">设计模式之单例模式</a>    </p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/15/js设计模式-工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/js设计模式-工厂模式/" itemprop="url">
                  js设计模式-工厂模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T10:07:51+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/15/js设计模式-工厂模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/15/js设计模式-工厂模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  594
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从事前端开发已经有几年了，也经常使用一些设计模式，但是对一些设计模式并不能很好的说出名字以及使用场景。<br>现利用周末闲暇事件来好好整理一下JS中常用的设计模式,如有不正确的地方，还望指出，谢谢！</p>
<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><pre><code>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。 
举例：计算器（加、减、乘、除）
    自行车售卖（山地、公路）
    饮料机（咖啡、牛奶、水）
    RPG中职业（战士、法师、射手）
这里就以RPG中职业（战士、法师、射手）来做说明：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">// 先创建各个角色的构造函数</div><div class="line">function  Warrior() &#123;</div><div class="line">	this.skill = &apos;回血&apos;;</div><div class="line">	this.blood = 150; // 初始化生命值</div><div class="line">	this.hit = 8; // 普通攻击伤害</div><div class="line">	// 其他特有属性和方法比如生命值</div><div class="line">	console.log(this);</div><div class="line">&#125;</div><div class="line">function  Mage() &#123;</div><div class="line">		this.skill = &apos;冰冻&apos;;</div><div class="line">	this.blood = 120; // 初始化生命值</div><div class="line">	this.hit = 3; // 普通攻击伤害</div><div class="line">	// 其他特有属性和方法</div><div class="line">	console.log(this);</div><div class="line">&#125;</div><div class="line">function  Archer() &#123;</div><div class="line">		this.skill = &apos;消耗&apos;;</div><div class="line">	this.blood = 110; // 初始化生命值</div><div class="line">	this.hit = 10; // 普通攻击伤害</div><div class="line">	// 其他特有属性和方法</div><div class="line">	console.log(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 工厂对象 可以是普通对象是的方法 和 构造函数，这里使用前者</div><div class="line">const RoleFactory = &#123;</div><div class="line">	createRole (role) &#123;</div><div class="line">		let roler;</div><div class="line">		switch (role) &#123;</div><div class="line">			case &apos;战士&apos;:</div><div class="line">				roler = new Warrior();</div><div class="line">				break;</div><div class="line">			case &apos;法师&apos;:</div><div class="line">				roler = new Mage();</div><div class="line">				break;</div><div class="line">			case &apos;射手&apos;:</div><div class="line">				roler = new Archer();</div><div class="line">				break;</div><div class="line">			// 后续扩展角色直接追加选择语句和添加角色构造函数</div><div class="line">			defaulr: </div><div class="line">				roler = new Warrior();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(RoleFactory); // 冻结该对象，防止他人操作</div><div class="line"></div><div class="line">// 创建各个角色的实例</div><div class="line">var warrior1 = RoleFactory.createRole(&apos;战士&apos;); // 创建一个战士</div><div class="line">var mage1 = RoleFactory.createRole(&apos;法师&apos;); // 创建一个法师</div><div class="line">var arche1 = RoleFactory.createRole(&apos;射手&apos;); // 创建一个射手</div></pre></td></tr></table></figure>
<p>其实我们还可以这样设计工厂处理函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const RoleFactory = function (role) &#123;</div><div class="line">	return new role ();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var warrior1 = RoleFactory(Warrior); // 创建一个战士</div><div class="line">var mage1 = RoleFactory(Mage); // 创建一个法师</div><div class="line">var arche1 = RoleFactory(Archer); // 创建一个射手</div></pre></td></tr></table></figure></p>
<p>上面输出的结果<br><img src="http://oxpnrlb4j.bkt.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%BE%93%E5%87%BA.png" alt="输出结果"></p>
<h1 id="什么时候使用工厂模式"><a href="#什么时候使用工厂模式" class="headerlink" title="什么时候使用工厂模式"></a>什么时候使用工厂模式</h1><ol>
<li>对象的构建十分复杂</li>
<li>需要依赖具体环境创建不同实例</li>
<li>处理大量具有相同属性的小对象<blockquote>
<p>   参考文档：<br><a href="http://www.cnblogs.com/coiorz/p/4806550.html" target="_blank" rel="external">JS设计模式之工厂模式</a><br><a href="http://www.cnblogs.com/myzy/p/5240457.html" target="_blank" rel="external">js之简单工厂模式</a></p>
</blockquote>
</li>
</ol>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/14/OSI七层与TCP-IP五层网络架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/14/OSI七层与TCP-IP五层网络架构/" itemprop="url">
                  OSI七层与TCP/IP五层网络架构
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T20:04:20+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/通信协议/" itemprop="url" rel="index">
                    <span itemprop="name">通信协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/14/OSI七层与TCP-IP五层网络架构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/14/OSI七层与TCP-IP五层网络架构/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,501
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，<br>从参加工作一直做的WEB前端开发，对这方面知识也不是太需要。<br>但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol>
<li>OSI：开放系统互连参考模型 (Open System Interconnect 简称OSI）。</li>
<li>TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li>IP：网络之间互连的协议（IP）是Internet Protocol的外语缩写，中文缩写为“网协”。</li>
<li>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。</li>
<li>HTTPS：HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</li>
</ol>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><pre><code>OSI七层结构--每层的解释
</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.jpg" alt="OSI七层结构"><br>    OSI七层结构–每层结构的功能<br><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="OSI七层结构"></p>
<h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><pre><code>OSI七层模型与TCP/IP五层模型的关系
</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.png" alt="TCP/IP五层模型"><br>    OSI七层模型–每层的设备<br><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E8%AE%BE%E5%A4%87.jpg" alt="各层对应的设备"></p>
<h1 id="对各层的详细说明"><a href="#对各层的详细说明" class="headerlink" title="对各层的详细说明"></a>对各层的详细说明</h1><ol>
<li>第一层是物理层（PhysicalLayer)，<br>规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。<br>具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；<br>电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等；<br>功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；<br>规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。<br>在这一层，数据的单位称为比特（bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。</li>
<li>第二层是数据链路层<br>在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，<br>并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。<br>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br>在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</li>
<li>第三层是网络层<br>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。<br>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。<br>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。<br>如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。<br>IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。<br>地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。<br>网络层协议的代表包括：IP、IPX、RIP、OSPF等。</li>
<li>第四层是处理信息的传输层<br>第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，<br>TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。<br>这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。<br>第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。<br>所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。<br>传输层协议的代表包括：TCP、UDP、SPX等。</li>
<li>第五层是会话层<br>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，<br>而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。<br>如服务器验证用户登录便是由会话层完成的。</li>
<li>第六层是表示层<br>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，<br>转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。<br>数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li>
<li>第七层应用层<br>应用层为操作系统或网络应用程序提供访问网络服务的接口。<br>应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。</li>
</ol>
<blockquote>
<p>   参考文档<br>    <a href="https://www.2cto.com/net/201310/252965.html" target="_blank" rel="external">OSI七层与TCP/IP五层网络架构详解</a><br>    <a href="http://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="external">OSI七层模型与TCP/IP五层模型</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/13/RESTful-API-设计指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/13/RESTful-API-设计指南/" itemprop="url">
                  RESTful API 设计指南
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T21:21:51+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/服务端/" itemprop="url" rel="index">
                    <span itemprop="name">服务端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/13/RESTful-API-设计指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/13/RESTful-API-设计指南/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,339
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RESTful-API-的产生"><a href="#RESTful-API-的产生" class="headerlink" title="RESTful API 的产生"></a>RESTful API 的产生</h2><pre><code>当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。
因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信，在这种情况下RESTful API产生了。
</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><pre><code>HTTP、HTTPS 应用层协议。 
联网的设备 和 服务器之前的通信。
</code></pre><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ol>
<li>API专用域名<br><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></li>
<li>API放在主域名<br><a href="https://example.org/api/" target="_blank" rel="external">https://example.org/api/</a></li>
</ol>
<h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><pre><code>将API的版本放入URL中。
https://api.example.com/v1
</code></pre><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote>
<p>   路径又称”终点”（endpoint），表示API的具体网址。<br>    在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>    举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://api.example.com/v1/zoos</div><div class="line">https://api.example.com/v1/animals</div><div class="line">https://api.example.com/v1/employees</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><pre><code>对于资源的具体操作类型，由HTTP动词表示。
常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
</code></pre><ol>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。    </li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）:从服务器删除资源。<br>不常用的两个动词</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的那些属性是客户端可以改变的。<br>动物园管理系统举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /zoos: 列出所有动物园。</div><div class="line">POST /zoos: 新建一个动物园（动物园的信息的请求体中）。</div><div class="line">GET /zoos/ID: 获取某个动物园的信息。</div><div class="line">PUT /zoos/ID: 更新某个指定动物园的信息（提供该动物园的全部信息）。</div><div class="line">PATCH /zoos/ID: 更新某个动物园的信息（提供该动物园的部分信息）。</div><div class="line">DELETE /zoos/ID: 删除某个动物园。</div><div class="line">GET /zoos/ID/animals: 列出某个指定动物园的所有动物。</div><div class="line">DELETE /zoos/ID/animals/ID: 删除某个动物园的指定动物。</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><pre><code>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">?limit=10：指定返回记录的数量</div><div class="line">?offset=10：指定返回记录的开始位置。</div><div class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</div><div class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</div><div class="line">?animal_type_id=1：指定筛选条件</div></pre></td></tr></table></figure>

参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。
比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。
</code></pre><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote>
<p>   服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</div><div class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</div><div class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</div><div class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</div><div class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</div><div class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</div><div class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</div><div class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</div><div class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</div><div class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</div><div class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</div><div class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</div></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>状态码的完全列表参见[w3c](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
</code></pre><h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><pre><code>如果状态码是4xx，就应该向用户返回出错信息。
一般来说，返回的信息中将error作为键名，出错信息作为键值即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	error: &quot;Invalid API key&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote>
<p>   针对不同操作，服务器向用户返回的结果应该符合以下规范。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /collection：返回资源对象的列表（数组）</div><div class="line">GET /collection/resource：返回单个资源对象</div><div class="line">POST /collection：返回新生成的资源对象</div><div class="line">PUT /collection/resource：返回完整的资源对象</div><div class="line">PATCH /collection/resource：返回完整的资源对象</div><div class="line">DELETE /collection/resource：返回一个空文档</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>（1）API的身份认证应该使用OAuth 2.0框架。
（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/12/js代码规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/12/js代码规范/" itemprop="url">
                  js代码规范
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T20:56:39+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范/" itemprop="url" rel="index">
                    <span itemprop="name">代码规范</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/12/js代码规范/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/12/js代码规范/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,722
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol>
<li>基本类型：直接存取基本类型。<br>String 字符串<br>Number 数值<br>Boolean 布尔类型<br>null<br>undefined</li>
<li>复制类型：通过引用的方式存取复杂类型。<br>Object 对象<br>Array 数组<br>Function 函数<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2></li>
<li>对不可变的引用使用 const 避免使用 var。<br>  const 声明的变量不可以重新赋值，而 var 可以。</li>
<li>对可变的引用使用 let 避免使用 var。</li>
<li>注意 let 和 const 都是块级作用域。<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li>
<li>使用字面值创建对象。</li>
<li>如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。</li>
<li>使用同义词替换需要使用的保留字。</li>
<li><p>创建有动态属性名的对象时，使用可被计算的属性名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getKey(k) &#123;</div><div class="line">	return `a key named $&#123;k&#125;`;</div><div class="line">&#125;</div><div class="line">const obj = &#123;</div><div class="line">	id: 5,</div><div class="line">	name: &apos;San Francisco&apos;,</div><div class="line">	[getKey(&apos;enabled&apos;)]: true,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>使用对象方法的简写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const atom = &#123;</div><div class="line">  value: 1,</div><div class="line">  // 方法简写</div><div class="line">  addValue(value) &#123;</div><div class="line">	return atom.value + value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>使用对象属性值的简写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const lukeSkywalker = &apos;Luke Skywalker111&apos;;</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">	lukeSkywalker,</div><div class="line">&#125;;</div><div class="line">console.log(obj.lukeSkywalker); // &apos;Luke Skywalker111&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>在对象属性声明前把简写的属性分组（也就是说把简写属性放在一起）。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li>
<li>使用字面值创建数组。</li>
<li><p>向数组添加元素时使用 Arrary#push 替代直接赋值。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	const someStack = [];</div><div class="line"></div><div class="line">	// bad</div><div class="line">	someStack[someStack.length] = &apos;abracadabra&apos;;</div><div class="line"></div><div class="line">	// good</div><div class="line">	someStack.push(&apos;abracadabra&apos;);</div><div class="line">	```	</div><div class="line">3.	使用拓展运算符 ... 复制数组。</div></pre></td></tr></table></figure>
<p>let array = [‘1’,’2’];<br>console.log([…array]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.	使用 Array#from 把一个类数组对象转换成数组。</div></pre></td></tr></table></figure>
<p>const foo = document.querySelectorAll(‘.foo’);<br>const nodes = Array.from(foo);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">##	解构</div><div class="line">1.	使用解构存取和使用多属性对象。</div></pre></td></tr></table></figure>
<p>// good<br>function getFullName(obj) {<br>  const { firstName, lastName } = obj;<br>  return <code>${firstName} ${lastName}</code>;<br>}</p>
<p>// best<br>  function getFullName({ firstName, lastName }) {<br>  return <code>${firstName} ${lastName}</code>;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.	对数组使用解构赋值。</div></pre></td></tr></table></figure>
<p>const arr = [1, 2, 3, 4];<br>const [first, second] = arr;<br>console.log(first, second); // 1, 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.	需要回传多个值时，使用对象解构，而不是数组解构。</div></pre></td></tr></table></figure>
<p>function processInput(input) {<br>  // then a miracle occurs<br>  return { left, right, top, bottom };<br>}</p>
<p>// 调用时只选择需要的数据<br>const { left, right } = processInput(input);</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li>
<li>字符串使用单引号 ‘’。 </li>
<li>字符串超过 80 个字节应该使用字符串连接号换行。\    </li>
<li>过度使用字串连接符号可能会对性能造成影响。可换用 +     </li>
<li>程序化生成字符串时，使用模板字符串代替字符串连接。<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li>
<li>使用函数声明代替函数表达式。    </li>
<li><p>立即调用的函数表达式 (IIFE)    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(() =&gt; &#123;</div><div class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
<li><p>永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。<br>浏览器允许你这么做，但它们的解析表现不一致。<br>可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let test;</div><div class="line">if (currentUser) &#123;</div><div class="line">  test = () =&gt; &#123;</div><div class="line">	console.log(&apos;Yup.&apos;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。</p>
</li>
<li>不要使用 arguments。可以选择 rest 语法 … 替代。</li>
<li><p>直接给函数的参数指定默认值，不要使用一个变化的函数参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function handleThings(opts = &#123;&#125;) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>直接给函数参数赋值时需要避免副作用。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2></li>
<li><p>当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].map((x) =&gt; &#123;</div><div class="line">	return x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。<br>如果不是，那就不要省略。</p>
<h2 id="Classes-和-Constructors"><a href="#Classes-和-Constructors" class="headerlink" title="Classes 和 Constructors"></a>Classes 和 Constructors</h2></li>
<li><p>总是使用 class。避免直接操作 prototype 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// good</div><div class="line">class Queue &#123;</div><div class="line">	constructor(contents = []) &#123;</div><div class="line">	  this._queue = [...contents];</div><div class="line">	&#125;</div><div class="line">	pop() &#123;</div><div class="line">	  const value = this._queue[0];</div><div class="line">	  this._queue.splice(0, 1);</div><div class="line">	  return value;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var demo = new Queue([1, 2, 3]);</div><div class="line">console.log(demo.pop()); // 1</div></pre></td></tr></table></figure>
</li>
<li><p>使用 extends 继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class PeekableQueue extends Queue &#123;</div><div class="line">	constructor (args) &#123;</div><div class="line">		super(args);</div><div class="line">	&#125;</div><div class="line">	peek() &#123;</div><div class="line">		return this._queue[0];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法可以返回 this 来帮助链式调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">	jump() &#123;</div><div class="line">		this.jumping = true;</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	setHeight(height) &#123;</div><div class="line">		this.height = height;</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const luke = new Jedi();</div><div class="line">luke.jump()</div><div class="line">	.setHeight(20);</div></pre></td></tr></table></figure>
</li>
<li><p>可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">	constructor(options = &#123;&#125;) &#123;</div><div class="line">		this.name = options.name || &apos;no name&apos;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	getName() &#123;</div><div class="line">		return this.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	toString() &#123;</div><div class="line">		return `Jedi - $&#123;this.getName()&#125;`;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li><p>总是使用模组 (import/export) 而不是其他非标准模块系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ok</div><div class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line">// best</div><div class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default es6;</div></pre></td></tr></table></figure>
</li>
<li><p>不要使用通配符 import。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">import * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div><div class="line"></div><div class="line">// good</div><div class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>不要从 import 中直接 export。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default es6;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Iterators-amp-Generators"><a href="#Iterators-amp-Generators" class="headerlink" title="Iterators &amp; Generators"></a>Iterators &amp; Generators</h2><ol>
<li>不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const numbers = [1, 2, 3, 4, 5];</div><div class="line"></div><div class="line">// good</div><div class="line">let sum = 0;</div><div class="line">numbers.forEach((num) =&gt; sum += num);</div><div class="line"></div><div class="line">// best (use the functional force)</div><div class="line">const sum = numbers.reduce((total, num) =&gt; total + num, 0);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li>普通属性使用 . 来访问对象的属性。    </li>
<li>当通过变量访问属性时使用中括号 []。<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li>
<li>一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。</li>
<li><p>单独声明每一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const items = getItems();</div><div class="line">const goSportsTeam = true;</div><div class="line">const dragonball = &apos;z&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>将所有的 const 和 let 分组。</p>
</li>
<li>在你需要的地方给变量赋值，但请把它们放在一个合理的位置。<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2></li>
<li>var 声明会被提升至该作用域的顶部，但它们赋值不会提升。<br>let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。</li>
<li>匿名函数表达式的变量名会被提升，但函数内容并不会。</li>
<li>命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。</li>
<li>函数声明的名称和函数体都会被提升。<h2 id="比较运算符-amp-等号"><a href="#比较运算符-amp-等号" class="headerlink" title="比较运算符 &amp; 等号"></a>比较运算符 &amp; 等号</h2></li>
<li>优先使用 === 和 !== 而不是 == 和 !=。</li>
<li>条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则<br>对象 被计算为 true<br>Undefined 被计算为 false<br>Null 被计算为 false<br>布尔值 被计算为 布尔的值<br>数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true<br>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</li>
<li>使用简写。<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2></li>
<li>使用大括号包裹所有的多行代码块。</li>
<li>如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li>
<li>使用 /<em>* … </em>/ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。<br>配合 JSDoc 完美</li>
<li>使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。<br>在注释前插入空行。</li>
<li>给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。<br>这将有别于常见的注释，因为它们是可操作的。<br>使用FIXME – need to figure this out 或者 TODO – need to implement。</li>
<li><p>使用 // FIXME: 标注问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Calculator &#123;</div><div class="line">	constructor() &#123;</div><div class="line">		// FIXME: shouldn&apos;t use a global here</div><div class="line">		total = 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用 // TODO: 标注问题的解决方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Calculator &#123;</div><div class="line">  constructor() &#123;</div><div class="line">	// TODO: total should be configurable by an options param</div><div class="line">	this.total = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ol>
<li>使用 2 个空格作为缩进。</li>
<li>在花括号前放一个空格。</li>
<li>在控制语句（if、while 等）的小括号前放一个空格。<br>在函数调用及声明中，不在函数的参数列表前加空格。</li>
<li>使用空格把运算符隔开。</li>
<li>在文件末尾插入一个空行。</li>
<li>在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。</li>
<li>在块末和新语句前插入空行。<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2></li>
<li>行首不要加逗号。</li>
<li>增加结尾的逗号: 需要。<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2></li>
<li>每个语句都使用分号。</li>
<li>IIFE 函数前添加分号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// good (防止函数在两个 IIFE 合并时被当成一个参数)</div><div class="line">;(() =&gt; &#123;</div><div class="line">  const name = &apos;Skywalker&apos;;</div><div class="line">  return name;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>在语句开始时执行类型转换。</li>
<li>显式转换字符串。<br>const reviewScore = 9;<br>const totalScore = String(reviewScore);</li>
<li><p>对数字使用 parseInt 转换，并带上类型转换的基数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const val = Number(inputValue);</div><div class="line"></div><div class="line">const val = parseInt(inputValue, 10);</div></pre></td></tr></table></figure>
</li>
<li><p>如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</p>
</li>
<li>小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数。<br>位操作处理大于 32 位的整数值时还会导致意料之外的行为。</li>
<li>转换为buer。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const age = 0;</div><div class="line">const hasAge = Boolean(age);</div><div class="line">const hasAge = !!age;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li>避免单字母命名。命名应具备描述性。</li>
<li>使用驼峰式命名对象、函数和实例。</li>
<li>使用帕斯卡（大驼峰）式命名构造函数或类。</li>
<li>使用下划线 _ 开头命名私有属性。</li>
<li><p>别保存 this 的引用。使用箭头函数或 Function#bind。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  return () =&gt; &#123;</div><div class="line">	console.log(this);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	return function() &#123;</div><div class="line">		console.log(this);</div><div class="line">	&#125;.bind(this)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// file contents</div><div class="line">class CheckBox &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">export default CheckBox;</div><div class="line"></div><div class="line">import CheckBox from &apos;./CheckBox&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>当你导出默认的函数时使用驼峰式命名。<br>你的文件名必须和函数名完全保持一致。</p>
</li>
<li>当你导出单例、函数库、空对象时使用帕斯卡式命名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const AirbnbStyleGuide = &#123;</div><div class="line">  es6: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default AirbnbStyleGuide;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><ol>
<li>属性的存取函数不是必须的。    </li>
<li><p>如果你需要存取函数时使用 getVal() 和 setVal(‘hello’)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dragon.getAge();</div><div class="line">dragon.setAge(25);</div></pre></td></tr></table></figure>
</li>
<li><p>如果属性是布尔值，使用 isVal() 或 hasVal()。</p>
</li>
<li>创建 get() 和 set() 函数是可以的，但要保持一致。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">  constructor(options = &#123;&#125;) &#123;</div><div class="line">	const lightsaber = options.lightsaber || &apos;blue&apos;;</div><div class="line">	this.set(&apos;lightsaber&apos;, lightsaber);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set(key, val) &#123;</div><div class="line">	this[key] = val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get(key) &#123;</div><div class="line">	return this[key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol>
<li>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。<br>这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).trigger(&apos;listingUpdated&apos;, &#123; listingId : listing.id &#125;);</div><div class="line"></div><div class="line">$(this).on(&apos;listingUpdated&apos;, function(e, data) &#123;</div><div class="line">  // do something with data.listingId</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><ol>
<li>使用 $ 作为存储 jQuery 对象的变量名前缀。<br>const $sidebar = $(‘.sidebar’);</li>
<li><p>缓存 jQuery 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setSidebar() &#123;</div><div class="line">  const $sidebar = $(&apos;.sidebar&apos;);</div><div class="line">  $sidebar.hide();</div><div class="line"></div><div class="line">  $sidebar.css(&#123;</div><div class="line">	&apos;background-color&apos;: &apos;pink&apos;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对 DOM 查询使用层叠 $(‘.sidebar ul’) 或 父元素 &gt; 子元素 $(‘.sidebar &gt; ul’)。</p>
</li>
<li>对有作用域的 jQuery 对象查询使用 find。<blockquote>
<p>   参考文档：<br><a href="https://www.kancloud.cn/kancloud/javascript-style-guide/43153" target="_blank" rel="external">Airbnb JavaScript 代码规范（ES6）</a><br><a href="https://github.com/airbnb/javascript#airbnb-javascript-style-guide-" target="_blank" rel="external">Airbnb JavaScript Style Guide</a></p>
</blockquote>
</li>
</ol>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/10/深入浅出Node-js-读书笔记（下）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/深入浅出Node-js-读书笔记（下）/" itemprop="url">
                  深入浅出Node.js-读书笔记
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T20:17:16+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJS/" itemprop="url" rel="index">
                    <span itemprop="name">NodeJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/10/深入浅出Node-js-读书笔记（下）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/10/深入浅出Node-js-读书笔记（下）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3,395
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><pre><code>常见的需求：
</code></pre><ol>
<li>请求方法的判断（保存在报文）<br>常见的方法有：GET(查看)\POST(更新)\DELETE(删除)\PUT(新建)\CONNECT\HEAD<br>通过req.method 来判断</li>
<li>URL的路径解析（保存在报文）<br><a href="http://localhost:8080/a.html" target="_blank" rel="external">http://localhost:8080/a.html</a><br>通过req.url 来查找</li>
<li>URL中查询字符串解析（保存在报文）<br>?foo=bar&amp;baz=val<br>使用Node提供的querystring 模块处理</li>
<li>Cookie的解析（保存在报文）<br>网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>http 为无状态协议。<br>数据保存在客户端。</li>
<li>Session（会话）的需求（保存在报文）<br>数据保存在服务器端。<br>1.基于Cookie 来实现用户和数据的映射。<br>  原理：在客户端只保存口令，发送请求是通过该口令再去查找对应的数据<br>2.通过查询字符串来实现浏览器端和服务器端数据的对应。<br>  不推荐使用，风险大。<br>两种存储方式：<br>1.内存<br>2.数据工具<br>  Redis是一个支持网络、基于内存、可选持久性的键值对存储数据库。</li>
<li>Basic认证（保存在报文）<br>当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</li>
<li>数据上传<br>思路：先判断数据的格式，再通过对应的解析方法解析。<br>1.表单数据的解析<br>先判断req.headers[‘content-type’] === ‘application/x-www-formurlencoded’<br>  querystring.parse(req.rawBody);<br>2.其他格式<br>  json – application/json<br>  xml – application/xml</li>
<li><p>任意格式文件的上传处理<br>此时需要<form action="/upload" method="post" enctype="multipart/form-data"></form></p>
</li>
<li><p>缓存<br>YSlow中提出的缓存规则：<br>1.添加Expires 和 Cache-Control 到报文头中。<br>2.配置ETags。<br>3.让Ajax 可缓存。<br>数据上传与安全<br>1.内存限制（提交数据占用了所有内存）<br>  限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。<br>  通过流式解析，将数据导向到磁盘中，Node只保留文件路径等小数据。<br>2.CSRF<br>  Cross-Site Request Forgery（跨站点请求伪造）</p>
</li>
</ol>
<h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><pre><code>文件路径型
    静态文件：URL 的路径与网站目录的路径一致，无须转换。
    动态文件：在 MVC 模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，
        它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。
MVC
    MVC 模型的主要思想是将业务逻辑按职责分离。
        控制器（Controller），一组行为的集合。
        模型（Model），数据相关的操作和封装。
        视图（View），视图的渲染。
        1.路由解析，根据URL寻找到对应的控制器和行为。
        2.行为调用相关的模型，进行数据操作。
        3.数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。
    路由映射
    1.手工映射
        正则匹配
        参数解析
    2.自然映射
RESTful        
    REST Representational State Transfer （表现层状态转化）        
    POST /user/fanerge 修改用户信息
    DELETE /user/fanerge 删除用户
    PUT /user/fanerge 新建用户        
    GET /user/fanerge 查询用户信息    
    请求方法    
</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre><code>作用：middleware 来简化和隔离这些基础设施与业务逻辑之间的细节，使开发者更加关注在业务的开发。    
</code></pre><p><img src="/images/middleware.png" alt="中间件工作原理"><br>    中间件设计格式（connect的设计）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var querystring = function (req, res, next) &#123;</div><div class="line">	// TODO</div><div class="line">	next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>使用中间件（串联多个中间件）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.use(&apos;/user/:username&apos;, querystring, cookie, session, function (req, res) &#123;</div><div class="line">	// 这里处理具体的业务逻辑</div><div class="line">&#125;);</div></pre></td></tr></table></figure>


异常处理
    同步异常 -- try {} catch (err) {throw err} 
    异步异常
        需要把异常传递出来
        domain 模块    
</code></pre><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><pre><code>内容响应
    Content-Encoding: gzip
    Content-Length: 21170
    Content-Type: text/javascript; charset=utf-8
    MIME : Multipurpose Internet Mail Extensions    
    附件下载：有些MIME类的资源不需要在客户端中打开它，只需要弹出并下载它即可。
        Content-Disposition: inline(查看)/attachment(附件下载);
        例如：Content-Disposition: attachment; filename=&apos;filename.ext&apos;; // 下载附件并为其命名
    响应JSON
    响应跳转    
视图渲染
模板
    如EJS、Pug等
    模板引擎
        语法分解。
        处理表达式。
        生成待执行的语句。
        与数据一起执行，生成最终字符串。
    with的应用    
        模板安全 XSS 解决方案 转义用户的输入
    模板逻辑
    集成文件系统    
    子模板    
    布局视图    
    模板性能
Bigpipe
    BigPipe是一个重新设计的基础动态网页服务体系。
    前端加载技术，它的提出主要是为了解决重数据页面的加载问题。
    Bigpipe 的解决思路则是将页面分割成多个部分（pagelet），
    先向用户输出没有数据（框架），将每个部分逐步输出到前端，
    再最终渲染填充框架，完成整个网页的渲染。
    这个过程中需要前端js的参与，它负责将后续输出的数据渲染到页面上。
    1.页面布局框架（无数据的）。
    2.后端持续性的数据输出。
    3.前端渲染。
        bigpipe.ready() -- 以一个key注册一个事件。
        bigpipe.set() -- 触发一个事件，进行页面渲染。
</code></pre><h2 id="玩转进程"><a href="#玩转进程" class="headerlink" title="玩转进程"></a>玩转进程</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><pre><code>child_process 模块
创建子进程
    1.spawn(): 启动一个子进程来执行命令。
    2.exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，
    它有一个回调函数获知子进程的状况。
    3.execFile(): 启动一个子进程来执行可执行文件。
    4.fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的Javascript文件模块即可。
    spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，
    一旦创建的进程运行超过设定的时间将会被杀死。
    exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。
进程间通信
    message事件 绑定发送事件
    send()方法 触发发送消息
句柄传递
    child_process.send(message, [sendHandle]);
    句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。
    比如句柄可以用来标识一个服务器端socket对象、客户端socket对象、UDP套接字、一个管道等。
</code></pre><h3 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h3><pre><code>进程事件
    message
    error
    exit
    close
    disconnect
自动重启
    自杀信号
    负载均衡（轮叫调度）    
        由主进程接受链接，将其依次分发给工作进程。
        cluster 模块
    状态共享
        第三方数据存储 通过轮询
        主动通知 当数据更新时，主动通知子进程。
</code></pre><h3 id="Cluster-模块"><a href="#Cluster-模块" class="headerlink" title="Cluster 模块"></a>Cluster 模块</h3><pre><code>解决多核CPU的利用率问题。
Cluster 工作原理
    该模块是 child_process 和 net 模块的组合应用。
Cluster 事件
    fork
    online
    listening
    disconnect
    exit
    setup
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>测试驱动开发
</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code>测试代码编写的原则
1.单一职责
2.接口抽象
3.层次分离
单元测试介绍
1.断言
    assert 模块
    单元测试中用来保证最小单元是否正常的检测方法。
    用于检查程序在运行时是否满足期望。
    ok(): 判断结果是否为真。
    equal(): 判断实际值余期望值是否相等。
    notEqual(): 判断实际值与期望值是否不相等。
    deepEqual(): 判断实际值余期望值是否深度相等（对象和数组的元素是否相等）。
    notDeepEqual(): 判断实际值与期望值是否不深度相等。
    strictEqual(): 判断实际值与期望值是否严格相等（===）。
    notStrictEqual(): 判断实际值与期望值是否不严格相等（!==）。
    throws(): 判断代码块是否抛出异常。
    doesNotThrow(): 判断代码块是否没有抛出异常。
    ifError(): 判断实际值是否为一个假值（null、undefined、0、&apos;&apos;、false），若实际值为真值，将抛出异常。
2.测试框架
    用于管理测试用例和生成测试报告。
    mocha 模块
    测试风格
        TDD 测试驱动开发
        BDD 行为驱动开发
    测试报告
        mocha --reporters
    测试代码的文件组织
    测试用例
    异步测试
    测试覆盖率
    mock 或者 muk
    私有方法的测试
        var lib = rewire(&apos;../lib/index.js&apos;); // 需要测试方法所在的文件
        var litmit = lib.__get__(&apos;limit&apos;); // 需要测试的方法
3.工程化与自动化    
    工程化 -- Makefile
    持续集成 -- travis-ci
</code></pre><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><pre><code>负载测试、压力测试和基准测试。
基准测试：（对基本的方法如Array.protoryp.map 和 for循环的比较）
    benchmark 模块
压力测试：（网络接口进行压力测试）
    常用的工具：ab、siege、http_load
基准测试驱动开发
    1.写基准测试
    2.写/改代码
    3.收集数据
    4.找出问题
    5.回到第（2）步
测试数据余业务数据的转换
    PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。
    UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。
    TPS 是每秒内的事务数，比如执行了dml操作，那么相应的tps会增加；
    QPS 是指每秒内查询次数，比如执行了select操作，相应的qps会增加。
    QPS = PV/H (H为访问量集中的时间单位小时)。
</code></pre><h2 id="产品化"><a href="#产品化" class="headerlink" title="产品化"></a>产品化</h2><pre><code>包括：工程化、架构、容灾备份、部署和运维。
</code></pre><h3 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a>项目工程化</h3><pre><code>1.目录结构
    Web框架：Express、Koa、Egg
2.构建工具
    合并静态文件、压缩文件大小、打包应用、编译模块。
    Makefile 
        一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，
        makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，
        哪些文件需要重新编译，甚至于进行更复杂的功能操作，
        因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。
    Grunt
3.编码规范
    JSLint JSHint ESLint
4.代码审查
</code></pre><h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><pre><code>部署环境
部署操作    
</code></pre><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><pre><code>动静分离
    静态请求用 Nginx 和 CDN 来保存
启用缓存
    Redis 和 Memcached
多进程架构    
    读写分离
</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code>访问日志
异常日志
日志与数据库
分割日志
</code></pre><h3 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h3><pre><code>业务逻辑型监控 和 硬件型监控
监控    
    日志监控
    响应时间
    进程监控
    磁盘监控
    内存监控
    CPU占用监控
    CPU load监控
    I/O负载
    网络监控
    应用状态监控
    DNS 监控 -- 免费DNS监控服务 DNSPod
    报警的实现
        邮件报警 -- nodemailer 模块
        短信或电话报警 

监控系统的稳定性
</code></pre><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><pre><code>多机器
多机房
容灾备份
</code></pre><h3 id="异构共存"><a href="#异构共存" class="headerlink" title="异构共存"></a>异构共存</h3><h2 id="调试Node"><a href="#调试Node" class="headerlink" title="调试Node"></a>调试Node</h2><pre><code>Debugger
    1.在代码中插入 debugger
    2.运行 node debug demo.js
Node Inspector
    1.安装 npm install -g node-inspector
    2.错误堆栈
</code></pre><h2 id="Node-编码规范"><a href="#Node-编码规范" class="headerlink" title="Node 编码规范"></a>Node 编码规范</h2><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><pre><code>1.空格与格式 -- 采用2个空格缩进，而不是tab缩进。
2.变量声明 -- 每个变量声明都应该带var。
3.空格 -- 操作符前后加空格，如+、-、*、%、/、=等
4.单双引号的问题 -- 只在html标签的属性中使用双引号，其余使用单引号。
    但在JSON中，严格的规范是要求使用字符串使用双引号，内容中出现双引号时需要转义。
5.大括号的位置 -- 不需要另起一行
6.逗号 -- 若逗号不在行结尾，前面需要一个空格。
7.分号 -- 给表达式结尾添加分号。    
</code></pre><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><pre><code>1.变量命名 -- 小驼峰式命名。
2.方法命名 -- 小驼峰式命名，尽量采用动词或判断词汇。
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var getUser = () =&gt; &#123;&#125;;</div><div class="line">var isAdmin = () =&gt; &#123;&#125;;</div></pre></td></tr></table></figure>

3.类命名（构造函数和Class） -- 大驼峰式命名。
4.常量命名 -- 全大写字母和下划线。    
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var PINK_COLOR = &apos;pink&apos;;</div></pre></td></tr></table></figure>


5.文件命名 -- 全小写字母和下划线。
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">child_process.js // 普通文件</div><div class="line">_linklist.js // 私有文件</div></pre></td></tr></table></figure>

6.包名 -- 不要包含 js 或 node 的字样，它们是重复的。
</code></pre><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><pre><code>1.使用 === 替代 ==
2.当遇到 0、undefined、null、false、&apos;&apos;假值时，不需要使用 === 或 ==。    
</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code>尽量使用 {}、[]，不要使用 new Object() 和 new Array()    
</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><pre><code>1.慎用with
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with (obj) &#123;</div><div class="line">	foo = bar;</div><div class="line">&#125;</div><div class="line">// 出现4中结果：obj.foo = obj.bar; obj.foo = bar; foo = obj.bar; foo = bar;</div></pre></td></tr></table></figure>

2.慎用eval()
</code></pre><h3 id="数组与对象"><a href="#数组与对象" class="headerlink" title="数组与对象"></a>数组与对象</h3><pre><code>1.字面量格式 -- 结尾用逗号分隔，若分行，一行只能一个元素。
2.for in 循环 -- 只能对对象使用，不能对数组使用。
    for in语句以任意顺序遍历一个对象的可枚举属性（包括原型上的属性）。
3.不要把数组当对象使用    
</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><pre><code>1.异步回调函数的第一个参数应该是错误指示    
2.执行传入的回调函数    
</code></pre><h3 id="类与模块"><a href="#类与模块" class="headerlink" title="类与模块"></a>类与模块</h3><pre><code>1.类继承（Node推荐的类继承方式）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Socket (options) &#123;</div><div class="line">	stream.Stream.call(this);</div><div class="line">&#125;</div><div class="line">util.inherits(Socket, stream.Stream);</div></pre></td></tr></table></figure>

2.导出 -- 所有供外部调用的方法或变量均需要挂载在exports变量上。
    当需要将文件当做一个类导出时，需要通过如下方式挂载。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module.exports = Class;</div></pre></td></tr></table></figure>
</code></pre><h3 id="注解规范"><a href="#注解规范" class="headerlink" title="注解规范"></a>注解规范</h3><pre><code>采用 JSDoc
</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><pre><code>1.冲突的解决原则 -- 入乡随俗
2.给编辑器设置检测工具    
3.版本控制中的hook    
4.持续集成
</code></pre><h2 id="搭建局域NPM仓库"><a href="#搭建局域NPM仓库" class="headerlink" title="搭建局域NPM仓库"></a>搭建局域NPM仓库</h2><blockquote>
<p>参考文档<br>    <a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="external">朴灵-深入浅出Node</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/10/Object的扩展、密密封、冻结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/Object的扩展、密密封、冻结/" itemprop="url">
                  Object的扩展、密密封、冻结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T19:56:38+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/10/Object的扩展、密密封、冻结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/10/Object的扩展、密密封、冻结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  816
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h2><pre><code>Object.isExtensible(obj)
    判断一个对象是可扩展(是否能有新的属性添加到它)。
Object.preventExtensions(obj)
    可以对对象的属性进行修改和删除，不能向自身添加属性但可以向其原型添加属性。
示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Object.create(proto[, propertiesObject]);</div><div class="line">var obj = &#123;</div><div class="line">	a: 1,</div><div class="line">	b: 2</div><div class="line">&#125;;</div><div class="line">console.log(Object.isExtensible(obj)); // true</div><div class="line">Object.preventExtensions(obj);</div><div class="line">console.log(Object.isExtensible(obj)); // false</div><div class="line">// obj.a = 3; // 可以修改原有属性</div><div class="line">// delete obj.a; // 可以删除原有属性</div><div class="line">// obj.c = 3; // 不能自身添加属性		</div><div class="line">console.log(obj);</div></pre></td></tr></table></figure>
</code></pre><h2 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h2><pre><code>Object.isSealed()
    判断一个对象是密封的。
Object.seal()
    密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。
    属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性。
    将所有现有的属性标记为不可配置。现在的属性的值仍然可以改变,只要它们是可写的。
示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  prop: function() &#123;&#125;,</div><div class="line">  foo: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line">var o = Object.seal(obj);</div><div class="line">console.log(o === obj); // true</div><div class="line">Object.isSealed(obj); // === true</div><div class="line"></div><div class="line">obj.foo = &apos;quux&apos;; // 可以改变属性</div><div class="line"></div><div class="line">// 不能改变属性访问器，会抛出错误</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</div><div class="line">  get: function() &#123; return &apos;g&apos;; &#125;</div><div class="line">&#125;); // throws a TypeError</div><div class="line"></div><div class="line">// 不能添加新属性</div><div class="line">obj.quaxxor = &apos;the friendly duck&apos;;</div><div class="line"></div><div class="line">// 不能删除原有属性</div><div class="line">delete obj.foo;</div><div class="line"></div><div class="line">// 可以更改属性，只要它是可写的</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</div><div class="line">  value: &apos;eit&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h2 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h2><pre><code>Object.isFrozen()
Object.freeze()
    防止新的属性被添加到它;防止现有的属性被移除;
    和防止现有的属性,或他们的可数性,可配置性,或可写性,被改变了,它还可以防止原型被改变了。
    该方法返回对象处于冻结状态。
示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  prop: function() &#123;&#125;,</div><div class="line">  foo: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回已被冻结的对象</div><div class="line">var o = Object.freeze(obj);</div><div class="line"></div><div class="line">// o === obj; // true</div><div class="line">Object.isFrozen(obj); // === true</div><div class="line"></div><div class="line">// 改变原有属性失败</div><div class="line">obj.foo = &apos;quux&apos;; // silently does nothing</div><div class="line">// 添加属性失败</div><div class="line">obj.quaxxor = &apos;the friendly duck&apos;;</div><div class="line">// 删除原有属性失败</div><div class="line">delete obj.foo; // throws a TypeError</div><div class="line">console.log(obj);</div><div class="line"></div><div class="line">// 重新配置原有属性失败</div><div class="line">Object.defineProperty(obj, &apos;ohai&apos;, &#123; value: 17 &#125;);</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;eit&apos; &#125;);</div><div class="line"></div><div class="line">// 向原型中添加属性失败</div><div class="line">Object.setPrototypeOf(obj, &#123; x: 20 &#125;)</div><div class="line">obj.__proto__ = &#123; x: 20 &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="浅冻结与深冻结"><a href="#浅冻结与深冻结" class="headerlink" title="浅冻结与深冻结"></a>浅冻结与深冻结</h2><pre><code>如该方法 MDN 的描述所述，倘若一个对象的属性是一个对象，
那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结，
若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">	obj = &#123;</div><div class="line">		internal :&#123;&#125;</div><div class="line">	&#125;;</div><div class="line">	Object.freeze(obj);//浅冻结</div><div class="line">	obj.internal.a = &quot;aValue&quot;;</div><div class="line">	console.log(obj.internal.a);//&quot;aValue&quot;</div><div class="line"></div><div class="line">	//想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数.</div><div class="line">	function deepFreeze(o)&#123;</div><div class="line">		var prop,propKey;</div><div class="line">		Object.freeze(o);//首先冻结第一层对象</div><div class="line">		for(propKey in o)&#123;</div><div class="line">			prop = o[propKey];</div><div class="line">			if(!o.hasOwnProperty(propKey) || !(typeof prop === &quot;object&quot;) || Object.isFrozen(prop))&#123;</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">			deepFreeze(prop);//递归</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">		</div><div class="line">	deepFreeze(obj);</div><div class="line">	obj.internal.b = &quot;bValue&quot;;//静默失败</div><div class="line">	console.log(obj.internal.b);//undefined</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000003894119" target="_blank" rel="external">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br>    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="external">MDN</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/09/深入浅出Node-js-读书笔记（上）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/09/深入浅出Node-js-读书笔记（上）/" itemprop="url">
                  深入浅出Node.js-读书笔记
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-09T20:09:51+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJS/" itemprop="url" rel="index">
                    <span itemprop="name">NodeJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/09/深入浅出Node-js-读书笔记（上）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/09/深入浅出Node-js-读书笔记（上）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,254
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。</p>
<h2 id="Node-js-基础知识"><a href="#Node-js-基础知识" class="headerlink" title="Node.js 基础知识"></a>Node.js 基础知识</h2><h3 id="chrome-与-Node-工作原理"><a href="#chrome-与-Node-工作原理" class="headerlink" title="chrome 与 Node 工作原理"></a>chrome 与 Node 工作原理</h3><pre><code>chrome：HTML + JavaScript + WebKit + V8 &gt;&gt; 中间层 &gt;&gt; 网卡 + 硬盘 + 显卡 + ...
Node：JavaScript + V8 &gt;&gt; 中间层（libuv）&gt;&gt; 网卡 + 硬盘 + 显卡 + ...
说明：libuv 是 Node 的新跨平台抽象层，用于抽象 Windows 的 IOCP 及 Unix 的 libev。
    作者打算在这个库的包含所有平台的差异性。
</code></pre><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.get(&apos;url&apos;, (data) =&gt; &#123;</div><div class="line">	console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

异步是并行的基础。
单线程，不适合大量计算占用 CPU 导致无法继续调用异步I/O。
</code></pre><h2 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h2><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><pre><code>模块引用：
    var math = require(&apos;math&apos;);    
模块定义：
    exports.add = () =&gt; {
        var a = 1,
            b = 3;
        return a + b;
    }
exports 是 module 的属性。
Node 引入模块的步骤：
    路径分析
    文件定位
    编译执行
</code></pre><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><pre><code>文件模块 &gt;&gt; 核心模块（JavaScript） &gt;&gt; 内建模块（C/C++）
</code></pre><h2 id="异步I-O-1"><a href="#异步I-O-1" class="headerlink" title="异步I/O"></a>异步I/O</h2><h3 id="Node-的异步I-O"><a href="#Node-的异步I-O" class="headerlink" title="Node 的异步I/O"></a>Node 的异步I/O</h3><pre><code>Node 自身的执行模型 -- 事件循环。
单线程、事件循环、观察者和I/O线程池
</code></pre><h3 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h3><pre><code>定时器：setTimeout()\setInterval()
process.nextTick()
    在事件循环的下一次循环中调用 callback 回调函数。
    效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；
    与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。
setImmediate()
    nextTick()的回调函数执行的优先级要高于setImmediate();    
    process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,
    I/O观察者先于check观察者.
</code></pre><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>高阶函数：以函数作为参数或返回值。
偏函数用法：通过指定部分参数来产生一个新的定制函数的形式就是偏函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const isType = function (type)&#123;</div><div class="line">	return function (obj) &#123;</div><div class="line">		return Object.prototype.toString.call(obj) == &apos;[object &apos; + type + &apos;]&apos;;</div><div class="line">	&#125;; </div><div class="line">&#125;</div><div class="line">var isString = isType(&apos;String&apos;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h3><pre><code>事件发布/订阅模式（事件绑定）
promise
generator
async-await
</code></pre><h3 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h3><pre><code>eventproxy
[async](https://github.com/caolan/async)
</code></pre><h2 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h2><h2 id="理解Buffer"><a href="#理解Buffer" class="headerlink" title="理解Buffer"></a>理解Buffer</h2><pre><code>Buffer 是一个像Array的对象，但它主要用于操作字节。
Buffer 对象
    var buf = new Buffer(&apos;string&apos;, &apos;utf-8&apos;);
</code></pre><h3 id="Buffer-的转换"><a href="#Buffer-的转换" class="headerlink" title="Buffer 的转换"></a>Buffer 的转换</h3><pre><code>    支持的字符串编码类型：
    ASCII\UTF-8\UTF-16LE/UCS-2\Base64\Binary\Hex
字符串转 Buffer    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var buf = new Buffer(str, [encoding]);</div><div class="line">buf.write(string, [offset], [length], [encoding]);</div></pre></td></tr></table></figure>

Buffer 转字符串
buf.toString([encoding], [start], [end]);
</code></pre><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>TCP 和 UDP 属于网络传输层协议，HTTP 属于应用层协议。
</code></pre><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><pre><code>创建TCP 服务器端 net 模块
TCP 服务的事件
</code></pre><h3 id="构建UDP-服务（用户数据包协议）"><a href="#构建UDP-服务（用户数据包协议）" class="headerlink" title="构建UDP 服务（用户数据包协议）"></a>构建UDP 服务（用户数据包协议）</h3><pre><code>创建UDP套接字 dgram模块
创建UDP 服务器端
创建UDP 客户端
UDP 套接字事件
</code></pre><h3 id="构建HTTP-服务"><a href="#构建HTTP-服务" class="headerlink" title="构建HTTP 服务"></a>构建HTTP 服务</h3><pre><code>HTTP 超文本传输协议。
http 模块
HTTP 客户端
</code></pre><h3 id="构建WebSocket-服务"><a href="#构建WebSocket-服务" class="headerlink" title="构建WebSocket 服务"></a>构建WebSocket 服务</h3><pre><code>以前的方案：Comet（彗星）技术细节为：长轮询（long-polling）或iframe流（streaming）。
长轮询原理：客户端向服务器断发送请求，服务端只在超时或有数据响应时断开连接（res.end()），
    客户端在接收到数据或者超时后重新发送请求。
iframe流原理：iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，
    然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。
    通过iframe里的内容进行长时间的请求，当需要传输内容时通过调用父页面js方法来实现页面展示，以此达到comet所需要的效果。
WebSocket原理：WebSocket是一种在单个TCP连接上进行全双工通讯的协议。
    WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，
    浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
</code></pre><h3 id="网络服务与安全"><a href="#网络服务与安全" class="headerlink" title="网络服务与安全"></a>网络服务与安全</h3><pre><code>Node在网络安全上提供了3个模块
</code></pre><ol>
<li>crypto – 主要用于加密和解密，SHA1、MD5。</li>
<li>tls – 类似于net模块，它是建立在TLS/SSL加密的TCP连接上。</li>
<li>https – 类似于http模块，他它是建立于安全的连接之上。<br>TLS/SSL<br>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构。<br>每个服务器断和客户端都有自己的公私钥。<br>公钥要来加密要传输的数据，私钥用来解密接收到的数据。<br>Node在底层采用的是openssl实现TLS/SSL。<br>数字证书：CA（Certificate Authority，数字证书认证中心）<br>HTTPS服务<br>HTTPS服务就是工作在TLS/SSL上的HTTP。<blockquote>
<p>参考文档<br><a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="external">朴灵-深入浅出Node</a></p>
</blockquote>
</li>
</ol>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">81</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<!--<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共104.0k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="150" height="300" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: -30px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/nito/nietzche.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
