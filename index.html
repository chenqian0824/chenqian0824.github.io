<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/26/常用dos命令总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/26/常用dos命令总结/" itemprop="url">
                  常用dos命令总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-26T20:39:57+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂项/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/26/常用dos命令总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/26/常用dos命令总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3,766
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是DOS命令"><a href="#什么是DOS命令" class="headerlink" title="什么是DOS命令"></a>什么是DOS命令</h1><p>DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h2><h3 id="md-mkdir"><a href="#md-mkdir" class="headerlink" title="md/mkdir"></a>md/mkdir</h3><p>作用：创建一个子目录（make directory）。<br>语法：md[C:][path]〈subPath〉</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>作用：改变或显示当前目录（change directory）。<br>语法：cd [C:][path]<br>PS：路径可以使用绝对路径和相对路径两种。<br>    cd\ 表示退回到根目录。<br>    cd.. 表示退回到上级目录。<br>    如果只有cd而没有参数，则只显示当前路径。<br>    注意：子目录中一定有两个“特殊目录”，即“.”“..”，其中一点表示当前目录，两点表示上一层目录。<br>    从简单实用的角度来看，我们只要学会逐层进入（cd 下一层某目录名），和逐层退出（cd..）就可以解决所有问题。</p>
<h3 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h3><p>作用：删除空子目录（remove directory）。<br>语法：rd [c:][path]<br>PS：rd是专门删除空子目录的命令。<br>    del 删除文件命令。<br>    注意两条：一是不能删除非空目录；二是不能删除当前目录。     </p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>作用：主要用来显示一个目录下的文件和子目录。(directory)<br>语法：dir [C:][path][filename][/o][/s][/p][/w][/a]<br>PS：斜杠表示后面的内容是参数。<br>    /p 显示信息满一屏时，暂停显示，按任意键后显示下一屏<br>    /o 排序显示。o后面可以接不同意义的字母<br>    /w 只显示文件名目录名，每行五个文件名。即宽行显示<br>    /s 将目录及子目录的全部目录文件都显示<br>    /a 显示隐藏文件</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>作用：设备可执行文件的搜索路径，只对文件有效。<br>语法：path[盘符1：][路径1][盘符2：][路径2]…<br>PS：当运行一个可执行文件时，dos会先在当前目录中搜索该文件，若找到则运行之；若找不到该文件，则根据path命令所设置的路径，顺序逐条地到目录中搜索该文件</p>
<h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>作用：显示指定驱动器上所有目录路径和这些目录下的所有文件名。<br>语法：tree [盘符：][/f][&gt;prn]</p>
<h3 id="deltree"><a href="#deltree" class="headerlink" title="deltree"></a>deltree</h3><p>作用：删除目录树。<br>语法：DELTREE [C1:][path1]<br>PS：这个命令将整个指定目录树全部消灭，而不管它是否是只读、隐藏与否。使用应特别小心。它是一个危险命令。</p>
<h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p>作用：将整个计算机的进程显示出来，同任务管理器。<br>语法：tasklist</p>
<h2 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>作用：磁盘格式化。<br>语法：format〈盘符：〉[/s][/4][/q]    </p>
<h3 id="unformat"><a href="#unformat" class="headerlink" title="unformat"></a>unformat</h3><p>作用：对进行过格式化误操作丢失数据的磁盘进行恢复。<br>语法：unformat〈盘符〉[/l][/u][/p][/test]    </p>
<h3 id="chkdsk"><a href="#chkdsk" class="headerlink" title="chkdsk"></a>chkdsk</h3><p>作用：显示磁盘状态、内存状态和指定路径下指定文件的不连续数目。<br>语法：chkdsk [盘符：][路径][文件名][/f][/v]<br>PS：PS：例如要检查A盘使用情况，就输入chkdsk　A: ，检查c盘使用情况，就输入chkdsk　C: ，如果直接输入chkdsk，就检查当前磁盘的使用情况。    </p>
<h3 id="diskcopy"><a href="#diskcopy" class="headerlink" title="diskcopy　"></a>diskcopy　</h3><p>作用：复制格式和内容完全相同的软盘。<br>语法：diskcopy[盘符1：][盘符2：]</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>作用：建立、更改、删除磁盘卷标。<br>语法：label[盘符：][卷标名]    </p>
<h3 id="vol"><a href="#vol" class="headerlink" title="vol"></a>vol</h3><p>作用：查看磁盘卷标号。<br>语法：vol[盘符：]</p>
<h3 id="scandisk"><a href="#scandisk" class="headerlink" title="scandisk"></a>scandisk</h3><p>作用：检测磁盘的fat表、目录结构、文件系统等是否有问题，并可将检测出的问题加以修复。<br>语法：scandisk[盘符1：]{[盘符2：]…}[/all]</p>
<h3 id="defrag"><a href="#defrag" class="headerlink" title="defrag"></a>defrag</h3><p>作用：整理磁盘，消除磁盘碎块。<br>语法：defrag[盘符：][/f]<br>PS：选用/f参数，将文件中存在盘上的碎片消除，并调整磁盘文件的安排，确保文件之间毫无空隙。从而加快读盘速度和节省磁盘空间。</p>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>作用：将当前驱动器上的dos系统文件io.sys,msdos.sys和command 传送到指定的驱动器上。<br>语法：sys[盘符：]    </p>
<h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>作用：拷贝一个或多个文件到指定盘上。<br>语法：copy [源盘][路径]（源文件名） [目标盘][路径](目标文件名）</p>
<h3 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h3><p>作用：复制指定的目录和目录下的所有文件连同目录结构。<br>语法：xcopy [源盘：]〈源路径名〉[目标盘符：][目标路径名][/s][/v][/e]<br>PS：xcopy是copy的扩展，可以把指定的目录连文件和目录结构一并拷贝，但不能拷贝隐藏文件和系统文件。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>作用：显示ascii码文件的内容。<br>语法：type [C:][path][filename.ext]<br>PS：type命令用来在屏幕上快速、简便地显示文本文件的内容，扩展名为TXT的文件是文本文件。    </p>
<h3 id="ren"><a href="#ren" class="headerlink" title="ren"></a>ren</h3><p>作用：对指定磁盘、目录中的一个文件或一组文件更改名称（rename）。<br>语法：ren[盘符：][路径]〈旧文件名〉〈新文件名〉<br>PS：改名操作只限于某个文件某组文件的名称，它不会更改文件所在的目录。    </p>
<h3 id="fc"><a href="#fc" class="headerlink" title="fc"></a>fc</h3><p>作用：比较文件的异同，并列出差异处。<br>语法：fc[盘符：][路径名]〈文件名〉[盘符：][路径名][文件名][/a][/c][/n]</p>
<h3 id="attrib"><a href="#attrib" class="headerlink" title="attrib"></a>attrib</h3><p>作用：修改指定文件的属性。<br>语法：attrib[文件名][r][—r][a][—a][h][—h][—s]</p>
<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>作用：删除指定的文件。<br>语法：del[盘符：][路径]〈文件名〉[/p]    </p>
<h3 id="undelete"><a href="#undelete" class="headerlink" title="undelete"></a>undelete</h3><p>作用：恢复被误删除文件。<br>语法：undelete[盘符：][路径名]〈文件名〉[/dos][/list][/all]    </p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol>
<li>cls——清屏幕命令    </li>
<li>ver查看系统版本号命令    </li>
<li>date日期设置命令<br>date[mm——dd——yy]</li>
<li>time系统时钟设置命令<br>time[hh：mm：ss：xx]</li>
<li>mem显示系统的硬件和操作系统的状况。<br>mem[/c][/f][/m][/p]</li>
<li>msg显示系统的硬件和操作系统的状况。<br>msg[/s]</li>
</ol>
<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><h3 id="Ping命令的独特用法"><a href="#Ping命令的独特用法" class="headerlink" title="Ping命令的独特用法"></a>Ping命令的独特用法</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：ping +空格+“IP地址或者域名” [-t][-l][-n]<br>PS：-t：不停的Ping对方的机器，直到用户按Ctrl＋C键终止。因为如果想用Ping命令测试网络传输质量，至少要查看Ping命令三分钟到五分钟的结果。<br>    -l：定义echo数据包大小。我们可以将数据包的大小定义在极限值附近，以此可以测试出网络传输质量的优劣，尤其是测试外网的传输质量，非常明显。<br>    -n：在默认情况下，Ping命令一般都会发送四个数据包，通过这个命令可以自己定义发送的个数，对测试网络传输质量很有帮助。我们结合实例说明一下如何通过Ping命令的测试结果判断网络传输质量。</p>
<h3 id="tracert命令的使用技巧"><a href="#tracert命令的使用技巧" class="headerlink" title="tracert命令的使用技巧"></a>tracert命令的使用技巧</h3><p>作用：tracert命令可以测试路由器的工作是否正常（部分网站无法访问）。<br>    我们根据返回的结果来判断，哪一个环节的网络出现了问题。<br>语法：tracert +空格+“IP地址或者域名”</p>
<h3 id="用netstat命令判断是否被攻击"><a href="#用netstat命令判断是否被攻击" class="headerlink" title="用netstat命令判断是否被攻击"></a>用netstat命令判断是否被攻击</h3><p>作用：netstat命令可以查看单位的网络是否被攻击。<br>语法：netstat [-a][-n][-b]<br>PS：-a：显示所有连接和监听端口<br>　　-n：以数字形式显示地址和端口号<br>　　-b：显示包含于创建每个连接或监听端口的可执行组件。另外，使用该参数之后，还可以显示占用TCP协议端口的一些程序名称</p>
<h3 id="巧用ARP命令防范ARP病毒"><a href="#巧用ARP命令防范ARP病毒" class="headerlink" title="巧用ARP命令防范ARP病毒"></a>巧用ARP命令防范ARP病毒</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：arp -s ip地址 MAC</p>
<h3 id="灵活使用ipconfig命令"><a href="#灵活使用ipconfig命令" class="headerlink" title="灵活使用ipconfig命令"></a>灵活使用ipconfig命令</h3><p>作用：ipconfig这个命令查看计算机当前的网络配置信息。<br>ps：Ipconfig /all：完全显示计算机的网络信息，IP地址、MAC地址及其他相关的信息，都可以显示出来。<br>　　Ipconfig /release：释放计算机当前获得的IP地址。对于使用动态IP地址的单位来说，如果发现机器无法上网，而计算机从DHCP服务器处获得的IP地址等相关信息不完全，可以将该地址释放。<br>　　Ipconfig /renew：从DHCP服务器重新获得IP地址。释放了IP地址及相关信息之后，必须重新获得一个IP地址，直接输入此命令之后，便可以从DHCP服务器处获得一个IP地址。如果不用此命令，要想重新获得一个IP地址信息，需要重新启动计算机或注销计算机才行。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>net 系列</li>
<li>tlist -t 以树行列表显示进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li>
<li>kill -f 进程名 加-f参数后强制结束某进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li>
</ol>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>shutdown.exe -a　取消关机<br>shutdown.exe -s 关机<br>shutdown.exe -f　强行关闭应用程序。<br>shutdown.exe -m \计算机名　控制远程计算机。<br>shutdown.exe -i　显示图形用户界面，但必须是Shutdown的第一个参数。<br>shutdown.exe -l　注销当前用户。<br>shutdown.exe -r　关机并重启。<br>shutdown.exe -t时间　设置关机倒计时。<br>shutdown.exe -c”消息内容”　输入关机对话框中的消息内容（不能超127个字符）。<br>示例：<br>    电脑要在24:00关机 – at 24:00 Shutdown -s<br>    倒计时的方式关机 – Shutdown.exe -s -t 7200</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h3><p>作用：该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，使用这个命令你可以得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等。在此我们就有必要了解几个基本的参数。<br>PS：-a 使用这个参数，只要你知道了远程主机的机器名称，就可以得到它的NETBIOS信息（下同）。<br>    -A 这个参数也可以得到远程主机的NETBIOS信息，但需要你知道它的IP。<br>    -n 列出本地机器的NETBIOS信息。</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>作用：这是一个用来查看网络状态的命令，操作简便功能强大。<br>PS：-a 查看本地机器的所有开放端口，可以有效发现和预防木马，可以知道机器所开的服务等信息<br>    这里可以看出本地机器开放有FTP服务、Telnet服务、邮件服务、WEB服务等。用法：netstat -a IP。<br>    -r 列出当前的路由信息，告诉我们本地机器的网关、子网掩码等信息。用法：netstat -r IP。</p>
<h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>作用：跟踪路由信息，使用此命令可以查出数据从本地机器传输到目标主机所经过的所有途径，这对我们了解网络布局和结构很有帮助。</p>
<h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><p>作用：这个命令是网络命令中最重要的一个，必须透彻掌握它的每一个子命令的用法，因为它的功能实在是太强大了在这里，我们重点掌握几个常用的子命令。</p>
<ol>
<li>net view<br>使用此命令查看远程主机的所有共享资源。命令格式为net view \IP。</li>
<li>net use<br>把远程主机的某个共享资源影射为本地盘符，图形界面方便使用。命令格式为net use x: \IP\sharename。</li>
<li>net start<br>使用它来启动远程主机上的服务。用法：net start servername</li>
<li>net stop<br>入侵后发现远程主机的某个服务碍手碍脚，怎么办？利用这个命令停掉就ok了，用法和net start同。</li>
<li>net user<br>查看和帐户有关的情况，包括新建帐户、删除帐户、查看特定帐户、激活帐户、帐户禁用等。<br>1，net user abcd 1234 /add，新建一个用户名为abcd，密码为1234的帐户，默认为user组成员。<br>2，net user abcd /del，将用户名为abcd的用户删除。<br>3，net user abcd /active:no，将用户名为abcd的用户禁用。<br>4，net user abcd /active:yes，激活用户名为abcd的用户。<br>5，net user abcd，查看用户名为abcd的用户的情况</li>
<li>net localgroup　<br>查看所有和用户组有关的信息和进行相关操作。</li>
<li>net time<br>这个命令可以查看远程主机当前的时间。</li>
</ol>
<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>作用：这个命令的作用是安排在特定日期或时间执行某个特定的命令和程序。<br>    用法：at time command \computer    </p>
<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>作用：首先在命令行键入ftp回车，出现ftp的提示符，这时候可以键入“help”来查看帮助（任何DOS命令都可以使用此方法查看其帮助）。<br>    1.ftp<br>    2.open 主机IP ftp端口<br>    3.录入用户名和密码，就可以进行相应操作了。<br>    dir 跟DOS命令一样，用于查看服务器的文件，直接敲上dir回车，就可以看到此ftp服务器上的文件。<br>    cd 进入某个文件夹。<br>    get 下载文件到本地机器。<br>    put 上传文件到远程服务器。这就要看远程ftp服务器是否给了你可写的权限了，如果可以，呵呵，该怎么 利用就不多说了，大家就自由发挥去吧。<br>    delete 删除远程ftp服务器上的文件。这也必须保证你有可写的权限。<br>    bye 退出当前连接。<br>    quit 同上。</p>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>作用：功能强大的远程登陆命令，几乎所有的入侵者都喜欢用它，屡试不爽。为什么？它操作简单，如同使用自己的机器一样，只要你熟悉DOS命令，在成功以administrator身份连接了远程机器后，就可以用它来**想干的一切了。下面介绍一下使用方法，首先键入telnet回车，再键入help查看其帮助信息。    </p>
<h1 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h1><ol>
<li>向上箭头”↑”和向下箭头”↓”—–回看上一次执行的命令        </li>
<li>“Ctrl+C” 组合键或”Break”键 —–中断操作        </li>
<li>鼠标操作”标记” —————–用来选中文本        </li>
<li>鼠标操作”粘贴” —————–用来把剪贴板内容粘贴到提示符下        </li>
</ol>
<h2 id="程序进程"><a href="#程序进程" class="headerlink" title="程序进程"></a>程序进程</h2><p>作用：ntsd 是一条dos命令，功能是用于结束一些常规下结束不了的死进程。<br>使用：<br>    1.利用进程的PID结束进程<br>        命令格式：ntsd -c q -p pid<br>        命令范例：ntsd -c q -p 1332 （结束explorer.exe进程）<br>    2.利用进程名结束进程<br>        命令格式：ntsd -c q -pn <strong><em>.exe （</em></strong>.exe 为进程名，exe不能省）<br>        命令范例：ntsd -c q -pn explorer.exe<br>    3.taskkill结束进程<br>        命令格式：taskkill /pid 1234 /f （ 也可以达到同样的效果）</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.jb51.net/article/30526.htm" target="_blank" rel="external">20种常用的DOS命令小结</a><br>    <a href="http://www.360doc.com/content/10/0712/19/1822972_38550278.shtml" target="_blank" rel="external">DOS中的PING命令的几种用法</a><br>    <a href="https://baike.baidu.com/item/DOS%E5%91%BD%E4%BB%A4/5143255?fr=aladdin#7" target="_blank" rel="external">百度文库-dos命令</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/26/JavaScript数据结构与算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/26/JavaScript数据结构与算法/" itemprop="url">
                  JavaScript数据结构与算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-26T20:33:32+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/26/JavaScript数据结构与算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/26/JavaScript数据结构与算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  5,295
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  23
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组及矩阵（二维数组）和多维数组（a-b-均为数组）"><a href="#数组及矩阵（二维数组）和多维数组（a-b-均为数组）" class="headerlink" title="数组及矩阵（二维数组）和多维数组（a, b 均为数组）"></a>数组及矩阵（二维数组）和多维数组（a, b 均为数组）</h1><p>最好使用数组存储一系列同一种数据类型的值（与其它语言保持一致）。<br>数组的有点：可以直接访问数组的某一项（相对于链表）。<br>数组的缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管我们已经学过的JavaScript的 Array 类方法可以帮我们做这些事，但背后的情况同样是这样）。</p>
<h2 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h2><h3 id="模拟栈数据结构"><a href="#模拟栈数据结构" class="headerlink" title="模拟栈数据结构"></a>模拟栈数据结构</h3><p>a.pop()  删除数组的最后一个元素并返回删除的元素。<br>a.push(item1, item2, …, itemX)  向数组的末尾添加一个或更多元素，并返回新的长度。</p>
<h3 id="模拟队列数据结构"><a href="#模拟队列数据结构" class="headerlink" title="模拟队列数据结构"></a>模拟队列数据结构</h3><p>a.shift()  删除并返回数组的第一个元素。<br>a.unshift(item1,item2, …, itemX)  可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<h3 id="排序相关方法"><a href="#排序相关方法" class="headerlink" title="排序相关方法"></a>排序相关方法</h3><p>a.sort(sortfunction)  方法用于对数组的元素进行排序。<br>a.reverse()  用于颠倒数组中元素的顺序。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>a.splice(index,howmany,item1,…..,itemX)  用于插入、删除或替换数组的元素。<br>    参数说明：1.规定从何处添加/删除元素。2.删除多少元素。3.插入的项目。<br>    这里返回类型为数组!!!<br>a.copyWithin(target, start, end)  从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>    参数说明：1.复制到指定目标索引位置。2,3为复制的起始和结束位置。<br>a.fill(value, start, end)  将一个固定值替换数组的元素。<br>PS：删除元素的方法，返回被删除的元素。<br>    添加元素的方法，返回数组长度。</p>
<h2 id="不操作原数组方法"><a href="#不操作原数组方法" class="headerlink" title="不操作原数组方法"></a>不操作原数组方法</h2><h3 id="返回Boolean值的方法"><a href="#返回Boolean值的方法" class="headerlink" title="返回Boolean值的方法"></a>返回Boolean值的方法</h3><p>a.every(function(currentValue,index,arr), thisValue)  检测数值元素的每个元素是否都符合条件。<br>a.some(function(currentValue,index,arr),thisValue)  用于检测数组中的元素是否满足指定条件（函数提供）。<br>a.includes(item) 判断该数组是否存在该项目。</p>
<h3 id="返回新数组的方法"><a href="#返回新数组的方法" class="headerlink" title="返回新数组的方法"></a>返回新数组的方法</h3><p>a.concat(b)  连接两个或更多的数组，并返回连接后的数组。<br>a.filter(function(currentValue,index,arr), thisValue)  创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>a.slice(start, end)  可从已有的数组中返回选定的元素。<br>a.map(function(currentValue,index,arr), thisValue)   返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
<h3 id="返回数组中的某项索引值"><a href="#返回数组中的某项索引值" class="headerlink" title="返回数组中的某项索引值"></a>返回数组中的某项索引值</h3><p>a.findIndex(function(currentValue, index, arr), thisValue)  返回符合传入测试（函数）条件的数组元素索引。<br>a.indexOf(item,start)  返回某个指定的字符串值在字符串中首次出现的位置。<br>a.lastIndexOf(item,start)   返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p>
<h3 id="返回数组中的某项值"><a href="#返回数组中的某项值" class="headerlink" title="返回数组中的某项值"></a>返回数组中的某项值</h3><p>a.find(function(currentValue, index, arr),thisValue)  返回传入一个测试条件（函数）符合条件的数组第一个元素。</p>
<h3 id="输出为字符串的方法"><a href="#输出为字符串的方法" class="headerlink" title="输出为字符串的方法"></a>输出为字符串的方法</h3><p>a.join(separator)  用于把数组中的所有元素通过分隔符转换一个字符串。<br>a.toString()  返回已逗号分割元素的字符串。</p>
<h3 id="其它对数组进行操作"><a href="#其它对数组进行操作" class="headerlink" title="其它对数组进行操作"></a>其它对数组进行操作</h3><p>a.forEach(function(currentValue, index, arr), thisValue)  array.forEach(function(currentValue, index, arr), thisValue)<br>a.reduce(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从左到右）。<br>a.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从右到左）。<br><a href="http://www.runoob.com/jsref/jsref-obj-array.html" target="_blank" rel="external">Array方法参考手册</a></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈，一种具有特殊行为的数组，具有后进先出（LIFO）原则的有序集合。<br>    （数组头部）栈底[]栈顶（数组尾部部）</p>
<h2 id="栈应该具有大方法"><a href="#栈应该具有大方法" class="headerlink" title="栈应该具有大方法"></a>栈应该具有大方法</h2><p>push(element(s)) ：添加一个（或几个）新元素到栈顶。<br>pop() ：移除栈顶的元素，同时返回被移除的元素。<br>peek() ：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。<br>isEmpty() ：如果栈里没有任何元素就返回 true ，否则返回 false 。<br>clear() ：移除栈里的所有元素。<br>size() ：返回栈里的元素个数。这个方法和数组的 length 属性很类似。</p>
<h2 id="构建栈及相应的方法"><a href="#构建栈及相应的方法" class="headerlink" title="构建栈及相应的方法"></a>构建栈及相应的方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">function Stack() &#123;</div><div class="line"></div><div class="line">	// 使用数组来模拟栈</div><div class="line">	let items = [];</div><div class="line">	</div><div class="line">	// push方法</div><div class="line">	this.push = function(element)&#123;</div><div class="line">		items.push(element);</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// pop方法</div><div class="line">	this.pop = function()&#123;</div><div class="line">		return items.pop();</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// peek方法</div><div class="line">	this.peek = function()&#123;</div><div class="line">		return items[items.length-1];</div><div class="line">		// return items.slice().pop();</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// isEmpty方法</div><div class="line">	this.isEmpty = function()&#123;</div><div class="line">		return items.length === 0;</div><div class="line">	&#125;;	</div><div class="line">	</div><div class="line">	// size方法</div><div class="line">	this.size = function()&#123;</div><div class="line">		return items.length;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// clear方法</div><div class="line">	this.clear = function()&#123;</div><div class="line">		items = [];</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// print调试方法</div><div class="line">	this.print = function()&#123;</div><div class="line">		console.log(items.toString());</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">let stack1 = new Stack();</div><div class="line">stack1.print(); // &apos;&apos;</div><div class="line">stack1.push(1);</div><div class="line">stack1.print(); // &apos;1&apos;</div><div class="line">stack1.clear();  </div><div class="line">stack1.print(); // &apos;&apos;</div></pre></td></tr></table></figure>
</code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function divideBy2(decNumber)&#123;</div><div class="line">	let remStack = new Stack(),</div><div class="line">		rem,</div><div class="line">		binaryString = &apos;&apos;;</div><div class="line">		</div><div class="line">	while (decNumber &gt; 0)&#123; //&#123;1&#125;</div><div class="line">		rem = Math.floor(decNumber % 2); //&#123;2&#125;</div><div class="line">		remStack.push(rem); //&#123;3&#125;</div><div class="line">		decNumber = Math.floor(decNumber / 2); //&#123;4&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	while (!remStack.isEmpty())&#123; //&#123;5&#125;</div><div class="line">		binaryString += remStack.pop().toString();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return binaryString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。</p>
<h2 id="队列需要的方法"><a href="#队列需要的方法" class="headerlink" title="队列需要的方法"></a>队列需要的方法</h2><p>enqueue(element(s)) ：向队列尾部添加一个（或多个）新的项。<br>dequeue() ：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。<br>front() ：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。<br>isEmpty() ：如果队列中不包含任何元素，返回 true ，否则返回 false 。<br>size() ：返回队列包含的元素个数，与数组的 length 属性类似。</p>
<h2 id="构建队列"><a href="#构建队列" class="headerlink" title="构建队列"></a>构建队列</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function Queue() &#123;</div><div class="line">	</div><div class="line">	// 保存数据</div><div class="line">	let items = [];</div><div class="line">	</div><div class="line">	// enqueue方法</div><div class="line">	this.enqueue = function(element)&#123;</div><div class="line">		items.push(element);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	// dequeue 方法</div><div class="line">	this.dequeue = function()&#123;</div><div class="line">		return items.shift();</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	// front 方法</div><div class="line">	this.front = function()&#123;</div><div class="line">		return items[0];</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	// isEmpty 方法</div><div class="line">	this.isEmpty = function()&#123;</div><div class="line">		return items.length === 0;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// size方法</div><div class="line">	this.size = function()&#123;</div><div class="line">		return items.length;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// print 调试方法</div><div class="line">	this.print = function()&#123;</div><div class="line">		console.log(items.toString());</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="可以设置优先级的队列"><a href="#可以设置优先级的队列" class="headerlink" title="可以设置优先级的队列"></a>可以设置优先级的队列</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function PriorityQueue() &#123;</div><div class="line">	let items = [];</div><div class="line">	</div><div class="line">	function QueueElement (element, priority)&#123; // &#123;1&#125;</div><div class="line">		this.element = element;</div><div class="line">		this.priority = priority;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	this.enqueue = function(element, priority)&#123;</div><div class="line">		var queueElement = new QueueElement(element, priority);</div><div class="line">		</div><div class="line">		if (this.isEmpty())&#123;</div><div class="line">			items.push(queueElement); // &#123;2&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			var added = false;</div><div class="line">			</div><div class="line">			for (var i=0; i&lt;items.length; i++)&#123;</div><div class="line">				if (queueElement.priority &lt; items[i].priority)&#123;</div><div class="line">					items.splice(i,0,queueElement); // &#123;3&#125;</div><div class="line">					added = true;</div><div class="line">					break; // &#123;4&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			if (!added)&#123; //&#123;5&#125;</div><div class="line">				items.push(queueElement);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	//其他方法和默认的Queue实现相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码var priorityQueue = new PriorityQueue();</div><div class="line">priorityQueue.enqueue(&quot;John&quot;, 2);</div><div class="line">priorityQueue.enqueue(&quot;Jack&quot;, 1);</div><div class="line">priorityQueue.enqueue(&quot;Camila&quot;, 1);</div><div class="line">priorityQueue.print(); // Jack, Camila, John</div></pre></td></tr></table></figure>
</code></pre><h2 id="循环队列–击鼓传花"><a href="#循环队列–击鼓传花" class="headerlink" title="循环队列–击鼓传花"></a>循环队列–击鼓传花</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function hotPotato (nameList, num)&#123;</div><div class="line">	var queue = new Queue(); // &#123;1&#125;</div><div class="line">	</div><div class="line">	for (var i=0; i&lt;nameList.length; i++)&#123;</div><div class="line">		queue.enqueue(nameList[i]); // &#123;2&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	var eliminated = &apos;&apos;;</div><div class="line">	</div><div class="line">	while (queue.size() &gt; 1)&#123;</div><div class="line">		for (var i=0; i&lt;num; i++)&#123;</div><div class="line">			queue.enqueue(queue.dequeue()); // &#123;3&#125;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		eliminated = queue.dequeue();// &#123;4&#125;</div><div class="line">		console.log(eliminated + &apos;在击鼓传花游戏中被淘汰。&apos;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return queue.dequeue();// &#123;5&#125;</div><div class="line">&#125;</div><div class="line">var names = [&apos;John&apos;,&apos;Jack&apos;,&apos;Camila&apos;,&apos;Ingrid&apos;,&apos;Carl&apos;];</div><div class="line">var winner = hotPotato(names, 7);</div><div class="line">console.log(&apos;胜利者：&apos; + winner);</div></pre></td></tr></table></figure>
</code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。<br>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。<br>然而，链表需要使用指针，因此实现链表时需要额外注意。<br>数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。<br>链表的优点：相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。<br>链表的缺点：数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p>
<h2 id="创建一个链表"><a href="#创建一个链表" class="headerlink" title="创建一个链表"></a>创建一个链表</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">function LinkedList() &#123;</div><div class="line">	</div><div class="line">	// 表示要加入列表的项</div><div class="line">	let Node = function(element)&#123; // &#123;1&#125;</div><div class="line">		this.element = element; // 填加到列表的值</div><div class="line">		this.next = null; // 列表中下一个节点项的引用</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	let length = 0; // &#123;2&#125;</div><div class="line">	</div><div class="line">	// 用于存在第一个节点的引用</div><div class="line">	let head = null; </div><div class="line">	</div><div class="line">	// 取得链表首元素</div><div class="line">	this.getHead = function()&#123;</div><div class="line">		return head;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 向列表尾部添加一个新的项</div><div class="line">	this.append = function(element)&#123;</div><div class="line">		let node = new Node(element);</div><div class="line">		current;</div><div class="line">		</div><div class="line">		if (head === null) &#123; // 列表中第一节点</div><div class="line">			head = node;</div><div class="line">		&#125; else &#123;</div><div class="line">			current = head; </div><div class="line">			</div><div class="line">			// 循环列表，直到找到最后一项</div><div class="line">			wihle(current.next)&#123;</div><div class="line">				current = current.next;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			// 找到最后一项，将其next赋值为node，建立链接</div><div class="line">			current.next = node;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		length++; // 链表长度加1</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 向列表的特定位置插入一个新的项</div><div class="line">	this.insert = function(position, element)&#123;</div><div class="line">	</div><div class="line">		//检查越界值</div><div class="line">		if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; //&#123;1&#125;</div><div class="line">			var node = new Node(element),</div><div class="line">				current = head,</div><div class="line">				previous,</div><div class="line">				index = 0;</div><div class="line">				</div><div class="line">			if (position === 0)&#123; //在第一个位置添加</div><div class="line">				node.next = current; //&#123;2&#125;</div><div class="line">				head = node;</div><div class="line">			&#125; else &#123;</div><div class="line">			</div><div class="line">				while (index++ &lt; position)&#123; //&#123;3&#125;</div><div class="line">					previous = current;</div><div class="line">					current = current.next;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				node.next = current; //&#123;4&#125;</div><div class="line">				previous.next = node; //&#123;5&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			length++; //更新列表的长度</div><div class="line">			return true;</div><div class="line">		&#125; else &#123;</div><div class="line">			return false; //&#123;6&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 从列表的特定位置移除一项</div><div class="line">	this.removeAt = function(position)&#123;</div><div class="line">		//检查越界值</div><div class="line">		if (position &gt; -1 &amp;&amp; position &lt; length)&#123; // &#123;1&#125;</div><div class="line">			var current = head, // &#123;2&#125;</div><div class="line">			previous, // &#123;3&#125;</div><div class="line">			index = 0; // &#123;4&#125;</div><div class="line">			</div><div class="line">			//移除第一项</div><div class="line">			if (position === 0)&#123; // &#123;5&#125;</div><div class="line">				head = current.next;</div><div class="line">			&#125; else &#123;</div><div class="line">				while (index++ &lt; position)&#123; // &#123;6&#125;</div><div class="line">					previous = current; // &#123;7&#125;</div><div class="line">					current = current.next; // &#123;8&#125;</div><div class="line">				&#125;</div><div class="line">			</div><div class="line">				//将previous与current的下一项链接起来：跳过current，从而移除它</div><div class="line">				previous.next = current.next; // &#123;9&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			length--; // &#123;10&#125;</div><div class="line">			return current.element;</div><div class="line">		&#125; else &#123;</div><div class="line">			return null; // &#123;11&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 从列表中移除一项</div><div class="line">	this.remove = function(element)&#123;</div><div class="line">		var index = this.indexOf(element);</div><div class="line">		return this.removeAt(index);</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 返回元素在列表中的索引</div><div class="line">	this.indexOf = function(element)&#123;</div><div class="line">		var current = head, //&#123;1&#125;</div><div class="line">			index = -1;</div><div class="line">		while (current) &#123; //&#123;2&#125;</div><div class="line">			if (element === current.element) &#123;</div><div class="line">				return index; //&#123;3&#125;</div><div class="line">			&#125;</div><div class="line">			index++; //&#123;4&#125;</div><div class="line">			current = current.next; //&#123;5&#125;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 如果链表中不包含任何元素，返回 true ，如果链表长度大于0则返回 false</div><div class="line">	this.isEmpty = function() &#123;</div><div class="line">		return length === 0;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 返回链表包含的元素个数。与数组的 length 属性类似</div><div class="line">	this.size = function() &#123;</div><div class="line">		return length;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 由于列表项使用了 Node 类，就需要重写继承自JavaScript对象默认的toString 方法，让其只输出元素的值</div><div class="line">	this.toString = function()&#123;</div><div class="line">		var current = head, //&#123;1&#125;</div><div class="line">		string = &apos;&apos;; //&#123;2&#125;</div><div class="line">		</div><div class="line">		while (current) &#123; //&#123;3&#125;</div><div class="line">			string = current.element; //&#123;4&#125;</div><div class="line">			current = current.next; //&#123;5&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return string; //&#123;6&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 调试方法</div><div class="line">	this.print = function()&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表的特点：双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。<br>当我们访问链表项时，在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">function  DoublyLinkedList()&#123;</div><div class="line">	var Node = function(element)&#123;</div><div class="line">		this.element = element;</div><div class="line">		this.next = null;</div><div class="line">		this.prev = null; //新增的</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	var length = 0;</div><div class="line">	var head = null;</div><div class="line">	var tail = null; //新增的</div><div class="line">	</div><div class="line">	this.insert = function(position, element)&#123;</div><div class="line">		//检查越界值</div><div class="line">		if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123;</div><div class="line">			var node = new Node(element),</div><div class="line">				current = head,</div><div class="line">				previous,</div><div class="line">				index = 0;</div><div class="line">			if (position === 0)&#123; //在第一个位置添加</div><div class="line">				if (!head)&#123; //新增的 &#123;1&#125;</div><div class="line">					head = node;</div><div class="line">					tail = node;</div><div class="line">				&#125; else &#123;</div><div class="line">					node.next = current;</div><div class="line">					current.prev = node; //新增的 &#123;2&#125;</div><div class="line">					head = node;</div><div class="line">				&#125;</div><div class="line">			&#125; else if (position === length) &#123; //最后一项 //新增的</div><div class="line">				current = tail; // &#123;3&#125;</div><div class="line">				current.next = node;</div><div class="line">				node.prev = current;</div><div class="line">				tail = node;</div><div class="line">			&#125; else &#123;</div><div class="line">				while (index++ &lt; position)&#123; //&#123;4&#125;</div><div class="line">				previous = current;</div><div class="line">				current = current.next;</div><div class="line">			&#125;</div><div class="line">			node.next = current; //&#123;5&#125;</div><div class="line">			previous.next = node;</div><div class="line">			current.prev = node; //新增的</div><div class="line">			node.prev = previous; //新增的</div><div class="line">			&#125;</div><div class="line">			length++; //更新列表的长度</div><div class="line">			return true;</div><div class="line">		&#125; else &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.removeAt = function(position)&#123;</div><div class="line">		//检查越界值</div><div class="line">		if (position &gt; -1 &amp;&amp; position &lt; length)&#123;</div><div class="line">			var current = head,</div><div class="line">				previous,</div><div class="line">				index = 0;</div><div class="line">			//移除第一项</div><div class="line">			if (position === 0)&#123;</div><div class="line">				head = current.next; // &#123;1&#125;</div><div class="line">				//如果只有一项，更新tail //新增的</div><div class="line">				if (length === 1)&#123; // &#123;2&#125;</div><div class="line">					tail = null;</div><div class="line">				&#125; else &#123;</div><div class="line">					head.prev = null; // &#123;3&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; else if (position === length-1)&#123; //最后一项 //新增的</div><div class="line">				current = tail; // &#123;4&#125;</div><div class="line">				tail = current.prev;</div><div class="line">				tail.next = null;</div><div class="line">			&#125; else &#123;</div><div class="line">				while (index++ &lt; position)&#123; // &#123;5&#125;</div><div class="line">					previous = current;</div><div class="line">					current = current.next;</div><div class="line">				&#125;</div><div class="line">				//将previous与current的下一项链接起来——跳过current</div><div class="line">				previous.next = current.next; // &#123;6&#125;</div><div class="line">				current.next.prev = previous; //新增的</div><div class="line">			&#125;</div><div class="line">			length--;</div><div class="line">			return current.element;</div><div class="line">		&#125; else &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单向循环链表的特点：循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用 null ，而是指向第一个元素（ head ）。<br>双向循环链表有指向 head 元素的 tail.next ，和指向 tail 元素的 head.prev 。</p>
<h1 id="集合（es6的Set）"><a href="#集合（es6的Set）" class="headerlink" title="集合（es6的Set）"></a>集合（es6的Set）</h1><p>集合的定义：集合是由一组无序且唯一（即不能重复）的项组成的。<br>集合的操作：集合也有并集、交集、差集等基本操作。</p>
<h2 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Set()&#123;</div><div class="line">	let items = &#123;&#125;; // js对象不允许两个不同的属性，保证集合元素的唯一性</div><div class="line"></div><div class="line">	this.has = function(value)&#123;</div><div class="line">		// 区别 in可以查找原型链而 hasOwnProperty方法只会查找自身</div><div class="line">		// return value in items;</div><div class="line">		return items.hasOwnProperty(value);</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.add = function(value)&#123;</div><div class="line">		if (!this.has(value)) &#123;</div><div class="line">			items[value] = value;</div><div class="line">			return ture;</div><div class="line">		&#125;</div><div class="line">		return false;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	this.remove = function(value)&#123;</div><div class="line">		if (this.has(value)) &#123;</div><div class="line">			delete items[value];</div><div class="line">			return ture;</div><div class="line">		&#125;</div><div class="line">		return false;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.clear = function()&#123;</div><div class="line">		items = &#123;&#125;;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.size = function()&#123;</div><div class="line">		return Object.keys(items).length;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	this.values = function()&#123;</div><div class="line">		return Object.keys(items);</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。<br>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。<br>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。<br>子集：验证一个给定集合是否是另一集合的子集。<br>一下假设A、B为两个集合。</p>
<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>运算公式：A∪B = { x | x ∈ A∨x ∈ B }<br>为Set类的union方法<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 思路先将原集合和新集合循环添加到并集合中</div><div class="line">this.union = function(otherSet)&#123;</div><div class="line">	let unionSet = new Set();</div><div class="line">	let values = this.values();</div><div class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">		unionSet.add(values[i]);</div><div class="line">	&#125;</div><div class="line">	values = otherSet.values();</div><div class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">		unionSet.add(values[i]);</div><div class="line">	&#125;</div><div class="line">	return unionSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>运算公式：A∩B = { x | x ∈ A∧x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.intersection = function(otherSet)&#123;</div><div class="line">	let intersectionSet = new Set();</div><div class="line">	let values = this.values();</div><div class="line">	</div><div class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">		if (otherSet.has(values[i])) &#123;</div><div class="line">			intersectionSet.add(values[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return intersectionSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>计算公式：AB = { x | x ∈ A ∧ x   B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.difference = function(otherSet)&#123;</div><div class="line">	let differenceSet = new Set();</div><div class="line">	let values = this.values();</div><div class="line">	</div><div class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">		if (!otherSet.has(values[i])) &#123;</div><div class="line">			differenceSet.add(values[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return differenceSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>运算公式：∀x { x ∈ A → x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">this.subset = function(otherSet)&#123;</div><div class="line">	if (this.size() &gt; otherSet.size()) &#123;</div><div class="line">		return false;</div><div class="line">	&#125; else &#123;</div><div class="line">		values = this.values();</div><div class="line">		for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">			if (!otherSet.has(values[i])) &#123;</div><div class="line">				return false;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="字典（映射es6的Map）"><a href="#字典（映射es6的Map）" class="headerlink" title="字典（映射es6的Map）"></a>字典（映射es6的Map）</h1><p>字典和散列表是用来存储唯一值（不重复的值）的数据结构。<br>两者都是[键，值]的形式来存储数据    </p>
<h2 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">function  Dictionary()&#123;</div><div class="line">	let items = &#123;&#125;;</div><div class="line">	</div><div class="line">	this.has = function(key)&#123;</div><div class="line">		return key in items;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.set = function(key, value)&#123;</div><div class="line">		items[key] = value;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.remove = function(key)&#123;</div><div class="line">		if (this.has(key)) &#123;</div><div class="line">			delete items[key];</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		return false;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.get = function(key)&#123;</div><div class="line">		return this.has(key) ? items[key] : undefined;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.values = function()&#123;</div><div class="line">		let values = &#123;&#125;;</div><div class="line">		for (let k in items) &#123;</div><div class="line">			if (this.has(k)) &#123;</div><div class="line">				values.push(items[k]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return values;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.clear = function()&#123;</div><div class="line">		items = &#123;&#125;;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.getItems = function()&#123;</div><div class="line">		return items;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列算法的作用是尽可能快地在数据结构中找到一个值。<br>使用散列函数，就知道值的具体位置，因此能够快速检索到该值。<br>散列函数的作用是给定一个键值，然后返回值在表中的地址。</p>
<h2 id="创建一个散列表"><a href="#创建一个散列表" class="headerlink" title="创建一个散列表"></a>创建一个散列表</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function HashTable()&#123;</div><div class="line">	var table = [];</div><div class="line">	// 私有方法-散列函数</div><div class="line">	let loseloseHashCode = function(key)&#123;</div><div class="line">		let hash = 0;</div><div class="line">		for (let i = 0; i &lt; key.length; i++) &#123;</div><div class="line">			hash += key.charCodeAt(i);</div><div class="line">		&#125;</div><div class="line">		return hash % 37;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.put = function(key, value)&#123;</div><div class="line">		let position = loseloseHashCode(key);</div><div class="line">		console.log(position + &apos; - &apos; + key); //&#123;6&#125;</div><div class="line">		table[position] = value;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	this.get = function(key)&#123;</div><div class="line">		return table[loseloseHashCode(key)];</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.remove = function(key)&#123;</div><div class="line">		table[loseloseHashCode(key)] = undefined;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="处理散列表的冲突（同名的地址覆盖）"><a href="#处理散列表的冲突（同名的地址覆盖）" class="headerlink" title="处理散列表的冲突（同名的地址覆盖）"></a>处理散列表的冲突（同名的地址覆盖）</h2><p>可以通过分离链接、线性探查和双散列法来解决冲突。</p>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>定义：包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>为了实现一个使用了分离链接的 HashTable 实例，我们需要一个新的辅助类来表示将要加入LinkedList 实例的元素。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">let ValuePair = function(key, value)&#123;</div><div class="line">	this.key = key;</div><div class="line">	this.value = value;</div><div class="line">	this.toString = function() &#123;</div><div class="line">		return &apos;[&apos; + this.key + &apos; - &apos; + this.value + &apos;]&apos;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.put = function(key, value)&#123;</div><div class="line">	let position = loseloseHashCode(key);</div><div class="line">	if (table[position] == undefined) &#123;</div><div class="line">		table[position] = new LinkedList();</div><div class="line">	&#125;</div><div class="line">	table[position].append(new ValuePair(key, value));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">	let position = loseloseHashCode(key);</div><div class="line">	</div><div class="line">	if (table[position] !== undefined) &#123;</div><div class="line">		// 遍历链表来寻找键/值</div><div class="line">		let current = table[position].getHead();</div><div class="line">		while (current.next) &#123;</div><div class="line">			if (current.elment.key === key) &#123;</div><div class="line">				return current.element.value;</div><div class="line">			&#125;</div><div class="line">			current = current.next;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		// 检查元素在链表第一个或最后一个节点的情况</div><div class="line">		if (current.element.key === key)&#123; //&#123;9&#125;</div><div class="line">			return current.element.value;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return undefined;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">	var position = loseloseHashCode(key);</div><div class="line">	if (table[position] !== undefined)&#123;</div><div class="line">		var current = table[position].getHead();</div><div class="line">		while(current.next)&#123;</div><div class="line">			if (current.element.key === key)&#123; //&#123;11&#125;</div><div class="line">				table[position].remove(current.element); //&#123;12&#125;</div><div class="line">				if (table[position].isEmpty())&#123; //&#123;13&#125;</div><div class="line">					table[position] = undefined; //&#123;14&#125;</div><div class="line">				&#125;</div><div class="line">				return true; //&#123;15&#125;</div><div class="line">			&#125;</div><div class="line">			current = current.next;</div><div class="line">		&#125;</div><div class="line">		// 检查是否为第一个或最后一个元素</div><div class="line">		if (current.element.key === key)&#123; //&#123;16&#125;</div><div class="line">			table[position].remove(current.element);</div><div class="line">			if (table[position].isEmpty())&#123;</div><div class="line">				table[position] = undefined;</div><div class="line">			&#125;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return false; //&#123;17&#125;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">this.put = function(key, value)&#123;</div><div class="line">	var position = loseloseHashCode(key); // &#123;1&#125;</div><div class="line">	if (table[position] == undefined) &#123; // &#123;2&#125;</div><div class="line">		table[position] = new ValuePair(key, value); // &#123;3&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		var index = ++position; // &#123;4&#125;</div><div class="line">		while (table[index] != undefined)&#123; // &#123;5&#125;</div><div class="line">			index++; // &#123;6&#125;</div><div class="line">		&#125;</div><div class="line">		table[index] = new ValuePair(key, value); // &#123;7&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key) &#123;</div><div class="line">	var position = loseloseHashCode(key);</div><div class="line">	if (table[position] !== undefined)&#123; //&#123;8&#125;</div><div class="line">		if (table[position].key === key) &#123; //&#123;9&#125;</div><div class="line">			return table[position].value; //&#123;10&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			var index = ++position;</div><div class="line">			while (table[index] === undefined || table[index].key !== key)&#123; //&#123;11&#125;</div><div class="line">				index++;</div><div class="line">			&#125;</div><div class="line">			if (table[index].key === key) &#123; //&#123;12&#125;</div><div class="line">				return table[index].value; //&#123;13&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return undefined; //&#123;14&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="创建更好的散列函数"><a href="#创建更好的散列函数" class="headerlink" title="创建更好的散列函数"></a>创建更好的散列函数</h3><p>比较好的散列函数，不会产生太多的冲突。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var djb2HashCode = function (key) &#123;</div><div class="line">	var hash = 5381; //&#123;1&#125;</div><div class="line">	for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125;</div><div class="line">		hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125;</div><div class="line">	&#125;</div><div class="line">	return hash % 1013; //&#123;4&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树，它对于存储需要快速查找的数据非常有用。<br>树是一种分层数据的抽象模型。</p>
<h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p>位于树顶部的节点叫作根节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。<br>有关树的另一个术语是子树。子树由节点和它的后代构成。<br>树的高度取决于所有节点深度的最大值。</p>
<h2 id="二叉树和二叉搜索树（BST）"><a href="#二叉树和二叉搜索树（BST）" class="headerlink" title="二叉树和二叉搜索树（BST）"></a>二叉树和二叉搜索树（BST）</h2><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。<br>这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。<br>二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。<br>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。<br>访问树的所有节点有三种方式：中序、先序和后序。<br>中序遍历 – 是以从最小到最大的顺序访问所有节点（第二层到第一层左中右）。<br>先序遍历 – 是以优先于后代节点的顺序访问每个节点的（第一层到第二层中左右）。<br>后序遍历 – 是先访问节点的后代节点，再访问节点本身（第二层到第一层左右中）。<br>中序遍历的一种应用就是对树进行排序操作。<br>先序遍历的一种应用是打印一个结构化的文档。<br>后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">function BinarySearchTree() &#123;</div><div class="line">	let Node = function(key)&#123;</div><div class="line">		this.key = key;</div><div class="line">		this.left = null;</div><div class="line">		this.right = null;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 根节点</div><div class="line">	let root = null;</div><div class="line">	</div><div class="line">	// 插入节点，小的节点插入left，大的节点插入right</div><div class="line">	let insertNode = function(node, newNode)&#123;</div><div class="line">		if (newNode.key &lt; node.key) &#123;</div><div class="line">			if (node.left === null) &#123;</div><div class="line">				node.left = newNode;</div><div class="line">			&#125; else &#123;</div><div class="line">				insertNode(node.left, newNode);</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			if (node.right === null) &#123;</div><div class="line">				node.right = newNode;</div><div class="line">			&#125; else &#123;</div><div class="line">				insertNode(node.right, newNode);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 向树中插入一个新的键</div><div class="line">	this.insert = function (key)&#123;</div><div class="line">		var newNode = new Node(key); //&#123;1&#125;</div><div class="line">		if (root === null)&#123; //&#123;2&#125;</div><div class="line">			root = newNode;</div><div class="line">		&#125; else &#123;</div><div class="line">			// 递归</div><div class="line">			insertNode(root,newNode); //&#123;3&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 私有方法-中序遍历</div><div class="line">	let inOrderTraverseNode = function(node, callback)&#123;</div><div class="line">		if (node !== null) &#123;</div><div class="line">			inOrderTraverseNode(node.left, callback);</div><div class="line">			callback(node.key);</div><div class="line">			inOrderTraverseNode(node.right, callback);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 中序遍历（左中右）小到大</div><div class="line">	this.inOrderTraverse = function(callback)&#123;</div><div class="line">		inOrderTraverseNode(root, callback);</div><div class="line">	</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 私有方法-先序遍历</div><div class="line">	var preOrderTraverseNode = function (node, callback) &#123;</div><div class="line">		if (node !== null) &#123;</div><div class="line">			callback(node.key); //&#123;1&#125;</div><div class="line">			preOrderTraverseNode(node.left, callback); //&#123;2&#125;</div><div class="line">			preOrderTraverseNode(node.right, callback); //&#123;3&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 先序遍历（中左右）</div><div class="line">	this.preOrderTraverse = function(callback)&#123;</div><div class="line">		preOrderTraverseNode(root, callback);</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 私有方法-后序遍历</div><div class="line">	var postOrderTraverseNode = function (node, callback) &#123;</div><div class="line">		if (node !== null) &#123;</div><div class="line">			postOrderTraverseNode(node.left, callback); //&#123;1&#125;</div><div class="line">			postOrderTraverseNode(node.right, callback); //&#123;2&#125;</div><div class="line">			callback(node.key); //&#123;3&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 后序遍历（左右中）</div><div class="line">	this.postOrderTraverse = function(callback)&#123;</div><div class="line">		postOrderTraverseNode(root, callback);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	// 私有方法-最小值</div><div class="line">	let minNode = function(node)&#123;</div><div class="line">		if (node) &#123;</div><div class="line">			while (node &amp;&amp; node.left !== null) &#123;</div><div class="line">				node = node.left</div><div class="line">			&#125;</div><div class="line">			return node.key;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 搜索最小值</div><div class="line">	this.min = function()&#123;</div><div class="line">		return minNode(node);</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	// 私有方法-最大值</div><div class="line">	var maxNode = function (node) &#123;</div><div class="line">		if (node)&#123;</div><div class="line">			while (node &amp;&amp; node.right !== null) &#123; //&#123;5&#125;</div><div class="line">				node = node.right;</div><div class="line">			&#125;</div><div class="line">			return node.key;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 搜索最大值</div><div class="line">	this.max = function() &#123;</div><div class="line">		return maxNode(root);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var searchNode = function(node, key)&#123;</div><div class="line">		if (node === null)&#123; //&#123;2&#125;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">		if (key &lt; node.key)&#123; //&#123;3&#125;</div><div class="line">			return searchNode(node.left, key); //&#123;4&#125;</div><div class="line">		&#125; else if (key &gt; node.key)&#123; //&#123;5&#125;</div><div class="line">			return searchNode(node.right, key); //&#123;6&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			return true; //&#123;7&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	this.search = function(key)&#123;</div><div class="line">		return searchNode(root, key); //&#123;1&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="序列数据结构"><a href="#序列数据结构" class="headerlink" title="序列数据结构"></a>序列数据结构</h2><p>1.数组（列表）<br>2.栈<br>3.队列<br>    普通队列<br>    优先队列<br>    循环队列<br>4.链表<br>    单向链表<br>    双向链表<br>    循环单向链表<br>    循环双向链表<br>5.集合 Set</p>
<h2 id="非序列数据结构"><a href="#非序列数据结构" class="headerlink" title="非序列数据结构"></a>非序列数据结构</h2><p>1.散列<br>2.字典 Map</p>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/23/排序算法-总结性文章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/23/排序算法-总结性文章/" itemprop="url">
                  排序算法-总结性文章
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T20:26:14+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/23/排序算法-总结性文章/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/23/排序算法-总结性文章/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3,845
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="排序算法的基本概念"><a href="#排序算法的基本概念" class="headerlink" title="排序算法的基本概念"></a>排序算法的基本概念</h1><h2 id="什么叫排序？"><a href="#什么叫排序？" class="headerlink" title="什么叫排序？"></a>什么叫排序？</h2><p>排序(Sorting) 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。</p>
<h2 id="排序算法的性质"><a href="#排序算法的性质" class="headerlink" title="排序算法的性质"></a>排序算法的性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。<br>反之，不稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中S在R之前。</p>
<h3 id="时间复杂度（最差、平均、和最好性能）T-n"><a href="#时间复杂度（最差、平均、和最好性能）T-n" class="headerlink" title="时间复杂度（最差、平均、和最好性能）T(n)"></a>时间复杂度（最差、平均、和最好性能）T(n)</h3><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。<br>    T(n) = O(f(n))<br>一般而言，好的性能是 O(nlogn)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">查看时间复杂度计算方式</a></p>
<h3 id="空间复杂度S-n"><a href="#空间复杂度S-n" class="headerlink" title="空间复杂度S(n)"></a>空间复杂度S(n)</h3><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。</p>
<h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>内排序：所有排序操作都在内存中完成。<br>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">更多详情</a></p>
<h1 id="先来张总结性图片"><a href="#先来张总结性图片" class="headerlink" title="先来张总结性图片"></a>先来张总结性图片</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt=""></p>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（尾部），故名。</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个（因为每次最后遍历的最后一个数都是最大的，所以不需要再次比较了）。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>选择排序法是对定位比较交换法（也就是冒泡排序法）的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</p>
<h2 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换，<br>2.第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换，<br>3.以此类推…<br>4.第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，<br>5.使有序序列不断增长直到全部排序完毕。<br>PS：冒泡排序是逐次把当前序列中最大值<span style="color: red;">推</span>到后面去。<br>    选择排序是逐次把当前序列中最小值<span style="color: red;">放</span>到前面去。<br><a href="https://fanerge.github.io/2017/11/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。<br>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。</p>
<h2 id="直接插入排序实现步骤"><a href="#直接插入排序实现步骤" class="headerlink" title="直接插入排序实现步骤"></a>直接插入排序实现步骤</h2><p>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：<br>①初始状态：无序区为R[1..n]，有序区为空。<br>②第1趟排序<br>在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br>……<br>③第i趟排序<br>第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。</p>
<h2 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.二分法查找插入位置<br>    如果R&lt;R[m]成立，那右指针就要向左移动中间指针一位，否则，左指针要向右移动中间指针一位。反复查找，直到左指针大于右指针时停止。<br>2.后移，有点迷惑，什么时候需要后移呢？有哪些记录需要移动呢？<br>    虽然我们很清楚的知道，我们需要后移那些排序码大于R的记录，但难免会问自己这样几个问题。其实它相当于需要移动从i-1到左指针的记录。<br>3.插入<br>    由1中得到的左指针其实就是元素要插入的位置。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p>
<h2 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>对数组arr，长度为n进行排序<br>1.第一个增量为Math.floor(n/2)，再最每个小的分租进行直接插入排序；<br>2.第二个增量为Math.floor(n/4)，再最每个小的分租进行直接插入排序；<br>3.以此类推…，直到增量为1，这是排序完成。<br><a href="https://fanerge.github.io/2017/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h2 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾,这时完成排序。<br><a href="https://fanerge.github.io/2017/11/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h2 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>一趟快速排序的算法是：排序序列A，N为排序序列长度<br>1.找基准（一般是以当前数组的第一项的值）<br>2.遍历数组，小于基准的放在left，大于基准的放在right<br>3.递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br><a href="https://fanerge.github.io/2017/11/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h2 id="实现步骤-6"><a href="#实现步骤-6" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br><a href="https://fanerge.github.io/2017/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h2><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p>
<h2 id="实现步骤-7"><a href="#实现步骤-7" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出待排序的数组中最大和最小的元素；<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>4.反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br><a href="https://fanerge.github.io/2017/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="桶排序-Bucket-SORT）"><a href="#桶排序-Bucket-SORT）" class="headerlink" title="桶排序 (Bucket SORT）"></a>桶排序 (Bucket SORT）</h1><h2 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h2><p>输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。</p>
<h2 id="实现步骤-8"><a href="#实现步骤-8" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br><a href="https://fanerge.github.io/2017/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h2><p>基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<h2 id="实现步骤-9"><a href="#实现步骤-9" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p>
</li>
<li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br><a href="https://fanerge.github.io/2017/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些算法我还记得在大学时学过的，只不过当然并没有太在意，这也许就是–欠下的债，终究是要还的。</p>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/22/排序算法-基数排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/22/排序算法-基数排序/" itemprop="url">
                  排序算法-基数排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:04:29+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/22/排序算法-基数排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/22/排序算法-基数排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  781
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基数排序（radix-sort）的基础"><a href="#基数排序（radix-sort）的基础" class="headerlink" title="基数排序（radix sort）的基础"></a>基数排序（radix sort）的基础</h1><p>技术排序的定义：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<h1 id="基数排序步骤"><a href="#基数排序步骤" class="headerlink" title="基数排序步骤"></a>基数排序步骤</h1><p>以LSD为例，排序数组arr = [73, 22, 93, 43, 55, 14, 28, 65, 39, 81];<br>    注：最低位优先(Least Significant Digit first)法，简称LSD法<br>        最高位优先(Most Significant Digit first)法，简称MSD法</p>
<ol>
<li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p>
</li>
<li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>PS：LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line">//LSD Radix Sort</div><div class="line">function radixSort(array, maxDigit) &#123;</div><div class="line">	var mod = 10;</div><div class="line">	var dev = 1;</div><div class="line">	var counter = [];</div><div class="line">	var arr = array.slice();</div><div class="line">	console.time(&apos;基数排序耗时&apos;);</div><div class="line">	for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</div><div class="line">		for(var j = 0; j &lt; arr.length; j++) &#123;</div><div class="line">			var bucket = parseInt((arr[j] % mod) / dev);</div><div class="line">			if(counter[bucket]== null) &#123;</div><div class="line">				counter[bucket] = [];</div><div class="line">			&#125;</div><div class="line">			counter[bucket].push(arr[j]);</div><div class="line">		&#125;</div><div class="line">		var pos = 0;</div><div class="line">		for(var j = 0; j &lt; counter.length; j++) &#123;</div><div class="line">			var value = null;</div><div class="line">			if(counter[j]!=null) &#123;</div><div class="line">				while ((value = counter[j].shift()) != null) &#123;</div><div class="line">					  arr[pos++] = value;</div><div class="line">				&#125;</div><div class="line">		  &#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	console.timeEnd(&apos;基数排序耗时&apos;);</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">var demo = radixSort(arr,2);</div><div class="line">console.log(arr); // [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(demo); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</div></pre></td></tr></table></figure>
</code></pre><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图">    </p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="external">基数排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/21/排序算法-桶排算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/21/排序算法-桶排算法/" itemprop="url">
                  排序算法-桶排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T20:01:12+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/21/排序算法-桶排算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/21/排序算法-桶排算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,010
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="桶排序的基础"><a href="#桶排序的基础" class="headerlink" title="桶排序的基础"></a>桶排序的基础</h1><p>桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。<br>桶排序的说明：桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O(n)）。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p>
<h1 id="桶排序的步骤"><a href="#桶排序的步骤" class="headerlink" title="桶排序的步骤"></a>桶排序的步骤</h1><div style="color: red;"><br>1.    找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.    计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.    再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.    将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.    将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br></div>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">// 插入排序</div><div class="line">function insertionSort(arr) &#123;</div><div class="line">	var len = arr.length;</div><div class="line">	var preIndex, current;</div><div class="line">	for (var i = 1; i &lt; len; i++) &#123;</div><div class="line">		preIndex = i - 1;</div><div class="line">		current = arr[i];</div><div class="line">		while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">			arr[preIndex+1] = arr[preIndex];</div><div class="line">			preIndex--;</div><div class="line">		&#125;</div><div class="line">		arr[preIndex+1] = current;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶排序</div><div class="line">function bucketSort(array, bucketSize) &#123;</div><div class="line">	let arr = array.slice();</div><div class="line">	let i;</div><div class="line">	let minValue = arr[0];</div><div class="line">	let maxValue = arr[0];</div><div class="line"></div><div class="line">	// 空数组时直接返回空数组</div><div class="line">	if (arr.length === 0) &#123;</div><div class="line">	  return arr;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	for (i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">	  if (arr[i] &lt; minValue) &#123;</div><div class="line">		  minValue = arr[i];                //输入数据的最小值</div><div class="line">	  &#125; else if (arr[i] &gt; maxValue) &#123;</div><div class="line">		  maxValue = arr[i];                //输入数据的最大值</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 桶的初始化</div><div class="line">	let DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5</div><div class="line">	bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</div><div class="line">	let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   </div><div class="line">	let buckets = new Array(bucketCount);</div><div class="line"></div><div class="line">	// 二维数组，每个桶初始化为空数组</div><div class="line">	for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">		buckets[i] = [];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 利用映射函数将数据分配到各个桶中</div><div class="line">	for (i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	arr.length = 0;</div><div class="line">	for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">		insertionSort(buckets[i]);                      //对每个桶进行插入排序</div><div class="line">		for (var j = 0; j &lt; buckets[i].length; j++) &#123;</div><div class="line">			arr.push(buckets[i][j]);                      </div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109];</div><div class="line">var demo = bucketSort(arr, 4); // 这里我分配了4个桶，桶越多越快但需要的内存就越多</div><div class="line">console.log(arr); // [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]</div><div class="line">console.log(demo); // [13, 28, 47, 51, 63, 67, 98, 101, 109, 117, 121, 133, 139, 141, 156, 157, 157, 181, 189, 194]</div></pre></td></tr></table></figure>
</code></pre><p>PS：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br>什么时候最快（Best Cases）：<br>  当输入的数据可以均匀的分配到每一个桶中<br>什么时候最慢（Worst Cases）：<br>  当输入的数据被分配到了同一个桶中</li>
</ol>
<h1 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg" alt="图片展示"></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin#4_2" target="_blank" rel="external">桶排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/20/排序算法-计数排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/20/排序算法-计数排序/" itemprop="url">
                  排序算法-计数排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T20:15:37+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/20/排序算法-计数排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/20/排序算法-计数排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,009
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计数排序的基础"><a href="#计数排序的基础" class="headerlink" title="计数排序的基础"></a>计数排序的基础</h1><p>定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）<br>计数排序对输入的数据有附加的限制条件：<br>    1、输入的线性表的元素属于有限偏序集S；<br>    2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。    </p>
<h1 id="计数排序算法思想"><a href="#计数排序算法思想" class="headerlink" title="计数排序算法思想"></a>计数排序算法思想</h1><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p>
<h1 id="现实计数算法"><a href="#现实计数算法" class="headerlink" title="现实计数算法"></a>现实计数算法</h1><h2 id="具体算法实现步骤"><a href="#具体算法实现步骤" class="headerlink" title="具体算法实现步骤"></a>具体算法实现步骤</h2><p><1>. 找出待排序的数组中最大和最小的元素；</1></p>
<p><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></p>
<p><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></p>
<p><4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function countingSort(arr)&#123;</div><div class="line">	let len = arr.length,</div><div class="line">		Result = [], // 保存排序后的数组</div><div class="line">		Count = [], // 保存各项出现次数的数组</div><div class="line">		min = max = arr[0];</div><div class="line">	console.time(&apos;计数排序计时&apos;);</div><div class="line"></div><div class="line">	// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数</div><div class="line">	for(var i = 0; i &lt; len; i++)&#123;</div><div class="line">		Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数</div><div class="line">		min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值</div><div class="line">		max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 从最小值-&gt;最大值,将计数逐项相加</div><div class="line">	for(var j = min; j &lt; max; j++)&#123;</div><div class="line">		Count[j+1] = (Count[j+1]||0)+(Count[j]||0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</div><div class="line">	for(var k = len - 1; k &gt;= 0;k--)&#123;</div><div class="line">		/*Result[位置] = arr数据*/</div><div class="line">		Result[Count[arr[k]] - 1] = arr[k];</div><div class="line">		/*减少Count数组中保存的计数*/</div><div class="line">		Count[arr[k]]--;</div><div class="line">		/*显示Result数组每一步详情*/</div><div class="line">		console.log(Result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console.timeEnd(&apos;计数排序计时&apos;);</div><div class="line">	return Result;</div><div class="line">&#125;</div><div class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</div><div class="line">console.log(countingSort(arr));</div></pre></td></tr></table></figure></4></p>
<pre><code>PS：时间复杂度：T(n) = O(n)
空间复杂度：S(n) = O(k)
是否稳定：是
排序方式：外排序
</code></pre><p>运行结果为:<br>[ , , , , , , , , , , , , , 48 ]<br>[ , , , , , , , , , , , , , 48, 50 ]<br>[ , , , , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>计数排序计时: 16ms<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图 | center"></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://hao.jser.com/archive/13600/" target="_blank" rel="external">基本算法学习(四)之计数排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin" target="_blank" rel="external">计数排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/15/排序算法-堆排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/排序算法-堆排序/" itemprop="url">
                  排序算法-堆排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T19:47:34+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/15/排序算法-堆排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/15/排序算法-堆排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,269
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆排序（Heapsort）的基础"><a href="#堆排序（Heapsort）的基础" class="headerlink" title="堆排序（Heapsort）的基础"></a>堆排序（Heapsort）的基础</h1><p>定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h1 id="我们需要了解什么叫堆"><a href="#我们需要了解什么叫堆" class="headerlink" title="我们需要了解什么叫堆"></a>我们需要了解什么叫堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：<br>        (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点<br>        若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p>
<h2 id="来个例子说明"><a href="#来个例子说明" class="headerlink" title="来个例子说明"></a>来个例子说明</h2><p>【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。<br>    小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。<br>    大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。<br>    注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。<br>    来张图表示一下：<br>    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b360e14f7bec54e755e1124cd851f035/43a7d933c895d1433f14885273f082025aaf0764.jpg" alt="大跟堆和小跟堆"></p>
<h2 id="堆的高度"><a href="#堆的高度" class="headerlink" title="堆的高度"></a>堆的高度</h2><p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p><div style="color: red;"><br>    <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>    <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>    <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br></3></2></1></div>    </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>```
/**
 * 对数组中的前n项整理成堆
 * @param array
 * @param n
 */
function refreshHeap(array, n){
    if(array.length&lt;n)n = array.length;

    //array[n/2-1]表示的是最后一个有子节点的节点
    for(let i=Math.floor(n/2)-1;i&gt;=0;i--){
        //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点
        //这个while是判断当前节点与其子节点是否需要调整
        while(2*i+1&lt;n){
            let j = 2*i+1;
            //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点
            if(j+1&lt;n){
                //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点）
                if(array[j]&lt;a[j+1]){
                    j++;
                }
            }
            //如果最大子节点大于其父节点，则交换
            if(a[i]&lt;a[j]){
                let tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
                //交换之后整个堆被破坏，需要重新调整，故令i=j
                //这个调整表示的是从j节点开始判断堆是否需要调整
                //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整
                i = j;
            }else{
                break;
            }
        }
    }
    return array;
}

function heapSort(array, n){
    if(array.length&lt;n)n = array.length;
    while(n&gt;0){
        //刷新堆之后，将array[0]（最大值）与最后一个子节点交换
        //然后重新刷新堆(不包括最后那些排好序的节点了)
        refreshHeap(array, n--);
        let tmp = array[n];
        array[n] = array[0];
        array[0] = tmp;
    }
    return array;
}

var a = [16,7,3,20,17,8];
console.log(a); // [16, 7, 3, 20, 17, 8]
heapSort(a,a.length);
console.log(a); // [3, 7, 8, 16, 17, 20]
```    
</code></pre><p>时间复杂度：T(n) = O(nlogn)<br>空间复杂度：S(n) = O(1)<br>稳定性：不稳定<br>排序方式：内排序    </p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F" alt="动图">    </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/liuyaqi1993/article/details/69569059" target="_blank" rel="external">JavaScript数据结构之 堆排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="external">堆排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/14/排序算法-快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/14/排序算法-快速排序/" itemprop="url">
                  排序算法-快速排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T20:13:47+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/14/排序算法-快速排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/14/排序算法-快速排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,282
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="快速排序（Quicksort）的基础"><a href="#快速排序（Quicksort）的基础" class="headerlink" title="快速排序（Quicksort）的基础"></a>快速排序（Quicksort）的基础</h1><p>定义：快速排序（Quicksort）是对冒泡排序的一种改进。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h1 id="快速排序算法的介绍"><a href="#快速排序算法的介绍" class="headerlink" title="快速排序算法的介绍"></a>快速排序算法的介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br>一趟快速排序的算法是：<br>    1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>    2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>    3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>    4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>    5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<h1 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h1><p>假设用户输入了如下数组：<br><span style="padding-left: 24px; color: red;">6, 2, 7, 3, 8, 9</span><br>1.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。<br>我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：<br><span style="padding-left: 24px; color: red;">3, 2, 7, 6, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=0 j=3 k=6</span><br>接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=2 j=3 k=6</span><br>称上面两次比较为一个循环。<br>接着，再递减变量j，不断重复进行上面的循环比较。<br>在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br>如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。<br>然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。<br>注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前面讲了那么多了，简单就记住下面的步骤就好了。</p>
<p><div style="color: red;"><br>1、找基准（一般是以当前数组的第一项的值）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br></div><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function quickSort(array)&#123;</div><div class="line">	let arr = array.slice();</div><div class="line"></div><div class="line">	//如果数组&lt;=1,则直接返回</div><div class="line">	if(arr.length&lt;=1)&#123;</div><div class="line">		return arr;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//找基准，并把基准从原数组删除</div><div class="line">	var pivot=arr.splice(0,1)[0];</div><div class="line">	//定义左右数组</div><div class="line">	var left=[];</div><div class="line">	var right=[];</div><div class="line"></div><div class="line">	//比基准小的放在left，比基准大的放在right</div><div class="line">	for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">		if(arr[i]&lt;=pivot)&#123;</div><div class="line">			left.push(arr[i]);</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			right.push(arr[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//递归</div><div class="line">	return quickSort(left).concat([pivot],quickSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [6, 2, 7, 3, 8, 9];</div><div class="line">let demo = quickSort(arr);</div><div class="line"></div><div class="line">console.log(arr); // [6, 2, 7, 3, 8, 9];</div><div class="line">console.log(demo); // [2, 3, 6, 7, 8, 9];</div></pre></td></tr></table></figure></p>
<p>时间复杂度：T(n) = O(n^2)<br>空间复杂度：S(n) = O(logn)<br>稳定性：不稳定<br>是否为内排序：是</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源网络，在次表示感谢</a></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dll-ft/p/5850487.html" target="_blank" rel="external">JS实现快速排序</a><br>    <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&amp;fromid=2084344&amp;fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#3_7" target="_blank" rel="external">快速排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/13/排序算法-归并算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/13/排序算法-归并算法/" itemprop="url">
                  排序算法-归并算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-13T20:18:58+08:00">
                2017-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/13/排序算法-归并算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/13/排序算法-归并算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,004
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="归并排序（MERGE-SORT）基础"><a href="#归并排序（MERGE-SORT）基础" class="headerlink" title="归并排序（MERGE-SORT）基础"></a>归并排序（MERGE-SORT）基础</h1><p>定义：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>实现过程：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
<h1 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h1><p>归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>假设要对数组C进行归并排序，步骤是：<br>    let C = [10, 4, 6, 3, 8, 2, 5, 7];<br>    1.先将C划分为两个数组A和B（即把数组C从中间分开 n = Math.floor(C.length/2)）<br>    2.再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。<br>    3.然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。<br>    4.依次类推，直到合并到最上层结束，这时数据的排序已经完成了。</p>
<h2 id="算法划分和合并过程"><a href="#算法划分和合并过程" class="headerlink" title="算法划分和合并过程"></a>算法划分和合并过程</h2><p><div style="color: red;"><br>    先划分：              [10, 4, 6, 3, 8, 2, 5, 7]<br>    第一次划分：[10, 4, 6, 3]         [8, 2, 5, 7]<br>    第二次划分：[10, 4]   [6, 3]      [8, 2]  [5, 7]<br>    第三次划分：[10] [4] [6] [3]      [8] [2] [5] [7]<br>    再合并：<br>    第一次合并：[4, 10] [3, 6]      [2, 8] [5, 7]<br>    第二次合并：[3, 4, 6, 10]      [2, 5, 7, 8]<br>    第三次合并：[2, 3, 4, 5, 6, 7, 8, 10]<br></div><br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt="图解">    </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function　merge(left, right)&#123;</div><div class="line">	var　result=[];</div><div class="line">	while(left.length &amp;&amp; right.length)&#123;</div><div class="line">		if(left[0] &lt; right[0])&#123;</div><div class="line">		/*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/</div><div class="line">			result.push(left.shift());</div><div class="line">		&#125;else&#123;</div><div class="line">			result.push(right.shift());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return　result.concat(left).concat(right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function　mergeSort(items)&#123;</div><div class="line">	if(items.length === 1)&#123;</div><div class="line">		return　items;</div><div class="line">	&#125;</div><div class="line">	let　middle = Math.floor(items.length/2),</div><div class="line">		left = items.slice(0, middle), //得到下标从0~index-1的数组</div><div class="line">		right = items.slice(middle); //得到下标从index开始到末尾的数组</div><div class="line">	return　merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [10, 4, 6, 3, 8, 2, 5, 7];</div><div class="line">let demo = mergeSort(arr)</div><div class="line">console.log(arr); // [10, 4, 6, 3, 8, 2, 5, 7]</div><div class="line">console.log(demo); // [2, 3, 4, 5, 6, 7, 8, 10]</div></pre></td></tr></table></figure>
</code></pre><p>ps：使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。<br>    时间复杂度：O(n log n)<br>    空间复炸都：O（n)<br>    稳定性：稳定<br>    排序方式：外排序</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源，在此表示感谢</a>    </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/fendou_dexiaoniao/article/details/46594125" target="_blank" rel="external">JS实现归并排序</a><br>    <a href="https://www.cnblogs.com/lizhancheng/p/3989809.html" target="_blank" rel="external">js归并排序法</a><br>    <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin#5_10" target="_blank" rel="external">归并排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/12/设计模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/设计模式总结/" itemprop="url">
                  JS常用设计模式总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T19:48:47+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/设计模式总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/设计模式总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,222
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>花了一个多月，终于把js中常用的设计模式整理了一遍。其中主要参阅了曾探的《JavaScript设计模式与开发实践》，讲真这本书写的真的很不错。<br>还参考了wiki、博客、掘金、CSDN等的文章，在此表示感谢，如有理解不当，还望指正。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>
<h1 id="工厂模式（Factory）"><a href="#工厂模式（Factory）" class="headerlink" title="工厂模式（Factory）"></a>工厂模式（Factory）</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）、<br>    自行车售卖（山地、公路）、<br>    饮料机（咖啡、牛奶、水）、<br>    RPG中职业（战士、法师、射手）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：：模态框、<br>    登录控件、<br>    注销控件<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）、<br>    计算年终奖（工资、效绩）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例： 图片预加载、图片懒加载、<br>    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、<br>    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、<br>    缓存代理（缓存请求结果、计算结果）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：手机购买页面（颜色、数量、内存、价格）、<br>    MVC模式（控制层便是位于表现层与模型层之间的中介者）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="装饰者模式（Decorator）"><a href="#装饰者模式（Decorator）" class="headerlink" title="装饰者模式（Decorator）"></a>装饰者模式（Decorator）</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。<br>举例：雷霆战机（吃道具的例子）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="发布订阅模式（Observer）"><a href="#发布订阅模式（Observer）" class="headerlink" title="发布订阅模式（Observer）"></a>发布订阅模式（Observer）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。<br>举例：模块通信、<br>    售楼中心<br><a href="https://fanerge.github.io/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>举例：常用于接口适配、<br>    兼容多个库（如Prototype库的$函数和YUI的get方法）<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>举例：jquery的$.each()、<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>举例：用桥接模式联结多个类、<br>    事件监控<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>举例：兼容浏览器事件绑定、<br>    兼容浏览器阻止冒泡、<br>    默认事件<br><a href="https://fanerge.github.io/2017/10/22/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br>举例：<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>举例：泡饮品（茶 和 coffee）<br>    公司面试（百度面试 和 阿里面试）<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>举例：文件扫描、<br>    dom节点操作<br><a href="https://fanerge.github.io/2017/11/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。<br>举例：分页控件、<br>    撤销组件<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。<br>举例：交押金预定手机、<br>    挤公交投币<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成。<br>举例：文件下载（开始、暂停、完成、失败等）、<br>    红绿灯<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。<br>举例：内衣厂展示许多商品展示、<br>    地图应用（对象池）<br><a href="https://fanerge.github.io/2017/11/07/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">130</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共172.1k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="80" height="160" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 100px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/hibiki/hibiki.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
