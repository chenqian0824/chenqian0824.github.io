<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/20/排序算法-计数排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/20/排序算法-计数排序/" itemprop="url">
                  排序算法-计数排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T20:15:37+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/20/排序算法-计数排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/20/排序算法-计数排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,009
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计数排序的基础"><a href="#计数排序的基础" class="headerlink" title="计数排序的基础"></a>计数排序的基础</h1><p>定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）<br>计数排序对输入的数据有附加的限制条件：<br>    1、输入的线性表的元素属于有限偏序集S；<br>    2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。    </p>
<h1 id="计数排序算法思想"><a href="#计数排序算法思想" class="headerlink" title="计数排序算法思想"></a>计数排序算法思想</h1><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p>
<h1 id="现实计数算法"><a href="#现实计数算法" class="headerlink" title="现实计数算法"></a>现实计数算法</h1><h2 id="具体算法实现步骤"><a href="#具体算法实现步骤" class="headerlink" title="具体算法实现步骤"></a>具体算法实现步骤</h2><p><1>. 找出待排序的数组中最大和最小的元素；</1></p>
<p><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></p>
<p><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></p>
<p><4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function countingSort(arr)&#123;</div><div class="line">	let len = arr.length,</div><div class="line">		Result = [], // 保存排序后的数组</div><div class="line">		Count = [], // 保存各项出现次数的数组</div><div class="line">		min = max = arr[0];</div><div class="line">	console.time(&apos;计数排序计时&apos;);</div><div class="line"></div><div class="line">	// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数</div><div class="line">	for(var i = 0; i &lt; len; i++)&#123;</div><div class="line">		Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数</div><div class="line">		min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值</div><div class="line">		max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 从最小值-&gt;最大值,将计数逐项相加</div><div class="line">	for(var j = min; j &lt; max; j++)&#123;</div><div class="line">		Count[j+1] = (Count[j+1]||0)+(Count[j]||0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</div><div class="line">	for(var k = len - 1; k &gt;= 0;k--)&#123;</div><div class="line">		/*Result[位置] = arr数据*/</div><div class="line">		Result[Count[arr[k]] - 1] = arr[k];</div><div class="line">		/*减少Count数组中保存的计数*/</div><div class="line">		Count[arr[k]]--;</div><div class="line">		/*显示Result数组每一步详情*/</div><div class="line">		console.log(Result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console.timeEnd(&apos;计数排序计时&apos;);</div><div class="line">	return Result;</div><div class="line">&#125;</div><div class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</div><div class="line">console.log(countingSort(arr));</div></pre></td></tr></table></figure></4></p>
<pre><code>PS：时间复杂度：T(n) = O(n)
空间复杂度：S(n) = O(k)
是否稳定：是
排序方式：外排序
</code></pre><p>运行结果为:<br>[ , , , , , , , , , , , , , 48 ]<br>[ , , , , , , , , , , , , , 48, 50 ]<br>[ , , , , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>计数排序计时: 16ms<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图 | center"></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://hao.jser.com/archive/13600/" target="_blank" rel="external">基本算法学习(四)之计数排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin" target="_blank" rel="external">计数排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/15/排序算法-堆排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/排序算法-堆排序/" itemprop="url">
                  排序算法-堆排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T19:47:34+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/15/排序算法-堆排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/15/排序算法-堆排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,269
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆排序（Heapsort）的基础"><a href="#堆排序（Heapsort）的基础" class="headerlink" title="堆排序（Heapsort）的基础"></a>堆排序（Heapsort）的基础</h1><p>定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h1 id="我们需要了解什么叫堆"><a href="#我们需要了解什么叫堆" class="headerlink" title="我们需要了解什么叫堆"></a>我们需要了解什么叫堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：<br>        (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点<br>        若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p>
<h2 id="来个例子说明"><a href="#来个例子说明" class="headerlink" title="来个例子说明"></a>来个例子说明</h2><p>【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。<br>    小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。<br>    大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。<br>    注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。<br>    来张图表示一下：<br>    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b360e14f7bec54e755e1124cd851f035/43a7d933c895d1433f14885273f082025aaf0764.jpg" alt="大跟堆和小跟堆"></p>
<h2 id="堆的高度"><a href="#堆的高度" class="headerlink" title="堆的高度"></a>堆的高度</h2><p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p><div style="color: red;"><br>    <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>    <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>    <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br></3></2></1></div>    </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>```
/**
 * 对数组中的前n项整理成堆
 * @param array
 * @param n
 */
function refreshHeap(array, n){
    if(array.length&lt;n)n = array.length;

    //array[n/2-1]表示的是最后一个有子节点的节点
    for(let i=Math.floor(n/2)-1;i&gt;=0;i--){
        //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点
        //这个while是判断当前节点与其子节点是否需要调整
        while(2*i+1&lt;n){
            let j = 2*i+1;
            //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点
            if(j+1&lt;n){
                //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点）
                if(array[j]&lt;a[j+1]){
                    j++;
                }
            }
            //如果最大子节点大于其父节点，则交换
            if(a[i]&lt;a[j]){
                let tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
                //交换之后整个堆被破坏，需要重新调整，故令i=j
                //这个调整表示的是从j节点开始判断堆是否需要调整
                //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整
                i = j;
            }else{
                break;
            }
        }
    }
    return array;
}

function heapSort(array, n){
    if(array.length&lt;n)n = array.length;
    while(n&gt;0){
        //刷新堆之后，将array[0]（最大值）与最后一个子节点交换
        //然后重新刷新堆(不包括最后那些排好序的节点了)
        refreshHeap(array, n--);
        let tmp = array[n];
        array[n] = array[0];
        array[0] = tmp;
    }
    return array;
}

var a = [16,7,3,20,17,8];
console.log(a); // [16, 7, 3, 20, 17, 8]
heapSort(a,a.length);
console.log(a); // [3, 7, 8, 16, 17, 20]
```    
</code></pre><p>时间复杂度：T(n) = O(nlogn)<br>空间复杂度：S(n) = O(1)<br>稳定性：不稳定<br>排序方式：内排序    </p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F" alt="动图">    </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/liuyaqi1993/article/details/69569059" target="_blank" rel="external">JavaScript数据结构之 堆排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="external">堆排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/14/排序算法-快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/14/排序算法-快速排序/" itemprop="url">
                  排序算法-快速排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T20:13:47+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/14/排序算法-快速排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/14/排序算法-快速排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,282
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="快速排序（Quicksort）的基础"><a href="#快速排序（Quicksort）的基础" class="headerlink" title="快速排序（Quicksort）的基础"></a>快速排序（Quicksort）的基础</h1><p>定义：快速排序（Quicksort）是对冒泡排序的一种改进。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h1 id="快速排序算法的介绍"><a href="#快速排序算法的介绍" class="headerlink" title="快速排序算法的介绍"></a>快速排序算法的介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br>一趟快速排序的算法是：<br>    1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>    2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>    3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>    4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>    5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<h1 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h1><p>假设用户输入了如下数组：<br><span style="padding-left: 24px; color: red;">6, 2, 7, 3, 8, 9</span><br>1.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。<br>我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：<br><span style="padding-left: 24px; color: red;">3, 2, 7, 6, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=0 j=3 k=6</span><br>接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=2 j=3 k=6</span><br>称上面两次比较为一个循环。<br>接着，再递减变量j，不断重复进行上面的循环比较。<br>在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br>如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。<br>然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。<br>注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前面讲了那么多了，简单就记住下面的步骤就好了。</p>
<p><div style="color: red;"><br>1、找基准（一般是以当前数组的第一项的值）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br></div><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function quickSort(array)&#123;</div><div class="line">	let arr = array.slice();</div><div class="line"></div><div class="line">	//如果数组&lt;=1,则直接返回</div><div class="line">	if(arr.length&lt;=1)&#123;</div><div class="line">		return arr;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//找基准，并把基准从原数组删除</div><div class="line">	var pivot=arr.splice(0,1)[0];</div><div class="line">	//定义左右数组</div><div class="line">	var left=[];</div><div class="line">	var right=[];</div><div class="line"></div><div class="line">	//比基准小的放在left，比基准大的放在right</div><div class="line">	for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">		if(arr[i]&lt;=pivot)&#123;</div><div class="line">			left.push(arr[i]);</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			right.push(arr[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//递归</div><div class="line">	return quickSort(left).concat([pivot],quickSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [6, 2, 7, 3, 8, 9];</div><div class="line">let demo = quickSort(arr);</div><div class="line"></div><div class="line">console.log(arr); // [6, 2, 7, 3, 8, 9];</div><div class="line">console.log(demo); // [2, 3, 6, 7, 8, 9];</div></pre></td></tr></table></figure></p>
<p>时间复杂度：T(n) = O(n^2)<br>空间复杂度：S(n) = O(logn)<br>稳定性：不稳定<br>是否为内排序：是</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源网络，在次表示感谢</a></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dll-ft/p/5850487.html" target="_blank" rel="external">JS实现快速排序</a><br>    <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&amp;fromid=2084344&amp;fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#3_7" target="_blank" rel="external">快速排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/13/排序算法-归并算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/13/排序算法-归并算法/" itemprop="url">
                  排序算法-归并算法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-13T20:18:58+08:00">
                2017-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/13/排序算法-归并算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/13/排序算法-归并算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,004
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="归并排序（MERGE-SORT）基础"><a href="#归并排序（MERGE-SORT）基础" class="headerlink" title="归并排序（MERGE-SORT）基础"></a>归并排序（MERGE-SORT）基础</h1><p>定义：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>实现过程：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
<h1 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h1><p>归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>假设要对数组C进行归并排序，步骤是：<br>    let C = [10, 4, 6, 3, 8, 2, 5, 7];<br>    1.先将C划分为两个数组A和B（即把数组C从中间分开 n = Math.floor(C.length/2)）<br>    2.再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。<br>    3.然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。<br>    4.依次类推，直到合并到最上层结束，这时数据的排序已经完成了。</p>
<h2 id="算法划分和合并过程"><a href="#算法划分和合并过程" class="headerlink" title="算法划分和合并过程"></a>算法划分和合并过程</h2><p><div style="color: red;"><br>    先划分：              [10, 4, 6, 3, 8, 2, 5, 7]<br>    第一次划分：[10, 4, 6, 3]         [8, 2, 5, 7]<br>    第二次划分：[10, 4]   [6, 3]      [8, 2]  [5, 7]<br>    第三次划分：[10] [4] [6] [3]      [8] [2] [5] [7]<br>    再合并：<br>    第一次合并：[4, 10] [3, 6]      [2, 8] [5, 7]<br>    第二次合并：[3, 4, 6, 10]      [2, 5, 7, 8]<br>    第三次合并：[2, 3, 4, 5, 6, 7, 8, 10]<br></div><br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt="图解">    </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function　merge(left, right)&#123;</div><div class="line">	var　result=[];</div><div class="line">	while(left.length &amp;&amp; right.length)&#123;</div><div class="line">		if(left[0] &lt; right[0])&#123;</div><div class="line">		/*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/</div><div class="line">			result.push(left.shift());</div><div class="line">		&#125;else&#123;</div><div class="line">			result.push(right.shift());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return　result.concat(left).concat(right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function　mergeSort(items)&#123;</div><div class="line">	if(items.length === 1)&#123;</div><div class="line">		return　items;</div><div class="line">	&#125;</div><div class="line">	let　middle = Math.floor(items.length/2),</div><div class="line">		left = items.slice(0, middle), //得到下标从0~index-1的数组</div><div class="line">		right = items.slice(middle); //得到下标从index开始到末尾的数组</div><div class="line">	return　merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [10, 4, 6, 3, 8, 2, 5, 7];</div><div class="line">let demo = mergeSort(arr)</div><div class="line">console.log(arr); // [10, 4, 6, 3, 8, 2, 5, 7]</div><div class="line">console.log(demo); // [2, 3, 4, 5, 6, 7, 8, 10]</div></pre></td></tr></table></figure>
</code></pre><p>ps：使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。<br>    时间复杂度：O(n log n)<br>    空间复炸都：O（n)<br>    稳定性：稳定<br>    排序方式：外排序</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源，在此表示感谢</a>    </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/fendou_dexiaoniao/article/details/46594125" target="_blank" rel="external">JS实现归并排序</a><br>    <a href="https://www.cnblogs.com/lizhancheng/p/3989809.html" target="_blank" rel="external">js归并排序法</a><br>    <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin#5_10" target="_blank" rel="external">归并排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/12/设计模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/设计模式总结/" itemprop="url">
                  JS常用设计模式总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T19:48:47+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/设计模式总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/设计模式总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,222
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>花了一个多月，终于把js中常用的设计模式整理了一遍。其中主要参阅了曾探的《JavaScript设计模式与开发实践》，讲真这本书写的真的很不错。<br>还参考了wiki、博客、掘金、CSDN等的文章，在此表示感谢，如有理解不当，还望指正。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>
<h1 id="工厂模式（Factory）"><a href="#工厂模式（Factory）" class="headerlink" title="工厂模式（Factory）"></a>工厂模式（Factory）</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）、<br>    自行车售卖（山地、公路）、<br>    饮料机（咖啡、牛奶、水）、<br>    RPG中职业（战士、法师、射手）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：：模态框、<br>    登录控件、<br>    注销控件<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）、<br>    计算年终奖（工资、效绩）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例： 图片预加载、图片懒加载、<br>    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、<br>    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、<br>    缓存代理（缓存请求结果、计算结果）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：手机购买页面（颜色、数量、内存、价格）、<br>    MVC模式（控制层便是位于表现层与模型层之间的中介者）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="装饰者模式（Decorator）"><a href="#装饰者模式（Decorator）" class="headerlink" title="装饰者模式（Decorator）"></a>装饰者模式（Decorator）</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。<br>举例：雷霆战机（吃道具的例子）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="发布订阅模式（Observer）"><a href="#发布订阅模式（Observer）" class="headerlink" title="发布订阅模式（Observer）"></a>发布订阅模式（Observer）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。<br>举例：模块通信、<br>    售楼中心<br><a href="https://fanerge.github.io/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>举例：常用于接口适配、<br>    兼容多个库（如Prototype库的$函数和YUI的get方法）<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>举例：jquery的$.each()、<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>举例：用桥接模式联结多个类、<br>    事件监控<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>举例：兼容浏览器事件绑定、<br>    兼容浏览器阻止冒泡、<br>    默认事件<br><a href="https://fanerge.github.io/2017/10/22/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br>举例：<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>举例：泡饮品（茶 和 coffee）<br>    公司面试（百度面试 和 阿里面试）<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>举例：文件扫描、<br>    dom节点操作<br><a href="https://fanerge.github.io/2017/11/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。<br>举例：分页控件、<br>    撤销组件<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。<br>举例：交押金预定手机、<br>    挤公交投币<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成。<br>举例：文件下载（开始、暂停、完成、失败等）、<br>    红绿灯<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>
<h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。<br>举例：内衣厂展示许多商品展示、<br>    地图应用（对象池）<br><a href="https://fanerge.github.io/2017/11/07/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/12/排序算法-希尔排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/排序算法-希尔排序/" itemprop="url">
                  排序算法-希尔排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T15:06:49+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/排序算法-希尔排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/排序算法-希尔排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  783
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="希尔排序（Shell-Sort）的基础"><a href="#希尔排序（Shell-Sort）的基础" class="headerlink" title="希尔排序（Shell Sort）的基础"></a>希尔排序（Shell Sort）的基础</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<h1 id="实现希尔排序（n为待排序arr-length）"><a href="#实现希尔排序（n为待排序arr-length）" class="headerlink" title="实现希尔排序（n为待排序arr.length）"></a>实现希尔排序（n为待排序arr.length）</h1><h2 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p>
<p>该方法实质上是一种分组插入方法</p>
<p>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。<br>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>假设待排序文件有10个记录，其关键字分别是：<br>    592,401,874,141,348,72,911,887,820,283。<br>增量序列的取值依次为：n = 10, 则增量d1 = 10/2 = 5。<br>    5，2，1<br><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" alt="计算过程"><br>    算法时间复杂度：T(n) = O(n*logn^2)<br>    内排序(内存排序就够了)<br>    不稳定(排序后原始顺序无法保证)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function shellSort(array) &#123;</div><div class="line">	let arr = array.slice(),</div><div class="line">		len = arr.length;</div><div class="line">	for(var fraction = Math.floor(len/2); fraction &gt; 0; fraction = Math.floor(fraction/2))&#123;</div><div class="line">		// 这里实质上有进行了直接插入排序</div><div class="line">		for(var i = fraction; i &lt; len; i++)&#123;</div><div class="line">			for(var j = i - fraction; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[fraction + j]; j -= fraction)&#123;</div><div class="line">				var temp = arr[j];</div><div class="line">				arr[j] = arr[fraction + j];</div><div class="line">				arr[fraction + j] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr1 = [592,401,874,141,348,72,911,887,820,283];</div><div class="line">let arr2 = shellSort(arr1);</div><div class="line">console.log(arr1); // [592, 401, 874, 141, 348, 72, 911, 887, 820, 283]</div><div class="line">console.log(arr2); // [72, 141, 283, 348, 401, 592, 820, 874, 887, 911]</div></pre></td></tr></table></figure>
</code></pre><p>PS：首个增量一般取值为 Math.floor(arr.length/2),对每个分组进行直接插入排序。<br>    重复上面过程，知道增量为1时，整个数组恰被分成一组，算法便终止。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="external">基本算法学习(一)之希尔排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">希尔排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/12/Symbol总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/Symbol总结/" itemprop="url">
                  Symbol总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T11:31:07+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/Symbol总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/Symbol总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,020
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Symbol-基础"><a href="#Symbol-基础" class="headerlink" title="Symbol 基础"></a>Symbol 基础</h1><h2 id="Symbol-引入的原因"><a href="#Symbol-引入的原因" class="headerlink" title="Symbol 引入的原因"></a>Symbol 引入的原因</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。<br>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>语法：Symbol([description])<br>参数：description – 可选的，字符串。symbol的description可以用于调试，但无法访问到symbol本身。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol();</div><div class="line">let s2 = Symbol();</div><div class="line"></div><div class="line">s1 === s2 // false</div></pre></td></tr></table></figure>
</code></pre><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 这里作为对象的属性使用，独一无二</div><div class="line">let s1 = Symbol();</div><div class="line">let a = &#123;</div><div class="line">	[s1]: &apos;我是Symbol类型的&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(a[s1]);</div></pre></td></tr></table></figure>
</code></pre><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。<br><span style="color: red;">它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</span><br>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<h1 id="Symbol-for-key-，Symbol-keyFor-key"><a href="#Symbol-for-key-，Symbol-keyFor-key" class="headerlink" title="Symbol.for(key)，Symbol.keyFor(key)"></a>Symbol.for(key)，Symbol.keyFor(key)</h1><h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p>我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&apos;foo&apos;);</div><div class="line">let s2 = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">s1 === s2 // true</div></pre></td></tr></table></figure></p>
<pre><code>PS：上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。
    Symbol.for(key)与Symbol(desc)这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
</code></pre><h2 id="Symbol-keyFor-key"><a href="#Symbol-keyFor-key" class="headerlink" title="Symbol.keyFor(key)"></a>Symbol.keyFor(key)</h2><pre><code>Symbol.keyFor方法返回一个（全局）已登记的 Symbol 类型值的key。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s1) // &quot;foo&quot;</div><div class="line"></div><div class="line">let s2 = Symbol(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s2) // undefined</div></pre></td></tr></table></figure>

PS：上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。
</code></pre><h1 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h1><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h2 id="迭代-symbols"><a href="#迭代-symbols" class="headerlink" title="迭代 symbols"></a>迭代 symbols</h2><ol>
<li>Symbol.iterator<br>  一个返回一个对象默认迭代器的方法。使用 for…of。</li>
<li>Symbol.asyncIterator（实验性API）<br>  一个返回对象默认的异步迭代器的方法。使用 for await of。</li>
</ol>
<h2 id="正则表达式-symbols"><a href="#正则表达式-symbols" class="headerlink" title="正则表达式 symbols"></a>正则表达式 symbols</h2><ol>
<li>Symbol.match<br>  一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match().</li>
<li>Symbol.replace<br>  一个替换匹配字符串的子串的方法. 使用 String.prototype.replace().</li>
<li>Symbol.search<br>  一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search().</li>
<li>Symbol.split<br>  一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split().</li>
</ol>
<h2 id="其他-symbols"><a href="#其他-symbols" class="headerlink" title="其他 symbols"></a>其他 symbols</h2><ol>
<li>Symbol.hasInstance<br>  一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof.</li>
<li>Symbol.isConcatSpreadable<br>  一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat().</li>
<li>Symbol.unscopables<br>  拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</li>
<li>Symbol.species<br>  一个用于创建派生对象的构造器函数。</li>
<li>Symbol.toPrimitive<br>  一个将对象转化为基本数据类型的方法。</li>
<li>Symbol.toStringTag<br>  用于对象的默认描述的字符串值。使用Object.prototype.toString().</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">阮一峰-Symbol</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">MDN-Symbol</a>    </p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Set和Map的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Set和Map的用法/" itemprop="url">
                  Set和Map的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T21:33:57+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Set和Map的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Set和Map的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,590
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Set-详解"><a href="#Set-详解" class="headerlink" title="Set 详解"></a>Set 详解</h1><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>语法：new Set([iterable]);<br>参数：如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。<br>返回值：一个新的Set对象。</p>
<h2 id="来个简单实例"><a href="#来个简单实例" class="headerlink" title="来个简单实例"></a>来个简单实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3]);</div><div class="line">console.log(set) // Set(3) &#123;1, 2, 3&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol>
<li>Set.prototype<br>表示Set构造器的原型，允许向所有Set对象添加新的属性。</li>
<li>Set.prototype.constructor<br>返回实例的构造函数。默认情况下是Set。</li>
<li>Set.prototype.size<br>返回Set对象的值的个数。</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</li>
<li>Set.prototype.clear()<br>移除Set对象内的所有元素。</li>
<li>Set.prototype.delete(value)<br>移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</li>
<li>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</li>
<li>Set.prototype.keys()<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</li>
<li>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</li>
<li>Set.prototype<a href="">@@iterator</a><br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值</li>
</ol>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-基础"><a href="#WeakSet-基础" class="headerlink" title="WeakSet 基础"></a>WeakSet 基础</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<h3 id="WeakSet-具有的方法"><a href="#WeakSet-具有的方法" class="headerlink" title="WeakSet 具有的方法"></a>WeakSet 具有的方法</h3>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const ws = new WeakSet();</div><div class="line">const obj = &#123;&#125;;</div><div class="line"></div><div class="line">ws.add(window);</div><div class="line">ws.add(obj);</div><div class="line"></div><div class="line">ws.has(window); // true</div><div class="line"></div><div class="line">ws.delete(window);</div><div class="line">ws.has(window);    // false</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-出现的背景"><a href="#Map-出现的背景" class="headerlink" title="Map 出现的背景"></a>Map 出现的背景</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<h2 id="基础特性-1"><a href="#基础特性-1" class="headerlink" title="基础特性"></a>基础特性</h2><p>语法：new Map([iterable])<br>参数：iterable<br>    Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>
<h2 id="简单的Map-实例"><a href="#简单的Map-实例" class="headerlink" title="简单的Map 实例"></a>简单的Map 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line"></div><div class="line">map.set(-0, 123);</div><div class="line">map.get(+0) // 123</div><div class="line"></div><div class="line">map.set(true, 1);</div><div class="line">map.set(&apos;true&apos;, 2);</div><div class="line">map.get(true) // 1</div><div class="line"></div><div class="line">map.set(undefined, 3);</div><div class="line">map.set(null, 4);</div><div class="line">map.get(undefined) // 3</div><div class="line"></div><div class="line">map.set(NaN, 123);</div><div class="line">map.get(NaN) // 123</div></pre></td></tr></table></figure>
</code></pre><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ol>
<li>Map.prototype<br>表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。</li>
<li>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</li>
<li>Map.prototype.size<br>返回Map对象的键/值对的数量。</li>
</ol>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</li>
<li>Map.prototype.delete(key)<br>移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。</li>
<li>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</li>
<li>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</li>
<li>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</li>
<li>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</li>
<li>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</li>
<li>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li>
<li>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</li>
<li>Map.prototype<a href="">@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li>
</ol>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的基础"><a href="#WeakMap-的基础" class="headerlink" title="WeakMap 的基础"></a>WeakMap 的基础</h3><pre><code>WeakMap结构与Map结构类似，也是用于生成键值对的集合。
WeakMap与Map的区别有两点：
</code></pre><ol>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<h3 id="WeakMap-的方法"><a href="#WeakMap-的方法" class="headerlink" title="WeakMap 的方法"></a>WeakMap 的方法</h3><ol>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>delete()</li>
</ol>
<h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>WeakMap 应用的典型场合就是 DOM 节点作为键名。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let myElement = document.getElementById(&apos;logo&apos;);</div><div class="line">let myWeakmap = new WeakMap();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">  let logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure></p>
<p>PS：上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">MDN-Set</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">MDN-Map</a><br>    <a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="external">阮一峰-Set和Map</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Proxy和Reflect的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Proxy和Reflect的用法/" itemprop="url">
                  Proxy和Reflect的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T18:51:05+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Proxy和Reflect的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Proxy和Reflect的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,659
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h1><h2 id="Proxy-定义"><a href="#Proxy-定义" class="headerlink" title="Proxy 定义"></a>Proxy 定义</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<h2 id="Proxy-语法"><a href="#Proxy-语法" class="headerlink" title="Proxy 语法"></a>Proxy 语法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 目标对象，需要被拦截 或 处理的对象，数组，函数甚至是其他的代理器</div><div class="line">let target = &#123;&#125;;</div><div class="line">// 拦截器对象</div><div class="line">let handler = &#123;</div><div class="line">	get(target, name)&#123;</div><div class="line">		// 这里如果 target 没有name属性的话，就设定一个默认值</div><div class="line">		return name in target ? target[name] : 27;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">console.log(target.name); // undefined</div><div class="line">console.log(proxy.name); // 27</div></pre></td></tr></table></figure>
</code></pre><p>PS：Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<h2 id="Proxy-支持的拦截操作一览，一共13种"><a href="#Proxy-支持的拦截操作一览，一共13种" class="headerlink" title="Proxy 支持的拦截操作一览，一共13种"></a>Proxy 支持的拦截操作一览，一共13种</h2><ol>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<h2 id="Proxy-revocable-可撤销的代理"><a href="#Proxy-revocable-可撤销的代理" class="headerlink" title="Proxy.revocable() 可撤销的代理"></a>Proxy.revocable() 可撤销的代理</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let target = &#123;&#125;;</div><div class="line">let handler = &#123;&#125;;</div><div class="line"></div><div class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</div><div class="line"></div><div class="line">proxy.foo = 123;</div><div class="line">console.log(proxy.foo);</div><div class="line"></div><div class="line">revoke(); // 取消Proxy实例</div><div class="line">console.log(proxy.foo); // TypeError: Revoked</div></pre></td></tr></table></figure></p>
<p>PS：Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。<br>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-的问题"><a href="#this-的问题" class="headerlink" title="this 的问题"></a>this 的问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const target = &#123;</div><div class="line">  m: function () &#123;</div><div class="line">	console.log(this === proxy);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">const handler = &#123;&#125;;</div><div class="line"></div><div class="line">const proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">target.m() // false</div><div class="line">proxy.m()  // true</div></pre></td></tr></table></figure></p>
<h2 id="Proxy-的应用"><a href="#Proxy-的应用" class="headerlink" title="Proxy 的应用"></a>Proxy 的应用</h2><h3 id="扩展数组的属性和方法"><a href="#扩展数组的属性和方法" class="headerlink" title="扩展数组的属性和方法"></a>扩展数组的属性和方法</h3><p>需求：对于数组对象，有时候我们只想要得到数组中对象的某个键值内容。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var AddSomeFunctionHandler=&#123;</div><div class="line">	get:function(obj,prop)&#123;</div><div class="line"></div><div class="line">		if(prop in obj)&#123;</div><div class="line">			return obj[prop]   // 按数组默认方式访问元素</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if(prop === &apos;name&apos;)&#123;</div><div class="line">			return obj.map(o=&gt;o.name)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var PersonArray=[&#123;</div><div class="line">	name:&quot;Alice&quot;,age:23</div><div class="line">&#125;,&#123;</div><div class="line">	name:&quot;Bob&quot;,age:45</div><div class="line">&#125;,&#123;</div><div class="line">	name:&quot;Mike&quot;,age:27</div><div class="line">&#125;]</div><div class="line"></div><div class="line">var p= new Proxy(PersonArray,AddSomeFunctionHandler)</div><div class="line">console.log(p.name) // [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</div></pre></td></tr></table></figure></p>
<h1 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h1><h2 id="Reflect-定义"><a href="#Reflect-定义" class="headerlink" title="Reflect 定义"></a>Reflect 定义</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。<br>Reflect对象的设计目的有这样几个：</p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li>
</ol>
<h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><p>Reflect对象一共有13个静态方法。</p>
<ol>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)<br>PS：上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</li>
</ol>
<h2 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h2><p>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  get baz() &#123;</div><div class="line">	return this.foo + this.bar;</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">Reflect.get(myObject, &apos;foo&apos;) // 1</div><div class="line">Reflect.get(myObject, &apos;bar&apos;) // 2</div><div class="line">Reflect.get(myObject, &apos;baz&apos;) // 3</div></pre></td></tr></table></figure></p>
<h2 id="实例–使用-Proxy-实现观察者模式"><a href="#实例–使用-Proxy-实现观察者模式" class="headerlink" title="实例–使用 Proxy 实现观察者模式"></a>实例–使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。<br>如果你还不懂<a href="">观察者模式</a><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//添加观察者</div><div class="line">const queuedObservers = new Set();</div><div class="line">const observe = fn =&gt; queuedObservers.add(fn);</div><div class="line"></div><div class="line">//proxy 的set 方法</div><div class="line">function set(target, key, value, receiver) &#123;</div><div class="line">	const result = Reflect.set(target, key, value, receiver);</div><div class="line">	queuedObservers.forEach(observer =&gt; observer());</div><div class="line">	return result;</div><div class="line">&#125;</div><div class="line">//创建proxy代理</div><div class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</div><div class="line">//被观察的 对象</div><div class="line">const person = observable(&#123;</div><div class="line">	name: &apos;张三&apos;,</div><div class="line">	age: 20</div><div class="line">&#125;);</div><div class="line"></div><div class="line">observe(print);</div><div class="line">console.log(person.name); // 张三</div><div class="line">person.name = &apos;李四&apos;;</div><div class="line">console.log(person.name); // 李四</div></pre></td></tr></table></figure></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">阮一峰-Reflect</a><br>    <a href="https://www.cnblogs.com/WhiteHorseIsNotHorse/p/7016010.html" target="_blank" rel="external">用es6 （proxy 和 reflect）轻松实现 观察者模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Generator函数的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Generator函数的用法/" itemprop="url">
                  Generator函数的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T15:48:46+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Generator函数的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Generator函数的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,088
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h1><p>从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<h1 id="Generator函数的简单示例"><a href="#Generator函数的简单示例" class="headerlink" title="Generator函数的简单示例"></a>Generator函数的简单示例</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* g() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var demo = g();</div></pre></td></tr></table></figure>
</code></pre><p>PS：上面代码定义了一个 Generator 函数g，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br><span style="color: red">返回的是，遍历器对象（Iterator Object）。例如这里，{ value: ‘hello’, done: false }</span></p>
<h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h1><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。<br>    （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。<br>    （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。<br>    （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。<br>    （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
<h1 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h1><pre><code>可以遍历 数组 和 实现了 Symbol.iterator 方法的对象。
</code></pre><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function *foo() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">  yield 4;</div><div class="line">  yield 5;</div><div class="line">  return 6;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let v of foo()) &#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">// 1 2 3 4 5</div></pre></td></tr></table></figure></p>
<h1 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a>Generator.prototype.next()</h1><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123; </div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen(); // &quot;Generator &#123; &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 1, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 2, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 3, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure></p>
<h1 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h1><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。    </p>
<h1 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h1><p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line"></div><div class="line">g.next()        // &#123; value: 1, done: false &#125;</div><div class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">g.next()        // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure></p>
<p>PS：遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。<br>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p>
<h1 id="比较一下多个异步操作的编码"><a href="#比较一下多个异步操作的编码" class="headerlink" title="比较一下多个异步操作的编码"></a>比较一下多个异步操作的编码</h1><p>step1完成才能做step2，step2完成才能做step3，step3完成才能做step4</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数("></a>回调函数(</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">step1(function (value1) &#123;</div><div class="line">  step2(value1, function(value2) &#123;</div><div class="line">	step3(value2, function(value3) &#123;</div><div class="line">	  step4(value3, function(value4) &#123;</div><div class="line">		// Do something with value4</div><div class="line">	  &#125;);</div><div class="line">	&#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>PS：层数多了就形成了回调地狱。</p>
<h2 id="Promise-组织代码"><a href="#Promise-组织代码" class="headerlink" title="Promise 组织代码"></a>Promise 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Q.fcall(step1)</div><div class="line">  .then(step2)</div><div class="line">  .then(step3)</div><div class="line">  .then(step4)</div><div class="line">  .then(function (value4) &#123;</div><div class="line">	// Do something with value4</div><div class="line">  &#125;, function (error) &#123;</div><div class="line">	// Handle any error from step1 through step4</div><div class="line">  &#125;)</div><div class="line">  .done();</div></pre></td></tr></table></figure>
</code></pre><p>PS：是不是代码稍微要清晰一些了。</p>
<h2 id="Generator-组织代码"><a href="#Generator-组织代码" class="headerlink" title="Generator 组织代码"></a>Generator 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function* longRunningTask() &#123;</div><div class="line">  try &#123;</div><div class="line">	var value1 = yield step1();</div><div class="line">	var value2 = yield step2(value1);</div><div class="line">	var value3 = yield step3(value2);</div><div class="line">	var value4 = yield step4(value3);</div><div class="line">	// Do something with value4</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">	// Handle any error from step1 through step4</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function scheduler(task) &#123;</div><div class="line">  setTimeout(function() &#123;</div><div class="line">	var taskObj = task.next(task.value);</div><div class="line">	// 如果Generator函数未结束，就继续调用</div><div class="line">	if (!taskObj.done) &#123;</div><div class="line">	  task.value = taskObj.value</div><div class="line">	  scheduler(task);</div><div class="line">	&#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">scheduler(longRunningTask());</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator 函数的语法</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">MDN-Generator</a><br>    <a href="http://blog.csdn.net/jiangbo_phd/article/details/51820642" target="_blank" rel="external">ES6 Generator 函数的使用</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">125</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共157.4k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="80" height="160" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 100px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/hibiki/hibiki.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
