<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-10-18T11:50:08.337Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue组件开发方法总结</title>
    <link href="https://fanerge.github.io/2017/10/18/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/10/18/vue组件开发方法总结/</id>
    <published>2017-10-18T11:29:37.000Z</published>
    <updated>2017-10-18T11:50:08.337Z</updated>
    
    <content type="html"><![CDATA[<p><em>VUE 组件的三种开发方式</em><br><strong>    开发组件大致分为3个步骤： 组件声明-组件注册（全局和局部）-组件使用</strong></p><h1 id="使用-script-标签"><a href="#使用-script-标签" class="headerlink" title="使用 script 标签"></a>使用 script 标签</h1><pre><code>1.组件声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 注意：使用&lt;script&gt;标签时，type指定为text/x-template，意在告诉浏览器这不是一段js脚本，浏览器在解析HTML文档时会忽略&lt;script&gt;标签内定义的内容。--&gt;</div><div class="line">&lt;!-- type 和 id 必须要填写 --&gt;</div><div class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;myComponent&quot;&gt;</div><div class="line">&lt;!--只能有一个根节点，下面两种方式同样遵循--&gt;</div><div class="line">       &lt;div class=&quot;root&quot;&gt;</div><div class="line">&lt;p&gt;我是p1&lt;/p&gt;</div><div class="line">&lt;p&gt;我是p2&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">   &lt;/script&gt;</div></pre></td></tr></table></figure>2.组件注册（分为全局注册和局部注册）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">全局注册：需要确保在根实例初始化之前注册，这样才能使组件在任意实例中都可以使用。</div><div class="line">Vue.component(&apos;my-component&apos;,MyComponent);//此句一定要放在new Vue(&#123;...&#125;);之前</div><div class="line">局部注册：限定了组件只能在被注册的组件中使用，而无法在其他组件中使用。</div><div class="line">//全局注册组件</div><div class="line">Vue.component(&apos;my-component&apos;,&#123;</div><div class="line">template: &apos;#myComponent&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>3.组件使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">       &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure>本例全部代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">&lt;!--3.组件使用--&gt;</div><div class="line">&lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!--1.组件声明--&gt;</div><div class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;myComponent&quot;&gt;</div><div class="line">&lt;div&gt;This is a component!&lt;/div&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">&lt;!--2.组件注册--&gt;</div><div class="line">Vue.component(&apos;my-component&apos;,&#123;</div><div class="line">template: &apos;#myComponent&apos;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">el: &apos;#app&apos;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></code></pre><h1 id="使用-template-标签"><a href="#使用-template-标签" class="headerlink" title="使用 template 标签"></a>使用 template 标签</h1><pre><code>1.组件声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;template id=&quot;myComponent&quot;&gt;</div><div class="line">       &lt;div&gt;This is a component!&lt;/div&gt;</div><div class="line">   &lt;/template&gt;</div></pre></td></tr></table></figure>2.组件注册<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-component&apos;,&#123;</div><div class="line">template: &apos;#myComponent&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>3.使用组件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">       &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure>本例全部代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">&lt;!--3.组件使用--&gt;</div><div class="line">&lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!--1.组件声明--&gt;</div><div class="line">&lt;template id=&quot;myComponent&quot;&gt;</div><div class="line">&lt;div&gt;This is a component!&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">&lt;!--2.组件注册--&gt;</div><div class="line">Vue.component(&apos;my-component&apos;,&#123;</div><div class="line">template: &apos;#myComponent&apos;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">el: &apos;#app&apos;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></code></pre><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><pre><code>注：这种方法常用在vue单页应用中。1.创建组件（hello.vue）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;hello&quot;&gt;</div><div class="line">&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">export default &#123;</div><div class="line">  name: &apos;hello&apos;,</div><div class="line">  data () &#123;</div><div class="line">return &#123;</div><div class="line">  msg: &apos;欢迎！&apos;</div><div class="line">&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>父组件代码（app.vue，这里app.vue为hello.vue的父组件）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 展示模板 --&gt;</div><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;</div><div class="line">&lt;!-- 3.使用组件 --&gt;</div><div class="line">&lt;hello&gt;&lt;/hello&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">// 导入组件</div><div class="line">import Hello from &apos;./components/hello&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  name: &apos;app&apos;,</div><div class="line">  // 2.这里进行组件局部注册</div><div class="line">  components: &#123;</div><div class="line">Hello</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="https://cn.vuejs.org/" target="_blank" rel="external">vue官网</a><br>    <a href="http://blog.csdn.net/u012123026/article/details/72460470" target="_blank" rel="external">vue组件的3种书写形式</a><br>    <a href="http://blog.csdn.net/u013910340/article/details/72763418" target="_blank" rel="external">vue.js中组件的创建和使用方法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;VUE 组件的三种开发方式&lt;/em&gt;&lt;br&gt;&lt;strong&gt;    开发组件大致分为3个步骤： 组件声明-组件注册（全局和局部）-组件使用&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用-script-标签&quot;&gt;&lt;a href=&quot;#使用-script-标签&quot; clas
      
    
    </summary>
    
      <category term="vue" scheme="https://fanerge.github.io/categories/vue/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://fanerge.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信的方式总结</title>
    <link href="https://fanerge.github.io/2017/10/17/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/10/17/vue组件通信的方式总结/</id>
    <published>2017-10-17T13:43:29.000Z</published>
    <updated>2017-10-17T14:20:31.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h1><pre><code>父组件通过 props 向子组件传递数据，子组件通过执行父组件的方法，通知父组件子组件所发生的变化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 父组件</div><div class="line">&lt;one-address :addressitems=&quot;addressitems&quot; @edit-address=&quot;editAddress&quot;&gt;&lt;/one-address&gt;</div><div class="line"></div><div class="line">// 子组件</div><div class="line">&lt;div&gt;&#123;&#123; addressitems.partment &#125;&#125;&#123;&#123; addressitems.address &#125;&#125;&lt;/div&gt;</div><div class="line">export default &#123;</div><div class="line">  props: &#123;</div><div class="line">addressitems: Object</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line"> editAddress () &#123;</div><div class="line">  this.$emit(&apos;edit-address&apos;, false)</div><div class="line"> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h1 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h1><pre><code>非父子组件通信同样也可以用Vue.$emit自定义事件来解决<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bus = new Vue();</div><div class="line">// 组件A</div><div class="line">bus.$emit(&apos;id-selected&apos;, 1);</div><div class="line">// 组件B</div><div class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</div><div class="line"> console.log(id)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h1 id="vue跨组件跨模块通信"><a href="#vue跨组件跨模块通信" class="headerlink" title="vue跨组件跨模块通信"></a>vue跨组件跨模块通信</h1><pre><code>使用 vuexvuex有四个核心概念，其中state和getters主要是用于数据的存储与输出，而mutations和actions是用于提交事件并修改state中的数据。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.jianshu.com/p/a78277be91d0" target="_blank" rel="external">vue组件之间的多种通信方法</a><br>    <a href="http://whutzkj.space/2017/08/05/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/#more" target="_blank" rel="external">vue组件之间的通信（一）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;父子组件通信&quot;&gt;&lt;a href=&quot;#父子组件通信&quot; class=&quot;headerlink&quot; title=&quot;父子组件通信&quot;&gt;&lt;/a&gt;父子组件通信&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;父组件通过 props 向子组件传递数据，子组件通过执行父组件的方法，通知父组件子组件所发生
      
    
    </summary>
    
      <category term="vue" scheme="https://fanerge.github.io/categories/vue/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://fanerge.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-发布订阅模式</title>
    <link href="https://fanerge.github.io/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/17/js设计模式-发布订阅模式/</id>
    <published>2017-10-17T13:39:45.000Z</published>
    <updated>2017-10-17T14:54:39.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发布-订阅模式（观察者模式）"><a href="#发布-订阅模式（观察者模式）" class="headerlink" title="发布-订阅模式（观察者模式）"></a>发布-订阅模式（观察者模式）</h1><pre><code>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</code></pre><h1 id="现实生活中的发布-订阅模式"><a href="#现实生活中的发布-订阅模式" class="headerlink" title="现实生活中的发布-订阅模式"></a>现实生活中的发布-订阅模式</h1><pre><code>    比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们。    在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息。</code></pre><h1 id="实现发布-订阅模式的步骤"><a href="#实现发布-订阅模式的步骤" class="headerlink" title="实现发布-订阅模式的步骤"></a>实现发布-订阅模式的步骤</h1><pre><code>1.首先要想好谁是发布者(比如上面的卖家)。2.然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。3.最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</code></pre><h1 id="发布-订阅模式的代码封装"><a href="#发布-订阅模式的代码封装" class="headerlink" title="发布-订阅模式的代码封装"></a>发布-订阅模式的代码封装</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">var Event = (function()&#123;</div><div class="line">var list = &#123;&#125;, // 缓存列表</div><div class="line">  listen, // 监听函数</div><div class="line">  trigger, // 触发监听</div><div class="line">  remove; // 移除监听函数</div><div class="line">  listen = function(key,fn)&#123;</div><div class="line">if(!list[key]) &#123;</div><div class="line">list[key] = [];</div><div class="line">&#125;</div><div class="line">list[key].push(fn);</div><div class="line">&#125;;</div><div class="line">trigger = function()&#123;</div><div class="line">var key = Array.prototype.shift.call(arguments),</div><div class="line"> fns = list[key];</div><div class="line">if(!fns || fns.length === 0) &#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">for(var i = 0, fn; fn = fns[i++];) &#123;</div><div class="line">fn.apply(this,arguments);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">remove = function(key,fn)&#123;</div><div class="line">var fns = list[key];</div><div class="line">if(!fns) &#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">if(!fn) &#123;</div><div class="line">fns &amp;&amp; (fns.length = 0);</div><div class="line">&#125;else &#123;</div><div class="line">for(var i = fns.length - 1; i &gt;= 0; i--)&#123;</div><div class="line">var _fn = fns[i];</div><div class="line">if(_fn === fn) &#123;</div><div class="line">fns.splice(i,1);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">return &#123;</div><div class="line">listen: listen,</div><div class="line">trigger: trigger,</div><div class="line">remove: remove</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">function d1() &#123;</div><div class="line">console.log(&apos;我是第二个color监听的函数!&apos;); </div><div class="line">&#125;</div><div class="line">function d2() &#123;</div><div class="line">console.log(&apos;我是第二个color监听的函数!&apos;);</div><div class="line">&#125;</div><div class="line">// 测试代码</div><div class="line">Event.listen(&quot;color&quot;, d1); // 在 list[&apos;color&apos;] 中绑定 d1 函数</div><div class="line">Event.listen(&quot;color&quot;, d2); // 在 list[&apos;color&apos;] 中绑定 d2 函数</div><div class="line">Event.remove(&apos;color&apos;, d1); // 在 list[&apos;color&apos;] 中移除 d1 函数</div><div class="line">Event.trigger(&quot;color&quot;); // 我是第二个color监听的函数!</div></pre></td></tr></table></figure>注意：此处代码来源于网络，可直接保留，以被使用。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4687947.html" target="_blank" rel="external">Javascript中理解发布–订阅模式</a><br>    <a href="http://www.cnblogs.com/weebly/p/5279952.html" target="_blank" rel="external">学习笔记-js发布/订阅模式的简单实现</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发布-订阅模式（观察者模式）&quot;&gt;&lt;a href=&quot;#发布-订阅模式（观察者模式）&quot; class=&quot;headerlink&quot; title=&quot;发布-订阅模式（观察者模式）&quot;&gt;&lt;/a&gt;发布-订阅模式（观察者模式）&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：对象间的一种一对多的关
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js函数传参方式--按值传递</title>
    <link href="https://fanerge.github.io/2017/10/17/js%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/17/js函数传参方式/</id>
    <published>2017-10-17T12:39:15.000Z</published>
    <updated>2017-10-17T13:20:19.630Z</updated>
    
    <content type="html"><![CDATA[<p>一直以为js函数传参方式–按引用传递，原来我一直错了。通过查阅资料彻底了解js函数传参是按值传递的。<br><strong>要搞清楚js函数传参方式，我们先需要具备一些基础知识。</strong></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><pre><code>基本类型值: Undefined,Null,Boolean,Number,String。引用类型值: Object,Array,Function,Date等。</code></pre><h1 id="变量的复制"><a href="#变量的复制" class="headerlink" title="变量的复制"></a>变量的复制</h1><h2 id="基本类型的复制"><a href="#基本类型的复制" class="headerlink" title="基本类型的复制"></a>基本类型的复制</h2><pre><code>    众所周知，js中变量的基本类型和引用类型保存方式是不同的，这也就导致变量复制时也就不同了。如果从一个变量向另一个变量复制基本类型的值时，会将前者的值克隆一个，然后将克隆的值赋值到后者，因此这两个值是完全独立的，只是他们的value相同而已。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num1 = 10;</div><div class="line">var num2 = num1;</div><div class="line">console.log(num2);//10</div></pre></td></tr></table></figure>    上面的num1中被保存的值为10，当把num1的值赋值给num2时，num2的值也为10。但是这两个10是完全独立的，num2中的10只是被克隆出来的，相当于我写了一个word文档，把它放到了num1的文件夹中，然后我再复制这个word文档，就叫word副本吧，然后把这个副本放到num2的文件夹下，这两个word文档是完全一样的，修改任何一个都不会影响另一个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num2 += 1;</div><div class="line">console.log(num1); //10</div><div class="line">console.log(num2); //11</div></pre></td></tr></table></figure></code></pre><h2 id="引用类型的复制"><a href="#引用类型的复制" class="headerlink" title="引用类型的复制"></a>引用类型的复制</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">  name : &quot;111&quot;</div><div class="line">&#125;;</div><div class="line">var obj2 = obj1;</div><div class="line">console.log(obj2.name); //111</div><div class="line">obj2.name = &quot;222&quot;;</div><div class="line">console.log(obj1.name); //222</div></pre></td></tr></table></figure>    第一次打印出的结果为“111”，这个我们很容易理解，但是第二次打印出来的是“222”，有点莫名其妙了。这就是引用类型和基本类型的不同之处了。复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了。将obj1的值复制给obj2，而这个值的副本实际上是一个指针，这个指针指向存储在堆中的一个对象，也就是说创建了一个新的内存地址传给了obj2，obj1和obj2两个变量同时指向了同一个Object，当去改变这个对象时，他们的值都会改变，也就是说他们中任何一个作出的改变都会反映在另一个身上。下面的简易图可能更明了些。</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6.png" alt="引用复制"></p><h1 id="函数参数的传递（按值传递）"><a href="#函数参数的传递（按值传递）" class="headerlink" title="函数参数的传递（按值传递）"></a>函数参数的传递（按值传递）</h1><h2 id="基本类型传递参数（）"><a href="#基本类型传递参数（）" class="headerlink" title="基本类型传递参数（）"></a>基本类型传递参数（）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var count = 10;</div><div class="line">function num(num1)&#123;</div><div class="line">   num1 = 1;</div><div class="line">   return num1;</div><div class="line">&#125;</div><div class="line">var result = num(count);</div><div class="line">console.log(result); //1</div><div class="line">console.log(count); //10，并未变成1</div></pre></td></tr></table></figure>    这个例子很容易理解，实际就是创建了一个count的副本，然后把count的副本的值传入参数中，因为函数中定义了参数的值，所以1就将10覆盖了，最后的result返回1，而count并未发生变化。</code></pre><h2 id="引用类型传递参数（按值传递）"><a href="#引用类型传递参数（按值传递）" class="headerlink" title="引用类型传递参数（按值传递）"></a>引用类型传递参数（按值传递）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person  = &#123;</div><div class="line">name : &quot;Tom&quot;</div><div class="line">&#125;;</div><div class="line">function obj(peo)&#123;</div><div class="line">// PS：这里 peo 对象和 person 对象的内存地址一模一样，所以后面两个才会同时改变</div><div class="line">peo.name = &quot;Jerry&quot;;</div><div class="line">return peo;</div><div class="line">&#125;</div><div class="line">var result = obj(person);</div><div class="line">console.log(result.name); // Jerry</div><div class="line">console.log(person.name); // Jerry</div></pre></td></tr></table></figure>    在上面的例子中，把person复制传入obj()中，peo和person指向了同一个对象，而在peo中修改了name属性，其实修改了它们共同指向的对象的name属性，相对应的外部person所引用的name属性也就改变了，所以打印出来的为Jerry。其实这个乍一看，感觉引用类型的参数是按照引用传递的，这就是我最初犯得错误。再来看一个例子。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">name : &quot;Tom&quot;</div><div class="line">&#125;; </div><div class="line">function obj(peo)&#123;</div><div class="line">// PS：这里在函数里面新建了一个对象 peo，其内存地址和 person 对象内存地址不一样，所以两个对象不相干涉 </div><div class="line">peo = &#123;</div><div class="line">   name : &quot;Jerry&quot;</div><div class="line">&#125;;</div><div class="line">return peo;</div><div class="line">&#125;</div><div class="line">var result = obj(person);</div><div class="line">console.log(result.name);// Jerry</div><div class="line">console.log(person.name);// Tom</div></pre></td></tr></table></figure>    上面的例子中，在函数中重新定义了一个对象，也就是现在堆内存中有两个对象，外部的person指向的是老的对象，被传入参数后指向的是新定义的对象，所以调用后返回的值是新定义的对象的值。如果是参数是按引用传递的，那么person.name打印出来的结果为Jerry，从这点可以得出参数是按值传递的（有的地方叫做按共享传递）。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>JavaScript中的函数不存在按引用传递，所有参数都是按值传递！<br>    引用类型的变量本就是一个引用，它的值是堆内存中Object的地址，<br>    当使用按值传递时传递的值本就是一个地址，所以在函数中对参数进行操作会影响到函数外对应的变量。</strong></p><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/dgjamin/p/4337677.html" target="_blank" rel="external">JavaScript中函数参数的按值传递与按引用传递（即按地址传递）</a><br>    <a href="http://blog.csdn.net/allenliu6/article/details/52516605" target="_blank" rel="external">JS函数参数都是按值传递的！</a><br>    <a href="http://www.cnblogs.com/open-wang/p/5208606.html" target="_blank" rel="external">js函数中参数的传递</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以为js函数传参方式–按引用传递，原来我一直错了。通过查阅资料彻底了解js函数传参是按值传递的。&lt;br&gt;&lt;strong&gt;要搞清楚js函数传参方式，我们先需要具备一些基础知识。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; clas
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-装饰者模式</title>
    <link href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/16/js设计模式-装饰者模式/</id>
    <published>2017-10-16T14:42:20.000Z</published>
    <updated>2017-10-16T15:18:46.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><pre><code>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。    装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。    与继承相比，装饰者是一种更轻便灵活的做法。</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E8%80%85%E5%8C%85%E8%A3%85%E6%B5%81%E7%A8%8B.png" alt="图解装饰者模式"><br>普通对象被装饰者包裹起来，就形成了装饰者模式。<br>    举例：<br>        雷霆战机（吃道具的例子）</p><h1 id="雷霆战机（吃道具的例子）"><a href="#雷霆战机（吃道具的例子）" class="headerlink" title="雷霆战机（吃道具的例子）"></a>雷霆战机（吃道具的例子）</h1><pre><code>介绍：现在我们假设正在开发一个小游戏--雷霆战机，     最开始我们使用最渣的飞机，只能发射普通子弹；    吃一颗星，可以发射普通子弹和发射散弹 ；    再吃一颗，可以发射普通子弹和散弹和跟踪导弹。// 一级飞机    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var plane = &#123;</div><div class="line">fire: function()&#123;</div><div class="line">console.log(&apos;发射普通子弹&apos;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">plane.fire(); // &apos;发射普通子弹&apos;</div></pre></td></tr></table></figure>// 二级飞机    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var fire1 = plane.fire;</div><div class="line">var shot = function() &#123;</div><div class="line">console.log(&apos;发射散弹&apos;);</div><div class="line">&#125;;</div><div class="line">plane.fire = function () &#123;</div><div class="line">fire1();</div><div class="line">shot();</div><div class="line">&#125;;</div><div class="line">plane.fire(); // &apos;发射普通子弹&apos; &apos;发射散弹&apos;</div></pre></td></tr></table></figure>// 三级飞机<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var fire2 = plane.fire;</div><div class="line">var track = function() &#123;</div><div class="line">console.log(&apos;发射跟踪导弹&apos;);</div><div class="line">&#125;;</div><div class="line">plane.fire = function () &#123;</div><div class="line">fire2();</div><div class="line">shot();</div><div class="line">&#125;;</div><div class="line">plane.fire(); // &apos;发射普通子弹&apos; &apos;发射散弹&apos; &apos;发射跟踪导弹&apos;</div></pre></td></tr></table></figure></code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E8%80%85%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="装饰者执行过程"><br>    说明：这样给对象动态的增加职责的方式就没有改变对象自身，<br>        一个对象放入另一个对象就形成了一条装饰链（一个聚合对象），<br>        而上面的shot和track也就是装饰者、装饰函数 ，<br>        当函数执行时，会把请求转给链中的下一个对象。</p><h1 id="在-FUNCTION-原型上封装通用的装饰函数"><a href="#在-FUNCTION-原型上封装通用的装饰函数" class="headerlink" title="在 FUNCTION 原型上封装通用的装饰函数"></a>在 FUNCTION 原型上封装通用的装饰函数</h1><pre><code>// 在原函数之前执行    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Function.prototype.before=function(beforefn) &#123;</div><div class="line">var _this = this;                               // 保存旧函数的引用</div><div class="line">return function() &#123;                           // 返回包含旧函数和新函数的“代理”函数</div><div class="line">beforefn.apply(this,arguments);            // 执行新函数,且保证this不被劫持,新函数接受的参数   </div><div class="line">return _this.apply(this,arguments);        // 也会被原封不动的传入旧函数,新函数在旧函数之前执行</div><div class="line">&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>// 在原函数之后执行    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Function.prototype.after = function(afterfn) &#123;</div><div class="line">var _this = this;</div><div class="line">return function() &#123;</div><div class="line">var ret = _this.apply(this,arguments);</div><div class="line">afterfn.apply(this,arguments);</div><div class="line">return ret;</div><div class="line">&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h1 id="封装成单独函数（不污染原型）"><a href="#封装成单独函数（不污染原型）" class="headerlink" title="封装成单独函数（不污染原型）"></a>封装成单独函数（不污染原型）</h1><pre><code>// 在原函数之前执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var before = function(fn, before) &#123;</div><div class="line">return function() &#123;</div><div class="line">before.apply(this, arguments);</div><div class="line">return fn.apply(this, arguments);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用</div><div class="line">before(func1, func2);</div></pre></td></tr></table></figure>// 在原函数之后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var after = function(fn, after) &#123;</div><div class="line">return function() &#123;</div><div class="line">var ret = fn.apply(this,arguments);</div><div class="line">after.apply(this,arguments);</div><div class="line">return ret;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用</div><div class="line">after(func1, func2);</div></pre></td></tr></table></figure>注意：代码来源于--腾讯.曾探《JavaScript设计模式与开发实践》，但能很好的说明装饰者模式在js实际项目中的应用。上面封装的函数可以直接在项目中使用。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/yisuowushinian/article/details/51934008" target="_blank" rel="external">JavaScript设计模式—-装饰者模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/02/24/2353434.html" target="_blank" rel="external">深入理解JavaScript系列（29）：设计模式之装饰者模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-中介者模式</title>
    <link href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/16/js设计模式-中介者模式/</id>
    <published>2017-10-16T14:41:28.000Z</published>
    <updated>2017-10-16T14:49:38.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><pre><code>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。举例：    手机购买页面（颜色、数量、内存、价格）    MVC模式（控制层便是位于表现层与模型层之间的中介者。）</code></pre><h1 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h1><pre><code>我们应该很熟悉 MVC 三层模型实体模型（Model）、视图表现层（View）还有控制层（Control/Mediator）。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** 模擬 Model, View, Controller */</div><div class="line">var M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;</div><div class="line"></div><div class="line">/** Model 負責存放資料 */</div><div class="line">M.data = &quot;hello world&quot;;</div><div class="line"></div><div class="line">/** View 負責將資料輸出到螢幕上 */</div><div class="line">V.render = (M) =&gt; &#123; alert(M.data); &#125;</div><div class="line"></div><div class="line">/** Controller 作為一個 M 和 V 的橋樑 */</div><div class="line">C.handleOnload = () =&gt; &#123; V.render(M); &#125;</div><div class="line"></div><div class="line">/** 在網頁讀取的時候呼叫 Controller */</div><div class="line">window.onload = C.handleOnload;</div></pre></td></tr></table></figure>MVC 模式中的Control/Mediator 层，就是本设计模式的中介者 (它必须拿到 View 和 Model 的引用)。</code></pre><h1 id="手机购买页面"><a href="#手机购买页面" class="headerlink" title="手机购买页面"></a>手机购买页面</h1><h2 id="HTML-部分"><a href="#HTML-部分" class="headerlink" title="HTML 部分"></a>HTML 部分</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">选择颜色: </div><div class="line">&lt;select id=&quot;colorSelect&quot;&gt;</div><div class="line">&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;</div><div class="line">&lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;</div><div class="line">&lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">选择内存: </div><div class="line">&lt;select id=&quot;memorySelect&quot;&gt;</div><div class="line">&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;</div><div class="line">&lt;option value=&quot;32G&quot;&gt;32G&lt;/option&gt;</div><div class="line">&lt;option value=&quot;16G&quot;&gt;16G&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">输入购买数量: &lt;input type=&quot;text&quot; id=&quot;numberInput&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;!--输入部分结束--&gt;</div><div class="line"></div><div class="line">您选择了颜色: &lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;</div><div class="line">您选择了内存: &lt;div id=&quot;memoryInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;</div><div class="line">您输入了数量: &lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;</div><div class="line">&lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和购买数量&lt;/button&gt;</div><div class="line">&lt;body&gt;</div></pre></td></tr></table></figure></code></pre><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">// 各种手机库存（通常来自于后端，这里前端进行模拟）</div><div class="line">var goods = &#123; </div><div class="line">&quot;red|32G&quot;: 3,</div><div class="line">&quot;red|16G&quot;: 0,</div><div class="line">&quot;blue|32G&quot;: 1,</div><div class="line">&quot;blue|16G&quot;: 6</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 中介者</div><div class="line">var mediator = (function()&#123;</div><div class="line">// 获得所有节点的引用，以便对其进行操作（中介者必许获得对其他对象的引用）</div><div class="line">var colorSelect = document.getElementById( &apos;colorSelect&apos; ),</div><div class="line">memorySelect = document.getElementById( &apos;memorySelect&apos; ),</div><div class="line">numberInput = document.getElementById( &apos;numberInput&apos; ),</div><div class="line">colorInfo = document.getElementById( &apos;colorInfo&apos; ),</div><div class="line">memoryInfo = document.getElementById( &apos;memoryInfo&apos; ),</div><div class="line">numberInfo = document.getElementById( &apos;numberInfo&apos; ),</div><div class="line">nextBtn = document.getElementById( &apos;nextBtn&apos; );</div><div class="line">return &#123;</div><div class="line">changed( obj )&#123;</div><div class="line">var color = colorSelect.value, // 颜色</div><div class="line">memory = memorySelect.value,// 内存</div><div class="line">number = numberInput.value, // 数量</div><div class="line">stock = goods[ color + &apos;|&apos; + memory ]; // 颜色和内存对应的手机库存数量</div><div class="line">if ( obj === colorSelect )&#123; // 如果改变的是选择颜色下拉框</div><div class="line">colorInfo.innerHTML = color;</div><div class="line">&#125;else if ( obj === memorySelect )&#123;</div><div class="line">memoryInfo.innerHTML = memory;</div><div class="line">&#125;else if ( obj === numberInput )&#123;</div><div class="line">numberInfo.innerHTML = number;</div><div class="line">&#125;</div><div class="line">if ( !color )&#123;</div><div class="line">nextBtn.disabled = true;</div><div class="line">nextBtn.innerHTML = &apos;请选择手机颜色&apos;;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">if ( !memory )&#123;</div><div class="line">nextBtn.disabled = true;</div><div class="line">nextBtn.innerHTML = &apos;请选择内存大小&apos;;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">if ( ( ( number - 0 ) | 0 ) !== number - 0 )&#123; // 输入购买数量是否为正整数</div><div class="line">nextBtn.disabled = true;</div><div class="line">nextBtn.innerHTML = &apos;请输入正确的购买数量&apos;;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">nextBtn.disabled = false;</div><div class="line">nextBtn.innerHTML = &apos;放入购物车&apos;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 与中介者联系起来，事件函数</div><div class="line">colorSelect.onchange = function()&#123;</div><div class="line">mediator.changed( this );</div><div class="line">&#125;;</div><div class="line">memorySelect.onchange = function()&#123;</div><div class="line">mediator.changed( this );</div><div class="line">&#125;;</div><div class="line">numberInput.oninput = function()&#123;</div><div class="line">mediator.changed( this );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>注意：代码来源于--腾讯.曾探《JavaScript设计模式与开发实践》，但能很好的说明中介者模式在js实际项目中的应用。说明：这里共有手机颜色、手机内存、手机数量的选择和展示共6个对象，和一个中介者对象。    中介者必须获得这6个对象的应用，当每个对象发生变化时都需要通知中介者，中介者再来执行具体操作。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/linhongyong/article/details/53439723" target="_blank" rel="external">js之中介模式</a><br>    <a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="external">wiki-MVC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，
所有的相关对象都通
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-代理模式</title>
    <link href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/15/js设计模式-代理模式/</id>
    <published>2017-10-15T12:24:36.000Z</published>
    <updated>2017-10-15T13:53:17.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><pre><code>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。    代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；举例：    图片预加载、图片懒加载、    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、    缓存代理（缓存请求结果、计算结果）</code></pre><h1 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 先实现具体的两个算法</div><div class="line">const mult = function() &#123;</div><div class="line">let a = 1;</div><div class="line">for (let i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">a *= arguments[i];</div><div class="line">&#125;</div><div class="line">return a;</div><div class="line">&#125;;</div><div class="line">const plus = function() &#123;</div><div class="line">let a = 0;</div><div class="line">for (let i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">a += arguments[i];</div><div class="line">&#125;</div><div class="line">return a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建缓存代理</div><div class="line">const createProxyFactory = function(fn) &#123;</div><div class="line">let cache = &#123;&#125;; // 保存计算的结果</div><div class="line">// 使用闭包在内存中保留对cache的引用</div><div class="line">return function() &#123;</div><div class="line">let args = Array.from(arguments).join(&apos;,&apos;); // 将所有参数转化为字符串作为缓存的 key</div><div class="line">if (args in cache) &#123;</div><div class="line">return cache[args];</div><div class="line">&#125; else &#123;</div><div class="line">return cache[args] = fn.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用代理对象</div><div class="line">const proxyMult = createProxyFactory(mult);</div><div class="line">const proxyPlus = createProxyFactory(plus);</div><div class="line">console.log(proxyMult(1,2,3,4)); // 24</div><div class="line">console.log(proxyPlus(1,2,3,4)); // 10</div></pre></td></tr></table></figure>说明：这里每次进行同类的计算时（乘法和加法两类），先判断缓存对象cache中是否存在该参数连接成的字符串作为key的属性。如果有，则直接从cache中读取，否则就进行计算并保存其结果。</code></pre><h1 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h1><pre><code>虚拟代理：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建例：使用虚拟代理实现图片懒加载下面以虚拟代理来说明：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 本体对象</div><div class="line">const imgFunc = (function() &#123;</div><div class="line">const imgNode = document.createElement(&apos;img&apos;);</div><div class="line">document.body.appendChild(imgNode);</div><div class="line">return &#123;</div><div class="line">setSrc(src)&#123;</div><div class="line">imgNode.src = src;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 代理对象</div><div class="line">const proxyImage = (function() &#123;</div><div class="line">const img = new Image();</div><div class="line">img.onload = function() &#123;</div><div class="line">imgFunc.setSrc(this.src);</div><div class="line">&#125;;</div><div class="line">return &#123;</div><div class="line">setSrc(src)&#123;</div><div class="line">imgFunc.setSrc(&apos;./loading.gif&apos;);</div><div class="line">img.src = src;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 使用代理对象</div><div class="line">proxyImage.setSrc(&apos;./reality.png&apos;);</div></pre></td></tr></table></figure>说明：图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。这里讲述一下代理对象做了那些事：    1.创建了一个 Image 对象，并为其绑定了 onload 事件。    2.将 imgNode 先设置为 &apos;./loading.gif&apos; 加载的菊花图。    3.当 Image 对象加载完真实的图片，也就是上文的 &apos;./reality.png&apos; ,将 imgNode 设置为 &apos;./reality.png&apos;。 </code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/shamoguying1140/p/3169206.html" target="_blank" rel="external">js设计模式（9）—代理模式</a><br>    <a href="https://juejin.im/post/59df4f74f265da430f311909" target="_blank" rel="external">JavaScript设计模式</a><br>    <a href="http://blog.csdn.net/hi_xiexialing/article/details/54605065" target="_blank" rel="external"> js用高阶函数动态创建缓存代理</a></p><p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4722696.html" target="_blank" rel="external">理解javascript中的策略模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
    代理对象和本体对象实现了同样的接口，并
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-策略模式</title>
    <link href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/15/js设计模式-策略模式/</id>
    <published>2017-10-15T11:11:08.000Z</published>
    <updated>2017-10-15T12:23:32.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><pre><code>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。举例：表单效验（是否为空、长度、手机号、邮箱等等）    计算年终奖（工资、效绩）下面以年终将做说明：比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 一组策略类封装具体的算法</div><div class="line">const Bouns = &#123;</div><div class="line">A (salary)&#123;</div><div class="line">return salary * 4;</div><div class="line">&#125;,</div><div class="line">B (salary)&#123;</div><div class="line">return salary * 3;</div><div class="line">&#125;,</div><div class="line">C (salary)&#123;</div><div class="line">return salary * 2;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(Bouns);</div><div class="line"></div><div class="line">/*</div><div class="line">* 计算年终奖 环境类Context</div><div class="line">* @param &#123;String&#125; A 效绩等级</div><div class="line">* @param &#123;Number&#125; 10000 每月工资</div><div class="line">* @returns &#123;Number&#125; 40000 年终奖</div><div class="line">*/</div><div class="line">const calculateBouns = function (type, salary)&#123;</div><div class="line">return Bouns[type](salary);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 测试年终奖计算方式</div><div class="line">const demo1 = calculateBouns(&apos;A&apos;, 10000);</div><div class="line">const demo2 = calculateBouns(&apos;B&apos;, 80000);</div><div class="line">console.log(demo1, demo2); // 40000, 240000</div></pre></td></tr></table></figure>说明：策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，而算法的实现是根据绩效对应不同的绩效规则；一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，随后把请求委托给某一个策略类。复合开放-封闭原则，可变的部分为策略类（一组算法），不变的部分为执行具体算法的方式。</code></pre><h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">// 这里我们实现一组策略类封装具体的验证规则</div><div class="line">const strategy = &#123;</div><div class="line">// 是否为空</div><div class="line">isNotEmpty (value, errorMsg)&#123;</div><div class="line">if (value === &apos;&apos;) &#123;</div><div class="line">return errorMsg;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">// 最小长度</div><div class="line">minLength (value, errorMsg, length)&#123;</div><div class="line">if (value.length &lt; length) &#123;</div><div class="line">return errorMsg;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">// 手机号码格式</div><div class="line">mobileFormat (value,errorMsg)&#123;</div><div class="line">if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;</div><div class="line">return errorMsg;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(strategy);</div><div class="line"></div><div class="line">var Validator = function()&#123;</div><div class="line">this.cache = [];  // 保存效验规则</div><div class="line">&#125;;</div><div class="line">Validator.prototype.add = function(dom,rules) &#123;</div><div class="line">var self = this;</div><div class="line">for(var i = 0, rule; rule = rules[i++]; )&#123;</div><div class="line">(function(rule)&#123;</div><div class="line">var strategyAry = rule.strategy.split(&quot;:&quot;);</div><div class="line">var errorMsg = rule.errorMsg;</div><div class="line">self.cache.push(function()&#123;</div><div class="line">var strategy = strategyAry.shift();</div><div class="line">strategyAry.unshift(dom.value);</div><div class="line">strategyAry.push(errorMsg);</div><div class="line">return strategys[strategy].apply(dom,strategyAry);</div><div class="line">&#125;);</div><div class="line">&#125;)(rule);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Validator.prototype.start = function()&#123;</div><div class="line">for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;</div><div class="line">var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息</div><div class="line">if(msg) &#123;</div><div class="line">return msg;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">// 代码调用</div><div class="line">var registerForm = document.getElementById(&quot;registerForm&quot;);</div><div class="line">var validateFunc = function()&#123;</div><div class="line">var validator = new Validator(); // 创建一个Validator对象</div><div class="line">/* 添加一些效验规则 */</div><div class="line">validator.add(registerForm.userName,[</div><div class="line">&#123;strategy: &apos;isNotEmpty&apos;,errorMsg:&apos;用户名不能为空&apos;&#125;,</div><div class="line">&#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;用户名长度不能小于6位&apos;&#125;</div><div class="line">]);</div><div class="line">validator.add(registerForm.password,[</div><div class="line">&#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;密码长度不能小于6位&apos;&#125;,</div><div class="line">]);</div><div class="line">validator.add(registerForm.phoneNumber,[</div><div class="line">&#123;strategy: &apos;mobileFormat&apos;,errorMsg:&apos;手机号格式不正确&apos;&#125;,</div><div class="line">]);</div><div class="line">var errorMsg = validator.start(); // 获得效验结果</div><div class="line">return errorMsg; // 返回效验结果</div><div class="line">&#125;;</div><div class="line">// 点击确定提交</div><div class="line">registerForm.onsubmit = function()&#123;</div><div class="line">var errorMsg = validateFunc();</div><div class="line">if(errorMsg)&#123;</div><div class="line">alert(errorMsg);</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>说明：此处代码来源于--腾讯.曾探的《javascript设计模式》，这能很好的说明策略模式的用途。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4722696.html" target="_blank" rel="external">理解javascript中的策略模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
举例：表单效验（是否为空、长度、手机
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-单例模式</title>
    <link href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/15/js设计模式-单例模式/</id>
    <published>2017-10-15T08:12:31.000Z</published>
    <updated>2017-10-15T09:58:46.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><pre><code>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。    在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。举例：模态框、登录控件、注销控件下面均以登录模态框做说明</code></pre><h1 id="引入代理实现单例模式"><a href="#引入代理实现单例模式" class="headerlink" title="引入代理实现单例模式"></a>引入代理实现单例模式</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var CreateDiv = function(html) &#123;</div><div class="line">this.html = html;</div><div class="line">this.init();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CreateDiv.prototype.init = function() &#123;</div><div class="line">var div = document.createElement(&apos;div&apos;);</div><div class="line">div.innerHTML = this.html;</div><div class="line">document.body.appendChild(div);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var ProxySingletonCreateDiv = (function() &#123;</div><div class="line">var instance;</div><div class="line">return function(html) &#123;</div><div class="line">if (!instance) &#123;</div><div class="line">instance = new CreateDiv(html);</div><div class="line">&#125;</div><div class="line">return instance;</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var a = new ProxySingletonCreateDiv(&apos;seven1&apos;);</div><div class="line">var b = new ProxySingletonCreateDiv(&apos;seven2&apos;);</div><div class="line"></div><div class="line">console.log(a === b); // true</div></pre></td></tr></table></figure>说明：我们负责管理单例的逻辑移到了代理类ProxySingletonCreateDiv中。这样一来，CreateDiv就变成了一个普通的类，他跟ProxySingletonCreateDiv组合起来可以达到单例模式的效果。</code></pre><h1 id="通用的单例模式"><a href="#通用的单例模式" class="headerlink" title="通用的单例模式"></a>通用的单例模式</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 通用的单例验证方法</div><div class="line">const getSingle = function (fn)&#123;</div><div class="line">let result;</div><div class="line">return function ()&#123;</div><div class="line">return result || (result = fn.apply(this, arguments));</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建登录模态框</div><div class="line">const createLoginLayer = function ()&#123;</div><div class="line">const div = document.createElement(&apos;div&apos;);</div><div class="line">div.innerHTML = &apos;我是登录模态框&apos;;</div><div class="line">document.body.appendChild(div);</div><div class="line">return div;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 为登录模态框使用单例模式</div><div class="line">const createSingleLoginLoyer = getSingle(createLoginLayer);</div><div class="line">const loginLayer1 = createSingleLoginLoyer(); // 第一个登录模态框</div><div class="line">const loginLayer2 = createSingleLoginLoyer(); // 还是第一个登录模态框</div><div class="line"></div><div class="line">console.log(loginLayer1 === loginLayer2); // true</div></pre></td></tr></table></figure>这时不管你执行多少次 createSingleLoginLoyer() 方法，都只会生产一个 div 节点。我们的通用单例模式就完成了。    </code></pre><h1 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h1><pre><code>定义：惰性单例指的是在需要的时候才创建对象的实例。以创建登录模态框为例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const createLoginLayer = (function ()&#123;</div><div class="line">let div;</div><div class="line">return function ()&#123;</div><div class="line">if (!div) &#123;</div><div class="line">div = document.createElement(&apos;div&apos;);</div><div class="line">div.innerHTML = &apos;我是登录模态框&apos;;</div><div class="line">&#125;</div><div class="line">return div;</div><div class="line">&#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 在点击按钮时才创建节点（惰性）</div><div class="line">document.getElementById(&apos;login-btn&apos;).onclick = function ()&#123;</div><div class="line">var loginLayer = createLoginLayer();</div><div class="line">loginLayer.style.display = &apos;block&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>这里的对惰性单例的实现主要是只有单例了网页上的登录按钮，才会去创建，登录框的dom节点，并且只是创建一次。</code></pre><blockquote><p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000006049548" target="_blank" rel="external">JavaScript设计模式—-单例模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html" target="_blank" rel="external">设计模式之单例模式</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-工厂模式</title>
    <link href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/10/15/js设计模式-工厂模式/</id>
    <published>2017-10-15T02:07:51.000Z</published>
    <updated>2017-10-15T08:58:21.223Z</updated>
    
    <content type="html"><![CDATA[<p>从事前端开发已经有几年了，也经常使用一些设计模式，但是对一些设计模式并不能很好的说出名字以及使用场景。<br>现利用周末闲暇事件来好好整理一下JS中常用的设计模式,如有不正确的地方，还望指出，谢谢！</p><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><pre><code>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。 举例：计算器（加、减、乘、除）    自行车售卖（山地、公路）    饮料机（咖啡、牛奶、水）    RPG中职业（战士、法师、射手）这里就以RPG中职业（战士、法师、射手）来做说明：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">// 先创建各个角色的构造函数</div><div class="line">function  Warrior() &#123;</div><div class="line">this.skill = &apos;回血&apos;;</div><div class="line">this.blood = 150; // 初始化生命值</div><div class="line">this.hit = 8; // 普通攻击伤害</div><div class="line">// 其他特有属性和方法比如生命值</div><div class="line">console.log(this);</div><div class="line">&#125;</div><div class="line">function  Mage() &#123;</div><div class="line">this.skill = &apos;冰冻&apos;;</div><div class="line">this.blood = 120; // 初始化生命值</div><div class="line">this.hit = 3; // 普通攻击伤害</div><div class="line">// 其他特有属性和方法</div><div class="line">console.log(this);</div><div class="line">&#125;</div><div class="line">function  Archer() &#123;</div><div class="line">this.skill = &apos;消耗&apos;;</div><div class="line">this.blood = 110; // 初始化生命值</div><div class="line">this.hit = 10; // 普通攻击伤害</div><div class="line">// 其他特有属性和方法</div><div class="line">console.log(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 工厂对象 可以是普通对象是的方法 和 构造函数，这里使用前者</div><div class="line">const RoleFactory = &#123;</div><div class="line">createRole (role) &#123;</div><div class="line">let roler;</div><div class="line">switch (role) &#123;</div><div class="line">case &apos;战士&apos;:</div><div class="line">roler = new Warrior();</div><div class="line">break;</div><div class="line">case &apos;法师&apos;:</div><div class="line">roler = new Mage();</div><div class="line">break;</div><div class="line">case &apos;射手&apos;:</div><div class="line">roler = new Archer();</div><div class="line">break;</div><div class="line">// 后续扩展角色直接追加选择语句和添加角色构造函数</div><div class="line">defaulr: </div><div class="line">roler = new Warrior();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(RoleFactory); // 冻结该对象，防止他人操作</div><div class="line"></div><div class="line">// 创建各个角色的实例</div><div class="line">var warrior1 = RoleFactory.createRole(&apos;战士&apos;); // 创建一个战士</div><div class="line">var mage1 = RoleFactory.createRole(&apos;法师&apos;); // 创建一个法师</div><div class="line">var arche1 = RoleFactory.createRole(&apos;射手&apos;); // 创建一个射手</div></pre></td></tr></table></figure><p>其实我们还可以这样设计工厂处理函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const RoleFactory = function (role) &#123;</div><div class="line">return new role ();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var warrior1 = RoleFactory(Warrior); // 创建一个战士</div><div class="line">var mage1 = RoleFactory(Mage); // 创建一个法师</div><div class="line">var arche1 = RoleFactory(Archer); // 创建一个射手</div></pre></td></tr></table></figure></p><p>上面输出的结果<br><img src="http://oxpnrlb4j.bkt.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%BE%93%E5%87%BA.png" alt="输出结果"></p><h1 id="什么时候使用工厂模式"><a href="#什么时候使用工厂模式" class="headerlink" title="什么时候使用工厂模式"></a>什么时候使用工厂模式</h1><ol><li>对象的构建十分复杂</li><li>需要依赖具体环境创建不同实例</li><li>处理大量具有相同属性的小对象<blockquote><p>   参考文档：<br><a href="http://www.cnblogs.com/coiorz/p/4806550.html" target="_blank" rel="external">JS设计模式之工厂模式</a><br><a href="http://www.cnblogs.com/myzy/p/5240457.html" target="_blank" rel="external">js之简单工厂模式</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从事前端开发已经有几年了，也经常使用一些设计模式，但是对一些设计模式并不能很好的说出名字以及使用场景。&lt;br&gt;现利用周末闲暇事件来好好整理一下JS中常用的设计模式,如有不正确的地方，还望指出，谢谢！&lt;/p&gt;
&lt;h1 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OSI七层与TCP/IP五层网络架构</title>
    <link href="https://fanerge.github.io/2017/10/14/OSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    <id>https://fanerge.github.io/2017/10/14/OSI七层与TCP-IP五层网络架构/</id>
    <published>2017-10-14T12:04:20.000Z</published>
    <updated>2017-10-15T02:09:26.559Z</updated>
    
    <content type="html"><![CDATA[<p>还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，<br>从参加工作一直做的WEB前端开发，对这方面知识也不是太需要。<br>但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol><li>OSI：开放系统互连参考模型 (Open System Interconnect 简称OSI）。</li><li>TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li><li>IP：网络之间互连的协议（IP）是Internet Protocol的外语缩写，中文缩写为“网协”。</li><li>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。</li><li>HTTPS：HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</li></ol><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><pre><code>OSI七层结构--每层的解释</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.jpg" alt="OSI七层结构"><br>    OSI七层结构–每层结构的功能<br><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="OSI七层结构"></p><h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><pre><code>OSI七层模型与TCP/IP五层模型的关系</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.png" alt="TCP/IP五层模型"><br>    OSI七层模型–每层的设备<br><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E8%AE%BE%E5%A4%87.jpg" alt="各层对应的设备"></p><h1 id="对各层的详细说明"><a href="#对各层的详细说明" class="headerlink" title="对各层的详细说明"></a>对各层的详细说明</h1><ol><li>第一层是物理层（PhysicalLayer)，<br>规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。<br>具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；<br>电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等；<br>功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；<br>规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。<br>在这一层，数据的单位称为比特（bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。</li><li>第二层是数据链路层<br>在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，<br>并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。<br>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br>在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</li><li>第三层是网络层<br>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。<br>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。<br>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。<br>如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。<br>IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。<br>地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。<br>网络层协议的代表包括：IP、IPX、RIP、OSPF等。</li><li>第四层是处理信息的传输层<br>第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，<br>TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。<br>这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。<br>第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。<br>所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。<br>传输层协议的代表包括：TCP、UDP、SPX等。</li><li>第五层是会话层<br>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，<br>而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。<br>如服务器验证用户登录便是由会话层完成的。</li><li>第六层是表示层<br>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，<br>转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。<br>数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li><li>第七层应用层<br>应用层为操作系统或网络应用程序提供访问网络服务的接口。<br>应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。</li></ol><blockquote><p>   参考文档<br>    <a href="https://www.2cto.com/net/201310/252965.html" target="_blank" rel="external">OSI七层与TCP/IP五层网络架构详解</a><br>    <a href="http://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="external">OSI七层模型与TCP/IP五层模型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，&lt;br&gt;从参加工作一直做的WEB前端开发，对这方面知识也不是太需要。&lt;br&gt;但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。&lt;/p&gt;
&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释
      
    
    </summary>
    
      <category term="通信协议" scheme="https://fanerge.github.io/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="OSI" scheme="https://fanerge.github.io/tags/OSI/"/>
    
      <category term="TCP/IP" scheme="https://fanerge.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计指南</title>
    <link href="https://fanerge.github.io/2017/10/13/RESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    <id>https://fanerge.github.io/2017/10/13/RESTful-API-设计指南/</id>
    <published>2017-10-13T13:21:51.000Z</published>
    <updated>2017-10-14T09:55:41.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTful-API-的产生"><a href="#RESTful-API-的产生" class="headerlink" title="RESTful API 的产生"></a>RESTful API 的产生</h2><pre><code>当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信，在这种情况下RESTful API产生了。</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><pre><code>HTTP、HTTPS 应用层协议。 联网的设备 和 服务器之前的通信。</code></pre><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ol><li>API专用域名<br><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></li><li>API放在主域名<br><a href="https://example.org/api/" target="_blank" rel="external">https://example.org/api/</a></li></ol><h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><pre><code>将API的版本放入URL中。https://api.example.com/v1</code></pre><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote><p>   路径又称”终点”（endpoint），表示API的具体网址。<br>    在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>    举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://api.example.com/v1/zoos</div><div class="line">https://api.example.com/v1/animals</div><div class="line">https://api.example.com/v1/employees</div></pre></td></tr></table></figure></p></blockquote><h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><pre><code>对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</code></pre><ol><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。    </li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）:从服务器删除资源。<br>不常用的两个动词</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的那些属性是客户端可以改变的。<br>动物园管理系统举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /zoos: 列出所有动物园。</div><div class="line">POST /zoos: 新建一个动物园（动物园的信息的请求体中）。</div><div class="line">GET /zoos/ID: 获取某个动物园的信息。</div><div class="line">PUT /zoos/ID: 更新某个指定动物园的信息（提供该动物园的全部信息）。</div><div class="line">PATCH /zoos/ID: 更新某个动物园的信息（提供该动物园的部分信息）。</div><div class="line">DELETE /zoos/ID: 删除某个动物园。</div><div class="line">GET /zoos/ID/animals: 列出某个指定动物园的所有动物。</div><div class="line">DELETE /zoos/ID/animals/ID: 删除某个动物园的指定动物。</div></pre></td></tr></table></figure></li></ol><h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><pre><code>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">?limit=10：指定返回记录的数量</div><div class="line">?offset=10：指定返回记录的开始位置。</div><div class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</div><div class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</div><div class="line">?animal_type_id=1：指定筛选条件</div></pre></td></tr></table></figure>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</code></pre><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote><p>   服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</div><div class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</div><div class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</div><div class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</div><div class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</div><div class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</div><div class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</div><div class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</div><div class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</div><div class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</div><div class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</div><div class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</div></pre></td></tr></table></figure></p></blockquote><pre><code>状态码的完全列表参见[w3c](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。</code></pre><h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><pre><code>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">error: &quot;Invalid API key&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote><p>   针对不同操作，服务器向用户返回的结果应该符合以下规范。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /collection：返回资源对象的列表（数组）</div><div class="line">GET /collection/resource：返回单个资源对象</div><div class="line">POST /collection：返回新生成的资源对象</div><div class="line">PUT /collection/resource：返回完整的资源对象</div><div class="line">PATCH /collection/resource：返回完整的资源对象</div><div class="line">DELETE /collection/resource：返回一个空文档</div></pre></td></tr></table></figure></p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>（1）API的身份认证应该使用OAuth 2.0框架。（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RESTful-API-的产生&quot;&gt;&lt;a href=&quot;#RESTful-API-的产生&quot; class=&quot;headerlink&quot; title=&quot;RESTful API 的产生&quot;&gt;&lt;/a&gt;RESTful API 的产生&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;当前的发展趋势，就是
      
    
    </summary>
    
      <category term="服务端" scheme="https://fanerge.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js代码规范</title>
    <link href="https://fanerge.github.io/2017/10/12/js%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://fanerge.github.io/2017/10/12/js代码规范/</id>
    <published>2017-10-12T12:56:39.000Z</published>
    <updated>2017-10-12T13:02:07.327Z</updated>
    
    <content type="html"><![CDATA[<p>Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>基本类型：直接存取基本类型。<br>String 字符串<br>Number 数值<br>Boolean 布尔类型<br>null<br>undefined</li><li>复制类型：通过引用的方式存取复杂类型。<br>Object 对象<br>Array 数组<br>Function 函数<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2></li><li>对不可变的引用使用 const 避免使用 var。<br>  const 声明的变量不可以重新赋值，而 var 可以。</li><li>对可变的引用使用 let 避免使用 var。</li><li>注意 let 和 const 都是块级作用域。<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li><li>使用字面值创建对象。</li><li>如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。</li><li>使用同义词替换需要使用的保留字。</li><li><p>创建有动态属性名的对象时，使用可被计算的属性名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getKey(k) &#123;</div><div class="line">return `a key named $&#123;k&#125;`;</div><div class="line">&#125;</div><div class="line">const obj = &#123;</div><div class="line">id: 5,</div><div class="line">name: &apos;San Francisco&apos;,</div><div class="line">[getKey(&apos;enabled&apos;)]: true,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>使用对象方法的简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const atom = &#123;</div><div class="line">  value: 1,</div><div class="line">  // 方法简写</div><div class="line">  addValue(value) &#123;</div><div class="line">return atom.value + value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>使用对象属性值的简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const lukeSkywalker = &apos;Luke Skywalker111&apos;;</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">lukeSkywalker,</div><div class="line">&#125;;</div><div class="line">console.log(obj.lukeSkywalker); // &apos;Luke Skywalker111&apos;</div></pre></td></tr></table></figure></li><li><p>在对象属性声明前把简写的属性分组（也就是说把简写属性放在一起）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li><li>使用字面值创建数组。</li><li><p>向数组添加元素时使用 Arrary#push 替代直接赋值。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const someStack = [];</div><div class="line"></div><div class="line">// bad</div><div class="line">someStack[someStack.length] = &apos;abracadabra&apos;;</div><div class="line"></div><div class="line">// good</div><div class="line">someStack.push(&apos;abracadabra&apos;);</div><div class="line">```</div><div class="line">3.使用拓展运算符 ... 复制数组。</div></pre></td></tr></table></figure><p>let array = [‘1’,’2’];<br>console.log([…array]);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.使用 Array#from 把一个类数组对象转换成数组。</div></pre></td></tr></table></figure><p>const foo = document.querySelectorAll(‘.foo’);<br>const nodes = Array.from(foo);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">##解构</div><div class="line">1.使用解构存取和使用多属性对象。</div></pre></td></tr></table></figure><p>// good<br>function getFullName(obj) {<br>  const { firstName, lastName } = obj;<br>  return <code>${firstName} ${lastName}</code>;<br>}</p><p>// best<br>  function getFullName({ firstName, lastName }) {<br>  return <code>${firstName} ${lastName}</code>;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.对数组使用解构赋值。</div></pre></td></tr></table></figure><p>const arr = [1, 2, 3, 4];<br>const [first, second] = arr;<br>console.log(first, second); // 1, 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.需要回传多个值时，使用对象解构，而不是数组解构。</div></pre></td></tr></table></figure><p>function processInput(input) {<br>  // then a miracle occurs<br>  return { left, right, top, bottom };<br>}</p><p>// 调用时只选择需要的数据<br>const { left, right } = processInput(input);</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li><li>字符串使用单引号 ‘’。 </li><li>字符串超过 80 个字节应该使用字符串连接号换行。\    </li><li>过度使用字串连接符号可能会对性能造成影响。可换用 +     </li><li>程序化生成字符串时，使用模板字符串代替字符串连接。<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li><li>使用函数声明代替函数表达式。    </li><li><p>立即调用的函数表达式 (IIFE)    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(() =&gt; &#123;</div><div class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></li><li><p>永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。<br>浏览器允许你这么做，但它们的解析表现不一致。<br>可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let test;</div><div class="line">if (currentUser) &#123;</div><div class="line">  test = () =&gt; &#123;</div><div class="line">console.log(&apos;Yup.&apos;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。</p></li><li>不要使用 arguments。可以选择 rest 语法 … 替代。</li><li><p>直接给函数的参数指定默认值，不要使用一个变化的函数参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function handleThings(opts = &#123;&#125;) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>直接给函数参数赋值时需要避免副作用。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2></li><li><p>当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].map((x) =&gt; &#123;</div><div class="line">return x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li><li><p>如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。<br>如果不是，那就不要省略。</p><h2 id="Classes-和-Constructors"><a href="#Classes-和-Constructors" class="headerlink" title="Classes 和 Constructors"></a>Classes 和 Constructors</h2></li><li><p>总是使用 class。避免直接操作 prototype 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// good</div><div class="line">class Queue &#123;</div><div class="line">constructor(contents = []) &#123;</div><div class="line">  this._queue = [...contents];</div><div class="line">&#125;</div><div class="line">pop() &#123;</div><div class="line">  const value = this._queue[0];</div><div class="line">  this._queue.splice(0, 1);</div><div class="line">  return value;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var demo = new Queue([1, 2, 3]);</div><div class="line">console.log(demo.pop()); // 1</div></pre></td></tr></table></figure></li><li><p>使用 extends 继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class PeekableQueue extends Queue &#123;</div><div class="line">constructor (args) &#123;</div><div class="line">super(args);</div><div class="line">&#125;</div><div class="line">peek() &#123;</div><div class="line">return this._queue[0];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>方法可以返回 this 来帮助链式调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">jump() &#123;</div><div class="line">this.jumping = true;</div><div class="line">return this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setHeight(height) &#123;</div><div class="line">this.height = height;</div><div class="line">return this;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const luke = new Jedi();</div><div class="line">luke.jump()</div><div class="line">.setHeight(20);</div></pre></td></tr></table></figure></li><li><p>可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">constructor(options = &#123;&#125;) &#123;</div><div class="line">this.name = options.name || &apos;no name&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName() &#123;</div><div class="line">return this.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">toString() &#123;</div><div class="line">return `Jedi - $&#123;this.getName()&#125;`;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol><li><p>总是使用模组 (import/export) 而不是其他非标准模块系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ok</div><div class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line">// best</div><div class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default es6;</div></pre></td></tr></table></figure></li><li><p>不要使用通配符 import。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">import * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div><div class="line"></div><div class="line">// good</div><div class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div></pre></td></tr></table></figure></li><li><p>不要从 import 中直接 export。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default es6;</div></pre></td></tr></table></figure></li></ol><h2 id="Iterators-amp-Generators"><a href="#Iterators-amp-Generators" class="headerlink" title="Iterators &amp; Generators"></a>Iterators &amp; Generators</h2><ol><li>不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const numbers = [1, 2, 3, 4, 5];</div><div class="line"></div><div class="line">// good</div><div class="line">let sum = 0;</div><div class="line">numbers.forEach((num) =&gt; sum += num);</div><div class="line"></div><div class="line">// best (use the functional force)</div><div class="line">const sum = numbers.reduce((total, num) =&gt; total + num, 0);</div></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>普通属性使用 . 来访问对象的属性。    </li><li>当通过变量访问属性时使用中括号 []。<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。</li><li><p>单独声明每一个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const items = getItems();</div><div class="line">const goSportsTeam = true;</div><div class="line">const dragonball = &apos;z&apos;;</div></pre></td></tr></table></figure></li><li><p>将所有的 const 和 let 分组。</p></li><li>在你需要的地方给变量赋值，但请把它们放在一个合理的位置。<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2></li><li>var 声明会被提升至该作用域的顶部，但它们赋值不会提升。<br>let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。</li><li>匿名函数表达式的变量名会被提升，但函数内容并不会。</li><li>命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。</li><li>函数声明的名称和函数体都会被提升。<h2 id="比较运算符-amp-等号"><a href="#比较运算符-amp-等号" class="headerlink" title="比较运算符 &amp; 等号"></a>比较运算符 &amp; 等号</h2></li><li>优先使用 === 和 !== 而不是 == 和 !=。</li><li>条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则<br>对象 被计算为 true<br>Undefined 被计算为 false<br>Null 被计算为 false<br>布尔值 被计算为 布尔的值<br>数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true<br>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</li><li>使用简写。<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2></li><li>使用大括号包裹所有的多行代码块。</li><li>如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li><li>使用 /<em>* … </em>/ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。<br>配合 JSDoc 完美</li><li>使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。<br>在注释前插入空行。</li><li>给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。<br>这将有别于常见的注释，因为它们是可操作的。<br>使用FIXME – need to figure this out 或者 TODO – need to implement。</li><li><p>使用 // FIXME: 标注问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Calculator &#123;</div><div class="line">constructor() &#123;</div><div class="line">// FIXME: shouldn&apos;t use a global here</div><div class="line">total = 0;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用 // TODO: 标注问题的解决方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Calculator &#123;</div><div class="line">  constructor() &#123;</div><div class="line">// TODO: total should be configurable by an options param</div><div class="line">this.total = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ol><li>使用 2 个空格作为缩进。</li><li>在花括号前放一个空格。</li><li>在控制语句（if、while 等）的小括号前放一个空格。<br>在函数调用及声明中，不在函数的参数列表前加空格。</li><li>使用空格把运算符隔开。</li><li>在文件末尾插入一个空行。</li><li>在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。</li><li>在块末和新语句前插入空行。<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2></li><li>行首不要加逗号。</li><li>增加结尾的逗号: 需要。<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2></li><li>每个语句都使用分号。</li><li>IIFE 函数前添加分号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// good (防止函数在两个 IIFE 合并时被当成一个参数)</div><div class="line">;(() =&gt; &#123;</div><div class="line">  const name = &apos;Skywalker&apos;;</div><div class="line">  return name;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li>在语句开始时执行类型转换。</li><li>显式转换字符串。<br>const reviewScore = 9;<br>const totalScore = String(reviewScore);</li><li><p>对数字使用 parseInt 转换，并带上类型转换的基数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const val = Number(inputValue);</div><div class="line"></div><div class="line">const val = parseInt(inputValue, 10);</div></pre></td></tr></table></figure></li><li><p>如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</p></li><li>小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数。<br>位操作处理大于 32 位的整数值时还会导致意料之外的行为。</li><li>转换为buer。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const age = 0;</div><div class="line">const hasAge = Boolean(age);</div><div class="line">const hasAge = !!age;</div></pre></td></tr></table></figure></li></ol><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>避免单字母命名。命名应具备描述性。</li><li>使用驼峰式命名对象、函数和实例。</li><li>使用帕斯卡（大驼峰）式命名构造函数或类。</li><li>使用下划线 _ 开头命名私有属性。</li><li><p>别保存 this 的引用。使用箭头函数或 Function#bind。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  return () =&gt; &#123;</div><div class="line">console.log(this);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">return function() &#123;</div><div class="line">console.log(this);</div><div class="line">&#125;.bind(this)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// file contents</div><div class="line">class CheckBox &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">export default CheckBox;</div><div class="line"></div><div class="line">import CheckBox from &apos;./CheckBox&apos;;</div></pre></td></tr></table></figure></li><li><p>当你导出默认的函数时使用驼峰式命名。<br>你的文件名必须和函数名完全保持一致。</p></li><li>当你导出单例、函数库、空对象时使用帕斯卡式命名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const AirbnbStyleGuide = &#123;</div><div class="line">  es6: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default AirbnbStyleGuide;</div></pre></td></tr></table></figure></li></ol><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><ol><li>属性的存取函数不是必须的。    </li><li><p>如果你需要存取函数时使用 getVal() 和 setVal(‘hello’)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dragon.getAge();</div><div class="line">dragon.setAge(25);</div></pre></td></tr></table></figure></li><li><p>如果属性是布尔值，使用 isVal() 或 hasVal()。</p></li><li>创建 get() 和 set() 函数是可以的，但要保持一致。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">  constructor(options = &#123;&#125;) &#123;</div><div class="line">const lightsaber = options.lightsaber || &apos;blue&apos;;</div><div class="line">this.set(&apos;lightsaber&apos;, lightsaber);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set(key, val) &#123;</div><div class="line">this[key] = val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get(key) &#123;</div><div class="line">return this[key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。<br>这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).trigger(&apos;listingUpdated&apos;, &#123; listingId : listing.id &#125;);</div><div class="line"></div><div class="line">$(this).on(&apos;listingUpdated&apos;, function(e, data) &#123;</div><div class="line">  // do something with data.listingId</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li></ol><h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><ol><li>使用 $ 作为存储 jQuery 对象的变量名前缀。<br>const $sidebar = $(‘.sidebar’);</li><li><p>缓存 jQuery 查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setSidebar() &#123;</div><div class="line">  const $sidebar = $(&apos;.sidebar&apos;);</div><div class="line">  $sidebar.hide();</div><div class="line"></div><div class="line">  $sidebar.css(&#123;</div><div class="line">&apos;background-color&apos;: &apos;pink&apos;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>对 DOM 查询使用层叠 $(‘.sidebar ul’) 或 父元素 &gt; 子元素 $(‘.sidebar &gt; ul’)。</p></li><li>对有作用域的 jQuery 对象查询使用 find。<blockquote><p>   参考文档：<br><a href="https://www.kancloud.cn/kancloud/javascript-style-guide/43153" target="_blank" rel="external">Airbnb JavaScript 代码规范（ES6）</a><br><a href="https://github.com/airbnb/javascript#airbnb-javascript-style-guide-" target="_blank" rel="external">Airbnb JavaScript Style Guide</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。&lt;/p&gt;
&lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js-读书笔记</title>
    <link href="https://fanerge.github.io/2017/10/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://fanerge.github.io/2017/10/10/深入浅出Node-js-读书笔记（下）/</id>
    <published>2017-10-10T12:17:16.000Z</published>
    <updated>2017-10-15T02:06:14.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><pre><code>常见的需求：</code></pre><ol><li>请求方法的判断（保存在报文）<br>常见的方法有：GET(查看)\POST(更新)\DELETE(删除)\PUT(新建)\CONNECT\HEAD<br>通过req.method 来判断</li><li>URL的路径解析（保存在报文）<br><a href="http://localhost:8080/a.html" target="_blank" rel="external">http://localhost:8080/a.html</a><br>通过req.url 来查找</li><li>URL中查询字符串解析（保存在报文）<br>?foo=bar&amp;baz=val<br>使用Node提供的querystring 模块处理</li><li>Cookie的解析（保存在报文）<br>网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>http 为无状态协议。<br>数据保存在客户端。</li><li>Session（会话）的需求（保存在报文）<br>数据保存在服务器端。<br>1.基于Cookie 来实现用户和数据的映射。<br>  原理：在客户端只保存口令，发送请求是通过该口令再去查找对应的数据<br>2.通过查询字符串来实现浏览器端和服务器端数据的对应。<br>  不推荐使用，风险大。<br>两种存储方式：<br>1.内存<br>2.数据工具<br>  Redis是一个支持网络、基于内存、可选持久性的键值对存储数据库。</li><li>Basic认证（保存在报文）<br>当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</li><li>数据上传<br>思路：先判断数据的格式，再通过对应的解析方法解析。<br>1.表单数据的解析<br>先判断req.headers[‘content-type’] === ‘application/x-www-formurlencoded’<br>  querystring.parse(req.rawBody);<br>2.其他格式<br>  json – application/json<br>  xml – application/xml</li><li><p>任意格式文件的上传处理<br>此时需要<form action="/upload" method="post" enctype="multipart/form-data"></form></p></li><li><p>缓存<br>YSlow中提出的缓存规则：<br>1.添加Expires 和 Cache-Control 到报文头中。<br>2.配置ETags。<br>3.让Ajax 可缓存。<br>数据上传与安全<br>1.内存限制（提交数据占用了所有内存）<br>  限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。<br>  通过流式解析，将数据导向到磁盘中，Node只保留文件路径等小数据。<br>2.CSRF<br>  Cross-Site Request Forgery（跨站点请求伪造）</p></li></ol><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><pre><code>文件路径型    静态文件：URL 的路径与网站目录的路径一致，无须转换。    动态文件：在 MVC 模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，        它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。MVC    MVC 模型的主要思想是将业务逻辑按职责分离。        控制器（Controller），一组行为的集合。        模型（Model），数据相关的操作和封装。        视图（View），视图的渲染。        1.路由解析，根据URL寻找到对应的控制器和行为。        2.行为调用相关的模型，进行数据操作。        3.数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。    路由映射    1.手工映射        正则匹配        参数解析    2.自然映射RESTful            REST Representational State Transfer （表现层状态转化）            POST /user/fanerge 修改用户信息    DELETE /user/fanerge 删除用户    PUT /user/fanerge 新建用户            GET /user/fanerge 查询用户信息        请求方法    </code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre><code>作用：middleware 来简化和隔离这些基础设施与业务逻辑之间的细节，使开发者更加关注在业务的开发。    </code></pre><p><img src="/images/middleware.png" alt="中间件工作原理"><br>    中间件设计格式（connect的设计）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var querystring = function (req, res, next) &#123;</div><div class="line">// TODO</div><div class="line">next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>使用中间件（串联多个中间件）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.use(&apos;/user/:username&apos;, querystring, cookie, session, function (req, res) &#123;</div><div class="line">// 这里处理具体的业务逻辑</div><div class="line">&#125;);</div></pre></td></tr></table></figure>异常处理    同步异常 -- try {} catch (err) {throw err}     异步异常        需要把异常传递出来        domain 模块    </code></pre><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><pre><code>内容响应    Content-Encoding: gzip    Content-Length: 21170    Content-Type: text/javascript; charset=utf-8    MIME : Multipurpose Internet Mail Extensions        附件下载：有些MIME类的资源不需要在客户端中打开它，只需要弹出并下载它即可。        Content-Disposition: inline(查看)/attachment(附件下载);        例如：Content-Disposition: attachment; filename=&apos;filename.ext&apos;; // 下载附件并为其命名    响应JSON    响应跳转    视图渲染模板    如EJS、Pug等    模板引擎        语法分解。        处理表达式。        生成待执行的语句。        与数据一起执行，生成最终字符串。    with的应用            模板安全 XSS 解决方案 转义用户的输入    模板逻辑    集成文件系统        子模板        布局视图        模板性能Bigpipe    BigPipe是一个重新设计的基础动态网页服务体系。    前端加载技术，它的提出主要是为了解决重数据页面的加载问题。    Bigpipe 的解决思路则是将页面分割成多个部分（pagelet），    先向用户输出没有数据（框架），将每个部分逐步输出到前端，    再最终渲染填充框架，完成整个网页的渲染。    这个过程中需要前端js的参与，它负责将后续输出的数据渲染到页面上。    1.页面布局框架（无数据的）。    2.后端持续性的数据输出。    3.前端渲染。        bigpipe.ready() -- 以一个key注册一个事件。        bigpipe.set() -- 触发一个事件，进行页面渲染。</code></pre><h2 id="玩转进程"><a href="#玩转进程" class="headerlink" title="玩转进程"></a>玩转进程</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><pre><code>child_process 模块创建子进程    1.spawn(): 启动一个子进程来执行命令。    2.exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，    它有一个回调函数获知子进程的状况。    3.execFile(): 启动一个子进程来执行可执行文件。    4.fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的Javascript文件模块即可。    spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，    一旦创建的进程运行超过设定的时间将会被杀死。    exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。进程间通信    message事件 绑定发送事件    send()方法 触发发送消息句柄传递    child_process.send(message, [sendHandle]);    句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。    比如句柄可以用来标识一个服务器端socket对象、客户端socket对象、UDP套接字、一个管道等。</code></pre><h3 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h3><pre><code>进程事件    message    error    exit    close    disconnect自动重启    自杀信号    负载均衡（轮叫调度）            由主进程接受链接，将其依次分发给工作进程。        cluster 模块    状态共享        第三方数据存储 通过轮询        主动通知 当数据更新时，主动通知子进程。</code></pre><h3 id="Cluster-模块"><a href="#Cluster-模块" class="headerlink" title="Cluster 模块"></a>Cluster 模块</h3><pre><code>解决多核CPU的利用率问题。Cluster 工作原理    该模块是 child_process 和 net 模块的组合应用。Cluster 事件    fork    online    listening    disconnect    exit    setup</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>测试驱动开发</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code>测试代码编写的原则1.单一职责2.接口抽象3.层次分离单元测试介绍1.断言    assert 模块    单元测试中用来保证最小单元是否正常的检测方法。    用于检查程序在运行时是否满足期望。    ok(): 判断结果是否为真。    equal(): 判断实际值余期望值是否相等。    notEqual(): 判断实际值与期望值是否不相等。    deepEqual(): 判断实际值余期望值是否深度相等（对象和数组的元素是否相等）。    notDeepEqual(): 判断实际值与期望值是否不深度相等。    strictEqual(): 判断实际值与期望值是否严格相等（===）。    notStrictEqual(): 判断实际值与期望值是否不严格相等（!==）。    throws(): 判断代码块是否抛出异常。    doesNotThrow(): 判断代码块是否没有抛出异常。    ifError(): 判断实际值是否为一个假值（null、undefined、0、&apos;&apos;、false），若实际值为真值，将抛出异常。2.测试框架    用于管理测试用例和生成测试报告。    mocha 模块    测试风格        TDD 测试驱动开发        BDD 行为驱动开发    测试报告        mocha --reporters    测试代码的文件组织    测试用例    异步测试    测试覆盖率    mock 或者 muk    私有方法的测试        var lib = rewire(&apos;../lib/index.js&apos;); // 需要测试方法所在的文件        var litmit = lib.__get__(&apos;limit&apos;); // 需要测试的方法3.工程化与自动化        工程化 -- Makefile    持续集成 -- travis-ci</code></pre><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><pre><code>负载测试、压力测试和基准测试。基准测试：（对基本的方法如Array.protoryp.map 和 for循环的比较）    benchmark 模块压力测试：（网络接口进行压力测试）    常用的工具：ab、siege、http_load基准测试驱动开发    1.写基准测试    2.写/改代码    3.收集数据    4.找出问题    5.回到第（2）步测试数据余业务数据的转换    PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。    UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。    TPS 是每秒内的事务数，比如执行了dml操作，那么相应的tps会增加；    QPS 是指每秒内查询次数，比如执行了select操作，相应的qps会增加。    QPS = PV/H (H为访问量集中的时间单位小时)。</code></pre><h2 id="产品化"><a href="#产品化" class="headerlink" title="产品化"></a>产品化</h2><pre><code>包括：工程化、架构、容灾备份、部署和运维。</code></pre><h3 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a>项目工程化</h3><pre><code>1.目录结构    Web框架：Express、Koa、Egg2.构建工具    合并静态文件、压缩文件大小、打包应用、编译模块。    Makefile         一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，        makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，        哪些文件需要重新编译，甚至于进行更复杂的功能操作，        因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。    Grunt3.编码规范    JSLint JSHint ESLint4.代码审查</code></pre><h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><pre><code>部署环境部署操作    </code></pre><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><pre><code>动静分离    静态请求用 Nginx 和 CDN 来保存启用缓存    Redis 和 Memcached多进程架构        读写分离</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code>访问日志异常日志日志与数据库分割日志</code></pre><h3 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h3><pre><code>业务逻辑型监控 和 硬件型监控监控        日志监控    响应时间    进程监控    磁盘监控    内存监控    CPU占用监控    CPU load监控    I/O负载    网络监控    应用状态监控    DNS 监控 -- 免费DNS监控服务 DNSPod    报警的实现        邮件报警 -- nodemailer 模块        短信或电话报警 监控系统的稳定性</code></pre><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><pre><code>多机器多机房容灾备份</code></pre><h3 id="异构共存"><a href="#异构共存" class="headerlink" title="异构共存"></a>异构共存</h3><h2 id="调试Node"><a href="#调试Node" class="headerlink" title="调试Node"></a>调试Node</h2><pre><code>Debugger    1.在代码中插入 debugger    2.运行 node debug demo.jsNode Inspector    1.安装 npm install -g node-inspector    2.错误堆栈</code></pre><h2 id="Node-编码规范"><a href="#Node-编码规范" class="headerlink" title="Node 编码规范"></a>Node 编码规范</h2><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><pre><code>1.空格与格式 -- 采用2个空格缩进，而不是tab缩进。2.变量声明 -- 每个变量声明都应该带var。3.空格 -- 操作符前后加空格，如+、-、*、%、/、=等4.单双引号的问题 -- 只在html标签的属性中使用双引号，其余使用单引号。    但在JSON中，严格的规范是要求使用字符串使用双引号，内容中出现双引号时需要转义。5.大括号的位置 -- 不需要另起一行6.逗号 -- 若逗号不在行结尾，前面需要一个空格。7.分号 -- 给表达式结尾添加分号。    </code></pre><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><pre><code>1.变量命名 -- 小驼峰式命名。2.方法命名 -- 小驼峰式命名，尽量采用动词或判断词汇。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var getUser = () =&gt; &#123;&#125;;</div><div class="line">var isAdmin = () =&gt; &#123;&#125;;</div></pre></td></tr></table></figure>3.类命名（构造函数和Class） -- 大驼峰式命名。4.常量命名 -- 全大写字母和下划线。        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var PINK_COLOR = &apos;pink&apos;;</div></pre></td></tr></table></figure>5.文件命名 -- 全小写字母和下划线。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">child_process.js // 普通文件</div><div class="line">_linklist.js // 私有文件</div></pre></td></tr></table></figure>6.包名 -- 不要包含 js 或 node 的字样，它们是重复的。</code></pre><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><pre><code>1.使用 === 替代 ==2.当遇到 0、undefined、null、false、&apos;&apos;假值时，不需要使用 === 或 ==。    </code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code>尽量使用 {}、[]，不要使用 new Object() 和 new Array()    </code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><pre><code>1.慎用with<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with (obj) &#123;</div><div class="line">foo = bar;</div><div class="line">&#125;</div><div class="line">// 出现4中结果：obj.foo = obj.bar; obj.foo = bar; foo = obj.bar; foo = bar;</div></pre></td></tr></table></figure>2.慎用eval()</code></pre><h3 id="数组与对象"><a href="#数组与对象" class="headerlink" title="数组与对象"></a>数组与对象</h3><pre><code>1.字面量格式 -- 结尾用逗号分隔，若分行，一行只能一个元素。2.for in 循环 -- 只能对对象使用，不能对数组使用。    for in语句以任意顺序遍历一个对象的可枚举属性（包括原型上的属性）。3.不要把数组当对象使用    </code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><pre><code>1.异步回调函数的第一个参数应该是错误指示    2.执行传入的回调函数    </code></pre><h3 id="类与模块"><a href="#类与模块" class="headerlink" title="类与模块"></a>类与模块</h3><pre><code>1.类继承（Node推荐的类继承方式）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Socket (options) &#123;</div><div class="line">stream.Stream.call(this);</div><div class="line">&#125;</div><div class="line">util.inherits(Socket, stream.Stream);</div></pre></td></tr></table></figure>2.导出 -- 所有供外部调用的方法或变量均需要挂载在exports变量上。    当需要将文件当做一个类导出时，需要通过如下方式挂载。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module.exports = Class;</div></pre></td></tr></table></figure></code></pre><h3 id="注解规范"><a href="#注解规范" class="headerlink" title="注解规范"></a>注解规范</h3><pre><code>采用 JSDoc</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><pre><code>1.冲突的解决原则 -- 入乡随俗2.给编辑器设置检测工具    3.版本控制中的hook    4.持续集成</code></pre><h2 id="搭建局域NPM仓库"><a href="#搭建局域NPM仓库" class="headerlink" title="搭建局域NPM仓库"></a>搭建局域NPM仓库</h2><blockquote><p>参考文档<br>    <a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="external">朴灵-深入浅出Node</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构建Web应用&quot;&gt;&lt;a href=&quot;#构建Web应用&quot; class=&quot;headerlink&quot; title=&quot;构建Web应用&quot;&gt;&lt;/a&gt;构建Web应用&lt;/h2&gt;&lt;h3 id=&quot;基础功能&quot;&gt;&lt;a href=&quot;#基础功能&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Object的扩展、密密封、冻结</title>
    <link href="https://fanerge.github.io/2017/10/10/Object%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%81%E5%AF%86%E5%AF%86%E5%B0%81%E3%80%81%E5%86%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/10/10/Object的扩展、密密封、冻结/</id>
    <published>2017-10-10T11:56:38.000Z</published>
    <updated>2017-10-17T13:30:45.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h2><pre><code>Object.isExtensible(obj)    判断一个对象是可扩展(是否能有新的属性添加到它)。Object.preventExtensions(obj)    可以对对象的属性进行修改和删除，不能向自身添加属性但可以向其原型添加属性。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Object.create(proto[, propertiesObject]);</div><div class="line">var obj = &#123;</div><div class="line">a: 1,</div><div class="line">b: 2</div><div class="line">&#125;;</div><div class="line">console.log(Object.isExtensible(obj)); // true</div><div class="line">Object.preventExtensions(obj);</div><div class="line">console.log(Object.isExtensible(obj)); // false</div><div class="line">// obj.a = 3; // 可以修改原有属性</div><div class="line">// delete obj.a; // 可以删除原有属性</div><div class="line">// obj.c = 3; // 不能自身添加属性</div><div class="line">console.log(obj);</div></pre></td></tr></table></figure></code></pre><h2 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h2><pre><code>Object.isSealed()    判断一个对象是密封的。Object.seal()    密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。    属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性。    将所有现有的属性标记为不可配置。现在的属性的值仍然可以改变,只要它们是可写的。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  prop: function() &#123;&#125;,</div><div class="line">  foo: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line">var o = Object.seal(obj);</div><div class="line">console.log(o === obj); // true</div><div class="line">Object.isSealed(obj); // === true</div><div class="line"></div><div class="line">obj.foo = &apos;quux&apos;; // 可以改变属性</div><div class="line"></div><div class="line">// 不能改变属性访问器，会抛出错误</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</div><div class="line">  get: function() &#123; return &apos;g&apos;; &#125;</div><div class="line">&#125;); // throws a TypeError</div><div class="line"></div><div class="line">// 不能添加新属性</div><div class="line">obj.quaxxor = &apos;the friendly duck&apos;;</div><div class="line"></div><div class="line">// 不能删除原有属性</div><div class="line">delete obj.foo;</div><div class="line"></div><div class="line">// 可以更改属性，只要它是可写的</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</div><div class="line">  value: &apos;eit&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h2><pre><code>Object.isFrozen()Object.freeze()    防止新的属性被添加到它;防止现有的属性被移除;    和防止现有的属性,或他们的可数性,可配置性,或可写性,被改变了,它还可以防止原型被改变了。    该方法返回对象处于冻结状态。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  prop: function() &#123;&#125;,</div><div class="line">  foo: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回已被冻结的对象</div><div class="line">var o = Object.freeze(obj);</div><div class="line"></div><div class="line">// o === obj; // true</div><div class="line">Object.isFrozen(obj); // === true</div><div class="line"></div><div class="line">// 改变原有属性失败</div><div class="line">obj.foo = &apos;quux&apos;; // silently does nothing</div><div class="line">// 添加属性失败</div><div class="line">obj.quaxxor = &apos;the friendly duck&apos;;</div><div class="line">// 删除原有属性失败</div><div class="line">delete obj.foo; // throws a TypeError</div><div class="line">console.log(obj);</div><div class="line"></div><div class="line">// 重新配置原有属性失败</div><div class="line">Object.defineProperty(obj, &apos;ohai&apos;, &#123; value: 17 &#125;);</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;eit&apos; &#125;);</div><div class="line"></div><div class="line">// 向原型中添加属性失败</div><div class="line">Object.setPrototypeOf(obj, &#123; x: 20 &#125;)</div><div class="line">obj.__proto__ = &#123; x: 20 &#125;</div></pre></td></tr></table></figure></code></pre><h2 id="浅冻结与深冻结"><a href="#浅冻结与深冻结" class="headerlink" title="浅冻结与深冻结"></a>浅冻结与深冻结</h2><pre><code>如该方法 MDN 的描述所述，倘若一个对象的属性是一个对象，那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结，若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">obj = &#123;</div><div class="line">internal :&#123;&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(obj);//浅冻结</div><div class="line">obj.internal.a = &quot;aValue&quot;;</div><div class="line">console.log(obj.internal.a);//&quot;aValue&quot;</div><div class="line"></div><div class="line">//想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数.</div><div class="line">function deepFreeze(o)&#123;</div><div class="line">var prop,propKey;</div><div class="line">Object.freeze(o);//首先冻结第一层对象</div><div class="line">for(propKey in o)&#123;</div><div class="line">prop = o[propKey];</div><div class="line">if(!o.hasOwnProperty(propKey) || !(typeof prop === &quot;object&quot;) || Object.isFrozen(prop))&#123;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">deepFreeze(prop);//递归</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">deepFreeze(obj);</div><div class="line">obj.internal.b = &quot;bValue&quot;;//静默失败</div><div class="line">console.log(obj.internal.b);//undefined</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000003894119" target="_blank" rel="external">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br>    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="external">MDN</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扩展特性&quot;&gt;&lt;a href=&quot;#扩展特性&quot; class=&quot;headerlink&quot; title=&quot;扩展特性&quot;&gt;&lt;/a&gt;扩展特性&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Object.isExtensible(obj)
    判断一个对象是可扩展(是否能有新的属性添加到它)。
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js-读书笔记</title>
    <link href="https://fanerge.github.io/2017/10/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://fanerge.github.io/2017/10/09/深入浅出Node-js-读书笔记（上）/</id>
    <published>2017-10-09T12:09:51.000Z</published>
    <updated>2017-10-09T15:15:42.993Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。</p><h2 id="Node-js-基础知识"><a href="#Node-js-基础知识" class="headerlink" title="Node.js 基础知识"></a>Node.js 基础知识</h2><h3 id="chrome-与-Node-工作原理"><a href="#chrome-与-Node-工作原理" class="headerlink" title="chrome 与 Node 工作原理"></a>chrome 与 Node 工作原理</h3><pre><code>chrome：HTML + JavaScript + WebKit + V8 &gt;&gt; 中间层 &gt;&gt; 网卡 + 硬盘 + 显卡 + ...Node：JavaScript + V8 &gt;&gt; 中间层（libuv）&gt;&gt; 网卡 + 硬盘 + 显卡 + ...说明：libuv 是 Node 的新跨平台抽象层，用于抽象 Windows 的 IOCP 及 Unix 的 libev。    作者打算在这个库的包含所有平台的差异性。</code></pre><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.get(&apos;url&apos;, (data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>异步是并行的基础。单线程，不适合大量计算占用 CPU 导致无法继续调用异步I/O。</code></pre><h2 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h2><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><pre><code>模块引用：    var math = require(&apos;math&apos;);    模块定义：    exports.add = () =&gt; {        var a = 1,            b = 3;        return a + b;    }exports 是 module 的属性。Node 引入模块的步骤：    路径分析    文件定位    编译执行</code></pre><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><pre><code>文件模块 &gt;&gt; 核心模块（JavaScript） &gt;&gt; 内建模块（C/C++）</code></pre><h2 id="异步I-O-1"><a href="#异步I-O-1" class="headerlink" title="异步I/O"></a>异步I/O</h2><h3 id="Node-的异步I-O"><a href="#Node-的异步I-O" class="headerlink" title="Node 的异步I/O"></a>Node 的异步I/O</h3><pre><code>Node 自身的执行模型 -- 事件循环。单线程、事件循环、观察者和I/O线程池</code></pre><h3 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h3><pre><code>定时器：setTimeout()\setInterval()process.nextTick()    在事件循环的下一次循环中调用 callback 回调函数。    效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；    与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。setImmediate()    nextTick()的回调函数执行的优先级要高于setImmediate();        process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,    I/O观察者先于check观察者.</code></pre><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>高阶函数：以函数作为参数或返回值。偏函数用法：通过指定部分参数来产生一个新的定制函数的形式就是偏函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const isType = function (type)&#123;</div><div class="line">return function (obj) &#123;</div><div class="line">return Object.prototype.toString.call(obj) == &apos;[object &apos; + type + &apos;]&apos;;</div><div class="line">&#125;; </div><div class="line">&#125;</div><div class="line">var isString = isType(&apos;String&apos;);</div></pre></td></tr></table></figure></code></pre><h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h3><pre><code>事件发布/订阅模式（事件绑定）promisegeneratorasync-await</code></pre><h3 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h3><pre><code>eventproxy[async](https://github.com/caolan/async)</code></pre><h2 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h2><h2 id="理解Buffer"><a href="#理解Buffer" class="headerlink" title="理解Buffer"></a>理解Buffer</h2><pre><code>Buffer 是一个像Array的对象，但它主要用于操作字节。Buffer 对象    var buf = new Buffer(&apos;string&apos;, &apos;utf-8&apos;);</code></pre><h3 id="Buffer-的转换"><a href="#Buffer-的转换" class="headerlink" title="Buffer 的转换"></a>Buffer 的转换</h3><pre><code>    支持的字符串编码类型：    ASCII\UTF-8\UTF-16LE/UCS-2\Base64\Binary\Hex字符串转 Buffer    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var buf = new Buffer(str, [encoding]);</div><div class="line">buf.write(string, [offset], [length], [encoding]);</div></pre></td></tr></table></figure>Buffer 转字符串buf.toString([encoding], [start], [end]);</code></pre><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>TCP 和 UDP 属于网络传输层协议，HTTP 属于应用层协议。</code></pre><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><pre><code>创建TCP 服务器端 net 模块TCP 服务的事件</code></pre><h3 id="构建UDP-服务（用户数据包协议）"><a href="#构建UDP-服务（用户数据包协议）" class="headerlink" title="构建UDP 服务（用户数据包协议）"></a>构建UDP 服务（用户数据包协议）</h3><pre><code>创建UDP套接字 dgram模块创建UDP 服务器端创建UDP 客户端UDP 套接字事件</code></pre><h3 id="构建HTTP-服务"><a href="#构建HTTP-服务" class="headerlink" title="构建HTTP 服务"></a>构建HTTP 服务</h3><pre><code>HTTP 超文本传输协议。http 模块HTTP 客户端</code></pre><h3 id="构建WebSocket-服务"><a href="#构建WebSocket-服务" class="headerlink" title="构建WebSocket 服务"></a>构建WebSocket 服务</h3><pre><code>以前的方案：Comet（彗星）技术细节为：长轮询（long-polling）或iframe流（streaming）。长轮询原理：客户端向服务器断发送请求，服务端只在超时或有数据响应时断开连接（res.end()），    客户端在接收到数据或者超时后重新发送请求。iframe流原理：iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，    然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。    通过iframe里的内容进行长时间的请求，当需要传输内容时通过调用父页面js方法来实现页面展示，以此达到comet所需要的效果。WebSocket原理：WebSocket是一种在单个TCP连接上进行全双工通讯的协议。    WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，    浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</code></pre><h3 id="网络服务与安全"><a href="#网络服务与安全" class="headerlink" title="网络服务与安全"></a>网络服务与安全</h3><pre><code>Node在网络安全上提供了3个模块</code></pre><ol><li>crypto – 主要用于加密和解密，SHA1、MD5。</li><li>tls – 类似于net模块，它是建立在TLS/SSL加密的TCP连接上。</li><li>https – 类似于http模块，他它是建立于安全的连接之上。<br>TLS/SSL<br>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构。<br>每个服务器断和客户端都有自己的公私钥。<br>公钥要来加密要传输的数据，私钥用来解密接收到的数据。<br>Node在底层采用的是openssl实现TLS/SSL。<br>数字证书：CA（Certificate Authority，数字证书认证中心）<br>HTTPS服务<br>HTTPS服务就是工作在TLS/SSL上的HTTP。<blockquote><p>参考文档<br><a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="external">朴灵-深入浅出Node</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。&lt;/p&gt;
&lt;h2 id=&quot;Node-js-基础知识&quot;&gt;&lt;a href=&quot;#Node-js-基础知识&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-总结</title>
    <link href="https://fanerge.github.io/2017/09/28/koa%E5%AD%A6%E4%B9%A0-%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/09/28/koa学习-总结/</id>
    <published>2017-09-28T12:22:32.000Z</published>
    <updated>2017-09-29T14:11:44.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个koa示例"><a href="#一个koa示例" class="headerlink" title="一个koa示例"></a>一个koa示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const koa = require(&apos;koa&apos;);</div><div class="line">const app = new koa();</div><div class="line"></div><div class="line">// 使用中间件</div><div class="line">app.use(); // @param function</div><div class="line">// 监听端口，开启服务</div><div class="line">app.listen(1314, () =&gt; &#123;</div><div class="line">console.log(&apos;success&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="Context-对象"><a href="#Context-对象" class="headerlink" title="Context 对象"></a>Context 对象</h2><pre><code>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。koa 通过 ctx.request.accepts 设置期望返回的类型内容，默认为 text/plain。        koa 通过 ctx.response.type 指定返回类型。示例：常用的格式xml、json、html、text等。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.use((ctx) =&gt; &#123;</div><div class="line">if (ctx.request.accepts(&apos;xml&apos;)) &#123;</div><div class="line">ctx.response.type = &apos;xml&apos;;</div><div class="line">ctx.response.body = &apos;&lt;data&gt;我是xml&lt;/data&gt;&apos;;</div><div class="line">&#125; else &#123;</div><div class="line">ctx.response.type = &apos;text&apos;;</div><div class="line">ctx.response.body = &apos;我是text&apos;;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">```</div><div class="line">示例：实际开发（网页模板）</div><div class="line">直接返回template.html</div></pre></td></tr></table></figure>    app.use(ctx =&gt; {      ctx.response.type = &apos;html&apos;;      ctx.response.body = fs.createReadStream(&apos;./views/template.html&apos;);    });    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">##路由</div><div class="line">通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。</div><div class="line">###原生路由</div></pre></td></tr></table></figure>    const main = ctx =&gt; {        ctx.response.type = &apos;html&apos;;      if (ctx.request.path === &apos;/&apos;) {        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;      } else if (ctx.request.path === &apos;/get&apos;) {        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Get Page&lt;/a&gt;&apos;;      } else {        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;other Page&lt;/a&gt;&apos;;      }    };    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###koa-route 模块</div></pre></td></tr></table></figure>const Koa = require(&apos;koa&apos;);const route = require(&apos;koa-route&apos;);const app = new Koa();const about = ctx =&gt; {    ctx.response.type = &apos;html&apos;;    ctx.response.body = &apos;&lt;p&gt;about page&lt;/p&gt;&apos;};const user = ctx =&gt; {    ctx.response.type = &apos;html&apos;;    ctx.response.body = &apos;&lt;p&gt;user page&lt;/p&gt;&apos;};const main = ctx =&gt; {    ctx.response.type = &apos;html&apos;;    ctx.response.body = &apos;hello world&apos;};app.use(route.get(&apos;/&apos;, main)); // 主页app.use(route.get(&apos;/about&apos;, about)); // about页面app.use(route.get(&apos;/user&apos;, user)); // user页面// app.use(main);app.listen(3000);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##静态资源 和 重定向</div><div class="line">###静态资源</div><div class="line">如果网站提供静态资源（图片、字体、样式表、脚本......）。</div><div class="line">koa-static 模块封装了这部分的请求。</div><div class="line">示例：请求本地12.js</div></pre></td></tr></table></figure>const Koa = require(&apos;koa&apos;);const app = new Koa();const path = require(&apos;path&apos;);const serve = require(&apos;koa-static&apos;);const main = serve(path.join(__dirname));app.use(main);app.listen(3000);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">说明：__dirname 表示 node.js 执行环境路径。</div><div class="line">请求资源： http://127.0.0.1:3000/12.js</div><div class="line">###重定向</div><div class="line">有些场合，服务器需要重定向（redirect）访问请求。</div><div class="line">比如，用户登陆以后，将他重定向到登陆前的页面。</div><div class="line">ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。</div></pre></td></tr></table></figure>const redirect = ctx =&gt; {  ctx.response.redirect(&apos;/&apos;);};const main = ctx =&gt; {  ctx.response.body = &apos;Hello World&apos;;};app.use(route.get(&apos;/&apos;, main));app.use(route.get(&apos;/redirect&apos;, redirect)); // 当请求路径为 /redirect 时，执行 redirect 方法，进行重定向<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。</div><div class="line">##中间件</div><div class="line">###设计中间件</div><div class="line">Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。</div><div class="line">示例：自己设计一个logger中间件。</div></pre></td></tr></table></figure>/*** 定义日志中间件 logger* @param ctx {object} 上下文对象 * @param next {function} 下一个中间件执行权*/const logger = (ctx, next) =&gt; {    console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);    next(); // 只要调用next函数，就可以把执行权转交给下一个中间件。};// 使用中间件app.use(logger);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###中间件特性</div><div class="line">多个中间件会形成一个栈结构（middle stack），以&quot;先进后出&quot;（first-in-last-out）的顺序执行。</div></pre></td></tr></table></figure>const one = (ctx, next) =&gt; {  console.log(&apos;&gt;&gt; one&apos;);  next();  console.log(&apos;&lt;&lt; one&apos;);}const two = (ctx, next) =&gt; {  console.log(&apos;&gt;&gt; two&apos;);  next();   console.log(&apos;&lt;&lt; two&apos;);}const three = (ctx, next) =&gt; {  console.log(&apos;&gt;&gt; three&apos;);  next();  console.log(&apos;&lt;&lt; three&apos;);}app.use(one);app.use(two);app.use(three);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输出：</div><div class="line">&gt;&gt; one   // one中间件进栈</div><div class="line">&gt;&gt; two   // two中间件进栈</div><div class="line">&gt;&gt; three // three中间件进栈</div><div class="line">&lt;&lt; three // three中间件 出栈</div><div class="line">&lt;&lt; two   // two中间件 出栈</div><div class="line">&lt;&lt; one // one中间件 出栈</div><div class="line">###异步中间件</div><div class="line">如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。</div><div class="line">实例：异步 main 中间件</div></pre></td></tr></table></figure>const fs = require(&apos;fs.promised&apos;);const main = async function (ctx, next) {  ctx.response.type = &apos;html&apos;;  ctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;);};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.readFile是一个异步操作，必须写成异步中间件。</div><div class="line">###koa-compose模块可以将多个中间件合成为一个。</div><div class="line">示例：合并 logger 和 main 中间件。</div></pre></td></tr></table></figure>const compose = require(&apos;koa-compose&apos;);const middlewares = compose([logger, main]);app.use(middlewares);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##错误处理</div><div class="line">如果代码运行过程中发生错误，我们需要把错误信息返回给用户。</div><div class="line">###500错误</div><div class="line">HTTP 协定约定这时要返回500状态码。</div><div class="line">Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误。</div></pre></td></tr></table></figure>const main = ctx =&gt; {    ctx.throw(500);};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###404错误</div><div class="line">如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。</div></pre></td></tr></table></figure>const main = ctx =&gt; {  ctx.response.status = 404; // ctx.throw(404);  ctx.response.body = &apos;Page Not Found&apos;;};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###处理错误的中间件</div><div class="line">为了方便处理错误，最好使用try...catch将其捕获。</div><div class="line">但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。</div></pre></td></tr></table></figure>// 最外层中间件const handler = async (ctx, next) =&gt; {  try {    await next();  } catch (err) {    ctx.response.status = err.statusCode || err.status || 500;    ctx.response.body = {      message: err.message    };  }};// 内层中间件const main = ctx =&gt; {  ctx.throw(404);};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###error 事件的监听</div><div class="line">运行过程中一旦出错，Koa 会触发一个error事件。</div><div class="line">监听这个事件，也可以处理错误。</div></pre></td></tr></table></figure>const main = ctx =&gt; {    ctx.throw(500); // 直接触发错误};// 监听错误app.on(&apos;error&apos;, (err, ctx) =&gt; {    console.error(&apos;server error&apos;, err);});<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###释放 error 事件</div><div class="line">需要注意的是，如果错误被try...catch捕获，就不会触发error事件。</div><div class="line">这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。</div></pre></td></tr></table></figure>const handler = async (ctx, next) =&gt; {    try {        await next();    } catch (err) {        ctx.response.status = err.statusCode || err.status || 500;        ctx.response.type = &apos;html&apos;;        ctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;;        ctx.app.emit(&apos;error&apos;, err, ctx);    }};const main = ctx =&gt; {    ctx.throw(500);};app.on(&apos;error&apos;, function(err) {    console.log(&apos;logging error &apos;, err.message);    console.log(err);});<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main函数抛出错误，被handler函数捕获。</div><div class="line">catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。</div><div class="line">##Web App 的功能</div><div class="line">###Cookies</div><div class="line">ctx.cookies 用来读写 Cookie。</div></pre></td></tr></table></figure>const main = function(ctx) {    const n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1;    ctx.cookies.set(&apos;view&apos;, n);    ctx.response.body = n + &apos; views&apos;;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">###表单</div><div class="line">Web 应用离不开处理表单。</div><div class="line">表单就是 POST 方法发送到服务器的键值对。</div><div class="line">koa-body模块可以用来从 POST 请求的数据体里面提取键值对。</div></pre></td></tr></table></figure>const koaBody = require(&apos;koa-body&apos;);const main = async function (ctx) {    const body = ctx.request.body;    if (!body.name) ctx.throw(400, &apos;.name required&apos;);    ctx.body = { name: body.name };};app.use(koaBody());<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###文件上传</div><div class="line">koa-body模块还可以用来处理文件上传。</div></pre></td></tr></table></figure>const os = require(&apos;os&apos;);const path = require(&apos;path&apos;);const koaBody = require(&apos;koa-body&apos;);const main = async function(ctx) {    const tmpdir = os.tmpdir();    const filePaths = [];    const files = ctx.request.body.files || {};    for (let key in files) {        const file = files[key];        const filePath = path.join(tmpdir, file.name);        const reader = fs.createReadStream(file.path);        const writer = fs.createWriteStream(filePath);        reader.pipe(writer);        filePaths.push(filePath);    }    ctx.body = filePaths;};app.use(koaBody({ multipart: true }));```</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="external">阮一峰老师的koa教程</a><br>    <a href="https://www.npmjs.com/package/koa-router" target="_blank" rel="external">koa-router官方文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一个koa示例&quot;&gt;&lt;a href=&quot;#一个koa示例&quot; class=&quot;headerlink&quot; title=&quot;一个koa示例&quot;&gt;&lt;/a&gt;一个koa示例&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签总结</title>
    <link href="https://fanerge.github.io/2017/09/27/jsDoc%E5%AD%A6%E4%B9%A0-5/"/>
    <id>https://fanerge.github.io/2017/09/27/jsDoc学习-5/</id>
    <published>2017-09-27T14:46:04.000Z</published>
    <updated>2017-10-12T13:02:24.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><pre><code>@class -- 此函数旨在需要使用”new”关键字调用（构造函数）或ES6中class。    @constructor@classdesc -- 使用的后面的蚊子来描述整个类。@abstract -- 这个成员必须在继承的子类中重写。    @virtual@static -- 记录一个静态成员。@access -- 指定该成员的访问级别（私有private、保护protected、公共public）。    @access private 等价于 @private    @access protected 等价于 @protected    @access public 等价于 @public@alias -- 标记成员有一个别名。@extends -- 指名这个子类继承至哪个父类，后面需要加父类名。    @augments@instance -- 记录一个实例成员。@interface -- 这是别人可以实现的一个接口。</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre><code>@borrows -- 这个对象使用另一个对象的某些东西。@lends -- 将一个字面量对象的所有属性标记为某个标识符（类或模块）的成员。@mixes -- 此对象混入了另一个对象中的所有成员。@mixin -- 记录一个mixin（混入）对象。@name  -- 记录一个对象的名称。@namespace -- 记录一个命名空间对象。@property -- 记录一个对象的属性。    @prop@typedef -- 记录一个自定义的类型。@type -- 记录一个对象的类型。@variation -- 区分具有相同名称的不同的对象。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>@callback -- 描述一个回调函数。@function -- 描述一个函数或方法。    @func    @method@returns -- 记录一个函数的返回值。    @return@this -- this关键字的指向。</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>@author -- 指定项目的作者。@constant -- 记录一个对象作为一个常量。    @const@default -- 记录默认值。    @defaultvalue@copyright -- 描述一些版权信息。@since -- 该方法添加于该版本，建议使用。@deprecated -- 该方法已弃用，不建议使用。@description -- 描述一个标识。    @desc@enum -- 描述一个相关属性的集合。@example -- 提供一个如何使用描述项的例子。@external -- 标识一个外部的类，命名空间，或模块。@file -- 描述一个文件。    @fileoverview    @overview@global -- 记录一个全局对象。@ignore -- 忽略文档中的一个标识。@implements -- 这个表示实现一个接口。@inheritdoc -- 指明这个标识应继承其父类的文档。@inner -- 描述一个内部对象。@kind -- 表示的类型。@license -- 表示你的代码采用何种软件许可协议。@member -- 记录一个成员。    @var@memberof -- 标明这个标识属于哪个父级标识。@override -- 指明一个标识符覆盖其父类同名的标识符。@param -- 记录传递给一个函数的参数。    @arg     @argument@readonly -- 标记为只读的。@see -- 更多详细参阅其他一些文档。@summary -- 完整描述的一个简写版本。@throws -- 说明可能会被抛出什么样的错误。@todo -- 记录一个将要完成的任务。@tutorial -- 插入一个连接到包含教程文件。@version -- 记录版本信息。</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>@event -- 描述一个事件。@listens -- 列出一个标识的监听事件。@fires -- 描述事件这个方法可能会触发。    @emits</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>@exports -- 表示一个由javascript模块导出的成员。@module -- 记录一个javascript模块。@requires -- 这个文件需要一个javascript模块。</code></pre><h2 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a>内联标签</h2><pre><code>@link -- 连接到文档中的另一个项目。    @linkcode    @linkplain@tutorial -- 链接到一个教程。</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>安装jsdoc3<br>npm install -g jsdoc</li><li>在cmd 中 (此时会在test.js的同级目录产出out目录，存放生成的API文档)<br>jsdoc test.js<br>  默认配置情况下out目录中产出：<pre><code>fonts、scripts、styles目录顾名思义。index.html -- API文档首页global.html -- 全局的（成员和方法）index.js.html -- 源代码页面</code></pre></li><li><p>相关配置<br>启用jsdoc有两种方式：命令行参数 和 conf.json配置<br>JSDoc命令行参数<br>  JSDoc命令行几个常用参数有以下几个：<br>  -c, –configure 指定configuration file<br>  -d, –destination 指定输出路径，默认./out<br>  -e, –encoding 设定encoding，默认utf8<br>  -p, –private 将private注释输出到文档，默认不输出<br>  -P, –package 指定package.json file<br>  -r, –recurse 查询子目录<br>  -t, –template 指定输出文档template<br>  -u, –tutorials 指定教程路径，默认无<br>  例如：jsdoc -T –match tag –verbose<br>JSDoc配置文件<br>  默认的配置文件：conf.json.EXAMPLE</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;tags&quot;: &#123;</div><div class="line">&quot;allowUnknownTags&quot;: true, // 允许使用自定义tag</div><div class="line">&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;] // 定义tag集</div><div class="line">&#125;,</div><div class="line">&quot;source&quot;: &#123;</div><div class="line">&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;, // 将以.js, .jsdoc结尾的文件作为源文件</div><div class="line">&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot; // 忽略以_开头的文件夹及文件</div><div class="line">&#125;,</div><div class="line">&quot;plugins&quot;: [],</div><div class="line">&quot;templates&quot;: &#123;</div><div class="line">&quot;cleverLinks&quot;: false,</div><div class="line">&quot;monospaceLinks&quot;: false</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  例如：jsdoc -c /path/to/conf.json</p></li></ol><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/inline-tags.html" target="_blank" rel="external">jsdoc</a><br>    <a href="https://github.com/jsdoc3/jsdoc" target="_blank" rel="external">jsdoc3</a><br>    <a href="http://www.moodpo.com/archives/jsdoc3-tutorial.html" target="_blank" rel="external">使用 JSDoc 3 自动生成 JavaScript API 文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类和构造函数&quot;&gt;&lt;a href=&quot;#类和构造函数&quot; class=&quot;headerlink&quot; title=&quot;类和构造函数&quot;&gt;&lt;/a&gt;类和构造函数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;@class -- 此函数旨在需要使用”new”关键字调用（构造函数）或ES6中class。
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签3</title>
    <link href="https://fanerge.github.io/2017/09/26/jsDoc%E5%AD%A6%E4%B9%A0-4/"/>
    <id>https://fanerge.github.io/2017/09/26/jsDoc学习-4/</id>
    <published>2017-09-26T13:28:50.000Z</published>
    <updated>2017-10-12T13:02:20.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h3><pre><code>@override标签指明一个标识符覆盖其父类同名的标识符。下面的例子说明一个方法如何重写父类的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @classdesc Abstract class representing a network connection.</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Connection() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Open the connection.</div><div class="line"> */</div><div class="line">Connection.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * @classdesc Class representing a socket connection.</div><div class="line"> * @class</div><div class="line"> * @augments Connection</div><div class="line"> */</div><div class="line">function Socket() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Open the socket.</div><div class="line"> * @override</div><div class="line"> */</div><div class="line">Socket.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h3><pre><code>@param标签提供了对某个函数的参数的各项说明，包括参数名、参数数据类型、描述等。别名：@arg @argument下面的示例演示如何在 @param标签中包含名称，类型，和说明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param somebody</div><div class="line"> */</div><div class="line">function sayHello(somebody) &#123;</div><div class="line">alert(&apos;Hello &apos; + somebody);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h3><pre><code>@private标签标记标识符为私有，或者不做一般用途使用。私有成员不会在生成文档中输出任何内容，除非JSDoc使用 -p/--private 命令行选项运行。语法：@private在下面的例子中，Documents和Documents.Newspaper会被输出到生成的文档中，但是Documents.Diary不会。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var Documents = &#123;</div><div class="line">/**</div><div class="line"> * An ordinary newspaper.</div><div class="line"> */</div><div class="line">Newspaper: 1,</div><div class="line">/**</div><div class="line"> * My diary.</div><div class="line"> * @private</div><div class="line"> */</div><div class="line">Diary: 2</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><pre><code>@property标签很容易描述类，命名空间或其它对象的静态属性列表。别名：@prop例如，描述命名空间的默认属性及嵌套属性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @namespace</div><div class="line"> * @property &#123;object&#125;  defaults               - The default values for parties.</div><div class="line"> * @property &#123;number&#125;  defaults.players       - The default number of players.</div><div class="line"> * @property &#123;string&#125;  defaults.level         - The default level for the party.</div><div class="line"> * @property &#123;object&#125;  defaults.treasure      - The default treasure.</div><div class="line"> * @property &#123;number&#125;  defaults.treasure.gold - How much gold the party starts with.</div><div class="line"> */</div><div class="line">var config = &#123;</div><div class="line">defaults: &#123;</div><div class="line">players: 1,</div><div class="line">level:   &apos;beginner&apos;,</div><div class="line">treasure: &#123;</div><div class="line">gold: 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h3><pre><code>@protected标签标记标识符为受保护的，通常情况下，受保护的成员只能在被继承的子类中或在模块内部可以访问。语法：@protected [{typeExpression}]在下面的例子中，该实例成员Thingy#_bar会被导出到生成的文档中，但使用注释说明它是被保护的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** @constructor */</div><div class="line">function Thingy() &#123;</div><div class="line">/** @protected */</div><div class="line">this._bar = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h3><pre><code>@public标签标记标识符为公开的。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The Thingy class is available to all.</div><div class="line"> * @public</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Thingy() &#123;</div><div class="line">/**</div><div class="line"> * The Thingy~foo member. Note that &apos;foo&apos; is still an inner member</div><div class="line"> * of &apos;Thingy&apos;, in spite of the @public tag.</div><div class="line"> * @public</div><div class="line"> */</div><div class="line">var foo = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h3><pre><code>标记一个标识符为只读。jsdoc不会检查某个代码是否真是只读的，只要标上@readonly，在文档中就体现为只读的。例如，给getter标记为只读<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Options for ordering a delicious slice of pie.</div><div class="line"> * @namespace</div><div class="line"> */</div><div class="line">var pieOptions = &#123;</div><div class="line">/**</div><div class="line"> * A la mode.</div><div class="line"> * @readonly</div><div class="line"> */</div><div class="line">get aLaMode() &#123;</div><div class="line">return this.plain + &apos; with ice cream&apos;;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="requires"><a href="#requires" class="headerlink" title="@requires"></a>@requires</h3><pre><code>@requires标签可以记录一个模块需要的依赖项。一个JSDoc注释块可以有多个@require标签。模块名可以被指定为 &quot;moduleName&quot; 或者 &quot;module:moduleName&quot;;这两种形式将被解析为模块。语法：@requires &lt;someModuleName&gt;例如，使用@requires 标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * This class requires the modules &#123;@link module:xyzcorp/helper&#125; and</div><div class="line"> * &#123;@link module:xyzcorp/helper.ShinyWidget#polish&#125;.</div><div class="line"> * @class</div><div class="line"> * @requires module:xyzcorp/helper</div><div class="line"> * @requires xyzcorp/helper.ShinyWidget#polish</div><div class="line"> */</div><div class="line">function Widgetizer() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="returns"><a href="#returns" class="headerlink" title="@returns"></a>@returns</h3><pre><code>@returns 标签描述一个函数的返回值。语法和@param类似。别名：@return返回值的类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns the sum of a and b</div><div class="line"> * @param &#123;Number&#125; a</div><div class="line"> * @param &#123;Number&#125; b</div><div class="line"> * @returns &#123;Number&#125;</div><div class="line"> */</div><div class="line">function sum(a, b) &#123;</div><div class="line">return a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h3><pre><code>@see标签表示可以参考另一个标识符的说明文档，或者一个外部资源。语法：@see &lt;namepath&gt;      @see &lt;text&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Both of these will link to the bar function.</div><div class="line"> * @see &#123;@link bar&#125;</div><div class="line"> * @see bar</div><div class="line"> */</div><div class="line">function foo() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="since"><a href="#since" class="headerlink" title="@since"></a>@since</h3><pre><code>@since标签标明一个类，方法，或其它标识符是在哪个特定版本开始添加进来的。语法：@since &lt;versionDescription&gt;例如，使用@since标签：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Provides access to user information.</div><div class="line"> * @since 1.0.1</div><div class="line"> */</div><div class="line">function UserRecord() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="static"><a href="#static" class="headerlink" title="@static"></a>@static</h3><pre><code>@static标签标明一个在父类中的标识符不需实例即可使用。例如，在一个虚拟注释中使用@static    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/** @namespace MyNamespace */</div><div class="line">/**</div><div class="line"> * @function myFunction</div><div class="line"> * @memberof MyNamespace</div><div class="line"> * @static</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="summary"><a href="#summary" class="headerlink" title="@summary"></a>@summary</h3><pre><code>@summary标签是完整描述的一个简写版本。它可以被添加到任何的doclet。语法：@summary Summary goes here.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological,</div><div class="line"> * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate,</div><div class="line"> * loquacious, garrulous, chatty, extended, babbling description.</div><div class="line"> * @summary A concise summary.</div><div class="line"> */</div><div class="line">function bloviate() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="this"><a href="#this" class="headerlink" title="@this"></a>@this</h3><pre><code>@this标签指明this关键字的指向。语法：@this &lt;namePath&gt;在下面的例子中，@this标签迫使&quot;this.name&quot;被描述为&quot;Greeter#name&quot;，而不是全局变量&quot;name&quot;。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/** @constructor */</div><div class="line">function Greeter(name) &#123;</div><div class="line">setName.apply(this, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/** @this Greeter */</div><div class="line">function setName(name) &#123;</div><div class="line">/** document me */</div><div class="line">this.name = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="throws"><a href="#throws" class="headerlink" title="@throws"></a>@throws</h3><pre><code>@throws标签可以让你描述函数可能会抛出的错误。在一个JSDoc注释块中您可以包含多个@throws标签。语法：@throws free-form description      @throws {&lt;type&gt;}      @throws {&lt;type&gt;} free-form description例如，在type中使用@throws标签:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @throws &#123;InvalidArgumentException&#125;</div><div class="line"> */</div><div class="line">function foo(x) &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="todo"><a href="#todo" class="headerlink" title="@todo"></a>@todo</h3><pre><code>@todo标签可以让你记录要完成的任务。在一个JSDoc注释块中您可以包含多个@todo标签。语法：@todo text describing thing to do.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @todo Write the documentation.</div><div class="line"> * @todo Implement this function.</div><div class="line"> */</div><div class="line">function foo() &#123;</div><div class="line">// write me</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="tutorial"><a href="#tutorial" class="headerlink" title="@tutorial"></a>@tutorial</h3><pre><code>@tutorial 标签插入一个指向向导教程的链接，作为文档的一部分。语法：@tutorial &lt;tutorialID&gt;在下面的例子中，MyClass的文档将链接到tutorial-1 和 tutorial-2标识符的教程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Description</div><div class="line"> * @class</div><div class="line"> * @tutorial tutorial-1</div><div class="line"> * @tutorial tutorial-2</div><div class="line"> */</div><div class="line">function MyClass() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><pre><code>@type标签允许你提供一个表达式，用于标识一个标识符可能包含的值的类型，或由函数返回值的类型。语法：@type {typeName1 | typeName2}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** @type &#123;(string|Array.&lt;string&gt;)&#125; */</div><div class="line">var foo;</div><div class="line">/** @type &#123;number&#125; */</div><div class="line">var bar = 1;</div></pre></td></tr></table></figure></code></pre><h3 id="typedef"><a href="#typedef" class="headerlink" title="@typedef"></a>@typedef</h3><pre><code>@typedef标签在描述自定义类型时是很有用的，特别是如果你要反复引用它们的时候。语法：@typedef [&lt;type&gt;] &lt;namepath&gt;这个例子定义了一个联合类型的参数，表示可以包含数字或字符串。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A number, or a string containing a number.</div><div class="line"> * @typedef &#123;(number|string)&#125; NumberLike</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="variation"><a href="#variation" class="headerlink" title="@variation"></a>@variation</h3><pre><code>描述: 区分具有相同名称的不同的对象。语法：@variation &lt;variationNumber&gt;</code></pre><h3 id="version"><a href="#version" class="headerlink" title="@version"></a>@version</h3><pre><code>@version标签后面的文本将被用于表示该项的版本。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @version 1.2.3</div><div class="line"> * @tutorial solver</div><div class="line"> */</div><div class="line">function solver(a, b) &#123;</div><div class="line">return b / a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="内联标签（inline-Tags）"><a href="#内联标签（inline-Tags）" class="headerlink" title="内联标签（inline Tags）"></a>内联标签（inline Tags）</h3><pre><code>{@link}内联标签创建一个链接到您指定的namepath或URL。当您使用{@link}标签，还可以提供几种不同的格式的链接文本。如果你不提供任何链接文本，JSDoc使用namepath或URL作为链接文字。别名：@linkcode  @linkplain语法：{@link namepathOrURL}      [link text]{@link namepathOrURL}      {@link namepathOrURL|link text}      {@link namepathOrURL link text (after the first space)}下面的例子显示了提供给{@link} 标签链接文本的所有方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * See &#123;@link MyClass&#125; and [MyClass&apos;s foo property]&#123;@link MyClass#foo&#125;.</div><div class="line"> * Also, check out &#123;@link http://www.google.com|Google&#125; and</div><div class="line"> * &#123;@link https://github.com GitHub&#125;.</div><div class="line"> */</div><div class="line">function myFunction() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="tutorial-1"><a href="#tutorial-1" class="headerlink" title="@tutorial"></a>@tutorial</h3><pre><code>{@tutorial}行内标签创建一个链接到您指定的教程标识符。当您使用{@tutorial}标签，您也可以提供几种不同的格式的链接文本。如果你不提供任何链接文本，JSDoc使用本教程的标题作为链接文字。语法：{@tutorial tutorialID}      [link text]{@tutorial tutorialID}      {@tutorial tutorialID|link text}      {@tutorial tutorialID link text (after the first space)}下面的例子显示了提供给{@tutorial}标签链接文本的所有方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * See &#123;@tutorial gettingstarted&#125; and [Configuring the Dashboard]&#123;@tutorial dashboard&#125;.</div><div class="line"> * For more information, see &#123;@tutorial create|Creating a Widget&#125; and</div><div class="line"> * &#123;@tutorial destroy Destroying a Widget&#125;.</div><div class="line"> */</div><div class="line">function myFunction() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;override&quot;&gt;&lt;a href=&quot;#override&quot; class=&quot;headerlink&quot; title=&quot;@override&quot;&gt;&lt;/a&gt;@override&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@override标签指明一个标识符覆盖其父类同名的标识符。
下面的例子
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签2</title>
    <link href="https://fanerge.github.io/2017/09/26/jsDoc%E5%AD%A6%E4%B9%A0-3/"/>
    <id>https://fanerge.github.io/2017/09/26/jsDoc学习-3/</id>
    <published>2017-09-26T12:26:15.000Z</published>
    <updated>2017-10-12T13:02:17.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="file"><a href="#file" class="headerlink" title="@file"></a>@file</h3><pre><code>@file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。别名：@fileoverview  @overview例如，文件描述<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @file 这是正则js文件</div><div class="line"> * @author fanerge &lt;fanerge@example.com&gt;</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="fires"><a href="#fires" class="headerlink" title="@fires"></a>@fires</h3><pre><code>@fires标签标明当一个方法被调用时将触发一个指定类型的事件，使用@event 标签来描述事件的内容。别名：@emits语法：@fires &lt;className&gt;#[event:]&lt;eventName&gt;例如，方法将触发&quot;drain&quot;事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Drink the milkshake.</div><div class="line"> * @fires Milkshake#drain</div><div class="line"> */</div><div class="line">Milkshake.prototype.drink = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="function"><a href="#function" class="headerlink" title="@function"></a>@function</h3><pre><code>标记一个对象作为一个函数，即使它可能不会出现在解析器中。它设置doclet的@kind为&apos;function&apos;。别名：@func  @method语法：@function [&lt;FunctionName&gt;]例如，使用@function标记为一个函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** @function */</div><div class="line">var paginate = paginateFactory(pages);</div></pre></td></tr></table></figure></code></pre><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><pre><code>@global标签指定一个在文档的标识是为全局性的标识。JSDoc忽略这个标识在源文件中的实际作用范围。这个标记是在本地所定义标识时特别有用。例如，文档中的内部变量作为一个全局变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">/** @global */</div><div class="line">var foo = &apos;hello foo&apos;;</div><div class="line"></div><div class="line">this.foo = foo;</div><div class="line">&#125;).apply(window);</div></pre></td></tr></table></figure></code></pre><h3 id="ignore"><a href="#ignore" class="headerlink" title="@ignore"></a>@ignore</h3><pre><code>@ignore标签表示在你的代码中的注释不应该出现在文档中，注释会被直接忽略。这个标签优先于所有其他标签。在下面的例子中，@ignore标签， Jacket 和 Jacket#color 将不会出现在文档中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @class</div><div class="line"> * @ignore</div><div class="line"> */</div><div class="line">function Jacket() &#123;</div><div class="line">/** The jacket&apos;s color. */</div><div class="line">this.color = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="implements"><a href="#implements" class="headerlink" title="@implements"></a>@implements</h3><pre><code>@implements标签指示一个标识实现一个接口。语法：@implements {typeExpression}在下面的例子中，TransparentColor类实现Color接口，并添加了TransparentColor#rgba方法。</code></pre><h3 id="inheritdoc"><a href="#inheritdoc" class="headerlink" title="@inheritdoc"></a>@inheritdoc</h3><pre><code>@inheritdoc标签指示该标识应继承其父类的文档。在你的JSDoc注释中的任何其它标签都将被忽略。下面的例子显示了一个类的描述如何从它的父类继承文档。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @classdesc Abstract class representing a network connection.</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Connection() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Open the connection.</div><div class="line"> */</div><div class="line">Connection.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * @classdesc Class representing a socket connection.</div><div class="line"> * @class</div><div class="line"> * @augments Connection</div><div class="line"> */</div><div class="line">function Socket() &#123;&#125;</div><div class="line"></div><div class="line">/** @inheritdoc */</div><div class="line">Socket.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="inner"><a href="#inner" class="headerlink" title="@inner"></a>@inner</h3><pre><code>使用@inner标签将标明该标识符作为它父标识符的内部成员。这意味着它可以通过 &quot;Parent~Child&quot; 被引用。在下面的例子中，我们使用@inner迫使一个命名空间的成员被描述作为内部成员（默认情况下，这是一个静态成员）。这意味着，foo现在有了MyNamespace~foo新名字，而不是MyNamespace.foo。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var MyNamespace = &#123;</div><div class="line">/**</div><div class="line"> * foo is now MyNamespace~foo rather than MyNamespace.foo.</div><div class="line"> * @inner</div><div class="line"> */</div><div class="line">foo: 1</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="instance"><a href="#instance" class="headerlink" title="@instance"></a>@instance</h3><pre><code>使用@instance标签标明该标识符作为它父标识符的实例成员。这意味着它可以通过&quot;Parent#Child&quot;被引用。例如，使用@instance确定一个实例成员<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var BaseObject = &#123;</div><div class="line">/**</div><div class="line"> * foo is now BaseObject#foo rather than BaseObject.foo.</div><div class="line"> * @instance</div><div class="line"> */</div><div class="line">foo: null</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** Generates BaseObject instances. */</div><div class="line">function fooFactory(fooValue) &#123;</div><div class="line">var props = &#123; foo: fooValue &#125;;</div><div class="line">return Object.create(BaseObject, props);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h3><pre><code>@interface标签使一个标识符作为其他标识符的一个实现接口。 例如，你的代码可能定义一个父类，它的方法和属性被去掉。您可以将@interface标签添加到父类，以指明子类必须实现父类的方法和属性。语法：@interface [&lt;name&gt;]在下面的例子中，Color函数表示其它类可以实现的接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Interface for classes that represent a color.</div><div class="line"> * @interface</div><div class="line"> */</div><div class="line">function Color() &#123;&#125;</div><div class="line">/**</div><div class="line"> * Get the color as an array of red, green, and blue values, represented as</div><div class="line"> * decimal numbers between 0 and 1.</div><div class="line"> * @returns &#123;Array&amp;lt;number&gt;&#125; An array containing the red, green, and blue values,</div><div class="line"> * in that order.</div><div class="line"> */</div><div class="line">Color.prototype.rgb = function() &#123;</div><div class="line">throw new Error(&apos;not implemented&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="kind"><a href="#kind" class="headerlink" title="@kind"></a>@kind</h3><pre><code>@kind标签是用来指明什么样的标识符被描述（例如，一类或模块）。标识符kind 不同于标识符type（例如，字符串或布尔）。语法：@kind &lt;kindName&gt;    kindName取值：class constant event external file function member mixin module namespace typedef<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A constant.</div><div class="line"> * @kind constant</div><div class="line"> */</div><div class="line">const asdf = 1;</div></pre></td></tr></table></figure></code></pre><h3 id="lends"><a href="#lends" class="headerlink" title="@lends"></a>@lends</h3><pre><code>@lends标签允许你将一个字面量对象的所有成员标记为某个标识符（类或模块）的成员，就像他们是给定名称的标识符成员。你可能想这样做，如果你传递一个对象字面量给一个函数，创建一个成员为对象字面量的命名类。语法：@lends &lt;namepath&gt;实例，@lends标签告诉JSDoc，这一对象字面量的所有成员都会被“借”给&quot;Person&quot;类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** @class */</div><div class="line">var Person = makeClass(</div><div class="line">/** @lends Person */</div><div class="line">&#123;</div><div class="line">initialize: function(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;,</div><div class="line">say: function(message) &#123;</div><div class="line">return this.name + &quot; says: &quot; + message;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">);</div></pre></td></tr></table></figure></code></pre><h3 id="license"><a href="#license" class="headerlink" title="@license"></a>@license</h3><pre><code>@license标签标识你的代码采用何种软件许可协议。语法：@license &lt;identifier&gt;例如，这是在Apache 2.0 许可下分发的模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Utility functions for the foo package.</div><div class="line"> * @module foo/util</div><div class="line"> * @license Apache-2.0</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="listens"><a href="#listens" class="headerlink" title="@listens"></a>@listens</h3><pre><code>@listens 标签指示一个标识监听指定的事件。使用@event 标签来记录事件的内容。语法：@listens &lt;eventName&gt;下面的示例演示了如何记录名为module:hurler~event:snowball的事件，还有一个方法命名为module:playground/monitor.reportThrowage来监听事件。</code></pre><h3 id="member"><a href="#member" class="headerlink" title="@member"></a>@member</h3><pre><code>@member标签记录成员基本种类（kind），比如&quot;class&quot;, &quot;function&quot;, 或者 &quot;constant&quot;。一个成员可以任选地具有一个类型以及名称。别名：@var语法：@member [&lt;type&gt;] [&lt;name&gt;]例如，Data#point上使用@member：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** @class */</div><div class="line">function Data() &#123;</div><div class="line">/** @member &#123;Object&#125; */</div><div class="line">this.point = &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="memberof"><a href="#memberof" class="headerlink" title="@memberof"></a>@memberof</h3><pre><code>@memberof标签标明成员隶属于哪一个父级标识符。语法：@memberof &lt;parentNamepath&gt;      @memberof! &lt;parentNamepath&gt;事实上，它就是一个全局性的函数，但同事它也是Tools命名空间的一个成员，而这才是你想描述的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var Tools = &#123;&#125;;</div><div class="line"></div><div class="line">/** @memberof Tools */</div><div class="line">var hammer = function() &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Tools.hammer = hammer;</div></pre></td></tr></table></figure></code></pre><h3 id="mixes"><a href="#mixes" class="headerlink" title="@mixes"></a>@mixes</h3><pre><code>@mixes标签指示当前对象混入了OtherObjectPath对象的所有成员,被混入的对象就是一个@mixin。    语法：@mixes &lt;OtherObjectPath&gt;</code></pre><h3 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h3><pre><code>您可以使用@mixin标签标识该对象是一个mixin（混入），旨在表明该对象的属性和方法混入到其他对象。然后，可以将@mixes标签 添加到使用了该 mixin（混入）的对象上。语法：@mixin [&lt;MixinName&gt;]</code></pre><h3 id="module"><a href="#module" class="headerlink" title="@module"></a>@module</h3><pre><code>@module可以将当前文件标注为一个模块，默认情况下文件内的所有标识符都隶属于此模块，除非文档另有说明。@module [[{&lt;type&gt;}] &lt;moduleName&gt;]下面的示例演示了在一个模块中用于标识的namepaths。第一个标识符是模块私有的，或“内部”变量 - 它只能在模块内访问。第二个标识符是由模块导出一个静态函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/** @module myModule */</div><div class="line"></div><div class="line">/** will be module:myModule~foo */</div><div class="line">var foo = 1;</div><div class="line"></div><div class="line">/** will be module:myModule.bar */</div><div class="line">var bar = function() &#123;&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="name"><a href="#name" class="headerlink" title="@name"></a>@name</h3><pre><code>@name标签强制JSDoc使用这个给定的名称，而忽略实际代码里的名称。这个标签最好用于&quot;虚拟注释&quot;，而不是在代码中随时可见的标签，如在运行时期间产生的方法。语法：@name &lt;namePath&gt;下面的例子演示了如何使用@name标签描述一个函数，JSDoc通常不会识别。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @name highlightSearchTerm</div><div class="line"> * @function</div><div class="line"> * @global</div><div class="line"> * @param &#123;string&#125; term - The search term to highlight.</div><div class="line"> */</div><div class="line">eval(&quot;window.highlightSearchTerm = function(term) &#123;&#125;;&quot;)</div></pre></td></tr></table></figure></code></pre><h3 id="namespace"><a href="#namespace" class="headerlink" title="@namespace"></a>@namespace</h3><pre><code>@namespace标签指明对象是一个命名空间。你也可以书写一个虚拟JSDoc注释，通过使用代码来定义命名空间。语法：@namespace [{&lt;type&gt;}] &lt;SomeName&gt;]例如，对象上使用 @namespace 标签：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * My namespace.</div><div class="line"> * @namespace</div><div class="line"> */</div><div class="line">var MyNamespace = &#123;</div><div class="line">/** documented as MyNamespace.foo */</div><div class="line">foo: function() &#123;&#125;,</div><div class="line">/** documented as MyNamespace.bar */</div><div class="line">bar: 1</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;file&quot;&gt;&lt;a href=&quot;#file&quot; class=&quot;headerlink&quot; title=&quot;@file&quot;&gt;&lt;/a&gt;@file&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。
别名：@fileovervie
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
