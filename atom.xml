<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-11-28T12:44:20.105Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用dos命令总结</title>
    <link href="https://fanerge.github.io/2017/11/26/%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/11/26/常用dos命令总结/</id>
    <published>2017-11-26T12:39:57.000Z</published>
    <updated>2017-11-28T12:44:20.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DOS命令"><a href="#什么是DOS命令" class="headerlink" title="什么是DOS命令"></a>什么是DOS命令</h1><p>DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h2><h3 id="md-mkdir"><a href="#md-mkdir" class="headerlink" title="md/mkdir"></a>md/mkdir</h3><p>作用：创建一个子目录（make directory）。<br>语法：md[C:][path]〈subPath〉</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>作用：改变或显示当前目录（change directory）。<br>语法：cd [C:][path]<br>PS：路径可以使用绝对路径和相对路径两种。<br>    cd\ 表示退回到根目录。<br>    cd.. 表示退回到上级目录。<br>    如果只有cd而没有参数，则只显示当前路径。<br>    注意：子目录中一定有两个“特殊目录”，即“.”“..”，其中一点表示当前目录，两点表示上一层目录。<br>    从简单实用的角度来看，我们只要学会逐层进入（cd 下一层某目录名），和逐层退出（cd..）就可以解决所有问题。</p><h3 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h3><p>作用：删除空子目录（remove directory）。<br>语法：rd [c:][path]<br>PS：rd是专门删除空子目录的命令。<br>    del 删除文件命令。<br>    注意两条：一是不能删除非空目录；二是不能删除当前目录。     </p><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>作用：主要用来显示一个目录下的文件和子目录。(directory)<br>语法：dir [C:][path][filename][/o][/s][/p][/w][/a]<br>PS：斜杠表示后面的内容是参数。<br>    /p 显示信息满一屏时，暂停显示，按任意键后显示下一屏<br>    /o 排序显示。o后面可以接不同意义的字母<br>    /w 只显示文件名目录名，每行五个文件名。即宽行显示<br>    /s 将目录及子目录的全部目录文件都显示<br>    /a 显示隐藏文件</p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>作用：设备可执行文件的搜索路径，只对文件有效。<br>语法：path[盘符1：][路径1][盘符2：][路径2]…<br>PS：当运行一个可执行文件时，dos会先在当前目录中搜索该文件，若找到则运行之；若找不到该文件，则根据path命令所设置的路径，顺序逐条地到目录中搜索该文件</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>作用：显示指定驱动器上所有目录路径和这些目录下的所有文件名。<br>语法：tree [盘符：][/f][&gt;prn]</p><h3 id="deltree"><a href="#deltree" class="headerlink" title="deltree"></a>deltree</h3><p>作用：删除目录树。<br>语法：DELTREE [C1:][path1]<br>PS：这个命令将整个指定目录树全部消灭，而不管它是否是只读、隐藏与否。使用应特别小心。它是一个危险命令。</p><h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p>作用：将整个计算机的进程显示出来，同任务管理器。<br>语法：tasklist</p><h2 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>作用：磁盘格式化。<br>语法：format〈盘符：〉[/s][/4][/q]    </p><h3 id="unformat"><a href="#unformat" class="headerlink" title="unformat"></a>unformat</h3><p>作用：对进行过格式化误操作丢失数据的磁盘进行恢复。<br>语法：unformat〈盘符〉[/l][/u][/p][/test]    </p><h3 id="chkdsk"><a href="#chkdsk" class="headerlink" title="chkdsk"></a>chkdsk</h3><p>作用：显示磁盘状态、内存状态和指定路径下指定文件的不连续数目。<br>语法：chkdsk [盘符：][路径][文件名][/f][/v]<br>PS：PS：例如要检查A盘使用情况，就输入chkdsk　A: ，检查c盘使用情况，就输入chkdsk　C: ，如果直接输入chkdsk，就检查当前磁盘的使用情况。    </p><h3 id="diskcopy"><a href="#diskcopy" class="headerlink" title="diskcopy　"></a>diskcopy　</h3><p>作用：复制格式和内容完全相同的软盘。<br>语法：diskcopy[盘符1：][盘符2：]</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>作用：建立、更改、删除磁盘卷标。<br>语法：label[盘符：][卷标名]    </p><h3 id="vol"><a href="#vol" class="headerlink" title="vol"></a>vol</h3><p>作用：查看磁盘卷标号。<br>语法：vol[盘符：]</p><h3 id="scandisk"><a href="#scandisk" class="headerlink" title="scandisk"></a>scandisk</h3><p>作用：检测磁盘的fat表、目录结构、文件系统等是否有问题，并可将检测出的问题加以修复。<br>语法：scandisk[盘符1：]{[盘符2：]…}[/all]</p><h3 id="defrag"><a href="#defrag" class="headerlink" title="defrag"></a>defrag</h3><p>作用：整理磁盘，消除磁盘碎块。<br>语法：defrag[盘符：][/f]<br>PS：选用/f参数，将文件中存在盘上的碎片消除，并调整磁盘文件的安排，确保文件之间毫无空隙。从而加快读盘速度和节省磁盘空间。</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>作用：将当前驱动器上的dos系统文件io.sys,msdos.sys和command 传送到指定的驱动器上。<br>语法：sys[盘符：]    </p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>作用：拷贝一个或多个文件到指定盘上。<br>语法：copy [源盘][路径]（源文件名） [目标盘][路径](目标文件名）</p><h3 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h3><p>作用：复制指定的目录和目录下的所有文件连同目录结构。<br>语法：xcopy [源盘：]〈源路径名〉[目标盘符：][目标路径名][/s][/v][/e]<br>PS：xcopy是copy的扩展，可以把指定的目录连文件和目录结构一并拷贝，但不能拷贝隐藏文件和系统文件。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>作用：显示ascii码文件的内容。<br>语法：type [C:][path][filename.ext]<br>PS：type命令用来在屏幕上快速、简便地显示文本文件的内容，扩展名为TXT的文件是文本文件。    </p><h3 id="ren"><a href="#ren" class="headerlink" title="ren"></a>ren</h3><p>作用：对指定磁盘、目录中的一个文件或一组文件更改名称（rename）。<br>语法：ren[盘符：][路径]〈旧文件名〉〈新文件名〉<br>PS：改名操作只限于某个文件某组文件的名称，它不会更改文件所在的目录。    </p><h3 id="fc"><a href="#fc" class="headerlink" title="fc"></a>fc</h3><p>作用：比较文件的异同，并列出差异处。<br>语法：fc[盘符：][路径名]〈文件名〉[盘符：][路径名][文件名][/a][/c][/n]</p><h3 id="attrib"><a href="#attrib" class="headerlink" title="attrib"></a>attrib</h3><p>作用：修改指定文件的属性。<br>语法：attrib[文件名][r][—r][a][—a][h][—h][—s]</p><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>作用：删除指定的文件。<br>语法：del[盘符：][路径]〈文件名〉[/p]    </p><h3 id="undelete"><a href="#undelete" class="headerlink" title="undelete"></a>undelete</h3><p>作用：恢复被误删除文件。<br>语法：undelete[盘符：][路径名]〈文件名〉[/dos][/list][/all]    </p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol><li>cls——清屏幕命令    </li><li>ver查看系统版本号命令    </li><li>date日期设置命令<br>date[mm——dd——yy]</li><li>time系统时钟设置命令<br>time[hh：mm：ss：xx]</li><li>mem显示系统的硬件和操作系统的状况。<br>mem[/c][/f][/m][/p]</li><li>msg显示系统的硬件和操作系统的状况。<br>msg[/s]</li></ol><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><h3 id="Ping命令的独特用法"><a href="#Ping命令的独特用法" class="headerlink" title="Ping命令的独特用法"></a>Ping命令的独特用法</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：ping +空格+“IP地址或者域名” [-t][-l][-n]<br>PS：-t：不停的Ping对方的机器，直到用户按Ctrl＋C键终止。因为如果想用Ping命令测试网络传输质量，至少要查看Ping命令三分钟到五分钟的结果。<br>    -l：定义echo数据包大小。我们可以将数据包的大小定义在极限值附近，以此可以测试出网络传输质量的优劣，尤其是测试外网的传输质量，非常明显。<br>    -n：在默认情况下，Ping命令一般都会发送四个数据包，通过这个命令可以自己定义发送的个数，对测试网络传输质量很有帮助。我们结合实例说明一下如何通过Ping命令的测试结果判断网络传输质量。</p><h3 id="tracert命令的使用技巧"><a href="#tracert命令的使用技巧" class="headerlink" title="tracert命令的使用技巧"></a>tracert命令的使用技巧</h3><p>作用：tracert命令可以测试路由器的工作是否正常（部分网站无法访问）。<br>    我们根据返回的结果来判断，哪一个环节的网络出现了问题。<br>语法：tracert +空格+“IP地址或者域名”</p><h3 id="用netstat命令判断是否被攻击"><a href="#用netstat命令判断是否被攻击" class="headerlink" title="用netstat命令判断是否被攻击"></a>用netstat命令判断是否被攻击</h3><p>作用：netstat命令可以查看单位的网络是否被攻击。<br>语法：netstat [-a][-n][-b]<br>PS：-a：显示所有连接和监听端口<br>　　-n：以数字形式显示地址和端口号<br>　　-b：显示包含于创建每个连接或监听端口的可执行组件。另外，使用该参数之后，还可以显示占用TCP协议端口的一些程序名称</p><h3 id="巧用ARP命令防范ARP病毒"><a href="#巧用ARP命令防范ARP病毒" class="headerlink" title="巧用ARP命令防范ARP病毒"></a>巧用ARP命令防范ARP病毒</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：arp -s ip地址 MAC</p><h3 id="灵活使用ipconfig命令"><a href="#灵活使用ipconfig命令" class="headerlink" title="灵活使用ipconfig命令"></a>灵活使用ipconfig命令</h3><p>作用：ipconfig这个命令查看计算机当前的网络配置信息。<br>ps：Ipconfig /all：完全显示计算机的网络信息，IP地址、MAC地址及其他相关的信息，都可以显示出来。<br>　　Ipconfig /release：释放计算机当前获得的IP地址。对于使用动态IP地址的单位来说，如果发现机器无法上网，而计算机从DHCP服务器处获得的IP地址等相关信息不完全，可以将该地址释放。<br>　　Ipconfig /renew：从DHCP服务器重新获得IP地址。释放了IP地址及相关信息之后，必须重新获得一个IP地址，直接输入此命令之后，便可以从DHCP服务器处获得一个IP地址。如果不用此命令，要想重新获得一个IP地址信息，需要重新启动计算机或注销计算机才行。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>net 系列</li><li>tlist -t 以树行列表显示进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li><li>kill -f 进程名 加-f参数后强制结束某进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li></ol><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>shutdown.exe -a　取消关机<br>shutdown.exe -s 关机<br>shutdown.exe -f　强行关闭应用程序。<br>shutdown.exe -m \计算机名　控制远程计算机。<br>shutdown.exe -i　显示图形用户界面，但必须是Shutdown的第一个参数。<br>shutdown.exe -l　注销当前用户。<br>shutdown.exe -r　关机并重启。<br>shutdown.exe -t时间　设置关机倒计时。<br>shutdown.exe -c”消息内容”　输入关机对话框中的消息内容（不能超127个字符）。<br>示例：<br>    电脑要在24:00关机 – at 24:00 Shutdown -s<br>    倒计时的方式关机 – Shutdown.exe -s -t 7200</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h3><p>作用：该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，使用这个命令你可以得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等。在此我们就有必要了解几个基本的参数。<br>PS：-a 使用这个参数，只要你知道了远程主机的机器名称，就可以得到它的NETBIOS信息（下同）。<br>    -A 这个参数也可以得到远程主机的NETBIOS信息，但需要你知道它的IP。<br>    -n 列出本地机器的NETBIOS信息。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>作用：这是一个用来查看网络状态的命令，操作简便功能强大。<br>PS：-a 查看本地机器的所有开放端口，可以有效发现和预防木马，可以知道机器所开的服务等信息<br>    这里可以看出本地机器开放有FTP服务、Telnet服务、邮件服务、WEB服务等。用法：netstat -a IP。<br>    -r 列出当前的路由信息，告诉我们本地机器的网关、子网掩码等信息。用法：netstat -r IP。</p><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>作用：跟踪路由信息，使用此命令可以查出数据从本地机器传输到目标主机所经过的所有途径，这对我们了解网络布局和结构很有帮助。</p><h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><p>作用：这个命令是网络命令中最重要的一个，必须透彻掌握它的每一个子命令的用法，因为它的功能实在是太强大了在这里，我们重点掌握几个常用的子命令。</p><ol><li>net view<br>使用此命令查看远程主机的所有共享资源。命令格式为net view \IP。</li><li>net use<br>把远程主机的某个共享资源影射为本地盘符，图形界面方便使用。命令格式为net use x: \IP\sharename。</li><li>net start<br>使用它来启动远程主机上的服务。用法：net start servername</li><li>net stop<br>入侵后发现远程主机的某个服务碍手碍脚，怎么办？利用这个命令停掉就ok了，用法和net start同。</li><li>net user<br>查看和帐户有关的情况，包括新建帐户、删除帐户、查看特定帐户、激活帐户、帐户禁用等。<br>1，net user abcd 1234 /add，新建一个用户名为abcd，密码为1234的帐户，默认为user组成员。<br>2，net user abcd /del，将用户名为abcd的用户删除。<br>3，net user abcd /active:no，将用户名为abcd的用户禁用。<br>4，net user abcd /active:yes，激活用户名为abcd的用户。<br>5，net user abcd，查看用户名为abcd的用户的情况</li><li>net localgroup　<br>查看所有和用户组有关的信息和进行相关操作。</li><li>net time<br>这个命令可以查看远程主机当前的时间。</li></ol><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>作用：这个命令的作用是安排在特定日期或时间执行某个特定的命令和程序。<br>    用法：at time command \computer    </p><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>作用：首先在命令行键入ftp回车，出现ftp的提示符，这时候可以键入“help”来查看帮助（任何DOS命令都可以使用此方法查看其帮助）。<br>    1.ftp<br>    2.open 主机IP ftp端口<br>    3.录入用户名和密码，就可以进行相应操作了。<br>    dir 跟DOS命令一样，用于查看服务器的文件，直接敲上dir回车，就可以看到此ftp服务器上的文件。<br>    cd 进入某个文件夹。<br>    get 下载文件到本地机器。<br>    put 上传文件到远程服务器。这就要看远程ftp服务器是否给了你可写的权限了，如果可以，呵呵，该怎么 利用就不多说了，大家就自由发挥去吧。<br>    delete 删除远程ftp服务器上的文件。这也必须保证你有可写的权限。<br>    bye 退出当前连接。<br>    quit 同上。</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>作用：功能强大的远程登陆命令，几乎所有的入侵者都喜欢用它，屡试不爽。为什么？它操作简单，如同使用自己的机器一样，只要你熟悉DOS命令，在成功以administrator身份连接了远程机器后，就可以用它来**想干的一切了。下面介绍一下使用方法，首先键入telnet回车，再键入help查看其帮助信息。    </p><h1 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h1><ol><li>向上箭头”↑”和向下箭头”↓”—–回看上一次执行的命令        </li><li>“Ctrl+C” 组合键或”Break”键 —–中断操作        </li><li>鼠标操作”标记” —————–用来选中文本        </li><li>鼠标操作”粘贴” —————–用来把剪贴板内容粘贴到提示符下        </li></ol><h2 id="程序进程"><a href="#程序进程" class="headerlink" title="程序进程"></a>程序进程</h2><p>作用：ntsd 是一条dos命令，功能是用于结束一些常规下结束不了的死进程。<br>使用：<br>    1.利用进程的PID结束进程<br>        命令格式：ntsd -c q -p pid<br>        命令范例：ntsd -c q -p 1332 （结束explorer.exe进程）<br>    2.利用进程名结束进程<br>        命令格式：ntsd -c q -pn <strong><em>.exe （</em></strong>.exe 为进程名，exe不能省）<br>        命令范例：ntsd -c q -pn explorer.exe<br>    3.taskkill结束进程<br>        命令格式：taskkill /pid 1234 /f （ 也可以达到同样的效果）</p><blockquote><p>   参考文档：<br>    <a href="http://www.jb51.net/article/30526.htm" target="_blank" rel="external">20种常用的DOS命令小结</a><br>    <a href="http://www.360doc.com/content/10/0712/19/1822972_38550278.shtml" target="_blank" rel="external">DOS中的PING命令的几种用法</a><br>    <a href="https://baike.baidu.com/item/DOS%E5%91%BD%E4%BB%A4/5143255?fr=aladdin#7" target="_blank" rel="external">百度文库-dos命令</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是DOS命令&quot;&gt;&lt;a href=&quot;#什么是DOS命令&quot; class=&quot;headerlink&quot; title=&quot;什么是DOS命令&quot;&gt;&lt;/a&gt;什么是DOS命令&lt;/h1&gt;&lt;p&gt;DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作
      
    
    </summary>
    
      <category term="杂项" scheme="https://fanerge.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="dos命令" scheme="https://fanerge.github.io/tags/dos%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构与算法</title>
    <link href="https://fanerge.github.io/2017/11/26/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/26/JavaScript数据结构与算法/</id>
    <published>2017-11-26T12:33:32.000Z</published>
    <updated>2017-12-10T13:47:55.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组及矩阵（二维数组）和多维数组（a-b-均为数组）"><a href="#数组及矩阵（二维数组）和多维数组（a-b-均为数组）" class="headerlink" title="数组及矩阵（二维数组）和多维数组（a, b 均为数组）"></a>数组及矩阵（二维数组）和多维数组（a, b 均为数组）</h1><p>最好使用数组存储一系列同一种数据类型的值（与其它语言保持一致）。<br>数组的有点：可以直接访问数组的某一项（相对于链表）。<br>数组的缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管我们已经学过的JavaScript的 Array 类方法可以帮我们做这些事，但背后的情况同样是这样）。</p><h2 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h2><h3 id="模拟栈数据结构"><a href="#模拟栈数据结构" class="headerlink" title="模拟栈数据结构"></a>模拟栈数据结构</h3><p>a.pop()  删除数组的最后一个元素并返回删除的元素。<br>a.push(item1, item2, …, itemX)  向数组的末尾添加一个或更多元素，并返回新的长度。</p><h3 id="模拟队列数据结构"><a href="#模拟队列数据结构" class="headerlink" title="模拟队列数据结构"></a>模拟队列数据结构</h3><p>a.shift()  删除并返回数组的第一个元素。<br>a.unshift(item1,item2, …, itemX)  可向数组的开头添加一个或更多元素，并返回新的长度。</p><h3 id="排序相关方法"><a href="#排序相关方法" class="headerlink" title="排序相关方法"></a>排序相关方法</h3><p>a.sort(sortfunction)  方法用于对数组的元素进行排序。<br>a.reverse()  用于颠倒数组中元素的顺序。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>a.splice(index,howmany,item1,…..,itemX)  用于插入、删除或替换数组的元素。<br>    参数说明：1.规定从何处添加/删除元素。2.删除多少元素。3.插入的项目。<br>    这里返回类型为数组!!!<br>a.copyWithin(target, start, end)  从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>    参数说明：1.复制到指定目标索引位置。2,3为复制的起始和结束位置。<br>a.fill(value, start, end)  将一个固定值替换数组的元素。<br>PS：删除元素的方法，返回被删除的元素。<br>    添加元素的方法，返回数组长度。</p><h2 id="不操作原数组方法"><a href="#不操作原数组方法" class="headerlink" title="不操作原数组方法"></a>不操作原数组方法</h2><h3 id="返回Boolean值的方法"><a href="#返回Boolean值的方法" class="headerlink" title="返回Boolean值的方法"></a>返回Boolean值的方法</h3><p>a.every(function(currentValue,index,arr), thisValue)  检测数值元素的每个元素是否都符合条件。<br>a.some(function(currentValue,index,arr),thisValue)  用于检测数组中的元素是否满足指定条件（函数提供）。<br>a.includes(item) 判断该数组是否存在该项目。</p><h3 id="返回新数组的方法"><a href="#返回新数组的方法" class="headerlink" title="返回新数组的方法"></a>返回新数组的方法</h3><p>a.concat(b)  连接两个或更多的数组，并返回连接后的数组。<br>a.filter(function(currentValue,index,arr), thisValue)  创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>a.slice(start, end)  可从已有的数组中返回选定的元素。<br>a.map(function(currentValue,index,arr), thisValue)   返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><h3 id="返回数组中的某项索引值"><a href="#返回数组中的某项索引值" class="headerlink" title="返回数组中的某项索引值"></a>返回数组中的某项索引值</h3><p>a.findIndex(function(currentValue, index, arr), thisValue)  返回符合传入测试（函数）条件的数组元素索引。<br>a.indexOf(item,start)  返回某个指定的字符串值在字符串中首次出现的位置。<br>a.lastIndexOf(item,start)   返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p><h3 id="返回数组中的某项值"><a href="#返回数组中的某项值" class="headerlink" title="返回数组中的某项值"></a>返回数组中的某项值</h3><p>a.find(function(currentValue, index, arr),thisValue)  返回传入一个测试条件（函数）符合条件的数组第一个元素。</p><h3 id="输出为字符串的方法"><a href="#输出为字符串的方法" class="headerlink" title="输出为字符串的方法"></a>输出为字符串的方法</h3><p>a.join(separator)  用于把数组中的所有元素通过分隔符转换一个字符串。<br>a.toString()  返回已逗号分割元素的字符串。</p><h3 id="其它对数组进行操作"><a href="#其它对数组进行操作" class="headerlink" title="其它对数组进行操作"></a>其它对数组进行操作</h3><p>a.forEach(function(currentValue, index, arr), thisValue)  array.forEach(function(currentValue, index, arr), thisValue)<br>a.reduce(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从左到右）。<br>a.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从右到左）。<br><a href="http://www.runoob.com/jsref/jsref-obj-array.html" target="_blank" rel="external">Array方法参考手册</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈，一种具有特殊行为的数组，具有后进先出（LIFO）原则的有序集合。<br>    （数组头部）栈底[]栈顶（数组尾部部）</p><h2 id="栈应该具有大方法"><a href="#栈应该具有大方法" class="headerlink" title="栈应该具有大方法"></a>栈应该具有大方法</h2><p>push(element(s)) ：添加一个（或几个）新元素到栈顶。<br>pop() ：移除栈顶的元素，同时返回被移除的元素。<br>peek() ：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。<br>isEmpty() ：如果栈里没有任何元素就返回 true ，否则返回 false 。<br>clear() ：移除栈里的所有元素。<br>size() ：返回栈里的元素个数。这个方法和数组的 length 属性很类似。</p><h2 id="构建栈及相应的方法"><a href="#构建栈及相应的方法" class="headerlink" title="构建栈及相应的方法"></a>构建栈及相应的方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">function Stack() &#123;</div><div class="line"></div><div class="line">// 使用数组来模拟栈</div><div class="line">let items = [];</div><div class="line"></div><div class="line">// push方法</div><div class="line">this.push = function(element)&#123;</div><div class="line">items.push(element);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// pop方法</div><div class="line">this.pop = function()&#123;</div><div class="line">return items.pop();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// peek方法</div><div class="line">this.peek = function()&#123;</div><div class="line">return items[items.length-1];</div><div class="line">// return items.slice().pop();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// isEmpty方法</div><div class="line">this.isEmpty = function()&#123;</div><div class="line">return items.length === 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// size方法</div><div class="line">this.size = function()&#123;</div><div class="line">return items.length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// clear方法</div><div class="line">this.clear = function()&#123;</div><div class="line">items = [];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// print调试方法</div><div class="line">this.print = function()&#123;</div><div class="line">console.log(items.toString());</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">let stack1 = new Stack();</div><div class="line">stack1.print(); // &apos;&apos;</div><div class="line">stack1.push(1);</div><div class="line">stack1.print(); // &apos;1&apos;</div><div class="line">stack1.clear();  </div><div class="line">stack1.print(); // &apos;&apos;</div></pre></td></tr></table></figure></code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function divideBy2(decNumber)&#123;</div><div class="line">let remStack = new Stack(),</div><div class="line">rem,</div><div class="line">binaryString = &apos;&apos;;</div><div class="line"></div><div class="line">while (decNumber &gt; 0)&#123; //&#123;1&#125;</div><div class="line">rem = Math.floor(decNumber % 2); //&#123;2&#125;</div><div class="line">remStack.push(rem); //&#123;3&#125;</div><div class="line">decNumber = Math.floor(decNumber / 2); //&#123;4&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">while (!remStack.isEmpty())&#123; //&#123;5&#125;</div><div class="line">binaryString += remStack.pop().toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line">return binaryString;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。</p><h2 id="队列需要的方法"><a href="#队列需要的方法" class="headerlink" title="队列需要的方法"></a>队列需要的方法</h2><p>enqueue(element(s)) ：向队列尾部添加一个（或多个）新的项。<br>dequeue() ：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。<br>front() ：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。<br>isEmpty() ：如果队列中不包含任何元素，返回 true ，否则返回 false 。<br>size() ：返回队列包含的元素个数，与数组的 length 属性类似。</p><h2 id="构建队列"><a href="#构建队列" class="headerlink" title="构建队列"></a>构建队列</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function Queue() &#123;</div><div class="line"></div><div class="line">// 保存数据</div><div class="line">let items = [];</div><div class="line"></div><div class="line">// enqueue方法</div><div class="line">this.enqueue = function(element)&#123;</div><div class="line">items.push(element);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// dequeue 方法</div><div class="line">this.dequeue = function()&#123;</div><div class="line">return items.shift();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// front 方法</div><div class="line">this.front = function()&#123;</div><div class="line">return items[0];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// isEmpty 方法</div><div class="line">this.isEmpty = function()&#123;</div><div class="line">return items.length === 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// size方法</div><div class="line">this.size = function()&#123;</div><div class="line">return items.length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// print 调试方法</div><div class="line">this.print = function()&#123;</div><div class="line">console.log(items.toString());</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="可以设置优先级的队列"><a href="#可以设置优先级的队列" class="headerlink" title="可以设置优先级的队列"></a>可以设置优先级的队列</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function PriorityQueue() &#123;</div><div class="line">let items = [];</div><div class="line"></div><div class="line">function QueueElement (element, priority)&#123; // &#123;1&#125;</div><div class="line">this.element = element;</div><div class="line">this.priority = priority;</div><div class="line">&#125;</div><div class="line"></div><div class="line">this.enqueue = function(element, priority)&#123;</div><div class="line">var queueElement = new QueueElement(element, priority);</div><div class="line"></div><div class="line">if (this.isEmpty())&#123;</div><div class="line">items.push(queueElement); // &#123;2&#125;</div><div class="line">&#125; else &#123;</div><div class="line">var added = false;</div><div class="line"></div><div class="line">for (var i=0; i&lt;items.length; i++)&#123;</div><div class="line">if (queueElement.priority &lt; items[i].priority)&#123;</div><div class="line">items.splice(i,0,queueElement); // &#123;3&#125;</div><div class="line">added = true;</div><div class="line">break; // &#123;4&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!added)&#123; //&#123;5&#125;</div><div class="line">items.push(queueElement);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">//其他方法和默认的Queue实现相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码var priorityQueue = new PriorityQueue();</div><div class="line">priorityQueue.enqueue(&quot;John&quot;, 2);</div><div class="line">priorityQueue.enqueue(&quot;Jack&quot;, 1);</div><div class="line">priorityQueue.enqueue(&quot;Camila&quot;, 1);</div><div class="line">priorityQueue.print(); // Jack, Camila, John</div></pre></td></tr></table></figure></code></pre><h2 id="循环队列–击鼓传花"><a href="#循环队列–击鼓传花" class="headerlink" title="循环队列–击鼓传花"></a>循环队列–击鼓传花</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function hotPotato (nameList, num)&#123;</div><div class="line">var queue = new Queue(); // &#123;1&#125;</div><div class="line"></div><div class="line">for (var i=0; i&lt;nameList.length; i++)&#123;</div><div class="line">queue.enqueue(nameList[i]); // &#123;2&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var eliminated = &apos;&apos;;</div><div class="line"></div><div class="line">while (queue.size() &gt; 1)&#123;</div><div class="line">for (var i=0; i&lt;num; i++)&#123;</div><div class="line">queue.enqueue(queue.dequeue()); // &#123;3&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">eliminated = queue.dequeue();// &#123;4&#125;</div><div class="line">console.log(eliminated + &apos;在击鼓传花游戏中被淘汰。&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return queue.dequeue();// &#123;5&#125;</div><div class="line">&#125;</div><div class="line">var names = [&apos;John&apos;,&apos;Jack&apos;,&apos;Camila&apos;,&apos;Ingrid&apos;,&apos;Carl&apos;];</div><div class="line">var winner = hotPotato(names, 7);</div><div class="line">console.log(&apos;胜利者：&apos; + winner);</div></pre></td></tr></table></figure></code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。<br>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。<br>然而，链表需要使用指针，因此实现链表时需要额外注意。<br>数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。<br>链表的优点：相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。<br>链表的缺点：数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p><h2 id="创建一个链表"><a href="#创建一个链表" class="headerlink" title="创建一个链表"></a>创建一个链表</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">function LinkedList() &#123;</div><div class="line"></div><div class="line">// 表示要加入列表的项</div><div class="line">let Node = function(element)&#123; // &#123;1&#125;</div><div class="line">this.element = element; // 填加到列表的值</div><div class="line">this.next = null; // 列表中下一个节点项的引用</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let length = 0; // &#123;2&#125;</div><div class="line"></div><div class="line">// 用于存在第一个节点的引用</div><div class="line">let head = null; </div><div class="line"></div><div class="line">// 取得链表首元素</div><div class="line">this.getHead = function()&#123;</div><div class="line">return head;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 向列表尾部添加一个新的项</div><div class="line">this.append = function(element)&#123;</div><div class="line">let node = new Node(element);</div><div class="line">current;</div><div class="line"></div><div class="line">if (head === null) &#123; // 列表中第一节点</div><div class="line">head = node;</div><div class="line">&#125; else &#123;</div><div class="line">current = head; </div><div class="line"></div><div class="line">// 循环列表，直到找到最后一项</div><div class="line">wihle(current.next)&#123;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 找到最后一项，将其next赋值为node，建立链接</div><div class="line">current.next = node;</div><div class="line">&#125;</div><div class="line"></div><div class="line">length++; // 链表长度加1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 向列表的特定位置插入一个新的项</div><div class="line">this.insert = function(position, element)&#123;</div><div class="line"></div><div class="line">//检查越界值</div><div class="line">if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; //&#123;1&#125;</div><div class="line">var node = new Node(element),</div><div class="line">current = head,</div><div class="line">previous,</div><div class="line">index = 0;</div><div class="line"></div><div class="line">if (position === 0)&#123; //在第一个位置添加</div><div class="line">node.next = current; //&#123;2&#125;</div><div class="line">head = node;</div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">while (index++ &lt; position)&#123; //&#123;3&#125;</div><div class="line">previous = current;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">node.next = current; //&#123;4&#125;</div><div class="line">previous.next = node; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">length++; //更新列表的长度</div><div class="line">return true;</div><div class="line">&#125; else &#123;</div><div class="line">return false; //&#123;6&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 从列表的特定位置移除一项</div><div class="line">this.removeAt = function(position)&#123;</div><div class="line">//检查越界值</div><div class="line">if (position &gt; -1 &amp;&amp; position &lt; length)&#123; // &#123;1&#125;</div><div class="line">var current = head, // &#123;2&#125;</div><div class="line">previous, // &#123;3&#125;</div><div class="line">index = 0; // &#123;4&#125;</div><div class="line"></div><div class="line">//移除第一项</div><div class="line">if (position === 0)&#123; // &#123;5&#125;</div><div class="line">head = current.next;</div><div class="line">&#125; else &#123;</div><div class="line">while (index++ &lt; position)&#123; // &#123;6&#125;</div><div class="line">previous = current; // &#123;7&#125;</div><div class="line">current = current.next; // &#123;8&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将previous与current的下一项链接起来：跳过current，从而移除它</div><div class="line">previous.next = current.next; // &#123;9&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">length--; // &#123;10&#125;</div><div class="line">return current.element;</div><div class="line">&#125; else &#123;</div><div class="line">return null; // &#123;11&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 从列表中移除一项</div><div class="line">this.remove = function(element)&#123;</div><div class="line">var index = this.indexOf(element);</div><div class="line">return this.removeAt(index);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回元素在列表中的索引</div><div class="line">this.indexOf = function(element)&#123;</div><div class="line">var current = head, //&#123;1&#125;</div><div class="line">index = -1;</div><div class="line">while (current) &#123; //&#123;2&#125;</div><div class="line">if (element === current.element) &#123;</div><div class="line">return index; //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">index++; //&#123;4&#125;</div><div class="line">current = current.next; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line">return -1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 如果链表中不包含任何元素，返回 true ，如果链表长度大于0则返回 false</div><div class="line">this.isEmpty = function() &#123;</div><div class="line">return length === 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回链表包含的元素个数。与数组的 length 属性类似</div><div class="line">this.size = function() &#123;</div><div class="line">return length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 由于列表项使用了 Node 类，就需要重写继承自JavaScript对象默认的toString 方法，让其只输出元素的值</div><div class="line">this.toString = function()&#123;</div><div class="line">var current = head, //&#123;1&#125;</div><div class="line">string = &apos;&apos;; //&#123;2&#125;</div><div class="line"></div><div class="line">while (current) &#123; //&#123;3&#125;</div><div class="line">string = current.element; //&#123;4&#125;</div><div class="line">current = current.next; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return string; //&#123;6&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 调试方法</div><div class="line">this.print = function()&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表的特点：双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。<br>当我们访问链表项时，在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">function  DoublyLinkedList()&#123;</div><div class="line">var Node = function(element)&#123;</div><div class="line">this.element = element;</div><div class="line">this.next = null;</div><div class="line">this.prev = null; //新增的</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var length = 0;</div><div class="line">var head = null;</div><div class="line">var tail = null; //新增的</div><div class="line"></div><div class="line">this.insert = function(position, element)&#123;</div><div class="line">//检查越界值</div><div class="line">if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123;</div><div class="line">var node = new Node(element),</div><div class="line">current = head,</div><div class="line">previous,</div><div class="line">index = 0;</div><div class="line">if (position === 0)&#123; //在第一个位置添加</div><div class="line">if (!head)&#123; //新增的 &#123;1&#125;</div><div class="line">head = node;</div><div class="line">tail = node;</div><div class="line">&#125; else &#123;</div><div class="line">node.next = current;</div><div class="line">current.prev = node; //新增的 &#123;2&#125;</div><div class="line">head = node;</div><div class="line">&#125;</div><div class="line">&#125; else if (position === length) &#123; //最后一项 //新增的</div><div class="line">current = tail; // &#123;3&#125;</div><div class="line">current.next = node;</div><div class="line">node.prev = current;</div><div class="line">tail = node;</div><div class="line">&#125; else &#123;</div><div class="line">while (index++ &lt; position)&#123; //&#123;4&#125;</div><div class="line">previous = current;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line">node.next = current; //&#123;5&#125;</div><div class="line">previous.next = node;</div><div class="line">current.prev = node; //新增的</div><div class="line">node.prev = previous; //新增的</div><div class="line">&#125;</div><div class="line">length++; //更新列表的长度</div><div class="line">return true;</div><div class="line">&#125; else &#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.removeAt = function(position)&#123;</div><div class="line">//检查越界值</div><div class="line">if (position &gt; -1 &amp;&amp; position &lt; length)&#123;</div><div class="line">var current = head,</div><div class="line">previous,</div><div class="line">index = 0;</div><div class="line">//移除第一项</div><div class="line">if (position === 0)&#123;</div><div class="line">head = current.next; // &#123;1&#125;</div><div class="line">//如果只有一项，更新tail //新增的</div><div class="line">if (length === 1)&#123; // &#123;2&#125;</div><div class="line">tail = null;</div><div class="line">&#125; else &#123;</div><div class="line">head.prev = null; // &#123;3&#125;</div><div class="line">&#125;</div><div class="line">&#125; else if (position === length-1)&#123; //最后一项 //新增的</div><div class="line">current = tail; // &#123;4&#125;</div><div class="line">tail = current.prev;</div><div class="line">tail.next = null;</div><div class="line">&#125; else &#123;</div><div class="line">while (index++ &lt; position)&#123; // &#123;5&#125;</div><div class="line">previous = current;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line">//将previous与current的下一项链接起来——跳过current</div><div class="line">previous.next = current.next; // &#123;6&#125;</div><div class="line">current.next.prev = previous; //新增的</div><div class="line">&#125;</div><div class="line">length--;</div><div class="line">return current.element;</div><div class="line">&#125; else &#123;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单向循环链表的特点：循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用 null ，而是指向第一个元素（ head ）。<br>双向循环链表有指向 head 元素的 tail.next ，和指向 tail 元素的 head.prev 。</p><h1 id="集合（es6的Set）"><a href="#集合（es6的Set）" class="headerlink" title="集合（es6的Set）"></a>集合（es6的Set）</h1><p>集合的定义：集合是由一组无序且唯一（即不能重复）的项组成的。<br>集合的操作：集合也有并集、交集、差集等基本操作。</p><h2 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Set()&#123;</div><div class="line">let items = &#123;&#125;; // js对象不允许两个不同的属性，保证集合元素的唯一性</div><div class="line"></div><div class="line">this.has = function(value)&#123;</div><div class="line">// 区别 in可以查找原型链而 hasOwnProperty方法只会查找自身</div><div class="line">// return value in items;</div><div class="line">return items.hasOwnProperty(value);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.add = function(value)&#123;</div><div class="line">if (!this.has(value)) &#123;</div><div class="line">items[value] = value;</div><div class="line">return ture;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(value)&#123;</div><div class="line">if (this.has(value)) &#123;</div><div class="line">delete items[value];</div><div class="line">return ture;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.clear = function()&#123;</div><div class="line">items = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.size = function()&#123;</div><div class="line">return Object.keys(items).length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.values = function()&#123;</div><div class="line">return Object.keys(items);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。<br>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。<br>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。<br>子集：验证一个给定集合是否是另一集合的子集。<br>一下假设A、B为两个集合。</p><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>运算公式：A∪B = { x | x ∈ A∨x ∈ B }<br>为Set类的union方法<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 思路先将原集合和新集合循环添加到并集合中</div><div class="line">this.union = function(otherSet)&#123;</div><div class="line">let unionSet = new Set();</div><div class="line">let values = this.values();</div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">unionSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">values = otherSet.values();</div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">unionSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">return unionSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>运算公式：A∩B = { x | x ∈ A∧x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.intersection = function(otherSet)&#123;</div><div class="line">let intersectionSet = new Set();</div><div class="line">let values = this.values();</div><div class="line"></div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">if (otherSet.has(values[i])) &#123;</div><div class="line">intersectionSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return intersectionSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>计算公式：AB = { x | x ∈ A ∧ x   B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.difference = function(otherSet)&#123;</div><div class="line">let differenceSet = new Set();</div><div class="line">let values = this.values();</div><div class="line"></div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">if (!otherSet.has(values[i])) &#123;</div><div class="line">differenceSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return differenceSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>运算公式：∀x { x ∈ A → x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">this.subset = function(otherSet)&#123;</div><div class="line">if (this.size() &gt; otherSet.size()) &#123;</div><div class="line">return false;</div><div class="line">&#125; else &#123;</div><div class="line">values = this.values();</div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">if (!otherSet.has(values[i])) &#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h1 id="字典（映射es6的Map）"><a href="#字典（映射es6的Map）" class="headerlink" title="字典（映射es6的Map）"></a>字典（映射es6的Map）</h1><p>字典和散列表是用来存储唯一值（不重复的值）的数据结构。<br>两者都是[键，值]的形式来存储数据    </p><h2 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">function  Dictionary()&#123;</div><div class="line">let items = &#123;&#125;;</div><div class="line"></div><div class="line">this.has = function(key)&#123;</div><div class="line">return key in items;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.set = function(key, value)&#123;</div><div class="line">items[key] = value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">if (this.has(key)) &#123;</div><div class="line">delete items[key];</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">return this.has(key) ? items[key] : undefined;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.values = function()&#123;</div><div class="line">let values = &#123;&#125;;</div><div class="line">for (let k in items) &#123;</div><div class="line">if (this.has(k)) &#123;</div><div class="line">values.push(items[k]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return values;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.clear = function()&#123;</div><div class="line">items = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.getItems = function()&#123;</div><div class="line">return items;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列算法的作用是尽可能快地在数据结构中找到一个值。<br>使用散列函数，就知道值的具体位置，因此能够快速检索到该值。<br>散列函数的作用是给定一个键值，然后返回值在表中的地址。</p><h2 id="创建一个散列表"><a href="#创建一个散列表" class="headerlink" title="创建一个散列表"></a>创建一个散列表</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function HashTable()&#123;</div><div class="line">var table = [];</div><div class="line">// 私有方法-散列函数</div><div class="line">let loseloseHashCode = function(key)&#123;</div><div class="line">let hash = 0;</div><div class="line">for (let i = 0; i &lt; key.length; i++) &#123;</div><div class="line">hash += key.charCodeAt(i);</div><div class="line">&#125;</div><div class="line">return hash % 37;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.put = function(key, value)&#123;</div><div class="line">let position = loseloseHashCode(key);</div><div class="line">console.log(position + &apos; - &apos; + key); //&#123;6&#125;</div><div class="line">table[position] = value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">return table[loseloseHashCode(key)];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">table[loseloseHashCode(key)] = undefined;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="处理散列表的冲突（同名的地址覆盖）"><a href="#处理散列表的冲突（同名的地址覆盖）" class="headerlink" title="处理散列表的冲突（同名的地址覆盖）"></a>处理散列表的冲突（同名的地址覆盖）</h2><p>可以通过分离链接、线性探查和双散列法来解决冲突。</p><h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>定义：包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>为了实现一个使用了分离链接的 HashTable 实例，我们需要一个新的辅助类来表示将要加入LinkedList 实例的元素。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">let ValuePair = function(key, value)&#123;</div><div class="line">this.key = key;</div><div class="line">this.value = value;</div><div class="line">this.toString = function() &#123;</div><div class="line">return &apos;[&apos; + this.key + &apos; - &apos; + this.value + &apos;]&apos;;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.put = function(key, value)&#123;</div><div class="line">let position = loseloseHashCode(key);</div><div class="line">if (table[position] == undefined) &#123;</div><div class="line">table[position] = new LinkedList();</div><div class="line">&#125;</div><div class="line">table[position].append(new ValuePair(key, value));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">let position = loseloseHashCode(key);</div><div class="line"></div><div class="line">if (table[position] !== undefined) &#123;</div><div class="line">// 遍历链表来寻找键/值</div><div class="line">let current = table[position].getHead();</div><div class="line">while (current.next) &#123;</div><div class="line">if (current.elment.key === key) &#123;</div><div class="line">return current.element.value;</div><div class="line">&#125;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检查元素在链表第一个或最后一个节点的情况</div><div class="line">if (current.element.key === key)&#123; //&#123;9&#125;</div><div class="line">return current.element.value;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return undefined;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">var position = loseloseHashCode(key);</div><div class="line">if (table[position] !== undefined)&#123;</div><div class="line">var current = table[position].getHead();</div><div class="line">while(current.next)&#123;</div><div class="line">if (current.element.key === key)&#123; //&#123;11&#125;</div><div class="line">table[position].remove(current.element); //&#123;12&#125;</div><div class="line">if (table[position].isEmpty())&#123; //&#123;13&#125;</div><div class="line">table[position] = undefined; //&#123;14&#125;</div><div class="line">&#125;</div><div class="line">return true; //&#123;15&#125;</div><div class="line">&#125;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line">// 检查是否为第一个或最后一个元素</div><div class="line">if (current.element.key === key)&#123; //&#123;16&#125;</div><div class="line">table[position].remove(current.element);</div><div class="line">if (table[position].isEmpty())&#123;</div><div class="line">table[position] = undefined;</div><div class="line">&#125;</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return false; //&#123;17&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">this.put = function(key, value)&#123;</div><div class="line">var position = loseloseHashCode(key); // &#123;1&#125;</div><div class="line">if (table[position] == undefined) &#123; // &#123;2&#125;</div><div class="line">table[position] = new ValuePair(key, value); // &#123;3&#125;</div><div class="line">&#125; else &#123;</div><div class="line">var index = ++position; // &#123;4&#125;</div><div class="line">while (table[index] != undefined)&#123; // &#123;5&#125;</div><div class="line">index++; // &#123;6&#125;</div><div class="line">&#125;</div><div class="line">table[index] = new ValuePair(key, value); // &#123;7&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key) &#123;</div><div class="line">var position = loseloseHashCode(key);</div><div class="line">if (table[position] !== undefined)&#123; //&#123;8&#125;</div><div class="line">if (table[position].key === key) &#123; //&#123;9&#125;</div><div class="line">return table[position].value; //&#123;10&#125;</div><div class="line">&#125; else &#123;</div><div class="line">var index = ++position;</div><div class="line">while (table[index] === undefined || table[index].key !== key)&#123; //&#123;11&#125;</div><div class="line">index++;</div><div class="line">&#125;</div><div class="line">if (table[index].key === key) &#123; //&#123;12&#125;</div><div class="line">return table[index].value; //&#123;13&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return undefined; //&#123;14&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="创建更好的散列函数"><a href="#创建更好的散列函数" class="headerlink" title="创建更好的散列函数"></a>创建更好的散列函数</h3><p>比较好的散列函数，不会产生太多的冲突。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var djb2HashCode = function (key) &#123;</div><div class="line">var hash = 5381; //&#123;1&#125;</div><div class="line">for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125;</div><div class="line">hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">return hash % 1013; //&#123;4&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="序列数据结构"><a href="#序列数据结构" class="headerlink" title="序列数据结构"></a>序列数据结构</h2><p>1.数组（列表）<br>2.栈<br>3.队列<br>    普通队列<br>    优先队列<br>    循环队列<br>4.链表<br>    单向链表<br>    双向链表<br>    循环单向链表<br>    循环双向链表<br>5.集合</p><h2 id="非序列数据结构"><a href="#非序列数据结构" class="headerlink" title="非序列数据结构"></a>非序列数据结构</h2><p>1.散列<br>2.字典</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组及矩阵（二维数组）和多维数组（a-b-均为数组）&quot;&gt;&lt;a href=&quot;#数组及矩阵（二维数组）和多维数组（a-b-均为数组）&quot; class=&quot;headerlink&quot; title=&quot;数组及矩阵（二维数组）和多维数组（a, b 均为数组）&quot;&gt;&lt;/a&gt;数组及矩阵（二
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="数据结构" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-总结性文章</title>
    <link href="https://fanerge.github.io/2017/11/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E6%80%A7%E6%96%87%E7%AB%A0/"/>
    <id>https://fanerge.github.io/2017/11/23/排序算法-总结性文章/</id>
    <published>2017-11-23T12:26:14.000Z</published>
    <updated>2017-11-23T14:44:55.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法的基本概念"><a href="#排序算法的基本概念" class="headerlink" title="排序算法的基本概念"></a>排序算法的基本概念</h1><h2 id="什么叫排序？"><a href="#什么叫排序？" class="headerlink" title="什么叫排序？"></a>什么叫排序？</h2><p>排序(Sorting) 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。</p><h2 id="排序算法的性质"><a href="#排序算法的性质" class="headerlink" title="排序算法的性质"></a>排序算法的性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。<br>反之，不稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中S在R之前。</p><h3 id="时间复杂度（最差、平均、和最好性能）T-n"><a href="#时间复杂度（最差、平均、和最好性能）T-n" class="headerlink" title="时间复杂度（最差、平均、和最好性能）T(n)"></a>时间复杂度（最差、平均、和最好性能）T(n)</h3><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。<br>    T(n) = O(f(n))<br>一般而言，好的性能是 O(nlogn)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">查看时间复杂度计算方式</a></p><h3 id="空间复杂度S-n"><a href="#空间复杂度S-n" class="headerlink" title="空间复杂度S(n)"></a>空间复杂度S(n)</h3><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。</p><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>内排序：所有排序操作都在内存中完成。<br>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">更多详情</a></p><h1 id="先来张总结性图片"><a href="#先来张总结性图片" class="headerlink" title="先来张总结性图片"></a>先来张总结性图片</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt=""></p><h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（尾部），故名。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个（因为每次最后遍历的最后一个数都是最大的，所以不需要再次比较了）。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>选择排序法是对定位比较交换法（也就是冒泡排序法）的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</p><h2 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换，<br>2.第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换，<br>3.以此类推…<br>4.第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，<br>5.使有序序列不断增长直到全部排序完毕。<br>PS：冒泡排序是逐次把当前序列中最大值<span style="color: red;">推</span>到后面去。<br>    选择排序是逐次把当前序列中最小值<span style="color: red;">放</span>到前面去。<br><a href="https://fanerge.github.io/2017/11/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。<br>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。</p><h2 id="直接插入排序实现步骤"><a href="#直接插入排序实现步骤" class="headerlink" title="直接插入排序实现步骤"></a>直接插入排序实现步骤</h2><p>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：<br>①初始状态：无序区为R[1..n]，有序区为空。<br>②第1趟排序<br>在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br>……<br>③第i趟排序<br>第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。</p><h2 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.二分法查找插入位置<br>    如果R&lt;R[m]成立，那右指针就要向左移动中间指针一位，否则，左指针要向右移动中间指针一位。反复查找，直到左指针大于右指针时停止。<br>2.后移，有点迷惑，什么时候需要后移呢？有哪些记录需要移动呢？<br>    虽然我们很清楚的知道，我们需要后移那些排序码大于R的记录，但难免会问自己这样几个问题。其实它相当于需要移动从i-1到左指针的记录。<br>3.插入<br>    由1中得到的左指针其实就是元素要插入的位置。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p><h2 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>对数组arr，长度为n进行排序<br>1.第一个增量为Math.floor(n/2)，再最每个小的分租进行直接插入排序；<br>2.第二个增量为Math.floor(n/4)，再最每个小的分租进行直接插入排序；<br>3.以此类推…，直到增量为1，这是排序完成。<br><a href="https://fanerge.github.io/2017/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h2 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾,这时完成排序。<br><a href="https://fanerge.github.io/2017/11/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h2 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>一趟快速排序的算法是：排序序列A，N为排序序列长度<br>1.找基准（一般是以当前数组的第一项的值）<br>2.遍历数组，小于基准的放在left，大于基准的放在right<br>3.递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br><a href="https://fanerge.github.io/2017/11/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><h2 id="实现步骤-6"><a href="#实现步骤-6" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br><a href="https://fanerge.github.io/2017/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h2><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p><h2 id="实现步骤-7"><a href="#实现步骤-7" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出待排序的数组中最大和最小的元素；<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>4.反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br><a href="https://fanerge.github.io/2017/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="桶排序-Bucket-SORT）"><a href="#桶排序-Bucket-SORT）" class="headerlink" title="桶排序 (Bucket SORT）"></a>桶排序 (Bucket SORT）</h1><h2 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h2><p>输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。</p><h2 id="实现步骤-8"><a href="#实现步骤-8" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br><a href="https://fanerge.github.io/2017/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h2><p>基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><h2 id="实现步骤-9"><a href="#实现步骤-9" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p></li><li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br><a href="https://fanerge.github.io/2017/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些算法我还记得在大学时学过的，只不过当然并没有太在意，这也许就是–欠下的债，终究是要还的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法的基本概念&quot;&gt;&lt;a href=&quot;#排序算法的基本概念&quot; class=&quot;headerlink&quot; title=&quot;排序算法的基本概念&quot;&gt;&lt;/a&gt;排序算法的基本概念&lt;/h1&gt;&lt;h2 id=&quot;什么叫排序？&quot;&gt;&lt;a href=&quot;#什么叫排序？&quot; class=&quot;head
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-基数排序</title>
    <link href="https://fanerge.github.io/2017/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/22/排序算法-基数排序/</id>
    <published>2017-11-22T12:04:29.000Z</published>
    <updated>2017-11-22T13:27:24.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序（radix-sort）的基础"><a href="#基数排序（radix-sort）的基础" class="headerlink" title="基数排序（radix sort）的基础"></a>基数排序（radix sort）的基础</h1><p>技术排序的定义：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><h1 id="基数排序步骤"><a href="#基数排序步骤" class="headerlink" title="基数排序步骤"></a>基数排序步骤</h1><p>以LSD为例，排序数组arr = [73, 22, 93, 43, 55, 14, 28, 65, 39, 81];<br>    注：最低位优先(Least Significant Digit first)法，简称LSD法<br>        最高位优先(Most Significant Digit first)法，简称MSD法</p><ol><li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p></li><li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>PS：LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line">//LSD Radix Sort</div><div class="line">function radixSort(array, maxDigit) &#123;</div><div class="line">var mod = 10;</div><div class="line">var dev = 1;</div><div class="line">var counter = [];</div><div class="line">var arr = array.slice();</div><div class="line">console.time(&apos;基数排序耗时&apos;);</div><div class="line">for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</div><div class="line">for(var j = 0; j &lt; arr.length; j++) &#123;</div><div class="line">var bucket = parseInt((arr[j] % mod) / dev);</div><div class="line">if(counter[bucket]== null) &#123;</div><div class="line">counter[bucket] = [];</div><div class="line">&#125;</div><div class="line">counter[bucket].push(arr[j]);</div><div class="line">&#125;</div><div class="line">var pos = 0;</div><div class="line">for(var j = 0; j &lt; counter.length; j++) &#123;</div><div class="line">var value = null;</div><div class="line">if(counter[j]!=null) &#123;</div><div class="line">while ((value = counter[j].shift()) != null) &#123;</div><div class="line">  arr[pos++] = value;</div><div class="line">&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">console.timeEnd(&apos;基数排序耗时&apos;);</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">var demo = radixSort(arr,2);</div><div class="line">console.log(arr); // [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(demo); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</div></pre></td></tr></table></figure></code></pre><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图">    </p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="external">基数排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基数排序（radix-sort）的基础&quot;&gt;&lt;a href=&quot;#基数排序（radix-sort）的基础&quot; class=&quot;headerlink&quot; title=&quot;基数排序（radix sort）的基础&quot;&gt;&lt;/a&gt;基数排序（radix sort）的基础&lt;/h1&gt;&lt;p&gt;技术
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-桶排序</title>
    <link href="https://fanerge.github.io/2017/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/21/排序算法-桶排算法/</id>
    <published>2017-11-21T12:01:12.000Z</published>
    <updated>2017-11-21T13:08:28.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序的基础"><a href="#桶排序的基础" class="headerlink" title="桶排序的基础"></a>桶排序的基础</h1><p>桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。<br>桶排序的说明：桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O(n)）。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p><h1 id="桶排序的步骤"><a href="#桶排序的步骤" class="headerlink" title="桶排序的步骤"></a>桶排序的步骤</h1><div style="color: red;"><br>1.    找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.    计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.    再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.    将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.    将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br></div><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">// 插入排序</div><div class="line">function insertionSort(arr) &#123;</div><div class="line">var len = arr.length;</div><div class="line">var preIndex, current;</div><div class="line">for (var i = 1; i &lt; len; i++) &#123;</div><div class="line">preIndex = i - 1;</div><div class="line">current = arr[i];</div><div class="line">while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">arr[preIndex+1] = arr[preIndex];</div><div class="line">preIndex--;</div><div class="line">&#125;</div><div class="line">arr[preIndex+1] = current;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶排序</div><div class="line">function bucketSort(array, bucketSize) &#123;</div><div class="line">let arr = array.slice();</div><div class="line">let i;</div><div class="line">let minValue = arr[0];</div><div class="line">let maxValue = arr[0];</div><div class="line"></div><div class="line">// 空数组时直接返回空数组</div><div class="line">if (arr.length === 0) &#123;</div><div class="line">  return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for (i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">  if (arr[i] &lt; minValue) &#123;</div><div class="line">  minValue = arr[i];                //输入数据的最小值</div><div class="line">  &#125; else if (arr[i] &gt; maxValue) &#123;</div><div class="line">  maxValue = arr[i];                //输入数据的最大值</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶的初始化</div><div class="line">let DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5</div><div class="line">bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</div><div class="line">let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   </div><div class="line">let buckets = new Array(bucketCount);</div><div class="line"></div><div class="line">// 二维数组，每个桶初始化为空数组</div><div class="line">for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">buckets[i] = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 利用映射函数将数据分配到各个桶中</div><div class="line">for (i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">arr.length = 0;</div><div class="line">for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">insertionSort(buckets[i]);                      //对每个桶进行插入排序</div><div class="line">for (var j = 0; j &lt; buckets[i].length; j++) &#123;</div><div class="line">arr.push(buckets[i][j]);                      </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109];</div><div class="line">var demo = bucketSort(arr, 4); // 这里我分配了4个桶，桶越多越快但需要的内存就越多</div><div class="line">console.log(arr); // [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]</div><div class="line">console.log(demo); // [13, 28, 47, 51, 63, 67, 98, 101, 109, 117, 121, 133, 139, 141, 156, 157, 157, 181, 189, 194]</div></pre></td></tr></table></figure></code></pre><p>PS：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br>什么时候最快（Best Cases）：<br>  当输入的数据可以均匀的分配到每一个桶中<br>什么时候最慢（Worst Cases）：<br>  当输入的数据被分配到了同一个桶中</li></ol><h1 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg" alt="图片展示"></p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin#4_2" target="_blank" rel="external">桶排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序的基础&quot;&gt;&lt;a href=&quot;#桶排序的基础&quot; class=&quot;headerlink&quot; title=&quot;桶排序的基础&quot;&gt;&lt;/a&gt;桶排序的基础&lt;/h1&gt;&lt;p&gt;桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-计数排序</title>
    <link href="https://fanerge.github.io/2017/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/20/排序算法-计数排序/</id>
    <published>2017-11-20T12:15:37.000Z</published>
    <updated>2017-11-20T13:47:37.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序的基础"><a href="#计数排序的基础" class="headerlink" title="计数排序的基础"></a>计数排序的基础</h1><p>定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）<br>计数排序对输入的数据有附加的限制条件：<br>    1、输入的线性表的元素属于有限偏序集S；<br>    2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。    </p><h1 id="计数排序算法思想"><a href="#计数排序算法思想" class="headerlink" title="计数排序算法思想"></a>计数排序算法思想</h1><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p><h1 id="现实计数算法"><a href="#现实计数算法" class="headerlink" title="现实计数算法"></a>现实计数算法</h1><h2 id="具体算法实现步骤"><a href="#具体算法实现步骤" class="headerlink" title="具体算法实现步骤"></a>具体算法实现步骤</h2><p><1>. 找出待排序的数组中最大和最小的元素；</1></p><p><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></p><p><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></p><p><4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function countingSort(arr)&#123;</div><div class="line">let len = arr.length,</div><div class="line">Result = [], // 保存排序后的数组</div><div class="line">Count = [], // 保存各项出现次数的数组</div><div class="line">min = max = arr[0];</div><div class="line">console.time(&apos;计数排序计时&apos;);</div><div class="line"></div><div class="line">// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数</div><div class="line">for(var i = 0; i &lt; len; i++)&#123;</div><div class="line">Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数</div><div class="line">min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值</div><div class="line">max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 从最小值-&gt;最大值,将计数逐项相加</div><div class="line">for(var j = min; j &lt; max; j++)&#123;</div><div class="line">Count[j+1] = (Count[j+1]||0)+(Count[j]||0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</div><div class="line">for(var k = len - 1; k &gt;= 0;k--)&#123;</div><div class="line">/*Result[位置] = arr数据*/</div><div class="line">Result[Count[arr[k]] - 1] = arr[k];</div><div class="line">/*减少Count数组中保存的计数*/</div><div class="line">Count[arr[k]]--;</div><div class="line">/*显示Result数组每一步详情*/</div><div class="line">console.log(Result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.timeEnd(&apos;计数排序计时&apos;);</div><div class="line">return Result;</div><div class="line">&#125;</div><div class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</div><div class="line">console.log(countingSort(arr));</div></pre></td></tr></table></figure></4></p><pre><code>PS：时间复杂度：T(n) = O(n)空间复杂度：S(n) = O(k)是否稳定：是排序方式：外排序</code></pre><p>运行结果为:<br>[ , , , , , , , , , , , , , 48 ]<br>[ , , , , , , , , , , , , , 48, 50 ]<br>[ , , , , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>计数排序计时: 16ms<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图 | center"></p><blockquote><p>   参考文档：<br>    <a href="http://hao.jser.com/archive/13600/" target="_blank" rel="external">基本算法学习(四)之计数排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin" target="_blank" rel="external">计数排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数排序的基础&quot;&gt;&lt;a href=&quot;#计数排序的基础&quot; class=&quot;headerlink&quot; title=&quot;计数排序的基础&quot;&gt;&lt;/a&gt;计数排序的基础&lt;/h1&gt;&lt;p&gt;定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-堆排序</title>
    <link href="https://fanerge.github.io/2017/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/15/排序算法-堆排序/</id>
    <published>2017-11-15T11:47:34.000Z</published>
    <updated>2017-11-15T15:20:38.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序（Heapsort）的基础"><a href="#堆排序（Heapsort）的基础" class="headerlink" title="堆排序（Heapsort）的基础"></a>堆排序（Heapsort）的基础</h1><p>定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><h1 id="我们需要了解什么叫堆"><a href="#我们需要了解什么叫堆" class="headerlink" title="我们需要了解什么叫堆"></a>我们需要了解什么叫堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：<br>        (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点<br>        若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p><h2 id="来个例子说明"><a href="#来个例子说明" class="headerlink" title="来个例子说明"></a>来个例子说明</h2><p>【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。<br>    小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。<br>    大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。<br>    注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。<br>    来张图表示一下：<br>    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b360e14f7bec54e755e1124cd851f035/43a7d933c895d1433f14885273f082025aaf0764.jpg" alt="大跟堆和小跟堆"></p><h2 id="堆的高度"><a href="#堆的高度" class="headerlink" title="堆的高度"></a>堆的高度</h2><p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p><div style="color: red;"><br>    <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>    <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>    <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br></3></2></1></div>    </p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>```/** * 对数组中的前n项整理成堆 * @param array * @param n */function refreshHeap(array, n){    if(array.length&lt;n)n = array.length;    //array[n/2-1]表示的是最后一个有子节点的节点    for(let i=Math.floor(n/2)-1;i&gt;=0;i--){        //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点        //这个while是判断当前节点与其子节点是否需要调整        while(2*i+1&lt;n){            let j = 2*i+1;            //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点            if(j+1&lt;n){                //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点）                if(array[j]&lt;a[j+1]){                    j++;                }            }            //如果最大子节点大于其父节点，则交换            if(a[i]&lt;a[j]){                let tmp = a[i];                a[i] = a[j];                a[j] = tmp;                //交换之后整个堆被破坏，需要重新调整，故令i=j                //这个调整表示的是从j节点开始判断堆是否需要调整                //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整                i = j;            }else{                break;            }        }    }    return array;}function heapSort(array, n){    if(array.length&lt;n)n = array.length;    while(n&gt;0){        //刷新堆之后，将array[0]（最大值）与最后一个子节点交换        //然后重新刷新堆(不包括最后那些排好序的节点了)        refreshHeap(array, n--);        let tmp = array[n];        array[n] = array[0];        array[0] = tmp;    }    return array;}var a = [16,7,3,20,17,8];console.log(a); // [16, 7, 3, 20, 17, 8]heapSort(a,a.length);console.log(a); // [3, 7, 8, 16, 17, 20]```    </code></pre><p>时间复杂度：T(n) = O(nlogn)<br>空间复杂度：S(n) = O(1)<br>稳定性：不稳定<br>排序方式：内排序    </p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F" alt="动图">    </p><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/liuyaqi1993/article/details/69569059" target="_blank" rel="external">JavaScript数据结构之 堆排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="external">堆排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆排序（Heapsort）的基础&quot;&gt;&lt;a href=&quot;#堆排序（Heapsort）的基础&quot; class=&quot;headerlink&quot; title=&quot;堆排序（Heapsort）的基础&quot;&gt;&lt;/a&gt;堆排序（Heapsort）的基础&lt;/h1&gt;&lt;p&gt;定义：堆排序(Heapsor
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-快速排序</title>
    <link href="https://fanerge.github.io/2017/11/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/14/排序算法-快速排序/</id>
    <published>2017-11-14T12:13:47.000Z</published>
    <updated>2017-11-14T14:18:55.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序（Quicksort）的基础"><a href="#快速排序（Quicksort）的基础" class="headerlink" title="快速排序（Quicksort）的基础"></a>快速排序（Quicksort）的基础</h1><p>定义：快速排序（Quicksort）是对冒泡排序的一种改进。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="快速排序算法的介绍"><a href="#快速排序算法的介绍" class="headerlink" title="快速排序算法的介绍"></a>快速排序算法的介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br>一趟快速排序的算法是：<br>    1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>    2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>    3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>    4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>    5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><h1 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h1><p>假设用户输入了如下数组：<br><span style="padding-left: 24px; color: red;">6, 2, 7, 3, 8, 9</span><br>1.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。<br>我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：<br><span style="padding-left: 24px; color: red;">3, 2, 7, 6, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=0 j=3 k=6</span><br>接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=2 j=3 k=6</span><br>称上面两次比较为一个循环。<br>接着，再递减变量j，不断重复进行上面的循环比较。<br>在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br>如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。<br>然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。<br>注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前面讲了那么多了，简单就记住下面的步骤就好了。</p><p><div style="color: red;"><br>1、找基准（一般是以当前数组的第一项的值）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br></div><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function quickSort(array)&#123;</div><div class="line">let arr = array.slice();</div><div class="line"></div><div class="line">//如果数组&lt;=1,则直接返回</div><div class="line">if(arr.length&lt;=1)&#123;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//找基准，并把基准从原数组删除</div><div class="line">var pivot=arr.splice(0,1)[0];</div><div class="line">//定义左右数组</div><div class="line">var left=[];</div><div class="line">var right=[];</div><div class="line"></div><div class="line">//比基准小的放在left，比基准大的放在right</div><div class="line">for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">if(arr[i]&lt;=pivot)&#123;</div><div class="line">left.push(arr[i]);</div><div class="line">&#125;</div><div class="line">else&#123;</div><div class="line">right.push(arr[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//递归</div><div class="line">return quickSort(left).concat([pivot],quickSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [6, 2, 7, 3, 8, 9];</div><div class="line">let demo = quickSort(arr);</div><div class="line"></div><div class="line">console.log(arr); // [6, 2, 7, 3, 8, 9];</div><div class="line">console.log(demo); // [2, 3, 6, 7, 8, 9];</div></pre></td></tr></table></figure></p><p>时间复杂度：T(n) = O(n^2)<br>空间复杂度：S(n) = O(logn)<br>稳定性：不稳定<br>是否为内排序：是</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源网络，在次表示感谢</a></p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dll-ft/p/5850487.html" target="_blank" rel="external">JS实现快速排序</a><br>    <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&amp;fromid=2084344&amp;fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#3_7" target="_blank" rel="external">快速排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序（Quicksort）的基础&quot;&gt;&lt;a href=&quot;#快速排序（Quicksort）的基础&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quicksort）的基础&quot;&gt;&lt;/a&gt;快速排序（Quicksort）的基础&lt;/h1&gt;&lt;p&gt;定义：快速排
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-归并算法</title>
    <link href="https://fanerge.github.io/2017/11/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/13/排序算法-归并算法/</id>
    <published>2017-11-13T12:18:58.000Z</published>
    <updated>2017-11-14T12:16:45.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序（MERGE-SORT）基础"><a href="#归并排序（MERGE-SORT）基础" class="headerlink" title="归并排序（MERGE-SORT）基础"></a>归并排序（MERGE-SORT）基础</h1><p>定义：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>实现过程：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p><h1 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h1><p>归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>假设要对数组C进行归并排序，步骤是：<br>    let C = [10, 4, 6, 3, 8, 2, 5, 7];<br>    1.先将C划分为两个数组A和B（即把数组C从中间分开 n = Math.floor(C.length/2)）<br>    2.再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。<br>    3.然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。<br>    4.依次类推，直到合并到最上层结束，这时数据的排序已经完成了。</p><h2 id="算法划分和合并过程"><a href="#算法划分和合并过程" class="headerlink" title="算法划分和合并过程"></a>算法划分和合并过程</h2><p><div style="color: red;"><br>    先划分：              [10, 4, 6, 3, 8, 2, 5, 7]<br>    第一次划分：[10, 4, 6, 3]         [8, 2, 5, 7]<br>    第二次划分：[10, 4]   [6, 3]      [8, 2]  [5, 7]<br>    第三次划分：[10] [4] [6] [3]      [8] [2] [5] [7]<br>    再合并：<br>    第一次合并：[4, 10] [3, 6]      [2, 8] [5, 7]<br>    第二次合并：[3, 4, 6, 10]      [2, 5, 7, 8]<br>    第三次合并：[2, 3, 4, 5, 6, 7, 8, 10]<br></div><br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt="图解">    </p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function　merge(left, right)&#123;</div><div class="line">var　result=[];</div><div class="line">while(left.length &amp;&amp; right.length)&#123;</div><div class="line">if(left[0] &lt; right[0])&#123;</div><div class="line">/*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/</div><div class="line">result.push(left.shift());</div><div class="line">&#125;else&#123;</div><div class="line">result.push(right.shift());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return　result.concat(left).concat(right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function　mergeSort(items)&#123;</div><div class="line">if(items.length === 1)&#123;</div><div class="line">return　items;</div><div class="line">&#125;</div><div class="line">let　middle = Math.floor(items.length/2),</div><div class="line">left = items.slice(0, middle), //得到下标从0~index-1的数组</div><div class="line">right = items.slice(middle); //得到下标从index开始到末尾的数组</div><div class="line">return　merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [10, 4, 6, 3, 8, 2, 5, 7];</div><div class="line">let demo = mergeSort(arr)</div><div class="line">console.log(arr); // [10, 4, 6, 3, 8, 2, 5, 7]</div><div class="line">console.log(demo); // [2, 3, 4, 5, 6, 7, 8, 10]</div></pre></td></tr></table></figure></code></pre><p>ps：使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。<br>    时间复杂度：O(n log n)<br>    空间复炸都：O（n)<br>    稳定性：稳定<br>    排序方式：外排序</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源，在此表示感谢</a>    </p><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/fendou_dexiaoniao/article/details/46594125" target="_blank" rel="external">JS实现归并排序</a><br>    <a href="https://www.cnblogs.com/lizhancheng/p/3989809.html" target="_blank" rel="external">js归并排序法</a><br>    <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin#5_10" target="_blank" rel="external">归并排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序（MERGE-SORT）基础&quot;&gt;&lt;a href=&quot;#归并排序（MERGE-SORT）基础&quot; class=&quot;headerlink&quot; title=&quot;归并排序（MERGE-SORT）基础&quot;&gt;&lt;/a&gt;归并排序（MERGE-SORT）基础&lt;/h1&gt;&lt;p&gt;定义：归并排
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS常用设计模式总结</title>
    <link href="https://fanerge.github.io/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/11/12/设计模式总结/</id>
    <published>2017-11-12T11:48:47.000Z</published>
    <updated>2017-11-12T13:22:13.841Z</updated>
    
    <content type="html"><![CDATA[<p>花了一个多月，终于把js中常用的设计模式整理了一遍。其中主要参阅了曾探的《JavaScript设计模式与开发实践》，讲真这本书写的真的很不错。<br>还参考了wiki、博客、掘金、CSDN等的文章，在此表示感谢，如有理解不当，还望指正。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><h1 id="工厂模式（Factory）"><a href="#工厂模式（Factory）" class="headerlink" title="工厂模式（Factory）"></a>工厂模式（Factory）</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）、<br>    自行车售卖（山地、公路）、<br>    饮料机（咖啡、牛奶、水）、<br>    RPG中职业（战士、法师、射手）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：：模态框、<br>    登录控件、<br>    注销控件<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）、<br>    计算年终奖（工资、效绩）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例： 图片预加载、图片懒加载、<br>    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、<br>    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、<br>    缓存代理（缓存请求结果、计算结果）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：手机购买页面（颜色、数量、内存、价格）、<br>    MVC模式（控制层便是位于表现层与模型层之间的中介者）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="装饰者模式（Decorator）"><a href="#装饰者模式（Decorator）" class="headerlink" title="装饰者模式（Decorator）"></a>装饰者模式（Decorator）</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。<br>举例：雷霆战机（吃道具的例子）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="发布订阅模式（Observer）"><a href="#发布订阅模式（Observer）" class="headerlink" title="发布订阅模式（Observer）"></a>发布订阅模式（Observer）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。<br>举例：模块通信、<br>    售楼中心<br><a href="https://fanerge.github.io/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>举例：常用于接口适配、<br>    兼容多个库（如Prototype库的$函数和YUI的get方法）<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>举例：jquery的$.each()、<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>举例：用桥接模式联结多个类、<br>    事件监控<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>举例：兼容浏览器事件绑定、<br>    兼容浏览器阻止冒泡、<br>    默认事件<br><a href="https://fanerge.github.io/2017/10/22/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br>举例：<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>举例：泡饮品（茶 和 coffee）<br>    公司面试（百度面试 和 阿里面试）<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>举例：文件扫描、<br>    dom节点操作<br><a href="https://fanerge.github.io/2017/11/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。<br>举例：分页控件、<br>    撤销组件<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。<br>举例：交押金预定手机、<br>    挤公交投币<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成。<br>举例：文件下载（开始、暂停、完成、失败等）、<br>    红绿灯<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。<br>举例：内衣厂展示许多商品展示、<br>    地图应用（对象池）<br><a href="https://fanerge.github.io/2017/11/07/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了一个多月，终于把js中常用的设计模式整理了一遍。其中主要参阅了曾探的《JavaScript设计模式与开发实践》，讲真这本书写的真的很不错。&lt;br&gt;还参考了wiki、博客、掘金、CSDN等的文章，在此表示感谢，如有理解不当，还望指正。&lt;/p&gt;
&lt;h1 id=&quot;设计模式&quot;&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-希尔排序</title>
    <link href="https://fanerge.github.io/2017/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/12/排序算法-希尔排序/</id>
    <published>2017-11-12T07:06:49.000Z</published>
    <updated>2017-11-12T09:46:47.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序（Shell-Sort）的基础"><a href="#希尔排序（Shell-Sort）的基础" class="headerlink" title="希尔排序（Shell Sort）的基础"></a>希尔排序（Shell Sort）的基础</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ol><h1 id="实现希尔排序（n为待排序arr-length）"><a href="#实现希尔排序（n为待排序arr-length）" class="headerlink" title="实现希尔排序（n为待排序arr.length）"></a>实现希尔排序（n为待排序arr.length）</h1><h2 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p><p>该方法实质上是一种分组插入方法</p><p>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。<br>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>假设待排序文件有10个记录，其关键字分别是：<br>    592,401,874,141,348,72,911,887,820,283。<br>增量序列的取值依次为：n = 10, 则增量d1 = 10/2 = 5。<br>    5，2，1<br><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" alt="计算过程"><br>    算法时间复杂度：T(n) = O(n*logn^2)<br>    内排序(内存排序就够了)<br>    不稳定(排序后原始顺序无法保证)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function shellSort(array) &#123;</div><div class="line">let arr = array.slice(),</div><div class="line">len = arr.length;</div><div class="line">for(var fraction = Math.floor(len/2); fraction &gt; 0; fraction = Math.floor(fraction/2))&#123;</div><div class="line">// 这里实质上有进行了直接插入排序</div><div class="line">for(var i = fraction; i &lt; len; i++)&#123;</div><div class="line">for(var j = i - fraction; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[fraction + j]; j -= fraction)&#123;</div><div class="line">var temp = arr[j];</div><div class="line">arr[j] = arr[fraction + j];</div><div class="line">arr[fraction + j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr1 = [592,401,874,141,348,72,911,887,820,283];</div><div class="line">let arr2 = shellSort(arr1);</div><div class="line">console.log(arr1); // [592, 401, 874, 141, 348, 72, 911, 887, 820, 283]</div><div class="line">console.log(arr2); // [72, 141, 283, 348, 401, 592, 820, 874, 887, 911]</div></pre></td></tr></table></figure></code></pre><p>PS：首个增量一般取值为 Math.floor(arr.length/2),对每个分组进行直接插入排序。<br>    重复上面过程，知道增量为1时，整个数组恰被分成一组，算法便终止。</p><blockquote><p>   参考文档：<br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="external">基本算法学习(一)之希尔排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">希尔排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;希尔排序（Shell-Sort）的基础&quot;&gt;&lt;a href=&quot;#希尔排序（Shell-Sort）的基础&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell Sort）的基础&quot;&gt;&lt;/a&gt;希尔排序（Shell Sort）的基础&lt;/h1&gt;&lt;p&gt;希尔
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Symbol总结</title>
    <link href="https://fanerge.github.io/2017/11/12/Symbol%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/11/12/Symbol总结/</id>
    <published>2017-11-12T03:31:07.000Z</published>
    <updated>2017-11-12T04:26:01.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Symbol-基础"><a href="#Symbol-基础" class="headerlink" title="Symbol 基础"></a>Symbol 基础</h1><h2 id="Symbol-引入的原因"><a href="#Symbol-引入的原因" class="headerlink" title="Symbol 引入的原因"></a>Symbol 引入的原因</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。<br>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>语法：Symbol([description])<br>参数：description – 可选的，字符串。symbol的description可以用于调试，但无法访问到symbol本身。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol();</div><div class="line">let s2 = Symbol();</div><div class="line"></div><div class="line">s1 === s2 // false</div></pre></td></tr></table></figure></code></pre><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 这里作为对象的属性使用，独一无二</div><div class="line">let s1 = Symbol();</div><div class="line">let a = &#123;</div><div class="line">[s1]: &apos;我是Symbol类型的&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(a[s1]);</div></pre></td></tr></table></figure></code></pre><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。<br><span style="color: red;">它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</span><br>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><h1 id="Symbol-for-key-，Symbol-keyFor-key"><a href="#Symbol-for-key-，Symbol-keyFor-key" class="headerlink" title="Symbol.for(key)，Symbol.keyFor(key)"></a>Symbol.for(key)，Symbol.keyFor(key)</h1><h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p>我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&apos;foo&apos;);</div><div class="line">let s2 = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">s1 === s2 // true</div></pre></td></tr></table></figure></p><pre><code>PS：上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。    Symbol.for(key)与Symbol(desc)这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</code></pre><h2 id="Symbol-keyFor-key"><a href="#Symbol-keyFor-key" class="headerlink" title="Symbol.keyFor(key)"></a>Symbol.keyFor(key)</h2><pre><code>Symbol.keyFor方法返回一个（全局）已登记的 Symbol 类型值的key。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s1) // &quot;foo&quot;</div><div class="line"></div><div class="line">let s2 = Symbol(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s2) // undefined</div></pre></td></tr></table></figure>PS：上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。</code></pre><h1 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h1><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p><h2 id="迭代-symbols"><a href="#迭代-symbols" class="headerlink" title="迭代 symbols"></a>迭代 symbols</h2><ol><li>Symbol.iterator<br>  一个返回一个对象默认迭代器的方法。使用 for…of。</li><li>Symbol.asyncIterator（实验性API）<br>  一个返回对象默认的异步迭代器的方法。使用 for await of。</li></ol><h2 id="正则表达式-symbols"><a href="#正则表达式-symbols" class="headerlink" title="正则表达式 symbols"></a>正则表达式 symbols</h2><ol><li>Symbol.match<br>  一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match().</li><li>Symbol.replace<br>  一个替换匹配字符串的子串的方法. 使用 String.prototype.replace().</li><li>Symbol.search<br>  一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search().</li><li>Symbol.split<br>  一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split().</li></ol><h2 id="其他-symbols"><a href="#其他-symbols" class="headerlink" title="其他 symbols"></a>其他 symbols</h2><ol><li>Symbol.hasInstance<br>  一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof.</li><li>Symbol.isConcatSpreadable<br>  一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat().</li><li>Symbol.unscopables<br>  拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</li><li>Symbol.species<br>  一个用于创建派生对象的构造器函数。</li><li>Symbol.toPrimitive<br>  一个将对象转化为基本数据类型的方法。</li><li>Symbol.toStringTag<br>  用于对象的默认描述的字符串值。使用Object.prototype.toString().</li></ol><blockquote><p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">阮一峰-Symbol</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">MDN-Symbol</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Symbol-基础&quot;&gt;&lt;a href=&quot;#Symbol-基础&quot; class=&quot;headerlink&quot; title=&quot;Symbol 基础&quot;&gt;&lt;/a&gt;Symbol 基础&lt;/h1&gt;&lt;h2 id=&quot;Symbol-引入的原因&quot;&gt;&lt;a href=&quot;#Symbol-引入的原因&quot;
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Set和Map的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Set%E5%92%8CMap%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Set和Map的用法/</id>
    <published>2017-11-11T13:33:57.000Z</published>
    <updated>2017-11-11T14:23:33.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set-详解"><a href="#Set-详解" class="headerlink" title="Set 详解"></a>Set 详解</h1><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>语法：new Set([iterable]);<br>参数：如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。<br>返回值：一个新的Set对象。</p><h2 id="来个简单实例"><a href="#来个简单实例" class="headerlink" title="来个简单实例"></a>来个简单实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3]);</div><div class="line">console.log(set) // Set(3) &#123;1, 2, 3&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>Set.prototype<br>表示Set构造器的原型，允许向所有Set对象添加新的属性。</li><li>Set.prototype.constructor<br>返回实例的构造函数。默认情况下是Set。</li><li>Set.prototype.size<br>返回Set对象的值的个数。</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</li><li>Set.prototype.clear()<br>移除Set对象内的所有元素。</li><li>Set.prototype.delete(value)<br>移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</li><li>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</li><li>Set.prototype.keys()<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li><li>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li><li>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</li><li>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</li><li>Set.prototype<a href="">@@iterator</a><br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值</li></ol><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-基础"><a href="#WeakSet-基础" class="headerlink" title="WeakSet 基础"></a>WeakSet 基础</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><ol><li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li><li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<h3 id="WeakSet-具有的方法"><a href="#WeakSet-具有的方法" class="headerlink" title="WeakSet 具有的方法"></a>WeakSet 具有的方法</h3>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const ws = new WeakSet();</div><div class="line">const obj = &#123;&#125;;</div><div class="line"></div><div class="line">ws.add(window);</div><div class="line">ws.add(obj);</div><div class="line"></div><div class="line">ws.has(window); // true</div><div class="line"></div><div class="line">ws.delete(window);</div><div class="line">ws.has(window);    // false</div></pre></td></tr></table></figure></li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-出现的背景"><a href="#Map-出现的背景" class="headerlink" title="Map 出现的背景"></a>Map 出现的背景</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><h2 id="基础特性-1"><a href="#基础特性-1" class="headerlink" title="基础特性"></a>基础特性</h2><p>语法：new Map([iterable])<br>参数：iterable<br>    Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p><h2 id="简单的Map-实例"><a href="#简单的Map-实例" class="headerlink" title="简单的Map 实例"></a>简单的Map 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line"></div><div class="line">map.set(-0, 123);</div><div class="line">map.get(+0) // 123</div><div class="line"></div><div class="line">map.set(true, 1);</div><div class="line">map.set(&apos;true&apos;, 2);</div><div class="line">map.get(true) // 1</div><div class="line"></div><div class="line">map.set(undefined, 3);</div><div class="line">map.set(null, 4);</div><div class="line">map.get(undefined) // 3</div><div class="line"></div><div class="line">map.set(NaN, 123);</div><div class="line">map.get(NaN) // 123</div></pre></td></tr></table></figure></code></pre><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ol><li>Map.prototype<br>表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。</li><li>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</li><li>Map.prototype.size<br>返回Map对象的键/值对的数量。</li></ol><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol><li>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</li><li>Map.prototype.delete(key)<br>移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。</li><li>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</li><li>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</li><li>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</li><li>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</li><li>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</li><li>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li><li>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</li><li>Map.prototype<a href="">@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li></ol><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的基础"><a href="#WeakMap-的基础" class="headerlink" title="WeakMap 的基础"></a>WeakMap 的基础</h3><pre><code>WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有两点：</code></pre><ol><li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li></ol><h3 id="WeakMap-的方法"><a href="#WeakMap-的方法" class="headerlink" title="WeakMap 的方法"></a>WeakMap 的方法</h3><ol><li>get()</li><li>set()</li><li>has()</li><li>delete()</li></ol><h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>WeakMap 应用的典型场合就是 DOM 节点作为键名。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let myElement = document.getElementById(&apos;logo&apos;);</div><div class="line">let myWeakmap = new WeakMap();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">  let logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure></p><p>PS：上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">MDN-Set</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">MDN-Map</a><br>    <a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="external">阮一峰-Set和Map</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Set-详解&quot;&gt;&lt;a href=&quot;#Set-详解&quot; class=&quot;headerlink&quot; title=&quot;Set 详解&quot;&gt;&lt;/a&gt;Set 详解&lt;/h1&gt;&lt;h2 id=&quot;基础特性&quot;&gt;&lt;a href=&quot;#基础特性&quot; class=&quot;headerlink&quot; title=&quot;基
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Proxy和Reflect的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Proxy%E5%92%8CReflect%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Proxy和Reflect的用法/</id>
    <published>2017-11-11T10:51:05.000Z</published>
    <updated>2017-11-11T13:20:28.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h1><h2 id="Proxy-定义"><a href="#Proxy-定义" class="headerlink" title="Proxy 定义"></a>Proxy 定义</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><h2 id="Proxy-语法"><a href="#Proxy-语法" class="headerlink" title="Proxy 语法"></a>Proxy 语法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 目标对象，需要被拦截 或 处理的对象，数组，函数甚至是其他的代理器</div><div class="line">let target = &#123;&#125;;</div><div class="line">// 拦截器对象</div><div class="line">let handler = &#123;</div><div class="line">get(target, name)&#123;</div><div class="line">// 这里如果 target 没有name属性的话，就设定一个默认值</div><div class="line">return name in target ? target[name] : 27;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">console.log(target.name); // undefined</div><div class="line">console.log(proxy.name); // 27</div></pre></td></tr></table></figure></code></pre><p>PS：Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p><h2 id="Proxy-支持的拦截操作一览，一共13种"><a href="#Proxy-支持的拦截操作一览，一共13种" class="headerlink" title="Proxy 支持的拦截操作一览，一共13种"></a>Proxy 支持的拦截操作一览，一共13种</h2><ol><li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li><li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li><li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li><li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li><li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li><li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li><li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ol><h2 id="Proxy-revocable-可撤销的代理"><a href="#Proxy-revocable-可撤销的代理" class="headerlink" title="Proxy.revocable() 可撤销的代理"></a>Proxy.revocable() 可撤销的代理</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let target = &#123;&#125;;</div><div class="line">let handler = &#123;&#125;;</div><div class="line"></div><div class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</div><div class="line"></div><div class="line">proxy.foo = 123;</div><div class="line">console.log(proxy.foo);</div><div class="line"></div><div class="line">revoke(); // 取消Proxy实例</div><div class="line">console.log(proxy.foo); // TypeError: Revoked</div></pre></td></tr></table></figure></p><p>PS：Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。<br>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="this-的问题"><a href="#this-的问题" class="headerlink" title="this 的问题"></a>this 的问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const target = &#123;</div><div class="line">  m: function () &#123;</div><div class="line">console.log(this === proxy);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">const handler = &#123;&#125;;</div><div class="line"></div><div class="line">const proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">target.m() // false</div><div class="line">proxy.m()  // true</div></pre></td></tr></table></figure></p><h2 id="Proxy-的应用"><a href="#Proxy-的应用" class="headerlink" title="Proxy 的应用"></a>Proxy 的应用</h2><h3 id="扩展数组的属性和方法"><a href="#扩展数组的属性和方法" class="headerlink" title="扩展数组的属性和方法"></a>扩展数组的属性和方法</h3><p>需求：对于数组对象，有时候我们只想要得到数组中对象的某个键值内容。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var AddSomeFunctionHandler=&#123;</div><div class="line">get:function(obj,prop)&#123;</div><div class="line"></div><div class="line">if(prop in obj)&#123;</div><div class="line">return obj[prop]   // 按数组默认方式访问元素</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(prop === &apos;name&apos;)&#123;</div><div class="line">return obj.map(o=&gt;o.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var PersonArray=[&#123;</div><div class="line">name:&quot;Alice&quot;,age:23</div><div class="line">&#125;,&#123;</div><div class="line">name:&quot;Bob&quot;,age:45</div><div class="line">&#125;,&#123;</div><div class="line">name:&quot;Mike&quot;,age:27</div><div class="line">&#125;]</div><div class="line"></div><div class="line">var p= new Proxy(PersonArray,AddSomeFunctionHandler)</div><div class="line">console.log(p.name) // [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</div></pre></td></tr></table></figure></p><h1 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h1><h2 id="Reflect-定义"><a href="#Reflect-定义" class="headerlink" title="Reflect 定义"></a>Reflect 定义</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。<br>Reflect对象的设计目的有这样几个：</p><ol><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li></ol><h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><p>Reflect对象一共有13个静态方法。</p><ol><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)<br>PS：上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</li></ol><h2 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h2><p>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  get baz() &#123;</div><div class="line">return this.foo + this.bar;</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">Reflect.get(myObject, &apos;foo&apos;) // 1</div><div class="line">Reflect.get(myObject, &apos;bar&apos;) // 2</div><div class="line">Reflect.get(myObject, &apos;baz&apos;) // 3</div></pre></td></tr></table></figure></p><h2 id="实例–使用-Proxy-实现观察者模式"><a href="#实例–使用-Proxy-实现观察者模式" class="headerlink" title="实例–使用 Proxy 实现观察者模式"></a>实例–使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。<br>如果你还不懂<a href="">观察者模式</a><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//添加观察者</div><div class="line">const queuedObservers = new Set();</div><div class="line">const observe = fn =&gt; queuedObservers.add(fn);</div><div class="line"></div><div class="line">//proxy 的set 方法</div><div class="line">function set(target, key, value, receiver) &#123;</div><div class="line">const result = Reflect.set(target, key, value, receiver);</div><div class="line">queuedObservers.forEach(observer =&gt; observer());</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line">//创建proxy代理</div><div class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</div><div class="line">//被观察的 对象</div><div class="line">const person = observable(&#123;</div><div class="line">name: &apos;张三&apos;,</div><div class="line">age: 20</div><div class="line">&#125;);</div><div class="line"></div><div class="line">observe(print);</div><div class="line">console.log(person.name); // 张三</div><div class="line">person.name = &apos;李四&apos;;</div><div class="line">console.log(person.name); // 李四</div></pre></td></tr></table></figure></p><blockquote><p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">阮一峰-Reflect</a><br>    <a href="https://www.cnblogs.com/WhiteHorseIsNotHorse/p/7016010.html" target="_blank" rel="external">用es6 （proxy 和 reflect）轻松实现 观察者模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Proxy-详解&quot;&gt;&lt;a href=&quot;#Proxy-详解&quot; class=&quot;headerlink&quot; title=&quot;Proxy 详解&quot;&gt;&lt;/a&gt;Proxy 详解&lt;/h1&gt;&lt;h2 id=&quot;Proxy-定义&quot;&gt;&lt;a href=&quot;#Proxy-定义&quot; class=&quot;head
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Generator%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Generator函数的用法/</id>
    <published>2017-11-11T07:48:46.000Z</published>
    <updated>2017-11-11T09:57:26.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h1><p>从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p><h1 id="Generator函数的简单示例"><a href="#Generator函数的简单示例" class="headerlink" title="Generator函数的简单示例"></a>Generator函数的简单示例</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* g() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var demo = g();</div></pre></td></tr></table></figure></code></pre><p>PS：上面代码定义了一个 Generator 函数g，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br><span style="color: red">返回的是，遍历器对象（Iterator Object）。例如这里，{ value: ‘hello’, done: false }</span></p><h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h1><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。<br>    （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。<br>    （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。<br>    （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。<br>    （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p><h1 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h1><pre><code>可以遍历 数组 和 实现了 Symbol.iterator 方法的对象。</code></pre><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function *foo() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">  yield 4;</div><div class="line">  yield 5;</div><div class="line">  return 6;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let v of foo()) &#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">// 1 2 3 4 5</div></pre></td></tr></table></figure></p><h1 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a>Generator.prototype.next()</h1><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123; </div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen(); // &quot;Generator &#123; &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 1, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 2, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 3, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure></p><h1 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h1><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。    </p><h1 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h1><p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line"></div><div class="line">g.next()        // &#123; value: 1, done: false &#125;</div><div class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">g.next()        // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure></p><p>PS：遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。<br>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p><h1 id="比较一下多个异步操作的编码"><a href="#比较一下多个异步操作的编码" class="headerlink" title="比较一下多个异步操作的编码"></a>比较一下多个异步操作的编码</h1><p>step1完成才能做step2，step2完成才能做step3，step3完成才能做step4</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数("></a>回调函数(</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">step1(function (value1) &#123;</div><div class="line">  step2(value1, function(value2) &#123;</div><div class="line">step3(value2, function(value3) &#123;</div><div class="line">  step4(value3, function(value4) &#123;</div><div class="line">// Do something with value4</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><p>PS：层数多了就形成了回调地狱。</p><h2 id="Promise-组织代码"><a href="#Promise-组织代码" class="headerlink" title="Promise 组织代码"></a>Promise 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Q.fcall(step1)</div><div class="line">  .then(step2)</div><div class="line">  .then(step3)</div><div class="line">  .then(step4)</div><div class="line">  .then(function (value4) &#123;</div><div class="line">// Do something with value4</div><div class="line">  &#125;, function (error) &#123;</div><div class="line">// Handle any error from step1 through step4</div><div class="line">  &#125;)</div><div class="line">  .done();</div></pre></td></tr></table></figure></code></pre><p>PS：是不是代码稍微要清晰一些了。</p><h2 id="Generator-组织代码"><a href="#Generator-组织代码" class="headerlink" title="Generator 组织代码"></a>Generator 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function* longRunningTask() &#123;</div><div class="line">  try &#123;</div><div class="line">var value1 = yield step1();</div><div class="line">var value2 = yield step2(value1);</div><div class="line">var value3 = yield step3(value2);</div><div class="line">var value4 = yield step4(value3);</div><div class="line">// Do something with value4</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">// Handle any error from step1 through step4</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function scheduler(task) &#123;</div><div class="line">  setTimeout(function() &#123;</div><div class="line">var taskObj = task.next(task.value);</div><div class="line">// 如果Generator函数未结束，就继续调用</div><div class="line">if (!taskObj.done) &#123;</div><div class="line">  task.value = taskObj.value</div><div class="line">  scheduler(task);</div><div class="line">&#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">scheduler(longRunningTask());</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator 函数的语法</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">MDN-Generator</a><br>    <a href="http://blog.csdn.net/jiangbo_phd/article/details/51820642" target="_blank" rel="external">ES6 Generator 函数的使用</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Generator函数的定义&quot;&gt;&lt;a href=&quot;#Generator函数的定义&quot; class=&quot;headerlink&quot; title=&quot;Generator函数的定义&quot;&gt;&lt;/a&gt;Generator函数的定义&lt;/h1&gt;&lt;p&gt;从语法上，首先可以把它理解成，Generat
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Promise的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Promise%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Promise的用法/</id>
    <published>2017-11-11T02:31:27.000Z</published>
    <updated>2017-11-11T07:40:52.349Z</updated>
    
    <content type="html"><![CDATA[<p>ES6出来了很久，Promise也一直在用，现在总结一下具体用法。</p><h1 id="Promise-定义"><a href="#Promise-定义" class="headerlink" title="Promise 定义"></a>Promise 定义</h1><p>Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="MDN"><br>    这里使用MDN的图片</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="创造了一个-Promise-实例"><a href="#创造了一个-Promise-实例" class="headerlink" title="创造了一个 Promise 实例"></a>创造了一个 Promise 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="对-Promise-实例成功-或-失败-做相应的处理"><a href="#对-Promise-实例成功-或-失败-做相应的处理" class="headerlink" title="对 Promise 实例成功 或 失败 做相应的处理"></a>对 Promise 实例成功 或 失败 做相应的处理</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(value) &#123;</div><div class="line">  // success</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><h2 id="分为三种调用形式（注意最后面需要带着错误处理函数）"><a href="#分为三种调用形式（注意最后面需要带着错误处理函数）" class="headerlink" title="分为三种调用形式（注意最后面需要带着错误处理函数）"></a>分为三种调用形式（注意最后面需要带着错误处理函数）</h2><ol><li>promise.then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li><li>promise.then((resolve) =&gt; { // 成功的处理函数 }).then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li><li>promise.then(null, (reject) =&gt; { // 错误的处理函数 })</li></ol><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个<span style="color: red">新的</span>Promise 对象，从而达到链式调用。</p><h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(resolve) &#123;</div><div class="line">  // 成功的处理函数</div><div class="line">&#125;).catch(function(error) &#123;</div><div class="line">  console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p><p>PS：Promise.all方法接受一个数组或具有Iterator 接口的对象作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>（1）只有p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure></p><p>PS：Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</div></pre></td></tr></table></figure></p><p>PS：将jQuery生成的deferred对象，转为一个新的Promise对象。</p><h2 id="根据不同参数，返回结果情况"><a href="#根据不同参数，返回结果情况" class="headerlink" title="根据不同参数，返回结果情况"></a>根据不同参数，返回结果情况</h2><ol><li>参数是一个Promise实例<br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li><li>参数是一个thenable对象（thenable对象指的是具有then方法的对象）<br>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</li><li>参数不是具有then方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</li><li>不带有任何参数<br>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。</li></ol><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br>下面两种形式一样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const p = Promise.reject(&apos;出错了&apos;);</div><div class="line">// 等同于</div><div class="line">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</div><div class="line"></div><div class="line">p.then(null, function (s) &#123;</div><div class="line">  console.log(s)</div><div class="line">&#125;);</div><div class="line">// 出错了</div></pre></td></tr></table></figure></p><h1 id="自己部署有用的方法"><a href="#自己部署有用的方法" class="headerlink" title="自己部署有用的方法"></a>自己部署有用的方法</h1><h2 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p><h3 id="部署-done-方法"><a href="#部署-done-方法" class="headerlink" title="部署 done 方法"></a>部署 done 方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.done = function (onFulfilled, onRejected) &#123;</div><div class="line">  this.then(onFulfilled, onRejected)</div><div class="line">.catch(function (reason) &#123;</div><div class="line">  // 抛出一个全局错误</div><div class="line">  setTimeout(() =&gt; &#123; throw reason &#125;, 0);</div><div class="line">&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">.then(f1)</div><div class="line">.catch(r1)</div><div class="line">.then(f2)</div><div class="line">.done();</div></pre></td></tr></table></figure></code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h2><h3 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p><h3 id="部署finally方法"><a href="#部署finally方法" class="headerlink" title="部署finally方法"></a>部署finally方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.finally = function (callback) &#123;</div><div class="line">  let P = this.constructor;</div><div class="line">  return this.then(</div><div class="line">value  =&gt; P.resolve(callback()).then(() =&gt; value),</div><div class="line">reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.listen(0)</div><div class="line">.then(function () &#123;</div><div class="line">// run test</div><div class="line">&#125;)</div><div class="line">.finally(server.stop);</div></pre></td></tr></table></figure></p><h1 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h1><p><span style="color: red">目前还为提案，Promise 库Bluebird、Q和when，提供了这个方法。</span></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。    </p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.try(f) // 这里不需要管 f 是同步还是异步函数。</div><div class="line">  .then(...)</div><div class="line">  .catch(...)</div></pre></td></tr></table></figure></code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const preloadImage = function (path) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">const image = new Image();</div><div class="line">image.onload  = resolve;</div><div class="line">image.onerror = reject;</div><div class="line">image.src = path;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">preloadImage</div><div class="line">.then((reslove) =&gt; &#123; console.log(&apos;图片加载成功了哦！&apos;) &#125;)</div><div class="line">.catch((reject) =&gt; &#123; console.log(&apos;图片加载失败了哦！&apos;) &#125;)</div></pre></td></tr></table></figure></p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN–Promiese</a><br>    <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰–Promise</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6出来了很久，Promise也一直在用，现在总结一下具体用法。&lt;/p&gt;
&lt;h1 id=&quot;Promise-定义&quot;&gt;&lt;a href=&quot;#Promise-定义&quot; class=&quot;headerlink&quot; title=&quot;Promise 定义&quot;&gt;&lt;/a&gt;Promise 定义&lt;/h1&gt;
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-插入排序</title>
    <link href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/10/排序算法-插入排序/</id>
    <published>2017-11-10T13:12:03.000Z</published>
    <updated>2017-11-10T14:02:40.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序算法定义（Insertion-Sort）"><a href="#插入排序算法定义（Insertion-Sort）" class="headerlink" title="插入排序算法定义（Insertion Sort）"></a>插入排序算法定义（Insertion Sort）</h1><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，<br>    这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序<br>    数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。<br>    是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，<br>    但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。<br>    在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><pre><code>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</code></pre><h1 id="插入排序的分类"><a href="#插入排序的分类" class="headerlink" title="插入排序的分类"></a>插入排序的分类</h1><p>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。<br>    属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个<br>    已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。<br>        例如,已知待排序的一组记录是：60,71,49,11,24,3,66<br>        假设在排序过程中，前3个记录已按关键码值递增的次序重新排列，构成一个有序序列：49,60,71<br>        将待排序记录中的第4个记录（即11）插入上述有序序列，以得到一个新的含4个记录的有序序列。<br>        首先，应找到11的插入位置，再进行插入。可以讲11放入数组的第一个单元r[0]中，这个单元称为监视哨，<br>        然后从71起从右到左查找，11小于71，将71右移一个位置，11小于60，又将60右移一个位置，11小于49，<br>        又再将49右移一个位置，这时再将11与r[0]的值比较，11≥r[0]，它的插入位置就是r[1]。<br>        假设11大于第一个值r[1]。它的插入位置应该在r[1]和r[2]之间，由于60已经右移了，留出来的位置正好留给11.<br>        后面的记录依照同样的方法逐个插入到该有序序列中。若记录数n,续进行n-1趟排序，才能完成。<br>        直接插入排序的算法思路：<br>        （1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；<br>        （2） 设置开始查找的位置j；<br>        （3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；<br>        （4） 将r[0]插入r[j+1]的位置上。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function insertSort(array)&#123;  </div><div class="line">let i,</div><div class="line">j, </div><div class="line">temp,</div><div class="line">arr = array.slice(),  // 这里对原数组拷贝</div><div class="line">n = arr.length; </div><div class="line"></div><div class="line">for(i = 1;i &lt; n;i++)&#123;   </div><div class="line">j = i-1; </div><div class="line">temp = arr[i]; // 第i项为待插入的项  </div><div class="line"></div><div class="line">while(j &lt; i &amp;&amp; arr[j] &gt; temp)&#123;   </div><div class="line">arr[j+1] = arr[j];   </div><div class="line">j--;  </div><div class="line">&#125;   </div><div class="line"></div><div class="line">arr[j+1] = temp;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;   </div><div class="line">&#125;   </div><div class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </div><div class="line">let demo = insertSort(arrayA);</div><div class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure></code></pre><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" alt="直接插入排序"><br>    最佳情况：输入数组按升序排列。T(n) = O(n)<br>    最坏情况：输入数组按降序排列。T(n) = O(n2)<br>    平均情况：T(n) = O(n2)</p><h2 id="折半插入排序（二分插入排序）"><a href="#折半插入排序（二分插入排序）" class="headerlink" title="折半插入排序（二分插入排序）"></a>折半插入排序（二分插入排序）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。<br>    在处理A[i]时，A[0]……A[i-1]已经按关键码值排好序。所谓折半比较，就是在插入A[i]时，<br>    取A[i-1/2]的关键码值与A[i]的关键码值进行比较，如果A[i]的关键码值小于A[i-1/2]的关键码值，<br>    则说明A[i]只能插入A[0]到A[i-1/2]之间，故可以在A[0]到A[i-1/2-1]之间继续使用折半比较；<br>    否则只能插入A[i-1/2]到A[i-1]之间，故可以在A[i-1/2+1]到A[i-1]之间继续使用折半比较。<br>    如此担负，直到最后能够确定插入的位置为止。一般在A[k]和A[r]之间采用折半，其中间结点为A[k+r/2]，<br>    经过一次比较即可排除一半记录，把可能插入的区间减小了一半，故称为折半。<br>    执行折半插入排序的前提是文件记录必须按顺序存储。</p><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><p>（1）计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，<br>        说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置 到中间值的位置，这样很简单的完成了折半；<br>    （2）在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，<br>        范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；<br>    （3）确定位置之后，将整个序列后移，并将元素插入到相应位置。</p><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function binaryInsertSort(array)&#123;</div><div class="line">let arr = array.slice();</div><div class="line">for (let i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">let key = arr[i], </div><div class="line">left = 0, </div><div class="line">right = i - 1;</div><div class="line"></div><div class="line">while (left &lt;= right) &#123;</div><div class="line">let middle = parseInt((left + right) / 2);</div><div class="line"></div><div class="line">if (key &lt; arr[middle]) &#123;</div><div class="line">right = middle - 1;</div><div class="line">&#125; else &#123;</div><div class="line">left = middle + 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">for (var j = i - 1; j &gt;= left; j--) &#123;</div><div class="line">  arr[j + 1] = arr[j];</div><div class="line">&#125;</div><div class="line"></div><div class="line">arr[left] = key;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </div><div class="line">let demo = binaryInsertSort(arrayA);</div><div class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure></code></pre><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="二分插入排序"><br>    最佳情况：T(n) = O(nlogn)<br>    最差情况：T(n) = O(n2)<br>    平均情况：T(n) = O(n2)</p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/90zeng/p/insert_sort.html" target="_blank" rel="external">数据结构复习：直接插入排序与二分插入排序的C++实现</a><br>    <a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="external">插入排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插入排序算法定义（Insertion-Sort）&quot;&gt;&lt;a href=&quot;#插入排序算法定义（Insertion-Sort）&quot; class=&quot;headerlink&quot; title=&quot;插入排序算法定义（Insertion Sort）&quot;&gt;&lt;/a&gt;插入排序算法定义（Inser
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-选择排序</title>
    <link href="https://fanerge.github.io/2017/11/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/09/排序算法-选择排序/</id>
    <published>2017-11-09T12:18:16.000Z</published>
    <updated>2017-11-09T13:07:31.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序算法定义（Selection-Sort）"><a href="#选择排序算法定义（Selection-Sort）" class="headerlink" title="选择排序算法定义（Selection Sort）"></a>选择排序算法定义（Selection Sort）</h1><pre><code>选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</code></pre><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。</code></pre><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><pre><code>每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</code></pre><h2 id="简单选择排序的基本思想"><a href="#简单选择排序的基本思想" class="headerlink" title="简单选择排序的基本思想"></a>简单选择排序的基本思想</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。</code></pre><h2 id="简单选择排序的存储状态"><a href="#简单选择排序的存储状态" class="headerlink" title="简单选择排序的存储状态"></a>简单选择排序的存储状态</h2><pre><code>初始序列：{49 27 65 97 76 12 38}</code></pre><p>　　第1趟：12与49交换：12{27 65 97 76 49 38}<br>　　第2趟：27不动　：12 27{65 97 76 49 38}<br>　　第3趟：65与38交换：12 27 38{97 76 49 65}<br>　　第4趟：97与49交换：12 27 38 49{76 97 65}<br>　　第5趟：76与65交换：12 27 38 49 65{97 76}<br>　　第6趟：97与76交换：12 27 38 49 65 76 97 完成</p><pre><code>PS：其中大括号内为无序区，大括号外为有序序列</code></pre><h1 id="简单选择排序的算法分析"><a href="#简单选择排序的算法分析" class="headerlink" title="简单选择排序的算法分析"></a>简单选择排序的算法分析</h1><pre><code>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，需要移动记录的次数最多为3（n-1）（此情况中待排序记录并非完全逆序，给完全逆序记录排序的移动次数应为(n/2)*3，其中n/2向下取整）。简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是∑ =(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n2)。</code></pre><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function selectionSort(array) &#123;</div><div class="line">let arr = array.slice(), // 深拷贝一份原数组</div><div class="line">len = arr.length,</div><div class="line">minIndex,</div><div class="line">temp;</div><div class="line">for (var i = 0; i &lt; len - 1; i++) &#123;</div><div class="line">minIndex = i;</div><div class="line">for (var j = i + 1; j &lt; len; j++) &#123;</div><div class="line">if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</div><div class="line">minIndex = j;                 //将最小数的索引保存</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">temp = arr[i];</div><div class="line">arr[i] = arr[minIndex];</div><div class="line">arr[minIndex] = temp;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [5, 4, 3, 2, 1];</div><div class="line">var demo = selectionSort(arr);</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>PS：建议使用不可变对象的思想进行编程。</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" alt="选择排序动图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">选择排序（Selection Sort）</a><br>    <a href="https://baike.baidu.com/item/选择排序法/2304587" target="_blank" rel="external">选择排序法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序算法定义（Selection-Sort）&quot;&gt;&lt;a href=&quot;#选择排序算法定义（Selection-Sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序算法定义（Selection Sort）&quot;&gt;&lt;/a&gt;选择排序算法定义（Selec
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法--冒泡排序</title>
    <link href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/08/排序算法-冒泡排序/</id>
    <published>2017-11-08T13:31:41.000Z</published>
    <updated>2017-11-09T13:05:40.909Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">或许你需要对算法的基本概念进行了解，请访问该链接。</a></p><h1 id="冒泡排序算法定义（Bubble-Sort）"><a href="#冒泡排序算法定义（Bubble-Sort）" class="headerlink" title="冒泡排序算法定义（Bubble Sort）"></a>冒泡排序算法定义（Bubble Sort）</h1><pre><code>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</code></pre><h1 id="冒泡排序算法原理"><a href="#冒泡排序算法原理" class="headerlink" title="冒泡排序算法原理"></a>冒泡排序算法原理</h1><pre><code>冒泡排序算法的运作如下：（从后往前）</code></pre><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h1 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><pre><code>若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。    C=n-1；M=0；</code></pre><p><span>所以，冒泡排序最好的时间复杂度为 O(n)。</span><br>    若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，<br>    且每次比较都必须移动记录三次来达到交换记录位置。<br>        C=n<em>(n-1)/2 = O(n^2)；M=3n</em>(n-1)/2 = O(n^2)</p><p><span>所以，冒泡排序最好的时间复杂度为 O(n^2)。</span><br>    综上，因此冒泡排序总的平均时间复杂度为  O(n^2)。        </p><h2 id="冒泡排序算法的稳定性"><a href="#冒泡排序算法的稳定性" class="headerlink" title="冒泡排序算法的稳定性"></a>冒泡排序算法的稳定性</h2><pre><code>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</code></pre><h1 id="冒泡排序算法描述"><a href="#冒泡排序算法描述" class="headerlink" title="冒泡排序算法描述"></a>冒泡排序算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(array) &#123;</div><div class="line">let len = array.length, j, arr = array.slice();</div><div class="line">let tempExchangeVal;</div><div class="line">while (len &gt; 0) &#123;</div><div class="line">for (j = 0; j &lt; len - 1; j++) &#123;</div><div class="line">if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">// 交换两个值</div><div class="line">tempExchangeVal = arr[j];</div><div class="line">arr[j] = arr[j + 1];</div><div class="line">arr[j + 1] = tempExchangeVal;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">len--;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">const arr = [5, 4, 3, 2, 1];</div><div class="line">let arrSorted = bubbleSort(arr);</div><div class="line">console.log(arrSorted); // [1, 2, 3, 4, 5]</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1];</div></pre></td></tr></table></figure>PS：这里在方法中新生成了一个数组，有不可变对象的思想。</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" alt="冒泡排序"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/zhouliang/p/6638010.html" target="_blank" rel="external">JS-排序详解-冒泡排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="external">冒泡排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;或许你需要对算法的基本概念进行了
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法基本概念</title>
    <link href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://fanerge.github.io/2017/11/08/排序算法基本概念/</id>
    <published>2017-11-08T12:19:57.000Z</published>
    <updated>2017-11-09T13:05:01.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对于评述算法优劣术语的说明"><a href="#对于评述算法优劣术语的说明" class="headerlink" title="对于评述算法优劣术语的说明"></a>对于评述算法优劣术语的说明</h1><ol><li>稳定：如果a原本在b的前面，若a=b，排序之后a仍然在b前面。</li><li>不稳定：如果a原本在b的前面，若a=b，排序之后a可能会在b的后面。</li><li>内排序：所有排序操作都在内存中完成。</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li>时间复杂度：一个算法执行所消耗的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ol><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="时间复杂度的定义-T-n-O-f-n"><a href="#时间复杂度的定义-T-n-O-f-n" class="headerlink" title="时间复杂度的定义 T(n)=O(f(n))"></a>时间复杂度的定义 T(n)=O(f(n))</h2><pre><code>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。</code></pre><h2 id="时间复杂度的计算步骤"><a href="#时间复杂度的计算步骤" class="headerlink" title="时间复杂度的计算步骤"></a>时间复杂度的计算步骤</h2><ol><li>计算出基本操作的执行次数T(n)<br>  基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。<br>  在做算法分析时，一般默认为考虑最坏的情况。</li><li>计算出T(n)的数量级<br>  求T(n)的数量级，只要将T(n)进行如下一些操作，忽略常量、低次幂和最高次幂的系数。<br>  令f(n)=T(n)的数量级。</li><li>用大O来表示时间复杂度<br>  当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。<br>  记作T(n)=O(f(n))。</li></ol><h2 id="计算一下时间复杂度"><a href="#计算一下时间复杂度" class="headerlink" title="计算一下时间复杂度"></a>计算一下时间复杂度</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)   //循环了，当然是O(n^2)</div><div class="line">       for(j=1;j&lt;=n;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure></code></pre><p>PS：这里的执行次数为 <span style="color: red;">n*n</span> 次 ，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)</div><div class="line">       for(j=1;j&lt;=i;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure></code></pre><p>PS：这里的执行次数为 <span style="color: red;">(1+2+3+…+n)≈(n^2)/2</span>次，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><h2 id="空间复杂度定义-S-n-O-f-n"><a href="#空间复杂度定义-S-n-O-f-n" class="headerlink" title="空间复杂度定义 S(n)=O(f(n))"></a>空间复杂度定义 S(n)=O(f(n))</h2><pre><code>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。</code></pre><h1 id="各种算法的总结"><a href="#各种算法的总结" class="headerlink" title="各种算法的总结"></a>各种算法的总结</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p><pre><code>总结：接着我会使用 js 来做各种排序算法的分析。 </code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="external">js十大排序算法</a><br>    <a href="http://univasity.iteye.com/blog/1164707" target="_blank" rel="external">算法时间复杂度的计算 [整理]</a><br>    <a href="http://blog.csdn.net/firefly_2002/article/details/8008987" target="_blank" rel="external">如何计算时间复杂度</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对于评述算法优劣术语的说明&quot;&gt;&lt;a href=&quot;#对于评述算法优劣术语的说明&quot; class=&quot;headerlink&quot; title=&quot;对于评述算法优劣术语的说明&quot;&gt;&lt;/a&gt;对于评述算法优劣术语的说明&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;稳定：如果a原本在b的前面，若a=b，排
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
