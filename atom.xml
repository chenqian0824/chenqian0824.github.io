<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2018-07-13T14:34:59.734Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web性能优化</title>
    <link href="https://fanerge.github.io/2018/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
    <id>https://fanerge.github.io/2018/Web性能优化.html</id>
    <published>2018-07-13T14:33:31.000Z</published>
    <updated>2018-07-13T14:34:59.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><h2 id="DNS-prefetch"><a href="#DNS-prefetch" class="headerlink" title="DNS prefetch"></a>DNS prefetch</h2><p>DNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。<br><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</code></p><h2 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h2><p>和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。<br><code>&lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt;</code></p><h2 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h2><p>当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用，prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。<br><code>&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;</code><br>PS：可以解决字体文件必须等DOM和CSSOM创建好后才能下载的性能瓶颈。</p><h2 id="Subresource"><a href="#Subresource" class="headerlink" title="Subresource"></a>Subresource</h2><p>可以用来指定资源是最高优先级的。<br><code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code><br>PS：rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。</p><h2 id="Prerender"><a href="#Prerender" class="headerlink" title="Prerender"></a>Prerender</h2><p>prerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。<br>一些适用场景用户搜索后的结果页面、登录成功后的页面、多页文章（预先加载下一页的资源）<br><code>&lt;link rel=&quot;prerender&quot;  href=&quot;/thenextpage.html&quot; /&gt;</code><br>PS：该属性会下载所有的资源、创建DOM、渲染页面、执行JS<a href="https://www.w3.org/TR/page-visibility/" target="_blank" rel="external">这篇文章可以防止页面还没有展示给用户就出发JS的执行</a>等等。</p><h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源。<br><code>&lt;link rel=&quot;preload&quot; href=&quot;image.png&quot;&gt;</code><br><a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/" target="_blank" rel="external">AlloyTeam-一箩筐的预加载技术</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预加载技术&quot;&gt;&lt;a href=&quot;#预加载技术&quot; class=&quot;headerlink&quot; title=&quot;预加载技术&quot;&gt;&lt;/a&gt;预加载技术&lt;/h1&gt;&lt;h2 id=&quot;DNS-prefetch&quot;&gt;&lt;a href=&quot;#DNS-prefetch&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="性能" scheme="https://fanerge.github.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="性能" scheme="https://fanerge.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>聊聊伪元素（::after和::before）、pointer-events属性、touch-action属性</title>
    <link href="https://fanerge.github.io/2018/%E8%81%8A%E8%81%8A%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%88-after%E5%92%8C-before%EF%BC%89%E5%92%8Cpointer-events%E5%B1%9E%E6%80%A7%E5%92%8Ctouch-action%E5%B1%9E%E6%80%A7.html"/>
    <id>https://fanerge.github.io/2018/聊聊伪元素（-after和-before）和pointer-events属性和touch-action属性.html</id>
    <published>2018-07-06T12:00:32.000Z</published>
    <updated>2018-07-06T12:34:59.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪元素（以-after举例）"><a href="#伪元素（以-after举例）" class="headerlink" title="伪元素（以::after举例）"></a>伪元素（以::after举例）</h1><h2 id="属性基础介绍"><a href="#属性基础介绍" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。<br>使用：CSS2.0为<code>element:after{content: &#39;&#39;;...}</code>；CSS3.0为<code>element::after{content: &#39;&#39;;...}</code><br>这些并不是我今天想讨论的，我们应该来看看伪元素的一些其他性质。</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>本文的重点：我们都知道我们不能为伪元素添加事件（目前是这样，不知道以后W3C会不会考虑），但是伪元素是可以触发元素本体上的事件。我认为伪元素的出现使我们在某种程度上可以精简DOM结构（伪元素可以达到补充、完善UI的目的），但是由于会触发元素本体上的事件，可能有些地方使用需要考虑一下了（在DOM简化的微小性能优化和是否适用于该场景中权衡一下）。<br>PS：元素本体：为了文章的好理解，我自己起的名字，意思为某个元素除了虚拟元素（::after等）以外的部分。<br>比如为了为了实现下图UI，用元素的 after伪类 实现登录和注册分割中的‘点.’，但这个 after伪类保留了 span标签 登录事件感觉有点不符合UI语义。<br><img src="http://pau044s3z.bkt.clouddn.com/after%E4%BC%AA%E7%B1%BB%E4%BD%BF%E7%94%A8.png" alt="after伪类的使用"></p><h1 id="CSS之pointer-events属性"><a href="#CSS之pointer-events属性" class="headerlink" title="CSS之pointer-events属性"></a>CSS之pointer-events属性</h1><p>我这里只讨论 pointer-events 的auto、none、inherit、initial、unset（不讨论SVG相关的属性值）。</p><h2 id="属性基础介绍-1"><a href="#属性基础介绍-1" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target，也就是说通过设置该属性可以控制该元素是否为事件的target。<br>对上面提到的属性值做下简单的介绍：<br>auto：  与 pointer-events 属性未指定时的表现效果相同<br>none：  元素永远不会成为鼠标事件的 target（不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍）。<br>inherit：  该关键字使得元素获取其父元素的计算值(computed value )，由于该属性为非继承属性 inherit 在这里指定的行为通常没有多大意义，一般使用使用 initial 或 unset 作为替代。<br>initial：  相关标准都设置了每个元素的的初始值，pointer-events 属性的初始值为 auto 。<br>unset：  关键字 unset 是 关键字 initial 和 inherit的组合（如果有继承父级样式，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值）。</p><h2 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h2><p>还记得我们刚刚讲到 pointer-events 的属性值为 none 时提到“不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍”，这里开始做说明。</p><blockquote><p> 使用pointer-events来阻止元素成为鼠标事件目标不一定意味着元素上的事件侦听器永远不会触发。如果元素后代明确指定了pointer-events属性并允许其成为鼠标事件的目标，那么指向该元素的任何事件在事件传播过程中都将通过父元素，并以适当的方式触发其上的事件侦听器。当然，位于父元素但不在后代元素上的鼠标活动都不会被父元素和后代元素捕获（鼠标活动将会穿过父元素而指向位于其下面的元素）。</p></blockquote><h3 id="该属性提高页面滚动时候的绘制性能是不准确的"><a href="#该属性提高页面滚动时候的绘制性能是不准确的" class="headerlink" title="该属性提高页面滚动时候的绘制性能是不准确的"></a>该属性提高页面滚动时候的绘制性能是不准确的</h3><p>为什么这么说呢？已经有前辈写过相应的文章，以及详细的测试数据<a href="https://www.zhangxinxu.com/wordpress/2014/01/pointer-events-none-avoiding-unnecessary-paints/" target="_blank" rel="external">pointer-events:none提高页面滚动时候的绘制性能？</a></p><h3 id="只能失效鼠标事件，并不能让键盘事件失效"><a href="#只能失效鼠标事件，并不能让键盘事件失效" class="headerlink" title="只能失效鼠标事件，并不能让键盘事件失效"></a>只能失效鼠标事件，并不能让键盘事件失效</h3><p>pointer-events 只能失效鼠标事件，并不能让键盘事件失效，所以用该属性对按钮的禁用需要小心<a href="https://www.zhangxinxu.com/wordpress/2011/12/css3-pointer-events-none-javascript/" target="_blank" rel="external">大家可以看看张鑫旭前辈的文章</a>。</p><h1 id="CSS之touch-action属性"><a href="#CSS之touch-action属性" class="headerlink" title="CSS之touch-action属性"></a>CSS之touch-action属性</h1><h2 id="属性基础介绍-2"><a href="#属性基础介绍-2" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。<br>属性值介绍：<br>auto：  当触控事件发生在元素上时，由浏览器来决定进行哪些操作，比如对viewport进行平滑、缩放等。<br>none：  当触控事件发生在元素上时，不进行任何操作。<br>pan-x：  启用单指水平平移手势。可以与 pan-y 、pan-up、pan-down、pinch-zoom 组合使用。<br>pan-y：  启用单指垂直平移手势。可以与 pan-x 、pan-left 、pan-right、pinch-zoom 组合使用。<br>manipulation：  浏览器只允许进行滚动和持续缩放操作。任何其它被auto值支持的行为不被支持。启用平移和缩小缩放手势，但禁用其他非标准手势，例如双击以进行缩放。 禁用双击可缩放功能可减少浏览器在用户点击屏幕时延迟生成点击事件的需要。<br>pinch-zoom：  启用多手指平移和缩放页面。 这可以与任何平移值组合。</p><h2 id="补充知识-2"><a href="#补充知识-2" class="headerlink" title="补充知识"></a>补充知识</h2><p>移动端300ms延迟，就可以使用 touch-action: manipulation;因为 manipulation 会禁用双击事件（浏览器就不需要等待300ms之后来判断了）。<br>处理移动端点击延迟代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">  touch-action: manipulation;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h3><ol><li><p>在地图或游戏开发中，最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#map &#123;</div><div class="line">  touch-action: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>水平图像轮播开发中，只想通过水平滑动但不想干扰网页的垂直滚动或缩放，可用以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.image-carousel &#123;</div><div class="line">  width: 100%;</div><div class="line">  height: 150px;</div><div class="line">  touch-action: pan-y pinch-zoom;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪元素（以-after举例）&quot;&gt;&lt;a href=&quot;#伪元素（以-after举例）&quot; class=&quot;headerlink&quot; title=&quot;伪元素（以::after举例）&quot;&gt;&lt;/a&gt;伪元素（以::after举例）&lt;/h1&gt;&lt;h2 id=&quot;属性基础介绍&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="CSS" scheme="https://fanerge.github.io/categories/CSS/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTTP知识（前端相关）</title>
    <link href="https://fanerge.github.io/2018/http%E5%BD%92%E7%BA%B3.html"/>
    <id>https://fanerge.github.io/2018/http归纳.html</id>
    <published>2018-07-05T12:21:36.000Z</published>
    <updated>2018-07-12T23:57:14.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全（Safe）"><a href="#安全（Safe）" class="headerlink" title="安全（Safe）"></a>安全（Safe）</h1><p>说一个HTTP方法是安全的，是说这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD和OPTIONS。<br>所有安全的方法都是idempotent（幂等），有些不安全的方法如PUT和DELETE则不是。<br>PS：网络爬虫也是依赖于安全的HTTP方法，安全方法: GET, HEAD, OPTIONS；非安全方法: PUT, DELETE, POST。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe" target="_blank" rel="external">MDN-Safe</a></p><h1 id="幂等（Idempotent）"><a href="#幂等（Idempotent）" class="headerlink" title="幂等（Idempotent）"></a>幂等（Idempotent）</h1><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态（不是返回的状态码而是数据）也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p><h1 id="HTTP方法比较"><a href="#HTTP方法比较" class="headerlink" title="HTTP方法比较"></a>HTTP方法比较</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体（也就是说只存在响应头无响应体）。<br>PS：该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST方法用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改。 </p><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>请求方法 PUT  用于新增资源或者使用请求中的有效负载替换目标资源的表现形式。<br>PS：PUT 与 POST 方法的区别在于，PUT方法是幂等的。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>DELETE 请求方法用于删除指定的资源。</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>OPTIONS 方法 用于获取目的资源所支持的通信选项。在 CORS 作为预检请求。</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>TRACE 方法 实行了向目标资源的沿路径的消息环回(loop-back)测试 ，提供了一种实用的debug机制。</p><h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><p>请求方法 PATCH  用于对资源进行部分修改。<br>PS：在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于  PUT 方法，而与 POST 方法类似，PATCH  方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="Cache-Control（请求头和响应头）"><a href="#Cache-Control（请求头和响应头）" class="headerlink" title="Cache-Control（请求头和响应头）"></a>Cache-Control（请求头和响应头）</h3><p>通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。<br>max-age：指定设置缓存最大的有效时间（单位为s）。<br>s-maxage：覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理CDN)，并且私有缓存中它被忽略。<br>public：表明响应可以被接收的客户端、代理服务器等缓存。<br>private：表明响应只能被客户端缓存，不能作为共享缓存（即代理服务器不能缓存它）。<br>no-cache：在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。<br>no-store：缓存不应存储有关客户端请求或服务器响应的任何内容。</p><h3 id="Expires（响应头）"><a href="#Expires（响应头）" class="headerlink" title="Expires（响应头）"></a>Expires（响应头）</h3><p>响应头包含日期/时间， 即在此时候之后，响应过期。<br>PS：如果在Cache-Control响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="Last-modified（响应头）"><a href="#Last-modified（响应头）" class="headerlink" title="Last-modified（响应头）"></a>Last-modified（响应头）</h3><p>它包含源头服务器认定的资源做出修改的日期及时间。<br>工作原理：浏览器首次请求资源是响应头中包含 Last-modified 字段，当再次请求时将上次 Last-modified 的值赋值给 If-Modified-Since 请求头，服务器根据对应资源的修改时间于 If-Modified-Since 的值进行比较，从而断定该资源是否被修改再响应304或200。</p><h3 id="ETag（响应头）"><a href="#ETag（响应头）" class="headerlink" title="ETag（响应头）"></a>ETag（响应头）</h3><p>工作原理：和 Last-modified（If-Modified-Since）工作原理基本一致，只不过服务器判断资源是否被更改的条件不是文件修改时间而是为资源生产的hash值是否发生变化。<br>PS：可以弥补 max-age 和 Last-modified 只能精确到秒的缺陷。<br><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/" target="_blank" rel="external">alloyteam-浅谈Web缓存</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安全（Safe）&quot;&gt;&lt;a href=&quot;#安全（Safe）&quot; class=&quot;headerlink&quot; title=&quot;安全（Safe）&quot;&gt;&lt;/a&gt;安全（Safe）&lt;/h1&gt;&lt;p&gt;说一个HTTP方法是安全的，是说这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器
      
    
    </summary>
    
      <category term="http" scheme="https://fanerge.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://fanerge.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>懂这些，你将能构建更安全的Web应用</title>
    <link href="https://fanerge.github.io/2018/web%E5%AE%89%E5%85%A8.html"/>
    <id>https://fanerge.github.io/2018/web安全.html</id>
    <published>2018-06-27T14:05:43.000Z</published>
    <updated>2018-07-11T14:55:08.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="同源策略（Same-Origin-Policy）"><a href="#同源策略（Same-Origin-Policy）" class="headerlink" title="同源策略（Same Origin Policy）"></a>同源策略（Same Origin Policy）</h2><p>同源策略限制了一个源（origin）中加载的文档或脚本与其他源（origin）中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。<br>源的定义：如果两个页面的协议、域名、端口（如果有指定）和都相同，则两个页面具有相同的源。</p><h2 id="浏览器沙箱Sandbox-和-多线程架构"><a href="#浏览器沙箱Sandbox-和-多线程架构" class="headerlink" title="浏览器沙箱Sandbox 和 多线程架构"></a>浏览器沙箱Sandbox 和 多线程架构</h2><p>浏览器为我们提供了一个独立的沙箱环境，尽量来保障浏览器的安全，也有部分浏览器采用一个 tab 页面一个线程，这样多线程架构增强了浏览器的安全（即使某个线程崩溃了，也不至于浏览器崩溃）。 </p><h2 id="恶意网址拦截（大多基于黑名单）"><a href="#恶意网址拦截（大多基于黑名单）" class="headerlink" title="恶意网址拦截（大多基于黑名单）"></a>恶意网址拦截（大多基于黑名单）</h2><p>常见的黑名单获取：<a href="https://www.phishtank.com/" target="_blank" rel="external">PhishTank恶意网址黑名单</a>、Google 的SafeBrowsing API、EVSSL证书</p><h2 id="更安全的浏览器进化"><a href="#更安全的浏览器进化" class="headerlink" title="更安全的浏览器进化"></a>更安全的浏览器进化</h2><p>IE8 的 XSS Filter功能<br>Firefox 的 CSP（Content Security Policy）</p><h1 id="XSS（跨站脚本攻击Cross-Site-Script）"><a href="#XSS（跨站脚本攻击Cross-Site-Script）" class="headerlink" title="XSS（跨站脚本攻击Cross Site Script）"></a>XSS（跨站脚本攻击Cross Site Script）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意 Web 用户将代码植入到提供给其它用户使用的页面中。<br>XSS分为三种类型：1.反射型XSS 2.存储型XSS 3.DOM Based XSS（通过修改页面的DOM节点形成的XSS）</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>Cookie劫持（一般Cookie作为登录凭证，通过HttpOnly可以防止）、构造GET与POST请求、XSS钓鱼、识别用户浏览器、CSS HIstory Hack（访问过的连接会使用:visited的样式）、获取用户的真实IP地址（前提如用户安装了Java环境JRE等）、XSS Worm</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>CSP(Content Security Policy)、对特殊字符转义，不要相信任何来自用户的输入（包括请求体、queryString甚至是请求Headers）</p><ol><li>响应头 HttpOnly 有效保护 Cookie</li><li>XSS Filter输入检查 排除、转义特殊字符</li><li>输出检查</li><li>安全的编码函数 HtmlEncode （将特殊字符转换为实体字符）</li><li>只需一种编码吗 浏览器解析 htmlparser 优先于 JavaScript Parser</li></ol><h2 id="对于处理富文本开发："><a href="#对于处理富文本开发：" class="headerlink" title="对于处理富文本开发："></a>对于处理富文本开发：</h2><ol><li>我们应该让事件被严格禁止，不包含iframe、script、base、form等危险标签。</li><li>使用白名单，避免使用黑名单。</li><li>OWASP 开源的 XSS Filter 项目（Antisamy–Java 和 .NET）（HTML Purifier–PHP） </li></ol><p><a href="https://www.zhuyingda.com/blog/article.html?id=2" target="_blank" rel="external">XSS漏洞的原理</a></p><h1 id="CSRF（跨站点脚本Cross-site-request-forgery）"><a href="#CSRF（跨站点脚本Cross-site-request-forgery）" class="headerlink" title="CSRF（跨站点脚本Cross-site request forgery）"></a>CSRF（跨站点脚本Cross-site request forgery）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>是指在黑客已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器 CRUD 来执行读写操作。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>验证码，我们应该使用验证码作为防御 CSRF 的辅助手段，而不应该作为最主要的解决方案（毕竟不可能所有操作都加上验证码，多次验证码不利于用户体验）。<br>Referer Check ，常见应用为防止图片盗链，直白的讲就是后端需要检查请求头中的 Referer 字段，是否为我们期望的”源”。<br>Anti CSRF Token，需要保证使用足够安全的随机数生产算法或真随机数生成器，只有用户和服务器共同持有，才能保证安全。<br>PS：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。<br><a href="https://www.zhuyingda.com/blog/article.html?id=5" target="_blank" rel="external">CSRF漏洞的原理</a></p><h1 id="clickjacking（点击劫持）"><a href="#clickjacking（点击劫持）" class="headerlink" title="clickjacking（点击劫持）"></a>clickjacking（点击劫持）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>点击劫持其实是一种视觉上的欺骗手段，攻击者将一个透明的、不可见的iframe覆盖在一个网页上，通过调整iframe页面位置，诱使用户在页面上进行操作，在不知情的情况下用户的点击恰好是点击在iframe页面的一些功能按钮上，其实还也可使用 img 来代替 iframe，这就是后面要说的 XSIO。<br>HTML5的Drag 和 Drop API会发生数据窃取，分别在 Drag 隐藏一个 iframe ，在 Drop 中 隐藏一个 textarea ，在 drop 事件时就可以获取来自 drag 的数据，从而形成数据劫持，event.dataTransfer.getData()</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>frame busting：禁止iframe的嵌套<a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">JS防止潜入</a><br>X-Frame-Options：防止或限制网页内嵌（http头部X-FRAME-OPTIONS）<br>CSP的frame-ancestors：指定了一个可以包含frame，iframe，object，embed，or applet等元素的有效来源。<br>PS：http头部X-FRAME-OPTIONS为非标准的（但所有浏览器都支持），你可以使用CSP的frame-ancestors（标准属性）。<br>同样还有触屏劫持（TapJacking）实现原理基本类似。<br><a href="https://www.zhuyingda.com/blog/article.html?id=6" target="_blank" rel="external">ClickJacking漏洞的原理</a></p><h1 id="window-name-的妙用"><a href="#window-name-的妙用" class="headerlink" title="window.name 的妙用"></a>window.name 的妙用</h1><p>window.name 属性可设置或返回存放窗口的名称的一个字符串。<br>因为 window 对象是浏览器的窗体，并非 document 对象，因此许多时候 window 对象不受同源策略的限制。<br>可以利用该属性实现跨域、跨页面传递数据<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">可以使用postMessage来进行跨源通信</a>。</p><h1 id="XSIO"><a href="#XSIO" class="headerlink" title="XSIO"></a>XSIO</h1><p>原理：没有限制图片的position属性为absolute，导致可以控制一张图片出现在网页的任意位置。<br><a href="https://blog.csdn.net/inject2006/article/details/3057045" target="_blank" rel="external">百度的XSIO</a></p><h1 id="iframe-的-sandbox-属性"><a href="#iframe-的-sandbox-属性" class="headerlink" title="iframe 的 sandbox 属性"></a>iframe 的 sandbox 属性</h1><p>可以防止以下操作：</p><ol><li>访问父页面的DOM（从技术角度来说，这是因为相对于父页面iframe已经成为不同的源了）</li><li>执行脚本</li><li>通过脚本嵌入自己的表单或操作表单</li><li>对cookie、本地存储Storage、本地数据库IndexDB的读写</li></ol><p>PS：sandbox 属性有 allow-same-origin（允许同源访问）、allow-top-navigation（允许访问顶层窗口）、allow-forms（允许提交表单）、allow-script（允许执行脚本）</p><h1 id="a标签-和-area标签的安全问题"><a href="#a标签-和-area标签的安全问题" class="headerlink" title="a标签 和 area标签的安全问题"></a>a标签 和 area标签的安全问题</h1><p>当a链接有target=”_blank”属性时，必须添加rel=”noreferrer noopener”，不然新产生的页面可以通过window.opener来获取到父窗口的window对象。<br><code>&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; &gt;</code></p><h1 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP (内容安全策略)"></a>CSP (内容安全策略)</h1><p>内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。<br>其实CSP的本质是以白名单的机制对网站加载或执行的资源起作用。</p><h2 id="适用方式"><a href="#适用方式" class="headerlink" title="适用方式"></a>适用方式</h2><ol><li>可以通过配置你的网络服务器返回  Content-Security-Policy  HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部，它是旧版本)。</li><li>在html页面中meta元素中使用，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt;</div></pre></td></tr></table></figure></li></ol><h1 id="隐私与-visited选择器"><a href="#隐私与-visited选择器" class="headerlink" title="隐私与:visited选择器"></a>隐私与:visited选择器</h1><h2 id="为什么说-visited选择器暴露了用户隐私？"><a href="#为什么说-visited选择器暴露了用户隐私？" class="headerlink" title="为什么说:visited选择器暴露了用户隐私？"></a>为什么说:visited选择器暴露了用户隐私？</h2><p>曾经，CSS选择器 :visited 被网站用来查看用户的浏览记录。通过使用 getComputedStyle() 或其他方法扫描用户的浏览记录来获取用户访问了哪些网站。这很容易实现，不仅能够判断用户是否曾经访问过这个页面，还能猜测出大量的用户身份信息。<br>不过现代浏览器已经做了相应的修复和只能给已访问链接设置少量的样式（color、background-color、border-color、outline-color、fill 和 stroke 等）</p><h1 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h1><p>CORS属于HTTP访问控制特性，以下内容大多针对于XMLHttpRequest，有些并不适用于 Fetch 。<br>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。<br>比如，站点 <code>http://domain-a.com</code> 的某 HTML 页面通过 <code>img</code> 的 <code>src</code> 请求 <code>http://domain-b.com/image.jpg</code>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。<br>PS：跨域并非不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）<br>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><h1 id="X-Frame-Options-响应头"><a href="#X-Frame-Options-响应头" class="headerlink" title="X-Frame-Options 响应头"></a>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>frame</code>（已废弃）, <code>iframe</code> 或者 <code>object</code> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p><h2 id="使用-X-Frame-Options"><a href="#使用-X-Frame-Options" class="headerlink" title="使用 X-Frame-Options"></a>使用 X-Frame-Options</h2><p>X-Frame-Options 有三个值:<br>DENY–表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。<br>SAMEORIGIN–表示该页面可以在相同域名页面的 frame 中展示。<br>ALLOW-FROM uri–表示该页面可以在指定来源的 frame 中展示。<br>PS：如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><h1 id="前端反爬虫"><a href="#前端反爬虫" class="headerlink" title="前端反爬虫"></a>前端反爬虫</h1><p>该课题是在腾讯的<a href="http://imweb.io/topic/595b7161d6ca6b4f0ac71f05" target="_blank" rel="external">IMWeb前端博客上看到的，整理于此，非常感谢。</a><br><a href="http://litten.me/2017/07/09/prevent-spiders/" target="_blank" rel="external">反击爬虫，前端工程师的脑洞可以有多大？</a></p><h2 id="FONT-FACE拼凑式"><a href="#FONT-FACE拼凑式" class="headerlink" title="FONT-FACE拼凑式"></a>FONT-FACE拼凑式</h2><p><a href="http://maoyan.com/films/#content" target="_blank" rel="external">猫眼电影</a>-页面使用了font-face定义了字符集，并通过unicode去映射展示。</p><h2 id="BACKGROUND拼凑式"><a href="#BACKGROUND拼凑式" class="headerlink" title="BACKGROUND拼凑式"></a>BACKGROUND拼凑式</h2><p>美团-与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p><h2 id="字符穿插式"><a href="#字符穿插式" class="headerlink" title="字符穿插式"></a>字符穿插式</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&amp;mid=2247484365&amp;idx=4&amp;sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&amp;chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&amp;scene=4" target="_blank" rel="external">微信公众号文章</a>-某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。</p><h2 id="伪元素隐藏式"><a href="#伪元素隐藏式" class="headerlink" title="伪元素隐藏式"></a>伪元素隐藏式</h2><p><a href="https://car.autohome.com.cn/config/series/3170.html" target="_blank" rel="external">汽车之家</a>-把关键的厂商信息，做到了伪元素的content里（如汽车厂家）。</p><h2 id="元素定位覆盖式"><a href="#元素定位覆盖式" class="headerlink" title="元素定位覆盖式"></a>元素定位覆盖式</h2><p><a href="https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&amp;searchArrivalAirport=%E5%8C%97%E4%BA%AC&amp;searchDepartureTime=2018-06-27&amp;searchArrivalTime=2018-06-29&amp;nextNDays=0&amp;startSearch=true&amp;fromCode=CAN&amp;toCode=BJS&amp;from=qunarindex&amp;lowestPrice=null" target="_blank" rel="external">去哪网</a>-对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格。</p><h2 id="IFRAME异步加载式"><a href="#IFRAME异步加载式" class="headerlink" title="IFRAME异步加载式"></a>IFRAME异步加载式</h2><p><a href="http://music.163.com/#/song?id=424477863" target="_blank" rel="external">网易云音乐</a>-页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面。</p><h2 id="字符分割式"><a href="#字符分割式" class="headerlink" title="字符分割式"></a>字符分割式</h2><p><a href="http://www.goubanjia.com/" target="_blank" rel="external">全网代理IP</a>-他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p><h2 id="字符集替换式"><a href="#字符集替换式" class="headerlink" title="字符集替换式"></a>字符集替换式</h2><p><a href="https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&amp;arrCity=%E4%B8%8A%E6%B5%B7&amp;goDate=2018-06-27&amp;from=touch_index_search&amp;child=0&amp;baby=0&amp;cabinType=0" target="_blank" rel="external">去哪儿移动侧</a>-html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果<br>PS：常用的后端反爬有 User-Agent + Referer检测、账号及Cookie验证、验证码、IP限制频次。</p><h1 id="子资源完整性（SRI-Subresource-Integrity）"><a href="#子资源完整性（SRI-Subresource-Integrity）" class="headerlink" title="子资源完整性（SRI,Subresource Integrity）"></a>子资源完整性（SRI,Subresource Integrity）</h1><p>子资源完整性(Subresource Integrity)是允许浏览器检查其获得的资源（例如从 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CDN" target="_blank" rel="external">CDN</a> 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。<br>子资源完整性 (SRI) 是一种安全功能，允许浏览器验证所获取的文件 (比如，从一个 CDN 内容分发网络) 是无意外操作而交付的。它的工作原理是允许你提供一个获取文件必须匹配的加密哈希。</p><h2 id="SRI-如何工作"><a href="#SRI-如何工作" class="headerlink" title="SRI 如何工作"></a>SRI 如何工作</h2><p>使用 内容分发网络 (CDN) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件)，因此可能潜在地攻击所有从该 CDN 获取文件的站点。<br>子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。</p><h2 id="如何使用-SRI"><a href="#如何使用-SRI" class="headerlink" title="如何使用 SRI"></a>如何使用 SRI</h2><p>将使用 base64 编码过后的文件哈希值写入你所引用的 script 或 link 标签的 integrigy 属性值中即可启用子资源完整性功能。<br>PS：integrity 值分成两个部分，第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。<br>integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。</p><h3 id="内容安全策略（CSP）和子资源完整性（SRI）共同使用"><a href="#内容安全策略（CSP）和子资源完整性（SRI）共同使用" class="headerlink" title="内容安全策略（CSP）和子资源完整性（SRI）共同使用"></a>内容安全策略（CSP）和子资源完整性（SRI）共同使用</h3><p>你可以根据内容安全策略来配置你的服务器使得指定类型的文件遵守 SRI。这是通过在 CSP 头部添加 require-sri-for 指令实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这条指令规定了所有 JavaScript 都要有 integrity 属性，且通过验证才能被加载。</div><div class="line">Content-Security-Policy: require-sri-for script;</div><div class="line">// 你也可以指定所有样式表也要通过 SRI 验证：</div><div class="line">Content-Security-Policy: require-sri-for style;</div></pre></td></tr></table></figure></p><p>你也可以对两者都加上验证。</p><h2 id="生成-SRI-哈希的工具"><a href="#生成-SRI-哈希的工具" class="headerlink" title="生成 SRI 哈希的工具"></a>生成 SRI 哈希的工具</h2><h3 id="openssl-在命令行"><a href="#openssl-在命令行" class="headerlink" title="openssl 在命令行"></a>openssl 在命令行</h3><p>你可以用 openssl 在命令行中执行如下命令来生成 SRI 哈希值：<br><code>cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A</code><br><a href="https://www.srihash.org/" target="_blank" rel="external">在线生成 SRI 哈希值的工具</a><br>下面以知乎的一个js文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原js文件地址</div><div class="line">https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js</div><div class="line">// 生成的脚本标签</div><div class="line">&lt;script src=&quot;https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js&quot; integrity=&quot;sha384-B4YDh2AljLezOmNwiezobW8FJbJQfyZxm1SksT7THfKULK6SVxN+dRNSvLxEmXtA&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><h3 id="shasum-在命令行"><a href="#shasum-在命令行" class="headerlink" title="shasum 在命令行"></a>shasum 在命令行</h3><p><code>shasum -b -a 384 FILENAME.js | xxd -r -p | base64</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="external">MDN-SRI</a></p><h1 id="用户密码是泄漏的原因？"><a href="#用户密码是泄漏的原因？" class="headerlink" title="用户密码是泄漏的原因？"></a>用户密码是泄漏的原因？</h1><p> HTTPS 协议旨在保护用户数据在网络上不被窃听（机密性） 和不被篡改（完整性）。处理用户数据的网站应该使用 HTTPS 协议保护他们的用户不受黑客的侵害。如果网站使用 HTTP 协议而不是 HTTPS 协议，窃取用户信息（比如他们的登录凭证）将会轻而易举。这曾经被 <a href="http://codebutler.github.io/firesheep/" target="_blank" rel="external">Firesheep</a> 很好地演示过。<br>这里罗列出密码所牵涉到的安全问题：</p><ol><li>在HTTP之上运行登录表单. 即使表单的action对象是HTTPS链接,用户的登录表单信息也会受到威胁,因为攻击者能够通过用户修改用户接收到的页面(例如,攻击者插入键盘记录脚本来盗取用户输入的密码.他们还能改变表单目的页从而将敏感信息传递到受他们控制的服务器).</li><li>在表单的action链接中使用HTTP链接.在这种情况下,用户输入的任何信息都将以明文方式通过网络传递.这样,从密码离开用户的电脑到密码到达服务器过程中,用户的密码将清楚地展现在任何嗅探用户网络的人眼前.</li><li>在网页iframe中递交登录表单(或是嵌入在HTTP frame中的HTTPS frame).即使最上层页面是HTTPS,但在HTTP iframe中包含密码域和在HTTP页面中包含密码域是没有区别的.攻击者同样能够修改这个页面以及偷取用户信息.</li><li>有时网页需要用户名及密码,但实际上却没有存储这些敏感的信息.例如,一个新闻页面可能存储一个用户想要再次阅读的文章,却没有存储任何关于这位用户的其他信息.这个新闻站点的网页开发者可能没有动力去对于提高他的网站的安全性以及保护他们用户的信息.不幸的是,密码重用也是一个大问题.用户可能在不同的站点使用相同的密码(新闻网页,社交网络,电子邮箱及其银行).因此即使通过用户名及密码登陆你的网页对你来说不是很大的问题,对于重复使用相同用户名及密码来登陆他们银行账户的用户来说却是一个极大的威胁.网络攻击者正变得越来越聪明.他们在一个网站同时盗取用户名及密码然后在另一个可能能给他们带来金钱的网站上使用这些密码.</li></ol><h1 id="弱签名算法"><a href="#弱签名算法" class="headerlink" title="弱签名算法"></a>弱签名算法</h1><p>在签署数字证书时，哈希算法的完整性是决定证书安全性的关键因素。哈希算法的弱点可能导致攻击者在某些情况下能够获得伪造的证书。由于技术的升级和已知的新型攻击，此类攻击的可行性已经大为提升。因此，不推荐使用旧算法，对于旧算法的支持最终也会停止。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>对基于MD5的签名的支持已在2012年初停止。</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>基于SHA-1的签名非常普遍；截至2015年5月，大约45%的数字证书皆使用此算法。但是，SHA-1已经过时因而不再推荐使用。<br>SHA-1的证书将从2017开始不再被主流浏览器厂商视为安全的。</p><h2 id="SHA-2（推荐使用）"><a href="#SHA-2（推荐使用）" class="headerlink" title="SHA-2（推荐使用）"></a>SHA-2（推荐使用）</h2><p>SHA-2是一个哈希算法家族，其中包括SHA-256和SHA-512。截至2015年，SHA-2家族被认为足够安全强大。许多证书颁发机构颁发新的证书使用SHA-256。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用预编译语句、使用存储过程、检查数据类型、使用安全函数（编码特殊字符）、最小权限原则（是否可操作数据库）<br>PS：防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。</p><h1 id="MIMT-中间人攻击Man-in-the-middle-attacks"><a href="#MIMT-中间人攻击Man-in-the-middle-attacks" class="headerlink" title="MIMT(中间人攻击Man-in-the-middle-attacks)"></a>MIMT(中间人攻击Man-in-the-middle-attacks)</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>Client &lt;–&gt; Proxy Server(Middle Man这里可能存在攻击) &lt;–&gt; Web Server真实的服务器<br>Client 发出的请求 和 Web Server返回的数据都经过Proxy Server 转发，这个Proxy Server 就起到了一个Middle Man的作用，如果这个“中间人” 够黑，那么整个代理过程的数据都可以由这个“中间人”控制，“中间人”可以进行截取敏感数据、代码注射、Proxp worm操作。</p><h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p>启用虚拟专用网(VPN)、https(传输报文加密)<br><a href="https://www.zhuyingda.com/blog/article.html?id=7" target="_blank" rel="external">web中间人攻击的威胁</a></p><h1 id="DDOS（分布式拒绝服务Distributed-Denial-of-Service）"><a href="#DDOS（分布式拒绝服务Distributed-Denial-of-Service）" class="headerlink" title="DDOS（分布式拒绝服务Distributed Denial of Service）"></a>DDOS（分布式拒绝服务Distributed Denial of Service）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>最基本的DDOS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。</p><h2 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h2><p>限制请求频率、高防服务器、黑名单、DDoS 清洗、CDN（隐藏真实IP及分流）</p><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="SYN-flood（网络层DDOS）"><a href="#SYN-flood（网络层DDOS）" class="headerlink" title="SYN flood（网络层DDOS）"></a>SYN flood（网络层DDOS）</h3><p><a href="https://www.cnblogs.com/popduke/p/5823801.html" target="_blank" rel="external">什么是SYN Flood攻击?</a><br>对抗措施：SYN Cookie 为每一个IP地址分配一个Cookie，并统计每个IP地址的访问频率。如果短时间内收到大量的来自同一个IP地址的数据包，则认为是受到攻击，之后来自这个IP地址的包将被丢失。</p><h3 id="Challenge-Collapasar（应用层DDOS）"><a href="#Challenge-Collapasar（应用层DDOS）" class="headerlink" title="Challenge Collapasar（应用层DDOS）"></a>Challenge Collapasar（应用层DDOS）</h3><p>原理：对一些消耗资源较大的应用页面不断发起正常的请求（查询数据库、读写硬盘文件等），以达到消耗服务端资源的目的。<br>对抗措施：在应用中针对每个”客户端”做一个请求频率的限制，可以通过IP地址与Cookie定位一个客户端。<br>若IP地址改变（代理服务器）或Cookie清空，应该使用应用代码要做好性能优化（常用数据转移到内存中），在网络架构上做好优化（利用负载均衡、CDN、镜像站点等分流，减轻主站的压力）。<br><a href="https://www.zhihu.com/question/22259175" target="_blank" rel="external">知乎-什么是 DDoS 攻击？</a></p><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><ol><li>上传文件是Web脚本语言</li><li>上传文件是木马、病毒文件，诱骗用户或者管理员下载执行</li><li>上传文件是钓鱼图片或包含了脚本的图片，在某些浏览器会被作为脚本执行</li></ol><h2 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h2><p>文件上传的目录设置为不可执行<br>判断文件类型（使用白名单而不是黑名单）<br>使用随机数改写文件名和文件路径<br>单独设置文件服务器的域名</p><h2 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h2><h3 id="绕过文件上传检查功能"><a href="#绕过文件上传检查功能" class="headerlink" title="绕过文件上传检查功能"></a>绕过文件上传检查功能</h3><p>UI原本允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\0].JPG，其中[\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为0x00字符截断的关系，最终会变成xxx.php。<br>对应的解决方案，可以检查附件头信息（同样也可以使用脚本语言来伪造一个合法头信息，这时应该提供不让脚本执行的容器，Web Server将其当做静态文件来解析，从而避免）。</p><h2 id="Apache文件解析问题"><a href="#Apache文件解析问题" class="headerlink" title="Apache文件解析问题"></a>Apache文件解析问题</h2><p>在Apache1.x、Apache2.x中，对文件名的解析就存在以下特性。<br>Apache对于文件的解析是从后往前解析的，知道遇到一个Apache认识的文件类型为止。<br>Apache的mime.types文件配置了Apache能认识那些文件。</p><h1 id="认证与会话管理"><a href="#认证与会话管理" class="headerlink" title="认证与会话管理"></a>认证与会话管理</h1><h2 id="认证和授权？"><a href="#认证和授权？" class="headerlink" title="认证和授权？"></a>认证和授权？</h2><p>认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。</p><h2 id="常见的认证方式"><a href="#常见的认证方式" class="headerlink" title="常见的认证方式"></a>常见的认证方式</h2><p>密码认证<br>多因素认证（手机号+身份证+护照等等）<br>Session 与认证（对SessionID加密后保存在Cookie中，Cookie随HTTP请求发送，且受浏览器同源策略的保护）</p><h2 id="常见攻击"><a href="#常见攻击" class="headerlink" title="常见攻击"></a>常见攻击</h2><p>Session Fixation 攻击：登录前和登录后，重写 Session ID。</p><h2 id="单点登录（SSO）"><a href="#单点登录（SSO）" class="headerlink" title="单点登录（SSO）"></a>单点登录（SSO）</h2><p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。<br>OpenID：OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。</p><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="垂直权限管理"><a href="#垂直权限管理" class="headerlink" title="垂直权限管理"></a>垂直权限管理</h2><p>主要为基于角色的访问控制（Role-Based Access Control）RBAC<br>一个用户有多个角色，一个角色有一个权限集合，最小粒度为每个权限（权限码）。<br>有以下几个分类</p><h3 id="基于URL的访问控制"><a href="#基于URL的访问控制" class="headerlink" title="基于URL的访问控制"></a>基于URL的访问控制</h3><p>如不同角色能访问不同的页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;sec:http&gt;</div><div class="line">&lt;sec:intercept-url pattern=&quot;/admin&quot; access=&quot;ROLE_ADMIN&quot;/&gt;</div><div class="line">&lt;sec:intercept-url pattern=&quot;/user/*&quot; access=&quot;ROLE_USER&quot;/&gt;</div><div class="line">&lt;/sec:http&gt;</div></pre></td></tr></table></figure></p><h3 id="基于method的访问控制"><a href="#基于method的访问控制" class="headerlink" title="基于method的访问控制"></a>基于method的访问控制</h3><p>如限定角色调用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@PreAuthorize(&quot;hasRole(&apos;ROLE_USER&apos;)&quot;)</div><div class="line">public void create(Contact contact)</div></pre></td></tr></table></figure></p><h3 id="基于表达式的访问控制"><a href="#基于表达式的访问控制" class="headerlink" title="基于表达式的访问控制"></a>基于表达式的访问控制</h3><p>如角色和IP地址验证<br><code>hasRole(&#39;admin&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;)</code></p><h2 id="水平权限管理"><a href="#水平权限管理" class="headerlink" title="水平权限管理"></a>水平权限管理</h2><h3 id="什么叫水平权限？"><a href="#什么叫水平权限？" class="headerlink" title="什么叫水平权限？"></a>什么叫水平权限？</h3><p>用户A只能访问用户A的数据，不能通过构造URL等手段访问到用户B的数据。</p><h2 id="OAuth（Open-Authorization）"><a href="#OAuth（Open-Authorization）" class="headerlink" title="OAuth（Open Authorization）"></a>OAuth（Open Authorization）</h2><p>OAUTH协议是一个在不提供用户名和密码的情况下，授权第三方应用访问 Web 资源的安全协议。<br>OAuth1.0中分为3个角色（Consumer：消费方 Client、Service Provider：服务提供方 Server、User：用户 Resource Owner）<br>如我们在人人网，想要导入用户MSN里的好友<br>这里人人网为消费方；MSN为服务提供方、用户为资源拥有者</p><h1 id="cookie防篡改（实现思路）"><a href="#cookie防篡改（实现思路）" class="headerlink" title="cookie防篡改（实现思路）"></a>cookie防篡改（实现思路）</h1><ol><li>服务端提供一个签名生成算法secret</li><li>根据方法生成签名secret(wall)=34Yult8i</li><li>将生成的签名放入对应的Cookie项username=wall|34Yult8i。其中，内容和签名用|隔开。</li><li>服务端根据接收到的内容和签名，校验内容是否被篡改（签名和服务器之前生成的不一致则表示cookie被篡改了）。</li></ol><p><a href="https://juejin.im/post/5b02fe326fb9a07ab1117c82" target="_blank" rel="external">Cookie防篡改机制</a></p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">浏览器的同源策略</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://publicsuffix.org/" target="_blank" rel="external">PUBLIC SUFFIX LIST</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://www.srihash.org/" target="_blank" rel="external">SRI Hash Generator</a><br><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">HTTPS</a><br><a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt，免费好用的 HTTPS 证书</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浏览器安全&quot;&gt;&lt;a href=&quot;#浏览器安全&quot; class=&quot;headerlink&quot; title=&quot;浏览器安全&quot;&gt;&lt;/a&gt;浏览器安全&lt;/h1&gt;&lt;h2 id=&quot;同源策略（Same-Origin-Policy）&quot;&gt;&lt;a href=&quot;#同源策略（Same-Origin-
      
    
    </summary>
    
      <category term="安全" scheme="https://fanerge.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://fanerge.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS技巧</title>
    <link href="https://fanerge.github.io/2018/CSS%E6%8A%80%E5%B7%A7.html"/>
    <id>https://fanerge.github.io/2018/CSS技巧.html</id>
    <published>2018-06-13T14:29:35.000Z</published>
    <updated>2018-06-18T08:40:35.512Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结日常CSS技巧，大多收集于网络、<a href="http://www.ituring.com.cn/book/1695" target="_blank" rel="external">《CSS揭秘》</a></p><h2 id="半透明边框"><a href="#半透明边框" class="headerlink" title="半透明边框"></a>半透明边框</h2><p>思路：默认 background 是从  border-box 裁切，我们可以通过 background-clip 属性来改变 background 裁切区域如 padding-box，在使用 rgba 或者 hsla 来指定边框颜色即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.border &#123;</div><div class="line">border: 10px solid hsla(0,0%,100%,.5);</div><div class="line">background: white;</div><div class="line">background-clip: padding-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/translucent-borders">半透明边框</a><br>PS：根据 stack context 层级关系 background 在 border 下层。</p><h2 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h2><h3 id="box-shadow-方案"><a href="#box-shadow-方案" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><p>思路：首先要知道 box-shadow 的参数：vl hl blurl spreadl color inset，并且支持多重阴影。<br><a href="play.csssecrets.io/multiple-borders">demo</a><br>PS：box-shadow 不影响布局（不占用空间）、不受 box-sizing 的控制、不适用于增加热点区域。</p><h3 id="outline-方案"><a href="#outline-方案" class="headerlink" title="outline 方案"></a>outline 方案</h3><p>只适用于两层边框。<br>PS：当 border 为圆角时，outline 不会贴合元素的圆角，需要使用 box-shadow 来填补。 </p><h2 id="灵活的背景定位"><a href="#灵活的背景定位" class="headerlink" title="灵活的背景定位"></a>灵活的背景定位</h2><h3 id="background-position-的扩展语法方案"><a href="#background-position-的扩展语法方案" class="headerlink" title="background-position 的扩展语法方案"></a>background-position 的扩展语法方案</h3><p><code>background-position: right 20px bottom 10px;</code><br>PS：背景定位于 right 的 20px处，bottom 的 10px处。<br><a href="play.csssecrets.io/extended-bg-position">bg-position</a></p><h3 id="background-origin-方案"><a href="#background-origin-方案" class="headerlink" title="background-origin 方案"></a>background-origin 方案</h3><p>background-origin 属性指定 background-position 属性应该是相对位置。<br><a href="play.csssecrets.io/background-origin">background-origin</a></p><h3 id="calc-方案"><a href="#calc-方案" class="headerlink" title="calc() 方案"></a>calc() 方案</h3><p><code>background-position: calc(100% - 20px) calc(100% - 10px);</code><br>PS：需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)。<br><a href="play.csssecrets.io/background-position-calc">background-position-calc</a></p><h2 id="边框内圆角"><a href="#边框内圆角" class="headerlink" title="边框内圆角"></a>边框内圆角</h2><p>我们知道box-shadow是会紧贴border-radius圆角边的，但是，描边outline并不会与圆角边border-radius贴合，我们可以将两者组合，通过box-shadow去填补描边outline所产生的间隙来达到我们想要的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">border-radius: 8px;</div><div class="line">    outline: 6px solid #b4a078;</div><div class="line">    box-shadow: 0 0 0 5px #b4a078; // 用于填充 outline 不能紧靠 border-radius</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://lhammer.cn/You-need-to-know-css/#/inner-rounding" target="_blank" rel="external">边框内圆角</a></p><h2 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h2><h3 id="横向条纹（默认横向渐变）"><a href="#横向条纹（默认横向渐变）" class="headerlink" title="横向条纹（默认横向渐变）"></a>横向条纹（默认横向渐变）</h3><p>如形成三条间隔条纹背景。<br><code>background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);</code><br>PS：#58a 0 的作用为直接填充 &gt; 33.3% 的部分。<br><a href="play.csssecrets.io/horizontal-stripes">horizontal-stripes</a></p><h3 id="垂直条纹"><a href="#垂直条纹" class="headerlink" title="垂直条纹"></a>垂直条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(to right, /* 或 90deg */#fb3 50%, #58a 0);</div><div class="line">background-size: 30px 100%;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/vertical-stripes">vertical-stripes</a></p><h3 id="斜向条纹"><a href="#斜向条纹" class="headerlink" title="斜向条纹"></a>斜向条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);</div><div class="line">background-size: 42.426406871px 42.426406871px;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/diagonal-stripes">diagonal-stripes</a><br><a href="play.csssecrets.io/diagonal-stripes-60deg">diagonal-stripes-60deg</a></p><h3 id="灵活的同色系条纹"><a href="#灵活的同色系条纹" class="headerlink" title="灵活的同色系条纹"></a>灵活的同色系条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: #58a;</div><div class="line">background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/subtle-stripes">subtle-stripes</a></p><h2 id="复杂的背景图案"><a href="#复杂的背景图案" class="headerlink" title="复杂的背景图案"></a>复杂的背景图案</h2><p><a href="play.csssecrets.io/blueprint">网格</a><br><a href="play.csssecrets.io/polka">波点</a><br><a href="play.csssecrets.io/test-conic-gradient">角向渐变</a><br><a href="http://lea.verou.me/css3patterns/" target="_blank" rel="external">css3patterns</a><br><a href="http://bennettfeely.com/gradients/" target="_blank" rel="external">图案库</a></p><h2 id="连续的图像边框"><a href="#连续的图像边框" class="headerlink" title="连续的图像边框"></a>连续的图像边框</h2><p>设置多层背景，再通过 background-clip 来裁剪各层背景。<br><a href="play.csssecrets.io/continuous-image-borders">图像边框</a><br><a href="play.csssecrets.io/vintage-envelope">信封背景</a><br><a href="play.csssecrets.io/marching-ants">蚂蚁行军边框</a><br><a href="play.csssecrets.io/footnote">footnote</a></p><h2 id="自适应的椭圆"><a href="#自适应的椭圆" class="headerlink" title="自适应的椭圆"></a>自适应的椭圆</h2><p>前提为 width === height<br>圆形：<code>border-radius: 100px;</code><br>椭圆：<code>border-radius: 100px / 75px;</code><br>适应性椭圆：<code>border-radius: 50%;</code><br>PS：50%; === 50% / 50%;分别为该元素的宽的50%和高的50%。<br><a href="play.csssecrets.io/ellipse">适应性椭圆</a><br>适应性的半椭圆：<code>border-radius: 100% 0 0 100% / 50%;</code><br>PS：上面的写法，分别为四个角设置。<br><a href="play.csssecrets.io/half-ellipse">适应性的半椭圆</a><br>四分之一椭圆：<code>border-radius: 100% 0 0 0;</code><br>PS：其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。<br><a href="play.csssecrets.io/quarter-ellipse">quarter-ellipse</a></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p>需求为让容器元素为平行四边形，但文本不可倾斜。</p><h3 id="嵌套元素方案"><a href="#嵌套元素方案" class="headerlink" title="嵌套元素方案"></a>嵌套元素方案</h3><p><a href="play.csssecrets.io/parallelograms">抵消策略</a><br>PS：对容器进行 skew() 变形，对内容再应用一次反向的 skew() 变形，从而抵消容器的变形效果</p><h3 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><p><a href="play.csssecrets.io/parallelograms-pseudo">parallelograms-pseudo</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p><h2 id="菱形图片"><a href="#菱形图片" class="headerlink" title="菱形图片"></a>菱形图片</h2><h3 id="基于变形的方案"><a href="#基于变形的方案" class="headerlink" title="基于变形的方案"></a>基于变形的方案</h3><p><a href="play.csssecrets.io/diamond-images">diamond-images</a><br>PS：运用 rotate(-45deg) 再使用 scale(1.42) 填满菱形区域。</p><h3 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p><code>clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);</code><br><a href="play.csssecrets.io/diamond-clip">diamond-clip</a></p><h2 id="切角效果"><a href="#切角效果" class="headerlink" title="切角效果"></a>切角效果</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p><a href="play.csssecrets.io/bevel-corners-gradients">线性渐变</a></p><h3 id="弧形切角"><a href="#弧形切角" class="headerlink" title="弧形切角"></a>弧形切角</h3><p><a href="play.csssecrets.io/scoop-corners">径向渐变</a></p><h3 id="内联-SVG-与-border-image-方案"><a href="#内联-SVG-与-border-image-方案" class="headerlink" title="内联 SVG 与 border-image 方案"></a>内联 SVG 与 border-image 方案</h3><p>相关 SVG 支持，以背景形式引入 SVG。<br><a href="play.csssecrets.io/bevel-corners">bevel-corners</a></p><h3 id="裁切路径方案-1"><a href="#裁切路径方案-1" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p>主要使用 clip-path 属性。<br><a href="play.csssecrets.io/bevel-corners-clipped">bevel-corners-clipped</a></p><h2 id="梯形标签页"><a href="#梯形标签页" class="headerlink" title="梯形标签页"></a>梯形标签页</h2><p>需求为让容器元素为梯形，但文本不可倾斜。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform: perspective(.5em) rotateX(5deg);</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/trapezoid-tabs">trapezoid-tabs</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p><h2 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h2><h3 id="基于-transform-的解决方案"><a href="#基于-transform-的解决方案" class="headerlink" title="基于 transform 的解决方案"></a>基于 transform 的解决方案</h3><p><a href="play.csssecrets.io/pie-animated">pie-animated</a><br><a href="play.csssecrets.io/pie-static">pie-static</a></p><h3 id="SVG-解决方案"><a href="#SVG-解决方案" class="headerlink" title="SVG 解决方案"></a>SVG 解决方案</h3><p><a href="play.csssecrets.io/pie-svg">pie-svg</a></p><h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>box-shadow: hl vl blur spread color;<br>PS：hl为水平位置，vl为垂直位置，blur为模糊距离（模糊面积越大，阴影就越大越淡），spread为阴影大小（取正值时，阴影扩大；取负值时，阴影收缩）。    </p><h3 id="单侧投影"><a href="#单侧投影" class="headerlink" title="单侧投影"></a>单侧投影</h3><p><code>box-shadow: 0 5px 4px -4px black;</code><br><a href="play.csssecrets.io/shadow-one-side">shadow-one-side</a><br>PS：第四个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。</p><h3 id="对边投影"><a href="#对边投影" class="headerlink" title="对边投影"></a>对边投影</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box-shadow: 5px 0 5px -5px black,</div><div class="line">-5px 0 5px -5px black;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/shadow-opposite-sides">shadow-opposite-sides</a><br>PS：利用 box-shadow 可以设置多重阴影。</p><h2 id="不规则投影"><a href="#不规则投影" class="headerlink" title="不规则投影"></a>不规则投影</h2><h3 id="filter-之-drop-shadow"><a href="#filter-之-drop-shadow" class="headerlink" title="filter 之 drop-shadow()"></a>filter 之 drop-shadow()</h3><p><a href="https://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/" target="_blank" rel="external">drop-shadow滤镜与box-shadow区别应用</a><br><a href="https://www.zhangxinxu.com/study/201605/drop-shadow-point-to.html" target="_blank" rel="external">demo</a><br><a href="play.csssecrets.io/drop-shadow">demo1</a><br>PS：drop-shadow 没有 inset，不能叠加，有颜色就会有阴影（不特定于盒模型）。</p><h2 id="染色效果"><a href="#染色效果" class="headerlink" title="染色效果"></a>染色效果</h2><h3 id="基于滤镜的方案"><a href="#基于滤镜的方案" class="headerlink" title="基于滤镜的方案"></a>基于滤镜的方案</h3><p><a href="play.csssecrets.io/color-tint-filter">color-tint-filter</a><br><a href="http://www.runoob.com/cssref/css3-pr-filter.html" target="_blank" rel="external">滤镜文档</a></p><h3 id="基于混合模式的方案"><a href="#基于混合模式的方案" class="headerlink" title="基于混合模式的方案"></a>基于混合模式的方案</h3><p>background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。<br><a href="play.csssecrets.io/color-tint">color-tint</a></p><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p><a href="play.csssecrets.io/frosted-glass">frosted-glass</a><br>PS：伪类来实现效果，原本元素放文本，就不会导致文本模糊。</p><h2 id="折角效果"><a href="#折角效果" class="headerlink" title="折角效果"></a>折角效果</h2><h3 id="45°折角的解决方案"><a href="#45°折角的解决方案" class="headerlink" title="45°折角的解决方案"></a>45°折角的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">background: #58a; /* 回退样式 */</div><div class="line">background: linear-gradient(to left bottom,</div><div class="line">transparent 50%, rgba(0,0,0,.4) 0)</div><div class="line">no-repeat 100% 0 / 2em 2em,</div><div class="line">linear-gradient(-135deg,</div><div class="line">transparent 1.5em, #58a 0);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/folded-corner">folded-corner</a></p><h3 id="其他角度的解决方案"><a href="#其他角度的解决方案" class="headerlink" title="其他角度的解决方案"></a>其他角度的解决方案</h3><p><a href="play.csssecrets.io/folded-corner-realistic">folded-corner-realistic</a><br><a href="play.csssecrets.io/folded-corner-mixin">folded-corner-mixin</a></p><h2 id="连字符断行"><a href="#连字符断行" class="headerlink" title="连字符断行"></a>连字符断行</h2><p>CSS 属性 hyphens 告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。<br><a href="play.csssecrets.io/hyphenation">hyphenation</a></p><h2 id="插入换行"><a href="#插入换行" class="headerlink" title="插入换行"></a>插入换行</h2><p><a href="play.csssecrets.io/line-breaks">line-breaks</a><br>PS：有一个 Unicode 字符是专门代表换行符的： 0x000A ① 。在 CSS 中，这个字符可以写作 “\000A” ，或简化为 “\A” ，类似于 br 标签。</p><h2 id="文本行的斑马条纹"><a href="#文本行的斑马条纹" class="headerlink" title="文本行的斑马条纹"></a>文本行的斑马条纹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">padding: .5em;</div><div class="line">line-height: 1.5;</div><div class="line">background: beige;</div><div class="line">background-size: auto 3em;</div><div class="line">background-origin: content-box;</div><div class="line">background-image: linear-gradient(rgba(0,0,0,.2) 50%,</div><div class="line">transparent 0);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/zebra-lines">zebra-lines</a></p><h2 id="调整-tab-的宽度"><a href="#调整-tab-的宽度" class="headerlink" title="调整 tab 的宽度"></a>调整 tab 的宽度</h2><p>tab-size 属性规定制表符（tab）字符的空格长度，只对 textarea 和 pre 有效。<br><a href="play.csssecrets.io/tab-size">tab-size</a></p><h2 id="连字"><a href="#连字" class="headerlink" title="连字"></a>连字</h2><p>font-variant-ligatures<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures;</div></pre></td></tr></table></figure></p><h2 id="未来的文本下划线"><a href="#未来的文本下划线" class="headerlink" title="未来的文本下划线"></a>未来的文本下划线</h2><p>text-decoration-color 用于自定义下划线或其他装饰效果的颜色。<br>text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。<br>text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。<br>text-underline-position 用于微调下划线的具体摆放位置。<br><a href="play.csssecrets.io/underlines">underlines</a></p><h2 id="现实中的文字效果"><a href="#现实中的文字效果" class="headerlink" title="现实中的文字效果"></a>现实中的文字效果</h2><p><a href="play.csssecrets.io/letterpress">凸版印刷效果</a><br><a href="play.csssecrets.io/stroked-text">空心字效果</a><br><a href="play.csssecrets.io/glow">文字外发光效果</a><br><a href="play.csssecrets.io/extruded">文字凸起效果</a></p><h2 id="环形文字"><a href="#环形文字" class="headerlink" title="环形文字"></a>环形文字</h2><p><a href="play.csssecrets.io/circular-text">SVG实现</a></p><h2 id="选用合适的鼠标光标"><a href="#选用合适的鼠标光标" class="headerlink" title="选用合适的鼠标光标"></a>选用合适的鼠标光标</h2><h3 id="提示禁用状态"><a href="#提示禁用状态" class="headerlink" title="提示禁用状态"></a>提示禁用状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</div><div class="line">cursor: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/disabled">disabled</a></p><h3 id="隐藏鼠标光标"><a href="#隐藏鼠标光标" class="headerlink" title="隐藏鼠标光标"></a>隐藏鼠标光标</h3><p>适用于播放 video 等情形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cursor: url(&apos;transparent.gif&apos;); // 兼容低版本</div><div class="line">cursor: none;</div></pre></td></tr></table></figure></p><h2 id="扩大可点击区域"><a href="#扩大可点击区域" class="headerlink" title="扩大可点击区域"></a>扩大可点击区域</h2><h3 id="Fitts-法则-或-菲茨定律-或-费茨法则"><a href="#Fitts-法则-或-菲茨定律-或-费茨法则" class="headerlink" title="Fitts 法则 或 菲茨定律 或 费茨法则"></a>Fitts 法则 或 菲茨定律 或 费茨法则</h3><p>人机交互的一个法则<br>Fitts 法则认为，人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。</p><h3 id="border-增加用户交互区域"><a href="#border-增加用户交互区域" class="headerlink" title="border 增加用户交互区域"></a>border 增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">border: 10px solid transparent;</div><div class="line">box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;</div><div class="line">background-clip: padding-box;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/hit-area-border">hit-area-border</a></p><h3 id="伪类增加用户交互区域"><a href="#伪类增加用户交互区域" class="headerlink" title="伪类增加用户交互区域"></a>伪类增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">button &#123;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">button::before &#123;</div><div class="line">content: &apos;&apos;;</div><div class="line">position: absolute;</div><div class="line">top: -10px; right: -10px;</div><div class="line">bottom: -10px; left: -10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/hit-area">hit-area</a></p><h2 id="自定义复选框"><a href="#自定义复选框" class="headerlink" title="自定义复选框"></a>自定义复选框</h2><p><a href="play.csssecrets.io/checkboxes">checkboxes</a><br><a href="play.csssecrets.io/toggle-buttons">toggle-buttons</a></p><h2 id="通过阴影来弱化背景"><a href="#通过阴影来弱化背景" class="headerlink" title="通过阴影来弱化背景"></a>通过阴影来弱化背景</h2><h3 id="伪元素方案-1"><a href="#伪元素方案-1" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body.dimmed::before &#123;</div><div class="line">position: fixed;</div><div class="line">top: 0;</div><div class="line">right: 0;</div><div class="line">bottom: 0;</div><div class="line">left: 0;</div><div class="line">z-index: 1;</div><div class="line">background: rgba(0,0,0,.8);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="box-shadow-方案-1"><a href="#box-shadow-方案-1" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);</div></pre></td></tr></table></figure><p><a href="box-shadow: 0 0 0 50vmax rgba(0,0,0,.8" target="_blank" rel="external">box-shadow</a>;)</p><h3 id="backdrop-方案"><a href="#backdrop-方案" class="headerlink" title="backdrop 方案"></a>backdrop 方案</h3><p><a href="play.csssecrets.io/native-modal">backdrop</a><br>PS：dialog 元素（ <dialog> 元素可以由它的 showModal() 方法显示出来），那么根据浏览器的默认样式，它会自带一个遮罩层（ ::backdrop 伪元素）。</dialog></p><h2 id="通过模糊来弱化背景"><a href="#通过模糊来弱化背景" class="headerlink" title="通过模糊来弱化背景"></a>通过模糊来弱化背景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main.de-emphasized &#123;</div><div class="line">filter: blur(3px) contrast(.8) brightness(.8);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/deemphasizing-blur">滤镜效果</a></p><h2 id="滚动提示"><a href="#滚动提示" class="headerlink" title="滚动提示"></a>滚动提示</h2><p><a href="play.csssecrets.io/scrolling-hints">上下滚动</a></p><h2 id="交互式的图片对比控件"><a href="#交互式的图片对比控件" class="headerlink" title="交互式的图片对比控件"></a>交互式的图片对比控件</h2><p><a href="play.csssecrets.io/image-slider">image-slider</a></p><h2 id="自适应内部元素"><a href="#自适应内部元素" class="headerlink" title="自适应内部元素"></a>自适应内部元素</h2><p>width 新添了一些属性，如min-content。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">figure &#123;</div><div class="line">max-width: 300px;</div><div class="line">max-width: min-content;</div><div class="line">margin: auto;</div><div class="line">&#125;</div><div class="line">figure &gt; img &#123; max-width: inherit; &#125;</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/intrinsic-sizing">intrinsic-sizing</a></p><h2 id="精确控制表格列宽"><a href="#精确控制表格列宽" class="headerlink" title="精确控制表格列宽"></a>精确控制表格列宽</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table &#123;</div><div class="line">table-layout: fixed;</div><div class="line">width: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/table-column-widths">table-column-widths</a></p><h2 id="根据兄弟元素的数量来设置样式"><a href="#根据兄弟元素的数量来设置样式" class="headerlink" title="根据兄弟元素的数量来设置样式"></a>根据兄弟元素的数量来设置样式</h2><h3 id="相当于li-only-child"><a href="#相当于li-only-child" class="headerlink" title="相当于li:only-child"></a>相当于li:only-child</h3><p>li:first-child:nth-last-child(1)</p><h3 id="当列表正好包含四项时，命中所有列表项"><a href="#当列表正好包含四项时，命中所有列表项" class="headerlink" title="当列表正好包含四项时，命中所有列表项"></a>当列表正好包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(4),<br>li:first-child:nth-last-child(4) ~ li</p><h3 id="当列表至少包含四项时，命中所有列表项"><a href="#当列表至少包含四项时，命中所有列表项" class="headerlink" title="当列表至少包含四项时，命中所有列表项"></a>当列表至少包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+4),<br>li:first-child:nth-last-child(n+4) ~ li</p><h3 id="当列表最多包含四项时，命中所有列表项"><a href="#当列表最多包含四项时，命中所有列表项" class="headerlink" title="当列表最多包含四项时，命中所有列表项"></a>当列表最多包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(-n+4),<br>li:first-child:nth-last-child(-n+4) ~ li </p><h3 id="当列表包含2～6项时，命中所有列表项"><a href="#当列表包含2～6项时，命中所有列表项" class="headerlink" title="当列表包含2～6项时，命中所有列表项"></a>当列表包含2～6项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+2):nth-last-child(-n+6),<br>li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li<br><a href="play.csssecrets.io/styling-sibling-count">styling-sibling-count</a></p><h2 id="满幅的背景，定宽的内容"><a href="#满幅的背景，定宽的内容" class="headerlink" title="满幅的背景，定宽的内容"></a>满幅的背景，定宽的内容</h2><p><a href="play.csssecrets.io/fluid-fixed">fluid-fixed</a></p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">position: absolute;</div><div class="line">top: 50%;</div><div class="line">left: 50%;</div><div class="line">transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">width: 18em;</div><div class="line">padding: 1em 1.5em;</div><div class="line">margin: 50vh auto 0; // 这里不能使用50%，详细请了解包含快知识</div><div class="line">transform: translateY(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">&#125;</div><div class="line">main &#123;</div><div class="line">margin: auto; // 水平和垂直都可以居中</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案（匿名容器）"><a href="#基于-Flexbox-的解决方案（匿名容器）" class="headerlink" title="基于 Flexbox 的解决方案（匿名容器）"></a>基于 Flexbox 的解决方案（匿名容器）</h3><p>PS：匿名容器即为没有被标签包裹的文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">align-items: center;</div><div class="line">justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="紧贴底部的页脚"><a href="#紧贴底部的页脚" class="headerlink" title="紧贴底部的页脚"></a>紧贴底部的页脚</h2><p>下列 header、main、footer 为 body 的子元素。</p><h3 id="固定高度的解决方案"><a href="#固定高度的解决方案" class="headerlink" title="固定高度的解决方案"></a>固定高度的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">min-height: calc(100vh - footerHeight);</div><div class="line">/* 避免内边距或边框搞乱高度的计算： */</div><div class="line">box-sizing: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="flex的解决方案"><a href="#flex的解决方案" class="headerlink" title="flex的解决方案"></a>flex的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">display: flex;</div><div class="line">flex-flow: column;</div><div class="line">min-height: 100vh;</div><div class="line">&#125;</div><div class="line">main &#123; </div><div class="line">// 自动伸展并占满所有的可用空间</div><div class="line">flex: 1; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="缓动效果（动画和过渡）"><a href="#缓动效果（动画和过渡）" class="headerlink" title="缓动效果（动画和过渡）"></a>缓动效果（动画和过渡）</h2><p><a href="play.csssecrets.io/bounce">回弹动画</a><br><a href="play.csssecrets.io/elastic">弹性过渡</a><br>PS：对颜色过渡时小心，RGB 三个通道的值是独立进行插值运算的，在过渡过程中会产生其他颜色。<br>一般通过 transition-property 设置指定过渡属性来避免。</p><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p>运动曲线适用性：贝塞尔曲线适用于平滑运动， steps(步进数, [start || end])适用于逐帧动画<br>PS：参数一为步进数（把动画分为多少步，然后在逐步运行），参数二用于指定动画在每个循环周期的什么位置发生帧的切换动作。<br><a href="play.csssecrets.io/frame-by-frame">逐帧动画</a></p><h3 id="闪烁效果"><a href="#闪烁效果" class="headerlink" title="闪烁效果"></a>闪烁效果</h3><p>animation-direction 属性定义是否循环交替反向播放动画。<br>reverse    动画反向播放。<br>alternate    动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。<br>alternate-reverse    动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。<br><a href="play.csssecrets.io/blink">闪烁效果</a></p><h3 id="打字动画"><a href="#打字动画" class="headerlink" title="打字动画"></a>打字动画</h3><p><a href="play.csssecrets.io/typing">打字动画</a></p><h3 id="状态平滑的动画"><a href="#状态平滑的动画" class="headerlink" title="状态平滑的动画"></a>状态平滑的动画</h3><p>animation–play-state 属性指定动画是否正在运行或已暂停。<br>paused    指定暂停动画<br>running    指定正在运行的动画<br><a href="play.csssecrets.io/state-animations">指定暂停动画</a></p><h2 id="first-letter"><a href="#first-letter" class="headerlink" title="::first-letter"></a>::first-letter</h2><p>定义：::first-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。</p><ol><li>::first-letter 伪元素生效的前提，常见的标点符号、各类括号和引号在::first-letter 伪元素眼中全部都是“辅助类”字符，不会作为第一个字符计算。</li><li>与::before使用（::before 若有字符，会参与计算及 伪类的 content 的字符会被::first-letter生效）。</li><li>::first-letter 伪元素可以生效的 CSS 属性有：字体属性、背景属性、color、padding、border、margin等。</li></ol><p>PS：“辅助类”包括·@#%&amp;<em>()（）[]【】{}:：”“”;；’‘’》《,，.。？?!！…</em>、/\。<br><a href="https://github.com/cubiq/iscroll/" target="_blank" rel="external">iScroll, smooth scrolling for the web</a></p><h2 id="CJK（中文-日文-韩文）两端对齐"><a href="#CJK（中文-日文-韩文）两端对齐" class="headerlink" title="CJK（中文/日文/韩文）两端对齐"></a>CJK（中文/日文/韩文）两端对齐</h2><p>text-align: justify;<br>text-justify: inter-ideograph;</p><h2 id="用户交互反馈（通用的按钮及连接交互反馈）"><a href="#用户交互反馈（通用的按钮及连接交互反馈）" class="headerlink" title="用户交互反馈（通用的按钮及连接交互反馈）"></a>用户交互反馈（通用的按钮及连接交互反馈）</h2><p>通用的连接和按钮交互反馈，原理为：background-color 总是在最底下的位置，所以这里的 background-image 一定是覆盖在按钮等元素背景色之上的，不会影响按钮原来的背景色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[href]:active, button:active &#123;</div><div class="line">background-image: linear-gradient(to top, rgba(0,0,0,.05), rgba(0,0,0,.05));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="script-标签"><a href="#script-标签" class="headerlink" title="script 标签"></a>script 标签</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，同时不渲染，不进行资源加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/html&quot;&gt;</div><div class="line">&lt;img src=&quot;1.jpg&quot;&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>PS：script标签隐藏内容获取使用 script.innerHTML</p><h3 id="display-none-隐藏"><a href="#display-none-隐藏" class="headerlink" title="display:none 隐藏"></a>display:none 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但资源有加载，DOM 可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.dn &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="visibility-hidden-隐藏"><a href="#visibility-hidden-隐藏" class="headerlink" title="visibility: hidden 隐藏"></a>visibility: hidden 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但显隐的时候可以有 transition 淡入淡出效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.hidden &#123;</div><div class="line">position: absolute;</div><div class="line">visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果希望元素不可见，不能点击，辅助设备无法访问，但占据空间保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.hidden &#123;</div><div class="line">visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="clip-剪裁隐藏"><a href="#clip-剪裁隐藏" class="headerlink" title="clip 剪裁隐藏"></a>clip 剪裁隐藏</h3><p>如果希望元素不可见，不能点击，不占据空间，但键盘可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.clip &#123;</div><div class="line">position: absolute;</div><div class="line">clip: rect(0 0 0 0);</div><div class="line">&#125;</div><div class="line">.out &#123;</div><div class="line">position: relative;</div><div class="line">left: -999em;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="relative-隐藏"><a href="#relative-隐藏" class="headerlink" title="relative 隐藏"></a>relative 隐藏</h3><p>如果希望元素不可见，不能点击，但占据空间，且键盘可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.lower &#123;</div><div class="line">position: relative;</div><div class="line">z-index: -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="透明度隐藏"><a href="#透明度隐藏" class="headerlink" title="透明度隐藏"></a>透明度隐藏</h3><p>如果希望元素不可见，但可以点击，而且不占据空间，则可以使用透明度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.opacity &#123;</div><div class="line">position: absolute;</div><div class="line">opacity: 0;</div><div class="line">filter: Alpha(opacity=0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果单纯希望元素看不见，但位置保留，依然可以点可以选，则直接让透明度为 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.opacity &#123;</div><div class="line">opacity: 0;</div><div class="line">filter: Alpha(opacity=0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：img元素，设置 display:none 在所有浏览器下依旧都会请求图片资源（浪费了宽带）。</p><h3 id="流向的改"><a href="#流向的改" class="headerlink" title="流向的改"></a>流向的改</h3><p>direction（改变水平流向）<br>unicode-bidi（文字流向）<br>writing-mode（改变 CSS 世界纵横规则）<br>writing-mode: lr-tb | tb-rl | tb-lr (IE8+);<br>writing-mode: horizontal-tb | vertical-rl | vertical-lr;</p><h2 id="1px边框（移动端）"><a href="#1px边框（移动端）" class="headerlink" title="1px边框（移动端）"></a>1px边框（移动端）</h2><h3 id="box-shadow-border-transform"><a href="#box-shadow-border-transform" class="headerlink" title="box-shadow/border + transform"></a>box-shadow/border + transform</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.border &#123;</div><div class="line">width: 100%;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.border::after &#123;</div><div class="line">content:&apos;&apos;;</div><div class="line">position: absolute;</div><div class="line">bottom: 0;left: 0;</div><div class="line">width: 100%;</div><div class="line">box-shadow: 0 0 0 1px red;</div><div class="line">transform-origin: 0 bottom;</div><div class="line">transform: scaleY(.5);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：还可以结合 @media (min-resolution: xdppx)做进一步处理。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background-origin: padding-box; 默认<br>background-position: top 20px left 20px; 参照点为默认padding-box<br>background-size: x y;<br>圆锥渐变<br>background: conic-gradient(red, yellow, lime, aqua, blue, fuchsia, red);<br>background缩写语法<br>background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><ol><li>可以通过’/‘设置水平水平和垂直半径，如<code>border-radius: 100px / 75px;</code></li><li>它不仅可以接受长度值，还可以接受百分比值（这个百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。）。</li><li></li></ol><h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>指定元素内的空白怎样处理。<br>normal    默认。空白会被浏览器忽略。<br>pre    空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。<br>nowrap    文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。<br>pre-wrap    保留空白符序列，但是正常地进行换行。<br>pre-line    合并空白符序列，但是保留换行符。<br>inherit    规定应该从父元素继承 white-space 属性的值。</pre></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>line-height 的百分比时相对于 font-size 计算的。<br>vertical-align 的百分比时相对于 line-height 计算的。<br>ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。)<br>ch 数字 0 的宽度，使用场景（需要配合等宽字体）：全数字输入框：手机号等。<br>font-weight 运行原理：字体不同粗细需要字体文件是否存在该粗细的字体。<br>font-style  同样有效的前提为字体文件中存在该类型的字体，italic 和 oblique。<br>font-family: system-ui; // 让网页的字体跟系统走，，网站字体能时时刻刻与时俱进。<br>text-transform 属性控制文本的大小写，支持capitalize、uppercase、lowercase。<br>适用场景：身份证输入，最后以为X，帮助用户转为大写；验证码输入，帮助用户转为大写。<br>::backdrop CSS 伪元素 是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结日常CSS技巧，大多收集于网络、&lt;a href=&quot;http://www.ituring.com.cn/book/1695&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《CSS揭秘》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;半透明边框&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记</title>
    <link href="https://fanerge.github.io/2018/CSS%E7%AC%94%E8%AE%B0.html"/>
    <id>https://fanerge.github.io/2018/CSS笔记.html</id>
    <published>2018-06-06T12:45:51.000Z</published>
    <updated>2018-06-12T13:28:13.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。</p><h1 id="CSS方法"><a href="#CSS方法" class="headerlink" title="CSS方法"></a>CSS方法</h1><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p>用来获取选择到的元素的某一HTML属性值，并用于其样式。</p><h2 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h2><p>可以通过计算来决定一个CSS属性的值了。<br>PS：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px);</code></p><h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p><code>counter-reset</code>属性创建或重置一个或多个计数器。<br><code>counter-increment</code>属性递增一个或多个计数器值。<br><code>counter(name)</code>方法用于获取计数器的值。<br>PS：<code>counter-reset</code>属性通常是和<code>counter-increment</code>属性，<code>content</code>属性一起使用。</p><h2 id="cubic-bezier"><a href="#cubic-bezier" class="headerlink" title="cubic-bezier()"></a>cubic-bezier()</h2><p>它主要作用于动画和过渡的运动曲线函数 animation-timing-function 和 transition-timing-function 。<br><a href="http://cubic-bezier.com/" target="_blank" rel="external">cubic-bezier转换网站</a></p><h2 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h2><h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h3><p>线性渐变<br><code>background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);</code><br><code>repeating-linear-gradient</code> – 重复线性渐变<br><code>background: repeating-linear-gradient(to top left, lightpink, lightpink 5px, white 5px, white 10px);</code></p><h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient"></a>radial-gradient</h3><p>径向渐变<br><code>background: radial-gradient(red, yellow, rgb(30, 144, 255));</code><br><code>repeating-radial-gradient</code> – 重复径向渐变<br><code>background: repeating-radial-gradient(powderblue, powderblue 8px, white 8px, white 16px);</code></p><h2 id="image-set"><a href="#image-set" class="headerlink" title="image-set()"></a>image-set()</h2><p>可以根据用户设备的分辨率匹配合适的图像。<br><code>background-image: image-set( &quot;test.png&quot; 1x, &quot;test-2x.png&quot; 2x, &quot;test-print.png&quot; 600dpi );</code></p><h3 id="img-的-srcset属性"><a href="#img-的-srcset属性" class="headerlink" title="img 的 srcset属性"></a>img 的 srcset属性</h3><p>以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。<br><code>&lt;img src=&quot;mm-width-128px.jpg&quot; srcset=&quot;mm-width-128px.jpg 1x, mm-width-256px.jpg 2x&quot;&gt;</code><br>PS：img的srcset属性方便的解决了页面图片适应不同屏幕密度的情况。</p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h2><p>matrix() 指定了一个由指定的 6 个值组成的 2D 变换矩阵。这种矩阵的常量值是隐含的，而不是由参数传递的；其他的参数是以列优先的顺序描述的。<br>matrix3d() 参数为 9 个值，对应 3D 变换。<br>PS：所有的 transform 参数值都可以用矩阵来表示。</p><h2 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h2><p>var()函数可以代替元素中任何属性中的值的任何部分。<br>语法：<code>var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? )</code><br>ps：带有前缀–的属性名，比如–example–name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。</p><h1 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h1><h2 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h2><p>指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。</p><h2 id="cross-fade"><a href="#cross-fade" class="headerlink" title="cross-fade"></a>cross-fade</h2><p>作用：CSS3背景图片透明叠加属性。<br>方法：<code>background-image: -webkit-cross-fade(url(1.jpg), url(2.jpg), 50%);</code><br>PS：透明度是作用在第二张图片上的。<br><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-background-image-cross-fade/" target="_blank" rel="external">Cross-fade</a></p><h2 id="caret-color"><a href="#caret-color" class="headerlink" title="caret-color"></a>caret-color</h2><p>用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。</p><h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><p>可以创建一个只有元素的部分区域可以显示的剪切区域（也就是说可以让一个元素显示出不同的形式，如圆形、椭圆、多边形等等）。<br><a href="http://yunkus.com/css-clip-path/" target="_blank" rel="external">CSS3 clip-path 用法详解</a></p><h2 id="shape-outside"><a href="#shape-outside" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>属性指定使用下面列表的值来定义浮动元素的浮动区域。这个浮动区域决定了行内内容（浮动元素）所包裹的形状。<br>其中还包括basic-shape有inset()、 circle()、ellipse()、polygon()</p><h2 id="resolution"><a href="#resolution" class="headerlink" title="resolution"></a>resolution</h2><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>每英寸包含点的数量（dots per inch）<br>普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx）。</p><h3 id="dpcm"><a href="#dpcm" class="headerlink" title="dpcm"></a>dpcm</h3><p>每厘米包含点的数量（dots per centimeter）</p><h3 id="dppx"><a href="#dppx" class="headerlink" title="dppx"></a>dppx</h3><p>每像素包含点的数量（dots per pixel）<br>基本的换算单位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1dppx = 96dpi</div><div class="line">1dpi ≈ 0.39dpcm</div><div class="line">1dpcm ≈ 2.54dpi</div><div class="line">1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px</div></pre></td></tr></table></figure></p><h2 id="empty-cells"><a href="#empty-cells" class="headerlink" title="empty-cells"></a>empty-cells</h2><p>渲染表格 table 中没有可见内容的单元格的边框和背景，取值为show 和 hide。</p><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>width属性又多了几个关键字成员，fill-available, max-content, min-content, 以及fit-content，兼容性还有很大问题，暂不深究。</p><h3 id="max-content"><a href="#max-content" class="headerlink" title="max-content"></a>max-content</h3><p>固有的首选宽度.</p><h3 id="min-content"><a href="#min-content" class="headerlink" title="min-content"></a>min-content</h3><p>这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素）。</p><h3 id="available"><a href="#available" class="headerlink" title="available"></a>available</h3><p>包含块的宽度减去水平 margin, border 和 padding.</p><h3 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h3><p>以下两种情况下的较大值:固有的最小宽度 或 固有首选宽度（max-content）和可用宽度（available）的较小值  </p><h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><p>之前的 length 或 percentage 应用到元素的边框盒子.</p><h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><p>之前的 length 或 percentage 应用到元素的内容盒子.</p><h2 id="hanging-punctuation"><a href="#hanging-punctuation" class="headerlink" title="hanging-punctuation"></a>hanging-punctuation</h2><p>指定了标点符号应该放在文本句子的开头还是结尾。悬挂标点符号可能被放在线框外。</p><h2 id="hyphens"><a href="#hyphens" class="headerlink" title="hyphens"></a>hyphens</h2><p>告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。</p><h2 id="image-rendering"><a href="#image-rendering" class="headerlink" title="image-rendering"></a>image-rendering</h2><p>决定浏览器对缩放图像采取的缩放算法.它适用于元素本身和有其他属性的图像.它对非缩放图像没有影响。</p><h2 id="image-orientation"><a href="#image-orientation" class="headerlink" title="image-orientation"></a>image-orientation</h2><p>用来修正某些图片的预设方向。<br>PS：该属性不是用来对图片进行任意角度旋转的, 它是用来修正那些带有不正确的预设方向的图片的. 因此该属性值会被四舍五入到 90 度的整数倍.</p><h2 id="通用关键字"><a href="#通用关键字" class="headerlink" title="通用关键字"></a>通用关键字</h2><p><code>inherit</code> – 关键字使得元素获取其父元素的计算值(computed value )，当然肯定只针对可继承属性。<br><code>initial</code> – 是将属性的初始值( initial value)赋给元素，至于那些为<a href="https://www.w3.org/TR/CSS2/propidx.html" target="_blank" rel="external">不同属性的初始值，请参见W3C</a>。<br><code>unset</code> – CSS 关键字 unset 是 关键字 initial 和 inherit的组合（换句话说这个unset关键字会优先用inherit的样式，其次会应该用initial的样式）。<br><code>all</code> – CSS all简写属性重设除了unicode-bidi 和 direction 之外的所有属性至它们的初始值或继承值。</p><h2 id="inline-size"><a href="#inline-size" class="headerlink" title="inline-size"></a>inline-size</h2><p>定义元素的块的水平或垂直大小，这取决于它的写入模式。它对应于 width 或 height，取决于 writing-mode 属性。</p><h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>定义该元素是否必须创建一个新的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="external">stacking context</a>。<br>PS：该属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。</p><h2 id="支持欠佳的属性，暂不深究"><a href="#支持欠佳的属性，暂不深究" class="headerlink" title="支持欠佳的属性，暂不深究"></a>支持欠佳的属性，暂不深究</h2><p>margin-block-start 和 margin-block-end<br>定义元素的逻辑块结束余量，该元素根据元素的writing-mode、方向性和文本方向映射到物理量度。<br>margin-inline-start 和 margin-inline-end<br>min-block-size 和 min-inline-size<br>offset-block-start 和 offset-block-end<br>offset-inline-start 和 offset-inline-end<br>padding-block-start 和 padding-block-end<br>padding-inline-end 和 padding-inline-start</p><h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。<br>遮罩mask是一个复合属性，包括mask-image、mask-mode、mask-repeat、mask-position、mask-clip、mask-origin、mask-size、mask-composite这8个属性</p><h3 id="mask-image"><a href="#mask-image" class="headerlink" title="mask-image"></a>mask-image</h3><p>默认值为none，值为透明图片，或透明渐变</p><h3 id="mask-repeat"><a href="#mask-repeat" class="headerlink" title="mask-repeat"></a>mask-repeat</h3><p>默认值为repeat，可选值与background-repeat相同</p><h3 id="mask-position"><a href="#mask-position" class="headerlink" title="mask-position"></a>mask-position</h3><p>默认值为0 0，可选值与background-position相同</p><h3 id="mask-clip"><a href="#mask-clip" class="headerlink" title="mask-clip"></a>mask-clip</h3><p>默认值为border-box，可选值与background-clip相同</p><h3 id="mask-origin"><a href="#mask-origin" class="headerlink" title="mask-origin"></a>mask-origin</h3><p>默认值为border-box，可选值与background-origin相同</p><h3 id="mask-size"><a href="#mask-size" class="headerlink" title="mask-size"></a>mask-size</h3><p>默认值为auto，可选值与background-size相同</p><h3 id="mask-mode"><a href="#mask-mode" class="headerlink" title="mask-mode"></a>mask-mode</h3><p>默认值为match-source，可选值为alpha、luminance、match-source，或者它们的组合</p><h3 id="mask-composite"><a href="#mask-composite" class="headerlink" title="mask-composite"></a>mask-composite</h3><p>默认值为add，可选值为add、subtract、intersect、exclude</p><h2 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h2><p>描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p><h2 id="作用于替换元素，如img"><a href="#作用于替换元素，如img" class="headerlink" title="作用于替换元素，如img"></a>作用于替换元素，如img</h2><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p>指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</p><h3 id="object-position"><a href="#object-position" class="headerlink" title="object-position"></a>object-position</h3><p>指定元素的替换内容在其盒子内的对齐方式。</p><h2 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h2><p>是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。<br>PS：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。</p><h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><p>指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。</p><h2 id="quotes"><a href="#quotes" class="headerlink" title="quotes"></a>quotes</h2><p>设置嵌套引用的引号类型。<br>PS：当4个参数时，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。</p><h2 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h2><p>CSS 规则关联了一组嵌套的CSS语句,这些语句被放置在一个CSS区块中,该区块以大括号分割, 还有一个由多个CSS声明检测组成的条件,它是一个键值组合, 由逻辑与,逻辑或,逻辑非组合而成. 这样的条件语句称为支持条件.<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@supports &lt;supports_condition&gt; &#123;</div><div class="line">  /* specific rules */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：在 supports_condition 中还支持 not、or、and 逻辑。</p><h2 id="tab-size"><a href="#tab-size" class="headerlink" title="tab-size"></a>tab-size</h2><p>用于自定义制表符 (U+0009) 的宽度。</p><h2 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h2><p>用于布局表格单元格，行和列的算法。</p><h2 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h2><p>描述的是一段文本中最后一行在被强制换行之前的对齐规则。</p><h2 id="text-combine-upright"><a href="#text-combine-upright" class="headerlink" title="text-combine-upright"></a>text-combine-upright</h2><p>文本结合 writing-mode（为vertical-rl 或 vertical-lr） 指定多个字符的组合到单个字符的空间中。</p><h2 id="text-emphasis"><a href="#text-emphasis" class="headerlink" title="text-emphasis"></a>text-emphasis</h2><p>主要效果为文本强调。<br>text-emphasis-color<br>text-emphasis-position<br>text-emphasis-style</p><h2 id="text-orientation"><a href="#text-orientation" class="headerlink" title="text-orientation"></a>text-orientation</h2><p>设置文本的方向。</p><h2 id="text-rendering"><a href="#text-rendering" class="headerlink" title="text-rendering"></a>text-rendering</h2><p>CSS 属性定义浏览器渲染引擎如何渲染字体。浏览器会在速度、清晰度、几何精度之间进行权衡。</p><h2 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h2><p>CSS属性指定如何将元素的文本大小写。</p><h2 id="text-underline-position"><a href="#text-underline-position" class="headerlink" title="text-underline-position"></a>text-underline-position</h2><p>当 text-decoration属性的值设置为 underline 之后，可以用 text-underline-position 属性为其设置下划线的位置。</p><h2 id="touch-action"><a href="#touch-action" class="headerlink" title="touch-action"></a>touch-action</h2><p>用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。</p><h2 id="transform-box"><a href="#transform-box" class="headerlink" title="transform-box"></a>transform-box</h2><p>defines the layout box, to which the transform and transform-origin properties relate to.</p><h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><p>确定元素的子元素是否位于3D空间中，还是在该元素所在的平面内被扁平化。</p><h2 id="unicode-bidi"><a href="#unicode-bidi" class="headerlink" title="unicode-bidi"></a>unicode-bidi</h2><p>CSS 的 unicode-bidi 属性和 direction 属性一起决定了如何处理文档中的双向文本（bidirectional text）。</p><h2 id="unicode-range"><a href="#unicode-range" class="headerlink" title="unicode-range"></a>unicode-range</h2><p>属性值可以是单个字符编码、字符编码区间、通配符区间、多个值等，如小写字母：[0x61,0x7a]（或十进制[97, 122]）<br>CSS unicode-range 特定字符使用 font-face 自定义字体。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。<br><code>baseline</code><br>元素基线与父元素的基线对齐。<br>对于一些 可替换元素，比如 textarea ， HTML标准没有说明它的基线，这意味着对其使用这个关键字，各浏览器表现可能不一样。<br><code>sub</code><br>元素基线与父元素的下标基线对齐。<br><code>super</code><br>元素基线与父元素的上标基线对齐。<br><code>text-top</code><br>元素顶端与父元素字体的顶端对齐。<br><code>text-bottom</code><br>元素底端与父元素字体的底端对齐。<br><code>middle</code><br>元素中垂线与父元素的基线加上小写x一半的高度值对齐。<br><code>length</code><br>元素基线超过父元素的基线指定高度。可以取负值。<br><code>percentage</code><br>同 length , 百分比相对于 line-height 。<br>以下两个值是相对于整行来说的：<br><code>top</code><br> 元素及其后代的顶端与整行的顶端对齐。<br><code>bottom</code><br>元素及其后代的底端与整行的底端对齐。</p><h2 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h2><p>CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。<br>PS：这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p><h2 id="增加热区的范围"><a href="#增加热区的范围" class="headerlink" title="增加热区的范围"></a>增加热区的范围</h2><ol><li>border 可以增加热区（与用户交互的区域），outline 和 box-shadow 是不能办到的。</li><li>伪元素同样可以代表其宿主元素来响应鼠标交互。</li></ol><p>通常的做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">border: 10px solid transparent;</div></pre></td></tr></table></figure></p><h1 id="filter-滤镜效果"><a href="#filter-滤镜效果" class="headerlink" title="filter(滤镜效果)"></a>filter(滤镜效果)</h1><p>CSS滤镜（filter）属提供的图形特效，像模糊，锐化或元素变色。过滤器通常被用于调整图片，背景和边界的渲染。<br>filter 可以开启浏览器的硬件加速GPU，优化性能。</p><h2 id="blur"><a href="#blur" class="headerlink" title="blur()"></a>blur()</h2><p>给图像设置高斯模糊。filter: blur(number);</p><h2 id="brightness"><a href="#brightness" class="headerlink" title="brightness()"></a>brightness()</h2><p>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</p><h2 id="drop-shadow"><a href="#drop-shadow" class="headerlink" title="drop-shadow()"></a>drop-shadow()</h2><p>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 </p><h2 id="contrast"><a href="#contrast" class="headerlink" title="contrast()"></a>contrast()</h2><p>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</p><h2 id="grayscale"><a href="#grayscale" class="headerlink" title="grayscale()"></a>grayscale()</h2><p>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p><h2 id="hue-rotate"><a href="#hue-rotate" class="headerlink" title="hue-rotate()"></a>hue-rotate()</h2><p>给图像应用色相旋转。“angle”一值设定图像会被调整的色环角度值。</p><h2 id="invert"><a href="#invert" class="headerlink" title="invert()"></a>invert()</h2><p>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</p><h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity()"></a>opacity()</h2><p>转化图像的透明程度。</p><h2 id="saturate"><a href="#saturate" class="headerlink" title="saturate()"></a>saturate()</h2><p>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。</p><h2 id="sepia"><a href="#sepia" class="headerlink" title="sepia()"></a>sepia()</h2><p>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。<br>PS：你可以组合任意数量的函数来控制渲染。下面的例子可以增强图像的对比度和亮度。<br><code>filter: contrast(175%) brightness(3%)</code></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background 是CSS简写属性，用来集中设置各种背景属性。background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat,background-size, background-attachment。</p><h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p>如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。</p><h2 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h2><p>定义该元素的背景图片，以及背景色如何混合。</p><h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>置元素的背景（背景图片或颜色）是否延伸到边框下面。<br>PS：简写形式background:bg-color bg-image bg-position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p><h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><h2 id="active"><a href="#active" class="headerlink" title=":active"></a>:active</h2><p>:active CSS伪类匹配被用户激活的元素。<br>PS：当多伪类同时使用时，需要注意顺序，否则就会发生被覆盖，如链接:link — :visited — :hover — :active。</p><h2 id="target"><a href="#target" class="headerlink" title=":target"></a>:target</h2><p>代表一个唯一的页面元素(目标元素)，其ID与当前URL片段匹配.</p><h2 id="default"><a href="#default" class="headerlink" title=":default"></a>:default</h2><p>表示一组相关元素中的默认表单元素。<br><code>该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用。</code></p><h2 id="dir"><a href="#dir" class="headerlink" title=":dir"></a>:dir</h2><p>伪类匹配特定文字书写方向的元素。在HTML中, 文字方向由dir属性决定。</p><h2 id="enabled"><a href="#enabled" class="headerlink" title=":enabled"></a>:enabled</h2><p>表示任何启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入）或获取焦点，则该元素是启用的。</p><h2 id="disabled"><a href="#disabled" class="headerlink" title=":disabled"></a>:disabled</h2><p>表示任何被禁用的元素。如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。</p><h2 id="read-only"><a href="#read-only" class="headerlink" title=":read-only"></a>:read-only</h2><p>表示元素不可被用户编辑的状态（如锁定的文本输入框）。</p><h2 id="read-write"><a href="#read-write" class="headerlink" title=":read-write"></a>:read-write</h2><p>代表一个元素（例如可输入文本的 input元素）可以被用户编辑。<br>PS：这个选择器不仅仅选择 input 元素，它也会选择所有可以被用户编辑的元素，例如设置了 contenteditable 属性的 p 元素。</p><h2 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h2><p>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格），无论一个元素是否为 (empty 或 not), 注释或处理指令都不会产生影响。</p><h2 id="not"><a href="#not" class="headerlink" title=":not()"></a>:not()</h2><p>是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。<br>PS：:not伪类不像其它伪类，它不会增加选择器的优先级。</p><h2 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h2><p>表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。</p><h2 id="fullscreen"><a href="#fullscreen" class="headerlink" title=":fullscreen"></a>:fullscreen</h2><p>应用于当前处于全屏显示模式的元素。 它不仅仅选择顶级元素，还包括所有已显示的栈内元素。</p><h2 id="in-range"><a href="#in-range" class="headerlink" title=":in-range"></a>:in-range</h2><p>代表一个 input 元素，其当前值处于属性min 和max 限定的范围之内.</p><h2 id="out-of-range"><a href="#out-of-range" class="headerlink" title=":out-of-range"></a>:out-of-range</h2><p>代表一个 input 元素，其当前值不在属性min 和max 限定的范围之内.</p><h2 id="indeterminate"><a href="#indeterminate" class="headerlink" title=":indeterminate"></a>:indeterminate</h2><p>表示状态不确定的表单元素.</p><h2 id="invalid"><a href="#invalid" class="headerlink" title=":invalid"></a>:invalid</h2><p>表示任意内容未通过验证的 input 或其他 form 元素 .</p><h2 id="valid"><a href="#valid" class="headerlink" title=":valid"></a>:valid</h2><p>表示任意内容通过验证的 input 或其他 form 元素 .</p><h2 id="required"><a href="#required" class="headerlink" title=":required"></a>:required</h2><p>表示 任意 input 元素表示任意拥有required属性的 input 或 textarea 元素使用它. 它允许表单在提交之前容易的展示必填字段并且渲染其外观. </p><h2 id="lang"><a href="#lang" class="headerlink" title=":lang()"></a>:lang()</h2><p>基于元素语言来匹配页面元素。</p><h2 id="optional"><a href="#optional" class="headerlink" title=":optional"></a>:optional</h2><p>表示任意没有required属性的 input，select 或  textarea 元素使用它。</p><h2 id="only-child"><a href="#only-child" class="headerlink" title=":only-child"></a>:only-child</h2><p>代表了属于某个父元素的唯一一个子元素.<br>PS：等价的方法还有:first-child:last-child或者:nth-child(1):nth-last-child(1)</p><h2 id="root"><a href="#root" class="headerlink" title=":root"></a>:root</h2><p>这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 html 元素，除了优先级更高之外，与 html 选择器相同。</p><h2 id="scope"><a href="#scope" class="headerlink" title=":scope"></a>:scope</h2><p>它将会匹配作为选择符匹配元素的参考点(css的作用域或作用点)。在HTML中，可以使用 style 的scoped属性来重新定义新的参考点。如果HTML中没有使用这个属性，那么默认的参考点(css的作用域或作用点)是 html。</p><h2 id="scroll-behavior"><a href="#scroll-behavior" class="headerlink" title="scroll-behavior"></a>scroll-behavior</h2><p>当由于导航或者CSSOM滚动api产生滚动时，CSS属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。<br>PS：可以配合 a 链接来实现平滑滚动到对应锚点位置。<br><a href="https://codepen.io/fanerge/pen/ERPELJ" target="_blank" rel="external">可以在Chrome浏览器中测试下</a></p><h2 id="scroll-snap-type"><a href="#scroll-snap-type" class="headerlink" title="scroll-snap-type"></a>scroll-snap-type</h2><p>CSS属性定义在滚动容器中的一个snap点如何被严格的执行。<br>PS：此属性不能用来指定任何精确的动画或者物理运动效果来执行snap点，而是交给用户代理来处理。</p><h2 id="shape-outside-1"><a href="#shape-outside-1" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>CSS 属性定义了一个行内内容应该包裹的形状。默认表现是行内元素包裹该形状的margin box。</p><h2 id="shape-image-threshold"><a href="#shape-image-threshold" class="headerlink" title="shape-image-threshold"></a>shape-image-threshold</h2><p>CSS property defines the alpha channel threshold used to extract the shape using an image as the value for shape-outside.</p><h2 id="shape-margin"><a href="#shape-margin" class="headerlink" title="shape-margin"></a>shape-margin</h2><p>CSS property specifies a margin for a CSS shape created using shape-outside.</p><h1 id="page"><a href="#page" class="headerlink" title="@page"></a>@page</h1><p>@page 规则用于在打印文档时修改某些CSS属性。<br>你不能用@page规则来修改所有的CSS属性，而是只能修改margin,orphans,widow 和 page breaks of the document。对其他属性的修改是无效的。</p><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>指定页面盒模型所在的容器的大小和方向。一般情况下，因为一个页面盒模型被渲染到一面纸张上，所以这个属性也指示了目标纸张的大小。</p><h2 id="marks"><a href="#marks" class="headerlink" title="marks"></a>marks</h2><p>向文档添加剪切标记和/或注册标记。</p><h2 id="bleed"><a href="#bleed" class="headerlink" title="bleed"></a>bleed</h2><p>指定一个超出页面盒模型的区域，在这个区域的页面内容将被裁剪。</p><h2 id="first"><a href="#first" class="headerlink" title=":first"></a>:first</h2><p>需要和 @page 配套使用，打印文档的时候，第一页的样式。</p><h2 id="left"><a href="#left" class="headerlink" title=":left"></a>:left</h2><p>需要和 @page 配套使用, 对打印文档的左侧页设置CSS样式.</p><h2 id="right"><a href="#right" class="headerlink" title=":right"></a>:right</h2><p>需要和 @page 配套使用, 对打印文档的右侧页设置CSS样式.</p><h2 id="blank"><a href="#blank" class="headerlink" title=":blank"></a>:blank</h2><p>与 :empty 关系类似，浏览器支持不佳。</p><h2 id="两个实验性"><a href="#两个实验性" class="headerlink" title="两个实验性"></a>两个实验性</h2><p>:recto 和 :verso </p><h2 id="page-break-after"><a href="#page-break-after" class="headerlink" title="page-break-after"></a>page-break-after</h2><p>CSS 属性调整当前元素之后的分页符</p><h2 id="page-break-before"><a href="#page-break-before" class="headerlink" title="page-break-before"></a>page-break-before</h2><p>CSS属性调整当前元素之前的分页符。</p><h2 id="page-break-inside"><a href="#page-break-inside" class="headerlink" title="page-break-inside"></a>page-break-inside</h2><p>CSS 属性调整当前元素内的分页符。</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><h2 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h2><p>::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。<br>PS：这个虚拟元素默认是行内元素。</p><h2 id="fitst-letter"><a href="#fitst-letter" class="headerlink" title="::fitst-letter"></a>::fitst-letter</h2><p>会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。<br>PS：你可能还不知道，::before 伪元素 和 content 属性结合起来有可能会在元素前面注入一些文本。如此，::first-letter 将会匹配到content文本的首字母。<br>首行只在 block-container box内部才有意义, 因此 ::first-letter 伪元素 只在display属性值为block, inline-block, table-cell, list-item 或者 table-caption的元素上才起作用. 其他情况下, ::first-letter 毫无意义.</p><h2 id="backdrop"><a href="#backdrop" class="headerlink" title="::backdrop"></a>::backdrop</h2><p>是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p><h2 id="placeholder"><a href="#placeholder" class="headerlink" title="::placeholder"></a>::placeholder</h2><p>可以选择一个表单元素的占位文本，它允许开发者和设计师自定义占位文本的样式。</p><h2 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h2><p>应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。</p><h2 id="slotted"><a href="#slotted" class="headerlink" title="::slotted()"></a>::slotted()</h2><p>CSS pseudo-element represents any element that has been placed into a slot inside an HTML template (see Using templates and slots for more information).</p><h1 id="css3-布局"><a href="#css3-布局" class="headerlink" title="css3 布局"></a>css3 布局</h1><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>place-content<br><a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/0320%E6%80%BB%E7%BB%93flex%E5%B8%83%E5%B1%80.txt" target="_blank" rel="external">Study-Notes</a></p><h2 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h2><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>通过设置 display: grid;  可以定义一个 CSS 网格。然后使用 grid-template-rows 和 grid-template-columns 属性来定义网格的 columns 和 rows。<br>PS：grid-template-rows 和 grid-template-columns 有较多种参数。<br>minmax(min, max)<br>可以设置最小值和最大值，当某个值为 auto 时不限制。<br>repeat( [ <positive-integer> | auto-fill | auto-fit ] , <track-list> )<br>重复的多个 track，第一个参数指定了 repeat 的次数。<br>auto-fit<br>倾向于使用最少列数占满当前行空间，浏览器先是和 auto-fill 一样，暗中创建一些列来填充多出来的行空间，然后坍缩（collapse）这些列以便腾出空间让其余列扩张。<br>auto-fill<br>倾向于容纳更多的列，所以如果在满足宽度限制的前提下还有空间能容纳新列，那么它会暗中创建一些列来填充当前行。</track-list></positive-integer></p><h3 id="Grid-Areas"><a href="#Grid-Areas" class="headerlink" title="Grid Areas"></a>Grid Areas</h3><p>网格区域是网格中由一个或者多个网格单元格组成的一个矩形区域。当你使用基于网格线位置放置一个项目或者使用命名的网格区域定义区域时，网格区域被创建。<br>通常用 grid-area 属性命名它们（为子网格命名），然后用 grid-template-areas 把它们放在网格上。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_areas" target="_blank" rel="external">Grid Areas</a></p><h3 id="Grid-Lines"><a href="#Grid-Lines" class="headerlink" title="Grid Lines"></a>Grid Lines</h3><p>使用Grid布局在显式网格中定义轨道的同时会创建网格线。<br>网格线可以用它们的编号来寻址，线编号遵循文档的写入模式，因此在从右到左的语言中，列线1行将位于网格的右侧。<br>PS：主要给下列属性使用grid-column-start、grid-column-end、grid-row-start、grid-row-end。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_lines" target="_blank" rel="external">Grid Lines</a></p><h3 id="Gutters"><a href="#Gutters" class="headerlink" title="Gutters"></a>Gutters</h3><p>网格间距是网格轨道之间的间距，可以通过 grid-column-gap 或者 grid-row-gap 在Grid布局中创建。</p><h1 id="动画和过渡和转换"><a href="#动画和过渡和转换" class="headerlink" title="动画和过渡和转换"></a>动画和过渡和转换</h1><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>animation属性是如下属性的一个简写属性形式: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode.</p><h2 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h2><p>指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。</p><h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p>CSS属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。</p><h2 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h2><p>CSS 属性指示动画是否反向播放，它通常在简写属性animation中设定。</p><h2 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h2><p>用来指定在动画执行之前和之后如何给动画的目标应用样式。</p><h2 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h2><p>定义动画在结束前运行的次数 可以是1次 无限循环。</p><h2 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h2><p>定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。</p><h2 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h2><p>定义CSS动画在每一动画周期中执行的节奏。</p><h2 id="perspective-或-perspective"><a href="#perspective-或-perspective" class="headerlink" title="perspective 或 perspective()"></a>perspective 或 perspective()</h2><p>指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。</p><h2 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h2><p>指定了观察者的位置，在属性perspective中被用作消失点。</p><h1 id="百分比属性参照对象"><a href="#百分比属性参照对象" class="headerlink" title="百分比属性参照对象"></a>百分比属性参照对象</h1><h2 id="参照包含块宽高"><a href="#参照包含块宽高" class="headerlink" title="参照包含块宽高"></a>参照包含块宽高</h2><ol><li>参照包含块的width（margin、padding、width、left、right、font-size、text-index）</li><li>参照包含块的height（height、top、bottom）</li></ol><h2 id="参照自身盒子宽高"><a href="#参照自身盒子宽高" class="headerlink" title="参照自身盒子宽高"></a>参照自身盒子宽高</h2><ol><li>盒子模型中的border-radius</li><li>背景中的background-size</li><li>在transform变换中，translate()、transform-origin、scale()<br><a href="https://juejin.im/post/5b0bc994f265da092918d421" target="_blank" rel="external">你知道我们平时在CSS中写的%都是相对于谁吗？</a></li></ol><h1 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h1><h2 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h2><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>相对长度单位，这个单位表示元素的font-size的计算值。如果用在font-size 属性本身，它会继承父元素的font-size。</p><h3 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h3><p>这个单位表示元素font的 x-height 。在含有“x”字母的字体中，它是该字体的小写字母的高度；对于很多字体， 1ex ≈ 0.5em。</p><h3 id="ch"><a href="#ch" class="headerlink" title="ch"></a>ch</h3><p>这一单位代表元素所用字体 font中“0”这一字形的宽度（“0”，Unicode字符U+0030），或更准确地说是“0”这一字形的预测尺寸（advance measure）。</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>这个单位代表根元素的 font-size 大小（html 元素的font-size）。</p><h3 id="lh"><a href="#lh" class="headerlink" title="lh"></a>lh</h3><p>等于元素行高line-height的计算值。</p><h3 id="rlh"><a href="#rlh" class="headerlink" title="rlh"></a>rlh</h3><p>等于根元素行高line-height的计算值。</p><h2 id="视口比例的长度"><a href="#视口比例的长度" class="headerlink" title="视口比例的长度"></a>视口比例的长度</h2><h3 id="vh"><a href="#vh" class="headerlink" title="vh"></a>vh</h3><p>视口高度的 1/100。</p><h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h3><p>视口宽度的 1/100。</p><h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>等于初始包含块的大小的1%，在根元素的内联轴的方向上。</p><h3 id="vb"><a href="#vb" class="headerlink" title="vb"></a>vb</h3><p>等于初始包含块的大小的1%，在根元素的块轴的方向上。</p><h3 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a>vmin</h3><p>视口高度和宽度之间的最小值的 1/100。</p><h3 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a>vmax</h3><p>视口高度和宽度之间的最大值的 1/100。</p><h2 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h2><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>对于屏幕显示，通常是一个设备像素（点）的显示。</p><h3 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h3><p>毫米。</p><h3 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h3><p>厘米（10毫米）。</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>英寸（2.54厘米）。</p><h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>磅（1/72 英寸）。</p><h3 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h3><p>12 点活字 (1 pc 等于 12 点)。</p><h1 id="color"><a href="#color" class="headerlink" title="color"></a>color</h1><h2 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h2><p>black（黑） 、silver（银）、gray[*]（灰）、white（白）等等。</p><h2 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h2><p>transparent 关键字，是 rgba(0,0,0,0) 的简写。<br>currentColor 关键字，取当前 color 的值。</p><h2 id="颜色表达式"><a href="#颜色表达式" class="headerlink" title="颜色表达式"></a>颜色表达式</h2><p>十六进制符号 #RRGGBB<br>rgb(r, g, b)<br>rgba(r, g, b, a)<br>hsl(h, s, l) // 分别代表：色相、饱和度、亮度<br>hsla(h, s, l, a)</p><h1 id="angle"><a href="#angle" class="headerlink" title="angle"></a>angle</h1><p>用于表示角的大小，单位为度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）。在 gradient 和 transform 的某些方法等场景中有所应用。</p><h2 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h2><p>度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。</p><h2 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h2><p>百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。</p><h2 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h2><p>弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。</p><h2 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h2><p>圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。</p><h1 id="cusor（各属性使用的场景）"><a href="#cusor（各属性使用的场景）" class="headerlink" title="cusor（各属性使用的场景）"></a>cusor（各属性使用的场景）</h1><h2 id="not-allowed"><a href="#not-allowed" class="headerlink" title="not-allowed"></a>not-allowed</h2><p>提示禁用状态，如按钮禁用、禁止拖动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</div><div class="line">cursor: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p>隐藏鼠标光标，如播放视频等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">video &#123;</div><div class="line">cursor: url(transparent.gif); // 兼容</div><div class="line">cursor: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。&lt;/p&gt;
&lt;h1 id=&quot;CSS方法&quot;&gt;&lt;a href=&quot;#CSS方法&quot; class=&quot;headerlink&quot; title=&quot;CSS方法&quot;&gt;&lt;/a&gt;CSS方
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>记录一些有趣的repo</title>
    <link href="https://fanerge.github.io/2018/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84repo.html"/>
    <id>https://fanerge.github.io/2018/记录一些有趣的repo.html</id>
    <published>2018-05-31T12:22:58.000Z</published>
    <updated>2018-07-11T14:11:44.718Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hellogithub.com/" target="_blank" rel="external">大量开源项目hellogithub</a></p><h1 id="best-resume-ever"><a href="#best-resume-ever" class="headerlink" title="best-resume-ever"></a>best-resume-ever</h1><p>用Vue和LESS简单、快速建立许多漂亮的简历，并创建你最好的简历。<br><a href="https://github.com/salomonelli/best-resume-ever" target="_blank" rel="external">best-resume-ever</a><br><a href="https://salomonelli.github.io/best-resume-ever/#/" target="_blank" rel="external">官网地址</a></p><h1 id="css知识"><a href="#css知识" class="headerlink" title="css知识"></a>css知识</h1><p><a href="https://github.com/l-hammer/You-need-to-know-css" target="_blank" rel="external">You-need-to-know-css</a></p><h1 id="Web性能测试工具"><a href="#Web性能测试工具" class="headerlink" title="Web性能测试工具"></a>Web性能测试工具</h1><p><a href="https://github.com/pod4g/hiper" target="_blank" rel="external">hiper</a></p><h1 id="实现数字动画"><a href="#实现数字动画" class="headerlink" title="实现数字动画"></a>实现数字动画</h1><p><a href="https://github.com/inorganik/CountUp.js" target="_blank" rel="external">countUp.js</a></p><h1 id="Web页面加载进度条"><a href="#Web页面加载进度条" class="headerlink" title="Web页面加载进度条"></a>Web页面加载进度条</h1><p><a href="https://github.com/rstacruz/nprogress/" target="_blank" rel="external">nprogress</a><br><a href="https://github.com/jacoborus/nanobar" target="_blank" rel="external">nanobar</a></p><h1 id="UI库"><a href="#UI库" class="headerlink" title="UI库"></a>UI库</h1><p><a href="https://github.com/yued-fe/lulu" target="_blank" rel="external">阅文-lulu（jQuery）</a></p><h1 id="常用的网址"><a href="#常用的网址" class="headerlink" title="常用的网址"></a>常用的网址</h1><p><a href="https://codepoints.net/" target="_blank" rel="external">码点查询大全</a>    </p><h1 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h1><h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><p>Fiddler、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hellogithub.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大量开源项目hellogithub&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;best-resume-ever&quot;&gt;&lt;a href=&quot;#best-resu
      
    
    </summary>
    
      <category term="杂项" scheme="https://fanerge.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="优秀项目" scheme="https://fanerge.github.io/tags/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Chrome调试</title>
    <link href="https://fanerge.github.io/2018/chrome%E8%B0%83%E8%AF%95.html"/>
    <id>https://fanerge.github.io/2018/chrome调试.html</id>
    <published>2018-05-24T14:13:30.000Z</published>
    <updated>2018-05-24T14:21:21.194Z</updated>
    
    <content type="html"><![CDATA[<p>记录Chrome DevTools比较少用但又很重要的技巧。</p><h1 id="检查动画"><a href="#检查动画" class="headerlink" title="检查动画"></a>检查动画</h1><p>使用Chrome DevTools Animations(动画)检查器检查和修改动画。<br>功能：<br>通过打开Animation Inspector(动画检查器)捕获动画。它会自动检测动画并将它们分组。<br>通过减慢动画，重播动画，或查看源代码，来检查动画。<br>通过更改动画的时间，延迟，持续时间或关键帧偏移来修改动画。</p><h1 id="设置DOM断点"><a href="#设置DOM断点" class="headerlink" title="设置DOM断点"></a>设置DOM断点</h1><p>设置DOM断点可以用来调试复杂的JavaScript应用程序。例如，如果你的JavaScript改变了DOM元素的样式，设置一个DOM断点当元素的属性被修改时触发。<br>在以下DOM更改都会触发断点：子树的变化，属性改变，节点删除。<br>设置DOM断点<br>Elements –&gt; Break on –&gt; Subtree Modifications/Attributes Modifications/Node Removal<br>查看DOM断点（包含断点类型）<br>Elements –&gt; DOM Breakpoints</p><h1 id="查看元素事件监听器"><a href="#查看元素事件监听器" class="headerlink" title="查看元素事件监听器"></a>查看元素事件监听器</h1><p>在Event Listeners(事件侦听器)窗格中查看与DOM节点相关联的JavaScript事件。<br>查看事件<br>Elements –&gt; Event Listeners<br>当取消勾选Framework listeners(框架侦听器)复选框时，事件侦听器代码可能会解析框架或库代码中的某处。</p><h1 id="模拟传感器"><a href="#模拟传感器" class="headerlink" title="模拟传感器"></a>模拟传感器</h1><p>Main menu –&gt; More Tools –&gt; Sensors<br>模拟地理位置坐标以测试地理位置覆盖。<br>模拟设备方向来测试加速计数据。</p><h1 id="在XHR上中断"><a href="#在XHR上中断" class="headerlink" title="在XHR上中断"></a>在XHR上中断</h1><p>有两种方法可以触发XHR上的断点：当任何XHR到达XHR生命周期的某个阶段时（readystatechange，load等），或者当XHR的URL与某个字符串匹配时。</p><h1 id="调试杂项"><a href="#调试杂项" class="headerlink" title="调试杂项"></a>调试杂项</h1><p>命名函数可以提高调用堆栈的可读性，不限于回掉函数。</p><h2 id="把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等"><a href="#把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等" class="headerlink" title="把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等"></a>把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等</h2><p>1.打开 DevTools Settings(设置)。<br>2.在左侧的导航菜单中，单击Blackboxing(黑箱)。<br>3.点击Add pattern…(添加模式)按钮。<br>4.在Pattern(模式)文本框输入您希望从调用堆栈中排除的文件名模式。DevTools 会排除该模式匹配的任何脚本。<br>5.在文本字段右侧的下拉菜单中，选择Blackbox(黑箱)以执行脚本文件但是排除来自调用堆栈的调用，或选择6.Disabled(禁用)来阻止文件执行。<br>7.点击 Add(添加) 保存。<br>下次运行页面并触发断点时，DevTools 将在Call Stack(调用堆栈)中隐藏任何来自放入黑盒脚本函数的调用。<br><a href="http://www.css88.com/doc/chrome-devtools/javascript/step-code/" target="_blank" rel="external">把第三方代码放入Blackbox</a><br>管理线程执行<br>使用Sources(源文件)面板上的Threads(线程)窗格暂停，step into(步入)，并检查其他线程，例如service worker 或 web worker 线程。</p><h2 id="启动-JavaScript-CPU-状态分析"><a href="#启动-JavaScript-CPU-状态分析" class="headerlink" title="启动 JavaScript CPU 状态分析"></a>启动 JavaScript CPU 状态分析</h2><p>启动一个JavaScript CPU 状态分析，可以添加一个可选标签名。要停止分析，请调用console.profileEnd()。每个分析结果都将添加到Profiles(分析)面板。<br>console.profile([label])<br>console.profileEnd();<br>在调用该方法的地方打印堆栈跟踪。<br>console.trace(object)</p><h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>monitorEvents()方法指示DevTools记录指定目标事件的信息。<br>monitorEvents(document.body, “click”);<br>要停止监听事件，请调用unmonitorEvents()方法,传递一个停止监视对象的参数。<br>unmonitorEvents(document.body);<br>查看在对象上注册事件监听器<br>getEventListeners() API返回在指定对象上注册事件的监听器。<br>返回值是一个对象，其中包含每个已注册事件类型的数组（例如，click 或 keydown）。 每个数组的成员都是对象，描述每中类型的已注册监听器。</p><blockquote><p>   参考文档：<br><a href="http://www.css88.com/doc/chrome-devtools/" target="_blank" rel="external">参考</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录Chrome DevTools比较少用但又很重要的技巧。&lt;/p&gt;
&lt;h1 id=&quot;检查动画&quot;&gt;&lt;a href=&quot;#检查动画&quot; class=&quot;headerlink&quot; title=&quot;检查动画&quot;&gt;&lt;/a&gt;检查动画&lt;/h1&gt;&lt;p&gt;使用Chrome DevTools Animat
      
    
    </summary>
    
      <category term="调试" scheme="https://fanerge.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://fanerge.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Web知识</title>
    <link href="https://fanerge.github.io/2018/Web%E6%9C%AF%E8%AF%AD.html"/>
    <id>https://fanerge.github.io/2018/Web术语.html</id>
    <published>2018-05-14T12:53:23.000Z</published>
    <updated>2018-07-09T14:22:52.128Z</updated>
    
    <content type="html"><![CDATA[<p>本文所有知识点，点到即止，详细内容请看各部分的连接。</p><h2 id="点击穿透（多见于移动端模态框等浮层）"><a href="#点击穿透（多见于移动端模态框等浮层）" class="headerlink" title="点击穿透（多见于移动端模态框等浮层）"></a>点击穿透（多见于移动端模态框等浮层）</h2><p>产生：上层元素触发touch事件-&gt;上层元素消失（300ms之内）-&gt;底层元素click事件触发<br>PS：touch事件之后会有300ms延迟在执行click事件是因为，在这300ms中若再次tap行为则认定为double tap事件，否则就触发click事件。<br>方案：只用touch事件、只用click事件（不推荐）、fastclick类库等<br><a href="https://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="CSP（内容安全策略Content-Security-Policy）"><a href="#CSP（内容安全策略Content-Security-Policy）" class="headerlink" title="CSP（内容安全策略Content-Security-Policy）"></a>CSP（内容安全策略Content-Security-Policy）</h2><p>定义：内容安全策略 (Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>定义：CORS (跨域资源共享)是一个系统, 包括传输的 HTTP headers, 其确定是否阻止或完成从该资源所在的域外的另一个域的网页上的受限资源的请求。<br>PS：同源安全策略( same-origin security policy)默认禁止“跨域”请求. CORS 给予Web服务器跨域访问控制, 启用安全的跨域数据传输。<br><a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" target="_blank" rel="external">CORS</a></p><h2 id="BFC（块格式化上下文Block-Formatting-Context）"><a href="#BFC（块格式化上下文Block-Formatting-Context）" class="headerlink" title="BFC（块格式化上下文Block Formatting Context）"></a>BFC（块格式化上下文Block Formatting Context）</h2><p>定义：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br>如何触发BFC：<br>• html 根元素；<br>• float 的值不为 none；<br>• overflow 的值为 auto、scroll 或 hidden；<br>• display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；<br>• position 的值不为 relative 和 static。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">块格式化上下文</a></p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p>CRLF实际上是两个字符：CR是Carriage Return（ASCII 13，\r），LF是Line Feed（ASCII 10，\n）。<br>\r\n这两个字符是用于表示换行的，其十六进制编码分别为 0x0d、0x0a。</p><h2 id="containing-block（包含块）"><a href="#containing-block（包含块）" class="headerlink" title="containing block（包含块）"></a>containing block（包含块）</h2><p>定义：在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。<br>PS：主要作用是以百分比（相关于包含块）计算自身的width、height、top、left、padding、margin等css Layout 属性。<br><a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">我所了解的CSS包含块</a>    </p><h2 id="FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）"><a href="#FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）" class="headerlink" title="FOUC（无样式内容闪烁Flash Of Unstyled Content）"></a>FOUC（无样式内容闪烁Flash Of Unstyled Content）</h2><p>定义：指的是加载网页时出现的短暂的CSS样式失效。<br>方案：head头部放css、避免使用import<br><a href="https://www.cnblogs.com/fsjohnhuang/p/6739064.html" target="_blank" rel="external">FOUC</a></p><h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>定义：由于不同的浏览器对CSS的支持程度不同，同样CSS的样式代码在不同浏览器当中的表现可能出现不一致。为了让所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。<br>方案：属性前缀法、选择器前缀法、条件注释法（<!--[if lt IE 8]-->）</p><h2 id="Domain-Name（域名）"><a href="#Domain-Name（域名）" class="headerlink" title="Domain Name（域名）"></a>Domain Name（域名）</h2><p>域名（英语：Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>顶级域名又称为跟域名（TLD）共1058+（.com、.net、.cn等等）<br>13个根域名服务器（不代表只有13台服务器，事实上517+台服务器）</p><h2 id="DNS（网域名称系统Domain-Name-System）"><a href="#DNS（网域名称系统Domain-Name-System）" class="headerlink" title="DNS（网域名称系统Domain Name System）"></a>DNS（网域名称系统Domain Name System）</h2><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p><h2 id="a链接问题"><a href="#a链接问题" class="headerlink" title="a链接问题"></a>a链接问题</h2><p>a链接使用绑定 mousedown 事件且 event.preventDefault() 会导致 :active 伪类失效（Firefox）。<br>PS：Firefox 认为 mousedown 事件在 :active 之前发生。</p><h2 id="min-width、max-width、width、-important优先级"><a href="#min-width、max-width、width、-important优先级" class="headerlink" title="min-width、max-width、width、!important优先级"></a>min-width、max-width、width、!important优先级</h2><p>如果min-width、max-width、width、!important同时存在时，优先级顺序：min-width &gt;&gt; max-width &gt;&gt; !important &gt;&gt; width</p><h2 id="巧用css-兄弟选择器（如导航分割线）"><a href="#巧用css-兄弟选择器（如导航分割线）" class="headerlink" title="巧用css 兄弟选择器（如导航分割线）"></a>巧用css 兄弟选择器（如导航分割线）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;</div><div class="line">// 这样排除第一个元素</div><div class="line">a + a:before &#123;</div><div class="line">content: &quot;&quot;;</div><div class="line">font-size: 0;</div><div class="line">padding: 10px 3px 1px;</div><div class="line">margin-left: 6px;</div><div class="line">border-left: 1px solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="img-在firefox和其他浏览器的差异"><a href="#img-在firefox和其他浏览器的差异" class="headerlink" title="img 在firefox和其他浏览器的差异"></a>img 在firefox和其他浏览器的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">// width 和 height 无效，需要设置display: inline-block;</div><div class="line">width: xx;</div><div class="line">height: xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="关于百分比设置下列属性"><a href="#关于百分比设置下列属性" class="headerlink" title="关于百分比设置下列属性"></a>关于百分比设置下列属性</h2><p>left（right）、width、padding、margin、background-position、text-index设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>的width值<br>top（bottom）、height设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>height值</p><h2 id="滚动容器底部留白"><a href="#滚动容器底部留白" class="headerlink" title="滚动容器底部留白"></a>滚动容器底部留白</h2><p>滚动容器底部留白使用 margin-bottom，使用 padding-bottom 存在兼容性问题。</p><h2 id="margin-合并（只存在垂直方向）"><a href="#margin-合并（只存在垂直方向）" class="headerlink" title="margin 合并（只存在垂直方向）"></a>margin 合并（只存在垂直方向）</h2><ol><li>相邻兄弟元素 margin 合并。</li><li>父级和第一个、父级和最后一个子元素。（虽然是在子元素上设置的 margin-top，但实际上就等同于在父元素上设置了 margin-top）</li><li>空块级元素的 margin 合并。</li></ol><p>PS：合并规则，正正取大值，正负值相加，负负最小值。</p><h2 id="margin-auto-的理解"><a href="#margin-auto-的理解" class="headerlink" title="margin: auto;的理解"></a>margin: auto;的理解</h2><p>margin: auto; 表示对剩余空白进行分配。<br>下面元素 .son 的 margin-left 为 300 - 200 -80 = 20px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-right: 80px;</div><div class="line">margin-left: auto; // 20px</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 margin 来进行 right 对齐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-left: auto; // 此时 auto 值为100px</div><div class="line">// flot: right; 等价</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：块级元素的左中右对齐使用 margin ，内联元素使用 text-align 控制左中右对戏。<br>水平和垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px; height:150px;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">position: absolute; // 很关键</div><div class="line">top: 0; right: 0; bottom: 0; left: 0;</div><div class="line">width: 200px; height: 100px;</div><div class="line">margin: auto; // 很关键</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="border-的一些秘密"><a href="#border-的一些秘密" class="headerlink" title="border 的一些秘密"></a>border 的一些秘密</h2><p>border-width 不支持百分比值（outline、box-shadow、text-shadow同样）<br>border-style:double 至少 3px 才有效果。<br>border-style:dashed 不同浏览器不一致（虚线颜色区的宽高比以及颜色区和透明区的宽度比例），如chrome上为方形ie为圆形。<br>thin（1px）、medium（默认值3px）、thick（4px）。</p><h2 id="border-技巧"><a href="#border-技巧" class="headerlink" title="border 技巧"></a>border 技巧</h2><p>等腰三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>直角三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>边框 3D 效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 10px; height: 10px;</div><div class="line">border: 10px solid;</div><div class="line">border-color: #f30 #00f #396 #0f0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="http://www.cnblogs.com/xiaohuochai/p/5457127.html" target="_blank" rel="external">等高布局</a></p><h2 id="css-度量单位-ex"><a href="#css-度量单位-ex" class="headerlink" title="css 度量单位 ex"></a>css 度量单位 ex</h2><p>相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。<br>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>作用：基于ex单位的天然垂直居中对齐效果</p><h2 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h2><p>行距 = line-height - font-size</p><h2 id="line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？"><a href="#line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？" class="headerlink" title="line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？"></a>line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？</h2><p>因为继承细节有所差别，如果使用数值作为 line-height 的属性值，那么所有的子元素继承的都是这个值（如1.5）；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值（16px*150%=24px，此时继承的就是24px这个值，不是150%）。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>作用：只能应用于内联元素以及 display 值为 table-cell 的元素。<br>定义：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。<br>线类，如 baseline（默认值）、top、middle、bottom；<br>文本类，如 text-top、text-bottom；<br>上标下标类，如 sub、super；<br>数值百分比类，如 20px、2em、20%等<br>PS：其实middle为基线往上 1/2 x-height 处（ x-height 为 x 的高度）</p><h2 id="消除图片下间隙"><a href="#消除图片下间隙" class="headerlink" title="消除图片下间隙"></a>消除图片下间隙</h2><ol><li>display:block;</li><li>vertical-align:top; // top，text-top，bottom，text-bottom 均可</li><li>font-size:0; // 父级设置</li><li>overflow:hidden;</li><li>float:left;</li></ol><p><a href="http://www.cnblogs.com/luojianqun/archive/2013/07/08/3177969.html" target="_blank" rel="external">CSS图片下面产生间隙的6种解决方案</a></p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>规范约定了浮动元素和内联元素在一行显示。<br>浮动元素会生成一个块级框，而不论它本身是何种元素。</p><h2 id="clip属性"><a href="#clip属性" class="headerlink" title="clip属性"></a>clip属性</h2><p>fixed 固定定位的剪裁<br>最佳可访问性隐藏（clip: rect(0,0,0,0)）</p><h2 id="stacking-context（层叠上下文）"><a href="#stacking-context（层叠上下文）" class="headerlink" title="stacking context（层叠上下文）"></a>stacking context（层叠上下文）</h2><p>层叠上下文，英文称作 stacking context，是 HTML 中的一个三维的概念。</p><h3 id="层叠水平（stacking-level-（逐渐升高）"><a href="#层叠水平（stacking-level-（逐渐升高）" class="headerlink" title="层叠水平（stacking level)（逐渐升高）"></a>层叠水平（stacking level)（逐渐升高）</h3><ol><li>层叠上下文（background/border） – 充当背景色</li><li>负的z-index</li><li>block块状水平盒子 – 布局</li><li>float浮动盒子</li><li>inline水平盒子（inline/inline-block/inline-table） – 内容</li><li>z-index:anto 或 看成 z-index:0</li><li>正的z-index</li></ol><p>一般情况都会满足满足上面的规则，详情可以看下面demo：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="pKverE" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/pKverE/" target="_blank" rel="external">stackingContext</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="external">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="如何触发一个元素形成堆叠上下文？"><a href="#如何触发一个元素形成堆叠上下文？" class="headerlink" title="如何触发一个元素形成堆叠上下文？"></a>如何触发一个元素形成堆叠上下文？</h3><ol><li>根元素 (HTML),</li><li>z-index 值不为 “auto”的 绝对/相对定位，</li><li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li><li>transform 属性值不为 “none”的元素，</li><li>mix-blend-mode 属性值不为 “normal”的元素，</li><li>filter值不为“none”的元素，</li><li>perspective值不为“none”的元素，</li><li>isolation 属性被设置为 “isolate”的元素，</li><li>position: fixed</li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li></ol><p>PS：使用了上述属性就会形成一个stacking context（堆叠上下文）。此时，要对两者进行层叠排列，就需要 z-index ，z-index 越高的层叠层级越高。<br>做了一个上述情况的demo：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="JZoWWp" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext2" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/JZoWWp/" target="_blank" rel="external">stackingContext2</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="external">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><a href="https://www.cnblogs.com/coco1s/p/5899089.html" target="_blank" rel="external">层叠顺序与堆栈上下文知多少</a></p><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。<br><a href="https://segmentfault.com/a/1190000014457824" target="_blank" rel="external">你应该知道的requestIdleCallback</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文所有知识点，点到即止，详细内容请看各部分的连接。&lt;/p&gt;
&lt;h2 id=&quot;点击穿透（多见于移动端模态框等浮层）&quot;&gt;&lt;a href=&quot;#点击穿透（多见于移动端模态框等浮层）&quot; class=&quot;headerlink&quot; title=&quot;点击穿透（多见于移动端模态框等浮层）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Web" scheme="https://fanerge.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>dom接口</title>
    <link href="https://fanerge.github.io/2018/dom%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://fanerge.github.io/2018/dom接口.html</id>
    <published>2018-05-08T12:43:18.000Z</published>
    <updated>2018-05-08T14:24:35.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CustomEvent"><a href="#CustomEvent" class="headerlink" title="CustomEvent"></a>CustomEvent</h1><p>创建一个自定义事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 添加一个适当的事件监听器</div><div class="line">obj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;)</div><div class="line"></div><div class="line">// 创建一个自定义事件</div><div class="line">var event = new CustomEvent(&quot;cat&quot;, &#123;&quot;detail&quot;:&#123;&quot;hazcheeseburger&quot;:true&#125;&#125;)</div><div class="line">// 分发事件</div><div class="line">obj.dispatchEvent(event)</div></pre></td></tr></table></figure></p><h1 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h1><p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。<br>DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。</p><h2 id="创建一个DocumentFragment"><a href="#创建一个DocumentFragment" class="headerlink" title="创建一个DocumentFragment"></a>创建一个DocumentFragment</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let ul = document.querySelector(`[data-uid=&quot;ul&quot;]`);</div><div class="line">let frag = document.createDocumentFragment();</div><div class="line">const list = [</div><div class="line">&apos;IE&apos;,</div><div class="line">&apos;Chrome&apos;</div><div class="line">];</div><div class="line">list.forEach(item =&gt; &#123;</div><div class="line">let li = document.creteElement(&apos;li&apos;);</div><div class="line">li.textContent = item;</div><div class="line">frag.appendChild(li);</div><div class="line">&#125;);</div><div class="line">// 只进行一次dom操作，触发一次reflow</div><div class="line">ul.appendChild(frag);</div><div class="line">```</div><div class="line">##其他方法（实例方法）</div></pre></td></tr></table></figure><p>documentFragment.find()<br>返回 DocumentFragment 树里第一个匹配的元素 Element 。<br>documentFragment.findAll()<br>返回 DocumentFragment 树里所有匹配的元素  NodeList。<br>documentFragment.querySelector()<br>documentFragment.querySelectorAll()<br>documentFragment.getElementById()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#MutationObserver</div><div class="line">给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</div><div class="line">##实例方法</div><div class="line">observe()</div><div class="line">给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.</div><div class="line">disconnect()</div><div class="line">让该观察者对象停止观察指定目标的DOM变化.即使再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.</div><div class="line">takeRecords()</div><div class="line">清空观察者对象的记录队列,并返回里面的内容.</div><div class="line">##示例</div></pre></td></tr></table></figure></p><p>let target = document.querySelector(‘#some-id’);</p><p>// 创建观察者对象<br>let observer = new MutationObserver(function(mutations) {<br>  mutations.forEach(function(mutation) {<br>    console.log(mutation.type);<br>  });<br>});</p><p>// 配置观察选项:<br>let config = { attributes: true, childList: true, characterData: true }</p><p>// 传入目标节点和观察选项<br>observer.observe(target, config);</p><p>// 随后,你还可以停止观察<br>observer.disconnect();<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CustomEvent&quot;&gt;&lt;a href=&quot;#CustomEvent&quot; class=&quot;headerlink&quot; title=&quot;CustomEvent&quot;&gt;&lt;/a&gt;CustomEvent&lt;/h1&gt;&lt;p&gt;创建一个自定义事件。&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>git工具书</title>
    <link href="https://fanerge.github.io/2018/git%E5%B7%A5%E5%85%B7%E4%B9%A6.html"/>
    <id>https://fanerge.github.io/2018/git工具书.html</id>
    <published>2018-04-23T14:41:30.000Z</published>
    <updated>2018-05-09T12:18:24.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%86.png" alt="git原理"><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">图片来源</a><br>PS：<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="git托管项目（新建-or-clone一个git项目）"><a href="#git托管项目（新建-or-clone一个git项目）" class="headerlink" title="git托管项目（新建 or clone一个git项目）"></a>git托管项目（新建 or clone一个git项目）</h2><p>mkdir gitdemo // 在当前目录创建gitdemo目录<br>cd gitdemo<br>pwd // 显示当前目录<br>git init // 将当前目录设置为git管理的仓库<br>git init [projectName] // 新建一个目录，将其初始化为Git代码库<br>or<br>git clone [ssh/https]</p><h2 id="工作区-gt-gt-暂存区（add为添加文件rm为移除文件）"><a href="#工作区-gt-gt-暂存区（add为添加文件rm为移除文件）" class="headerlink" title="工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）"></a>工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）</h2><p>git add [fileName] // 单个或多个文件<br>git add *.js // 通配符<br>git add -u  // 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .  // 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件<br>git add -A  // 提交所有变化（是git add .和git add -u的结合，git add -all的简写</p><p>git rm [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区<br>git rm --cached [fileName] // 停止追踪指定文件，但该文件会保留在工作区<br>git mv [fileNameOld] [fileNameNew] // 改名文件，并且将这个改名放入暂存区</p><h2 id="暂存区-gt-gt-本地仓库"><a href="#暂存区-gt-gt-本地仓库" class="headerlink" title="暂存区&gt;&gt;本地仓库"></a>暂存区&gt;&gt;本地仓库</h2><p>git commit -m ‘说明信息’ // 提交<br>git commit -am ‘说明’ // git add . 和 git commit的简写（一次完成两个动作）<br>常用commit type</p><ul><li>feat: 新功能</li><li>fix: 修复问题</li><li>docs: 修改文档</li><li>style: 修改代码格式，不影响代码逻辑</li><li>refactor: 重构代码，理论上不影响现有功能</li><li>perf: 提升性能</li><li>test: 增加修改测试用例</li><li>chore: 修改工具相关（包括但不限于文档、代码生成等）</li></ul><h2 id="本地仓库-gt-gt-远程仓库"><a href="#本地仓库-gt-gt-远程仓库" class="headerlink" title="本地仓库&gt;&gt;远程仓库"></a>本地仓库&gt;&gt;远程仓库</h2><p>git push ssh://git@dev.fanerge.com/gitdemo.git master // 把本地仓库提交到远程仓库的master分支中<br>git push -u origin master // 当前分支提交到远程 master 分支<br>git push // 如果当前分支与远程分支存在追踪关系</p><h2 id="远程仓库-gt-gt-本地仓库"><a href="#远程仓库-gt-gt-本地仓库" class="headerlink" title="远程仓库&gt;&gt;本地仓库"></a>远程仓库&gt;&gt;本地仓库</h2><p>git fetch [远程主机名] [分支名] // 远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地<br>git fetch origin master<br>git clone [ssh/https]// 从远程主机克隆一个版本库<br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">更详细的资料</a></p><h2 id="远程仓库-gt-gt-工作区"><a href="#远程仓库-gt-gt-工作区" class="headerlink" title="远程仓库&gt;&gt;工作区"></a>远程仓库&gt;&gt;工作区</h2><p>git pull [远程主机名] [远程分支名]:[本地分支名] // 远程主机某个分支的更新，再与本地的指定分支合并<br>git pull // 当前分支只有一个追踪分支时可省略部分参数</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>git branch // 查看本地所有分支（*表示当前分支）<br>git branch -v // 查看本地所有分支及最近一次提交信息<br>git branch -vv // 查看本地所有分支及最近一次提交信息和远程追踪分支<br>git branch -r // 查看远程所有分支<br>git branch -a // 查看本地/远程所有分支</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout [branchName] // 切换分支<br>git checkout - // 切换到上一个分支</p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>git branch [branchName] // 新建一个分支（但仍然留在当前分支）<br>git checkout -b [branchName] // 新建一个分支（并切换到该分支）<br>git branch [branchName] [commitId] // 新建一个分支（并指向指定的commitId）<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>如：新建 test 分支，并指向远程的 orign/dev 分支<br>git branch --track test origin/dev</p><h2 id="新建远程分支（新建本地分支，推送的远程作为远程分支）"><a href="#新建远程分支（新建本地分支，推送的远程作为远程分支）" class="headerlink" title="新建远程分支（新建本地分支，推送的远程作为远程分支）"></a>新建远程分支（新建本地分支，推送的远程作为远程分支）</h2><p>git branch [branchName]<br>git push origin [branchName]:[remoteBranchName]<br>还需要为新建本地分支和远程分支建立追踪关系<br>如：本地的 test 分支作为远程的 dev 分支<br>git push origin test:dev</p><h2 id="建立追踪关系（当前分支和远程分支）"><a href="#建立追踪关系（当前分支和远程分支）" class="headerlink" title="建立追踪关系（当前分支和远程分支）"></a>建立追踪关系（当前分支和远程分支）</h2><p>作用：用来描述当前和远程分支的位置关系，在使用git pull 和 git push 的时候可以省略远程参数<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>git branch –-set-upstream-to=origin/[branchName]<br>如：当前分支和远程 dev 分支建立追踪关系<br>git branch –-set-upstream-to=origin/dev</p><h2 id="合并分支（branchName合并到当前分支）"><a href="#合并分支（branchName合并到当前分支）" class="headerlink" title="合并分支（branchName合并到当前分支）"></a>合并分支（branchName合并到当前分支）</h2><p>git merge [branchName]<br>git rebase [branchName]<br>PS：<br>git merge dev（当前分支为master）<br>会在 master 分支产生一个新的commit。<br>git rebase dev（当前分支为master）<br>会将master上的提交推至顶端。</p><h2 id="删除分支（本地）"><a href="#删除分支（本地）" class="headerlink" title="删除分支（本地）"></a>删除分支（本地）</h2><p>git branch -d [branchName] // 删除分支（本地）<br>git push origin --delete [branchName] // 删除分支（远程）<br>git branch -dr [remoteBranchName] // 删除分支（远程）</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>tag作用类似于里程碑，可以快速找到里程碑的代码。</p><h2 id="查看所有tag"><a href="#查看所有tag" class="headerlink" title="查看所有tag"></a>查看所有tag</h2><p>git tag</p><h2 id="新建tag在当前commit"><a href="#新建tag在当前commit" class="headerlink" title="新建tag在当前commit"></a>新建tag在当前commit</h2><p>git tag [tagName]</p><h2 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h2><p>git tag [tagName] [commitId]</p><h2 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h2><p>git tag -d [tagName]</p><h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><p>git push origin :refs/tags/[tagName]</p><h2 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h2><p>git show [tagName]</p><h2 id="向远程提交指定tag"><a href="#向远程提交指定tag" class="headerlink" title="向远程提交指定tag"></a>向远程提交指定tag</h2><p>git push [remoteBranchName] [tagName]</p><h2 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h2><p>git checkout -b [branchName] [tagName]</p><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><h2 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h2><p>git status</p><h2 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h2><p>git log</p><h2 id="显示当前分支的版本历史（包括commit发生变更的文件）"><a href="#显示当前分支的版本历史（包括commit发生变更的文件）" class="headerlink" title="显示当前分支的版本历史（包括commit发生变更的文件）"></a>显示当前分支的版本历史（包括commit发生变更的文件）</h2><p>git log –stat</p><h2 id="显示当前分支的版本历史（通过关键词）"><a href="#显示当前分支的版本历史（通过关键词）" class="headerlink" title="显示当前分支的版本历史（通过关键词）"></a>显示当前分支的版本历史（通过关键词）</h2><p>git log -S [keyword]</p><h2 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h2><p>git log [tagName] HEAD –pretty=format:%s</p><h2 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h2><p>git log [tagName] HEAD –grep feature</p><h2 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h2><p>git log –follow [fileName]<br>git whatchanged [fileName]</p><h2 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h2><p>git log -p [fileName]</p><h2 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h2><p>git log -5 –pretty –oneline</p><h2 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h2><p>git shortlog -sn</p><h2 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h2><p>git blame [file]</p><h2 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h2><p>git biff</p><h2 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h2><p>git diff –cached [fileName]</p><h2 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h2><p>git diff HEAD</p><h2 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h2><p>git diff [first-branch]…[second-branch]</p><h2 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h2><p>git diff –shortstat “@{0 day ago}”</p><h2 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h2><p>git show [commitId]</p><h2 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h2><p>git show –name-only [commitId]</p><h2 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h2><p>git show [commitId]:[fileName]</p><h2 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h2><p>git reflog</p><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h2><p>git fetch [ssh/https]</p><h2 id="显示所有远程仓库（包括fetch和push地址）"><a href="#显示所有远程仓库（包括fetch和push地址）" class="headerlink" title="显示所有远程仓库（包括fetch和push地址）"></a>显示所有远程仓库（包括fetch和push地址）</h2><p>git remote -v</p><h2 id="显示某一远程仓库的信息"><a href="#显示某一远程仓库的信息" class="headerlink" title="显示某一远程仓库的信息"></a>显示某一远程仓库的信息</h2><p>git remote show [remoteRepositoryName]</p><h2 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h2><p>git remote add [shortname] [url]</p><h2 id="取回远程仓库的变化，并与本地分支合并（merge）"><a href="#取回远程仓库的变化，并与本地分支合并（merge）" class="headerlink" title="取回远程仓库的变化，并与本地分支合并（merge）"></a>取回远程仓库的变化，并与本地分支合并（merge）</h2><p>git pull [remote] [remoteBranchName]<br>PS：remote 一般为 origin ，当建立追踪关系，可以git pull 省略两个参数</p><h2 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h2><p>git push [remote] [branchName]</p><h2 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h2><p>git push [remote] –force</p><h2 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h2><p>git push [remote] –all</p><h1 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销/恢复"></a>撤销/恢复</h1><h2 id="撤销工作区修改（指定文件）"><a href="#撤销工作区修改（指定文件）" class="headerlink" title="撤销工作区修改（指定文件）"></a>撤销工作区修改（指定文件）</h2><p>git chekout – [fileName]</p><h2 id="撤销工作区（所有文件）"><a href="#撤销工作区（所有文件）" class="headerlink" title="撤销工作区（所有文件）"></a>撤销工作区（所有文件）</h2><p>git checkout – .</p><h2 id="暂存区–-gt-工作区（指定文件）"><a href="#暂存区–-gt-工作区（指定文件）" class="headerlink" title="暂存区–&gt;工作区（指定文件）"></a>暂存区–&gt;工作区（指定文件）</h2><p>git reset HEAD [fileName] // 撤销暂存区的修改<br>git checkout [fileName] // 撤销工作区的修改</p><h2 id="重置暂存区到上次提交commit（工作区不变）"><a href="#重置暂存区到上次提交commit（工作区不变）" class="headerlink" title="重置暂存区到上次提交commit（工作区不变）"></a>重置暂存区到上次提交commit（工作区不变）</h2><p>git reset [fileName]</p><h2 id="重置暂存区、工作区到上次提交commit"><a href="#重置暂存区、工作区到上次提交commit" class="headerlink" title="重置暂存区、工作区到上次提交commit"></a>重置暂存区、工作区到上次提交commit</h2><p>git reset –hard<br>git reset HEAD^ –hard // 回到上一次commit<br>git reset HEAD^^ –hard // 回到上一次的上一次commit</p><h2 id="重置暂存区、当前分支指定commitId（工作区不变）"><a href="#重置暂存区、当前分支指定commitId（工作区不变）" class="headerlink" title="重置暂存区、当前分支指定commitId（工作区不变）"></a>重置暂存区、当前分支指定commitId（工作区不变）</h2><p>git reset [commitId]</p><h2 id="重置暂存区、工作区、当前分支为指定commitId"><a href="#重置暂存区、工作区、当前分支为指定commitId" class="headerlink" title="重置暂存区、工作区、当前分支为指定commitId"></a>重置暂存区、工作区、当前分支为指定commitId</h2><p>git reset –hard [commitId]</p><h2 id="重置当前HEAD为指定commitId（暂存区、工作区不表）"><a href="#重置当前HEAD为指定commitId（暂存区、工作区不表）" class="headerlink" title="重置当前HEAD为指定commitId（暂存区、工作区不表）"></a>重置当前HEAD为指定commitId（暂存区、工作区不表）</h2><p>git reset –keep [commitId]</p><h2 id="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"><a href="#新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）" class="headerlink" title="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"></a>新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）</h2><p>git revert [commitId]</p><h2 id="暂时将未提交的变化存于stash，后续再从stash中取出"><a href="#暂时将未提交的变化存于stash，后续再从stash中取出" class="headerlink" title="暂时将未提交的变化存于stash，后续再从stash中取出"></a>暂时将未提交的变化存于stash，后续再从stash中取出</h2><p>git stash list // 查看 stash 列表<br>git stash // 保存当前暂未提交的修改<br>git stash apply // 从stash中恢复，但不清除该stash<br>git stash drop  // 清除该stash<br>git stash pop // 从stash中恢复并清除该stash<br>PS：一般用于停下手中活，处理更加紧急的任务，处理完任务后在回过头继续。<br>git stash pop = git stash apply + git stash drop</p><blockquote><p>   参考文档：<br><a href="https://git-scm.com/" target="_blank" rel="external">git 官网</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="external">Git教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%
      
    
    </summary>
    
      <category term="代码管理" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://fanerge.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>js算法集合</title>
    <link href="https://fanerge.github.io/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html"/>
    <id>https://fanerge.github.io/2018/js算法集合.html</id>
    <published>2018-04-08T14:20:17.000Z</published>
    <updated>2018-04-25T14:04:52.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断文本是否为回文"><a href="#判断文本是否为回文" class="headerlink" title="判断文本是否为回文"></a>判断文本是否为回文</h1><p>定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。</p><h2 id="方法一（字符串、数组内置方法）"><a href="#方法一（字符串、数组内置方法）" class="headerlink" title="方法一（字符串、数组内置方法）"></a>方法一（字符串、数组内置方法）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome1(val)&#123;</div><div class="line">// 允许输入字符串和数字和布尔值</div><div class="line">if (typeof val !== &apos;string&apos;) val = val.toString();</div><div class="line">let newVal = val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line"></div><div class="line">return val === newVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome1(121) // true</div><div class="line">isPalindrome1(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>// PS：方法简单，但效率不高，会产生一个新的变量</p><h2 id="方法二（循环）"><a href="#方法二（循环）" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome2(val)&#123;</div><div class="line">val = val + &apos;&apos;; // 非字符串转化为字符串</div><div class="line"></div><div class="line">// 这里为什么 i &lt;= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！</div><div class="line">for(let i = 0, j = val.length - 1; i &lt; j; i++, j--)&#123;</div><div class="line">if(val.charAt(i) !== val.charAt(j))&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome2(121) // true</div><div class="line">isPalindrome2(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>PS：网上还有其他解法，大多为以上两种的变形。</p><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="方法一（字符串、数组内置方法））"><a href="#方法一（字符串、数组内置方法））" class="headerlink" title="方法一（字符串、数组内置方法））"></a>方法一（字符串、数组内置方法））</h2><p>借用反转字符串的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal1(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">return val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法二（循环）-1"><a href="#方法二（循环）-1" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><p>循环系列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal2(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">i = 0,</div><div class="line">len = val.length;</div><div class="line">while(i &lt; len)&#123;</div><div class="line">str += val.charAt(len - 1 - i);</div><div class="line">i++; </div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal3(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">len = val.length;</div><div class="line">for(let i = len - 1; i &gt;= 0; i--)&#123;</div><div class="line">str += val.charAt(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：reverseVal(‘abc’) // ‘cba’</p><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="方法一（递归）"><a href="#方法一（递归）" class="headerlink" title="方法一（递归）"></a>方法一（递归）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize1(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line"></div><div class="line">// 建议不要使用 arguments.callee，目前已经废弃了。</div><div class="line">return n * factorialize1(n - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</p><h2 id="方法二（ES6尾调用优化）"><a href="#方法二（ES6尾调用优化）" class="headerlink" title="方法二（ES6尾调用优化）"></a>方法二（ES6尾调用优化）</h2><p>（递归优化版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize2(n, total = 1)&#123;</div><div class="line">if(typeof n !== &apos;number&apos; || typeof total !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return total;</div><div class="line"></div><div class="line">return factorialize2(n - 1, n * total)</div><div class="line">// f(3) =&gt; f(2, 3 * 2) =&gt; f(1, 6) =&gt; 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="external">ES6尾调用优化</a>但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><h2 id="方法三（循环）"><a href="#方法三（循环）" class="headerlink" title="方法三（循环）"></a>方法三（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize3(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line">let total = 1;</div><div class="line"></div><div class="line">while(n&gt;1)&#123;</div><div class="line">total = n * total;</div><div class="line">n--;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：factorialize1(3) // 6</p><h1 id="随机生成长度为n字符串"><a href="#随机生成长度为n字符串" class="headerlink" title="随机生成长度为n字符串"></a>随机生成长度为n字符串</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString1(n)&#123;</div><div class="line">let str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;</div><div class="line">let tem = &apos;&apos;,</div><div class="line">i = 0;</div><div class="line"></div><div class="line">// Math.random 函数产生值的范围[0,1)</div><div class="line">while(i&lt;n)&#123;</div><div class="line">tem += str.charAt(Math.floor(Math.random() * str.length))</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：Math.round(Math.random() <em> (str.length - 1))<br>Math.ceil(Math.random() </em> (str.length - 1))<br>Math.floor(Math.random() * str.length)<br>这三种方式等价，都能生成[0, str.length-1]随机数</p><h2 id="方法二（进制转化）"><a href="#方法二（进制转化）" class="headerlink" title="方法二（进制转化）"></a>方法二（进制转化）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString2(n)&#123;</div><div class="line">return Math.random().toString(36).substr(2).slice(0, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法原理为随机产生的数转换为指定进制字符串<br>toString(n)，n为[2,36]，n&lt;=10时只产生0-9也就是10进制数字<br>该方法有个缺点，产生字符串的长度有一定的限制。</p><h2 id="方法三（随机码点）"><a href="#方法三（随机码点）" class="headerlink" title="方法三（随机码点）"></a>方法三（随机码点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString3(n)&#123;</div><div class="line">let str = &apos;&apos;;</div><div class="line"></div><div class="line">function randomChar()&#123;</div><div class="line">let l = Math.floor(Math.random() * 62);</div><div class="line">if(l &lt; 10) return l; // 数字部分 0-9</div><div class="line">if(l &lt; 36) return String.fromCharCode(l + 55); // 大写字母</div><div class="line"></div><div class="line">return String.fromCharCode(l + 61); // 小写字母</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(str.length &lt; n) str += randomChar();</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以参考对于的<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="external">ASCII码表</a>。<br>测试：randomString1(3) // ‘1sd’</p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="方法一（ES6的Set数据结构）"><a href="#方法一（ES6的Set数据结构）" class="headerlink" title="方法一（ES6的Set数据结构）"></a>方法一（ES6的Set数据结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique1(ary)&#123;</div><div class="line">return [...new Set(ary)];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法二（对象的key唯一性）"><a href="#方法二（对象的key唯一性）" class="headerlink" title="方法二（对象的key唯一性）"></a>方法二（对象的key唯一性）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique2(ary)&#123;</div><div class="line">let obj = &#123;&#125;,</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(!obj[ary[i]])&#123;</div><div class="line">obj[ary[i]] = true; // 如果不存在</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">return Object.keys(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串。<br>会把数字1和字符串’1’，会被视为同一个值。</p><h2 id="方法三（临时数组判断插入）"><a href="#方法三（临时数组判断插入）" class="headerlink" title="方法三（临时数组判断插入）"></a>方法三（临时数组判断插入）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique3(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">// tem.indexOf() === -1 同理</div><div class="line">!tem.includes(ary[i]) ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法四（判断首次出现的位置）"><a href="#方法四（判断首次出现的位置）" class="headerlink" title="方法四（判断首次出现的位置）"></a>方法四（判断首次出现的位置）</h2><p>如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique4(ary)&#123;</div><div class="line">let tem = [ary[0]],</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">for(let i = 1; i &lt; len; i++ )&#123;</div><div class="line">// 核心，首次的索引出现是否为当前的索引</div><div class="line">if(ary.indexOf(ary[i]) === i) tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法五（排序后逐个比较插入）"><a href="#方法五（排序后逐个比较插入）" class="headerlink" title="方法五（排序后逐个比较插入）"></a>方法五（排序后逐个比较插入）</h2><p>给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; array 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique5(array)&#123;</div><div class="line">let ary = array.slice();</div><div class="line">ary.sort();</div><div class="line">let tem = [ary[0]];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">ary[i] !== tem[tem.length - 1] ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：返回的数组顺序发生了改变。</p><h2 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h2><p>获取没有重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique6(ary)&#123;</div><div class="line">let tem = [];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">for(let j = i + 1; j &lt; len; j++)&#123;</div><div class="line">if(ary[i] === ary[j]) j = ++i;</div><div class="line">&#125;</div><div class="line">tem.push(ary[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：unique1([1, 2, 3, 2]) // [1, 2, 3]</p><h1 id="出现次数最多的字符"><a href="#出现次数最多的字符" class="headerlink" title="出现次数最多的字符"></a>出现次数最多的字符</h1><h2 id="方法一（对象key的唯一性进行累加）"><a href="#方法一（对象key的唯一性进行累加）" class="headerlink" title="方法一（对象key的唯一性进行累加）"></a>方法一（对象key的唯一性进行累加）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function maxNum1(str)&#123;</div><div class="line">if(typeof(str) !== &apos;string&apos;) str = str.toString();</div><div class="line">let obj = &#123;&#125;,</div><div class="line">maxChar = []; // 使用数组保存出现最多次的某些字符</div><div class="line">str.split(&apos;&apos;).forEach( (val) =&gt; &#123;</div><div class="line">if(!obj[val])&#123;</div><div class="line">let demo = obj[val] = 1;</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line">obj[val]++;</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">let maxCount =  Math.max.apply(null, Object.values(obj))</div><div class="line"></div><div class="line">// forEach方法总是返回 undefined 且 没有办法中止或者跳出 forEach 循环。</div><div class="line">Object.entries(obj).forEach( item =&gt; &#123;</div><div class="line">if(item[1] == maxCount)&#123;</div><div class="line">maxChar.push(item[0])</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return maxChar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：maxNum1(‘11223333’) // ‘3’</p><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>实现方法：Array.prototype.flatten(depth)，参数depth表示需要扁平化的层数，返回一个新的数组。 </p><h2 id="方法一（递归遍历数组拼接）"><a href="#方法一（递归遍历数组拼接）" class="headerlink" title="方法一（递归遍历数组拼接）"></a>方法一（递归遍历数组拼接）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function flatten1(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(Array.isArray(ary[i]))&#123;</div><div class="line">// 递归进行上面步骤</div><div class="line">// [].concat(...ary)，它的参数可以为数组或值，作用为将数组或值连接成新数组。</div><div class="line">tem = tem.concat(flatten1(ary[i]))</div><div class="line">&#125;else&#123;</div><div class="line">tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法二（reduce结合concat）"><a href="#方法二（reduce结合concat）" class="headerlink" title="方法二（reduce结合concat）"></a>方法二（reduce结合concat）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.reduce((pre, cur) =&gt; &#123;</div><div class="line">return pre.concat(Array.isArray(cur) ? flatten2(cur) : cur)</div><div class="line">&#125;, [])</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法三（转化为字符串）"><a href="#方法三（转化为字符串）" class="headerlink" title="方法三（转化为字符串）"></a>方法三（转化为字符串）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.toString().split(&apos;,&apos;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：返回的数组项将为字符串。</p><h2 id="方法四（解构数组）"><a href="#方法四（解构数组）" class="headerlink" title="方法四（解构数组）"></a>方法四（解构数组）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function flatten4(ary)&#123;</div><div class="line"></div><div class="line">let tem = []</div><div class="line">ary.forEach(item =&gt; &#123;</div><div class="line">if(Array.isArray(item))&#123;</div><div class="line">tem = tem.concat(...item);</div><div class="line">&#125;else&#123;</div><div class="line">tem = tem.concat(item);</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：只能处理2维数组。<br>测试：getMaxProfit1([1, 2, 3, [4, 5, 6]]) // [1, 2, 3, 4, 5, 6]</p><h1 id="数组中最大差值"><a href="#数组中最大差值" class="headerlink" title="数组中最大差值"></a>数组中最大差值</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getMaxProfit1(ary)&#123;</div><div class="line">return Math.max.apply(null, ary) - Math.min.apply(null, ary);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：getMaxProfit1([1, 2, 3, 4]) // 3 </p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>这里我们只实现通项公式</p><h2 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fib1(n)&#123;</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return fib1(n - 1) + fib1(n - 2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(2^n)，空间复杂度为O(n)</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let tem = [1, 1];</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 数组索引从0开始，数列索引从1开始</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">tem[i] = tem[i-1] + tem[i-2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem[n-1];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(n)</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let prev = 1, </div><div class="line">next = 1,</div><div class="line">res;</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">res = prev + next;  </div><div class="line">prev = next; </div><div class="line">next = res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(1)<br>测试：fib2(3) // 2 </p><h1 id="判断是否为质数（prime-number）素数"><a href="#判断是否为质数（prime-number）素数" class="headerlink" title="判断是否为质数（prime number）素数"></a>判断是否为质数（prime number）素数</h1><p>质数：只能被1和自己整除且大于1的数。<br>合数：数大于1且因数多余2个（大于1的数质数的补集）。</p><h2 id="方法一（循环）"><a href="#方法一（循环）" class="headerlink" title="方法一（循环）"></a>方法一（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">if(n &lt; 2) return false;</div><div class="line">if(n === 2) return true; // 最小的质数</div><div class="line"></div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">if(n % i === 0)&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：isPrimeNumber1(2) // true</p><h2 id="方法二（正则）"><a href="#方法二（正则）" class="headerlink" title="方法二（正则）"></a>方法二（正则）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">  return n&lt;2?false:!/^(11+?)\1+$/.test(Array(n+1).join(&apos;1&apos;))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法很巧妙，于2018-04-25在掘金上发现。<br><a href="https://juejin.im/post/5adeb462f265da0b9c104358" target="_blank" rel="external">方法详解</a></p><h1 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function greatestCommonDivisor1(a, b)&#123;</div><div class="line">if(a &lt; 0 || b &lt; 0) throw new Error(&apos;参数只能为正整数&apos;);</div><div class="line">if(a &lt; 2 || b &lt; 2) return 1;</div><div class="line">let min = a,</div><div class="line">max = b,</div><div class="line">arymin = [];</div><div class="line"></div><div class="line">if(a &gt; b) &#123;</div><div class="line">min = b;</div><div class="line">max = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(let i = 1; i &lt;= min; i++)&#123;</div><div class="line">if(min % i === 0)&#123;</div><div class="line">arymin.push(i);</div><div class="line">console.log(1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">arymin.reverse();</div><div class="line"></div><div class="line">for(let j = 0, len = arymin.length; j &lt; len; j++)&#123;</div><div class="line">if(max % arymin[j] === 0)&#123;</div><div class="line">return arymin[j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：greatestCommonDivisor1(5, 10) // 5</p><h1 id="金额转大写"><a href="#金额转大写" class="headerlink" title="金额转大写"></a>金额转大写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function money2Chinese(num) &#123;</div><div class="line">  if(typeof num) throw new Error(&apos;参数为数字&apos;)</div><div class="line">  let strOutput = &quot;&quot;</div><div class="line">  let strUnit = &apos;仟佰拾亿仟佰拾万仟佰拾元角分&apos;</div><div class="line">  num += &quot;00&quot;</div><div class="line">  const intPos = num.indexOf(&apos;.&apos;)</div><div class="line">  if (intPos &gt;= 0) &#123;</div><div class="line">    num = num.substring(0, intPos) + num.substr(intPos + 1, 2)</div><div class="line">  &#125;</div><div class="line">  strUnit = strUnit.substr(strUnit.length - num.length)</div><div class="line">  for (let i = 0; i &lt; num.length; i++) &#123;</div><div class="line">    strOutput += &apos;零壹贰叁肆伍陆柒捌玖&apos;.substr(num.substr(i, 1), 1) + strUnit.substr(i, 1)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  return strOutput.replace(/零角零分$/, &apos;整&apos;).replace(/零[仟佰拾]/g, &apos;零&apos;).replace(/零&#123;2,&#125;/g, &apos;零&apos;).replace(/零([亿|万])/g, &apos;$1&apos;).replace(/零+元/, &apos;元&apos;).replace(/亿零&#123;0,3&#125;万/, &apos;亿&apos;).replace(/^元/, &quot;零元&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：money2Chinese(1234) // 壹仟贰佰叁拾肆元整</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断文本是否为回文&quot;&gt;&lt;a href=&quot;#判断文本是否为回文&quot; class=&quot;headerlink&quot; title=&quot;判断文本是否为回文&quot;&gt;&lt;/a&gt;判断文本是否为回文&lt;/h1&gt;&lt;p&gt;定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我所了解的CSS包含块</title>
    <link href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://fanerge.github.io/2018/一次详细的包含块学习.html</id>
    <published>2018-03-29T11:53:04.000Z</published>
    <updated>2018-05-27T03:00:44.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指出错误观念"><a href="#指出错误观念" class="headerlink" title="指出错误观念"></a>指出错误观念</h1><p>许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！<br>一个元素的尺寸和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。<br>下面我们看看盒模型：<br>当浏览器展示一个文档的时候，对于每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域：</p><ol><li>内容区</li><li>内边距区</li><li>边框区</li><li>外边距区<br><img src="http://p677fntmi.bkt.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></li></ol><h1 id="什么是包含块？"><a href="#什么是包含块？" class="headerlink" title="什么是包含块？"></a>什么是包含块？</h1><p>包含块有分为根元素包含块和其他元素的包含块。</p><h2 id="根元素包含块"><a href="#根元素包含块" class="headerlink" title="根元素包含块"></a>根元素包含块</h2><p>根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。<br>可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。<br>对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。</p><h2 id="其他元素的包含块"><a href="#其他元素的包含块" class="headerlink" title="其他元素的包含块"></a>其他元素的包含块</h2><p>大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样，下面就来学习如何确定这些元素的包含块。</p><h1 id="如何确定元素的包含块？"><a href="#如何确定元素的包含块？" class="headerlink" title="如何确定元素的包含块？"></a>如何确定元素的包含块？</h1><p>确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景：</p><ol><li>如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）或格式化上下文<a href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#BFC">BFC</a>(比如说 a table container, flex container, grid container, or the block container itself)的<span style="color: red">内容区的边缘</span>组成的。</li><li>如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的<span style="color: red">内边距区的边缘</span>组成的。</li><li>如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in  the case of paged media) 组成的。</li><li>如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的<span style="color: red">内边距区的边缘</span>组成的：<br>A transform or perspective value other than none<br>A will-change value of transform or perspective<br>A filter value other than none or a will-change value of filter (only works on Firefox).</li></ol><h1 id="元素包含块的作用？"><a href="#元素包含块的作用？" class="headerlink" title="元素包含块的作用？"></a>元素包含块的作用？</h1><p>元素的尺寸和位置经常受其包含块的影响。对于一个绝对定位的元素来说（他的 position 属性被设定为 absolute 或 fixed），如果它的 width, height, padding, margin, 和 offset 这些属性的值是一个比例值（如百分比等）的话，那这些值的计算值就是由它的包含块计算而来的。<br>简单来说，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</p><ol><li>height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。</li><li>width, left, right, padding, margin, text-indent(2018-05-27修改)这些属性由包含块的 width 属性的值来计算它的百分值。</li></ol><h1 id="下面看些例子"><a href="#下面看些例子" class="headerlink" title="下面看些例子"></a>下面看些例子</h1><p>下面示例公用HTML代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;section&gt;</div><div class="line">    &lt;p&gt;This is a paragraph!&lt;/p&gt;</div><div class="line">  &lt;/section&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: block;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;   /* == 400px * .5 = 200px */</div><div class="line">  height: 25%;  /* == 160px * .25 = 40px */</div><div class="line">  margin: 5%;   /* == 400px * .05 = 20px */</div><div class="line">  padding: 5%;  /* == 400px * .05 = 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk1.png" alt=""></p><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: inline;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;     /* == half the body&apos;s width */</div><div class="line">  height: 200px;  /* Note: a percentage would be 0 */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk2.png" alt=""></p><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  transform: rotate(0deg);</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 80px;</div><div class="line">  top: 30px;</div><div class="line">  width: 50%;   /* == 200px */</div><div class="line">  height: 25%;  /* == 40px */</div><div class="line">  margin: 5%;   /* == 20px */</div><div class="line">  padding: 5%;  /* == 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk3.png" alt=""></p><h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 30px;</div><div class="line">  top: 30px;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  padding: 30px 20px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  width: 50%;   /* == (400px + 20px + 20px) * .5 = 220px */</div><div class="line">  height: 25%;  /* == (160px + 30px + 30px) * .25 = 55px */</div><div class="line">  margin: 5%;   /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  padding: 5%;  /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk4.png" alt=""></p><h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  width: 300px;</div><div class="line">  height: 300px;</div><div class="line">  margin: 30px;</div><div class="line">  padding: 15px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: fixed;</div><div class="line">  width: 50%;   /* == (50vw - (width of vertical scrollbar)) */</div><div class="line">  height: 50%;  /* == (50vh - (height of horizontal scrollbar)) */</div><div class="line">  margin: 5%;   /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  padding: 5%;  /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk5.png" alt=""></p><p>如果本文对你有帮助，记得给我的博客项目<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="external">star</a>(⊙﹏⊙)，<a href="https://fanerge.github.io">顺便找找成都氛围好的前端团队，也许我就是你们要找的の</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指出错误观念&quot;&gt;&lt;a href=&quot;#指出错误观念&quot; class=&quot;headerlink&quot; title=&quot;指出错误观念&quot;&gt;&lt;/a&gt;指出错误观念&lt;/h1&gt;&lt;p&gt;许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！&lt;br&gt;一个元素的尺
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>全面了解Object对象</title>
    <link href="https://fanerge.github.io/2018/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Object%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://fanerge.github.io/2018/全面了解Object对象.html</id>
    <published>2018-03-20T12:36:46.000Z</published>
    <updated>2018-03-21T12:13:35.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么一切皆为对象"><a href="#为什么一切皆为对象" class="headerlink" title="为什么一切皆为对象"></a>为什么一切皆为对象</h1><p>‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一探究竟吧？<br>为了解决这个问题，我们的从javascript的原型链说起。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在js几乎任何对象有一个 [[prototype]] 属性，在标准中，这是一个隐藏属性。<br>虽然说 [[prototype]] 是一个隐藏属性，但很多浏览器都给每一个对象提供 __proto__ 这一属性，这个属性就是该对象的[[prototype]]。</p><blockquote><p>   Object.prototype 的 __proto__  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部 [[Prototype]] (一个对象或 null)。<br>使用 __proto__ 是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__ 属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 赞成Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf 来获取或设置对象的原型链。</p></blockquote><p>下面我们用标准的方法来获取对象的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 基本数据类型（Number,String,Boolean,Symbol）</div><div class="line">let str = &apos;strstr&apos;;</div><div class="line">// 1</div><div class="line">Object.getPrototypeOf(str) // String对象（这里包括字符串原型链上的所有方法如slice、indexOf等）</div><div class="line">// 2</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(str)) // Object对象</div><div class="line">// 3</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(str))) // null</div><div class="line">console.dir(Object.getPrototypeOf(str))</div><div class="line"></div><div class="line">// 其他类型（Object,Function,Array,Error,Math,Date,Map,Set,WeakMap,WeakSet,JSON）</div><div class="line">function demo() &#123;&#125;</div><div class="line">// 4</div><div class="line">Object.getPrototypeOf(demo) // anonymous函数</div><div class="line">// 5</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(demo)) // Object对象</div><div class="line">// 6</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(demo))) // null</div></pre></td></tr></table></figure></p><p>PS：博主分别以基本数据类型Number,String,Boolean,Symbol（这里不考虑undefined和null，因为它们是特殊的两个值，木有原型）做了测试，上面代码注释1,2,3最终到达原型链的顶端null。<br>对于其他类型也是同样的，通过4,5,6到达原型链顶端Object.prototype === null。<br>从上面可以整个javascript语法系统都是基于这个原型链来实现方法和属性的继承的，并且可以看到原型链是有终点的值为 null。</p><p>搞清楚了原型链，在回到‘一切皆为对象’。<br>明白了javascript的原型链，明白了所有的继承终点都到了Object上，就不难理解‘一切皆为对象’了吧。</p><h1 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 27,</div><div class="line">city: &apos;chengdu&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是大家最熟悉的创建方式。</p><h2 id="Object实例化"><a href="#Object实例化" class="headerlink" title="Object实例化"></a>Object实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let obj = new Object(&#123;</div><div class="line">// name: &apos;yzf&apos;,</div><div class="line">// age: 27,</div><div class="line">// city: &apos;chengdu&apos;</div><div class="line">&#125;);</div><div class="line">obj.name = &apos;yzf&apos;;</div><div class="line">obj.age = 27;</div><div class="line">obj.city = &apos;chengdu&apos;;</div></pre></td></tr></table></figure><p>这里两种方式，为obj赋值，一种在实例化是进行，一种在实例化之后添加。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, city)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.city = city;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let fanerge = new Person(&apos;yzf&apos;, 27, &apos;chengdu&apos;)</div></pre></td></tr></table></figure><h1 id="Object对象的方法"><a href="#Object对象的方法" class="headerlink" title="Object对象的方法"></a>Object对象的方法</h1><p>Object对象的方法分为Object静态方法和Object的实例方法，静态方法定义在Object自身上，而实例方法定义在Object.prototype上；<br>在使用方式上也有区别，静态方法使用’如Object.keys(obj)’而实例方法使用’如obj.hasOwnProperty(prop)’。<br>我认为我们学习API是需要重点了解一个API的使用方式、定义、参数说明、返回值，下面我给出Object标准库中的方法，其中有部分是ES6+的方法，存在一定的兼容性问题。</p><h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><h3 id="Object-assign-target-…sources"><a href="#Object-assign-target-…sources" class="headerlink" title="Object.assign(target, …sources)"></a>Object.assign(target, …sources)</h3><p>定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>参数：target为目标对象，sources为源对象。<br>返回：目标对象。</p><h3 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [propertiesObject])"></a>Object.create(proto, [propertiesObject])</h3><p>定义：创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>参数：proto为新创建对象的原型对象，propertiesObject为相关属性的描述符。<br>返回：新对象。</p><h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>定义：会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>参数：obj为要在其上定义属性的对象，prop为要定义或修改的属性的名称，descriptor为将被定义或修改的属性描述符。<br>返回：obj。</p><h3 id="Object-defineProperties-obj-props"><a href="#Object-defineProperties-obj-props" class="headerlink" title="Object.defineProperties(obj, props)"></a>Object.defineProperties(obj, props)</h3><p>定义：直接在一个对象上定义新的属性或修改现有属性，并返回该对象。<br>参数：obj为要在其上定义属性的对象，props为要定义或修改的一个或多个属性的描述符。<br>返回：obj。</p><h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><p>定义：返回一个由一个给定对象的自身可枚举属性组成的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个表示给定对象的所有可枚举属性的字符串数组。</p><h3 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个包含对象自身的所有可枚举属性值的数组。</p><h3 id="Object-values-obj-1"><a href="#Object-values-obj-1" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：给定对象自身可枚举属性的键值（键值对也为数组）对数组。</p><h3 id="Object-preventExtensions-obj"><a href="#Object-preventExtensions-obj" class="headerlink" title="Object.preventExtensions(obj)"></a>Object.preventExtensions(obj)</h3><p>定义：让一个对象变的不可扩展，也就是永远不能再添加新的属性。<br>参数：obj为将要变得不可扩展的对象。<br>返回：已经不可扩展的对象。<br>PS：该对象的属性可能仍然可删除，且对象的原型仍然可以添加属性。</p><h3 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h3><p>定义：判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否可扩展的一个Boolean 。</p><h3 id="Object-seal-obj"><a href="#Object-seal-obj" class="headerlink" title="Object.seal(obj)"></a>Object.seal(obj)</h3><p>定义：封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。<br>参数：obj为将要被密封的对象。<br>返回：被密封的对象。<br>PS：属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性（get）。</p><h3 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h3><p>定义：判断一个对象是否被密封。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被密封的一个Boolean。</p><h3 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h3><p>定义：可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。<br>参数：obj为要被冻结的对象。<br>返回：要被冻结的对象。</p><h3 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h3><p>定义：判断一个对象是否被冻结。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被冻结的Boolean。</p><h3 id="Object-getOwnPropertyDescriptor-obj-prop"><a href="#Object-getOwnPropertyDescriptor-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptor(obj, prop)"></a>Object.getOwnPropertyDescriptor(obj, prop)</h3><p>定义：返回指定对象上一个自有属性对应的属性描述符。<br>参数：obj为需要查找的目标对象，prop为目标对象内属性名称（String类型）。<br>返回：如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</p><h3 id="Object-getOwnPropertyDescriptors-obj"><a href="#Object-getOwnPropertyDescriptors-obj" class="headerlink" title="Object.getOwnPropertyDescriptors(obj)"></a>Object.getOwnPropertyDescriptors(obj)</h3><p>定义：用来获取一个对象的所有自身属性的描述符。<br>参数：obj为需要查找的目标对象。<br>返回：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p><h3 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>返回：在给定对象上找到的属性对应的字符串数组。</p><h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为要返回 Symbol 属性的对象。<br>返回：在给定对象自身上找到的所有 Symbol 属性的数组。</p><h3 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h3><p>定义：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或null。<br>参数：obj为要设置其原型的对象，prototype为该对象的新原型(一个对象 或 null)。<br>返回：返回obj对象。</p><h3 id="Object-getPrototypeOf-object"><a href="#Object-getPrototypeOf-object" class="headerlink" title="Object.getPrototypeOf(object)"></a>Object.getPrototypeOf(object)</h3><p>定义：返回指定对象的原型（内部[[Prototype]]属性的值）。<br>参数：要返回其原型的对象。<br>返回：给定对象的原型。如果没有继承属性，则返回null。</p><h3 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2);"></a>Object.is(value1, value2);</h3><p>定义：判断两个值是否是相同的值。<br>参数：value1为需要比较的第一个值，value2为需要比较的第二个值。<br>返回：表示两个参数是否相同的Boolean 。</p><h2 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>下面obj为Object的实例。</p><h3 id="obj-hasOwnProperty-prop"><a href="#obj-hasOwnProperty-prop" class="headerlink" title="obj.hasOwnProperty(prop)"></a>obj.hasOwnProperty(prop)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：prop为要检测的属性String或者Symbol。<br>返回：用来判断某个对象是否含有指定的属性的Boolean。</p><h3 id="prototypeObj-isPrototypeOf-obj"><a href="#prototypeObj-isPrototypeOf-obj" class="headerlink" title="prototypeObj.isPrototypeOf(obj)"></a>prototypeObj.isPrototypeOf(obj)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：obj为在该对象的原型链上搜寻。<br>返回：表示调用对象是否在另一个对象的原型链上的Boolean。</p><h3 id="obj-propertyIsEnumerable-prop"><a href="#obj-propertyIsEnumerable-prop" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个布尔值，表示指定的属性是否可枚举。<br>参数：prop为需要测试的属性名。<br>返回：用来表示指定的属性名是否可枚举的Boolean。</p><h3 id="obj-toLocaleString"><a href="#obj-toLocaleString" class="headerlink" title="obj.toLocaleString()"></a>obj.toLocaleString()</h3><p>定义：方法返回一个该对象的字符串表示。<br>返回：表示对象的字符串。</p><h3 id="obj-propertyIsEnumerable-prop-1"><a href="#obj-propertyIsEnumerable-prop-1" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个表示该对象的字符串。<br>返回：表示该对象的字符串。<br>PS：ES6之前经常这样用Object.prototype.toString.call(obj) === ‘[object Object]’ 来区别Object和Array。</p><h3 id="ob-valueOf"><a href="#ob-valueOf" class="headerlink" title="ob.valueOf()"></a>ob.valueOf()</h3><p>定义：返回指定对象的原始值。<br>返回：返回值为该对象的原始值。</p><h3 id="object-instanceof-constructor"><a href="#object-instanceof-constructor" class="headerlink" title="object instanceof constructor"></a>object instanceof constructor</h3><p>定义：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>参数：object为要检测的对象，constructor为某个构造函数。<br>返回：boolean值。[2018-03-21]</p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="external">MDN__proto__</a><br><a href="https://www.zhihu.com/question/34183746/answer/58068402" target="_blank" rel="external">__proto__和prototype的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Object</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么一切皆为对象&quot;&gt;&lt;a href=&quot;#为什么一切皆为对象&quot; class=&quot;headerlink&quot; title=&quot;为什么一切皆为对象&quot;&gt;&lt;/a&gt;为什么一切皆为对象&lt;/h1&gt;&lt;p&gt;‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript标准库总结</title>
    <link href="https://fanerge.github.io/2018/javascript%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/2018/javascript标准库总结.html</id>
    <published>2018-03-19T13:56:38.000Z</published>
    <updated>2018-04-04T12:47:12.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="值属性"><a href="#值属性" class="headerlink" title="值属性"></a>值属性</h1><p>这部分属性只是简单的值，它们没有自己的属性和方法。</p><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><pre><code>全局属性 Infinity 是一个数值，表示无穷大。</code></pre><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><pre><code>全局属性 NaN 的值表示不是一个数字（Not-A-Number）。</code></pre><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><pre><code>全局属性undefined表示原始值undefined。它是一个JavaScript的 原始数据类型 。</code></pre><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><pre><code>值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。</code></pre><h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。    </p><h3 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h3><pre><code>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。</code></pre><p>PS：eval会造成安全和性能方面的问题，具体参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval#Don.27t_use_eval.21" target="_blank" rel="external">避免在不必要的情况下使用 eval</a>。</p><h3 id="isFinite-arg"><a href="#isFinite-arg" class="headerlink" title="isFinite(arg)"></a>isFinite(arg)</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为有限值。</code></pre><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为NaN。</code></pre><p>PS：使用Number.isNaN()来代替更有语义性。</p><h3 id="parseFloat-str"><a href="#parseFloat-str" class="headerlink" title="parseFloat(str)"></a>parseFloat(str)</h3><pre><code>parseFloat() 函数解析一个字符串参数并返回一个浮点数。</code></pre><p>PS：如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略.<br>    如果第一个字符不能解析，直接返回NaN。</p><h3 id="parseInt-str-radix"><a href="#parseInt-str-radix" class="headerlink" title="parseInt(str, radix);"></a>parseInt(str, radix);</h3><pre><code>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</code></pre><p>PS：radix一个介于2和36之间的整数，表示上述字符串的基数（默认为10）。</p><h3 id="encodeURI-URI"><a href="#encodeURI-URI" class="headerlink" title="encodeURI(URI)"></a>encodeURI(URI)</h3><p>函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。<br>PS：encodeURI 字母、数字、;、,、/、?、:、@、&amp;、=、+、$、-、_、.、!、~、*、’、(、)、#、之外的所有字符。</p><h3 id="decodeURI-encodeURI"><a href="#decodeURI-encodeURI" class="headerlink" title="decodeURI(encodeURI)"></a>decodeURI(encodeURI)</h3><pre><code>decodeURI() 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。</code></pre><h3 id="encodeURIComponent-str"><a href="#encodeURIComponent-str" class="headerlink" title="encodeURIComponent(str)"></a>encodeURIComponent(str)</h3><pre><code>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。</code></pre><p>PS：encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。<br>    为了避免服务器收到不可预知的请求，对任何用户输入的作为URI部分的内容你都需要用encodeURIComponent进行转义。</p><h3 id="decodeURIComponent-encodedURI"><a href="#decodeURIComponent-encodedURI" class="headerlink" title="decodeURIComponent(encodedURI)"></a>decodeURIComponent(encodedURI)</h3><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><h3 id="encodeURI和encodeURIComponent的区别与使用场景"><a href="#encodeURI和encodeURIComponent的区别与使用场景" class="headerlink" title="encodeURI和encodeURIComponent的区别与使用场景"></a>encodeURI和encodeURIComponent的区别与使用场景</h3><pre><code>区别在于编码的字符范围不同。</code></pre><p>encodeURI使用于编码整个URI而encodeURIComponent主要query部分（当你需要编码URL中的参数）。<br><a href="https://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="external">简单明了区分escape、encodeURI和encodeURIComponent</a></p><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。</p><h2 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>定义：指明函数的形参个数（确定多少个必须要传入的参数）区别于arguments.length实参个数（确定函数被调用时的实际传参个数）。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>定义：返回创建实例对象的 Object 构造函数的引用。</p><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="func-apply-thisArg-argsArray"><a href="#func-apply-thisArg-argsArray" class="headerlink" title="func.apply(thisArg, [argsArray])"></a>func.apply(thisArg, [argsArray])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为func函数执行时this的指向，argsArray为类数组参数数组。<br>返回：调用有指定this值和参数的函数的结果。</p><h3 id="fun-call-thisArg-arg1-arg2-…"><a href="#fun-call-thisArg-arg1-arg2-…" class="headerlink" title="fun.call(thisArg, arg1, arg2, …)"></a>fun.call(thisArg, arg1, arg2, …)</h3><p>定义：调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。<br>参数：thisArg为func函数执行时this的指向，arg1, arg2, …为指定的参数列表。<br>返回：返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。<br>运用：1.使用call方法调用父构造函数（在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承）<br>  2.使用call方法调用匿名函数3.使用call方法调用函数并且指定上下文的’this’<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#示例" target="_blank" rel="external">运用举例</a></p><h3 id="fun-bind-thisArg-arg1-arg2-…"><a href="#fun-bind-thisArg-arg1-arg2-…" class="headerlink" title="fun.bind(thisArg[, arg1[, arg2[, …]]])"></a>fun.bind(thisArg[, arg1[, arg2[, …]]])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为当绑定函数被调用时，该参数会作为原函数运行时的 this 指向，arg1、arg2…为当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。<br>返回：由指定的this值和初始化参数改造的原函数拷贝（返回一个函数）。<br>运用：1.创建绑定函数（显式绑定this）2.偏函数（使一个函数拥有预设的初始参数）。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#示例" target="_blank" rel="external">运用举例</a></p><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>定义：返回一个表示当前函数源代码的字符串。<br>参数：null。<br>返回：表示函数源代码的一个字符串。</p><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。<br>Number()，如果参数无法被转换为数字，则返回 NaN。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>两个可表示(representable)数之间的最小间隔，在进行计算时误差在这个范围内被认为是合理的。</p><h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>JavaScript 中最大的安全整数 (2^53 - 1)。</p><h3 id="Number-MIN-SAFE-INTEGER"><a href="#Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MIN_SAFE_INTEGER"></a>Number.MIN_SAFE_INTEGER</h3><p>JavaScript 中最小的安全整数 (-(2^53 - 1)).</p><h3 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h3><p>能表示的最大正数。最小的负数是 -MAX_VALUE。</p><h3 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h3><p>能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。</p><h3 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h3><p>Not A Number.</p><h3 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h3><p>特殊的负无穷大值，在溢出时返回该值。</p><h3 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h3><p>特殊的正无穷大值，在溢出时返回改值。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>下列方法均不会发生将String转化为Number的过程。</p><h3 id="Number-isNaN-value"><a href="#Number-isNaN-value" class="headerlink" title="Number.isNaN(value)"></a>Number.isNaN(value)</h3><p>定义：确定传递的值是否为 NaN和其类型是 Number。它是用于代替原始的全局isNaN()。<br>参数：要被检测是否是 NaN 的值。<br>返回：一个布尔值，表示给定的值是否是 NaN。<br>PS：该方法不同于全局的isNaN()，不会将字符串转换为数字。</p><h3 id="Number-isFinite-value"><a href="#Number-isFinite-value" class="headerlink" title="Number.isFinite(value)"></a>Number.isFinite(value)</h3><p>定义：用来检测传入的参数是否是一个有穷数（finite number）。<br>参数：value要被检测有穷性的值。<br>返回：一个布尔值表示给定的值是否是一个有穷数。<br>PS：和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值。</p><h3 id="Number-isInteger-value"><a href="#Number-isInteger-value" class="headerlink" title="Number.isInteger(value)"></a>Number.isInteger(value)</h3><p>定义：用来判断给定的参数是否为整数。<br>参数：value要判断此参数是否为整数。<br>返回：判断给定值是否是整数的 Boolean 值。</p><h3 id="Number-isSafeInteger-testValue"><a href="#Number-isSafeInteger-testValue" class="headerlink" title="Number.isSafeInteger(testValue)"></a>Number.isSafeInteger(testValue)</h3><p>定义：用来判断传入的参数值是否是一个“安全整数”（safe integer）。<br>参数：testValue需要检测的参数。<br>返回：一个布尔值 表示给定的值是否是一个安全整数（safe integer）。</p><h3 id="Number-parseFloat-string"><a href="#Number-parseFloat-string" class="headerlink" title="Number.parseFloat(string)"></a>Number.parseFloat(string)</h3><p>定义：可以把一个字符串解析成浮点数。<br>参数：string被解析的字符串。<br>返回：对应的浮点数。<br>PS：与全局函数 parseFloat()一样。</p><h3 id="Number-parseInt-string-radix"><a href="#Number-parseInt-string-radix" class="headerlink" title="Number.parseInt(string[, radix])"></a>Number.parseInt(string[, radix])</h3><p>定义：可以根据给定的进制数的一个字符串数解析成整数。<br>参数：string要解析的值，radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>下列方法均返回为字符串。</p><h3 id="numObj-toExponential-fractionDigits"><a href="#numObj-toExponential-fractionDigits" class="headerlink" title="numObj.toExponential([fractionDigits])"></a>numObj.toExponential([fractionDigits])</h3><p>定义：以指数表示法返回该数值字符串表示形式。<br>参数：fractionDigits一个整数，用来指定小数点后有几位数字。<br>返回：一个用幂的形式 (科学记数法) 来表示Number 对象的字符串。</p><h3 id="numObj-toFixed-digits"><a href="#numObj-toFixed-digits" class="headerlink" title="numObj.toFixed(digits)"></a>numObj.toFixed(digits)</h3><p>定义：使用定点表示法来格式化一个数。<br>参数：digits小数点后数字的个数。<br>返回：所给数值的定点数表示法的字符串形式。</p><h3 id="numObj-toPrecision-precision"><a href="#numObj-toPrecision-precision" class="headerlink" title="numObj.toPrecision(precision)"></a>numObj.toPrecision(precision)</h3><p>定义：以指定的精度返回该数值对象的字符串表示。<br>参数：precision一个用来指定有效数个数的整数。<br>返回：以定点表示法或指数表示法表示的一个数值对象的字符串表示。</p><h3 id="numObj-toLocaleString-locales-options"><a href="#numObj-toLocaleString-locales-options" class="headerlink" title="numObj.toLocaleString([locales [, options]])"></a>numObj.toLocaleString([locales [, options]])</h3><p>定义：返回这个数字在特定语言环境下的表示字符串。<br>参数：locales为指定本地要使用的编号系统，options为有下列属性（localeMatcher、style、currency等等但存在一定的兼容性）<br>返回：返回一个语言环境下的表示字符串。<br>PS：通常用于格式化为某种货币形式。</p><h3 id="numObj-toString-radix"><a href="#numObj-toString-radix" class="headerlink" title="numObj.toString([radix])"></a>numObj.toString([radix])</h3><p>定义：返回指定 Number 对象的字符串表示形式。<br>参数：radix指定要用于数字到字符串的转换的基数(从2到36)。<br>返回：转换后的字符串。</p><h3 id="numObj-valueOf"><a href="#numObj-valueOf" class="headerlink" title="numObj.valueOf()"></a>numObj.valueOf()</h3><p>定义：返回一个被 Number 对象包装的原始值。<br>返回：表示指定 Number 对象的原始值的数字。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode-num1-…-numN"><a href="#String-fromCharCode-num1-…-numN" class="headerlink" title="String.fromCharCode(num1, …, numN)"></a>String.fromCharCode(num1, …, numN)</h3><p>定义：返回使用指定的Unicode值序列创建的字符串。</p><h3 id="String-fromCodePoint-num1-…-numN"><a href="#String-fromCodePoint-num1-…-numN" class="headerlink" title="String.fromCodePoint(num1[, …[, numN]])"></a>String.fromCodePoint(num1[, …[, numN]])</h3><p>定义：返回使用指定的代码点序列创建的字符串，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p><h3 id="String-raw-callSite-…substitutions-String-rawtemplateString"><a href="#String-raw-callSite-…substitutions-String-rawtemplateString" class="headerlink" title="String.raw(callSite, …substitutions) || String.rawtemplateString"></a>String.raw(callSite, …substitutions) || String.raw<code>templateString</code></h3><p>是用来获取一个模板字符串的原始字面量值的。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h3><p>返回：字符串的长度。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>返回：第N个字符串，但不能更改。</p><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="str-charAt-index"><a href="#str-charAt-index" class="headerlink" title="str.charAt(index)"></a>str.charAt(index)</h3><p>定义：从一个字符串中返回指定index的字符，缺省参数为0。</p><h3 id="str-charCodeAt-index"><a href="#str-charCodeAt-index" class="headerlink" title="str.charCodeAt(index)"></a>str.charCodeAt(index)</h3><p>定义：返回给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。</p><h3 id="str-codePointAt-index"><a href="#str-codePointAt-index" class="headerlink" title="str.codePointAt(index)"></a>str.codePointAt(index)</h3><p>定义：返回 一个 Unicode 编码点值的非负整数。</p><h3 id="str-concat-string2-string3-…-stringN"><a href="#str-concat-string2-string3-…-stringN" class="headerlink" title="str.concat(string2, string3[, …, stringN])"></a>str.concat(string2, string3[, …, stringN])</h3><p>定义：将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p><h3 id="str-includes-searchString-index"><a href="#str-includes-searchString-index" class="headerlink" title="str.includes(searchString[, index])"></a>str.includes(searchString[, index])</h3><p>定义：判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。</p><h3 id="str-startsWith-searchString-index"><a href="#str-startsWith-searchString-index" class="headerlink" title="str.startsWith(searchString [, index])"></a>str.startsWith(searchString [, index])</h3><p>定义：用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。</p><h3 id="str-endsWith-searchString-index"><a href="#str-endsWith-searchString-index" class="headerlink" title="str.endsWith(searchString [, index]);"></a>str.endsWith(searchString [, index]);</h3><p>定义：判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p><h3 id="str-indexOf-searchValue-index"><a href="#str-indexOf-searchValue-index" class="headerlink" title="str.indexOf(searchValue[, index])"></a>str.indexOf(searchValue[, index])</h3><p>定义：第一次出现的指定值的索引，开始在Index进行搜索，否则返回-1。</p><h3 id="str-lastIndexOf-searchValue-index"><a href="#str-lastIndexOf-searchValue-index" class="headerlink" title="str.lastIndexOf(searchValue[, index])"></a>str.lastIndexOf(searchValue[, index])</h3><p>定义：返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</p><h3 id="str-localeCompare-compareString-locales-options"><a href="#str-localeCompare-compareString-locales-options" class="headerlink" title="str.localeCompare(compareString[, locales[, options]])"></a>str.localeCompare(compareString[, locales[, options]])</h3><p>定义：localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。</p><h3 id="str-match-regexp"><a href="#str-match-regexp" class="headerlink" title="str.match(regexp);"></a>str.match(regexp);</h3><p>定义：当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。</p><h3 id="str-normalize-form"><a href="#str-normalize-form" class="headerlink" title="str.normalize([form]);"></a>str.normalize([form]);</h3><p>定义：会按照指定的一种 Unicode 正规形式将当前字符串正规化。</p><h3 id="str-padStart-targetLength-padString"><a href="#str-padStart-targetLength-padString" class="headerlink" title="str.padStart(targetLength [, padString])"></a>str.padStart(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之前（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p><h3 id="str-padEnd-targetLength-padString"><a href="#str-padEnd-targetLength-padString" class="headerlink" title="str.padEnd(targetLength [, padString])"></a>str.padEnd(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之后（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p><h3 id="str-repeat-count"><a href="#str-repeat-count" class="headerlink" title="str.repeat(count);"></a>str.repeat(count);</h3><p>定义：返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。<br>PS：参数从零开始。</p><h3 id="str-replace-regexp-substr-newSubStr-function"><a href="#str-replace-regexp-substr-newSubStr-function" class="headerlink" title="str.replace(regexp|substr, newSubStr|function)"></a>str.replace(regexp|substr, newSubStr|function)</h3><p>定义：返回一个由替换值替换一些或所有匹配的模式后的新字符串。<br>如果第一个参数为regexp第二个参数为function时，该函数参数说明<br>参数1：匹配模式的字符串。<br>参数2–：子表达是匹配的子字符串（就是捕获分组）。<br>倒数参数2：声明匹配在string中出现的位置。<br>倒数参数1：进行匹配的sting本身。</p><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>定义：行正则表达式和 String对象之间的一个搜索匹配。<br>返回：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p><h3 id="str-slice-beginSlice-endSlice"><a href="#str-slice-beginSlice-endSlice" class="headerlink" title="str.slice(beginSlice[, endSlice])"></a>str.slice(beginSlice[, endSlice])</h3><p>定义：提取一个字符串的一部分，并返回一新的字符串。<br>参数：beginSlice从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度。<br>endSlice在该索引（以 0 为基数）处结束提取字符串，同样可为负数。</p><h3 id="str-split-separator-limit"><a href="#str-split-separator-limit" class="headerlink" title="str.split([separator[, limit]])"></a>str.split([separator[, limit]])</h3><p>定义：使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 </p><h3 id="str-substr-start-length"><a href="#str-substr-start-length" class="headerlink" title="str.substr(start[, length])"></a>str.substr(start[, length])</h3><p>定义：返回一个字符串中从指定位置开始到指定字符数的字符。<br>PS：start &gt;=str.length 或 length &lt;= 0 返回空字符串;start &lt; 0 则转换为start + str.length。</p><h3 id="str-substring-indexStart-indexEnd"><a href="#str-substring-indexStart-indexEnd" class="headerlink" title="str.substring(indexStart[, indexEnd])"></a>str.substring(indexStart[, indexEnd])</h3><p>定义：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。<br>PS：一些特殊情况。<br>如果 indexStart 等于 indexEnd，substring 返回一个空字符串。<br>如果省略 indexEnd，substring 提取字符一直到字符串末尾。<br>如果任一参数小于 0 或为 NaN，则被当作 0。<br>如果任一参数大于 stringName.length，则被当作 stringName.length。<br>如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。</p><h3 id="str-toLowerCase"><a href="#str-toLowerCase" class="headerlink" title="str.toLowerCase()"></a>str.toLowerCase()</h3><p>定义：将调用该方法的字符串值转为小写形式，并返回新字符串。</p><h3 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h3><p>定义：将调用该方法的字符串值转换为大写形式，并返回新字符串。</p><h3 id="str-toLocaleLowerCase"><a href="#str-toLocaleLowerCase" class="headerlink" title="str.toLocaleLowerCase()"></a>str.toLocaleLowerCase()</h3><p>定义：根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。<br>PS：在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同（除土耳其等）。</p><h3 id="str-toLocaleUpperCase"><a href="#str-toLocaleUpperCase" class="headerlink" title="str.toLocaleUpperCase()"></a>str.toLocaleUpperCase()</h3><p>定义：使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。</p><h3 id="str-toString"><a href="#str-toString" class="headerlink" title="str.toString()"></a>str.toString()</h3><p>定义：返回指定对象的字符串形式。</p><h3 id="str-trim"><a href="#str-trim" class="headerlink" title="str.trim()"></a>str.trim()</h3><p>定义：会从一个字符串的两端删除空白字符，返回一个新的字符串。<br>PS：str.trimLeft() 和 str.trimRight() 不是标准方法。</p><h3 id="string-Symbol-iterator"><a href="#string-Symbol-iterator" class="headerlink" title="string[Symbol.iterator]"></a>string[Symbol.iterator]</h3><p>返回一个新的Iterator对象，它遍历字符串的代码点，返回每一个代码点的字符串值。<br>PS：下列内置类型拥有默认迭代器行为Array、String、Set、Map等，而Object没有。</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><p>在 ES2015 中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。</p><h3 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike[, mapFn[, thisArg]])"></a>Array.from(arrayLike[, mapFn[, thisArg]])</h3><p>定义：从一个类似数组或可迭代对象中创建一个新的数组实例。<br>参数：<br>  arrayLike想要转换成数组的伪数组对象或可迭代对象。<br>  mapFn (可选参数)如果指定了该参数，新数组中的每个元素会执行该回调函数。<br>  thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。<br>返回：一个新的数组。<br>PS：Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg)，ES6之前的做法：Array.prototype.slice.call(arrayLike)。</p><h3 id="Array-isArray-obj"><a href="#Array-isArray-obj" class="headerlink" title="Array.isArray(obj)"></a>Array.isArray(obj)</h3><p>定义：确定传递的值是否是一个 Array。<br>返回：boolean。<br>PS：ES6之前的做法Object.prototype.toString.call(arg) === ‘[object Array]’。</p><h3 id="Array-of-element0-element1-…-elementN"><a href="#Array-of-element0-element1-…-elementN" class="headerlink" title="Array.of(element0[, element1[, …[, elementN]]])"></a>Array.of(element0[, element1[, …[, elementN]]])</h3><p>定义：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。<br>参数：任意个参数，将按顺序成为返回数组中的元素。<br>返回：参数列表组成的数组。<br>PS：Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。</p><h2 id="实例方法及属性"><a href="#实例方法及属性" class="headerlink" title="实例方法及属性"></a>实例方法及属性</h2><h3 id="ary-length"><a href="#ary-length" class="headerlink" title="ary.length"></a>ary.length</h3><p>返回：读写数组的长度。</p><h3 id="修改器方法（改变原数组）"><a href="#修改器方法（改变原数组）" class="headerlink" title="修改器方法（改变原数组）"></a>修改器方法（改变原数组）</h3><h4 id="arr-copyWithin-target-start-end"><a href="#arr-copyWithin-target-start-end" class="headerlink" title="arr.copyWithin(target[, start[, end]])"></a>arr.copyWithin(target[, start[, end]])</h4><p>定义：浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。<br>参数：<br>target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。<br>start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。<br>end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。<br>返回值：操作原数组。</p><h4 id="arr-fill-value-start-end"><a href="#arr-fill-value-start-end" class="headerlink" title="arr.fill(value[, start[, end]])"></a>arr.fill(value[, start[, end]])</h4><p>定义：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。<br>参数：<br>  value 用来填充数组元素的值。<br>  start 开始索引，默认为0。<br>  end 结束索引，默认为arr.length（不包括）。<br>返回：修改后的数组。</p><h4 id="arr-push-element1-…-elementN"><a href="#arr-push-element1-…-elementN" class="headerlink" title="arr.push(element1, …, elementN)"></a>arr.push(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br>参数：<br>  elementN 被添加到数组末尾的元素。<br>返回：操作后的数组的长度。</p><h4 id="arr-pop"><a href="#arr-pop" class="headerlink" title="arr.pop()"></a>arr.pop()</h4><p>定义：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素(当数组为空时返回undefined)。</p><h4 id="arr-reverse"><a href="#arr-reverse" class="headerlink" title="arr.reverse()"></a>arr.reverse()</h4><p>定义：将数组中元素的位置颠倒。<br>返回：颠倒数组中元素的位置，并返回该数组的引用。</p><h4 id="arr-sort-compareFunction"><a href="#arr-sort-compareFunction" class="headerlink" title="arr.sort(compareFunction)"></a>arr.sort(compareFunction)</h4><p>定义：可以根据指定方法对数组进行排序。<br>compareFunction 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>返回：返回排序后的数组。原数组已经被排序后的数组代替。</p><h4 id="arr-shift"><a href="#arr-shift" class="headerlink" title="arr.shift()"></a>arr.shift()</h4><p>定义：从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素; 如果数组为空则返回undefined。 </p><h4 id="arr-unshift-element1-…-elementN"><a href="#arr-unshift-element1-…-elementN" class="headerlink" title="arr.unshift(element1, …, elementN)"></a>arr.unshift(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br>参数：element1, …, elementN 要添加到数组开头的元素。<br>返回：当一个对象调用该方法时，返回其 length 属性值。</p><h4 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start, [deleteCount], [item1], [item2], …)"></a>array.splice(start, [deleteCount], [item1], [item2], …)</h4><p>定义：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br>参数：<br>  start 开始修改的位置。<br>  deleteCount 移除数组元素的个数。<br>  item1、item2…为添加的元素。<br>返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p><h3 id="访问方法（不直接操作原理的数组）"><a href="#访问方法（不直接操作原理的数组）" class="headerlink" title="访问方法（不直接操作原理的数组）"></a>访问方法（不直接操作原理的数组）</h3><h4 id="old-array-concat-value1-value2-…-valueN"><a href="#old-array-concat-value1-value2-…-valueN" class="headerlink" title="old_array.concat(value1[, value2[, …[, valueN]]])"></a>old_array.concat(value1[, value2[, …[, valueN]]])</h4><p>定义：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br>参数：valueN 将数组和/或值连接成新数组。<br>返回：新数组。</p><h4 id="arr-includes-searchElement-fromIndex"><a href="#arr-includes-searchElement-fromIndex" class="headerlink" title="arr.includes(searchElement, [fromIndex])"></a>arr.includes(searchElement, [fromIndex])</h4><p>定义：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：boolean。</p><h4 id="arr-join-separator"><a href="#arr-join-separator" class="headerlink" title="arr.join([separator])"></a>arr.join([separator])</h4><p>定义：将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：string。</p><h4 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin], [end])"></a>arr.slice([begin], [end])</h4><p>定义：返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。<br>返回：一个含有提取元素的新数组。</p><h4 id="arr-indexOf-searchElement-fromIndex-0"><a href="#arr-indexOf-searchElement-fromIndex-0" class="headerlink" title="arr.indexOf(searchElement[, fromIndex = 0])"></a>arr.indexOf(searchElement[, fromIndex = 0])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。</p><h4 id="arr-lastIndexOf-searchElement-fromIndex-arr-length-1"><a href="#arr-lastIndexOf-searchElement-fromIndex-arr-length-1" class="headerlink" title="arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])"></a>arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：数组中最后一个元素的索引，如未找到返回-1。</p><h4 id="arr-toString"><a href="#arr-toString" class="headerlink" title="arr.toString()"></a>arr.toString()</h4><p>定义：返回一个字符串，表示指定的数组及其元素。<br>返回：逗号分隔的字符串。</p><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="array-forEach-callback-currentValue-index-array-do-something-this"><a href="#array-forEach-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.forEach(callback(currentValue, index, array){ //do something}, this)"></a>array.forEach(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：对数组的每个元素执行一次提供的函数。<br>返回：undefined。<br>PS：没有办法中止或者跳出 forEach 循环，需要跳出请使用循环代替。<br>已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不会跳过那些值为 undefined、null 的项）。</p><h4 id="array-map-callback-currentValue-index-array-do-something-this"><a href="#array-map-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.map(callback(currentValue, index, array){ //do something}, this)"></a>array.map(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>返回：一个新数组，每个元素都是回调函数的结果。</p><h4 id="arr-keys"><a href="#arr-keys" class="headerlink" title="arr.keys()"></a>arr.keys()</h4><p>定义：返回一个新的Array迭代器，它包含数组中每个索引的键。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-values"><a href="#arr-values" class="headerlink" title="arr.values()"></a>arr.values()</h4><p>定义：返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-entries"><a href="#arr-entries" class="headerlink" title="arr.entries()"></a>arr.entries()</h4><p>定义：返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-every-callback-thisArg"><a href="#arr-every-callback-thisArg" class="headerlink" title="arr.every(callback[, thisArg])"></a>arr.every(callback[, thisArg])</h4><p>定义：测试数组的所有元素是否都通过了指定函数的测试。<br>返回：boolean。</p><h4 id="arr-some-callback-thisArg"><a href="#arr-some-callback-thisArg" class="headerlink" title="arr.some(callback[, thisArg])"></a>arr.some(callback[, thisArg])</h4><p>定义：测试数组中的某些元素是否通过由提供的函数实现的测试。<br>返回：boolean。</p><h4 id="arr-filter-callback-thisArg"><a href="#arr-filter-callback-thisArg" class="headerlink" title="arr.filter(callback[, thisArg])"></a>arr.filter(callback[, thisArg])</h4><p>定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br>返回：新数组。</p><h4 id="arr-findIndex-callback-thisArg"><a href="#arr-findIndex-callback-thisArg" class="headerlink" title="arr.findIndex(callback[, thisArg])"></a>arr.findIndex(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值的索引，否则返回 -1。</p><h4 id="arr-find-callback-thisArg"><a href="#arr-find-callback-thisArg" class="headerlink" title="arr.find(callback[, thisArg])"></a>arr.find(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。</p><h4 id="arr-reduce-callback-initialValue"><a href="#arr-reduce-callback-initialValue" class="headerlink" title="arr.reduce(callback[, initialValue])"></a>arr.reduce(callback[, initialValue])</h4><p>定义：对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<br>参数：<br>  callback 执行数组中每个值的函数，包含四个参数：<br>    accumulato 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br>    currentValue 数组中正在处理的元素。<br>    currentIndex可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。<br>    array可选 调用reduce的数组。<br>  initialValue 可选用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br>返回：函数累计处理的结果。</p><h4 id="arr-reduceRight-callback-initialValue"><a href="#arr-reduceRight-callback-initialValue" class="headerlink" title="arr.reduceRight(callback[, initialValue])"></a>arr.reduceRight(callback[, initialValue])</h4><p>定义：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。</p><h4 id="arrSymbol-iterator"><a href="#arrSymbol-iterator" class="headerlink" title="arrSymbol.iterator"></a>arr<a href="">Symbol.iterator</a></h4><p>定义：默认为数组不说了迭代器，@@iterator 属性和 values() 属性的初始值均为同一个函数对象。<br>返回：数组的 iterator 方法，默认情况下与 values() 返回值相同。</p><h4 id="arr-flatten-depth"><a href="#arr-flatten-depth" class="headerlink" title="arr.flatten(depth)"></a>arr.flatten(depth)</h4><p>定义：会递归到指定深度将所有子数组连接，并返回一个新数组。<br>参数：depth 可选指定嵌套数组中的结构深度，默认值为1。<br>返回：一个将子数组连接的新数组。</p><h4 id="arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg"><a href="#arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg" class="headerlink" title="arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])"></a>arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])</h4><p>定义：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flatten 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。<br>返回：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</p><h1 id="Proxy-amp-amp-Reflect"><a href="#Proxy-amp-amp-Reflect" class="headerlink" title="Proxy &amp;&amp; Reflect"></a>Proxy &amp;&amp; Reflect</h1><p>Proxy是一个构造函数（对对象的访问进行拦截），Reflect（操作对象提供的API）。<br>Reflect它与Proxy对象的方法是一一对应的，这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Proxy方法：target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">var person = &#123;</div><div class="line">  name: &quot;张三&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var proxy = new Proxy(person, &#123;</div><div class="line">  get: function(target, property) &#123;</div><div class="line">    if (property in target) &#123;</div><div class="line">      return target[property];</div><div class="line">    &#125; else &#123;</div><div class="line">      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">proxy.name // &quot;张三&quot;</div><div class="line">proxy.age // 抛出一个错误</div></pre></td></tr></table></figure></p><p><a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" target="_blank" rel="external">Proxy使用详解</a></p><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。<br>// 下列方法说明：target为目标对象，name为某个属性，receiver为如果name属性设置了赋值函数，则为函数的this指向<br>Reflect.apply(target, thisArg, args)<br>  Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。<br>Reflect.construct(target, args)<br>  Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。<br>Reflect.get(target, name, receiver)<br>  Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>Reflect.set(target, name, value, receiver)<br>  Reflect.set方法设置target对象的name属性等于value。<br>Reflect.defineProperty(target, name, desc)<br>  Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。<br>Reflect.deleteProperty(target, name)<br>  Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。<br>Reflect.has(target, name)<br>  Reflect.has方法对应name in obj里面的in运算符。<br>Reflect.ownKeys(target)<br>  Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。<br>Reflect.isExtensible(target)<br>  Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。<br>Reflect.preventExtensions(target)<br>  Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。<br>Reflect.getOwnPropertyDescriptor(target, name)<br>  Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。<br>Reflect.getPrototypeOf(target)<br>  Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。<br>Reflect.setPrototypeOf(target, prototype)<br>  Reflect.setPrototypeOf方法用于设置对象的<strong>proto</strong>属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。</p><h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>Event接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="bubbles（只读）"><a href="#bubbles（只读）" class="headerlink" title="bubbles（只读）"></a>bubbles（只读）</h3><p>定义：用来表示该事件是否在DOM中冒泡的boolean值。</p><h3 id="cancelBubble（废弃）"><a href="#cancelBubble（废弃）" class="headerlink" title="cancelBubble（废弃）"></a>cancelBubble（废弃）</h3><p>定义：获取或设置当前事件是否要取消冒泡（使用e.stopPropagation()代替）。</p><h3 id="cancelable（只读）"><a href="#cancelable（只读）" class="headerlink" title="cancelable（只读）"></a>cancelable（只读）</h3><p>定义：表示这个事件是否可以取消默认行为（阻止默认行为e.preventDefault()）。</p><h3 id="composed（只读）"><a href="#composed（只读）" class="headerlink" title="composed（只读）"></a>composed（只读）</h3><p>定义：表示该事件是否可以Shadow DOM 传递到一般的 DOM。</p><h3 id="currentTarget（只读）"><a href="#currentTarget（只读）" class="headerlink" title="currentTarget（只读）"></a>currentTarget（只读）</h3><p>定义：当前注册事件的对象的引用，这个值会在传递途中发生变化。</p><h3 id="deepPath"><a href="#deepPath" class="headerlink" title="deepPath"></a>deepPath</h3><p>定义：返回事件冒泡过程所有经过的节点所构成的Array数组。</p><h3 id="defaultPrevented（只读）"><a href="#defaultPrevented（只读）" class="headerlink" title="defaultPrevented（只读）"></a>defaultPrevented（只读）</h3><p>定义：返回是否已经调用了e.preventDefault()来阻止默认行为。</p><h3 id="eventPhase（只读）"><a href="#eventPhase（只读）" class="headerlink" title="eventPhase（只读）"></a>eventPhase（只读）</h3><p>定义：返回事件流正在哪个阶段。</p><h3 id="returnValue（废弃）"><a href="#returnValue（废弃）" class="headerlink" title="returnValue（废弃）"></a>returnValue（废弃）</h3><p>定义：获取或设置事件的默认操作是否已被阻止。</p><h3 id="target（只读）"><a href="#target（只读）" class="headerlink" title="target（只读）"></a>target（只读）</h3><p>定义：返回一个触发事件的对象的引用（ie的srcElement）。</p><h3 id="timeStamp（只读）"><a href="#timeStamp（只读）" class="headerlink" title="timeStamp（只读）"></a>timeStamp（只读）</h3><p>定义：事件创建时的时间戳，毫秒级别。</p><h3 id="type（只读）"><a href="#type（只读）" class="headerlink" title="type（只读）"></a>type（只读）</h3><p>定义：返回一个字符串（不区分大小写）, 表示该事件对象的事件类型。</p><h3 id="isTrusted（只读）"><a href="#isTrusted（只读）" class="headerlink" title="isTrusted（只读）"></a>isTrusted（只读）</h3><p>定义：指明事件是否是由浏览器（当用户点击实例后）或者由脚本（使用事件的创建方法，例如event.initEvent）启动。</p><h3 id="target与currentTarget的区别"><a href="#target与currentTarget的区别" class="headerlink" title="target与currentTarget的区别"></a>target与currentTarget的区别</h3><p>event.target返回触发事件的元素<br>event.currentTarget返回绑定事件的元素<br><a href="https://www.cnblogs.com/yewenxiang/p/6171411.html" target="_blank" rel="external">event对象中 target和currentTarget 属性的区别</a></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="document-createEvent-“UIEvents”"><a href="#document-createEvent-“UIEvents”" class="headerlink" title="document.createEvent(“UIEvents”)"></a>document.createEvent(“UIEvents”)</h3><p>创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化。</p><h3 id="event-initEvent-type-bubbles-cancelable"><a href="#event-initEvent-type-bubbles-cancelable" class="headerlink" title="event.initEvent(type, bubbles, cancelable)"></a>event.initEvent(type, bubbles, cancelable)</h3><p>定义：Event.initEvent() 方法可以用来初始化由Document.createEvent() 创建的 event 实例，且在触发之前event.dispatchEvent()。</p><h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h3><p>定义：如果此事件没有需要显式处理，那么它默认的动作也不要做（因为默认是要做的）。</p><h3 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation()"></a>event.stopPropagation()</h3><p>定义：阻止捕获和冒泡阶段中当前事件的进一步传播（只阻止当前侦听器）。</p><h3 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h3><p>定义：阻止调用相同事件的其他侦听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;值属性&quot;&gt;&lt;a href=&quot;#值属性&quot; class=&quot;headerlink&quot; title=&quot;值属性&quot;&gt;&lt;/a&gt;值属性&lt;/h1&gt;&lt;p&gt;这部分属性只是简单的值，它们没有自己的属性和方法。&lt;/p&gt;
&lt;h3 id=&quot;Infinity&quot;&gt;&lt;a href=&quot;#Infinity
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从对象的遍历到浅拷贝的思考</title>
    <link href="https://fanerge.github.io/2017/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E5%88%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%80%9D%E8%80%83.html"/>
    <id>https://fanerge.github.io/2017/从对象的遍历到浅拷贝的思考.html</id>
    <published>2018-03-14T12:17:36.000Z</published>
    <updated>2018-03-16T14:00:15.496Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有<span style="color: red;">String</span>类型，ES6之后对象的属性有<span style="color: red;">String和Symbol类型</span>。<br>由于文章上下文关系，本文将按照’属性描述符’-&gt;’对象的属性遍历方法介绍’-&gt;’现代ECMAScript对象的浅拷贝’进行介绍，现代ECMAScript对象的深拷贝比较复杂，有时间在分析。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。</p><h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p><h2 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</p><h2 id="属性描述符的读写操作"><a href="#属性描述符的读写操作" class="headerlink" title="属性描述符的读写操作"></a>属性描述符的读写操作</h2><p>我们可以通过Object.getOwnPropertyDescriptor(o,name)、Object.getOwnPropertyDescriptors(obj)来查看属性描述符，<br>通过Object.defineProperty(o,name,desc)、Object.defineProperties(o,descriptors)、Object.create(proto,descriptors)等方法来更改属性描述符。</p><h1 id="对象的属性遍历方法介绍"><a href="#对象的属性遍历方法介绍" class="headerlink" title="对象的属性遍历方法介绍"></a>对象的属性遍历方法介绍</h1><p>上面，我们了解了属性描述符，其中枚举这个属性描述符，在不同方法对对象属性的遍历过程产生的作用差异很大，下面我开始介绍如何遍历对象的属性。<br><strong>本小结的测试代码，我就不贴出来了，都很简单，我这里直接给出结论，感兴趣的朋友可以自己尝试。</strong></p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>定义：for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item in object) &#123;...&#125;</div><div class="line">// itme--在每次迭代时，将不同的属性名分配给变量。</div><div class="line">// object--被迭代枚举其属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.可以遍历对象自身和原型链上可枚举的属性<br>2.任意顺序，说明遍历的属性先后顺序不定（不同运行环境顺序不同）。不建议对数组使用for…in来遍历主要原因就是这个，另一方面为性能考虑for…in还会遍历到原型链上的可枚举属性。</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>定义：Object.keys() 方法会返回一个由该对象的自身的可枚举属性组成的数组。</p><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.keys(obj)</div><div class="line">// obj--要返回其枚举自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性是可枚举的<br>3.任意顺序，枚举属性的顺序和for…in/Object.getOwnPropertyNames(obj)一致<br>4.返回一个所有元素为字符串（不包括Symbol）的数组</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>定义：Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyNames(obj)</div><div class="line">// obj--一个对象，其自身的可枚举和不可枚举属性的名称被返回。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性了枚举和不可枚举都可以遍历<br>3.任意顺序，枚举属性的顺序和for…in/Object.keys(obj)一致</p><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>定义：Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertySymbols(obj)</div><div class="line">// obj--要返回 Symbol 属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性为Symbol类型</p><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><p>定义：Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Reflect.ownKeys(target)</div><div class="line">// target--获取自身属性键的目标对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>这里看，似乎能遍历出自身的所有属性，还差原型连上的属性。</p><h2 id="总结下上面的方法"><a href="#总结下上面的方法" class="headerlink" title="总结下上面的方法"></a>总结下上面的方法</h2><p>为了好归纳，我这里将对象的属性分为以下类别：1.自身可枚举的属性，2.自身不可枚举的属性，3.Symbol类型的属性，4.原型链上的可枚举属性，5.原型链上的不可枚举属性，6.原型链上的Symbol属性<strong>2018-03-16更新</strong></p><table><thead><tr><th>方法</th><th style="text-align:center">可遍历的属性类别</th></tr></thead><tbody><tr><td>for…in</td><td style="text-align:center">1，4</td></tr><tr><td>Object.keys()</td><td style="text-align:center">1</td></tr><tr><td>Object.getOwnPropertyNames()</td><td style="text-align:center">1，2</td></tr><tr><td>Object.getOwnPropertySymbols()</td><td style="text-align:center">3</td></tr><tr><td>Reflect.ownKeys()</td><td style="text-align:center">1，2，3</td></tr></tbody></table><p>从上表分析，还没有一个方法能完美解决，我们只能组合使用了。<br>PS：除了for…in其余方法均返回数组。</p><h1 id="现代ECMAScript对象的浅拷贝"><a href="#现代ECMAScript对象的浅拷贝" class="headerlink" title="现代ECMAScript对象的浅拷贝"></a>现代ECMAScript对象的浅拷贝</h1><p>本小节会我们会实现各种浅拷贝，并分析各自的劣势，最终我们将实现一种比较完美的方法（暂不考虑兼容性）。</p><h2 id="现看一个以前实现的方法"><a href="#现看一个以前实现的方法" class="headerlink" title="现看一个以前实现的方法"></a>现看一个以前实现的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function shallowCopy (obj) &#123;</div><div class="line">  if (typeof obj !== &apos;object&apos;) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  var newObj = obj instanceof Array ? [] : &#123;&#125;</div><div class="line">  for (var key in obj) &#123;</div><div class="line">    if (obj.hasOwnProperty(key)) &#123;</div><div class="line">      newObj[key] = obj[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return newObj</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这中方法对于ES6之前的确可行，毕竟我也用过这样的方法，有了Symbol之后这个就不再正确了。</p><h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><blockquote><p>   该方式在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。<br>不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的 对象 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们</p></blockquote><h2 id="Object-assign-和-展开运算符（…）"><a href="#Object-assign-和-展开运算符（…）" class="headerlink" title="Object.assign 和 展开运算符（…）"></a>Object.assign 和 展开运算符（…）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj2 = Object.assign(&#123;&#125;, obj)</div><div class="line">// obj2</div><div class="line">&#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个函数的定义：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>特点：自身的可枚举的包括Symbol类型的，不包括不可枚举的属性和原型链上的属性，不完美。</p><h2 id="Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors"><a href="#Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors" class="headerlink" title="Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()"></a>Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()</h2><p>首先需要介绍一下相关的方法，ES7的Object.getOwnPropertyDescriptors()。</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>定义：Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// 需要获取自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>4.包括了集体属性的描述符（value）<br>到这里似乎我们已经找到了，比较完美的解决方案了，我们来组合一下这3个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// obj为需要浅拷贝的对象</div><div class="line">let obj1 = Object.create(</div><div class="line">  Object.getPrototypeOf(obj), </div><div class="line">  Object.getOwnPropertyDescriptors(obj) </div><div class="line">)</div><div class="line">// obj1就是我们浅拷贝的得到的对象。</div></pre></td></tr></table></figure></p><p>PS：obj1对象通过Object.create()方法指定了自身的原型链（从原型链继承了相关属性），然后在通过Object.getOwnPropertyDescriptors()方法把自身的（包括可枚举的、不可枚举的、Symbol类型的）全部添加obj1上，这样是实现了我们的真正意义上的浅拷贝。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>数组的浅拷贝ary.slice()、 ary.concat()、[…ary]、JSON.parse(JSON.stringify(ary))<br><a href="https://fanerge.github.io/">期望加入一个技术氛围nice的团队-成都</a></p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="external">Object.getOwnPropertySymbols</a><br><a href="https://github.com/Alvin-Liu/Blog/issues/8" target="_blank" rel="external">ES6时代，你真的会克隆对象吗？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有&lt;span style=&quot;color: red;&quot;&gt;String&lt;/span&gt;类型，ES6之后对象的属性有&lt;span
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>梳理下浏览器对象模型知识（BOM）</title>
    <link href="https://fanerge.github.io/2018/%E6%A2%B3%E7%90%86%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%EF%BC%88BOM%EF%BC%89.html"/>
    <id>https://fanerge.github.io/2018/梳理下浏览器对象模型知识（BOM）.html</id>
    <published>2018-03-12T12:41:17.000Z</published>
    <updated>2018-03-16T14:03:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。</p><h1 id="BOM介绍"><a href="#BOM介绍" class="headerlink" title="BOM介绍"></a>BOM介绍</h1><p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。<br>浏览器对象模型的构成<br><img src="http://p5hb0ypha.bkt.clouddn.com/BOM.svg" alt="浏览器对象模型的构成"></p><h1 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h1><p>Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。<br>在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。</p><h2 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" alt="Window对象的属性"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" target="_blank" rel="external">看不清，点这里</a></p><h2 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" alt="Window对象的方法"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h1><p>Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。<br>Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。<br><img src="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" alt="Location对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h1><p>History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。<br><img src="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" alt="History对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h1><p>Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。<br><img src="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" alt="Navigator对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h1><p>Screen 对象包含有关用户屏幕的信息。<br><img src="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" alt="Screen对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h1><p>Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。<br><img src="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" alt="document对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。&lt;/p&gt;
&lt;h1 id=&quot;BOM介绍&quot;&gt;&lt;a href=&quot;#BOM介绍&quot; class=&quot;head
      
    
    </summary>
    
      <category term="BOM" scheme="https://fanerge.github.io/categories/BOM/"/>
    
    
      <category term="BOM" scheme="https://fanerge.github.io/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj2</title>
    <link href="https://fanerge.github.io/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj2.html"/>
    <id>https://fanerge.github.io/2018/前端常识-gj2.html</id>
    <published>2018-03-11T12:19:13.000Z</published>
    <updated>2018-03-11T13:08:28.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h1><ol><li>在浏览器地址栏输入URL</li><li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control<br>  HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期<br>  HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间    </li><li>浏览器解析URL获取协议，主机，端口，path    </li><li>浏览器组装一个HTTP（GET）请求报文    </li><li>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存<br>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li><li>打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z</li><li>TCP链接建立后发送HTTP请求    </li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序    </li><li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码    </li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作    </li><li>服务器将响应报文通过TCP连接发送回浏览器    </li><li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同    </li><li>如果资源可缓存，进行缓存    </li><li>对响应进行解码（例如gzip压缩）    </li><li>根据资源类型决定如何处理（假设资源为HTML文档）    </li><li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释    </li><li>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树    </li><li>解析过程中遇到图片、样式表、js文件，启动下载    </li><li>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</li><li>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式</li><li>js解析如下：<br>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading<br>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素<br>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</li><li>显示页面（HTML解析过程中会逐步显示页面）<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="CSS选择器有哪些"><a href="#CSS选择器有哪些" class="headerlink" title="CSS选择器有哪些"></a>CSS选择器有哪些</h2></li></ol><ul><li>通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+<br>#X id选择器：选择id值为X的元素，兼容性：IE6+<br>.X 类选择器： 选择class包含X的元素，兼容性：IE6+<br>X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+<br>X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+<br>:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+<br>X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+<br>X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+<br>X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+<br>[attr]：选择所有设置了attr属性的元素，兼容性IE7+<br>[attr=value]：选择属性值刚好为value的元素<br>[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素<br>[attr|=value]：选择属性值刚好为value或者value-开头的元素<br>[attr^=value]：选择属性值以value开头的元素<br>[attr$=value]：选择属性值以value结尾的元素<br>[attribute*=value]：选择属性值中包含value的元素<br>X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+<br>:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+<br>:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+<br>::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+<br>::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+<br>:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+<br>:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+<br>X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+<br>X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+<br>X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+<br>X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+<br>X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+<br>X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+<br>X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+<h2 id="css-sprite是什么-有什么优缺点"><a href="#css-sprite是什么-有什么优缺点" class="headerlink" title="css sprite是什么,有什么优缺点"></a>css sprite是什么,有什么优缺点</h2>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。<br>优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br>缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要从新布局整个图片，样式<h2 id="display-none-与visibility-hidden-的区别"><a href="#display-none-与visibility-hidden-的区别" class="headerlink" title="display: none;与visibility: hidden;的区别"></a>display: none;与visibility: hidden;的区别</h2>相同点：它们都能让元素不可见<br>区别：<br>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见<br>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式<br>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。<br>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容<h2 id="specified-value-computed-value-used-value计算方法"><a href="#specified-value-computed-value-used-value计算方法" class="headerlink" title="specified value,computed value,used value计算方法"></a>specified value,computed value,used value计算方法</h2>specified value: 计算方法如下：<br>  如果样式表设置了一个值，使用这个值<br>  如果没有设置值，这个属性是继承属性，从父元素继承<br>  如果没设置，并且不是继承属性，使用css规范指定的初始值及浏览器初始值<br>computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承<br>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局，<br>  background-position<br>  bottom, left, right, top<br>  height, width<br>  margin-bottom, margin-left, margin-right, margin-top<br>  min-height, min-width<br>  padding-bottom, padding-left, padding-right, padding-top<br>  text-indent<h2 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h2>  link是HTML方式， @import是CSS方式<br>  link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC无样式内容闪烁(Flash Of Unstyled Content)<br>  link可以通过rel=”alternate stylesheet”指定候选样式<br>  浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br>  @import必须在样式规则之前，可以在css文件中引用其他文件<br>  总体来说：link优于@import<h2 id="display-block-和display-inline-的区别"><a href="#display-block-和display-inline-的区别" class="headerlink" title="display: block;和display: inline;的区别"></a>display: block;和display: inline;的区别</h2>block元素特点：<br>  1.处于常规流中时，如果width没有设置，会自动填充满父容器<br>  2.可以应用margin/padding<br>  3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素<br>  4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）<br>  5.忽略vertical-align<br>inline元素特点<br>  1.水平方向上根据direction依次布局<br>  2.不会在元素前后进行换行<br>  3.受white-space控制<br>  4.margin/padding在竖直方向上无效，水平方向上有效<br>  5.width/height属性对非替换行内元素无效，宽度由元素内容决定<br>  6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定<br>  6.浮动或绝对定位时会转换为block<br>  7.vertical-align属性生效<h2 id="PNG-GIF-JPG-webp-svg的区别及如何选"><a href="#PNG-GIF-JPG-webp-svg的区别及如何选" class="headerlink" title="PNG,GIF,JPG,webp,svg的区别及如何选"></a>PNG,GIF,JPG,webp,svg的区别及如何选</h2>GIF:<br>  8位像素，256色<br>  无损压缩<br>  支持简单动画<br>  支持boolean透明<br>  适合简单动画<br>JPEG：<br>  颜色限于256<br>  有损压缩<br>  可控制压缩质量<br>  不支持透明<br>  适合照片<br>PNG：<br>  有PNG8和truecolor PNG<br>  PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画<br>  适合图标、背景、按钮<br>未来趋势：<br>  webp（google推出的图片格式，目前存在浏览器兼容）<br>  svg（矢量图如：iconfont）<h2 id="CSS有哪些继承属性"><a href="#CSS有哪些继承属性" class="headerlink" title="CSS有哪些继承属性"></a>CSS有哪些继承属性</h2>关于文字排版的属性如：<br>  font<br>  word-break<br>  letter-spacing<br>  text-align<br>  text-rendering<br>  word-spacing<br>  white-space<br>  text-indent<br>  text-transform<br>  text-shadow<br>line-height<br>color<br>visibility<br>cursor<h2 id="容器包含若干浮动元素时如何清理-包含-浮动"><a href="#容器包含若干浮动元素时如何清理-包含-浮动" class="headerlink" title="容器包含若干浮动元素时如何清理(包含)浮动"></a>容器包含若干浮动元素时如何清理(包含)浮动</h2>容器元素闭合标签前添加额外元素并设置clear: both<br>父元素触发块级格式化上下文(见块级可视化上下文部分)<br>设置容器元素伪元素进行清理推荐的清理浮动方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 在标准浏览器下使用</div><div class="line">* 1 content内容为空格用于修复opera下文档中出现</div><div class="line">*   contenteditable属性时在清理浮动元素上下的空白</div><div class="line">* 2 使用display使用table而不是block：可以防止容器和</div><div class="line">*   子元素margin-top折叠,这样能使清理效果与BFC，IE6/7</div><div class="line">*   zoom: 1;一致</div><div class="line">* 3 overflow: hidden;</div><div class="line">**/</div><div class="line"></div><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">    content: &quot; &quot;; /* 1 */</div><div class="line">    display: table; /* 2 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">.clearfix:after &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* IE 6/7下使用</div><div class="line">* 通过触发hasLayout实现包含浮动</div><div class="line">**/</div><div class="line">.clearfix &#123;</div><div class="line">    *zoom: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="什么是FOUC-如何避免"><a href="#什么是FOUC-如何避免" class="headerlink" title="什么是FOUC?如何避免"></a>什么是FOUC?如何避免</h2><p>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head使用link元素。</p><h2 id="什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用"><a href="#什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用" class="headerlink" title="什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用"></a>什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于布局中的普通流。<br>创建规则：<br>    根元素<br>    浮动元素（float不是none）<br>    绝对定位元素（position取值为absolute或fixed）<br>    display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素<br>    overflow不是visible的元素<br>作用：<br>    可以包含浮动元素（父布局overflow: hidden）<br>    不被浮动元素覆盖（两列自适应布局：子1浮动，子2不浮动且有overflow: hidden）<br>    阻止父子元素的margin折叠（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中）<br><img src="https://zhuanlan.zhihu.com/p/25321647" alt="https://zhuanlan.zhihu.com/p/25321647"></p><h2 id="display-float-position的关系"><a href="#display-float-position的关系" class="headerlink" title="display,float,position的关系"></a>display,float,position的关系</h2><p>如果display为none，那么position和float都不起作用，这种情况下元素不产生框<br>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。<br>否则，如果float不是none，框是浮动的，display根据下表进行调整<br>否则，如果元素是根元素，display根据下表进行调整<br>其他情况下display的值为指定值<br>总结起来：绝对定位、浮动、根元素都需要调整display</p><h2 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h2><p>毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下：<br>1.两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠<br>2.浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠<br>3.创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠<br>4.元素自身的margin-bottom和margin-top相邻时也会折叠</p><h2 id="如何确定一个元素的包含块-containing-block"><a href="#如何确定一个元素的包含块-containing-block" class="headerlink" title="如何确定一个元素的包含块(containing block)"></a>如何确定一个元素的包含块(containing block)</h2><p>1.根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。<br>2.position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成。<br>3.如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area<br>4.如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下：<br>    如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element.<br>    其他情况下包含块由祖先节点的padding edge组成<br>如果找不到定位的祖先元素，包含块为初始包含块</p><h2 id="stacking-context-布局规则"><a href="#stacking-context-布局规则" class="headerlink" title="stacking context,布局规则"></a>stacking context,布局规则</h2><p>z轴上的默认层叠顺序如下（从下到上）：<br>    根元素的边界和背景<br>    常规流中的元素按照html中顺序<br>    浮动块<br>    positioned元素按照html中出现顺序<br>如何创建stacking context：<br>    根元素<br>    z-index不为auto的定位元素<br>    a flex item with a z-index value other than ‘auto’<br>    opacity小于1的元素<br>    在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context</p><h2 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h2><p>如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现<br>如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。<br>如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto</p><h2 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h2><p>需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height<br><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="external">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术</a><br><a href="http://vanseodesign.com/css/vertical-centering/" target="_blank" rel="external">6 Methods For Vertical Centering With CSS</a></p><h1 id="JavaScript概念部分"><a href="#JavaScript概念部分" class="headerlink" title="JavaScript概念部分"></a>JavaScript概念部分</h1><h2 id="DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系"><a href="#DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系" class="headerlink" title="DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系"></a>DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</h2><p>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性<br>e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问<br>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）<br>e.propName返回值可能是字符串、布尔值、对象、undefined等<br>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性<br>一些布尔属性’<input hidden>‘的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property<br>像’<a href="../index.html">link</a>‘中href属性，转换成property的时候需要通过转换得到完整URL<br>一些attribute和property不是一一对应如：form控件中’input value=”hello”‘对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</p><h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h2><p>offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同<br>clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸</p><h2 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h2><p>1.readyState:表示请求状态的整数，取值：<br>    UNSENT（0）：对象已创建<br>    OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求<br>    HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到<br>    LOADING(3)：响应体正在接收<br>    DONE(4)：数据传输完成或者传输产生错误<br>2.onreadystatechange：readyState改变时调用的函数<br>3.status：服务器返回的HTTP状态码（如，200， 404）<br>4.statusText:服务器返回的HTTP状态信息（如，OK，No Content）<br>5.responseText:作为字符串形式的来自服务器的完整响应<br>6.responseXML: Document对象，表示服务器的响应解析成的XML文档<br>7.abort():取消异步HTTP请求<br>8.getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行<br>9.getResponseHeader(headerName):返回headName对应的报头值<br>10.open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证<br>11.setRequestHeader(name, value):设置HTTP报头<br>12.send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</p><h2 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h2><p>mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持<br>mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能<br>标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素</p><h2 id="sessionStorage-localStorage-cookie区别"><a href="#sessionStorage-localStorage-cookie区别" class="headerlink" title="sessionStorage,localStorage,cookie区别"></a>sessionStorage,localStorage,cookie区别</h2><p>都会在浏览器端保存，有大小限制，同源限制<br>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器<br>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie<br>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除<br>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享<br>localStorage的修改会促发其他文档窗口的update事件<br>cookie有secure属性要求HTTPS传输<br>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</p><h2 id="javascript跨域通信"><a href="#javascript跨域通信" class="headerlink" title="javascript跨域通信"></a>javascript跨域通信</h2><p>同源：两个文档同源需满足<br>    协议相同<br>    域名相同<br>    端口相同<br>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法<br>如果是log之类的简单单项通信，新建img,script,link,iframe元素，通过src，href属性设置为目标url。实现跨域请求<br>如果请求json数据，使用script进行jsonp请求<br>现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用<br>内部服务器代理请求跨域url，然后返回数据<br>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源</p><h2 id="javascript有哪几种数据类型"><a href="#javascript有哪几种数据类型" class="headerlink" title="javascript有哪几种数据类型"></a>javascript有哪几种数据类型</h2><p>六种基本数据类型<br>    undefined<br>    null<br>    string<br>    boolean<br>    number<br>    symbol(ES6)<br>一种引用类型<br>    Object</p><h2 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h2><p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：<br>    函数本身作用域。<br>    闭包定义时的作用域。<br>    全局作用域。<br>闭包常见用途：<br>    创建特权方法用于访问控制<br>    事件处理程序及回调</p><h2 id="javascript有哪几种方法定义函数"><a href="#javascript有哪几种方法定义函数" class="headerlink" title="javascript有哪几种方法定义函数"></a>javascript有哪几种方法定义函数</h2><p>函数声明表达式<br>function操作符<br>Function 构造函数<br>ES6:arrow function</p><h2 id="应用程序存储和离线web应用"><a href="#应用程序存储和离线web应用" class="headerlink" title="应用程序存储和离线web应用"></a>应用程序存储和离线web应用</h2><p>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:’<html manifest="myapp.appcache">‘，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"></div><div class="line">CACHE:</div><div class="line">myapp.html</div><div class="line">myapp.css</div><div class="line">myapp.js</div><div class="line"></div><div class="line">FALLBACK:</div><div class="line">videos/ offline_help.html</div><div class="line"></div><div class="line">NETWORK:</div><div class="line">cgi/</div></pre></td></tr></table></figure></html></p><h2 id="客户端存储localStorage和sessionStorage"><a href="#客户端存储localStorage和sessionStorage" class="headerlink" title="客户端存储localStorage和sessionStorage"></a>客户端存储localStorage和sessionStorage</h2><p>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前<br>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。<br>Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key</p><h2 id="cookie及其操作"><a href="#cookie及其操作" class="headerlink" title="cookie及其操作"></a>cookie及其操作</h2><p>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。<br>通过读写cookie检测是否支持<br>cookie属性有name，value，max-age，path, domain，secure；<br>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期<br>cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问<br>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下<br>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</p><h2 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h2><p>对象字面量： var obj = {};<br>构造函数： var obj = new Object();<br>Object.create(): var obj = Object.create(Object.prototype); // Object.create(proto[, propertiesObject])</p><h2 id="运算符判断相等的流程是怎样的"><a href="#运算符判断相等的流程是怎样的" class="headerlink" title="===运算符判断相等的流程是怎样的"></a>===运算符判断相等的流程是怎样的</h2><p>如果两个值不是相同类型，它们不相等<br>如果两个值都是null或者都是undefined，它们相等<br>如果两个值都是布尔类型true或者都是false，它们相等<br>如果其中有一个是NaN，它们不相等<br>如果都是数值型并且数值相等，他们相等， -0等于0<br>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同和=都认为他们不相等<br>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</p><h2 id="运算符判断相等的流程是怎样的-1"><a href="#运算符判断相等的流程是怎样的-1" class="headerlink" title="==运算符判断相等的流程是怎样的"></a>==运算符判断相等的流程是怎样的</h2><p>如果两个值类型相同，按照===比较方法进行比较<br>如果类型不同，使用如下规则进行比较<br>如果其中一个值是null，另一个是undefined，它们相等<br>如果一个值是数字另一个是字符串，将字符串转换为数字进行比较<br>如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较<br>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较<br>其他所有情况都认为不相等</p><h2 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h2><p>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果<br>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果<br>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</p><h2 id="对象到数字的转换步骤"><a href="#对象到数字的转换步骤" class="headerlink" title="对象到数字的转换步骤"></a>对象到数字的转换步骤</h2><ol><li>如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果</li><li>否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果</li><li>否则，throws a TypeError<h2 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;,&gt;,&lt;=,&gt;=的比较规则"></a>&lt;,&gt;,&lt;=,&gt;=的比较规则</h2>所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:<br>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错<br>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）<br>否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较<h2 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h2>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象<br>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参<br>arguments.length为实参的个数（Function.length表示形参长度）<br>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化<br>arguments.caller为调用当前函数的函数（已被遗弃）<br>转换为数组：var args = Array.prototype.slice.call(arguments, 0);    <h2 id="列举数组相关的常用方法"><a href="#列举数组相关的常用方法" class="headerlink" title="列举数组相关的常用方法"></a>列举数组相关的常用方法</h2>参考答案: push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter<h2 id="列举字符串相关的常用方法"><a href="#列举字符串相关的常用方法" class="headerlink" title="列举字符串相关的常用方法"></a>列举字符串相关的常用方法</h2>参考答案: indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase<h2 id="请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”"><a href="#请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”" class="headerlink" title="请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”"></a>请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];</div><div class="line">var date = new Date();</div><div class="line"></div><div class="line">console.log(&apos;今天是星期&apos; + days[date.getDay()]);</div></pre></td></tr></table></figure></li></ol><h2 id="js里的作用域是什么样子的？"><a href="#js里的作用域是什么样子的？" class="headerlink" title="js里的作用域是什么样子的？"></a>js里的作用域是什么样子的？</h2><p>参考答案：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined.</p><pre><code>var globalVar = &apos;global var&apos;;function test() {alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义var globalVar = &apos;overrided var&apos;; //　globalVar在本函数内被重定义alert(globalVar);　// overrided var}alert(globalVar); // global var，使用全局变量</code></pre><h2 id="js里边的this指的是什么"><a href="#js里边的this指的是什么" class="headerlink" title="js里边的this指的是什么?"></a>js里边的this指的是什么?</h2><p>参考答案: this指的是对象本身，而不是构造函数．    </p><h2 id="apply-call和bind有什么区别"><a href="#apply-call和bind有什么区别" class="headerlink" title="apply, call和bind有什么区别?"></a>apply, call和bind有什么区别?</h2><p>参考答案：三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，    </p><h2 id="caller-callee和arguments分别是什么"><a href="#caller-callee和arguments分别是什么" class="headerlink" title="caller, callee和arguments分别是什么?"></a>caller, callee和arguments分别是什么?</h2><p>参考答案: caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot;&gt;&lt;a href=&quot;#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot; class=&quot;headerlink&quot; title=&quot;从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)&quot;&gt;&lt;/a&gt;从
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Babel工作原理及Babel插件开发探索</title>
    <link href="https://fanerge.github.io/2018/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8ABabel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2.html"/>
    <id>https://fanerge.github.io/2018/Babel工作原理及Babel插件开发探索.html</id>
    <published>2018-03-04T12:46:18.000Z</published>
    <updated>2018-03-04T13:25:41.481Z</updated>
    
    <content type="html"><![CDATA[<p>在掘金上看见了<a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒</a>，正巧自己对Babel工作原理和Babel插件开发也不够了解，赶紧来补一波吧。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>首先我们这里需要了解一些基本的概念，<a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">这篇文章介绍的很详细</a>，我这边只提一下。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。<br>意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。<br>和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。<br>一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote><p>   静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。<br>静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p></blockquote><h1 id="Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）"><a href="#Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）" class="headerlink" title="Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）"></a>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接收代码并输出AST。这个步骤又分为两个阶段：词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段把字符串形式的代码转换成令牌（tokens）流。<br>你可以把令牌看作是一个扁平化的语法片段数组。<br>如：n*n代码经过词法分析转换成令牌<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// n*n</div><div class="line">[</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</div><div class="line">  ...</div><div class="line">]</div></pre></td></tr></table></figure></p><p>每一个type有一组属性来描述该令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &#123;</div><div class="line">    label: &apos;name&apos;,</div><div class="line">    keyword: undefined,</div><div class="line">    beforeExpr: false,</div><div class="line">    startsExpr: true,</div><div class="line">    rightAssociative: false,</div><div class="line">    isLoop: false,</div><div class="line">    isAssign: false,</div><div class="line">    prefix: false,</div><div class="line">    postfix: false,</div><div class="line">    binop: null,</div><div class="line">    updateContext: null</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析阶段会把一个令牌(tokens)流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。<br>这个过程我们可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">astexplorer</a>来查看我们代码生成的AST。<br>这个时候我们的AST就产生了，如下图。<br><img src="http://p52glq5m1.bkt.clouddn.com/ASTdemo1.png" alt="源代码到AST"><br>PS：上图左边为我们的源代码，右边为对应生成的抽象语法树AST。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。<br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。<br>Babel工作原理见下图表示。<br><img src="http://p52glq5m1.bkt.clouddn.com/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="Babel工作原理"><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">图片来源，探索 babel 和 babel 插件是怎么工作的</a></p><h1 id="开发一个Babel插件"><a href="#开发一个Babel插件" class="headerlink" title="开发一个Babel插件"></a>开发一个Babel插件</h1><h2 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a>Visitors（访问者）</h2><p>当我们谈及“进入”一个节点，实际上是说我们在访问它们， 之所以使用这样的术语是因为有一个访问者模式（visitor）的概念。<br>访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const MyVisitor = &#123;</div><div class="line">  Identifier: &#123;</div><div class="line">// 当进入Identifier节点的时候执行</div><div class="line">enter() &#123; </div><div class="line">  console.log(&quot;Entered&quot;);</div><div class="line">&#125;,</div><div class="line">// 当退出Identifier节点的时候执行</div><div class="line">exit() &#123;</div><div class="line">      console.log(&quot;Exited!&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>PS： 许多时候我们只需要关心进入节点，就可以使用简写 Identifier() { … } 或者 Identifier: { enter() { … } } 。<br>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier里面的enter方法和exit方法。</p><h2 id="Paths（路径）"><a href="#Paths（路径）" class="headerlink" title="Paths（路径）"></a>Paths（路径）</h2><blockquote><p>   我们通过 visitor可以在遍历到对应节点执行对应的函数，当需要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置 （即和其他节点间的关系）, visitor在遍历到对应节点执行对应函数时候会给我们传入 path参数，辅助我们完成上面这些操作。注意 Path 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了 Identifier节点，它传入的 path参数看起来是这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;parent&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;VariableDeclarator&quot;,</div><div class="line">    &quot;id&quot;: &#123;</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    ....</div><div class="line">  &#125;,</div><div class="line">  &quot;node&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;Identifier&quot;,</div><div class="line">    &quot;name&quot;: &quot;...&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里就可以通过：path.node.name 获得当前节点的name；path.parent.id 获得父节点的id<br>另外path对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。</p><h2 id="开始动手写插件了"><a href="#开始动手写插件了" class="headerlink" title="开始动手写插件了"></a>开始动手写插件了</h2><p>输入的源代码为：<br><code>yuzhenfan === wangkemei</code><br>生成的AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &quot;BinaryExpression&quot;,</div><div class="line">  operator: &quot;===&quot;,</div><div class="line">  left: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;,</div><div class="line">  right: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>省略部分属性，可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">http://astexplorer.net</a>查看全部属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const babel = require(&apos;babel-core&apos;)</div><div class="line"></div><div class="line">// 我们的babel插件</div><div class="line">let MyVisitor = function(&#123; types: t &#125;) &#123;</div><div class="line">  return &#123;</div><div class="line">    visitor: &#123;</div><div class="line"></div><div class="line">      BinaryExpression(path) &#123;</div><div class="line">  </div><div class="line">        if (path.node.operator !== &quot;===&quot;) &#123;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 改变当前节点的left、right（插件的核心代码）</div><div class="line">path.node.left = t.identifier(&quot;fanerge1&quot;);</div><div class="line">path.node.right = t.identifier(&quot;fanerge2&quot;);</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const code = `yuzhenfan === wangkemei;`;</div><div class="line"></div><div class="line">let demo = babel.transform(code, &#123;</div><div class="line">  // 使用我们的插件</div><div class="line">  plugins: [MyVisitor]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(demo); // fanerge1===fanerge2</div></pre></td></tr></table></figure></p><p>输出的代码为（经过我们的插件处理）：<br><code>fanerge1===fanerge2</code><br>下图为node打印出Balbel输出的代码：<br><img src="http://p52glq5m1.bkt.clouddn.com/result.png" alt="babel转换的代码"><br><a href="https://github.com/fanerge/babel_plugin" target="_blank" rel="external">项目地址，非常简单的Babel插件，后续再继续学习</a></p><blockquote><p>   参考文档<br><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-introduction" target="_blank" rel="external">Babel 插件手册</a><br><a href="https://github.com/estree/estree" target="_blank" rel="external">ESTree</a><br><a href="http://astexplorer.net/" target="_blank" rel="external">AST Explorer</a><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">探索 babel 和 babel 插件是怎么工作的</a><br><a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">掘金-babel插件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在掘金上看见了&lt;a href=&quot;https://juejin.im/post/5a9315e46fb9a0633a711f25&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒&lt;/a&gt;，正
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="Babel" scheme="https://fanerge.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>浏览器工作原理-webkit内核研究</title>
    <link href="https://fanerge.github.io/2018/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html"/>
    <id>https://fanerge.github.io/2018/浏览器工作原理-webkit内核研究.html</id>
    <published>2018-03-03T02:10:00.000Z</published>
    <updated>2018-03-17T12:32:49.119Z</updated>
    
    <content type="html"><![CDATA[<p>从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。<br>主要查阅了<a href="https://book.douban.com/subject/25910556/" target="_blank" rel="external">WebKit技术内幕</a>、<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>、<a href="https://www.w3.org/" target="_blank" rel="external">W3C</a>等网站资料，下文中有若干图片摘自于《WebKit技术内幕》，在此表示感谢。<br>本文略长，如有不适，实属意外。如有不正确的地方，还望指正，毕竟传播真理才不会误导其他同学，共同进步才是目的。</p><h1 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h1><p>浏览器内核由渲染引擎和JS引擎组成，不同的浏览器、即使同一浏览器不同型号可能渲染引擎和JS引擎都不一样。</p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>1)Trident渲染引擎 –&gt; 老版本IE系列浏览器<br>2)Edge渲染引擎 -&gt; Win10中IE浏览器<br>3)Gecko渲染引擎 –&gt; Mozilla Firefox<br>4)Presto渲染引擎 –&gt; Opera<br>5)KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome<br>6)Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器<br>7)Blink渲染引擎 -&gt; 新版本的Chromium浏览器Google项目</p><h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h2><p>1)JScript引擎 –&gt; IE系列浏览器<br>2)spiderMonkey引擎 –&gt; Mozilla Firefox<br>3)V8引擎 –&gt; Google Chrome<br>4)linear b/futhark引擎 –&gt; Opera</p><h2 id="浏览器渲染引擎的进度史"><a href="#浏览器渲染引擎的进度史" class="headerlink" title="浏览器渲染引擎的进度史"></a>浏览器渲染引擎的进度史</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" alt="浏览器渲染引擎的进度史"><br>为大家提供两个开发常用查询网站：<br><a href="http://html5test.com/" target="_blank" rel="external">该浏览器对html5的支持程度</a><br><a href="https://caniuse.com" target="_blank" rel="external">不同与Can I use</a></p><h1 id="浏览器的渲染引擎及依赖模块分析"><a href="#浏览器的渲染引擎及依赖模块分析" class="headerlink" title="浏览器的渲染引擎及依赖模块分析"></a>浏览器的渲染引擎及依赖模块分析</h1><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%9F%E8%83%BD.png" alt="渲染引擎的功能"><br>上图中虚线部分表示渲染引擎所提供的功能。<br>这里渲染引擎包含了JavaScript引擎，许多时候两者都不太区分。<br>下面的内容大部分都是基于这张图来分析的，我们将逐步解释从用户输入URL到页面展示给用户这个过程中都发生了什么？<br>我们先了解网页的基础知识。</p><h1 id="网页基础知识"><a href="#网页基础知识" class="headerlink" title="网页基础知识"></a>网页基础知识</h1><p>html – 结构<br>css – 样式<br>JavaScript – 行为<br>还需要一些静态资源：png、gif、webp、MP4、font、svg等等。<br>由上面几部分就构成我们的网页。</p><h2 id="输入URL到页面展示简图"><a href="#输入URL到页面展示简图" class="headerlink" title="输入URL到页面展示简图"></a>输入URL到页面展示简图</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/url%E5%88%B0dom%E6%A0%91.png" alt="URL到页面展示"><br>读者不要太关心上图所标的顺序，在某些时候可能会有出入。</p><h2 id="浏览器内核各部分解释"><a href="#浏览器内核各部分解释" class="headerlink" title="浏览器内核各部分解释"></a>浏览器内核各部分解释</h2><blockquote><p>   HTML解释器：解释HTML文本的解释器，主要作用是将HTML文本解释成DOM树，DOM是一种文档表示方法。<br>CSS解释器：级联样式表的解释器，它的作用是为DOM中的各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。<br>布局：在DOM创建之后，webkit需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部比偶表示模型。<br>JavaScript引擎：使用JavaScript代码可以修改网页的内容，也能修改CSS的信息，JavaScript引擎能过解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染结果。<br>绘图：使用图形库将布局计算后的各个网页的节点绘制成图像结果。</p></blockquote><p>PS：这些模块依赖许多其他基础模块，其中包括网络、存储、2D/3D图形、音频视频和图片解码器等。这里就不对基础模块做相应说明了。</p><p>下面，我就逐个过程进行分析，我这里省略一些非本文目的的过程，如DNS环节。</p><h1 id="HTML解释器"><a href="#HTML解释器" class="headerlink" title="HTML解释器"></a>HTML解释器</h1><p>先来看看HTML解释器工作原理<br><img src="http://p4yvw0vpm.bkt.clouddn.com/html%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="HTML解释器工作原理"><br>字节流（Bytes）–&gt; 字符流（Characters）–&gt; 词语（Tokens）–&gt; 节点 –&gt; DOM树</p><blockquote><p>   首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），时候经过分析器构建成节点，最后这些节点被组建成一棵DOM树。<br>词法分析：HTMLTokenizer 类（作用是词法分析，类似于状态机），输入的是字符串，输出的是一个个的词语。<br>XSSAuditor验证词语：XSSAuditor （验证词语流Token Stream）XSS指的是Cross Site Security，主要是针对安全方面的考虑。<br>词语到节点：webkit用来构建DOM节点，这一步骤由HTMLDocumentParser 类调用 HTMLTreeBuilder 类的 constructTree的函数来实现。<br>节点到DOM树：树中的元素节点创建属性节点等工作由HTMLConstructionSite类来完成，该类中包含一个 HTMLElementStack 作为保存元素节点的栈。<br>JavaScript的执行：webkit将DOM树创建过程中需要执行得我Javascript代码交由HTMLScriptRunner类来负责。<br>DOM的事件机制：webkit中用EventTarget类来表示DOM规范中Events部分定义的事件目标，Node 节点继承自 EventTarget类，所以Node拥有EventTarget类的相关的方法。</p></blockquote><p>这里需要提一下W3C新规范，影子（Shadow）DOM<br>Shadow DOM API的 ShadowRoot接口是一个DOM子树的根节点, 它与文档的主DOM树分开渲染。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ShadowRoot" target="_blank" rel="external">MDN-影子节点</a></p><h2 id="影子（Shadow）DOM"><a href="#影子（Shadow）DOM" class="headerlink" title="影子（Shadow）DOM"></a>影子（Shadow）DOM</h2><p>定义：Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。<br>ShadowRoot 类继承自 DocumentFragment 类。<br>PS：可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.</p><h1 id="CSS解释器和样式布局"><a href="#CSS解释器和样式布局" class="headerlink" title="CSS解释器和样式布局"></a>CSS解释器和样式布局</h1><p>先看看CSS怎么和DOM结合展示页面的呢？<br><img src="http://p4yvw0vpm.bkt.clouddn.com/css%E5%92%8Cdom%E6%A0%91%E5%88%B0%E7%BB%98%E5%88%B6%E7%BD%91%E9%A1%B5.png" alt="CSS+DOM形成简单页面"><br>css解释器和规则匹配处于DOM树建立之后，RenderObject树建立之前，css解释器解释后的结果会保存起来，然后RenderObject树基于该结果来进行规范匹配和布局计算。</p><h2 id="CSSOM（CSS-Object-Model）"><a href="#CSSOM（CSS-Object-Model）" class="headerlink" title="CSSOM（CSS Object Model）"></a>CSSOM（CSS Object Model）</h2><p>CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动。<br>document.styleSheets 可以查看当前页面的StyleSheetList对象，每个link、style都会产生 CSSStyleSheet 作为 StyleSheetList对象的value。</p><h2 id="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"><a href="#CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）" class="headerlink" title="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"></a>CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）</h2><p>DocumentStyleSheetCollection类（属于Document类），该类包含了所有CSS样式表，还包括了webkit的内部表示类CSSStyleSheet，它包含了CSS的href、类型、内容等信息。<br>CSS解释过程：css字符串经过css解释器处理后变成渲染引擎的内部规则的过程，使用CSSParser类来负责该过程。<br>在解释网页中自定义的CSS样式之前，实际上webkit渲染引擎会为每个网页设置一个默认样式，这也是我们为什么要重置浏览器样式的根本原因。<br>规则匹配：StyleResolver类为DOM的元素节点匹配样式，StyleResolver类根据元素的信息，例如标签名、类别等，从样式规则中查找最匹配的规则，然后将样式信息保存到新建的RenderStyle对象中。最后，这些RenderStyle对象被RenderObject类所管理和使用。<br>    其中，规则的匹配则是由ElementRuleCollector类来计算并获得，它根据元素的属性等信息，并从DocumentRuleSets类中获取规则集合，依次按照ID、CLASS、标签等选择器信息逐次匹配获得元素的样式。<br>    然后webkit对这些规则进行排序，对于该元素需要的样式属性，webkit选择从高优先级规则中选取，并将样式属性值返回。<br>这里，我引入一个不太相关的知识点，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">不太了解的同学，请异步MDN-BFC</a></p><h1 id="webkit布局"><a href="#webkit布局" class="headerlink" title="webkit布局"></a>webkit布局</h1><p>当webkit创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息的过程称为布局计算/排版。<br>    布局计算分类：第一类是对整个RenderObject树进行的计算；第二类是对RenderObject树中某个子树的计算，常见于文本元素或者overflow：auto块的计算。<br>    布局计算：布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。</p><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>我们常说的reflow和repaint。涉及到元素的几何属性改变会造成reflow会降低性能（transform、opacity等属性不会造成reflow）。<br>扩展为什么说transform实现动画较直接设置几何属性性能较好？<br>1.webkit渲染过程：style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite，transform是位于’Composite（渲染层合并）‘，而width、left、margin等则是位于‘Layout（布局）’层，这必定导致reflow。<br>2.现代浏览器针对transform等开启GPU加速。<br>    style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite（transform发生在这个时候）<br>由这个过程我们可以看出，这也是为什么发生reflow必定会发生repaint的根本原因。<br><a href="https://www.w3cplus.com/animation/animation-performance.html" target="_blank" rel="external">CSS Animation性能优化</a><br><a href="https://segmentfault.com/a/1190000008650975" target="_blank" rel="external">从重绘重排角度讲解transform的动画性能</a></p><h1 id="渲染过程的一些理论"><a href="#渲染过程的一些理论" class="headerlink" title="渲染过程的一些理论"></a>渲染过程的一些理论</h1><p>RenderObject树同其他树（如RenderLayer树等），构成了webkit渲染的主要基础设施。</p><h2 id="RenderObject树（DOM树-gt-RenderObject树）"><a href="#RenderObject树（DOM树-gt-RenderObject树）" class="headerlink" title="RenderObject树（DOM树 -&gt; RenderObject树）"></a>RenderObject树（DOM树 -&gt; RenderObject树）</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/DOM%E5%88%B0RenderObject.png" alt="DOM到RenderObject"><br>一个RenderObject对象保存了为绘制DOM节点所需要的各种信息，例如样式布局信息，经过webkit的处理之后，RenderObject对象知道如何绘制自己。<br>下列情况会使DOM树节点创建一个RenderObject对象（DOM和RenderObject并非一一对应）。<br>1.DOM树的document节点。<br>2.DOM树种的可视节点，例如html、body、div等。而webkit不会为非可视化节点创建RenderObject节点，例如meta、script。<br>3.某些情况下webkit需要建立匿名的RenderObject节点，该节点不对应于DOM树种的任何节点，而是webkit处理上的需要，典型的例子例如匿名的RenderBlock节点。<br>在html组建页面结构时，webkit为了提升网页性能，会引入分层结构。</p><h2 id="网页层次结构（css也会对网页的分层策略产生重要影响）"><a href="#网页层次结构（css也会对网页的分层策略产生重要影响）" class="headerlink" title="网页层次结构（css也会对网页的分层策略产生重要影响）"></a>网页层次结构（css也会对网页的分层策略产生重要影响）</h2><p>对于一个html文件webkit会为某些元素和它的子节点建立新层，这样webkit可以单独对某层操作提升性能，下列情况会产生新层。<br>1.video标签 – webkit在新层中有效的处理视频解码器和浏览器之间的交互和渲染问题。<br>2.div、p等普通标签 – 涉及到3D变换时。<br>3.canvas标签 – 复杂的2D和3D绘图操作。</p><h2 id="RenderLayer树"><a href="#RenderLayer树" class="headerlink" title="RenderLayer树"></a>RenderLayer树</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/RenderObject%E5%88%B0RenderLayer.png" alt="RenderObject到RenderLayer"><br>webkit会为网页的层次创建相应的RenderLayer对象。当某些类型RenderObject的节点或者某些css样式的RenderObject节点出现的时候，webkit就会为这些节点创建RenderLayer对象。<br>RenderLayer树是基于RenderObject树建立起来的一棵新树。RenderLayer节点和RenderObject节点不是一一对应关系，而是一对多的关系。<br>哪些情况下的RenderObject节点需要建立新的RenderLayer节点呢？<br>1.DOM树的Document节点对应的RenderView节点。<br>2.DOM树中的Document的子节点，也就是HTML节点对应RenderBlock节点。<br>3.显式的制定css位置的RenderObject节点。<br>4.有透明效果的RenderObject节点。<br>5.节点有溢出（overflow）、alpha或者反射效果的RenderObject节点。<br>6.使用Canvas 2D和3D（WebGL）技术的RenderObject节点。<br>7.Video节点对应的RenderObject节点。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><p>绘图上下文（绘图上下文可以分成两种类型）：<br>    第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）。<br>    第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）。<br>网页的三种渲染方式：<br>1.软件渲染（CPU内存）<br>2.使用软件绘图的合成化渲染（GPU内存）css3D、WebGL<br>3.硬件加速的合成化渲染（GPU内存）</p><h2 id="webkit软件渲染技术"><a href="#webkit软件渲染技术" class="headerlink" title="webkit软件渲染技术"></a>webkit软件渲染技术</h2><p>在不需要硬件加速内容的时候（包括但不限于css3 3D变形、css3 3D变换、WebGL和视频），webkit就可以使用软件渲染技术来完成页面绘制。<br>对于每个RenderObject对象，需要三个阶段绘制自己：<br>第一阶段是绘制该层中所有块的背景和边框。<br>第二阶段是绘制浮动内容。<br>第三阶段是前景（Foreground），也就是内容部分、轮廓、字体颜色、大小等（内嵌元素的背景、边框等发生在这一阶段）。</p><h2 id="硬件加速机制"><a href="#硬件加速机制" class="headerlink" title="硬件加速机制"></a>硬件加速机制</h2><p>硬件加速技术是指使用GPU的硬件能力来帮助渲染网页（GPU的作用主要是用来绘制3D图形并且性能特别好）。</p><h3 id="Chrome的硬件加速机制"><a href="#Chrome的硬件加速机制" class="headerlink" title="Chrome的硬件加速机制"></a>Chrome的硬件加速机制</h3><p>canvas开发，可以将画布分解为更小的画布，这样在更新时只需要更新小画布从而减少开销。<br>css3 3D变形技术，它能过让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果（只触发Composite而不用触发style -&gt; Layout(reflow发生在这) -&gt; Paint）。</p><h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><p>WebGL是Khronous组织提出的一套基于3D图形定义的javascript接口。<br>它基于canvas元素，跟canvas2D不同的是，Web开发者可以使用3D图形接口来绘制各种3D图形。</p><h3 id="css-3D变形"><a href="#css-3D变形" class="headerlink" title="css 3D变形"></a>css 3D变形</h3><p>这里包括3D变形和动画。<br>webkit会建立一个新层来处理，从而提升性能。</p><h1 id="JavaScript引擎-1"><a href="#JavaScript引擎-1" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h1><p>推动JavaScript运行速度提高的利器JIT（Just-In-Time）。<br>JIT：就是代码在目标平台上运行的时候，实时的把代码编译为目标机器上的机器码。<br>编译原理：<br>C++：源代码 –&gt; 抽象语法树 –&gt; 本地代码<br>Java：源代码 –&gt; 抽象语法树  –&gt; 字节码（跨平台） –&gt; JIT –&gt; 本地代码</p><h2 id="V8的一些特性（这里太多了，读者可以自己深究）"><a href="#V8的一些特性（这里太多了，读者可以自己深究）" class="headerlink" title="V8的一些特性（这里太多了，读者可以自己深究）"></a>V8的一些特性（这里太多了，读者可以自己深究）</h2><p>常用的javascript引擎有v8和JavaScriptCore<br>工作原理<br>在js中，基本数据类型Boolean、Number、String、Null、Undefined、Symbol，其他数据都是对象。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>在V8中，数据的表示分成两个部分<br>    第一部分是数据的实际内容，它们是变长的，而且内容的类型也不一样，如String、对象等。<br>    第二部分是数据的句柄，句柄的大小是固定的，句柄中包含指向数据的指针。</p><h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>Handle：句柄类，主要用来管理基础数据和对象，以便被垃圾回收器操作。<br>主要有两个类型，一个Local类（继承自Handle类），表示本地栈上的数据，所以比较轻量。<br>另一个是Persistent类（继承自Handle类）表示函数间的数据和对象访问。<br>对于整形数据，由Handle本身来存储，同时也为了快速访问。<br>其他的数据都是从堆中申请内存来存储它们，由于其他数据类型，受限于Handle的大小和变长等原因，都存储在堆中。<br>V8的延迟（deferred）特性：它使的许多javascript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销。<br><img src="http://p4yvw0vpm.bkt.clouddn.com/javascript%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81.png" alt="v8将源代码-本地代码"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="常见的语言类型"><a href="#常见的语言类型" class="headerlink" title="常见的语言类型"></a>常见的语言类型</h3><p>机器语言（它是计算机唯一能直接执行的语言，电子计算机的机器指令是一列二进制数字。）<br>汇编语言 汇编指令是机器指令便于记忆的书写格式，但他需要进过编译器转换为机器语言，这样机器才能执行。</p><h3 id="使用setTimeout或setInterval较requestAnimationFrame的缺点？"><a href="#使用setTimeout或setInterval较requestAnimationFrame的缺点？" class="headerlink" title="使用setTimeout或setInterval较requestAnimationFrame的缺点？"></a>使用setTimeout或setInterval较requestAnimationFrame的缺点？</h3><p>时间间隔应该设置为多少才合适呢。<br>跟屏幕的分辨率有关吗（不同浏览器存在一个极小值）。<br>设置的时间会按照会准确执行吗。<br>动画会被平滑地显示效果吗。<br>回调函数时复杂的好还是简单的好呢。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame</a></p><h1 id="其他浏览器相关知识"><a href="#其他浏览器相关知识" class="headerlink" title="其他浏览器相关知识"></a>其他浏览器相关知识</h1><h2 id="插件和Javascript扩展"><a href="#插件和Javascript扩展" class="headerlink" title="插件和Javascript扩展"></a>插件和Javascript扩展</h2><p>在早期的浏览器能力十分有限，Web前端开发者们希望能够通过一些机制来扩展浏览器的能力（插件机制如flash插件）。</p><h3 id="NPAPI全称叫-Netscape-plugin-API"><a href="#NPAPI全称叫-Netscape-plugin-API" class="headerlink" title="NPAPI全称叫 Netscape plugin API"></a>NPAPI全称叫 Netscape plugin API</h3><p>NPAPI是当今最流行的插件架构，几乎所有浏览器都支持，不过存在很大的安全隐患，插件可以窃取系统底层权限，发起恶意攻击。</p><h3 id="PPAPI也就是Pepper-Plugin-API"><a href="#PPAPI也就是Pepper-Plugin-API" class="headerlink" title="PPAPI也就是Pepper Plugin API"></a>PPAPI也就是Pepper Plugin API</h3><p>2010年，Google开发了新的PPAPI，将外挂插件全部放到沙盒里运行，2012年Windows、Mac版本的Chrome浏览器先后升级了PPAPI Flash Player，并希望今年底之前彻底淘汰NPAPI。</p><h2 id="JavaScript引擎的扩展机制"><a href="#JavaScript引擎的扩展机制" class="headerlink" title="JavaScript引擎的扩展机制"></a>JavaScript引擎的扩展机制</h2><p>通过如下url参看当前chrome浏览器安装的extensions<br>chrome://extensions/ </p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><p>WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="external">MDN-WebRTC</a><br>最重要的方法：navigator.mediaDevices.getUserMedia(constraints)<br>还有Video、Audio等。</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><p>第一部分是网页的安全，包括但是不限于网页数据安全传输、跨域访问、用户数据安全等。<br>第二部分是浏览器的安全，具体是指虽然网页或者Javascript代码有一些安全问题或者存在安全漏洞，浏览器也能够在运行它们的时候保证吱声的安全，不受到攻击从而泄漏数据或者使系统遭受破坏。</p><h3 id="网页安全模型"><a href="#网页安全模型" class="headerlink" title="网页安全模型"></a>网页安全模型</h3><p>安全模型基础：<br>域（Same Origin Policy）XMLHttpRequest、cookie的读写、DOM对象操作等。<br>XSS（Cross Site Scripting）执行跨域的js脚本代码。开发者可以将用户输入的数据进行字符转换来避免。webkit通过XSSAuditor对象帮我们过滤（默认开启）。<br>CSP （Content-Security-Policy）HTTP首部字段，内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。<br>CORS（Cross Origin Resource Sharing）跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。<br>    具体服务端代码设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 请求头</div><div class="line">header(&apos;Access-Control-Allow-Origin: http://arunranga.com&apos;); // </div><div class="line">header(&apos;Access-Control-Allow-Methods: POST, GET, OPTIONS&apos;);</div><div class="line">header(&apos;Access-Control-Allow-Headers: X-PINGARUNER&apos;);</div><div class="line">// 响应头</div><div class="line">Access-Control-Allow-Origin、</div><div class="line">Access-Control-Allow-Credentials、</div><div class="line">Access-Control-Allow-Headers、</div><div class="line">Access-Control-Expose-Headers、</div><div class="line">Access-Control-Allow-Methods、</div><div class="line">Access-Control-Max-Age</div></pre></td></tr></table></figure></p><p>Cross Document Messaging 通过 window.postMessage 和 message 事件来通信。<br>HTTPS（安全传输协议）<br>SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。    SPDY核心思想为多路复用。<br>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。</p><h4 id="CSP和CORS的区别："><a href="#CSP和CORS的区别：" class="headerlink" title="CSP和CORS的区别："></a>CSP和CORS的区别：</h4><p>CSP定义了网页自身能够访问的某些域和资源。<br>CORS定义一个网页如何才能访问被同源策略禁止的跨域资源，并规定了两者交互的协议和方式。</p><h3 id="沙箱模型"><a href="#沙箱模型" class="headerlink" title="沙箱模型"></a>沙箱模型</h3><p>浏览器的沙箱模型是利用系统提供的安全技术，让网页在执行过程中不会修改操作系统或者是访问系统中的隐私数据，而需要访问系统资源或者说是系统调用的时候，通过一个代理机制来完成。</p><h1 id="chrome浏览其使用技巧（以实用性排列）"><a href="#chrome浏览其使用技巧（以实用性排列）" class="headerlink" title="chrome浏览其使用技巧（以实用性排列）"></a>chrome浏览其使用技巧（以实用性排列）</h1><p>一下url直接输入在浏览器中，enter即可</p><table><thead><tr><th>URL</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>chrome://inspect</td><td style="text-align:center">移动端网页调试</td></tr><tr><td>chrome://net-internals</td><td style="text-align:center">net-internals是一套工具集合，用于帮助诊断网络请求与访问方面的问题，它通过监听和搜集 DNS，Sockets，SPDY，Caches等事件与数据来向开发者反馈各种网络请求的过程、状态以及可能产生影响的因素。如，查看DNS主机解析缓存chrome://net-internals/#dns</td></tr><tr><td>chrome://view-http-cache/</td><td style="text-align:center">查看内部存储内容及其详情</td></tr><tr><td>chrome://downloads/</td><td style="text-align:center">下载内容管理，其快捷键是Ctrl+J</td></tr><tr><td>chrome://extensions/</td><td style="text-align:center">扩展管理</td></tr><tr><td>chrome://bookmarks/</td><td style="text-align:center">书签管理  </td></tr><tr><td>chrome://history</td><td style="text-align:center">访问历史管理  </td></tr><tr><td>chrome://restart</td><td style="text-align:center">重启chrome浏览器 </td></tr><tr><td>chrome://apps</td><td style="text-align:center">chrome网上应用店  </td></tr><tr><td>chrome://flags/</td><td style="text-align:center">新特性管理 </td></tr><tr><td>chrome://dns</td><td style="text-align:center">查看DNS预取命名（从超链接等处来预测）  </td></tr><tr><td>chrome://quota-internals</td><td style="text-align:center">查看浏览器所使用磁盘空间配额 </td></tr><tr><td>chrome://settings</td><td style="text-align:center">浏览器的设置</td></tr><tr><td>chrome://sync-internals</td><td style="text-align:center">查看chrome 的同步状态 </td></tr><tr><td>chrome://about/</td><td style="text-align:center">查看所有chrome命令 </td></tr></tbody></table><p><a href="https://fanerge.github.io">期望加入一个技术氛围nice的团队-成都</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。&lt;br&gt;主要查阅了&lt;a href=&quot;https://book.douban.com/subject/25
      
    
    </summary>
    
      <category term="webkit" scheme="https://fanerge.github.io/categories/webkit/"/>
    
    
      <category term="浏览器" scheme="https://fanerge.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
