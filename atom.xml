<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-09-05T14:38:59.140Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node-学习（七天学会NodeJs）</title>
    <link href="https://fanerge.github.io/2017/09/05/node-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/05/node-学习/</id>
    <published>2017-09-05T14:32:47.000Z</published>
    <updated>2017-09-05T14:38:59.140Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NodeJs基础"><a href="#NodeJs基础" class="headerlink" title="NodeJs基础"></a>NodeJs基础</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><pre><code>在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。
</code></pre><h6 id="require"><a href="#require" class="headerlink" title="require"></a>require</h6><pre><code>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var foo1 = require(&apos;./foo&apos;);</div><div class="line">var foo2 = require(&apos;./foo.js&apos;);</div><div class="line">var foo3 = require(&apos;/home/user/foo&apos;);</div><div class="line">var foo4 = require(&apos;/home/user/foo.js&apos;);</div><div class="line">// foo1至foo4中保存的是同一个模块的导出对象。</div></pre></td></tr></table></figure>

还可以加载使用JSON文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var data = require(&apos;./data.json&apos;);</div></pre></td></tr></table></figure>
</code></pre><h6 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h6><pre><code>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。
以下例子中导出了一个公有方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = function () &#123;</div><div class="line">	console.log(&apos;fanerge&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h6 id="module"><a href="#module" class="headerlink" title="module"></a>module</h6><pre><code>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。
例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = function () &#123;</div><div class="line">	console.log(&apos;fanerge&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h4 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h4><h5 id="模块路径的解析规则（先后顺序）"><a href="#模块路径的解析规则（先后顺序）" class="headerlink" title="模块路径的解析规则（先后顺序）"></a>模块路径的解析规则（先后顺序）</h5><ol>
<li>内置模块<br>如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(‘fs’)。</li>
<li><p>node_modules目录（第三方包）<br>NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/user/node_modules/foo/bar</div><div class="line">/home/node_modules/foo/bar</div><div class="line">/node_modules/foo/bar</div></pre></td></tr></table></figure>
</li>
<li><p>NODE_PATH环境变量<br>与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_PATH=/home/user/lib:/home/lib</div></pre></td></tr></table></figure>
<p>当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/home/user/lib/foo/bar</div><div class="line">/home/lib/foo/bar</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h5><pre><code>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。
示例一个标准包：
-cat:
    doc -- 包说明文档
    -lib -- 包具体代码
        head.js
        body.js
        index.js -- 入口文件
    tests -- 测试用例
    package.json -- 包的说明及依赖关系
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// index.js具体代码</div><div class="line">var head = require(&apos;./head&apos;);</div><div class="line">var body = require(&apos;./body&apos;);</div><div class="line">exports.create = function (name) &#123;</div><div class="line">	return &#123;</div><div class="line">		name: name,</div><div class="line">		head: head.create(),</div><div class="line">		body: body.create()</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line">// package.json具体代码</div><div class="line">&#123;</div><div class="line">	&quot;name&quot;: &quot;cat&quot;,</div><div class="line">	&quot;main&quot;: &quot;./lib/index.js&quot; // 入口模块位置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h5><pre><code>一个标准的工程目录
/home/user/workspace/node-echo/ # 工程目录
    -bin/                       # 存放命令行相关代码
        node-echo
    +doc/                       # 存放文档
    -lib/                       # 存放API相关代码
        echo.js
    -node_modules/              # 存放第三方包
        babel
    +tests/                     # 存放测试用例
    package.json                # 元数据文件
    README.md                    # 说明文件
</code></pre><h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><pre><code>安装第三方包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install argv</div></pre></td></tr></table></figure>

安装第三方包（特定版本）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install argv@0.0.1</div></pre></td></tr></table></figure>

批量安装
还可以在package.json中dependencies字段中写入所有依赖包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">       &quot;argv&quot;: &quot;0.0.2&quot;,</div><div class="line">	...</div><div class="line">   &#125;</div><div class="line">// 在使用指令批量安装</div><div class="line">npm install</div></pre></td></tr></table></figure>

更新包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm update &lt;package&gt;</div></pre></td></tr></table></figure>

清除NPM本地缓存
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm cache clear（用于对付使用相同版本号发布新版本代码的人）</div></pre></td></tr></table></figure>
</code></pre><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="文件拷贝练手"><a href="#文件拷贝练手" class="headerlink" title="文件拷贝练手"></a>文件拷贝练手</h5><pre><code>// copy.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">function copy(src, dst) &#123;</div><div class="line">	fs.writeFileSync(dst, fs.readFileSync(src));</div><div class="line">&#125;</div><div class="line">function main(argv) &#123;</div><div class="line">	copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line">main(process.argv.slice(0, 2));</div><div class="line">// 进行拷贝</div><div class="line">node copy.js</div></pre></td></tr></table></figure>

以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。
process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径
</code></pre><h5 id="文件操作有关的API"><a href="#文件操作有关的API" class="headerlink" title="文件操作有关的API"></a>文件操作有关的API</h5><h6 id="Buffer（数据块）"><a href="#Buffer（数据块）" class="headerlink" title="Buffer（数据块）"></a>Buffer（数据块）</h6><pre><code>NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 构造一个Buffer实例</div><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">// Buffer实例具有length属性和bin[index]</div><div class="line">bin[0]; // =&gt; 0x68;</div><div class="line">// Buffer实例转化指定编码的字符串</div><div class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</div><div class="line">// 将字符串转化为指定编码的二进制数据</div><div class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div><div class="line">// Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。</div><div class="line">// 至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。</div></pre></td></tr></table></figure>

Buffer拷贝的例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。</div><div class="line">// 这个类似于申请一块新的内存，并把已有内存中的数据复制过去。</div><div class="line">var bin = new Buffer([0x68, 0x65, 0x6c, 0x6c, 0x6f]);</div><div class="line">var dup = new Buffer(bin.length);</div><div class="line">bin.copy(dup);</div><div class="line">dup[0] =0x46;</div><div class="line">console.log(bin, dup);</div></pre></td></tr></table></figure>
</code></pre><h6 id="Stream（数据流）"><a href="#Stream（数据流）" class="headerlink" title="Stream（数据流）"></a>Stream（数据流）</h6><pre><code>Stream的使用场景：
</code></pre><ol>
<li>当内存中无法一次装下需要处理的数据时。</li>
<li>一边读取一边处理更加高效时，我们就需要用到数据流。<br>实例–将a.js拷贝到b.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var rs = fs.createReadStream(process.argv[1].slice(0, -7) + &apos;a.js&apos;);</div><div class="line">var ws = fs.createWriteStream(process.argv[1].slice(0, -7) + &apos;b.js&apos;);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">	// 传入的数据是否写入目标</div><div class="line">	if (ws.write(chunk) === false) &#123;</div><div class="line">			rs.pause();</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">	ws.end();</div><div class="line">&#125;);</div><div class="line">// 判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了</div><div class="line">ws.on(&apos;drain&apos;, function () &#123;</div><div class="line">	rs.resume();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="File-System（文件系统）"><a href="#File-System（文件系统）" class="headerlink" title="File System（文件系统）"></a>File System（文件系统）</h6><pre><code>NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：
</code></pre><ol>
<li>文件属性读写。<br>其中常用的有fs.stat、fs.chmod、fs.chown等等。</li>
<li>文件内容读写。<br>其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。</li>
<li><p>底层文件操作。<br>其中常用的有fs.open、fs.read、fs.write、fs.close等等<br>同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。<br>// 异步处理文件及异常处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">fs.readFile(process.argv[1].slice(0, -7) + &apos;a.js&apos;, function (error, data) &#123;</div><div class="line">	if (error) &#123;</div><div class="line">		console.error(error);</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(data);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>// 同步处理文件及异常处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">try&#123;</div><div class="line">	var data = fs.readFileSync(process.argv[1].slice(0, -7) + &apos;a.js&apos;);</div><div class="line">	console.log(data);</div><div class="line">&#125;catch(err)&#123;</div><div class="line">	console.error(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="Path（路径）"><a href="#Path（路径）" class="headerlink" title="Path（路径）"></a>Path（路径）</h6><pre><code>NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。
path.normalize(str)
    将传入的路径转换为标准路径，除了解析路径中的.与..外，还能去掉多余的斜杠。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var path = require(&apos;path&apos;);</div><div class="line">var cache = &#123;&#125;;</div><div class="line">function store (key, value) &#123;</div><div class="line">	cache[path.normalize(key)] = value;</div><div class="line">	console.dir(cache);</div><div class="line">&#125;</div><div class="line">store(&apos;/home&apos;, 1);</div><div class="line">store(&apos;/home/user&apos;, 44);</div><div class="line">// 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &apos;/&apos;)再替换一下标准路径。</div></pre></td></tr></table></figure>

path.join()
将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</div></pre></td></tr></table></figure>

path.extname()
当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</div></pre></td></tr></table></figure>
</code></pre><h5 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h5><pre><code>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。
</code></pre><h6 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h6><pre><code>计算N的阶乘
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function factorial (n) &#123;</div><div class="line">	if (n === 1) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return n * factorial(n-1);	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</div></pre></td></tr></table></figure>
</code></pre><h6 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h6><pre><code>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。
同步遍历
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function travel (dir, callback) &#123;</div><div class="line">	try &#123;</div><div class="line">		fs.readdirSync(dir).forEach(function (file) &#123;</div><div class="line">			var pathname = path.join(dir, file);</div><div class="line">			if (fs.statSync(pathname).isDirectory()) &#123;</div><div class="line">				travel(pathname, callback);</div><div class="line">			&#125; else &#123;</div><div class="line">				callback(pathname);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;catch(e)&#123;</div><div class="line">		console.error(e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

异步遍历（有点复杂）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback, finish) &#123;</div><div class="line">	fs.readdir(dir, function (err, files) &#123;</div><div class="line">		(function next(i) &#123;</div><div class="line">			if (i &lt; files.length) &#123;</div><div class="line">				var pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">				fs.stat(pathname, function (err, stats) &#123;</div><div class="line">					if (stats.isDirectory()) &#123;</div><div class="line">						travel(pathname, callback, function () &#123;</div><div class="line">							next(i + 1);</div><div class="line">						&#125;);</div><div class="line">					&#125; else &#123;</div><div class="line">						callback(pathname, function () &#123;</div><div class="line">							next(i + 1);</div><div class="line">						&#125;);</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125; else &#123;</div><div class="line">				finish &amp;&amp; finish();</div><div class="line">			&#125;</div><div class="line">		&#125;(0));</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h5><p>我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。</p>
<h6 id="BOM的移除"><a href="#BOM的移除" class="headerlink" title="BOM的移除"></a>BOM的移除</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function readText (pathname) &#123;</div><div class="line">	var bin = fs.readFileAync(pathname);</div><div class="line">	if (bin[0] === 0xFF &amp;&amp; bin[1] === oxBB &amp;&amp; bin[2] === 0xBF) &#123;</div><div class="line">		bin = bin.slice(3);</div><div class="line">	&#125;</div><div class="line">	return bin.toString(&apos;utf-8&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="GBK转UTF8"><a href="#GBK转UTF8" class="headerlink" title="GBK转UTF8"></a>GBK转UTF8</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 第三方包转换编码</div><div class="line">var iconv = require(&apos;iconv-lite&apos;); </div><div class="line">function readGBKText(pathname) &#123;</div><div class="line">	var bin = fs.readFileSync(pathname);</div><div class="line">	return iconv.decode(bin, &apos;gbk&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h6><pre><code>不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function replace(pathname) &#123;</div><div class="line">	var str = fs.readFileSync(pathname, &apos;binary&apos;);</div><div class="line">	str = str.replace(&apos;foo&apos;, &apos;bar&apos;);</div><div class="line">	fs.writeFileSync(pathname, str, &apos;binary&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h4><h5 id="例子开启一个服务"><a href="#例子开启一个服务" class="headerlink" title="例子开启一个服务"></a>例子开启一个服务</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text-plain&apos;&#125;);</div><div class="line">	response.end(&apos;Hello world\n&apos;);</div><div class="line">&#125;).listen(8734);</div><div class="line">// 以上程序创建了一个HTTP服务器并监听8734端口，打开浏览器访问该端口http://127.0.0.1:8124/就能够看到效果。</div></pre></td></tr></table></figure>
</code></pre><h5 id="网络相关的API"><a href="#网络相关的API" class="headerlink" title="网络相关的API"></a>网络相关的API</h5><h6 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h6><pre><code>&apos;http&apos;模块提供两种使用方式：
</code></pre><ol>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。<br>在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。<br>除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	var body = [];</div><div class="line">	console.log(request.method);</div><div class="line">	console.log(request.headers);</div><div class="line">	request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">		body.push(chunk);</div><div class="line">	&#125;);</div><div class="line">	request.on(&apos;end&apos;, function () &#123;</div><div class="line">		body = Buffer.concat(body);</div><div class="line">		console.log(body.toString());</div><div class="line">	&#125;);</div><div class="line">&#125;).listen(8734);</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h6><pre><code>https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。
创建一个HTTPS服务器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">       key: fs.readFileSync(&apos;./ssl/default.key&apos;),</div><div class="line">       cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</div><div class="line">   &#125;;</div><div class="line">var server = https.createServer(options, function (request, response) &#123;</div><div class="line">		// ...</div><div class="line">&#125;);</div><div class="line">// 与创建HTTP服务器相比，多了一个options对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。</div></pre></td></tr></table></figure>

另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server.addContext(&apos;foo.com&apos;, &#123;</div><div class="line">	key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;),</div><div class="line">	cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h6 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h6><pre><code>处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。
</code></pre><ol>
<li><p>url.parse()<br>将一个URL字符串转换为URL对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var url = require(&apos;url&apos;, [boolean], [boolean]);</div><div class="line">console.log(url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;));</div><div class="line">第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。</div><div class="line">第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如//www.example.com/foo/bar。</div></pre></td></tr></table></figure>
</li>
<li><p>url.format()<br>允许将一个URL对象转换为URL字符串</p>
</li>
<li>url.resolve()<br>可以用于拼接URL<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dd = url.resolve(&apos;http://www.baidu.com/yzf/age/sex&apos;, &apos;../va&apos;);</div><div class="line">// http://www.baidu.com/yzf/va</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="Query-String"><a href="#Query-String" class="headerlink" title="Query String"></a>Query String</h6><pre><code>querystring模块用于实现URL参数字符串与参数对象的互相转换.
querystring.parse()
    将字符串参数转化为对象URL参数
querystring.stringify()
    将参数对象转化为URL参数字符串
</code></pre><h6 id="Zlib"><a href="#Zlib" class="headerlink" title="Zlib"></a>Zlib</h6><pre><code>zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。
例子：使用zlib模块压缩HTTP响应体数据。
这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据。
zlib.gzip()
    数据压缩
zlib.gunzip()
    数据解压
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	let i = 1024,</div><div class="line">		data = &apos;&apos;;</div><div class="line">	while (i--) &#123;</div><div class="line">		data += &apos;x&apos;;</div><div class="line">	&#125;</div><div class="line">	if (request.headers[&apos;accept-encoding&apos;].includes(&apos;gzip&apos;)) &#123;</div><div class="line">		zlib.gzip(data, function (err, data) &#123;</div><div class="line">			response.writeHead(200, &#123;</div><div class="line">				&apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">				&apos;Content-Encoding&apos;: &apos;gzip&apos;</div><div class="line">			&#125;);</div><div class="line">			response.end(data);</div><div class="line">		&#125;)</div><div class="line">	&#125; else &#123;</div><div class="line">		response.writeHead(200, &#123;</div><div class="line">			&apos;Content-Type&apos;: &apos;text/plain&apos;</div><div class="line">		&#125;);</div><div class="line">		response.end(data);</div><div class="line">	&#125;</div><div class="line">&#125;).listen(8888);</div></pre></td></tr></table></figure>
</code></pre><h6 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h6><pre><code>net模块可用于创建Socket服务器或Socket客户端。
使用Socket搭建一个HTTP服务器的例子。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net.createServer(function (conn) &#123;</div><div class="line">	conn.on(&apos;data&apos;, function (data) &#123;</div><div class="line">		conn.write([</div><div class="line">			&apos;HTTP/1.1 200 OK&apos;,</div><div class="line">			&apos;Content-Type: text/plain&apos;,</div><div class="line">			&apos;Content-Length: 12&apos;,</div><div class="line">			&apos;&apos;,</div><div class="line">			&apos;Hello World&apos;</div><div class="line">		].join(&apos;\n&apos;));</div><div class="line">	&#125;);</div><div class="line">&#125;).listen(8888);</div></pre></td></tr></table></figure>
</code></pre><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><pre><code>NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。
node.js调用终端简化目录拷贝
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var child_process = require(&apos;child_process&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">function copy(source, target, callback) &#123;</div><div class="line">	child_process.exec(</div><div class="line">		util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</div><div class="line">&#125;</div><div class="line">copy(process.argv[1].slice(0, -7) + &apos;copy1&apos;, process.argv[1].slice(0, -7) + &apos;copy2&apos;, function (err, data) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(err)</div><div class="line">	&#125;</div><div class="line">	console.log(data)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h5><pre><code>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。
另外需要注意的是，process不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。
</code></pre><h5 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h5><pre><code>使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。
</code></pre><h5 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h5><pre><code>cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。
</code></pre><p>应用场景</p>
<ol>
<li>如何获取命令行参数<br>  在NodeJS中可以通过process.argv获取命令行参数。<br>  但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。<br>  一般这样获取：process.argv.slice(2)</li>
<li><p>如何退出程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">	// ...</div><div class="line">&#125; catch (err) &#123;</div><div class="line">	// ...</div><div class="line">	process.exit(1); // 返回特定的状态码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如何控制输入输出<br>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr，<br>第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。</p>
</li>
<li><p>如何降权<br>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http.createServer(callback).listen(80, function () &#123;</div><div class="line">	var env = process.env,</div><div class="line">		uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</div><div class="line">		gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</div><div class="line">	process.setgid(gid);</div><div class="line">	process.setuid(uid);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如何创建子进程<br>创建NodeJS子进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;a.js&apos; ]);</div><div class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</div><div class="line">	console.log(&apos;stdout: &apos; + data);</div><div class="line">&#125;);</div><div class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</div><div class="line">	console.log(&apos;stderr: &apos; + data);</div><div class="line">&#125;);</div><div class="line">child.on(&apos;close&apos;, function (code) &#123;</div><div class="line">	console.log(&apos;child process exited with code &apos; + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>进程间如何通讯    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</div><div class="line"></div><div class="line">child.kill(&apos;SIGTERM&apos;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">	cleanUp();</div><div class="line">	process.exit(0);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>进程间如何通讯<br>如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</div><div class="line">		stdio: [ 0, 1, 2, &apos;ipc&apos; ]</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">child.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">	console.log(msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">	msg.hello = msg.hello.toUpperCase();</div><div class="line">	process.send(msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如何守护子进程<br>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function spawn(mainModule) &#123;</div><div class="line">	var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</div><div class="line">	worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">		if (code !== 0) &#123;</div><div class="line">			spawn(mainModule);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">spawn(&apos;worker.js&apos;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><pre><code>NodeJS最大的卖点——事件机制和异步IO。
</code></pre><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><pre><code>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(function () &#123;</div><div class="line">	console.log(&apos;我是setTimeout&apos;)</div><div class="line">&#125;, 1000);</div><div class="line">console.log(&apos;hello&apos;);</div></pre></td></tr></table></figure>

理解js中如何实现异步
    JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的
    事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。
    我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。
    也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。
</code></pre><h5 id="代码设计模式"><a href="#代码设计模式" class="headerlink" title="代码设计模式"></a>代码设计模式</h5><h6 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h6><pre><code>使用一个函数的输出作为另一个函数的输入是很常见的需求。
同步方式编写代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var output = fn1(fn2(&apos;input&apos;));</div></pre></td></tr></table></figure>

异步方式编写代码：
由于函数执行结果不是通过返回值，而是通过回调函数传递。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fn2(&apos;input&apos;, function (output2) &#123;</div><div class="line">	fn1(output2, function (output1) &#123;</div><div class="line">		// do something</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h6 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h6><pre><code>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。
同步方式编写代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var len = arr.length;</div><div class="line">for (let i = 0; i &lt; len; i++) &#123;</div><div class="line">	arr[i] = sync(arr[i]);</div><div class="line">&#125;</div><div class="line">// 所有的数组项处理完，打算做的事</div></pre></td></tr></table></figure>

异步方式编写代码(异步串行遍历)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">((function next (i, len, callback) &#123;</div><div class="line">	if (i &lt; len) &#123;</div><div class="line">		async(arr[i], function (value) &#123;</div><div class="line">			arr[i] = value;</div><div class="line">			next(i + 1, len, callback);</div><div class="line">		&#125;);</div><div class="line">	&#125; else &#123;</div><div class="line">		callback();</div><div class="line">	&#125;</div><div class="line">&#125;)(0, arr.length, function () &#123;</div><div class="line">	// 所有的数组项处理完，打算做的事</div><div class="line">&#125;));</div></pre></td></tr></table></figure>

异步方式编写代码(异步并行遍历)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">((function (i, len, count, callback) &#123;</div><div class="line">	for (; i &lt; len; i++) &#123;</div><div class="line">		(function (i) &#123;</div><div class="line">			async(arr[i], function (value) &#123;</div><div class="line">				arr[i] = value;</div><div class="line">				if (++count === len) &#123;</div><div class="line">					callback();</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;)(i);</div><div class="line">	&#125;</div><div class="line">&#125;)(0, arr.length, 0, function () &#123;</div><div class="line">	// 所有的数组项处理完，打算做的事</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
</code></pre><h6 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h6><pre><code>JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。
同步异常处理：
因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function sync(fn) &#123;</div><div class="line">	return fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">	sync(null);</div><div class="line">	// Do something.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">	console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

异步异常处理：
但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。
因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。
</code></pre><h5 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h5><pre><code>NodeJS提供了domain模块，可以简化异步代码的异常处理。
一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</div><div class="line">	console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(function (fn) &#123;</div><div class="line">	fn();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

使用domain模块创建一个子域（JS子运行环境）。
在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的error事件统一捕获。
我们使用.create方法创建了一个子域对象，并通过.run方法进入需要在子域中运行的代码的入口点。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">	// Do something.</div><div class="line">	asyncA(request, function (data) &#123;</div><div class="line">		// Do something</div><div class="line">		asyncB(request, function (data) &#123;</div><div class="line">			// Do something</div><div class="line">			asyncC(request, function (data) &#123;</div><div class="line">				// Do something</div><div class="line">				callback(data);</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	var d = domain.create(); // 创建子域</div><div class="line"></div><div class="line">	d.on(&apos;error&apos;, function () &#123;</div><div class="line">		response.writeHead(500);</div><div class="line">		response.end();</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	d.run(function () &#123; // 子域运行入口</div><div class="line">		async(request, function (data) &#123;</div><div class="line">			response.writeHead(200);</div><div class="line">			response.end(data);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><pre><code>无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。    
</code></pre><p>参考书籍：<br>    <a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJs</a><br>    <a href="http://nodejs.cn/api/" target="_blank" rel="external">node中文</a><br>代码仓库：<a href="https://github.com/fanerge/7day-NodeJs.git" target="_blank" rel="external">node学习源代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NodeJs基础&quot;&gt;&lt;a href=&quot;#NodeJs基础&quot; class=&quot;headerlink&quot; title=&quot;NodeJs基础&quot;&gt;&lt;/a&gt;NodeJs基础&lt;/h4&gt;&lt;h5 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>css加强（多形状图像和心跳灯和竖着排的文字和面包屑导航）</title>
    <link href="https://fanerge.github.io/2017/09/04/css%E5%8A%A0%E5%BC%BA-5/"/>
    <id>https://fanerge.github.io/2017/09/04/css加强-5/</id>
    <published>2017-09-04T13:55:45.000Z</published>
    <updated>2017-09-04T15:21:05.875Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="多形状图像"><a href="#多形状图像" class="headerlink" title="多形状图像"></a>多形状图像</h4><pre><code>可以实现多形状图像
border-radius: top right bottom left;
</code></pre><h4 id="心跳灯"><a href="#心跳灯" class="headerlink" title="心跳灯"></a>心跳灯</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.heartbeat &#123;</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	background: red;</div><div class="line">	animation: heartbeat .83s ease-in-out infinite;</div><div class="line">&#125;</div><div class="line">@keyframes heartbeat &#123;</div><div class="line">	from &#123;</div><div class="line">		opacity:0.1;</div><div class="line">	&#125;</div><div class="line">	50% &#123;</div><div class="line">		opacity:1;</div><div class="line">	&#125;</div><div class="line">	to &#123;</div><div class="line">		opacity:0.1;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="竖着排的文字"><a href="#竖着排的文字" class="headerlink" title="竖着排的文字"></a>竖着排的文字</h4><pre><code>writing-mode: horizontal-tb | vertical-lr | vertical-rl;
    horizontal-tb表示水平方向自上而下的书写方式。
    vertical-rl表示垂直方向自右向左的书写方式
    vertical-lr表示垂直方向自左向右的书写方式
IE
writing-mode: lr-tb | tb-rl;
    lr-tb水平方向自左向右的书写方式
    tb-rl垂直方向自上而下的书写方式。
</code></pre><h4 id="首字母下沉"><a href="#首字母下沉" class="headerlink" title="首字母下沉"></a>首字母下沉</h4><pre><code>::first-letter伪元素选择器用于选取指定选择器的首字母。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p::first-letter &#123;</div><div class="line">	color:#c69c6d;</div><div class="line">	float:left;</div><div class="line">	font-size:5em;</div><div class="line">	margin:0 .2em 0 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css加强（表单和文本样式和动态边框和上传组件美化）</title>
    <link href="https://fanerge.github.io/2017/09/04/css%E5%8A%A0%E5%BC%BA-4/"/>
    <id>https://fanerge.github.io/2017/09/04/css加强-4/</id>
    <published>2017-09-04T11:31:38.000Z</published>
    <updated>2017-09-04T13:55:12.989Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="表单input"><a href="#表单input" class="headerlink" title="表单input"></a>表单input</h4><p>主要添加了过渡下border和验证提示<br><img src="/images/form.png" alt="表单中的input"></p>
<h5 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;input-field&quot;&gt;</div><div class="line">	&lt;input id=&quot;last-name&quot; type=&quot;text&quot; placeholder=&quot;name&quot;&gt;&lt;/input&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;!--带验证的--&gt;</div><div class="line">&lt;div class=&quot;input-field error input-field-icon&quot;&gt;</div><div class="line">	&lt;input id=&quot;last_name&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;&gt;</div><div class="line">	&lt;span class=&quot;gradient&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;i class=&quot;ion-android-close&quot;&gt;</div><div class="line">	&lt;/i&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>

解释：
.input-field成为容器层，input和span并列排列。
让span来充当input的下border，然后在通过为类选择器:focus和兄弟选择器和伪类元素span:after来完成
</code></pre><h5 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> *&#123;</div><div class="line">	box-sizing:border-box;</div><div class="line">&#125;</div><div class="line">.input-field &#123;</div><div class="line">	position: relative;</div><div class="line">	width: 200px;</div><div class="line">	margin: 20px 50px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-field input &#123;</div><div class="line">	background-color: transparent;</div><div class="line">	border: none;</div><div class="line">	border-radius: 0;</div><div class="line">	height: 35px;</div><div class="line">	width: 100%;</div><div class="line">	padding: 0;</div><div class="line">	box-shadow: none;</div><div class="line">	outline: none;</div><div class="line">	transition: all 0.3s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-field input+span &#123;</div><div class="line">	position: absolute;</div><div class="line">	top: 100%;</div><div class="line">	left: 0;</div><div class="line">	display: inline-block;</div><div class="line">	max-width: 100%;</div><div class="line">	z-index: 0;</div><div class="line">	width: 100%;</div><div class="line">	height: 1px;</div><div class="line">	border-bottom: 1px solid #d9d9d9;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-field span:after &#123;</div><div class="line">	content: &quot;&quot;;</div><div class="line">	position: absolute;</div><div class="line">	bottom: 0;</div><div class="line">	left: 0;</div><div class="line">	width: 100%;</div><div class="line">	height: 2px;</div><div class="line">	background: #2196f3;</div><div class="line">	transform: scale(0);</div><div class="line">	transition: all .2s ease-out;</div><div class="line">&#125;</div><div class="line">.input-field input:focus+span:after &#123;</div><div class="line">	transform: scale(1);</div><div class="line">&#125;</div><div class="line">.input-field.input-field-icon i&#123;</div><div class="line">	position:absolute;</div><div class="line">	right:0;</div><div class="line">	top:50%;</div><div class="line">	padding:0 5px;</div><div class="line">	font-size:1.5em;</div><div class="line">	-webkit-transform: translate(0, -50%);</div><div class="line">	transform: translate(0, -50%);</div><div class="line">&#125;</div><div class="line">.input-field.input-field-icon input&#123;</div><div class="line">	padding-right:30px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

这里有个小技巧：要是验证图标垂直居中，达到居中效果。
top: 50%; 相对于父元素的高度
transform: translate(0, -50%); 相对于自身元素的高度。
</code></pre><h4 id="自定义选择文本样式"><a href="#自定义选择文本样式" class="headerlink" title="自定义选择文本样式"></a>自定义选择文本样式</h4><pre><code>使用::selection伪类选择器，我们可以实现与众不同的选择文本样式。
注意：只能设置背景色和文字颜色，同时不支持渐变色。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">::selection &#123;</div><div class="line">	background: #009a61;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div><div class="line"></div><div class="line">::-moz-selection &#123;</div><div class="line">	background: #009a61;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div><div class="line"></div><div class="line">::-webkit-selection &#123;</div><div class="line">	background: #009a61;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="动态的边框"><a href="#动态的边框" class="headerlink" title="动态的边框"></a>动态的边框</h4><h5 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;dynamic-border dynamic-border-2&quot;&gt;</div><div class="line">	&lt;span&gt;</div><div class="line">	&lt;/span&gt;</div><div class="line">	&lt;img src=&quot;images/girl.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>

整体思路：
创建一个容器，容器自身两个伪类元素，span又包含两个伪类元素，可以动态生成容器的4个边框（相对+绝对定位）。
在加上过渡效果就OK了。第二个动态边框只要按不同时间延迟组合就好了。
</code></pre><h5 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"> *&#123;</div><div class="line">	box-sizing:border-box;</div><div class="line">&#125;</div><div class="line">.dynamic-border &#123;</div><div class="line">	position:relative;</div><div class="line">	width:200px;</div><div class="line">	height:200px;</div><div class="line">	background:gray;</div><div class="line">&#125;</div><div class="line">.dynamic-border:before,</div><div class="line">.dynamic-border:after,</div><div class="line">.dynamic-border span:first-child:before,</div><div class="line">.dynamic-border span:first-child:after &#123;</div><div class="line">	content:&quot;&quot;;</div><div class="line">	position:absolute;</div><div class="line">	background:red;</div><div class="line">	-webkit-transition:all .2s ease;</div><div class="line">	transition:all .2s ease;</div><div class="line">&#125;</div><div class="line">/*上边边框*/</div><div class="line">.dynamic-border:before &#123;</div><div class="line">	width:0; </div><div class="line">	top:-2px;</div><div class="line">	right:0;</div><div class="line">	height:2px;</div><div class="line">&#125;</div><div class="line">/*右边边框*/</div><div class="line">.dynamic-border:after &#123;</div><div class="line">	width:2px;</div><div class="line">	height:0;  </div><div class="line">	right:-2px;</div><div class="line">	bottom:0;</div><div class="line">&#125;</div><div class="line">/*下边边框*/</div><div class="line">.dynamic-border span:first-child:before &#123;</div><div class="line">	width:0;  </div><div class="line">	height:2px;</div><div class="line">	bottom:-2px;</div><div class="line">	left:0;</div><div class="line">&#125;</div><div class="line">/*左边边框*/</div><div class="line">.dynamic-border span:first-child:after &#123;</div><div class="line">	width:2px;</div><div class="line">	height:0;  </div><div class="line">	top:0;</div><div class="line">	left:-2px;</div><div class="line">&#125;</div><div class="line">/*鼠标移动上去时*/</div><div class="line">.dynamic-border:hover:before,</div><div class="line">.dynamic-border:hover span:first-child:before &#123;</div><div class="line">	width:calc(100% + 2px);</div><div class="line">&#125;</div><div class="line">.dynamic-border:hover:after,</div><div class="line">.dynamic-border:hover span:first-child:after &#123;</div><div class="line">	height:calc(100% + 2px);</div><div class="line">&#125;</div><div class="line">/*添加过渡延迟时间*/</div><div class="line">.dynamic-border-1:hover:before,</div><div class="line">.dynamic-border-1:hover span:first-child:before &#123;</div><div class="line">	-webkit-transition-delay:.2s;</div><div class="line">	transition-delay:.2s;</div><div class="line">&#125;</div><div class="line">.dynamic-border-2:hover span:first-child:before &#123;</div><div class="line">	-webkit-transition-delay:.2s;</div><div class="line">	transition-delay:.2s;</div><div class="line">&#125;</div><div class="line">.dynamic-border-2:hover:after &#123;</div><div class="line">	-webkit-transition-delay:.4s;</div><div class="line">	transition-delay:.4s;</div><div class="line">&#125;</div><div class="line">.dynamic-border-2:hover:before &#123;</div><div class="line">	-webkit-transition-delay:.6s;</div><div class="line">	transition-delay:.6s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="上传组件美化"><a href="#上传组件美化" class="headerlink" title="上传组件美化"></a>上传组件美化</h4><h5 id="创建模版-2"><a href="#创建模版-2" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;file file-input&quot;&gt;</div><div class="line">	&lt;div class=&quot;file-inner&quot;&gt;</div><div class="line">		选择文件</div><div class="line">		&lt;button class=&quot;btn btn-primary file-inner-btn&quot;&gt;</div><div class="line">			文件上传</div><div class="line">			&lt;i class=&quot;ion-ios-cloud-upload-outline&quot;&gt;</div><div class="line">			&lt;/i&gt;</div><div class="line">		&lt;/button&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;input type=&quot;file&quot; /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="设置CSS样式"><a href="#设置CSS样式" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">.file &#123;</div><div class="line">	position:relative;</div><div class="line">&#125;</div><div class="line">.file input &#123;</div><div class="line">	position:absolute;</div><div class="line">	top:0;</div><div class="line">	left:0;</div><div class="line">	opacity:0;</div><div class="line">	width:100%;</div><div class="line">	height:100%;</div><div class="line">&#125;</div><div class="line">.file-inner &#123;</div><div class="line">	position:relative;</div><div class="line">	width:250px;</div><div class="line">	height:35px;</div><div class="line">	border:1px solid #d9d9d9;</div><div class="line">	border-radius:5px;</div><div class="line">	padding-left:10px;</div><div class="line">	line-height:35px;</div><div class="line">&#125;</div><div class="line">.file-inner .file-inner-btn &#123;</div><div class="line">	position:absolute;</div><div class="line">	right:0;</div><div class="line">	top:0;</div><div class="line">	height:100%;</div><div class="line">	box-shadow:none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

解释；
这里就用了一个技巧，把input设置为opacity: 0;然后在绝对定位并设置宽高100%，这样就会是整个区域都触发file的input默认事件。
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css加强（进度条和遮罩条和切角）</title>
    <link href="https://fanerge.github.io/2017/09/03/css%E5%8A%A0%E5%BC%BA-3/"/>
    <id>https://fanerge.github.io/2017/09/03/css加强-3/</id>
    <published>2017-09-03T09:39:50.000Z</published>
    <updated>2017-09-03T13:47:49.913Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。<br>进度条<br>    <img src="./images/progress.png" alt="进度条"></p>
<h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><h5 id="创建进度条"><a href="#创建进度条" class="headerlink" title="创建进度条"></a>创建进度条</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	&lt;div class=&quot;fan-progress fan-striped fan-active&quot;&gt;</div><div class="line">		&lt;div class=&quot;fan-progress-bar&quot; style=&quot;width: 40%;&quot;&gt;40%&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	```	</div><div class="line">	解释：</div><div class="line">	1.	fan-progress为定义进度条的整体样式（背景）</div><div class="line">	2.	fan-striped为定义斑纹样式（背景）</div><div class="line">	3. 	fan-active为定义动态进度条样式（背景）</div><div class="line">	4.	fan-progress-bar为定义当前行进到样式</div><div class="line">#####	设置样式</div></pre></td></tr></table></figure>

* {
    box-sizing: border-box;
}
fan-progress {
    box-sizing: border-box;
    height: 20px;
    line-height: 20px;
    background: #f7f7f7;
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .08), inset 0 2px 2px rgba(0, 0, 0, .08);
    border-radius: 4px;
}
fan-progress-bar {
    width: 0;
    height: 100%;
    background: #009dd8;
    float: left;
    transition: width .6s ease;
    font-size: 12px;
    color: #fff;
    text-align: center;
    background-image: linear-gradient(to bottom, #oob4f5, #008dc5);
    box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .3), inset 0 0 0 1px rgba(0, 0, 0, .1);
    text-shadow: 0 -1px 0 rgba(0,0,0,.2);
}
/*条纹*/
.fan-progress-striped .fan-progress-bar {
    background-image:linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);
    background-size:30px 30px;
}
/*动态*/
.fan-progress-striped.fan-active .fan-progress-bar {
    animation: fan-progress-active 2s linear infinite;
}
@keyframes fan-progress-active {
    0% {
        background-position: 0 0;
    }
    100% {
        background-position: 30px 0;
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####	遮罩条</div><div class="line">	设计思路：</div><div class="line">1.	用一个DOM容器包图片</div><div class="line">2. 	遮罩条主要以容器的伪类来创建</div><div class="line">3.	通过hover效果和css3的transition和transform完成相应动画</div><div class="line">#####	创建DOM节点</div></pre></td></tr></table></figure>

&lt;div class=&quot;mask&quot; data-title=&quot;遮罩条&quot;&gt;
    &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot;&gt;
&lt;/div&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#####	设置样式</div></pre></td></tr></table></figure>

.mask {
    position: relative;
    width: 150px;
    height: 150px;
    overflow: hidden;
}   
.mask:before {
    content: attr(data-title);
    position: absolute;
    top: 100%;
    left: 0;
    padding: .7em 0;
    width: 100%;
    text-align: center;
    color: #fff;
    background: rgba(0,0,0,.5);
    transform: translate(0, 100%);
    transition: all .3s ease-in-out;
    opacity: 0;
}  
.mask:hover:before {
    top: 80%;
    transform: translate(0, 0);
    opacity: 1;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####	切角</div><div class="line">#####	创建DOM节点</div></pre></td></tr></table></figure>

&lt;div class=&quot;box corner&quot;&gt;单个切角&lt;/div&gt;
&lt;div class=&quot;box corner1&quot;&gt;多个切角&lt;/div&gt;
&lt;div class=&quot;box corner2&quot;&gt;多个园角&lt;/div&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#####	设置样式</div></pre></td></tr></table></figure>

.corner {
    background: linear-gradient(-45deg, transparent 15px, #58a 15px);
}
.corner1 {
    background: linear-gradient(135deg, transparent 15px, #58a 0) top left, 
        linear-gradient(-135deg, transparent 15px, #58a 0) top right, 
        linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,
        linear-gradient(45deg, transparent 15px, #58a 0) bottom left;
    background-size: 50% 50%;
    background-repeat: no-repeat;
}
.corner2 {
    background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, 
        radial-gradient(circle at top right, transparent 15px, #58a 0) top right, 
        radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, 
        radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;
    background-size: 50% 50%;
    background-repeat: no-repeat;
}
```
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>http缓存相关的知识</title>
    <link href="https://fanerge.github.io/2017/09/01/http%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/09/01/http缓存知识总结/</id>
    <published>2017-09-01T10:56:40.000Z</published>
    <updated>2017-09-01T10:56:51.213Z</updated>
    
    <content type="html"><![CDATA[<h4 id="http缓存整理"><a href="#http缓存整理" class="headerlink" title="http缓存整理"></a>http缓存整理</h4><h5 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h5><pre><code>当一个用户发送一个静态资源请求通过下面几步获取资源：
</code></pre><ol>
<li>当第一次发送请求时，http返回200的状态码。</li>
<li>在没有关闭缓存请求的时候，则返回header中返回包含last-Modified以及Etag和Expires的字段，然后将文件保存在Cache目录下。</li>
<li>后续请求该文件时，先本地查找该资源。如果本地缓存存在该资源，但不知道是否过期，则发送一个http请求到服务器，然后服务器来判断。<br>如果该文件没有改动，则返回304，继续使用本地资源。<br>如果该文件发生改动，服务器返回该资源并返回200。<br>如果服务器没有这个资源，则返回404。<h5 id="http头部缓存相关key"><a href="#http头部缓存相关key" class="headerlink" title="http头部缓存相关key"></a>http头部缓存相关key</h5><h6 id="request-header缓存相关"><a href="#request-header缓存相关" class="headerlink" title="request header缓存相关"></a>request header缓存相关</h6>cache-control：<br>  其缓存指令对于前端常用的有如下no-cache、no-store、max-age这几个值；<br>if-none-match：<br>  该字段与响应中的eTag一起使用，表示检查实体是否有更新改变;客户端第一次发送请求时候响应报文会包含字段Etag，表示资源状态，当资源改变后该值也会改变（客户端不必关心该值怎么生成）<br>  然后缓存保存下该字段，第二次已经有该缓存时候在浏览本地缓存时候会将该值赋给if-none-match字段发送给服务器，服务器将发送的值与当前的状态进行对比，<br>  如果值一样的话则答复304去使用缓存数据，如果值改变了则发送最新数据给客户端替代现有缓存数据，并且返回状态200;<br>if-modified-since:<br>  该字段与last-modified配合使用，跟上述原理差不多，都是响应端先返回一个last-modified时间字段，再次请求时候 request头部会将缓存中的last-modified字段拿出来赋给if-modified-since，<br>  发送给服务器，服务器去判断时间是否过期，如未过期则返回304，告诉客户使用缓存数据，如果过期则重新返回一个last-modified并且返回200；<h6 id="response-header缓存相关："><a href="#response-header缓存相关：" class="headerlink" title="response header缓存相关："></a>response header缓存相关：</h6>Etag：<br>  刚才也说过 是跟if-none-match配合去使用，它根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。<br>  使用Etag主要是为了解决根据时间无法解决的问题：比如文件修改频繁（秒之内修改），导致根据时间无法判断是否更新；以及修改时间变了，但是内容没变（我们应该认为该文件是没变的）<br>expires：<br>  表示缓存过期时间例如:expires:Mon Dec 30 2011 11:01:19 GMT，跟cache-control中的max-age作用一样，不过在碰见max-age之后，该值会被覆盖从而被max-age替代;<br>last-modified:<br>  表示文件最后修改时间；</li>
</ol>
<h5 id="实现有关前端对于缓存的操作"><a href="#实现有关前端对于缓存的操作" class="headerlink" title="实现有关前端对于缓存的操作"></a>实现有关前端对于缓存的操作</h5><h6 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h6><pre><code>方法一：
在服务器进行配置其max-age或者expires使其设置一个过期值为当前一年之后。这样每次进行检验时候都会使用缓存中文件。
例如在.htaccess中
&lt;IfModule mod_headers.c&gt;
 &lt;FilesMatch &quot;.(gif|jpg|jpeg|png|ico)$&quot;&gt;
Header set Cache-Control &quot;max-age=604800&quot;
 &lt;/FilesMatch&gt;
方法二：
前端设置if-modified-since去设置一个上次修改时间大于当前日期，
方法三：
服务器端根据etag去判断是否匹配来根据实际业务来使用缓存；
后面两个方法属于弱缓存数据头，需要浪费http连接，所以建议使用第一种方式;
</code></pre><h6 id="禁用缓存"><a href="#禁用缓存" class="headerlink" title="禁用缓存"></a>禁用缓存</h6><pre><code>方法一：
可以在meta标签标明
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 
方法二：
也可以动态去setRequestHeader，强制不用缓存设置组合如下：
cache-control=&apos;no-cache,no-store&apos;
pragma=&apos;no-cache&apos;
if-modified-since=0;
方法三：
请求端设置if-modified-since为已经过期的某个时间，可以是几年前或者几十年前。
方法四：
服务端设置Expires为过期某个时间，例如PHP中header(&quot;Expires: Mon, 26 Jul 1997 05:00:00 GMT&quot;);
实际开发中如果需要一致性检测则尽量去配合Etag以及last-Modified去进行比较然后返回使用缓存还是新数据;这个有点偏服务器端了，不再赘述
方法五：
url后面加随机数或者时间戳url += “&amp;random=” + Math.random()这个方法js以及PHP经常用，原理就是每个请求的url都不一样这样一来缓存中找不到对应数据，就自动去服务器寻找最新资源;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;http缓存整理&quot;&gt;&lt;a href=&quot;#http缓存整理&quot; class=&quot;headerlink&quot; title=&quot;http缓存整理&quot;&gt;&lt;/a&gt;http缓存整理&lt;/h4&gt;&lt;h5 id=&quot;缓存过程&quot;&gt;&lt;a href=&quot;#缓存过程&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="http" scheme="https://fanerge.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://fanerge.github.io/tags/http/"/>
    
      <category term="缓存" scheme="https://fanerge.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>css加强（单选复选Switch、Loading）</title>
    <link href="https://fanerge.github.io/2017/08/30/css%E5%8A%A0%E5%BC%BA-2/"/>
    <id>https://fanerge.github.io/2017/08/30/css加强-2/</id>
    <published>2017-08-30T13:36:57.000Z</published>
    <updated>2017-08-31T14:41:41.075Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="单选复选Switch"><a href="#单选复选Switch" class="headerlink" title="单选复选Switch"></a>单选复选Switch</h4><p>switch组件是常用组件，默认的单选复选框都很丑，是这里使用CSS3美化switch。<br>    <img src="/images/switch.png" alt="效果图"><br>本问重点将一下整体思路（以单选为例）</p>
<h5 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt;</div><div class="line">       &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;</div><div class="line">       &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt;</div><div class="line">       &lt;div class=&quot;fan-check-inner&quot;&gt;</div><div class="line">           &lt;div class=&quot;fan-check-title&quot;&gt;男&lt;/div&gt;</div><div class="line">       &lt;/div&gt;</div><div class="line">   &lt;/label&gt;</div><div class="line">   &lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt;</div><div class="line">       &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;</div><div class="line">       &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt;</div><div class="line">       &lt;div class=&quot;fan-check-inner&quot;&gt;</div><div class="line">           &lt;div class=&quot;fan-check-title&quot;&gt;女&lt;/div&gt;</div><div class="line">       &lt;/div&gt;</div><div class="line">   &lt;/label&gt;</div></pre></td></tr></table></figure>

这里讲解一下DOM结构用义：
</code></pre><ol>
<li>label包含整个组件，并且是label绑定与input的关系。</li>
<li>主要前端效果通过<div class="fan-check-media"></div>节点及其伪类完成</li>
<li><p>通过input:checked 和 兄弟选择器 + 控制类fan-check-media元素的样式</p>
<h5 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line">  box-sizing: border-box;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&#123;</div><div class="line">	display: flex;</div><div class="line">	padding: 5px 0;</div><div class="line">	cursor: pointer;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&gt;input&#123;</div><div class="line">	display: none;</div><div class="line">&#125;</div><div class="line">.fan-check-radio:hover .fan-check-media &#123;</div><div class="line">	border-color: red!important;</div><div class="line">&#125;</div><div class="line">.fan-check-inner,.fan-check-media</div><div class="line">&#123;</div><div class="line">	position: relative;</div><div class="line">&#125;</div><div class="line"> .fan-check-radio .fan-check-media &#123;</div><div class="line">	line-height: 20px;</div><div class="line">	width: 22px;</div><div class="line">	height: 22px;</div><div class="line">	margin-right: 5px;</div><div class="line">	text-align: center;</div><div class="line">	color: #fff;</div><div class="line">	border: 1px solid #d9d9d9;</div><div class="line">	border-radius: 11px;</div><div class="line">&#125;</div><div class="line"> .fan-check-checkbox .fan-check-media &#123;</div><div class="line">	line-height: 20px;</div><div class="line">	width: 22px;</div><div class="line">	height: 22px;</div><div class="line">	margin-right: 5px;</div><div class="line">	text-align: center;</div><div class="line">	color: #fff;</div><div class="line">	border: 1px solid #d9d9d9;</div><div class="line">	border-radius: 2px;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&gt;input:checked + .fan-check-media &#123;</div><div class="line">	border: 1px solid #1aa500;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&gt;input:checked + .fan-check-media:after &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	position: absolute;</div><div class="line">	animation: radiozoom .1s linear forwards;</div><div class="line">	border-radius: 6px;</div><div class="line">	background: #1aa500; </div><div class="line">&#125;</div><div class="line">@keyframes radiozoom &#123;</div><div class="line">	from &#123;</div><div class="line">		top: 8px;</div><div class="line">		left:8px;</div><div class="line">		width: 2px;</div><div class="line">		height: 2px;</div><div class="line">	&#125;</div><div class="line">	to &#123;</div><div class="line">		top: 4px;</div><div class="line">		left:4px;    </div><div class="line">		width: 12px;</div><div class="line">		height: 12px;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：<br>我们需要隐藏radio默认的样式，来做我们自己的UI：.fan-check-radio&gt;input{ display: none; }<br>然后在就只这个<div class="fan-check-media"></div>节点及其伪类上下功夫了。<br>.fan-check-media这个节点需要使用相对定位，其伪类上使用绝对定位。<br>先设定input未选中时的样式，也是通过.fan-check-media及其伪类来控制。<br>在设置input选中时的样式，通过属性选择其[type=’radio’]:checked来控制radio被选中的样式。<br>具体操作请参考，下面的代码库</p>
</li>
</ol>
<h4 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h4><p>先来看下效果<br>    <img src="/images/loading.png" alt="loading"><br>    讲解一下大体思路：</p>
<ol>
<li>构建外层包裹div（相对定位），内部8个span分别占据一周（使它们绕中心一周）通过绝对定位。</li>
<li>创建一个动画，并为每个span添加动画及动画延迟。（需要满足动画周期 === 8* animation-delay ）</li>
</ol>
<h5 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code>我们创意个正方形的div，里面放置8个子元素。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;loader circle-line small&quot;&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code>通过定位和css的转换来移动每一个span的位置。
设置容器的基本样式和span的基本样式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.loader &#123;</div><div class="line">	position: relative;</div><div class="line">	width: 5rem;</div><div class="line">	height: 5rem;</div><div class="line">&#125;</div><div class="line">.loader.circle-line span &#123;</div><div class="line">	position: absolute;</div><div class="line">	display: inline-block;</div><div class="line">	width: 1.5rem;</div><div class="line">	height: .5rem;</div><div class="line">	border-top-left-radius: .25rem;</div><div class="line">	border-bottom-left-radius: .25rem;</div><div class="line">	background: #1aa500;</div><div class="line">	opacity: .05;</div><div class="line">	-webkit-animation: circle-line 1s ease infinite;</div><div class="line">	animation: circle-line 1s ease infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

通过css3-transform得到loading图案
当然这哥定位还是很复杂，我直接参考[web开始实战](https://www.kancloud.cn/dennis/javascriptmethod/261478)的源代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">.loader.circle-line span:nth-child(1) &#123;</div><div class="line">	top: 50%;</div><div class="line">	left: 0;</div><div class="line">	margin-top: -.25rem;</div><div class="line">	animation-delay: .13s;</div><div class="line">&#125;</div><div class="line">.loader.circle-line span:nth-child(2) &#123;</div><div class="line">	top: 1rem;</div><div class="line">	left: .5rem;</div><div class="line">	-webkit-transform: rotate(45deg);</div><div class="line">	transform: rotate(45deg);</div><div class="line">	animation-delay: .26s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(3) &#123;</div><div class="line">	left: 50%;</div><div class="line">	top: .5rem;</div><div class="line">	margin-left: -.75rem;</div><div class="line">	-webkit-transform: rotate(90deg);</div><div class="line">	transform: rotate(90deg);</div><div class="line">	animation-delay: .39s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(4) &#123;</div><div class="line">	right: .5rem;</div><div class="line">	top: 1rem;</div><div class="line">	-webkit-transform: rotate(145deg);</div><div class="line">	transform: rotate(145deg);</div><div class="line">	animation-delay: .52s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(5) &#123;</div><div class="line">	left: 3.5rem;</div><div class="line">	top: 50%;</div><div class="line">	margin-top: -.25rem;</div><div class="line">	-webkit-transform: rotate(180deg);</div><div class="line">	transform: rotate(180deg);</div><div class="line">	animation-delay: .65s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(6) &#123;</div><div class="line">	bottom: 1rem;</div><div class="line">	right: .5rem;</div><div class="line">	-webkit-transform: rotate(-145deg);</div><div class="line">	transform: rotate(-145deg);</div><div class="line">	animation-delay: .78s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(7) &#123;</div><div class="line">	left: 50%;</div><div class="line">	bottom: .5rem;</div><div class="line">	margin-left: -15px;</div><div class="line">	-webkit-transform: rotate(-90deg);</div><div class="line">	transform: rotate(-90deg);</div><div class="line">	animation-delay: 0.91s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(8) &#123;</div><div class="line">	bottom: 1rem;</div><div class="line">	left: .5rem;</div><div class="line">	-webkit-transform: rotate(-45deg);</div><div class="line">	transform: rotate(-45deg);</div><div class="line">	animation-delay: 1.04s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

注意：上面动画的周期必须要无限接近于最后一个span元素的动画延迟（动画延迟是平均分配的哦）。

动画，这是使用Opcity动画。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@keyframes circle-line &#123;</div><div class="line">	0% &#123;</div><div class="line">		opacity: .05;</div><div class="line">	&#125;</div><div class="line">	100% &#123;</div><div class="line">		opacity: .7;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css加强（水中倒影、工具提示tooltip）</title>
    <link href="https://fanerge.github.io/2017/08/30/css%E5%8A%A0%E5%BC%BA-1/"/>
    <id>https://fanerge.github.io/2017/08/30/css加强-1/</id>
    <published>2017-08-30T11:39:15.000Z</published>
    <updated>2017-08-30T13:27:38.643Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="水中倒影"><a href="#水中倒影" class="headerlink" title="水中倒影"></a>水中倒影</h4><pre><code>要实现倒影，有两种方式：box-reflect方式和transform方式。
</code></pre><p>box-reflect效果<br>    <img src="/images/box_reflect.png" alt="box-reflect方式"></p>
<h5 id="box-reflect方式（存在兼容性）"><a href="#box-reflect方式（存在兼容性）" class="headerlink" title="box-reflect方式（存在兼容性）"></a>box-reflect方式（存在兼容性）</h5><h6 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h6><pre><code>box-reflect: &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?
参数说明：
</code></pre><ol>
<li>表示倒影的方向，可能值：above、below、left、right（上下左右）；</li>
<li>表示倒影与元素之间的间隔；</li>
<li>表示遮罩图像，可为url地址、渐变<h6 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;./img/demo.png&quot; alt=&quot;&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">       -webkit-box-reflect: below 0 -webkit-linear-gradient(top, rgba(250, 250, 250, 0), rgba(250, 250, 250, .1) 20%, rgba(250, 250, 250, .3));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="transform方式"><a href="#transform方式" class="headerlink" title="transform方式"></a>transform方式</h5><pre><code>这种方式其实就是复制图片，然后翻转，最后同样是使用渐变来充当遮罩层，覆盖在翻转的图片之上。
</code></pre><p>transform效果<br>    <img src="/images/transform_reflect.png" alt="transform方式"></p>
<h6 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;box-reflect&quot;&gt;</div><div class="line">       &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot; /&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h6 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h6><pre><code>使用伪类元素将我们需要将图片克隆一份，然后翻转过来，before存放背景图片，after达到渐变效果，这样after的z-index在before大，就达到了我们想要的效果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">.box-reflect &#123;</div><div class="line">       position: relative;</div><div class="line">       width: 150px;</div><div class="line">       float: left;</div><div class="line">       margin-right: 40px;</div><div class="line">   &#125;</div><div class="line">   .box-reflect img &#123;</div><div class="line">       width: 100%;</div><div class="line">       height: 100%;</div><div class="line">   &#125;</div><div class="line">   .box-reflect:before &#123;</div><div class="line">       background: url(img/demo.png) no-repeat;</div><div class="line">       background-size: 100% 100%;</div><div class="line">       transform: scaleY(-1);</div><div class="line">       /*添加半透明是为了更真实*/</div><div class="line">       opacity: 0.5;</div><div class="line">       filter: alpha(opacity=&apos;50&apos;);</div><div class="line">   &#125;</div><div class="line">   .box-reflect:before, .box-reflect:after &#123;</div><div class="line">       position: absolute;</div><div class="line">       width: 100%;</div><div class="line">       height: 100%;</div><div class="line">       top: 100%;</div><div class="line">       left: 0;</div><div class="line">       content: &quot;&quot;;</div><div class="line">   &#125;</div><div class="line">   .box-reflect:after &#123;</div><div class="line">       background-image: -webkit-linear-gradient(bottom,rgb(0,0,0) 20%,rgba(0,0,0,0) 90%);</div><div class="line">       filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColor=0, EndColorStr=#000000);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="工具提示（tooltip）"><a href="#工具提示（tooltip）" class="headerlink" title="工具提示（tooltip）"></a>工具提示（tooltip）</h4><p>css3设计的tooltip工具<br>    <img src="/images/tooltip.png" alt="tooltip"></p>
<h5 id="创建模版-2"><a href="#创建模版-2" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;toop-group&quot;&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在上方&quot; data-direction=&quot;up&quot;&gt;</div><div class="line">           在上方</div><div class="line">       &lt;/button&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在右方&quot; data-direction=&quot;right&quot;&gt;</div><div class="line">           在右方</div><div class="line">       &lt;/button&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在下方&quot; data-direction=&quot;down&quot;&gt;</div><div class="line">           在下方</div><div class="line">       &lt;/button&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在左方&quot; data-direction=&quot;left&quot;&gt;</div><div class="line">           在左方</div><div class="line">       &lt;/button&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="设置样式-2"><a href="#设置样式-2" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code>总体思路：
</code></pre><ol>
<li>利用伪类before生成提示工具的三角形border来形成。</li>
<li>利用伪类after生成提示内容（长方形）以及获取提示文本content(attr(data-tooltip)),来获取自身的自定义属性data-tooltip。</li>
<li>利用hover效果让其展现，在加入一些css3动画将表现的更好。</li>
<li>使用了calc用于动态计算长度值，使我们的组件更通用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">.tooltip</div><div class="line">&#123;</div><div class="line">	position: relative;</div><div class="line">&#125;</div><div class="line">.tooltip:before</div><div class="line">&#123;</div><div class="line">	position: absolute;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	border: 5px solid transparent;</div><div class="line">&#125;</div><div class="line">.tooltip:after</div><div class="line">&#123;</div><div class="line">	font-size: 14px;</div><div class="line">	line-height: normal;</div><div class="line"></div><div class="line">	position: absolute;</div><div class="line"></div><div class="line">	padding: 5px 10px;</div><div class="line">	content: attr(data-tooltip);</div><div class="line">	white-space: nowrap;</div><div class="line"></div><div class="line">	color: #fff;</div><div class="line">	border-radius: 3px;</div><div class="line">	background: #383838;</div><div class="line">&#125;</div><div class="line">.tooltip:before,</div><div class="line">.tooltip:after</div><div class="line">&#123;</div><div class="line">	z-index: 1000000;</div><div class="line"></div><div class="line">	visibility: hidden;</div><div class="line"></div><div class="line">	-webkit-transition: .3s ease;</div><div class="line">	   -moz-transition: .3s ease;</div><div class="line">			transition: .3s ease;</div><div class="line">	-webkit-transition-delay: 0ms;</div><div class="line">	   -moz-transition-delay: 0ms;</div><div class="line">			transition-delay: 0ms;</div><div class="line">	pointer-events: none;</div><div class="line"></div><div class="line">	opacity: 0;</div><div class="line">&#125;</div><div class="line">.tooltip:hover:before,</div><div class="line">.tooltip:hover:after</div><div class="line">&#123;</div><div class="line">	visibility: visible;</div><div class="line"></div><div class="line">	opacity: 1;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;down&apos;]:before</div><div class="line">&#123;</div><div class="line">	top: -webkit-calc(100% - 5px);</div><div class="line">	top:    -moz-calc(100% - 5px);</div><div class="line">	top:         calc(100% - 5px);</div><div class="line"></div><div class="line">	border-bottom-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;down&apos;]:after</div><div class="line">&#123;</div><div class="line">	top: -webkit-calc(100% + 5px);</div><div class="line">	top:    -moz-calc(100% + 5px);</div><div class="line">	top:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;down&apos;]:before,</div><div class="line">[data-direction=&apos;down&apos;]:after,</div><div class="line">[data-direction=&apos;up&apos;]:before,</div><div class="line">[data-direction=&apos;up&apos;]:after</div><div class="line">&#123;</div><div class="line">	left: 50%;</div><div class="line">	-webkit-transform: translate3d(-50%,0,0);</div><div class="line">	   -moz-transform: translate3d(-50%,0,0);</div><div class="line">			transform: translate3d(-50%,0,0);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;up&apos;]:before</div><div class="line">&#123;</div><div class="line">	bottom: -webkit-calc(100% - 5px);</div><div class="line">	bottom:    -moz-calc(100% - 5px);</div><div class="line">	bottom:         calc(100% - 5px);</div><div class="line"></div><div class="line">	border-top-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;up&apos;]:after</div><div class="line">&#123;</div><div class="line">	bottom: -webkit-calc(100% + 5px);</div><div class="line">	bottom:    -moz-calc(100% + 5px);</div><div class="line">	bottom:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;left&apos;]:before,</div><div class="line">[data-direction=&apos;left&apos;]:after,</div><div class="line">[data-direction=&apos;right&apos;]:before,</div><div class="line">[data-direction=&apos;right&apos;]:after</div><div class="line">&#123;</div><div class="line">	top: 50%;</div><div class="line">	-webkit-transform: translate3d(0,-50%,0);</div><div class="line">	   -moz-transform: translate3d(0,-50%,0);</div><div class="line">			transform: translate3d(0,-50%,0);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;left&apos;]:before</div><div class="line">&#123;</div><div class="line">	left: -5px;</div><div class="line">	border-left-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;left&apos;]:after</div><div class="line">&#123;</div><div class="line">	right: -webkit-calc(100% + 5px);</div><div class="line">	right:    -moz-calc(100% + 5px);</div><div class="line">	right:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;right&apos;]:before</div><div class="line">&#123;</div><div class="line">	left: -webkit-calc(100% - 5px);</div><div class="line">	left:    -moz-calc(100% - 5px);</div><div class="line">	left:         calc(100% - 5px);</div><div class="line"></div><div class="line">	border-right-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;right&apos;]:after</div><div class="line">&#123;</div><div class="line">	left: -webkit-calc(100% + 5px);</div><div class="line">	left:    -moz-calc(100% + 5px);</div><div class="line">	left:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">.toop-group &#123;</div><div class="line">	padding-top: 100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>   参考文档：</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261476" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-box-reflect" target="_blank" rel="external">MDN box-reflect</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css-加强（白光划过效果、3D立方体）</title>
    <link href="https://fanerge.github.io/2017/08/29/css%E5%8A%A0%E5%BC%BA/"/>
    <id>https://fanerge.github.io/2017/08/29/css加强/</id>
    <published>2017-08-29T12:53:23.000Z</published>
    <updated>2017-08-30T12:06:33.632Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="白光划过效果"><a href="#白光划过效果" class="headerlink" title="白光划过效果"></a>白光划过效果</h4><h5 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h5><p>我们要放置一张图片，用一个div包裹起来：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;highlight-box&quot;&gt;</div><div class="line">	&lt;img src=&quot;./img/demo.png&quot; width=&quot;296&quot; height=&quot;374&quot; alt=&quot;s&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h5 id="设置CSS样式"><a href="#设置CSS样式" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><p>定义初始样式:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.highlight-box &#123;</div><div class="line">       /**这里用于before、after伪类定位**/</div><div class="line">       position: relative; </div><div class="line">       width: 296px;</div><div class="line">       height: 374px;</div><div class="line">       overflow: hidden;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>接着让我们来制作白光，我们不需多余的元素，只需使用:before选择器.position为伪类定位：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.highlight-box:before &#123;</div><div class="line">       position: absolute;</div><div class="line">       /* 注意这里top和left，让白光移动到图片左上角，后续的划过动画也是依靠这两个属性 */</div><div class="line">       top: -200%;</div><div class="line">       left: -100%;</div><div class="line">       z-index: 2;</div><div class="line">       display: block;</div><div class="line">       content: &apos;&apos;;</div><div class="line">       /* 定义白光的高宽，hight为300%是为了防止在移动过程中白光不够用 */</div><div class="line">       width: 50%;</div><div class="line">       height: 300%;</div><div class="line">       /* 使用线性渐变来实现白光 */</div><div class="line">       background: linear-gradient(to left top, rgba(255, 255, 255, .05) 20%, rgba(255, 255, 255, .6) 65% , rgba(255, 255, 255, .05) 100%);</div><div class="line">       /* background: rgba(255, 255, 255, .5); */</div><div class="line">       transform: rotate(45deg);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>我们使用渐变（linear-gradient）来实现白光效果，同时为了斜向划过，使用transform: rotate(45deg)将其旋转45度。<br>上面的height、width、top和left，你也可以使用具体的像素值，不过建议采用百分比，这样可以重复使用，而不需手动改变太多值。<br>触发白光(hover伪类和css3动画)：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.highlight-box:hover:before &#123;</div><div class="line">       /* 这里省略了私有前缀代码 */</div><div class="line">       animation: crossed .5s linear;</div><div class="line">   &#125;</div><div class="line">   @keyframes crossed &#123;</div><div class="line">       0% &#123;</div><div class="line">           top: -200%;</div><div class="line">           left: -100%;</div><div class="line">       &#125;</div><div class="line">       100% &#123;</div><div class="line">           top: -50px;</div><div class="line">           left: 100%;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>截图效果(鼠标划入时的效果)<br>        <img src="/images/css_white_light.jpg" alt="白光划过"></p>
<h4 id="3D立方体"><a href="#3D立方体" class="headerlink" title="3D立方体"></a>3D立方体</h4><p>随着CSS3的出现，实现3D效果已经不是难事，这一节就来看看3D立方体是如何实现的。</p>
<h5 id="创建模板-1"><a href="#创建模板-1" class="headerlink" title="创建模板"></a>创建模板</h5><p>首先来放置一个父div.cude，然后在其里面放置6个div，分别表示立方体的6个面。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;cude&quot;&gt;</div><div class="line">	&lt;div class=&quot;front surface&quot;&gt;</div><div class="line">		正面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface left&quot;&gt;</div><div class="line">		左面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface right&quot;&gt;</div><div class="line">		右面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface bottom&quot;&gt;</div><div class="line">		底面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface top&quot;&gt;</div><div class="line">		顶面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface back&quot;&gt;</div><div class="line">		背面</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h5 id="设置CSS样式-1"><a href="#设置CSS样式-1" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">.cude &#123;</div><div class="line">	width:300px;</div><div class="line">	height:300px;</div><div class="line">	position:relative;</div><div class="line">	margin:100px auto;</div><div class="line">	transform-style:preserve-3d;</div><div class="line">	-webkit-transform-style:preserve-3d;</div><div class="line">&#125;</div><div class="line">.surface &#123;</div><div class="line">	position:absolute;</div><div class="line">	top:0;</div><div class="line">	left:0;</div><div class="line">	width:300px;</div><div class="line">	height:300px;</div><div class="line">	background:#666;</div><div class="line">	opacity:0.8;</div><div class="line">	font-size:60px;</div><div class="line">	text-align:center;</div><div class="line">	line-height:300px;</div><div class="line">	font-weight:bold;</div><div class="line">	color:#fff;</div><div class="line">	border:1px solid #fff;</div><div class="line">	-webkit-transition:all .3s;</div><div class="line">	transition:all .3s;</div><div class="line">&#125;</div><div class="line">.surface img &#123;</div><div class="line">	width:100%;</div><div class="line">&#125;</div><div class="line">.front &#123;</div><div class="line">	transform:rotateY(0) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.back &#123;</div><div class="line">	transform:translateZ(-150px) rotateY(180deg);</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">	transform:rotateY(-90deg) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">	transform:rotateY(90deg) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.top &#123;</div><div class="line">	transform:rotateX(90deg) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.bottom &#123;</div><div class="line">	transform:rotateX(90deg) translateZ(-150px);</div><div class="line">&#125;</div><div class="line">@-webkit-keyframes rotate &#123;</div><div class="line">	from &#123;</div><div class="line">		transform: rotateX(0deg) rotateY(0deg);</div><div class="line">	&#125;</div><div class="line">	to &#123;</div><div class="line">		transform: rotateX(360deg) rotateY(360deg);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>总结：</p>
<ol>
<li>使用了before和after伪类</li>
<li>linear-gradient-api的使用</li>
<li>animation</li>
<li>transform(分为2D转换和3D转换)</li>
<li>2d转换：translate(x,y)、translateX(x)、translateY(y)、scale(x,y)、scaleX(x)、scaleY(y)、rotate(angle)、skew(x-angle,y-angle)、skewX(angle)</li>
<li>3d转换：translate3d(x,y,z)、translateZ(z)、scale3d(x,y,z)、scaleZ(z)、rotate3d(x,y,z,angle)、rotateX(angle)、rotateY(angle)、rotateZ(angle)</li>
</ol>
<blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient" target="_blank" rel="external">linear-gradient</a></li>
<li><a href="http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">transform</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ramda运用--官方文档解读</title>
    <link href="https://fanerge.github.io/2017/08/25/ramda%E8%BF%90%E7%94%A8-5/"/>
    <id>https://fanerge.github.io/2017/08/25/ramda运用-5/</id>
    <published>2017-08-25T12:37:40.000Z</published>
    <updated>2017-08-29T12:50:28.911Z</updated>
    
    <content type="html"><![CDATA[<p>从8月25到8月29共5个晚上和小部分周末时间撸完了Ramda官方文档，继续在事件中继续学习。<br>Rmda中共分为List、Relation、Object、Function、Math、Type、Logic、String共8大类。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><pre><code>定义：检测字符串是否匹配给定的正则表达式。
```   
R.test(/^x/, &apos;xyz&apos;); // true
```   
</code></pre><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><pre><code>定义：正则匹配字符串。注意，如果没有匹配项，则返回空数组。和 String.prototype.match 不同，后者在没有匹配项时会返回 null。
```   
R.match(/([a-z]a)/g, &apos;bananas&apos;); //=&gt; [&apos;ba&apos;, &apos;na&apos;, &apos;na&apos;]
```   
</code></pre><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><pre><code>定义：替换字符串的子串或正则匹配到的值。
```   
R.replace(&apos;foo&apos;, &apos;bar&apos;, &apos;foo foo foo&apos;); // bar foo foo
```   
</code></pre><h5 id="split"><a href="#split" class="headerlink" title="split"></a>split</h5><pre><code>定义：根据指定的分隔符将字符串拆分为字符串类型的数组。
```   
R.split(&apos;.&apos;, &apos;a.b.c.xyz.d&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;xyz&apos;, &apos;d&apos;]
```   
</code></pre><h5 id="toLower"><a href="#toLower" class="headerlink" title="toLower"></a>toLower</h5><pre><code>定义：将字符串转换成小写。
```   
R.toLower(&apos;XYZ&apos;); // xyz
```   
</code></pre><h5 id="toUpper"><a href="#toUpper" class="headerlink" title="toUpper"></a>toUpper</h5><pre><code>定义：将字符串转换为大写。
```   
R.toUpper(&apos;abc&apos;); // ABC
```   
</code></pre><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><pre><code>定义：返回代表输入元素的字符串。求得的输出结果应该等价于输入的值。许多内建的 toString 方法都不满足这一条件。
如果输入值是 [object Object] 对象，且自身含有 toString 方法（不是 Object.prototype.toString 方法），那么直接调用这个方法求返回值。
这意味着，通过用户自定义的构造函数可以提供合适的 toString 方法。
```   
R.toString(42); // 42
```   
</code></pre><h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><pre><code>定义：删除字符串首、尾两端的空白字符。
```   
R.trim(&apos;   xyz  &apos;); //=&gt; &apos;xyz&apos;
```   
</code></pre><h4 id="List-Array"><a href="#List-Array" class="headerlink" title="List(Array)"></a>List(Array)</h4><h5 id="adjust"><a href="#adjust" class="headerlink" title="adjust"></a>adjust</h5><pre><code>定义：将数组中指定索引处的值替换为经函数变换的值。
```   
R.adjust(R.add(10))(1)([1, 2, 3]); // [1, 12, 3]
```   
</code></pre><h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><pre><code>定义：如果列表中的所有元素都满足 predicate，则返回 true；否则，返回 false。
```   
var equals3 = R.equals(3);
R.all(equals3)([3, 3, 3]); // true
R.all(equals3)([1, 3, 3]); // false
```   
</code></pre><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><pre><code>定义：只要列表中有一个元素满足 predicate，就返回 true，否则返回 false。
```   
var lessThan0 = R.flip(R.lt)(0);
var lessThan2 = R.flip(R.lt)(2);
R.any(lessThan0)([1, 2]); // false
R.any(lessThan2)([1, 2]); // true
```   
</code></pre><h5 id="aperture"><a href="#aperture" class="headerlink" title="aperture"></a>aperture</h5><pre><code>定义：返回一个新列表，列表中的元素为由原列表相邻元素组成的 n 元组。如果 n 大于列表的长度，则返回空列表。
```   
R.aperture(2, [1, 2, 3, 4, 5]); // [[1, 2], [2, 3], [3, 4], [4, 5]]
```   
</code></pre><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><pre><code>定义：在列表末尾拼接一个元素。
```   
R.append(5)([1, 2, 3]); // [1, 2, 3, 5]
```   
</code></pre><h5 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h5><pre><code>定义：chain 将函数映射到列表中每个元素，并将结果连接起来。 chain 在一些库中也称为 flatMap（先 map 再 flatten ）。
```   
var duplicate = n =&gt; [n, n];
R.chain(duplicate, [1, 2, 3]); // [1, 1, 2, 2, 3, 3]
```        
</code></pre><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><pre><code>定义：连接列表或字符串。
```   
R.concat(&apos;ABC&apos;, &apos;DEF&apos;); // ABCDEF
R.concat([1, 2, 3])([4, 5, 6]); // [1, 2, 3, 4, 5, 6]
```            
</code></pre><h5 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h5><pre><code>定义：只要列表中有一个元素等于指定值，则返回 true；否则返回 false。通过 R.equals 函数进行相等性判断。
```   
R.contains(2, [1, 2, 3]); // true
```       
</code></pre><h5 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h5><pre><code>定义：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。
```   
R.drop(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;zhen&apos;]
R.drop(2, &apos;fanerge&apos;); // nerge
```       
</code></pre><h5 id="dropLast"><a href="#dropLast" class="headerlink" title="dropLast"></a>dropLast</h5><pre><code>定义：删除 &quot;list&quot; 末尾的 n 个元素。
```   
R.dropLast(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;fan&apos;]
R.dropLast(2, &apos;fanerge&apos;); // faner
```       
</code></pre><h5 id="dropLastWhile"><a href="#dropLastWhile" class="headerlink" title="dropLastWhile"></a>dropLastWhile</h5><pre><code>定义：对 list 从后向前一直删除满足 predicate 的尾部元素，直到遇到第一个 falsy 值，此时停止删除操作。
predicate 需要作为第一个参数传入。
```   
var lteThree = x =&gt; x &lt;= 3;
R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3, 4]
```       
</code></pre><h5 id="dropRepeats"><a href="#dropRepeats" class="headerlink" title="dropRepeats"></a>dropRepeats</h5><pre><code>定义：返回一个没有连续重复元素的 list。通过 R.equals 函数进行相等性判断。
```   
R.dropRepeats([1, 1, 2, 2, 3, 3, 2, 2]); // [1, 2, 3, 2] 
```       
</code></pre><h5 id="dropRepeatsWith"><a href="#dropRepeatsWith" class="headerlink" title="dropRepeatsWith"></a>dropRepeatsWith</h5><pre><code>定义：返回一个没有连续重复元素的 list。首个参数提供的 predicate 用于检测 list 中相邻的两个元素是否相等。
一系列相等元素中的首个元素会被保留。
```   
var list = [1, -1, 1, 3, 4, -4];
R.dropRepeatsWith(R.eqBy(Math.abs), list); // [1, 3, 4]
```       
</code></pre><h5 id="dropWhile"><a href="#dropWhile" class="headerlink" title="dropWhile"></a>dropWhile</h5><pre><code>定义：对 list 从前向后删除满足 predicate 的头部元素，直到遇到第一个 falsy 值。
predicate 需要作为第一个参数传入。
```   
var lteTwo = x =&gt; x &lt;= 2;
R.dropWile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); // [3, 4, 3, 2, 1]
```       
</code></pre><h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h5><pre><code>定义：检查列表或字符串是否以给定的值结尾。
```   
R.endsWith(&apos;c&apos;, &apos;abc&apos;); // true
R.endsWith([&apos;c&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true
```       
</code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><pre><code>定义：使用 predicate 遍历传入的 Filterable，返回满足 predicate 的所有元素的新的 Filterable。新 Filterable 与原先的类型相同。Filterable 类型包括 plain object 或者任何带有 filter 方法的类型，如 Array 。
```   
var isEven = n =&gt; n % 2 === 0;
R.filter(isEven, [1, 2, 3, 4]); // [2, 4]
```       
</code></pre><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><pre><code>定义：查找并返回 list 中首个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。
```   
var xs = [{a: 1}, {a: 2}, {a: 3}];
R.find(R.propEq(&apos;a&apos;, 2))(xs); // {a: 2}
```   
</code></pre><h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h5><pre><code>定义：查找并返回 list 中首个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。
```   
var xs = [{a: 1}, {a: 2}, {a: 3}];
R.findIndex(R.propEq(&apos;a&apos;, 2))(xs); // 1
```   
</code></pre><h5 id="findLast"><a href="#findLast" class="headerlink" title="findLast"></a>findLast</h5><pre><code>定义：查找并返回 list 中最后一个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。
```   
var xs = [{a: 1, b: 0}, {a:1, b: 1}];
R.findLast(R.propEq(&apos;a&apos;, 1))(xs); // {a: 1, b: 1}
```   
</code></pre><h5 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h5><pre><code>定义：查找并返回 list 中最后一个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。
```   
var xs = [{a: 1, b: 0}, {a:1, b: 1}];
R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs); // 1
```   
</code></pre><h5 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h5><pre><code>定义：获取 list 的所有元素（包含所有子数组中的元素），然后由这些元素组成一个新的数组。深度优先。
```   
R.flatten([1, [2, [3]]]); // [1, 2, 3]
```   
</code></pre><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><pre><code>定义：遍历 list，对 list 中的每个元素执行方法 fn。
Ramda 的 forEach 会将原数组返回。
```   
var printPlusFive = x =&gt; console.log(x + 5);
R.forEach(printPlusFive, [1, 2, 3]); // [1, 2, 3]
```   
</code></pre><h5 id="fromPairs"><a href="#fromPairs" class="headerlink" title="fromPairs"></a>fromPairs</h5><pre><code>定义：由一系列 “键值对” 创建一个 object。如果某个键出现多次，选取最右侧的键值对。
```   
var R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]); // {a: 1, b: 2, c: 3}
```   
</code></pre><h5 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h5><pre><code>定义：将列表根据一定规则拆分成多组子列表，并存储在一个对象中。
对列表中的每个元素调用函数，根据函数返回结果进行分组。
函数返回字符串作为相等性判断，返回的字符串作为存储对象的键，具有相同返回字符串的元素聚合为数组，作为该键的值。
```   
var byGrade = R.groupBy(function(student) {
  var score = student.score;
  return score &lt; 65 ? &apos;F&apos; :
         score &lt; 70 ? &apos;D&apos; :
         score &lt; 80 ? &apos;C&apos; :
         score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;
});
var students = [{name: &apos;Abby&apos;, score: 84},
                {name: &apos;Eddy&apos;, score: 58},
                // ...
                {name: &apos;Jack&apos;, score: 69}];
byGrade(students);
// {
//   &apos;A&apos;: [{name: &apos;Dianne&apos;, score: 99}],
//   &apos;B&apos;: [{name: &apos;Abby&apos;, score: 84}]
//   // ...,
//   &apos;F&apos;: [{name: &apos;Eddy&apos;, score: 58}]
// }
```   
</code></pre><h5 id="groupWith"><a href="#groupWith" class="headerlink" title="groupWith"></a>groupWith</h5><pre><code>定义：通过给定的对比函数，将列表按顺序分割成多组子列表。
对比函数只比较相邻元素。
```   
var R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 13, 21]); 
// [[0], [1, 1], [2], [3], [5], [13], [21]]
```   
</code></pre><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><pre><code>定义：求列表或字符串的首个元素。在某些库中，该函数也被称作 first。
```   
R.head([1, 2, 3]); // 1
R.head(&apos;fan&apos;); // f
```   
</code></pre><h5 id="indexBy"><a href="#indexBy" class="headerlink" title="indexBy"></a>indexBy</h5><pre><code>定义：通过生成键的函数，将元素为对象的 list 转换为以生成的键为索引的新对象。注意，如果 list 中多个对象元素生成相同的键，以最后一个对象元素作为该键的值。
```   
var list = [{id: &apos;xyz&apos;, title: &apos;A&apos;}, {id: &apos;abc&apos;, title: &apos;B&apos;}];
R.indexBy(R.prop(&apos;id&apos;), list);
//=&gt; {abc: {id: &apos;abc&apos;, title: &apos;B&apos;}, xyz: {id: &apos;xyz&apos;, title: &apos;A&apos;}}
```   
</code></pre><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><pre><code>定义：返回给定元素在数组中首次出现时的索引值，如果数组中没有该元素，则返回 -1。通过 R.equals 函数进行相等性判断。
```   
R.indexOf(3, [1, 2, 3, 4]); // 2
```       
</code></pre><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><pre><code>定义：返回 list 或 string 删除最后一个元素后的部分。
```   
R.init([1, 2, 3]);  //=&gt; [1, 2]
R.init(&apos;abc&apos;);  //=&gt; &apos;ab&apos;
```       
</code></pre><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><pre><code>定义：将元素插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。
```   
R.insert(2, &apos;x&apos;, [1, 2, 3, 4]); // [1,2,&apos;x&apos;,3,4]
```       
</code></pre><h5 id="insertAll"><a href="#insertAll" class="headerlink" title="insertAll"></a>insertAll</h5><pre><code>定义：将子 list 插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。
```   
R.insertAll(2, [&apos;x&apos;, &apos;y&apos;], [1, 2, 3, 4]); // [1, 2, &apos;x&apos;, &apos;y&apos;, 3, 4]
```       
</code></pre><h5 id="intersperse"><a href="#intersperse" class="headerlink" title="intersperse"></a>intersperse</h5><pre><code>定义：在列表的元素之间插入分割元素。
```   
R.intersperse(&apos;n&apos;, [&apos;ba&apos;, &apos;a&apos;, &apos;a&apos;]); //=&gt; [&apos;ba&apos;, &apos;n&apos;, &apos;a&apos;, &apos;n&apos;, &apos;a&apos;]
```       
</code></pre><h5 id="into"><a href="#into" class="headerlink" title="into"></a>into</h5><pre><code>定义：使用 transducer 对 list 中的元素进行转换，然后使用基于 accumulator 的类型的迭代器函数将转换后的元素依次添加到 accumulator 上。
```   
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));
R.into([], transducer, numbers); //=&gt; [2, 3]
```       
</code></pre><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><pre><code>定义：将列表中所有元素通过 分隔符 串连为一个字符串。
```   
var spacer = R.join(&apos;#&apos;);
spacer([1, 2, 3]); // 1#2#3
```       
</code></pre><h5 id="last"><a href="#last" class="headerlink" title="last"></a>last</h5><pre><code>定义：返回列表或字符串的最后一个元素。
```   
R.last([&apos;fan&apos;, &apos;zhen&apos;, &apos;yu&apos;]); // yu
R.last(&apos;abc&apos;); // c
```       
</code></pre><h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><pre><code>定义：返回数组中某元素最后一次出现的位置，如果数组中不包含该项则返回 -1 。通过 R.equals 函数进行相等性判断。
```   
R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); // 6
```   
</code></pre><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><pre><code>定义：通过 list.length，返回数组的大小（数组中元素的数量）。
```   
R.length([]); // 0
```   
</code></pre><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><pre><code>定义：接收一个函数和一个 functor, 将该函数应用到 functor 的每个值上，返回一个具有相同形态的 functor。
Ramda 为 Array 和 Object 提供了合适的 map 实现，因此 R.map 适用于 [1, 2, 3] 或 {x: 1, y: 2, z: 3}。
若第二个参数自身存在 map 方法，则调用自身的 map 方法。
```   
var double = x =&gt; x * 2;
R.map(double, [1, 2, 3]); // [2, 4, 6]
```   
</code></pre><h5 id="mapAccum"><a href="#mapAccum" class="headerlink" title="mapAccum"></a>mapAccum</h5><pre><code>定义：mapAccum 的行为类似于 map 和 reduce 的组合；
它将迭代函数作用于列表中的每个元素，从左往右传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。 
迭代函数接收两个参数，acc 和 value， 返回一个元组 [acc, value]。
```   
var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];
var appender = (a, b) =&gt; [a + b, a + b];
R.mapAccum(appender, 0, digits); // [&apos;01234&apos;, [&apos;01&apos;, &apos;012&apos;, &apos;0123&apos;, &apos;01234&apos;]]
```   
</code></pre><h5 id="mapAccumRight"><a href="#mapAccumRight" class="headerlink" title="mapAccumRight"></a>mapAccumRight</h5><pre><code>定义：mapAccumRight 的行为类似于 map 和 reduce 的组合；
它将迭代函数作用于列表中的每个元素，从右往左传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。
和 mapAccum 类似，除了列表遍历顺序是从右往左的。
迭代函数接收两个参数，value 和 acc ，返回一个元组 [value, acc]。
```   
var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];
var append = (a, b) =&gt; [a + b, a + b];
R.mapAccumRight(append, 5, digits); // [[&apos;12345&apos;, &apos;2345&apos;, &apos;345&apos;, &apos;45&apos;], &apos;12345&apos;]
```   
</code></pre><h5 id="mapObjIndexed"><a href="#mapObjIndexed" class="headerlink" title="mapObjIndexed"></a>mapObjIndexed</h5><pre><code>定义：Object 版本的 map。mapping function 接受三个参数： (value, key, obj) 。如果仅用到参数 value，则用 map 即可。
```   
var values = {x: 1, y: 2, z: 3};
var prependKeyAndDouble = (val, key, obj) =&gt; key + (val * 2);
R.mapIndexed(prependKeyAndDouble, values); // { x: &apos;x2&apos;, y: &apos;y4&apos;, z: &apos;z6&apos; }
```   
</code></pre><h5 id="mergaAll"><a href="#mergaAll" class="headerlink" title="mergaAll"></a>mergaAll</h5><pre><code>定义：将对象类型列表合并为一个对象。
```   
R.mergeAll([{foo: 1}, {bar: 2}, {baz: 3}]); // {foo: 1, bar: 2, baz: 3}
```   
</code></pre><h5 id="none"><a href="#none" class="headerlink" title="none"></a>none</h5><pre><code>定义：如果列表中的元素都不满足 predicate，返回 true；否则返回 false。
```   
var isEven = n =&gt; n % 2 === 0;
R.none(isEven, [1, 2, 3]); // true
```   
</code></pre><h5 id="nth"><a href="#nth" class="headerlink" title="nth"></a>nth</h5><pre><code>定义：返回列表或字符串的第 n 个元素。如果 n 为负数，则返回索引为 length + n 的元素。
```   
var list = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;quux&apos;];
R.nth(1, list); // &apos;bar&apos;
```   
</code></pre><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><pre><code>定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。
```   
R.pair(&apos;foo&apos;, &apos;bar&apos;); // [&apos;foo&apos;, &apos;bar&apos;]
```   
</code></pre><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><pre><code>定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。
```   
R.partition(R.contains(&apos;s&apos;), [&apos;sss&apos;, &apos;ttt&apos;, &apos;foo&apos;, &apos;bars&apos;]);
// [ [ &apos;sss&apos;, &apos;bars&apos; ],  [ &apos;ttt&apos;, &apos;foo&apos; ] ]
```   
</code></pre><h5 id="pluck"><a href="#pluck" class="headerlink" title="pluck"></a>pluck</h5><pre><code>定义：从列表内的每个对象元素中取出特定名称的属性，组成一个新的列表。
pluck 可以作用于任何 functor ，包括 Array，因为它等价于 R.map(R.prop(k), f)。
```   
R.pluck(&apos;a&apos;)([{a: 1}, {a: 2}]); // [1, 2]
```   
</code></pre><h5 id="prepend"><a href="#prepend" class="headerlink" title="prepend"></a>prepend</h5><pre><code>定义：在列表头部之前拼接一个元素。
```   
R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); // [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]
```   
</code></pre><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><pre><code>定义：返回从 from 到 to 之间的所有数的升序列表。左闭右开（包含 from，不包含 to）。
```   
R.range(1, 5); // [1, 2, 3, 4]
```   
</code></pre><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><pre><code>定义：左折叠操作。
遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。
可以用 R.reduced 提前终止遍历操作。
```   
R.reduce(R.subtract, 0, [1, 2, 3, 4]) // =&gt; ((((0 - 1) - 2) - 3) - 4) = -10
```   
</code></pre><h5 id="reduceBy"><a href="#reduceBy" class="headerlink" title="reduceBy"></a>reduceBy</h5><pre><code>定义：首先对列表中的每个元素调用函数 keyFn ，根据 keyFn 返回的字符串对列表元素进行分组。
然后调用 reducer 函数 valueFn，对组内的元素进行折叠操作。
该函数相当于更通用的 groupBy 函数。
```   
var reduceToNamesBy = R.reduceBy((acc, student) =&gt; acc.concat(student.name), []);
var namesByGrade = reduceToNamesBy(function(student) {
  var score = student.score;
  return score &lt; 65 ? &apos;F&apos; :
         score &lt; 70 ? &apos;D&apos; :
         score &lt; 80 ? &apos;C&apos; :
         score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;
});
var students = [{name: &apos;Lucy&apos;, score: 92},
                {name: &apos;Drew&apos;, score: 85},
                {name: &apos;Bart&apos;, score: 62}];
namesByGrade(students);
// {
//   &apos;A&apos;: [&apos;Lucy&apos;],
//   &apos;B&apos;: [&apos;Drew&apos;]
//   &apos;F&apos;: [&apos;Bart&apos;]
// }
```   
</code></pre><h5 id="reduced"><a href="#reduced" class="headerlink" title="reduced"></a>reduced</h5><pre><code>定义：返回一个封装的值，该值代表 reduce 或 transduce 操作的最终结果。
返回值是一个黑盒：不保证其内部结构的稳定性。
```   
R.reduce(
    (acc, item) =&gt; item &gt; 3 ? R.reduced(acc) : acc.concat(item),
    [],
    [1, 2, 3, 4, 5]
); // [1, 2, 3]
```   
</code></pre><h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h5><pre><code>定义：右折叠操作。
遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。
类似于 reduce，除了遍历列表的顺序是从右向左的。
```   
R.reduceRight(R.subtract, 0, [1, 2, 3, 4]); // (1 - (2 - (3 - (4 - 0)))) = -2
```   
</code></pre><h5 id="reduceWhile"><a href="#reduceWhile" class="headerlink" title="reduceWhile"></a>reduceWhile</h5><pre><code>定义：与 reduce 类似， reduceWhile 会遍历列表，相继调用二元迭代函数，并返回最终累积值。
reduceWhile 在每次调用迭代函数前，先使用 predicate 进行判断，如果 predicate 返回 false ，则提前终止遍历操作，并返回当前累积值。
```   
var isOdd = (acc, x) =&gt; x % 2 === 1;
var xs = [1, 3, 5, 60, 777, 800];
R.reduceWhile(isOdd, R.add, 0, xs); // 9
```   
</code></pre><h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><pre><code>定义：filter 的补操作。返回结果为 R.filter 操作结果的补集。
```   
var isOdd = (acc, x) =&gt; x % 2 === 1;
R.reject(isOdd, [1, 2, 3, 4]); // [2, 4]
```   
</code></pre><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><pre><code>定义：删除列表中从 start 开始的 count 个元素。_ 注意，该操作是非破坏性的：不改变原列表，返回处理后列表的拷贝。
```   
R.remove(2, 3, [1, 2, 3, 4, 5, 6, 7, 8]); // [1, 2, 6, 7, 8]
```   
</code></pre><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><pre><code>定义：生成包含 n 个同一元素的数组。
```   
R.repeat(&apos;h&apos;, 5); // [&apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;]
```   
</code></pre><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><pre><code>定义：对列表或字符串的排列顺序取反。
```   
R.reverse([1, 2, 3]); // [3, 2, 1]
```   
</code></pre><h5 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h5><pre><code>定义：Scan 与 reduce 类似，但会将每次迭代计算的累积值记录下来，组成一个列表返回。
```   
var numbers = [1, 2, 3, 4];
var factorials = R.scan(R.multiply, 1, numbers); // [1, 1, 2, 6, 24]
```   
</code></pre><h5 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h5><pre><code>定义：将一个 Applicative 的 Traversable 转换成一个 Traversable 类型的 Applicative。
```   
R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=&gt; Just([1, 2, 3])
```   
</code></pre><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><pre><code>定义：取出给定的列表或字符串（或带有 slice 方法的对象）中，从 fromIndex（包括）到 toIndex（不包括）的元素。
```   
R.slice(1, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]); // [&apos;b&apos;, &apos;c&apos;]
```   
</code></pre><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><pre><code>定义：使用比较函数对列表进行排序。比较函数每次接受两个参数，如果第一个值较小，则返回负数；如果第一个值较大，则返回正数；如果两值相等，返回零。注意，返回的是列表的 拷贝 ，不会修改原列表。
```   
var diff = function (a, b) { return a - b };
R.sort(diff, [4, 2, 7, 5]); // [2, 4, 5, 7]
```   
</code></pre><h5 id="splitAt"><a href="#splitAt" class="headerlink" title="splitAt"></a>splitAt</h5><pre><code>定义：在指定的索引处拆分列表或者字符串。
```   
R.splitAt(1, [1, 2, 3]); // [[1], [2, 3]]
R.splitAt(5, &apos;hello world&apos;); // [&apos;hello&apos;, &apos;world&apos;]
```   
</code></pre><h5 id="splitEvery"><a href="#splitEvery" class="headerlink" title="splitEvery"></a>splitEvery</h5><pre><code>定义：将列表拆分成指定长度的子列表集。
```   
R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); // [[1, 2, 3], [4, 5, 6], 7]
R.splitEvery(3, &apos;foobarbaz&apos;); //=&gt; [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]
```   
</code></pre><h5 id="splitWhen"><a href="#splitWhen" class="headerlink" title="splitWhen"></a>splitWhen</h5><pre><code>定义：查找列表中首个满足 predicate 的元素，在该处将列表拆分为两部分。首个满足 predicate 的元素包含在后一部分。
```   
R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=&gt; [[1], [2, 3, 1, 2, 3]]
```   
</code></pre><h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h5><pre><code>定义：检查列表是否以给定的值开头。
```   
R.startsWith(&apos;a&apos;, &apos;abc&apos;); // true
R.startsWith([&apos;a&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true
```   
</code></pre><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><pre><code>定义：删除列表中的首个元素（或者调用对象的 tail 方法）。
```   
R.tail([1, 2, 3]); // [2, 3]
```   
</code></pre><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><pre><code>定义：返回列表的前 n 个元素、字符串的前n个字符或者用作 transducer/transform（或者调用对象的 take 方法）。
```   
R.take(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;]
```   
</code></pre><h5 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h5><pre><code>定义：返回列表的后 n 个元素。如果 n &gt; list.length，则返回 list.length 个元素。
```   
R.takeLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;baz&apos;]
```   
</code></pre><h5 id="takeLastWhile"><a href="#takeLastWhile" class="headerlink" title="takeLastWhile"></a>takeLastWhile</h5><pre><code>定义：从后往前取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。
```   
var isNotOne = x =&gt; x !== 1;
R.takeLastWhile(isNotOne, [1, 2, 3, 4]); // [2, 3, 4]
```   
</code></pre><h5 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h5><pre><code>定义：从前往后取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。
```   
var isNotFour = x =&gt; x !== 4;
R.takeLastWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3]
```   
</code></pre><h5 id="times"><a href="#times" class="headerlink" title="times"></a>times</h5><pre><code>定义：执行输入的函数 n 次，返回由函数执行结果组成的数组。
fn 为一元函数，n 次调用接收的参数为：从 0 递增到 n-1 。
```   
R.times(R.identity, 5); // [0, 1, 2, 3, 4]
```   
</code></pre><h5 id="transduce"><a href="#transduce" class="headerlink" title="transduce"></a>transduce</h5><pre><code>定义：用 iterator function 初始化 transducer ，生成一个 transformed iterator function。
然后顺次遍历列表，对每个列表元素先进行转换，然后与累积值进行归约，返回值作为下一轮迭代的累积值。最终返回与初始累积值类型相同的一个累积值。
```   
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));
R.transduce(transducer, R.flip(R.append), [], numbers); //=&gt; [2, 3]
```   
</code></pre><h5 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h5><pre><code>定义：二维数组行列转置。输入 n 个长度为 x 的数组，输出 x 个长度为 n 的数组。
```   
R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
```       
</code></pre><h5 id="traverse"><a href="#traverse" class="headerlink" title="traverse"></a>traverse</h5><pre><code>定义：将返回值为 Applicative 类型的函数映射到一个 Traversable 上。
然后使用 sequence 将结果由 Traversable of Applicative 转换为 Applicative of Traversable。
```   
var safeDiv = n =&gt; d =&gt; d === 0 ? Nothing() : Just(n / d);
R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=&gt; Just([5, 2.5, 2])
```       
</code></pre><h5 id="unfold"><a href="#unfold" class="headerlink" title="unfold"></a>unfold</h5><pre><code>定义：通过一个种子值（ seed ）创建一个列表。unfold 接受一个迭代函数：
该函数或者返回 false 停止迭代，或者返回一个长度为 2 的数组：数组首个元素添加到结果列表，第二个元素作为种子值传给下一轮迭代使用。
```   
var f = n =&gt; n &gt; 50 ? false : [-n, n + 10];
R.unfold(f, 10); //=&gt; [-10, -20, -30, -40, -50]
```       
</code></pre><h5 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h5><pre><code>定义：列表去重操作。返回无重复元素的列表。通过 R.equals 函数进行相等性判断。
```   
R.uniq([1, 1, 2, 1]); // [1, 2]
```   
</code></pre><h5 id="uniqBy"><a href="#uniqBy" class="headerlink" title="uniqBy"></a>uniqBy</h5><pre><code>定义：返回无重复元素的列表。元素通过给定的函数的返回值以及 R.equals 进行相同性判断。如果给定的函数返回值相同，保留第一个元素。
```   
R.uniqBy(Math.abs, [1, -1, 2, 1]); // [1, 2]
```   
</code></pre><h5 id="uniqWith"><a href="#uniqWith" class="headerlink" title="uniqWith"></a>uniqWith</h5><pre><code>定义：返回无重复元素的列表。元素通过 predicate 进行相同性判断。如果通过 predicate 判断两元素相同，保留第一个元素。
```   
var strEq = R.eqBy(String);
R.uniqWith(strEq)([1, &apos;1&apos;, 2, 1]); //=&gt; [1, 2]
```   
</code></pre><h5 id="unnest"><a href="#unnest" class="headerlink" title="unnest"></a>unnest</h5><pre><code>定义：R.chain(R.identity) 的简写, 对 Chain 类型的数据消除一层嵌套。
```   
R.unnest([1, [2], [[3]]]); //=&gt; [1, 2, [3]]
```   
</code></pre><h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><pre><code>定义：替换数组中指定索引处的值。
```   
R.update(1, 11, [0, 1, 2]); // [0, 11, 2]
```   
</code></pre><h5 id="without"><a href="#without" class="headerlink" title="without"></a>without</h5><pre><code>定义：求第二个列表中，未包含在第一个列表中的任一元素的集合。通过 R.equals 函数进行相等性判断。
```   
R.without([1, 2], [1, 2, 1, 3, 4]); // [3, 4]
```   
</code></pre><h5 id="xprod"><a href="#xprod" class="headerlink" title="xprod"></a>xprod</h5><pre><code>定义：将两个列表的元素两两组合，生成一个新的元素对列表。
```   
R.xprod([1, 2], [&apos;a&apos;, &apos;b&apos;]); // [[1, &apos;a&apos;], [1, &apos;b&apos;], [2, &apos;a&apos;], [2, &apos;b&apos;]]
```   
</code></pre><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><pre><code>定义：将两个列表对应位置的元素组合，生成一个新的元素对列表。生成的列表长度取决于较短的输入列表的长度。
注意，zip 等价于 zipWith(function(a, b) { return [a, b] }) 。
```   
R.zip([1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]
```   
</code></pre><h5 id="zipObj"><a href="#zipObj" class="headerlink" title="zipObj"></a>zipObj</h5><pre><code>定义：将两个列表对应位置的元素作为键值对组合，生成一个新的键值对的列表。生成的列表长度取决于较短的输入列表的长度。
注意，zip 等价于 pipe(zipWith(pair), fromPairs) 。
```   
R.zipObj([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]); // {a: 1, b: 2, c: 3}
```   
</code></pre><h5 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h5><pre><code>定义：将两个列表对应位置的元素通过一个函数处理，生成一个新的元素的列表。生成的列表长度取决于较短的输入列表的长度。
```   
var f = (x, y) =&gt; {
  // ...
};
R.zipWith(f, [1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);
//=&gt; [f(1, &apos;a&apos;), f(2, &apos;b&apos;), f(3, &apos;c&apos;)]
```   
</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="assoc"><a href="#assoc" class="headerlink" title="assoc"></a>assoc</h5><pre><code>定义：浅复制对象，然后设置或覆盖对象的指定属性。
```   
R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); {a: 1, b: 2, c: 3}
```       
</code></pre><h5 id="assocPath"><a href="#assocPath" class="headerlink" title="assocPath"></a>assocPath</h5><pre><code>定义：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。
```   
R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); // {a: {b: {c: 42}}}
```       
</code></pre><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><pre><code>定义：深复制。其值可能（嵌套）包含 Array、Object、Number、String、Boolean、Date 类型的数据。Function 通过引用复制。
```   
var objects = [{}, {}, {}];
var objectsClone = R.clone(objects);
objects === objectsClone; // true
```           
</code></pre><h5 id="dissoc"><a href="#dissoc" class="headerlink" title="dissoc"></a>dissoc</h5><pre><code>定义：删除对象中指定 prop 属性。
```   
R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); // {a: 1, c: 3}
```           
</code></pre><h5 id="dissocPath"><a href="#dissocPath" class="headerlink" title="dissocPath"></a>dissocPath</h5><pre><code>定义：浅复制对象，删除返回对象中指定路径上的属性。
```   
R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); // {a: {b: {}}}
```       
</code></pre><h5 id="eqProps"><a href="#eqProps" class="headerlink" title="eqProps"></a>eqProps</h5><pre><code>定义：判断两个对象指定的属性值是否相等。通过 R.equals 函数进行相等性判断。可用作柯里化的 predicate 。
```   
var o1 = {a: 1, b: 2, c: 3, d: 4};
var o2 = {a: 10, b: 20, c: 3, d: 40};
R.eqProps(&apos;a&apos;, o1, o2); // false
```       
</code></pre><h5 id="evolve"><a href="#evolve" class="headerlink" title="evolve"></a>evolve</h5><pre><code>定义：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。所有非原始类型属性都通过引用来复制。
如果某个 transformation 函数对应的键在被变换的 object 中不存在，那么该方法将不会执行。
```   
var tomato  = {firstName: &apos;  Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123};
var transformations = {
    firstName: R.trim,
    lastName: R.trim, // Will not get invoked
    data: {elapsed: R.add(1), remaining: R.add(-1)}
};
R.evolve(transformations, tomato); // {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123}
```       
</code></pre><h5 id="forEachObjIndexed"><a href="#forEachObjIndexed" class="headerlink" title="forEachObjIndexed"></a>forEachObjIndexed</h5><pre><code>定义：遍历 object，对 object 中的每对 key 和 value 执行方法 fn。
fn 接收三个参数: (value, key, obj).
```   
var printKeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value);
R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=&gt; {x: 1, y: 2}
```       
</code></pre><h5 id="has"><a href="#has" class="headerlink" title="has"></a>has</h5><pre><code>定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。
```   
R.has(&apos;name&apos;)({name: &apos;fanerge&apos;}); // true
```       
</code></pre><h5 id="hasIn"><a href="#hasIn" class="headerlink" title="hasIn"></a>hasIn</h5><pre><code>定义：如果对象自身或原型链上含有指定的属性，则返回 true；否则返回 false。
```   
var Rect = function (w, h) {
    this.width = w;
    this.height = h;
};
Rect.prototype.area = function (){
    return this.width * this.heigth;
};
var rect1 = new Rect(100, 200);
R.hasIn(&apos;area&apos;)(rect1); // true
```       
</code></pre><h5 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h5><pre><code>定义：与 R.invertObj 类似，但会将值放入数组中，来处理一个键对应多个值的情况。
```   
var raceResultsByFirstName = {
  first: &apos;alice&apos;,
  second: &apos;jake&apos;,
  third: &apos;alice&apos;,
};
R.invert(raceResultsByFirstName);
//=&gt; { &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] }
```       
</code></pre><h5 id="invertObj"><a href="#invertObj" class="headerlink" title="invertObj"></a>invertObj</h5><pre><code>定义：将对象的键、值交换位置：值作为键，对应的键作为值。交换后的键会被强制转换为字符串。注意，如果原对象同一值对应多个键，采用最后遍历到的键。
```   
var raceResults = {
  first: &apos;alice&apos;,
  second: &apos;jake&apos;
};
R.invertObj(raceResults);
//=&gt; { &apos;alice&apos;: &apos;first&apos;, &apos;jake&apos;:&apos;second&apos; }
```       
</code></pre><h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><pre><code>定义：返回给定对象所有可枚举的、自身属性的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.keys({a: 1, b: 2, c: 3}); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
```       
</code></pre><h5 id="keysIn"><a href="#keysIn" class="headerlink" title="keysIn"></a>keysIn</h5><pre><code>定义：返回给定对象所有属性（包括 prototype 属性）的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function () { this.x = &apos;X&apos; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.keysIn(f); // [&apos;x&apos;, &apos;y&apos;]
```       
</code></pre><h5 id="lens"><a href="#lens" class="headerlink" title="lens"></a>lens</h5><pre><code>定义：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。
setter 不会改变原数据。
```   
var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));
R.view(xLens, {x: 1, y: 2}); // 1
R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2}
R.over(xLens, R.negate, {x: 1, y: 2}); // {x: -1, y: 2}
```       
</code></pre><h5 id="lensIndex"><a href="#lensIndex" class="headerlink" title="lensIndex"></a>lensIndex</h5><pre><code>定义：返回聚焦到指定索引的 lens。
```   
var headLens = R.lensIndex(0);
R.view(headLens, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // a
R.set(headLens, &apos;x&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;x&apos;, &apos;b&apos;, &apos;c&apos;]
R.over(headLens, R.toUpper, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]
```       
</code></pre><h5 id="lensPath"><a href="#lensPath" class="headerlink" title="lensPath"></a>lensPath</h5><pre><code>定义：返回聚焦到指定路径的 lens。
```   
var xHeadYLens = R.lensPath([&apos;x&apos;, 0, &apos;y&apos;]);
R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // 2
R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
```       
</code></pre><h5 id="lensProp"><a href="#lensProp" class="headerlink" title="lensProp"></a>lensProp</h5><pre><code>定义：返回聚焦到指定属性的 lens。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.view(xLens, {x: 1, y: 2});            //=&gt; 1
R.set(xLens, 4, {x: 1, y: 2});          //=&gt; {x: 4, y: 2}
R.over(xLens, R.negate, {x: 1, y: 2});  //=&gt; {x: -1, y: 2}
```       
</code></pre><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。
```   
R.merge({&apos;name&apos;: &apos;fanerge&apos;, &apos;age&apos;: 10}, {age: 30}); // {&apos;name&apos;: &apos;fanerge&apos;, age: 30}
```   
</code></pre><h5 id="mergaDeepLeft"><a href="#mergaDeepLeft" class="headerlink" title="mergaDeepLeft"></a>mergaDeepLeft</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个值都是对象，则继续递归合并这两个值。
否则，采用第一个对象的值。
```   
R.mergeDeepLeft({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }},
            { age: 40, contact: { email: &apos;baa@example.com&apos; }});
// { name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }}
```   
</code></pre><h5 id="mergaDeepRight"><a href="#mergaDeepRight" class="headerlink" title="mergaDeepRight"></a>mergaDeepRight</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个值都是对象，则继续递归合并这两个值。
否则，采用第二个对象的值。
```   
R.mergeDeepRight({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }},
             { age: 40, contact: { email: &apos;baa@example.com&apos; }});
// { name: &apos;fred&apos;, age: 40, contact: { email: &apos;baa@example.com&apos; }}
```   
</code></pre><h5 id="mergaDeepWith"><a href="#mergaDeepWith" class="headerlink" title="mergaDeepWith"></a>mergaDeepWith</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个关联的值都是对象，则继续递归合并这两个值。
否则，使用给定函数对两个值进行处理，并将返回值作为该 key 的新值。
如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。
```   
R.mergeDeepWith(R.concat,
            { a: true, c: { values: [10, 20] }},
            { b: true, c: { values: [15, 35] }});
// { a: true, b: true, c: { values: [10, 20, 15, 35] }}
```   
</code></pre><h5 id="mergeDeepWithKey"><a href="#mergeDeepWithKey" class="headerlink" title="mergeDeepWithKey"></a>mergeDeepWithKey</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个关联的值都是对象，则继续递归合并这两个值。
否则，使用给定函数对该 key 和对应的两个值进行处理，并将返回值作为该 key 的新值。
如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。
```   
let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r
R.mergeDeepWithKey(concatValues,
                   { a: true, c: { thing: &apos;foo&apos;, values: [10, 20] }},
                   { b: true, c: { thing: &apos;bar&apos;, values: [15, 35] }});
// { a: true, b: true, c: { thing: &apos;bar&apos;, values: [10, 20, 15, 35] }}
```       
</code></pre><h5 id="mergeWith"><a href="#mergeWith" class="headerlink" title="mergeWith"></a>mergeWith</h5><pre><code>定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。
如果某个 key 在两个对象中都存在，则使用给定的函数对每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。
```   
R.mergeWith(R.concat, 
                {a: true, values: [10, 20]}, 
                {b: true, values: [15, 35]});
// {a: true, b: true, values: [10, 20, 15, 35]}
```       
</code></pre><h5 id="mergeWithKey"><a href="#mergeWithKey" class="headerlink" title="mergeWithKey"></a>mergeWithKey</h5><pre><code>定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。
如果某个 key 在两个对象中都存在，则使用给定的函数对该 key 和每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。
```   
let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r
R.mergeWithKey(concatValues,
               { a: true, thing: &apos;foo&apos;, values: [10, 20] },
               { b: true, thing: &apos;bar&apos;, values: [15, 35] });
// { a: true, b: true, thing: &apos;bar&apos;, values: [10, 20, 15, 35] }
```       
</code></pre><h5 id="objOf"><a href="#objOf" class="headerlink" title="objOf"></a>objOf</h5><pre><code>定义：创建一个包含单个键值对的对象。
```   
var matchPhrases = R.compose(
    R.objOf(&apos;must&apos;),
    R.map(R.objOf(&apos;match_phrase&apos;))
);
matchPhrases([&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; {must: [{match_phrase: &apos;foo&apos;}, {match_phrase: &apos;bar&apos;}, {match_phrase: &apos;baz&apos;}]}
```   
</code></pre><h5 id="omit"><a href="#omit" class="headerlink" title="omit"></a>omit</h5><pre><code>定义：删除对象中给定的 keys 对应的属性。
```   
R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {b: 2, c: 3}
```       
</code></pre><h5 id="over"><a href="#over" class="headerlink" title="over"></a>over</h5><pre><code>定义：对数据结构中被 lens 聚焦的部分进行函数变换。
```   
var headLens = R.lensIndex(0);
R.over(headLens, R.toUpper, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); // [&apos;FOO&apos;, &apos;bar&apos;, &apos;baz&apos;]
```       
</code></pre><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><pre><code>定义：取出给定路径上的值。
```   
R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2
```       
</code></pre><h5 id="pathOr"><a href="#pathOr" class="headerlink" title="pathOr"></a>pathOr</h5><pre><code>定义：如果非空对象在给定路径上存在值，则将该值返回；否则返回给定的默认值。
```   
R.pathOr(&apos;N/A&apos;, [&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2
```       
</code></pre><h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。
```   
R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4}
```       
</code></pre><h5 id="pickAll"><a href="#pickAll" class="headerlink" title="pickAll"></a>pickAll</h5><pre><code>定义：与 pick 类似，但 pickAll 会将不存在的属性以 key: undefined 键值对的形式返回。
```   
R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;e&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4, e: undefined}
```       
</code></pre><h5 id="pickBy"><a href="#pickBy" class="headerlink" title="pickBy"></a>pickBy</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含 key 满足 predicate 的属性。
```   
var isUpperCase = (val, key) =&gt; key.toUpperCase() === key;
R.pickBy(isUpperCase, {a: 1,b: 2, A: 3, B: 4}); // {A: 3, B: 4}
```       
</code></pre><h5 id="project"><a href="#project" class="headerlink" title="project"></a>project</h5><pre><code>定义：模拟 SQL 中的 select 语句。
```   
var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2};
var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7};
var kids = [abby, fred];
R.project([&apos;name&apos;, &apos;grade&apos;], kids); // [{name: &apos;Abby&apos;, grade: 2}, {name: &apos;Fred&apos;, grade: 7}]
```   
</code></pre><h5 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h5><pre><code>定义：取出对象中指定属性的值。如果不存在，则返回 undefined。
```   
R.prop(&apos;x&apos;, {x: 100}); // 100
```   
</code></pre><h5 id="propOr"><a href="#propOr" class="headerlink" title="propOr"></a>propOr</h5><pre><code>定义：对于给定的非空对象，如果指定属性存在，则返回该属性值；否则返回给定的默认值。
```   
var alice = {
  name: &apos;ALICE&apos;,
  age: 101
};
var favorite = R.prop(&apos;favoriteLibrary&apos;);
var favoriteWithDefault = R.propOr(&apos;Ramda&apos;, &apos;favoriteLibrary&apos;);

favorite(alice);  // undefined
favoriteWithDefault(alice);  // &apos;Ramda&apos;
```   
</code></pre><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><pre><code>定义：返回 prop 的数组：输入为 keys 数组，输出为对应的 values 数组。values 数组的顺序与 keys 的相同。
```   
R.props([&apos;x&apos;, &apos;y&apos;], {x: 1, y: 2}); // [1, 2]
```   
</code></pre><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><pre><code>定义：通过 lens 对数据结构聚焦的部分进行设置。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2}
```   
</code></pre><h5 id="toPairs"><a href="#toPairs" class="headerlink" title="toPairs"></a>toPairs</h5><pre><code>定义：将一个对象的属性转换成键、值二元组类型的数组，只处理对象自身的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.toPairs({a: 1, b: 2, c: 3}); // [[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]
```       
</code></pre><h5 id="toPairsIn"><a href="#toPairsIn" class="headerlink" title="toPairsIn"></a>toPairsIn</h5><pre><code>定义：将一个对象的属性转换成键、值二元组类型的数组，包括原型链上的属性。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function () { this.x = &apos;X&apos;; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.toPairsIn(f); // [[&apos;x&apos;,&apos;X&apos;], [&apos;y&apos;,&apos;Y&apos;]]
```       
</code></pre><h5 id="values"><a href="#values" class="headerlink" title="values"></a>values</h5><pre><code>定义：返回对象所有自身可枚举的属性的值。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.values({a: 1, b: 2, c: 3}); //=&gt; [1, 2, 3]
```       
</code></pre><h5 id="valuesIn"><a href="#valuesIn" class="headerlink" title="valuesIn"></a>valuesIn</h5><pre><code>定义：返回对象所有属性的值，包括原型链上的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function() { this.x = &apos;X&apos;; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.valuesIn(f); //=&gt; [&apos;X&apos;, &apos;Y&apos;]
```       
</code></pre><h5 id="view"><a href="#view" class="headerlink" title="view"></a>view</h5><pre><code>定义：返回数据结构中，lens 聚焦的部分。lens 的焦点决定了数据结构中的哪部分是可见的。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.view(xLens, {x: 1, y: 2});  //=&gt; 1
```       
</code></pre><h5 id="where"><a href="#where" class="headerlink" title="where"></a>where</h5><pre><code>定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。测试规范对象的每个属性值都必须是 predicate 。
每个 predicate 作用于待检测对象对应的属性值，如果所有 predicate 都返回 true，则 where 返回 true，否则返回 false 。
where 非常适合于需要声明式表示约束的函数，比如 filter 和 find 。
```   
var pred = R.where({
  a: R.equals(&apos;foo&apos;),
  b: R.complement(R.equals(&apos;bar&apos;)),
  x: R.gt(R.__, 10),
  y: R.lt(R.__, 20)
});

pred({a: &apos;foo&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; true
pred({a: &apos;xxx&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; false
```       
</code></pre><h5 id="whereEq"><a href="#whereEq" class="headerlink" title="whereEq"></a>whereEq</h5><pre><code>定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。
如果对于每一个测试规范对象的属性值，待检测对象中都有一个对应的相同属性值，则 where 返回 true，否则返回 false 。
whereEq 是 where 的一种特殊形式。
```   
var pred = R.whereEq({a: 1, b: 2});
pred({a: 1});              //=&gt; false
pred({a: 1, b: 2});        //=&gt; true
```       
</code></pre><h4 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h4><h5 id="allPass"><a href="#allPass" class="headerlink" title="allPass"></a>allPass</h5><pre><code>定义：传入包含多个 predicate 的列表，返回一个 predicate：如果给定的参数满足列表中的所有 predicate ，则返回 true。
该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。
```   
var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;);
var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;);
var isQueenOfSpades = R.allPass([isQueen, isSpade]);
isQueenOfSpades({rank: &apos;Q&apos;, suit: &apos;??&apos;}); // true
```   
</code></pre><h5 id="anyPass"><a href="#anyPass" class="headerlink" title="anyPass"></a>anyPass</h5><pre><code>定义：传入包含多个 predicate 的列表，返回一个 predicate：只要给定的参数满足列表中的一个 predicate ，就返回 true。
该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。
```   
var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;);
var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;);
var isQueenOfSpades = R.anyPass([isQueen, isSpade]);
isQueenOfSpades({rank: &apos;K&apos;, suit: &apos;??&apos;}); // true
```   
</code></pre><h5 id="and（针对于值）"><a href="#and（针对于值）" class="headerlink" title="and（针对于值）"></a>and（针对于值）</h5><pre><code>定义：如果两个参数都是 true，则返回 true；否则返回 false。相当于且（&amp;&amp;）
```   
R.and(true, true); // true
```           
</code></pre><h5 id="or（针对于值）"><a href="#or（针对于值）" class="headerlink" title="or（针对于值）"></a>or（针对于值）</h5><pre><code>定义：逻辑或运算，只要有一个参数为 truth-y，就返回 true；否则返回 false。
```   
R.or(true, true); // true
```   
</code></pre><h5 id="not（针对于值）"><a href="#not（针对于值）" class="headerlink" title="not（针对于值）"></a>not（针对于值）</h5><pre><code>定义：逻辑非运算。 当传入参数为 false-y 值时，返回 true；truth-y 值时，返回 false。
```   
R.not(true); // false
```   
</code></pre><h5 id="both（针对于函数）"><a href="#both（针对于函数）" class="headerlink" title="both（针对于函数）"></a>both（针对于函数）</h5><pre><code>定义：该函数调用两个函数，并对两函数返回值进行与操作。若第一个函数结果为 false-y 值 (false, null, 0 等)，则返回该结果，否则返回第二个函数的结果。注意，both 为短路操作，即如果第一个函数返回 false-y 值，则不会调用第二个函数。
```   
var gt10 = R.gt(R.__, 10);
var lt20 = R.lt(R.__, 20);
var f = R.both(gt10, lt20);
f(15); // true
```           
</code></pre><h5 id="either（针对于函数）"><a href="#either（针对于函数）" class="headerlink" title="either（针对于函数）"></a>either（针对于函数）</h5><pre><code>定义：返回由 || 运算符连接的两个函数的包装函数。如果两个函数中任一函数的执行结果为 truth-y，则返回其执行结果。 注意，这个是短路表达式，意味着如果第一个函数返回 truth-y 值的话，第二个函数将不会执行。
```   
var gt10 = x =&gt; x &gt; 10;
var even = x =&gt; x % 2 === 0;
var f = R.either(gt10, even);
f(101); // true
```   
</code></pre><h5 id="complement（针对于函数）"><a href="#complement（针对于函数）" class="headerlink" title="complement（针对于函数）"></a>complement（针对于函数）</h5><pre><code>定义：对函数的返回值取反。接受一个函数 f，返回一个新函数 g：在输入参数相同的情况下，若 f 返回 &apos;true-y&apos; ，则 g 返回 false-y ，反之亦然。
```   
var isNotNil = R.complement(R.isNil);
isNotNil(null); // true
```       
</code></pre><h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><pre><code>定义：返回一个封装了 if / else，if / else if/ else逻辑的函数 fn。 R.cond 接受列表元素为 [predicate，transformer] 的列表。 
fn 的所有参数顺次作用于每个 predicate，直到有一个返回 &quot;truthy&quot; 值，此时相应 transformer 对参数处理，并作为 fn 的结果返回。
如果没有 predicate 匹配，则 fn 返回 undefined。
```   
var fn = R.cond([
    [R.equals(0), R.always(&apos;water freezes at 0&apos;)],
    [R.equals(100), R.always(&apos;water freezes at 100&apos;)],
    [R.T, temp =&gt; `nothing special happens at ${temp}`],
]);
fn(3); // nothing special happens at 3
```       
</code></pre><h5 id="defaultTo"><a href="#defaultTo" class="headerlink" title="defaultTo"></a>defaultTo</h5><pre><code>定义：如果第二个参数不是 null、undefined 或 NaN，则返回第二个参数，否则返回第一个参数（默认值）。
```   
var defaultTo42 = R.defaultTo(42);
defaultTo42(undefined); // 42 
defaultTo42(13); // 13 
```       
</code></pre><h5 id="ifElse"><a href="#ifElse" class="headerlink" title="ifElse"></a>ifElse</h5><pre><code>定义：根据 condition predicate 的返回值调用 onTrue 或 onFalse 函数。
```   
var inCount = R.ifElse(
    R.has(&apos;count&apos;),
    R.over(R.lensProp(&apos;count&apos;), R.inc),
    R.assoc(&apos;count&apos;, 1)
);
incCount({});           //=&gt; { count: 1 }
incCount({ count: 1 }); //=&gt; { count: 2 }
```       
</code></pre><h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h5><pre><code>定义：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。
```   
R.isEmpty([1, 2, 3]); // false
R.isEmpty(&apos;&apos;); // true
```   
</code></pre><h5 id="pathSatisfies"><a href="#pathSatisfies" class="headerlink" title="pathSatisfies"></a>pathSatisfies</h5><pre><code>定义：如果对象的给定路径上的属性满足 predicate，返回 ture；否则返回 false。
```   
R.pathSatisfies(y =&gt; y &gt; 0, [&apos;x&apos;, &apos;y&apos;], {x: {y: 2}}); // true
```   
</code></pre><h5 id="propSatisfies"><a href="#propSatisfies" class="headerlink" title="propSatisfies"></a>propSatisfies</h5><pre><code>定义：如果指定的对象属性满足 predicate，返回 true；否则返回 false。
```   
R.propSatisfies(x =&gt; x &gt; 0, &apos;x&apos;, {x: 1, y: 2}); // true
```   
</code></pre><h5 id="unless"><a href="#unless" class="headerlink" title="unless"></a>unless</h5><pre><code>定义：判断输入值是否满足 predicate，若不符合，则将输入值传给 whenFalseFn 处理，并将处理结果作为返回；若符合，则将输入值原样返回。
```   
let safeInc = R.unless(R.isNil, R.inc);
safeInc(null); //=&gt; null
safeInc(1); //=&gt; 2
```   
</code></pre><h5 id="until"><a href="#until" class="headerlink" title="until"></a>until</h5><pre><code>定义：接受一个 predicate ，transform function 和 初始值，返回一个与初始值相同类型的值。
对输入值进行 transform ，直到 transform 的结果满足 predicate，此时返回这个满足 predicate 的值。
```   
R.until(R.gt(R.__, 100), R.multiply(2))(1); // 128
```   
</code></pre><h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><pre><code>定义：判断输入值是否满足 predicate，若符合，则将输入值传给 whenTrueFn 处理，并将处理结果作为返回；若不符合，则将输入值原样返回。
```   
var truncate = R.when(
  R.propSatisfies(R.gt(R.__, 10), &apos;length&apos;),
  R.pipe(R.take(10), R.append(&apos;…&apos;), R.join(&apos;&apos;))
);
truncate(&apos;12345&apos;);         // &apos;12345&apos;
truncate(&apos;0123456789ABC&apos;); // &apos;0123456789…&apos;
```   
</code></pre><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><h5 id=""><a href="#" class="headerlink" title="__"></a>__</h5><pre><code>定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。
```   
假设 g 代表柯里化的三元函数
g(1, 2, 3)
g(R.__, 2, 3)(1)
g(R.__, R__, 3)(1)(2)
g(R.__, 2, R.__)(1)(3)
g(R.__, 2)(R.__, 3)(1)
// 这些函数都是等价的。
var greet = R.replace(&apos;{name}&apos;, R.__, &apos;Hello, {name}!&apos;);
greet(&apos;Fanerge&apos;); // Hello, Fanerge
```       
</code></pre><h5 id="addIndex"><a href="#addIndex" class="headerlink" title="addIndex"></a>addIndex</h5><pre><code>定义：通过向列表迭代函数的回调函数添加两个新的参数：当前索引、整个列表，创建新的列表迭代函数。
```   
var mapIndexed = R.addIndex(R.map);
mapIndexed((val, idx) =&gt; {idx + &apos;-&apos; + val}, [&apos;f&apos;, &apos;a&apos;, &apos;n&apos;]); // [&apos;0-f&apos;, &apos;1-a&apos;, &apos;2-n&apos;]
```   
</code></pre><h5 id="always"><a href="#always" class="headerlink" title="always"></a>always</h5><pre><code>定义：返回一个返回恒定值的函数。注意，对于非原始值，返回的值是对原始值的引用。
```   
var t = R.always(&apos;Tee&apos;);
t(); // Tee
```   
</code></pre><h5 id="ap"><a href="#ap" class="headerlink" title="ap"></a>ap</h5><pre><code>定义：将函数列表作用于值列表上。
```   
R.ap([R.multiply(2), R.add(3)], [1, 2, 3]); // [2, 4, 6, 4, 5, 6]
```   
</code></pre><h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><pre><code>定义：将函数 fn 作用于参数列表 args。apply 可以将变参函数转换为为定参函数。如果上下文很重要，则 fn 应该绑定其上下文。
```   
var nums = [1, 2, 3, -99, 42, 6, 7];
R.apply(Math.max, nums); // 42
```   
</code></pre><h5 id="applySpec"><a href="#applySpec" class="headerlink" title="applySpec"></a>applySpec</h5><pre><code>定义：接受一个属性值为函数的对象，返回一个能生成相同结构对象的函数。返回的函数使用传入的参数调用对象的每个属性位对应的函数，来生成相应属性的值。
```   
var getMetrics = R.applySpec({    
    sum: R.add,
    nested: { mul: R.multiply }
});
getMetrics(2, 4); // {sum: 6, nested: { mul: 8 }}
```   
</code></pre><h5 id="ascend"><a href="#ascend" class="headerlink" title="ascend"></a>ascend</h5><pre><code>定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个升序比较函数。
```   
var byAge = R.ascend(R.prop(&apos;age&apos;));
var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}];
var peopleByYoungestFirst = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}]
```       
</code></pre><h5 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h5><pre><code>定义：将任意元函数封装为二元函数（只接受2个参数）中。任何额外的参数都不会传递给被封装的函数。
```   
var takesThreeArgs = function (a, b, c){
    return [a, b, c];
};
vat takeTwoArgs = R.binary(takesThreeArgs);
// takeTwoArgs.length; // 2
takeTwoArgs(1, 2, 3); // [1, 2, undefined]
```           
</code></pre><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><pre><code>定义：创建一个绑定了上下文的函数。
注意：与 Function.prototype.bind 不同，R.bind 不会绑定额外参数。
```   
var log = R.bind(console.log, console);
log(1); // 1
```   
</code></pre><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><pre><code>定义：提取第一个参数作为函数，其余参数作为刚提取的函数的参数，调用该函数并将结果返回。
```   
R.call(R.add, 1, 2); // 3
```       
</code></pre><h5 id="comparator"><a href="#comparator" class="headerlink" title="comparator"></a>comparator</h5><pre><code>定义：由首个参数是否小于第二个参数的判断函数，生成一个比较函数。
```   
var byAge = R.comparator((a, b) =&gt; a.age &lt; b.age);
var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}];
var peopleByIncreasingAge = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}]
```       
</code></pre><h5 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h5><pre><code>定义：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
```   
R.compose(R.add(1), R.multiply(2))(3); // 7
```           
</code></pre><h5 id="composeK"><a href="#composeK" class="headerlink" title="composeK"></a>composeK</h5><pre><code>定义：接受一系列函数，返回从右向左的 Kleisli 组合，每个函数必须返回支持 chain 操作的值。
```   
R.composeK(h, g, f) 等同于 R.compose(R.chain(h)，R.chain(g)，R.chain(f))。
```       
</code></pre><h5 id="composeP"><a href="#composeP" class="headerlink" title="composeP"></a>composeP</h5><pre><code>定义： 从右向左执行返回 Promise 的函数的组合。最右边的函数可以是任意元函数（参数个数不限）; 其余函数必须是一元函数。
```   
var db = {
      users: {
            JOE: {
              name: &apos;Joe&apos;,
              followers: [&apos;STEVE&apos;, &apos;SUZY&apos;]
            }
      }
};
var lookupUser = (userId) =&gt; Promise.resolve(db.users[userId]);
var lookupFollowers = (user) =&gt; Promise.resolve(user.followers);
lookupUser(&apos;JOE&apos;).then(lookupFollowers);
var followersForUser = R.composeP(lookupFollowers, lookupUser);
followersForUser(&apos;JOE&apos;).then(followers =&gt; console.log(&apos;Followers:&apos;, followers)) // [&quot;STEVE&quot;,&quot;SUZY&quot;]
```   
</code></pre><h5 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h5><pre><code>定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。
```   
// constructor function
function Animal (kind) {
    this.kind = kind;
}
Animal.prototype.sighting = function () {
    return `it&apos;s a ${this.kind}!`;
};
var AnimalConstructor = R.construct(Animal);
console.log(AnimalConstructor(&apos;PIG&apos;)); // {&quot;kind&quot;:&quot;PIG&quot;}
```   
</code></pre><h5 id="constructN"><a href="#constructN" class="headerlink" title="constructN"></a>constructN</h5><pre><code>定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。为了能够使用变参的构造函数，返回函数的元数需要明确指定。
```   
function Salad() {
  this.ingredients = arguments;
};
Salad.prototype.recipe = function() {
  var instructions = R.map((ingredient) =&gt; (
    &apos;Add a whollop of &apos; + ingredient, this.ingredients)
  )
  return R.join(&apos;\n&apos;, instructions)
}

var ThreeLayerSalad = R.constructN(3, Salad)

// Notice we no longer need the &apos;new&apos; keyword, and the constructor is curried for 3 arguments.
var salad = ThreeLayerSalad(&apos;Mayonnaise&apos;)(&apos;Potato Chips&apos;)(&apos;Ketchup&apos;)
console.log(salad.recipe());
// Add a whollop of Mayonnaise
// Add a whollop of Potato Chips
// Add a whollop of Potato Ketchup
```   
</code></pre><h5 id="converge"><a href="#converge" class="headerlink" title="converge"></a>converge</h5><pre><code>定义：接受一个 converging 函数和一个分支函数列表，返回一个新函数。
当被调用时，新函数接受参数，并将这些参数转发给每个分支函数；然后将每个分支函数的计算结果作为参数传递给 converging 函数，converging 函数的计算结果即新函数的返回值。
```   
var average = R.converge(R.divide, [R.sum, R.length]);
average([1, 2, 3, 4, 5, 6, 7]); // 4
```   
</code></pre><h5 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h5><pre><code>定义：对函数进行柯里化。柯里化函数与其他语言中的柯里化函数相比，有两个非常好的特性：
1.参数不需要一次只传入一个。 
    g(1)(2)(3) === g(1, 2, 3)
2.占位符值 R.__ 可用于标记暂未传入参数的位置。允许部分应用于任何参数组合，而无需关心它们的位置和顺序。
    F(1, 2, 3) === F(R.__, 2, 3)(1) === F(R.__, 3)(1)(2)
```   
var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d;
var curriedAddFourNumbers = R.curry(addFourNumbers);
var f = curriedAddFourNumbers(1); // 返回剩余三个参数的函数
f(2, 3, 4); // 10(当参数全部传入，才返回结果)
```   
</code></pre><h5 id="curryN"><a href="#curryN" class="headerlink" title="curryN"></a>curryN</h5><pre><code>定义：对函数进行柯里化，并限制柯里化函数的元数。
```   
var sumArgs = (...args) =&gt; R.sum(args);
var curriedFourNumbers = R.curryN(5, sumArgs);
var f = curriedAddFourNumbers(1, 2);
var g = f(3, 4, 5); // 15
```       
</code></pre><h5 id="descend"><a href="#descend" class="headerlink" title="descend"></a>descend</h5><pre><code>定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个降序比较函数。
```   
var byAge = R.descend(R.prop(&apos;age&apos;));
var people = [

];
var peopleByOldFirst = R.sort(byAge, people);
```       
</code></pre><h5 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h5><pre><code>定义：根据传入参数的类型返回其对应的空值。
Ramda 定义了各类型的空值如下：Array ([])，Object ({})，String (&apos;&apos;)，和 Arguments。empty 还支持其它定义了 &lt;Type&gt;.empty 和/或 &lt;Type&gt;.prototype.empty 的类型。
```   
R.empty(Just(42)); // Noting()
R.empty([1, 2]); // []
```       
</code></pre><h5 id="F"><a href="#F" class="headerlink" title="F"></a>F</h5><pre><code>定义：恒定返回 false 的函数。忽略所有的输入参数。
```   
R.F(); // false
```       
</code></pre><h5 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h5><pre><code>定义：交换函数前两个参数的位置。
```   
var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);
mergeThree(1, 2, 3); // [1, 2, 3]
R.flip(mergeThree)(1, 2, 3); // [2, 1, 3]
```       
</code></pre><h5 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h5><pre><code>定义：将输入值原样返回。适合用作默认或占位函数。
```   
R.identity(1); // 1
var obj = {};
R.identity(obj) === obj; // true
```       
</code></pre><h5 id="invoker"><a href="#invoker" class="headerlink" title="invoker"></a>invoker</h5><pre><code>定义：将具有指定元数（参数个数）的具名方法，转换为可以被给定参数和目标对象直接调用的函数。
返回的函数是柯里化的，它接收 arity + 1 个参数，其中最后一个参数是目标对象。
```   
var sliceFrom = R.invoker(1, &apos;slice&apos;);
sliceFrom(6, &apos;abcdefghijklm&apos;); //=&gt; &apos;ghijklm&apos;
```       
</code></pre><h5 id="juxt"><a href="#juxt" class="headerlink" title="juxt"></a>juxt</h5><pre><code>定义：juxt 将函数列表作用于值列表。
```   
var getRange = R.juxt([Math.min, Math.max]);
getRange(3, 4, 9, -3); // [-3, 9]
```       
</code></pre><h5 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h5><pre><code>定义：提升一个多元函数，使之能映射到列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。
```   
var madd3 = R.lift((a, b, c) =&gt; a + b + c);
madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]
```       
</code></pre><h5 id="liftN"><a href="#liftN" class="headerlink" title="liftN"></a>liftN</h5><pre><code>定义：将一个函数提升为指定元数的函数，使之能映射到多个列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。
```   
var madd3 = R.liftN(3, (...args) =&gt; R.sum(args));
madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]
```       
</code></pre><h5 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a>memoize</h5><pre><code>定义：memoize 方法可以缓存函数的计算结果。
创建一个新函数，被调用时，缓存特定参数对应的经 fn 计算的结果，并将结果返回。
此后如果用相同的参数调用缓存的 fn 时，直接返回该参数对应的缓存结果，不必再调用 fn。
```   
var count = 0;
const factorial = R.memoize(n =&gt; {
    count += 1;
    return R.product(R.range(1, n + 1));
});
factorial(5); // 120
factorial(5); // 120
count; // 1(只进行了一次运算)
```       
</code></pre><h5 id="memoizeWith"><a href="#memoizeWith" class="headerlink" title="memoizeWith"></a>memoizeWith</h5><pre><code>定义：R.memoize 的可定制版本。memoizeWith 需要一个额外的函数，该函数接受一个参数集，用于创建缓存的键值，在该缓存中会存储被缓存函数的结果。
注意，生成缓存键值时，要避免可能会错误地覆盖之前已缓存键值对的冲突。
```   
var count = 0;
const factorial = R.memoizeWith(R.identity, n =&gt; {
    count += 1;
    return R.product(R.range(1, n + 1));
});
factorial(5); // 120
factorial(5); // 120
count; // 1(只进行了一次运算)
```           
</code></pre><h5 id="nAry"><a href="#nAry" class="headerlink" title="nAry"></a>nAry</h5><pre><code>定义：将一个任意元（包括零元）的函数，封装成一个确定元数（参数个数）的函数。任何多余的参数都不会传入被封装的函数。
```   
var takesTwoArgs = (a, b) =&gt; [a, b];
takesTwoArgs.length; // 2
takesTwoArgs(1, 2); // [1, 2]
var takesOneArg = R.nAry(1, takeTwoArgs);
takesOneArg.length; // 1
takesOneArg(1, 2); // [1, undefined]
```       
</code></pre><h5 id="nthArg"><a href="#nthArg" class="headerlink" title="nthArg"></a>nthArg</h5><pre><code>定义：返回一个函数，该函数返回它的第 n 个参数。
```   
R.nthArg(1)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;); // b
```       
</code></pre><h5 id="o"><a href="#o" class="headerlink" title="o"></a>o</h5><pre><code>定义：o 是一个柯里化组合函数，返回一元函数。
类似于 compose，o 从右到左执行函数组合。但与 compose 不同的是，传递给 o 的最右边的函数为一元函数。
```   
R.o(R.multiply(10), R.add(10))(-4); // 60
```       
</code></pre><h5 id="of"><a href="#of" class="headerlink" title="of"></a>of</h5><pre><code>定义：将给定值作为元素，封装成单元素数组。
```   
R.of(42); // [42]
```       
</code></pre><h5 id="once"><a href="#once" class="headerlink" title="once"></a>once</h5><pre><code>定义：创建一个只能调用一次的函数。
将给定函数 fn 封装到新函数fn&apos;中，fn&apos; 确保 fn 只能调用一次。重复调用fn&apos; ，只会返回第一次执行时的结果。
```   
var addOneOnce = R.once(x =&gt; x + 1);
addOneOnce(10); // 11
addOneOnce(51); // 11
```       
</code></pre><h5 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h5><pre><code>定义：部分应用。
接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将初始参数和 g 的参数顺次传给 f，并返回 f 的执行结果。
```   
var multiply2 = (a, b) =&gt; a * b;
var double = R.partial(multiply2, [2]);
double(3); // 2*3=6
```       
</code></pre><h5 id="partialRight"><a href="#partialRight" class="headerlink" title="partialRight"></a>partialRight</h5><pre><code>定义：部分应用。
接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将 g 的参数和初始参数顺序传给 f，并返回 f 的执行结果。
```   
var multiply2 = (a, b) =&gt; a * b;
var double = R.partial(multiply2, [2]);
double(3); // 3*2=6
```       
</code></pre><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><pre><code>定义：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
```   
var f = R.pipe(Math.pow, R.negate, R.inc);
f(3, 4); // -(3^4) + 1
```       
</code></pre><h5 id="pipeK"><a href="#pipeK" class="headerlink" title="pipeK"></a>pipeK</h5><pre><code>定义：将一系列函数，转换成从左到右的 Kleisli 组合，每个函数必须返回支持chain操作的值。
R.pipeK(f, g, h) 等价于 R.pipe(R.chain(f), R.chain(g), R.chain(h))。
```   
var getStateCode = R.pipeK(
  parseJson,
  get(&apos;user&apos;),
  get(&apos;address&apos;),
  get(&apos;state&apos;),
  R.compose(Maybe.of, R.toUpper)
);
getStateCode(&apos;{&quot;user&quot;:{&quot;address&quot;:{&quot;state&quot;:&quot;ny&quot;}}}&apos;);
// Just(&apos;NY&apos;)
```       
</code></pre><h5 id="pipeP"><a href="#pipeP" class="headerlink" title="pipeP"></a>pipeP</h5><pre><code>定义：从左往右执行返回 Promise 的函数的组合。最左边的函数可以是任意元函数（参数个数不限）；其余函数必须是一元函数。
```   
var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
```       
</code></pre><h5 id="T"><a href="#T" class="headerlink" title="T"></a>T</h5><pre><code>定义：恒定返回 true 的函数。忽略所有的输入参数。
```   
R.T(); // true
```       
</code></pre><h5 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h5><pre><code>定义：对输入的值执行给定的函数，然后返回输入的值。
```   
var sayX = x =&gt; console.log(&apos;x is &apos; + x);
R.tap(sayX, 100); // 100
```       
</code></pre><h5 id="tryCatch"><a href="#tryCatch" class="headerlink" title="tryCatch"></a>tryCatch</h5><pre><code>定义：tryCatch 接受两个函数：tryer 和 catcher，生成的函数执行 tryer，若未抛出异常，则返回执行结果。
若抛出异常，则执行 catcher，返回 catcher 的执行结果。注意，为了有效的组合该函数，tryer 和 catcher 应返回相同类型的值。
```   
R.tryCatch(R.prop(&apos;x&apos;), R.f)({x: true}); // true
```       
</code></pre><h5 id="unapply"><a href="#unapply" class="headerlink" title="unapply"></a>unapply</h5><pre><code>定义：输入一个只接收单个数组作为参数的函数，返回一个新函数：
接收任意个参数；
将参数组成数组传递给 fn ；
返回执行结果。
换言之，R.unapply 将一个使用数组作为参数的函数，变为一个不定参函数。 R.unapply 是 R.apply 的逆函数
```   
R.unapply(JSON.stringify, 1, 2, 3); // &apos;[1, 2, 3]&apos;
```   
</code></pre><h5 id="unary"><a href="#unary" class="headerlink" title="unary"></a>unary</h5><pre><code>定义：将任意元（包括零元）函数封装成一元函数。任何额外的参数都不会传递给被封装的函数。
```   
var takesTwoArgs = function(a, b) {
  return [a, b];
};
takesTwoArgs.length; //=&gt; 2
takesTwoArgs(1, 2); //=&gt; [1, 2]

var takesOneArg = R.unary(takesTwoArgs);
takesOneArg.length; //=&gt; 1
// 只有一个参数能被传递到函数当中
takesOneArg(1, 2); //=&gt; [1, undefined]
```   
</code></pre><h5 id="uncurryN"><a href="#uncurryN" class="headerlink" title="uncurryN"></a>uncurryN</h5><pre><code>定义：将一个柯里化的函数转换为一个 n 元函数。
```   
var addFour = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d;
var uncurriedAddFour = R.uncurryN(4, addFour);
uncurriedAddFour(1, 2, 3, 4); // 10
```   
</code></pre><h5 id="useWith"><a href="#useWith" class="headerlink" title="useWith"></a>useWith</h5><pre><code>定义：接受一个函数 fn 和一个 transformer 函数的列表，返回一个柯里化的新函数。
当被调用时，新函数将每个参数转发给对应位置的 transformer 函数，然后将每个 transformer 函数的计算结果作为参数传递给 fn，fn 的计算结果即新函数的返回值。
如果新函数传传入参数的数量比 transformer 函数的数量多，多出的参数会作为附加参数直接传给 fn 。
如果不需要处理多出的那部分参数，除了忽略之外，也可以用 identity 函数来作为 transformer ，以保证新函数的参数数量是确定的。
```   
R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=&gt; 81
```   
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><pre><code>定义：两数相加。
```   
R.add(2)(3); // 5
```   
</code></pre><h5 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h5><pre><code>定义：两数相除。等价于a / b。
```   
R.divide(71, 100); // 0.71
```   
</code></pre><h5 id="dec（相当于自减）"><a href="#dec（相当于自减）" class="headerlink" title="dec（相当于自减）"></a>dec（相当于自减）</h5><pre><code>定义：减一。与i--的区别为会生产一个新数据（不改变原有值）。
```   
R.dec(42); // 41
```   
</code></pre><h5 id="inc（相当于自加）"><a href="#inc（相当于自加）" class="headerlink" title="inc（相当于自加）"></a>inc（相当于自加）</h5><pre><code>定义：加1。
```   
R.inc(42); // 43
```       
</code></pre><h5 id="mathMod"><a href="#mathMod" class="headerlink" title="mathMod"></a>mathMod</h5><pre><code>定义：mathMod 和算术取模操作类似，而不像 % 操作符 （或 R.modulo）。所以 -17 % 5 等于 -2，而 mathMod(-17, 5) 等于 3 。
mathMod 要求参数为整型，并且当模数等于 0 或者负数时返回 NaN 。
```   
R.mathMod(-17, 5); // 3
R.mathMod(17, 5); // 2
```       
</code></pre><h5 id="mean"><a href="#mean" class="headerlink" title="mean"></a>mean</h5><pre><code>定义：返回给定数字列表的平均值。
```   
R.mean([2, 7, 9]); // 6
```       
</code></pre><h5 id="median"><a href="#median" class="headerlink" title="median"></a>median</h5><pre><code>定义：返回给定数字列表的中位数。
```   
R.median([2, 9, 7]); // 7
```       
</code></pre><h5 id="modulo"><a href="#modulo" class="headerlink" title="modulo"></a>modulo</h5><pre><code>定义：用第一个参数除以第二个参数，并返回余数。注意，该函数是 JavaScript-style 的求模操作。数学求模另见 mathMod。
```   
R.modulo(17, 3); // 2
R.modulo(-17, 3); // -2
```       
</code></pre><h5 id="multiply"><a href="#multiply" class="headerlink" title="multiply"></a>multiply</h5><pre><code>定义：两数相乘，等价于柯里化的 a * b 。
```   
R.multiply(2, 3); // 6
```   
</code></pre><h5 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h5><pre><code>定义：取反操作。
```   
R.negate(42); // -42
```   
</code></pre><h5 id="product"><a href="#product" class="headerlink" title="product"></a>product</h5><pre><code>定义：列表中的所有元素相乘。
```   
R.product([2, 3, 4]); // 24
```   
</code></pre><h5 id="subtract"><a href="#subtract" class="headerlink" title="subtract"></a>subtract</h5><pre><code>定义：首个参数减去第二个参数。
```   
R.subtract(1, 2); // -1
```   
</code></pre><h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><pre><code>定义：对数组中所有元素求和。
```   
R.sum([1, 2, 3]); // 6
```   
</code></pre><h4 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h4><h5 id="clamp"><a href="#clamp" class="headerlink" title="clamp"></a>clamp</h5><pre><code>定义：将数字限制在指定的范围内。
clamp 也可用于其他有序类型，如字符串和日期。
```   
R.clamp(1, 10, -5); // 1
R.clamp(1, 10, 4); // 4
```   
</code></pre><h5 id="countBy"><a href="#countBy" class="headerlink" title="countBy"></a>countBy</h5><pre><code>定义：根据给定函数提供的统计规则对列表中的元素进行分类计数。
返回一个对象，其键值对为：fn 根据列表元素生成键，列表中通过 fn 映射为对应键的元素的个数作为值。
注意，由于 JavaScript 对象的实现方式，所有键都被强制转换为字符串。
```   
var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
R.countBy(Math.floor, numbers); // {&apos;1&apos;: 3, &apos;2&apos;: 2, &apos;3&apos;: 1 }
```   
</code></pre><h5 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h5><pre><code>定义：求差集。求第一个列表中，未包含在第二个列表中的任一元素的集合。对象和数组比较数值相等，而非引用相等。
```   
R.difference([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [1, 2]
```   
</code></pre><h5 id="differenceWith"><a href="#differenceWith" class="headerlink" title="differenceWith"></a>differenceWith</h5><pre><code>定义：求第一个列表中未包含在第二个列表中的所有元素的集合（集合中没有重复元素）。
两列表中的元素通过 predicate 判断相应元素是否同时 “包含在” 两列表中。
```   
var cmp = (x, y) =&gt; x.a === y.a;
var l1 = [{a: 1}, {a: 2}, {a: 3}];
var l2 = [{a: 3}, {a: 4}];
R.differenceWith(cmp, l1, l2); // [{a: 1}, {a: 2}]
```   
</code></pre><h5 id="eqBy"><a href="#eqBy" class="headerlink" title="eqBy"></a>eqBy</h5><pre><code>定义：接受一个函数和两个值，通过传入函数对两个值进行相等性判断。如果两个值的计算结果相等，则返回 true ；否则返回 false 。
```   
R.eqBy(Math.abs, 5, -5); // true
```   
</code></pre><h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><pre><code>定义：如果传入的参数相等，返回 true；否则返回 false。可以处理几乎所有 JavaScript 支持的数据结构。
```   
R.equals(1, 1); // true
R.equals([&apos;1&apos;], [&apos;1&apos;]); // true
```   
</code></pre><h5 id="gt"><a href="#gt" class="headerlink" title="gt"></a>gt</h5><pre><code>定义：如果首个参数大于第二个参数，返回 true；否则返回 false。
```   
R.gt(2, 1); // true
```   
</code></pre><h5 id="gte"><a href="#gte" class="headerlink" title="gte"></a>gte</h5><pre><code>定义：如果首个参数大于等于第二个参数，返回 true；否则返回 false。
```   
R.gte(2, 1); // true
```   
</code></pre><h5 id="identical"><a href="#identical" class="headerlink" title="identical"></a>identical</h5><pre><code>定义：如果两个参数是完全相同，则返回 true，否则返回 false。
如果它们引用相同的内存，也认为是完全相同的。NaN 和 NaN 是完全相同的；0 和 -0 不是完全相同的。
```   
var o = {};
R.identical(o, o); //=&gt; true
R.identical(1, 1); //=&gt; true
```   
</code></pre><h5 id="innerJoin"><a href="#innerJoin" class="headerlink" title="innerJoin"></a>innerJoin</h5><pre><code>定义：接受一个 predicate pred 、列表 xs 和 ys ，返回列表 xs&apos;。
依次取出 xs 中的元素，若通过 pred 判断等于 ys 中的一个或多个元素，则放入 xs&apos; 。
pred 必须为二元函数，两个参数分别来自于对应两个列表中的元素。
```   
R.innerJoin(
  (record, id) =&gt; record.id === id,
  [{id: 824, name: &apos;Richie Furay&apos;},
   {id: 956, name: &apos;Dewey Martin&apos;},
   {id: 313, name: &apos;Bruce Palmer&apos;},
   {id: 456, name: &apos;Stephen Stills&apos;},
   {id: 177, name: &apos;Neil Young&apos;}],
  [177, 456, 999]
);
// [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}]
```   
</code></pre><h5 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h5><pre><code>定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。
```   
R.intersection([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [4, 3]
```   
</code></pre><h5 id="intersectionWith"><a href="#intersectionWith" class="headerlink" title="intersectionWith"></a>intersectionWith</h5><pre><code>定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。由给定的 predicate 进行相同性判断。
```   
var buffaloSpringfield = [
  {id: 824, name: &apos;Richie Furay&apos;},
  {id: 956, name: &apos;Dewey Martin&apos;},
  {id: 313, name: &apos;Bruce Palmer&apos;},
  {id: 456, name: &apos;Stephen Stills&apos;},
  {id: 177, name: &apos;Neil Young&apos;}
];
var csny = [
  {id: 204, name: &apos;David Crosby&apos;},
  {id: 456, name: &apos;Stephen Stills&apos;},
  {id: 539, name: &apos;Graham Nash&apos;},
  {id: 177, name: &apos;Neil Young&apos;}
];

var list = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield, csny);
//=&gt; [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}]
```   
</code></pre><h5 id="lt"><a href="#lt" class="headerlink" title="lt"></a>lt</h5><pre><code>定义：如果首个参数小于第二个参数，返回 true；否则返回 false。
```   
R.lt(2, 1); // false
R.lt(&apos;a&apos;, &apos;b&apos;); // true
```   
</code></pre><h5 id="lte"><a href="#lte" class="headerlink" title="lte"></a>lte</h5><pre><code>定义：如果首个参数小于或等于第二个参数，返回 true；否则返回 false。
```   
R.lt(2, 2); // false
R.lt(&apos;a&apos;, &apos;b&apos;); // true
```   
</code></pre><h5 id="max"><a href="#max" class="headerlink" title="max"></a>max</h5><pre><code>定义：返回两个参数中的较大值。
```   
R.max(789, 123); // 789
```   
</code></pre><h5 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h5><pre><code>定义：接收一个函数和两个值，返回使给定函数执行结果较大的值。
```   
var square = n =&gt; n * n;
R.maxBy(square, -3, 2); // -3
R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); // -5
```   
</code></pre><h5 id="min"><a href="#min" class="headerlink" title="min"></a>min</h5><pre><code>定义：返回两个参数中的较小值。
```   
R.min(789, 123); // 123
R.min(&apos;a&apos;, &apos;c&apos;); // a
```   
</code></pre><h5 id="minBy"><a href="#minBy" class="headerlink" title="minBy"></a>minBy</h5><pre><code>定义：接收一个函数和两个值，返回使给定函数执行结果较小的值。
```   
var square = n =&gt; n * n;
R.minBy(square, -3, 2); // 2
```   
</code></pre><h5 id="pathEq"><a href="#pathEq" class="headerlink" title="pathEq"></a>pathEq</h5><pre><code>定义：判断对象的嵌套路径上是否为给定的值，通过 R.equals 函数进行相等性判断。常用于列表过滤。
```   
var user1 = { address: { zipCode: 90210 } };
var user2 = { address: { zipCode: 55555 } };
var user3 = { name: &apos;Bob&apos; };
var users = [ user1, user2, user3 ];
var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 90210);
var list = R.filter(isFamous, users); // [{&quot;address&quot;:{&quot;zipCode&quot;:90210}}]
```   
</code></pre><h5 id="propEq"><a href="#propEq" class="headerlink" title="propEq"></a>propEq</h5><pre><code>定义：如果指定对象属性与给定的值相等，则返回 true ；否则返回 false 。通过 R.equals 函数进行相等性判断。
```   
var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;};
var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;};
var rusty = {name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;};
var alois = {name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;};
var kids = [abby, fred, rusty, alois];
var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;);
R.filter(hasBrownHair, kids); // [fred, rusty]
```   
</code></pre><h5 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h5><pre><code>定义：根据给定的函数对列表进行排序。
```   
var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop(&apos;name&apos;)));
var alice = {
  name: &apos;ALICE&apos;,
  age: 101
};
var bob = {
  name: &apos;Bob&apos;,
  age: -10
};
var clara = {
  name: &apos;clara&apos;,
  age: 314.159
};
var people = [clara, bob, alice];
sortByNameCaseInsensitive(people); //=&gt; [alice, bob, clara]
```   
</code></pre><h5 id="sortWith"><a href="#sortWith" class="headerlink" title="sortWith"></a>sortWith</h5><pre><code>定义：依据比较函数列表对输入列表进行排序。
```   
var alice = {
  name: &apos;alice&apos;,
  age: 40
};
var bob = {
  name: &apos;bob&apos;,
  age: 30
};
var clara = {
  name: &apos;clara&apos;,
  age: 40
};
var people = [clara, bob, alice];
var ageNameSort = R.sortWith([
  R.descend(R.prop(&apos;age&apos;)),
  R.ascend(R.prop(&apos;name&apos;))
]);
ageNameSort(people); //=&gt; [alice, clara, bob]
```   
</code></pre><h5 id="symmetricDifference"><a href="#symmetricDifference" class="headerlink" title="symmetricDifference"></a>symmetricDifference</h5><pre><code>定义：求对称差集。所有不属于两列表交集元素的集合，其元素在且仅在给定列表中的一个里面出现。
```   
R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=&gt; [1,2,7,6,5]
```   
</code></pre><h5 id="symmetricDifferenceWith"><a href="#symmetricDifferenceWith" class="headerlink" title="symmetricDifferenceWith"></a>symmetricDifferenceWith</h5><pre><code>定义：求对称差集。所有不属于两列表交集元素的集合。交集的元素由条件函数的返回值决定。
```   
var eqA = R.eqBy(R.prop(&apos;a&apos;));
var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
R.symmetricDifferenceWith(eqA, l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
```       
</code></pre><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><pre><code>定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。
```   
R.union([1, 2, 3], [2, 3, 4]); //=&gt; [1, 2, 3, 4]
```       
</code></pre><h5 id="unionWith"><a href="#unionWith" class="headerlink" title="unionWith"></a>unionWith</h5><pre><code>定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。由 predicate 的返回值决定两元素是否重复。
```   
var l1 = [{a: 1}, {a: 2}];
var l2 = [{a: 1}, {a: 4}];
R.unionWith(R.eqBy(R.prop(&apos;a&apos;)), l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 4}]
```       
</code></pre><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><h5 id="is"><a href="#is" class="headerlink" title="is"></a>is</h5><pre><code>定义：检测一个对象（val）是否是给定构造函数的实例。该函数会依次检测其原型链，如果存在的话。
```   
R.is(Object, {}); // true
```   
</code></pre><h5 id="isNil"><a href="#isNil" class="headerlink" title="isNil"></a>isNil</h5><pre><code>定义：检测输入值是否为 null 或 undefined 。
```   
R.isNil(null); // true
```   
</code></pre><h5 id="propIs"><a href="#propIs" class="headerlink" title="propIs"></a>propIs</h5><pre><code>定义：判断指定对象的属性是否为给定的数据类型，是则返回 true ；否则返回 false 。
```   
R.propIs(Number, &apos;x&apos;, {x: 1, y: 2}); // true
```   
</code></pre><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><pre><code>定义：用一个单词来描述输入值的（原生）类型，返回诸如 &apos;Object&apos;、&apos;Number&apos;、&apos;Array&apos;、&apos;Null&apos; 之类的结果。不区分用户自定义的类型，统一返回 &apos;Object&apos;。
```   
R.type([]); // Array
```   
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从8月25到8月29共5个晚上和小部分周末时间撸完了Ramda官方文档，继续在事件中继续学习。&lt;br&gt;Rmda中共分为List、Relation、Object、Function、Math、Type、Logic、String共8大类。&lt;/p&gt;
&lt;h4 id=&quot;String&quot;&gt;
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda运用概述</title>
    <link href="https://fanerge.github.io/2017/08/24/ramda%E8%BF%90%E7%94%A8-4/"/>
    <id>https://fanerge.github.io/2017/08/24/ramda运用-4/</id>
    <published>2017-08-24T12:05:16.000Z</published>
    <updated>2017-08-24T13:00:30.150Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<p>它提供了一系列以函数式、声明式和数据不变性方式工作的函数。<br>在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：</p>
<ol>
<li>数据最后：几乎所有的函数都将数据参数作为最后一个参数。</li>
<li>柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</li>
</ol>
<h4 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h4><p>入门：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：map、filter 和 reduce 等。<br>函数组合：演示了可以使用工具（如 both、either、pipe 和 compose）以多种方式组合函数。<br>部分应用(Partial Application)：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 partial 和 curry 可以实现部分应用。我们还学习了 flip 和占位符（__）。<br>声明式编程：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。<br>无参数风格编程(Pointfree Style)：介绍了 pointfree 风格的思想，也被称为 “tatic” 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。<br>数据不变性和对象：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。<br>数据不变性和数组：继续上一节的主题，展示了数据不变性在数组中的应用。<br>透镜(Lenses)：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 view、set 和 over 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。</p>
<blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;p&gt;它提供了一系列以函数式、声明式和数据不变性方式工作的函数。&lt;br&gt;在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据最后：几乎所有的函数都将数据参数作为最后一个参数。&lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda数组的操作和透镜</title>
    <link href="https://fanerge.github.io/2017/08/23/ramda%E8%BF%90%E7%94%A8-3/"/>
    <id>https://fanerge.github.io/2017/08/23/ramda运用-3/</id>
    <published>2017-08-23T12:09:42.000Z</published>
    <updated>2017-08-24T12:42:02.708Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="数据不变性和数组"><a href="#数据不变性和数组" class="headerlink" title="数据不变性和数组"></a>数据不变性和数组</h4><h5 id="读取数组元素"><a href="#读取数组元素" class="headerlink" title="读取数组元素"></a>读取数组元素</h5><pre><code>nth -- 类型于对象prop
slice -- 类似于对象pick
contains -- 类似于对象的has
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const numbers = [10, 20, 30, 40, 50, 60]</div><div class="line">R.nth(3, numbers) // =&gt; 40  (0-based indexing)</div><div class="line">R.nth(-2, numbers) // =&gt; 50 (negative numbers start from the right)</div><div class="line">R.slice(2, 5, numbers) // =&gt; [30, 40, 50] (see below)</div><div class="line">R.contains(20, numbers) // =&gt; true</div></pre></td></tr></table></figure>

nth(0) === head
nth(length-1) === last
tail -- 访问除首个元素之外的所有元素的函数
init -- 除最后一个元素之外的所有元素的方法
take(N) -- 前 N 个元素
takeLast(N) -- 后 N 个元素
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const numbers = [10, 20, 30, 40, 50, 60]</div><div class="line">R.head(numbers) // =&gt; 10</div><div class="line">R.tail(numbers) // =&gt; [20, 30, 40, 50, 60]</div><div class="line">R.last(numbers) // =&gt; 60</div><div class="line">R.init(numbers) // =&gt; [10, 20, 30, 40, 50]</div><div class="line">R.take(3, numbers) // =&gt; [10, 20, 30]</div><div class="line">R.takeLast(3, numbers) // =&gt; [40, 50, 60]</div></pre></td></tr></table></figure>
</code></pre><h5 id="增、删、改数组元素"><a href="#增、删、改数组元素" class="headerlink" title="增、删、改数组元素"></a>增、删、改数组元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">insert：将元素插入到 list 指定索引处。</div><div class="line">R.insert(2, &apos;x&apos;, [1,2,3,4]); //=&gt; [1,2,&apos;x&apos;,3,4]</div><div class="line">update：替换数组中指定索引处的值。</div><div class="line">R.update(1, 11, [0, 1, 2]);     //=&gt; [0, 11, 2]</div><div class="line">append：在列表末尾拼接一个元素。</div><div class="line">R.append(&apos;tests&apos;, [&apos;write&apos;, &apos;more&apos;]); //=&gt; [&apos;write&apos;, &apos;more&apos;, &apos;tests&apos;]</div><div class="line">prepend：在列表头部之前拼接一个元素。</div><div class="line">R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); //=&gt; [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]</div><div class="line">concat：连接列表或字符串。</div><div class="line">R.concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]</div><div class="line">// 反转数组拼接</div><div class="line">const concatAfter = R.flip(R.concat)</div><div class="line">remove：删除列表中从 start 开始的 count 个元素。</div><div class="line">R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=&gt; [1,2,6,7,8]</div><div class="line">without：求第二个列表中，未包含在第一个列表中的任一元素的集合。</div><div class="line">R.without([1, 2], [1, 2, 1, 3, 4]); //=&gt; [3, 4]</div><div class="line">drop：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。</div><div class="line">R.drop(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;bar&apos;, &apos;baz&apos;]</div><div class="line">dropLast：删除 &quot;list&quot; 末尾的 n 个元素。</div><div class="line">R.dropLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;, &apos;bar&apos;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="变换元素"><a href="#变换元素" class="headerlink" title="变换元素"></a>变换元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adjust：将数组中指定索引处的值替换为经函数变换的值。</div><div class="line">R.adjust(R.add(10), 1, [1, 2, 3]);     //=&gt; [1, 12, 3]</div></pre></td></tr></table></figure>
</code></pre><h4 id="透镜（Lenses）"><a href="#透镜（Lenses）" class="headerlink" title="透镜（Lenses）"></a>透镜（Lenses）</h4><h5 id="什么是透镜？"><a href="#什么是透镜？" class="headerlink" title="什么是透镜？"></a>什么是透镜？</h5><pre><code>透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。
可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。
</code></pre><h5 id="如何创建透镜"><a href="#如何创建透镜" class="headerlink" title="如何创建透镜"></a>如何创建透镜</h5><pre><code>lens：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));</div><div class="line">R.view(xLens, &#123;x: 1, y: 2&#125;);            //=&gt; 1</div><div class="line">R.set(xLens, 4, &#123;x: 1, y: 2&#125;);          //=&gt; &#123;x: 4, y: 2&#125;</div><div class="line">// 还有三个便捷函数</div><div class="line">LensProp：创建关注对象某一属性的透镜。</div><div class="line">lensPath: 创建关注对象某一嵌套属性的透镜。</div><div class="line">lensIndex: 创建关注数组某一索引的透镜。</div></pre></td></tr></table></figure>
</code></pre><h5 id="我能用它做什么呢？"><a href="#我能用它做什么呢？" class="headerlink" title="我能用它做什么呢？"></a>我能用它做什么呢？</h5><pre><code>Ramda 提供了三个配合透镜一起使用的的函数：
    view：读取透镜的值。
    set：更新透镜的值。
    over：将变换函数作用于透镜。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));</div><div class="line">R.view(xLens, &#123;x: 1, y: 2&#125;);            //=&gt; 1</div><div class="line">R.set(xLens, 4, &#123;x: 1, y: 2&#125;);          //=&gt; &#123;x: 4, y: 2&#125;</div><div class="line">R.over(xLens, R.negate, &#123;x: 1, y: 2&#125;);  //=&gt; &#123;x: -1, y: 2&#125;</div><div class="line">// 区别:</div><div class="line">// set 和 over 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</div></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：某些较大数据结构的处理 -- 透镜。
数组：读取(nth、slice、contains、head、last、tail、init、take、takeLast)
增、删、改(insert、update、append、prepend、concat、remove、without、drop、dropLast)
变换(adjust)
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;数据不变性和数组&quot;&gt;&lt;a href=&quot;#数据不变性和数组&quot; class=&quot;headerlink&quot; title=&quot;数据不变性和数组&quot;&gt;&lt;/a&gt;数据不变性和数组&lt;/h4&gt;&lt;h5 id=&quot;读取数组元素&quot;&gt;&lt;a href=&quot;#读取数组
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda无参数风格和对象的相关操作</title>
    <link href="https://fanerge.github.io/2017/08/22/ramda%E8%BF%90%E7%94%A8-2/"/>
    <id>https://fanerge.github.io/2017/08/22/ramda运用-2/</id>
    <published>2017-08-22T11:36:23.000Z</published>
    <updated>2017-08-23T12:15:45.084Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="Pointfree-风格（无参数风格）"><a href="#Pointfree-风格（无参数风格）" class="headerlink" title="Pointfree 风格（无参数风格）"></a>Pointfree 风格（无参数风格）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), R.always(21), R.inc)(age);</div><div class="line">// console.log(forever21(23)); // 21</div><div class="line"></div><div class="line">// pointfree风格的</div><div class="line">var forever21 = R.ifElse(R.gte(R.__, 21), R.always(21), R.inc);</div><div class="line">// console.log(forever21(21));</div><div class="line">// 我们刚刚让 age 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 age 参数。</div></pre></td></tr></table></figure>
</code></pre><h4 id="多元函数（多参数函数）"><a href="#多元函数（多参数函数）" class="headerlink" title="多元函数（多参数函数）"></a>多元函数（多参数函数）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var titlesForYear = R.curry((year, books) =&gt; &#123;</div><div class="line">  R.pipe(</div><div class="line">	R.filter(publishedInYear(year)),</div><div class="line">	R.map(book =&gt; book.title)    </div><div class="line">  )(books);</div><div class="line">&#125;);</div><div class="line">// console.log(titlesForYear(2012)(books));</div><div class="line"></div><div class="line">var titlesForYear = year =&gt; &#123;</div><div class="line">  R.pipe(</div><div class="line">	R.filter(publishedInYear(year)),</div><div class="line">	R.map(book =&gt; book.title)</div><div class="line">  )</div><div class="line">&#125;;</div><div class="line">console.log(titlesForYear(2012));</div></pre></td></tr></table></figure>
</code></pre><h4 id="重构为-pointfree-风格的代码"><a href="#重构为-pointfree-风格的代码" class="headerlink" title="重构为 pointfree 风格的代码"></a>重构为 pointfree 风格的代码</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 改写18岁投票系统</div><div class="line">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</div><div class="line">const isOver18 = person =&gt; person.age &gt;= 18</div><div class="line">const isCitizen = person =&gt; wasBornInCountry(person) || wasNaturalized(person)</div><div class="line">const isEligibleToVote = person =&gt; isOver18(person) &amp;&amp; isCitizen(person)</div><div class="line"></div><div class="line">const isEligibleToVote = person =&gt; both(isOver18, isCitizen)(person)</div><div class="line">const isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line">const isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure>
</code></pre><h4 id="读取对象属性"><a href="#读取对象属性" class="headerlink" title="读取对象属性"></a>读取对象属性</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</div><div class="line">const isOver18 = person =&gt; person.age &gt;= 18</div><div class="line">const isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line">const isEligibleToVote = both(isOver18, isCitizen)</div><div class="line"></div><div class="line">// 改写为</div><div class="line">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY)</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</div><div class="line">const isOver18 = person =&gt; gte(person.age, 18)</div></pre></td></tr></table></figure>
</code></pre><h5 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h5><pre><code>定义：取出对象中指定属性的值。如果不存在，则返回 undefined。
R.prop(&apos;x&apos;, {x: 100}); //=&gt; 100
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var wasBornInCountry = R.compose(R.equals(&apos;CHINA&apos;), R.prop(&apos;birthCountry&apos;))</div><div class="line">var wasNaturalized = R.compose(Boolean, R.prop(&apos;naturalizationDate&apos;))</div><div class="line">var isOver18 = R.compose(R.gte(R.__, 18), R.prop(&apos;age&apos;))</div><div class="line">console.log(R.both(wasBornInCountry, isOver18)(person1)); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。
R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {a: 1, d: 4}
</code></pre><h5 id="has-hasIn"><a href="#has-hasIn" class="headerlink" title="has/hasIn"></a>has/hasIn</h5><pre><code>has定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。
R.has(&apos;name&apos;)({name: &apos;alice&apos;});
hasIn定义：如果对象自身或其原型链上含有指定的属性，则返回 true；否则返回 false。
</code></pre><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><pre><code>定义：取出给定路径上的值。
R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); //=&gt; 2
</code></pre><h5 id="propOr-pathOr"><a href="#propOr-pathOr" class="headerlink" title="propOr / pathOr"></a>propOr / pathOr</h5><pre><code>propOr定义：propOr 和 pathOr 像是 prop/path 与 defaultTo 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值
propOr(&apos;&lt;Unnamed&gt;&apos;, &apos;name&apos;, person);
</code></pre><h5 id="keys-values"><a href="#keys-values" class="headerlink" title="keys / values"></a>keys / values</h5><pre><code>keys 返回一个包含对象中所有属性名称的数组，values 返回这些属性的值组成的数组。
</code></pre><h5 id="对属性增、删、改、查"><a href="#对属性增、删、改、查" class="headerlink" title="对属性增、删、改、查"></a>对属性增、删、改、查</h5><pre><code>···    
assoc/assocPath
assoc：浅复制对象，然后设置或覆盖对象的指定属性。
R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); //=&gt; {a: 1, b: 2, c: 3}
assocPath：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。
R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); //=&gt; {a: {b: {c: 42}}}

dissoc/dissocPath/omit
dissoc：删除对象中指定 prop 属性。
R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); //=&gt; {a: 1, c: 3}
dissocPath：浅复制对象，删除返回对象中指定路径上的属性。
R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); //=&gt; {a: {b: {}}}
omit：删除对象中给定的 keys 对应的属性。
R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">####	属性转换</div><div class="line">	evolve：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。</div></pre></td></tr></table></figure>

var tomato  = {firstName: &apos;  Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123};
var transformations = {
  firstName: R.trim,
  lastName: R.trim, // Will not get invoked.
  data: {elapsed: R.add(1), remaining: R.add(-1)}
};
R.evolve(transformations, tomato); //=&gt; {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####	合并对象</div><div class="line">	merge：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。</div></pre></td></tr></table></figure>

R.merge({ &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10 }, { &apos;age&apos;: 40 });
//=&gt; { &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 40 }
// 定义一个反转合并的函数(用前面的同名属性覆盖后面的同名属性)
 reverseMerge：const reverseMerge = R.flip(merge)
```
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：pointfree(无参数风格编程) 
对象属性：读取(prop、pick、has、path、propOr、pathOr、keys、values、)
增删改查(assoc、assocPath、dissoc、dissocPath、omit)
属性转换(evolve)
合并对象(merge)
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;Pointfree-风格（无参数风格）&quot;&gt;&lt;a href=&quot;#Pointfree-风格（无参数风格）&quot; class=&quot;headerlink&quot; title=&quot;Pointfree 风格（无参数风格）&quot;&gt;&lt;/a&gt;Pointfree 
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda无参数风格编程 (Pointfree Style)和声明式编程</title>
    <link href="https://fanerge.github.io/2017/08/21/ramda%E8%BF%90%E7%94%A8-1/"/>
    <id>https://fanerge.github.io/2017/08/21/ramda运用-1/</id>
    <published>2017-08-21T12:37:43.000Z</published>
    <updated>2017-08-22T11:38:32.585Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="部分应用（Partial-Application）"><a href="#部分应用（Partial-Application）" class="headerlink" title="部分应用（Partial Application）"></a>部分应用（Partial Application）</h4><pre><code>在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？
例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var books = [</div><div class="line">  &#123;year: 1991, title: &apos;11111&apos;&#125;,</div><div class="line">  &#123;year: 1991, title: &apos;22222&apos;&#125;,</div><div class="line">  &#123;year: 1992, title: &apos;33333&apos;&#125;</div><div class="line">];</div><div class="line">const publishedInYear = (book, year) =&gt; book.year === year;</div><div class="line">const titlesForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(book =&gt; publishedInYear(book, year), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;;</div><div class="line">var book1 = titlesForYear(books, 1991); // [&apos;11111&apos;, &apos;22222&apos;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><pre><code>获取或返回其他函数的函数称为 &quot;高阶函数&quot;。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 高阶函数</div><div class="line">var publishedInYear = function (year) &#123;</div><div class="line">  return function (book) &#123;</div><div class="line">	return book.year === year;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">// 箭头函数</div><div class="line">// var publishedInYear = year =&gt; book =&gt; book.year === year;</div><div class="line">var titlesForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(publishedInYear(year), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;; </div><div class="line">console.log(titlesForYear(books, 1992)); // &apos;33333&apos;</div></pre></td></tr></table></figure>
</code></pre><h5 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h5><pre><code>partial/partialRight（部分应用）
定义：这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 例子，只是想检查一本书是否是在指定年份出版的。</div><div class="line">var publishedInYear = (book, year) =&gt; book.year === year;</div><div class="line">var titleForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(R.partialRight(publishedInYear, [year]), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;;</div><div class="line">// console.log(titleForYear(books, 1992)); // [&apos;33333&apos;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h5><pre><code>定义：一个柯里化了的函数是一系列高阶一元函数，将多参数函数转化为单参数函数。
一般来说，我只有需要在多个地方对同一个函数使用 partial 的时候，才会对函数进行柯里化。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var publishedInYear = R.curry((year, book) =&gt; book.year === year);</div><div class="line">var titlesForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(publishedInYear(year), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;;</div><div class="line">console.log(titlesForYear(books, 1992)); // [&apos;33333&apos;]</div><div class="line">var book2 = publishedInYear(1992, &#123;year: 1992, title: &apos;33333&apos;&#125;); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="顺序错误的参数"><a href="#顺序错误的参数" class="headerlink" title="顺序错误的参数"></a>顺序错误的参数</h5><pre><code>filp：交换函数前两个参数的位置。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);</div><div class="line">console.log(R.flip(mergeThree)(1, 2, 3)); // [2, 1, 3]</div></pre></td></tr></table></figure>

__或placeholder (占位符)
定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。
更通用的选择是使用 &quot;placeholder&quot; 参数（__）
假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const threeArgs = curry((a, b, c) =&gt; &#123; /* ... */ &#125;);</div><div class="line">const middleArgumentLater = threeArgs(&apos;value for a&apos;, R.__, &apos;value for c&apos;);</div><div class="line"></div><div class="line">var publishedInYear = R.curry((year, book) =&gt; book.year === year)</div><div class="line">var titlesForYear = R.curry((year, books) =&gt;</div><div class="line">  R.pipe(</div><div class="line">	R.filter(publishedInYear(year)),</div><div class="line">	R.map(book =&gt; book.title)</div><div class="line">  )(books)</div><div class="line">)</div><div class="line">// console.log(titlesForYear(1991, books)); // [&quot;11111&quot;, &quot;22222&quot;]</div></pre></td></tr></table></figure>
</code></pre><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><h5 id="命令式-vs-声明式"><a href="#命令式-vs-声明式" class="headerlink" title="命令式 vs 声明式"></a>命令式 vs 声明式</h5><pre><code>命令式编程中，程序员需要告诉计算机怎么做来完成任务。
声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var square = x =&gt; R.multiply(x, x);</div><div class="line">var operate = R.pipe(</div><div class="line">  R.multiply,</div><div class="line">  R.add(1),</div><div class="line">  square</div><div class="line">  );</div><div class="line">var operate3 = operate(3, 4); // 169</div><div class="line">// add(1) 与增量运算符（++）非常相似，但 ++ 修改了被操作的值，因此它是 &quot;mutation&quot; 的。</div><div class="line">// 所以使用R.add(1),R.subtract(1)代替++ 和 --</div><div class="line">// Ramda提供了R.inc和R.dec</div><div class="line">R.dec(42); //=&gt; 41</div><div class="line">R.negate(42); //=&gt; -42 取反</div></pre></td></tr></table></figure>
</code></pre><h5 id="比较-Comparison"><a href="#比较-Comparison" class="headerlink" title="比较(Comparison)"></a>比较(Comparison)</h5><pre><code>使用R.gt()、R.gte()、R.lt()、R.lte()、R.equals()代替&gt;、&gt;=、&lt;、&lt;=、===
identical：如果两个参数是完全相同，则返回 true，否则返回 false。如果它们引用相同的内存，也认为是完全相同的。
isEmpty：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。
isNil：检测输入值是否为 null 或 undefined 。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 改写投票的例子</div><div class="line">var wasBornInCountry = person =&gt; R.equals(person.birthCountry, &apos;CHINA&apos;);</div><div class="line">var wasNaturalized = person =&gt; Boolean(person.naturalizationDate);</div><div class="line">var isOver18 = person =&gt; R.gte(person.age, 18);</div><div class="line">var isCitizen = R.either(wasBornInCountry, wasBornInCountry);</div><div class="line">var isEligibleToVote = R.both(isOver18, isCitizen);</div><div class="line">console.log(isEligibleToVote(&#123;</div><div class="line">  birthCountry: &apos;CHINA&apos;, </div><div class="line">  naturalizationDate: false,</div><div class="line">  age: 22</div><div class="line">&#125;)); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="逻辑-Logic"><a href="#逻辑-Logic" class="headerlink" title="逻辑(Logic)"></a>逻辑(Logic)</h5><pre><code>both 和 either 来代替 &amp;&amp; 和 || 运算符。使用 complement 代替 !。
我以下列方式进行分类：and、or 和 not 用于处理数值；both、either 和 complement 用于处理函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var setting = &#123;&#125;;</div><div class="line">var lineWith = setting.lineWith || 80;</div><div class="line">var lineWith = R.defaultTo(80, setting.lineWith);</div><div class="line">console.log(lineWith); //使用后者代替前者</div></pre></td></tr></table></figure>
</code></pre><h5 id="条件-Conditionals"><a href="#条件-Conditionals" class="headerlink" title="条件(Conditionals)"></a>条件(Conditionals)</h5><pre><code>R.ifElse 代替 if-else
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var forever21 = age =&gt; age &gt;= 21 ? 21 : age + 1</div><div class="line">// console.log(forever21(19)); // 20</div><div class="line">var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), () =&gt; 21, R.inc)(age)</div><div class="line">// console.log(forever21(19)); // 20</div></pre></td></tr></table></figure>
</code></pre><h5 id="constants-常量"><a href="#constants-常量" class="headerlink" title="constants (常量)"></a>constants (常量)</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">R.always(42) 代替 42</div><div class="line">R.T() === true 忽略所有参数</div><div class="line">console.log(R.T(false)); // true</div><div class="line">R.F() === false 忽略所有参数</div></pre></td></tr></table></figure>
</code></pre><h5 id="identity-恒等"><a href="#identity-恒等" class="headerlink" title="identity (恒等)"></a>identity (恒等)</h5><pre><code>输出恒等于输入。如，a =&gt; a
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">identity：将输入值原样返回。适合用作默认或占位函数。</div><div class="line">nthArg；返回一个函数，该函数返回它的第 n 个参数。</div><div class="line">const alwaysDrivingAge = age =&gt; ifElse(lt(__, 16), always(16), a =&gt; a)(age)</div></pre></td></tr></table></figure>
</code></pre><h5 id="when-和-unless"><a href="#when-和-unless" class="headerlink" title="when 和 unless"></a>when 和 unless</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var alwaysDrivingAge = age =&gt; R.unless(R.gte(R.__, 16), R.always(16))(age)</div><div class="line">console.log(alwaysDrivingAge(15)); // 16</div></pre></td></tr></table></figure>
</code></pre><h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><pre><code>作用：来代替 switch 语句或链式的 if...then...else 语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const water = temperature =&gt; R.cond([</div><div class="line">  [R.equals(0),   R.always(&apos;water freezes at 0°C&apos;)],</div><div class="line">  [R.equals(100), R.always(&apos;water boils at 100°C&apos;)],</div><div class="line">  [R.T,           temp =&gt; `nothing special happens at $&#123;temp&#125;°C`]</div><div class="line">])(temperature)</div><div class="line">console.log(water(23)); // nothing special happens at 23°C</div></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：高阶函数、部分应用函数、柯里化（Curry）、改变参数顺序的方法（flip、plachhokder__、pipeline）
常用的声明式编程替换命令式编程：add、subtract、multiply、divide等等
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;部分应用（Partial-Application）&quot;&gt;&lt;a href=&quot;#部分应用（Partial-Application）&quot; class=&quot;headerlink&quot; title=&quot;部分应用（Partial Applicatio
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda入门和函数组合</title>
    <link href="https://fanerge.github.io/2017/08/20/ramda%E8%BF%90%E7%94%A8/"/>
    <id>https://fanerge.github.io/2017/08/20/ramda运用/</id>
    <published>2017-08-20T13:37:12.000Z</published>
    <updated>2017-08-21T12:40:06.116Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="总结Ramda与Lodash和Underscore的优势"><a href="#总结Ramda与Lodash和Underscore的优势" class="headerlink" title="总结Ramda与Lodash和Underscore的优势"></a>总结Ramda与Lodash和Underscore的优势</h4><h5 id="自动柯里化"><a href="#自动柯里化" class="headerlink" title="自动柯里化"></a>自动柯里化</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 一map函数为例，解释Ramda的自动柯里化 </div><div class="line">// map函数解释：param1为对集合每一项进行处理并返回同类型的数据，param2需要处理的集合（Array或Object）</div><div class="line">// 第一种，为使用柯里化</div><div class="line">var map3 = R.map(function (item) &#123;</div><div class="line">  return item * item;</div><div class="line">&#125;, [1, 2, 3, 4]); </div><div class="line">// console.log(map3); // [1, 4, 9, 16]</div><div class="line"></div><div class="line">// 第一种curry化（转化成单参数函数）</div><div class="line">var map1 = R.map(function (item) &#123;</div><div class="line">  return item * item;</div><div class="line">&#125;);</div><div class="line">var map2 = map1([1, 2, 3, 4]);</div><div class="line">// console.log(map2); // [1, 4, 9, 16]</div></pre></td></tr></table></figure>
</code></pre><h5 id="函数参数优先于数据"><a href="#函数参数优先于数据" class="headerlink" title="函数参数优先于数据"></a>函数参数优先于数据</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 函数优先于数据</div><div class="line">var map4 = R.map(R.multiply(2), [1, 2, 3, 4]);</div><div class="line">// console.log(map4); // [2, 4, 6, 8]</div><div class="line">var map5 = R.map(R.multiply(2))([1, 2, 3, 4]);</div><div class="line">// console.log(map5); // [2, 4, 6, 8]</div></pre></td></tr></table></figure>
</code></pre><h4 id="Ramdajs的组合"><a href="#Ramdajs的组合" class="headerlink" title="Ramdajs的组合"></a>Ramdajs的组合</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// ramdajs的compose组合</div><div class="line">var users = [</div><div class="line">  &#123; &apos;user&apos;: &apos;user1&apos;,  &apos;age&apos;: 36 &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;user2&apos;,    &apos;age&apos;: 40 &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;user3&apos;, &apos;age&apos;: 18 &#125;</div><div class="line">];</div><div class="line">// R.pluck(k)[array] === R.map(R.prop(k), array)</div><div class="line">var pluck1 = R.pluck(&apos;user&apos;)(users);</div><div class="line">var pluck2 = R.map(R.prop(&apos;user&apos;))(users);</div><div class="line"></div><div class="line">// compose为函数组合（从右到左）</div><div class="line">var pluck3 = R.compose(R.join(&apos;,&apos;), R.pluck(&apos;user&apos;))(users);</div><div class="line">// console.log(pluck3); // user1,user2,user3</div><div class="line">// pipe为函数组合（从左到右）</div><div class="line">var pipe1 = R.pipe(R.pluck(&apos;user&apos;), R.join(&apos;*&apos;))(users);</div><div class="line">// console.log(pipe1); // user1*user2*user3</div><div class="line"></div><div class="line">// 依次获得用户的出生年</div><div class="line">var compose1 = R.compose(R.join(&apos;,&apos;), R.map(R.subtract(new Date().getFullYear())), R.pluck(&apos;age&apos;))(users);</div><div class="line">console.log(compose1); // 1981,1977,1999</div><div class="line"></div><div class="line">// 获得最年轻的用户信息</div><div class="line">var userMin = R.compose(R.head, R.sortBy(R.prop(&apos;age&apos;)))(users);</div><div class="line">var userMax = R.compose(R.last, R.sortBy(R.prop(&apos;age&apos;)))(users);</div><div class="line">var userMax1 = R.compose(R.head, R.reverse, R.sortBy(R.prop(&apos;age&apos;)))(users);</div><div class="line">console.log(userMin, userMax); // &#123;user: &quot;user3&quot;, age: 18&#125; &#123;user: &quot;user2&quot;, age: 40&#125;</div><div class="line">console.log(userMax1); // &#123;user: &quot;user2&quot;, age: 40&#125;</div></pre></td></tr></table></figure>

**纯函数**纯函数是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 &quot;输出&quot;，不会对数据库进行读写，不会修改输入参数等。
纯函数的基本思想是：相同的输入，永远会得到相同的输出。
**数据不变性**函数式编程的另一个重要概念是 &quot;Immutability&quot;，&quot;Immutability&quot; 是指 &quot;数据不变性&quot;。
当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。
开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">foreach</div><div class="line">for (const value of Array) &#123;</div><div class="line">	console.log(value);</div><div class="line">&#125;</div><div class="line">forEach(value =&gt; console.log(value), Array);</div><div class="line"></div><div class="line">map</div><div class="line">map(x =&gt; x*2, [1, 2, 3]); // [2, 4, 6]</div><div class="line"></div><div class="line">filter/reject(互补)</div><div class="line">const isEven = x =&gt; x % 2 === 0;</div><div class="line">filter(isEven, [1, 2, 3]); // [2]</div><div class="line">reject(isEven, [1, 2, 3]); // [1, 3]</div><div class="line"></div><div class="line">find</div><div class="line">find(isEven, [1, 2, 3, 4]); // 2</div><div class="line"></div><div class="line">reduce</div><div class="line">const add = (accum, value) =&gt; accum + value;	</div><div class="line">reduce(add, 5, [1, 2, 3, 4]); // 15</div></pre></td></tr></table></figure>
</code></pre><h4 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h4><h5 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h5><pre><code>Complement：对函数的返回值取反。接受一个函数 f，返回一个新函数 g。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const isEven = x =&gt; x % 2 === 0;</div><div class="line">var complement1 = R.find(isEven, [1, 1, 2, 4]); // 2</div><div class="line">var complement2 = R.find(R.complement(isEven), [1, 2, 2, 4]); // 1</div></pre></td></tr></table></figure>
</code></pre><h5 id="Both-Either"><a href="#Both-Either" class="headerlink" title="Both/Either"></a>Both/Either</h5><pre><code>both：该函数调用两个函数，并对两函数返回值进行与（&amp;&amp;）操作。
either：该函数调用两个函数，并对两函数返回值进行或（||）操作。    
投票系统（投票资格的条件：在本国出生，或者后来加入该国国籍，且年满18岁。）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 判断是否有投票的权利</div><div class="line">let person1 = &#123;</div><div class="line">  birthCountry: &apos;CHINA&apos;,</div><div class="line">  naturalizationDate: false,</div><div class="line">  age: 20</div><div class="line">&#125;;</div><div class="line">const wasBornInCountry = person =&gt; person.birthCountry === &apos;CHINA&apos;;</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate);</div><div class="line">const isOver18 = person =&gt; person.age &gt;= 18;</div><div class="line">var isCitizen = R.either(wasBornInCountry, wasNaturalized); // 在本国出生，或者后来加入该国国籍。</div><div class="line">var isEligibleToVote = R.both(isCitizen, isOver18);</div><div class="line">var vote1 = isEligibleToVote(person1); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="Pipelines-管道"><a href="#Pipelines-管道" class="headerlink" title="Pipelines(管道)"></a>Pipelines(管道)</h5><pre><code>pipe：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var multiply = (num1, num2) =&gt; num1 * num2;</div><div class="line">var addOne = num =&gt; num + 1;</div><div class="line">var square = num =&gt; num * num;</div><div class="line">var operate1 = R.pipe(multiply, addOne, square)(1, 2); // ((1*2)+1)^2 = 9</div></pre></td></tr></table></figure>

compose：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var operate2 =R.compose(square, addOne, multiply)(1, 2); // 9</div></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：函数、纯函数、IMMUTABILITY、foreach（递归替代循环）、map、filter、reject、find、reduce、
函数组合的方法：complement、either、both、pipe、compose、
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;总结Ramda与Lodash和Underscore的优势&quot;&gt;&lt;a href=&quot;#总结Ramda与Lodash和Underscore的优势&quot; class=&quot;headerlink&quot; title=&quot;总结Ramda与Lodash和Un
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda库的使用</title>
    <link href="https://fanerge.github.io/2017/08/16/ramda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://fanerge.github.io/2017/08/16/ramda库的使用/</id>
    <published>2017-08-16T12:24:01.000Z</published>
    <updated>2017-08-16T14:39:03.457Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanerge/Ramda-study/blob/master/ramda/js/pointfree.js" target="_blank" rel="external">学习源代码地址</a></p>
<h4 id="了解Pointfree的概念"><a href="#了解Pointfree的概念" class="headerlink" title="了解Pointfree的概念"></a>了解Pointfree的概念</h4><pre><code>概念：fn = R.pipe(f1, f2, f3);
可以把数据处理的过程，定义成一种与参数无关的合成运算。
**不使用所要处理的值，只合成运算过程。**
</code></pre><h5 id="一些小例子"><a href="#一些小例子" class="headerlink" title="一些小例子"></a>一些小例子</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// pointfree例子</div><div class="line">var addOne = x =&gt; x + 1;</div><div class="line">var square = x =&gt; x * x;</div><div class="line">var addOneThenSquare = R.pipe(square, addOne);</div><div class="line">var pointfree1 = addOneThenSquare(3);</div><div class="line">console.log(pointfree1); // 10</div><div class="line">// addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。</div><div class="line"></div><div class="line">var prop = (p, obj) =&gt; obj[p]; // 封装了读取操作，它需要两个参数p（属性名）和obj（对象）。</div><div class="line">var propRole = R.curry(prop)(&apos;role&apos;); // 将函数柯里化</div><div class="line">var demo1 = propRole(&#123;role: &apos;fan&apos;&#125;);</div><div class="line">console.log(demo1); // fan</div><div class="line"></div><div class="line">var data = [</div><div class="line">  &#123;name: &apos;张三&apos;, role: &apos;worker&apos;&#125;,</div><div class="line">  &#123;name: &apos;李四&apos;, role: &apos;worker&apos;&#125;,</div><div class="line">  &#123;name: &apos;王五&apos;, role: &apos;manager&apos;&#125;,</div><div class="line">];</div><div class="line">var isWorker = r =&gt; r === &apos;worker&apos;;</div><div class="line">var getWorkers = R.filter(R.pipe(R.prop(&apos;role&apos;), isWorker));</div><div class="line">var demo2 = getWorkers(data);</div><div class="line">// console.log(demo2); </div><div class="line">// [</div><div class="line">//   &#123;&quot;name&quot;: &quot;张三&quot;, &quot;role&quot;: &quot;worker&quot;&#125;,</div><div class="line">//   &#123;&quot;name&quot;: &quot;李四&quot;, &quot;role&quot;: &quot;worker&quot;&#125;</div><div class="line">// ]</div></pre></td></tr></table></figure>
</code></pre><h5 id="Pointfree示例一"><a href="#Pointfree示例一" class="headerlink" title="Pointfree示例一"></a>Pointfree示例一</h5><pre><code>**求下面字符串，请问其中最长的单词有多少个字符？**
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var str = &apos;Lorem ipsum dolor sit amet consectetur adipiscing elit&apos;;</div><div class="line">// 以空格分割单词</div><div class="line">var splitBySpace = s =&gt; s.split(&apos; &apos;);</div><div class="line">// 获得每个单词的长度</div><div class="line">var getLength = w =&gt; w.length;</div><div class="line">// 单词数组转化为单词长度的数组</div><div class="line">var getLengArr = arr =&gt; R.map(getLength, arr);</div><div class="line">// 返回较大的数字</div><div class="line">var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;</div><div class="line">// 返回最大的一个数字</div><div class="line">var findBiggestNumber = arr =&gt; R.reduce(getBiggerNumber, 0, arr);</div><div class="line"></div><div class="line">var getLongestWordLength = R.pipe(  </div><div class="line">	splitBySpace,</div><div class="line">	getLengArr,</div><div class="line">	findBiggestNumber</div><div class="line">  );</div><div class="line">var demo3 = getLongestWordLength(str);</div><div class="line">console.log(demo3); // 11</div><div class="line"></div><div class="line">// 使用ramda库</div><div class="line">var getLongestWordLength = R.pipe(</div><div class="line">	R.split(&apos; &apos;),</div><div class="line">	R.map(R.length),</div><div class="line">	R.reduce(R.max, 0)</div><div class="line">  );</div><div class="line">var demo3 = getLongestWordLength(str);</div><div class="line">// console.log(demo3); // 11</div></pre></td></tr></table></figure>
</code></pre><h4 id="Pointfree-示例二"><a href="#Pointfree-示例二" class="headerlink" title="Pointfree 示例二"></a>Pointfree 示例二</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// 下面是一段服务器返回的 JSON 数据。</div><div class="line">var data = &#123;</div><div class="line">	result: &quot;SUCCESS&quot;,</div><div class="line">	interfaceVersion: &quot;1.0.3&quot;,</div><div class="line">	requested: &quot;10/17/2013 15:31:20&quot;,</div><div class="line">	lastUpdated: &quot;10/16/2013 10:52:39&quot;,</div><div class="line">	tasks: [</div><div class="line">		&#123;id: 104, complete: false,            priority: &quot;high&quot;,</div><div class="line">				  dueDate: &quot;2013-11-29&quot;,      username: &quot;Scott&quot;,</div><div class="line">				  title: &quot;Do something&quot;,      created: &quot;9/22/2013&quot;&#125;,</div><div class="line">		&#123;id: 105, complete: false,            priority: &quot;medium&quot;,</div><div class="line">				  dueDate: &quot;2013-11-22&quot;,      username: &quot;Lena&quot;,</div><div class="line">				  title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;&#125;,</div><div class="line">		&#123;id: 107, complete: true,             priority: &quot;high&quot;,</div><div class="line">				  dueDate: &quot;2013-11-22&quot;,      username: &quot;Mike&quot;,</div><div class="line">				  title: &quot;Fix the foo&quot;,       created: &quot;9/22/2013&quot;&#125;,</div><div class="line">		&#123;id: 108, complete: false,            priority: &quot;low&quot;,</div><div class="line">				  dueDate: &quot;2013-11-15&quot;,      username: &quot;Punam&quot;,</div><div class="line">				  title: &quot;Adjust the bar&quot;,    created: &quot;9/25/2013&quot;&#125;,</div><div class="line">		&#123;id: 110, complete: false,            priority: &quot;medium&quot;,</div><div class="line">				  dueDate: &quot;2013-11-15&quot;,      username: &quot;Scott&quot;,</div><div class="line">				  title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;&#125;,</div><div class="line">		&#123;id: 112, complete: true,             priority: &quot;high&quot;,</div><div class="line">				  dueDate: &quot;2013-11-27&quot;,      username: &quot;Lena&quot;,</div><div class="line">				  title: &quot;Alter all quuxes&quot;,  created: &quot;10/5/2013&quot;&#125;</div><div class="line">	]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var fetchData = function (data) &#123;</div><div class="line">  return Promise.resolve(data);</div><div class="line">&#125;;</div><div class="line">// 提取 tasks 属性</div><div class="line">var SelectTasks = R.prop(&apos;tasks&apos;);</div><div class="line"></div><div class="line">// 过滤出指定的用户</div><div class="line">var filterMember = member =&gt; R.filter(</div><div class="line">  R.propEq(&apos;username&apos;, member)</div><div class="line">  );</div><div class="line"></div><div class="line">// 排除已经完成的任务</div><div class="line">var excludeCompletedTasks = R.reject(R.propEq(&apos;complete&apos;, true));</div><div class="line"></div><div class="line">// 选取指定属性</div><div class="line">var selectFields = R.map(</div><div class="line">	R.pick([&apos;id&apos;, &apos;dueDate&apos;, &apos;title&apos;, &apos;priority&apos;])</div><div class="line">  );</div><div class="line"></div><div class="line">// 按照到期日期排序</div><div class="line">var sortByDueDate = R.sortBy(R.prop(&apos;dueDate&apos;));</div><div class="line"></div><div class="line">// 合成函数</div><div class="line">var getIncompleteTaskSummaries = function (membername) &#123;</div><div class="line">  return fetchData(data)</div><div class="line">  .then(R.prop(&apos;tasks&apos;))</div><div class="line">  .then(R.filter(R.propEq(&apos;username&apos;, membername)))</div><div class="line">  .then(R.reject(R.propEq(&apos;complete&apos;, true)))</div><div class="line">  .then(R.map(R.pick([&apos;id&apos;, &apos;dueData&apos;, &apos;title&apos;, &apos;priority&apos;])))</div><div class="line">  .then(R.sortBy(R.prop(&apos;dueData&apos;)));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var scottList = getIncompleteTaskSummaries(&apos;Scott&apos;);</div><div class="line">console.log(scottList);	</div><div class="line">[[object Object] &#123;</div><div class="line">  dueDate: &quot;2013-11-15&quot;,</div><div class="line">  id: 110,</div><div class="line">  priority: &quot;medium&quot;,</div><div class="line">  title: &quot;Rename everything&quot;</div><div class="line">&#125;, [object Object] &#123;</div><div class="line">  dueDate: &quot;2013-11-29&quot;,</div><div class="line">  id: 104,</div><div class="line">  priority: &quot;high&quot;,</div><div class="line">  title: &quot;Do something&quot;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="external">阮老师–Pointfree 编程风格指南</a><br><a href="http://ramda.cn/" target="_blank" rel="external">Ramda 中文</a>    </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanerge/Ramda-study/blob/master/ramda/js/pointfree.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;学习源代码地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>Ramda库学习</title>
    <link href="https://fanerge.github.io/2017/08/13/Ramda%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/08/13/Ramda库学习/</id>
    <published>2017-08-13T11:28:31.000Z</published>
    <updated>2017-08-16T12:38:21.873Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanerge/Ramda-study.git" target="_blank" rel="external">学习源代码</a><br>经过4个晚上的学习，了解了ramda库120多个api的用法，下一步继续深入学习函数式编程。<br>继续学习js函数式编程，这里贴出阮老师总结的Ramda的优点：</p>
<pre><code>1.    Ramda 的数据一律放在最后一个参数，理念是&quot;function first，data last&quot;。
2.    所有方法都支持柯里化。
</code></pre><h4 id="一、比较运算（gt、gte、lt、lte、eauals、eqBy）"><a href="#一、比较运算（gt、gte、lt、lte、eauals、eqBy）" class="headerlink" title="一、比较运算（gt、gte、lt、lte、eauals、eqBy）"></a>一、比较运算（gt、gte、lt、lte、eauals、eqBy）</h4><pre><code>gt：判断第一个参数是否大于第二个参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let gt1 = R.gt(2)(1);</div><div class="line">// console.log(gt1); true</div><div class="line">let gt2 = R.gt(&apos;a&apos;)(&apos;c&apos;);</div><div class="line">// console.log(gt2); false</div></pre></td></tr></table></figure>

gte：判断第一个参数是否大于等于第二个参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let gte1 = R.gte(2)(2);</div><div class="line">// console.log(gte1); true</div><div class="line">let gte2 = R.gte(&apos;a&apos;)(&apos;c&apos;);</div><div class="line">// console.log(gte2); false</div></pre></td></tr></table></figure>

lt：判断第一个参数是否小于第二个参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let lt1 = R.lt(2)(1);</div><div class="line">// console.log(lt1); false</div><div class="line">let lt2 = R.lt(&apos;a&apos;)(&apos;z&apos;);</div><div class="line">// console.log(lt2); true</div></pre></td></tr></table></figure>

lte：判断第一个参数是否小于等于第二个参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let lte1 = R.lte(1)(2);</div><div class="line">// console.log(lte1); true</div><div class="line">let lte2 = R.lte(&apos;a&apos;)(&apos;v&apos;);</div><div class="line">// console.log(lte2); true</div></pre></td></tr></table></figure>

eauals：比较两个值是否相等（支持对象的比较）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let equals1 = R.equals(1)(1);</div><div class="line">// console.log(equals1); true</div><div class="line">let equals2 = R.equals(1)(&apos;1&apos;);</div><div class="line">// console.log(equals2); false</div><div class="line">let equals3 = R.equals([1, 2])([1,2]);</div><div class="line">// console.log(equals3); // true</div><div class="line">let equals4 = R.equals(&#123;a:1&#125;)(&#123;a:2&#125;);</div><div class="line">// console.log(equals4); // false</div></pre></td></tr></table></figure>

eqBy：比较两个值传入指定函数的运算结果是否相等。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let eqBy1 = R.eqBy(Math.abs, 5, -5);</div><div class="line">console.log(eqBy1);</div></pre></td></tr></table></figure>
</code></pre><h4 id="二、数学运算（add、subtract、multiply、divide）"><a href="#二、数学运算（add、subtract、multiply、divide）" class="headerlink" title="二、数学运算（add、subtract、multiply、divide）"></a>二、数学运算（add、subtract、multiply、divide）</h4><pre><code>add：返回两个值的和。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let add1 = R.add(1)(10);</div><div class="line">// console.log(add1); // 11</div></pre></td></tr></table></figure>

subtract：返回第一个参数减去第二个参数的差。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let subtract1 = R.subtract(10)(2);</div><div class="line">//console.log(subtract1); // 8</div></pre></td></tr></table></figure>

multiply：返回两个值的积。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let multiply1 = R.multiply(5)(6);</div><div class="line">// console.log(multiply1); // 30</div></pre></td></tr></table></figure>

divide：返回第一个参数除以第二个参数的商。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let divide1 = R.divide(5)(10);</div><div class="line">// console.log(divide1); // 0.5</div></pre></td></tr></table></figure>
</code></pre><h4 id="三、逻辑运算（either、both、allPass）"><a href="#三、逻辑运算（either、both、allPass）" class="headerlink" title="三、逻辑运算（either、both、allPass）"></a>三、逻辑运算（either、both、allPass）</h4><pre><code>either：接收两个参数，相当于 || 运算（或）。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let gt10 = x =&gt; x &gt; 10;</div><div class="line">let even = x =&gt; x % 2 === 0;</div><div class="line">let either1 = R.either(gt10)(even);</div><div class="line">let either2 = either1(18);</div><div class="line">let either3 = either1(3);</div><div class="line">// console.log(either2); // true</div><div class="line">//console.log(either3); // false</div></pre></td></tr></table></figure>

both：接收两个参数，相当于 &amp;&amp; 运算（且）。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var gt10 = x =&gt; x &gt; 10;</div><div class="line">var even = x =&gt; x % 2 === 0;</div><div class="line">let both1 = R.both(gt10)(even);</div><div class="line">let both2 = both1(18);</div><div class="line">let both3 = both1(4);</div><div class="line">// console.log(both2); // true</div><div class="line">// console.log(both3); // false</div></pre></td></tr></table></figure>

allPass：接受一个函数数组作为参数，只有它们都返回true，才返回true，否则返回false。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var gt10 = x =&gt; x &gt; 10;</div><div class="line">var lt20 = x =&gt; x &lt; 20;</div><div class="line">var even = x =&gt; x % 2 === 0;</div><div class="line">let allPass1 = R.allPass([gt10, even, lt20]);</div><div class="line">let allPass2 = allPass1(16);</div><div class="line">let allPass3 = both1(13);</div><div class="line">console.log(allPass2); // true</div><div class="line">console.log(allPass3); // false</div></pre></td></tr></table></figure>
</code></pre><h4 id="四、字符串（split、test、match）"><a href="#四、字符串（split、test、match）" class="headerlink" title="四、字符串（split、test、match）"></a>四、字符串（split、test、match）</h4><pre><code>split：按照指定分隔符将字符串拆成一个数组。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let split1 = R.split(&apos;.&apos;)(&apos;a.b.c.fanerge&apos;);</div><div class="line">// console.log(split1); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;fanerge&quot;]</div></pre></td></tr></table></figure>

test：判断一个字符串是否匹配给定的正则表达式。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let test1 = R.test(/^f/)(&apos;fanerge&apos;);</div><div class="line">// console.log(test1); // true</div></pre></td></tr></table></figure>

match：返回一个字符串的匹配结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let match1 = R.match(/([a-z]a)/g)(&apos;bananas&apos;)</div><div class="line">// console.log(match1); // [&quot;ba&quot;, &quot;na&quot;, &quot;na&quot;]</div><div class="line">let match2 = R.match(/a/)(&apos;n&apos;);</div><div class="line">// console.log(match2); // []</div></pre></td></tr></table></figure>
</code></pre><h4 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h4><h5 id="5-1-函数的合成（compose、pipe、converge）"><a href="#5-1-函数的合成（compose、pipe、converge）" class="headerlink" title="5.1 函数的合成（compose、pipe、converge）"></a>5.1 函数的合成（compose、pipe、converge）</h5><pre><code>compose：将多个函数合并成一个函数，从右到左执行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let compose1 = R.compose(Math.abs, R.add(1), R.multiply(2))(4)</div><div class="line">console.log(compose1); // 9</div></pre></td></tr></table></figure>

pipe：将多个函数合并成一个函数，从左到右执行。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let pipe1 = R.pipe(Math.abs, R.add(1), R.multiply(2))(4);</div><div class="line">console.log(pipe1); // 10</div></pre></td></tr></table></figure>

converge：接受两个参数，第一个参数是函数，第二个参数是函数数组。传入的值先使用第二个参数包含的函数分别处理以后，再用第一个参数处理前一步生成的结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var sumOfArr = arr =&gt; &#123;</div><div class="line">	let sum = 0;</div><div class="line">	arr.forEach(i =&gt; sum += i);</div><div class="line">	return sum;</div><div class="line">&#125;;</div><div class="line">var lengthArr = arr =&gt; arr.length;</div><div class="line">var converge1 = R.converge(R.divide, [sumOfArr, lengthArr]);</div><div class="line">var converge2 = converge1([1, 2, 3, 4, 5]);</div><div class="line">// console.log(converge2); // 3</div></pre></td></tr></table></figure>
</code></pre><h4 id="5-2-柯里化（curry、partial、partialRight、useWith、memoize、complement）"><a href="#5-2-柯里化（curry、partial、partialRight、useWith、memoize、complement）" class="headerlink" title="5.2 柯里化（curry、partial、partialRight、useWith、memoize、complement）"></a>5.2 柯里化（curry、partial、partialRight、useWith、memoize、complement）</h4><pre><code>curry：将多个参数的函数，转化成单参数的形式。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d;</div><div class="line">var curriedAddFourNumbers = R.curry(addFourNumbers);</div><div class="line">var f = curriedAddFourNumbers(1)(2)(3)(4);</div><div class="line">// console.log(f); // 10</div></pre></td></tr></table></figure>

partial：允许多参数的函数接受一个数组，指定最左边的部分参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var multiply2 = (a, b) =&gt; a * b;</div><div class="line">var double = R.partial(multiply2, [3]);</div><div class="line">// console.log(double(2)); // 6</div></pre></td></tr></table></figure>

partialRight：与partial类似，但数组指定的参数为最右边的参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var greet = (salutation, title, firstName, lastName) =&gt;</div><div class="line">  salutation + &apos;, &apos; + title + &apos; &apos; + firstName + &apos; &apos; + lastName + &apos;!&apos;;</div><div class="line">var greetMsJaneJones = R.partialRight(greet, [&apos;Ms.&apos;, &apos;Jane&apos;, &apos;Jones&apos;]);</div><div class="line">var dd = greetMsJaneJones(&apos;Hello&apos;); </div><div class="line">console.log(dd); // &apos;Hello, Ms. Jane Jones!&apos;</div></pre></td></tr></table></figure>

useWith：接受一个函数fn和一个函数数组fnList作为参数，返回fn的柯里化版本。该新函数的参数，先分别经过对应的fnList成员处理，再传入fn执行。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var decreaseOne = x =&gt; x - 1;</div><div class="line">var increaseOne = x =&gt; x + 1;</div><div class="line">var useWith1 = R.useWith(Math.pow, [decreaseOne, increaseOne])(3)(4);</div><div class="line">console.log(useWith1) // 2^5 32</div></pre></td></tr></table></figure>

memoize：返回一个函数，会缓存每一次的运行结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var productOfArr = arr =&gt; &#123;</div><div class="line">  var product = 1;</div><div class="line">  arr.forEach(i =&gt; product *= i);</div><div class="line">  return product;</div><div class="line">&#125;;</div><div class="line">var count = 0;</div><div class="line">var factorial = R.memoize(n =&gt; &#123;</div><div class="line">  count += 1;</div><div class="line">  return productOfArr(R.range(1, n + 1));</div><div class="line">&#125;);</div><div class="line">var memoize1 = factorial(5);</div><div class="line">console.log(memoize1, count); // 120, 1</div></pre></td></tr></table></figure>

complement：返回一个新函数，如果原函数返回true，该函数返回false；如果原函数返回false，该函数返回true。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var gt10 = x =&gt; x &gt; 10;</div><div class="line">var lte10 = R.complement(gt10);</div><div class="line">var complement1 = lte10(11);</div><div class="line">// console.log(complement1); // false</div></pre></td></tr></table></figure>
</code></pre><h4 id="5-3-函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）"><a href="#5-3-函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）" class="headerlink" title="5.3 函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）"></a>5.3 函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）</h4><pre><code>binary：参数函数执行时，只传入最前面两个参数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var takesThreeArgs = function (a, b, c) &#123;</div><div class="line">	return [a, b, c];</div><div class="line">&#125;;</div><div class="line">var takesTwoArgs = R.binary(takesThreeArgs);</div><div class="line">var binary1 = takesTwoArgs(1, 2, 3);</div><div class="line">// console.log(binary1); // [1, 2, undefined]</div></pre></td></tr></table></figure>

tap：将一个值传入指定函数，并返回该值。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sayX = x =&gt; console.log(&apos;x is&apos; + x);</div><div class="line">var tap1 = R.tap(sayX)(100);</div><div class="line">// console.log(tap1); // x is100 100</div></pre></td></tr></table></figure>

zipWith：将两个数组对应位置的值，一起作为参数传入某个函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var f = (x, y) =&gt; &#123;</div><div class="line">	return x + y;</div><div class="line">&#125;;</div><div class="line">var zipWith1 = R.zipWith(f)([1, 2, 3])([4, 5, 6]);</div><div class="line">// console.log(zipWith1); // [5, 7, 9]</div></pre></td></tr></table></figure>

apply：将数组转成参数序列，传入指定函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var nums = [1, 2, 3, -99, 42, 6, 7];</div><div class="line">var apply1 = R.apply(Math.max)(nums);</div><div class="line">// console.log(apply1); // 42</div></pre></td></tr></table></figure>

applySpec：返回一个模板函数，该函数会将参数传入模板内的函数执行，然后将执行结果填充到模板。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var getMetrics = R.applySpec(&#123;</div><div class="line">	sum: R.add,</div><div class="line">	nested: &#123;mul: R.multiply&#125;</div><div class="line">&#125;);</div><div class="line">var applySpec1 = getMetrics(2, 4);</div><div class="line">//console.log(applySpec1); // &#123; sum: 6, nested: &#123; mul: 8 &#125; &#125;</div></pre></td></tr></table></figure>

ascend：返回一个升序排列的比较函数，主要用于排序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var byAge = R.ascend(R.prop(&apos;age&apos;));</div><div class="line">var people = [</div><div class="line">	&#123;name: &apos;fan&apos;, age: 11&#125;,</div><div class="line">	&#123;name: &apos;yu&apos;, age: 8&#125;,</div><div class="line">	&#123;name: &apos;zhen&apos;, age: 9&#125;</div><div class="line">];</div><div class="line">var ascend1 = R.sort(byAge)(people);</div><div class="line">// console.log(ascend1); // [ &#123;name: &apos;yu&apos;, age: 8&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;, name: &apos;fan&apos;, age: 11&#125;];</div></pre></td></tr></table></figure>

ascend：返回一个升序排列的比较函数，主要用于排序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var byAge = R.descend(R.prop(&apos;age&apos;));</div><div class="line">var people = [</div><div class="line">	&#123;name: &apos;fan&apos;, age: 11&#125;,</div><div class="line">	&#123;name: &apos;yu&apos;, age: 8&#125;,</div><div class="line">	&#123;name: &apos;zhen&apos;, age: 9&#125;</div><div class="line">];</div><div class="line">var descend1 = R.sort(byAge)(people);</div><div class="line">// console.log(descend1); // [ &#123;name: &apos;fan&apos;, age: 11&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;, &#123;name: &apos;yu&apos;, age: 8&#125;];</div></pre></td></tr></table></figure>
</code></pre><h4 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h4><h5 id="6-1-数组的特性判断（contains、all、any、none）"><a href="#6-1-数组的特性判断（contains、all、any、none）" class="headerlink" title="6.1 数组的特性判断（contains、all、any、none）"></a>6.1 数组的特性判断（contains、all、any、none）</h5><pre><code>contains：如果包含某个成员，返回true。        
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var contains1 = R.contains(3)([1,2]);</div><div class="line">// console.log(contains1); // false</div></pre></td></tr></table></figure>

contains：如果包含某个成员，返回true。        
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var contains1 = R.contains(3)([1,2]);</div><div class="line">var contains2 = R.contains(&#123;name: &apos;fan&apos;&#125;)([&#123;name: &apos;fan&apos;&#125;,2]);</div><div class="line">// console.log(contains1); // false</div><div class="line">// console.log(contains2); // true</div></pre></td></tr></table></figure>

all：所有成员都满足指定函数时，返回true，否则返回false        
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var equals3 = R.equals(3);</div><div class="line">var all1 = R.all(equals3)([3, 3]);</div><div class="line">// console.log(all1); // true</div></pre></td></tr></table></figure>

any：只要有一个成员满足条件，就返回true。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var lessThan0 = R.flip(R.lt)(0);</div><div class="line">var lessThan2 = R.flip(R.lt)(2);</div><div class="line">var any1 = R.any(lessThan0)([1, 2]);</div><div class="line">// console.log(any1); // false</div><div class="line">var any2 = R.any(lessThan2)([1, 2]);</div><div class="line">// console.log(any2); // true</div></pre></td></tr></table></figure>

none：没有成员满足条件时，返回true。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var isEven = n =&gt; n % 2 === 0;</div><div class="line">var none1 = R.none(isEven)([1, 3, 5, 7, 9, 11]) // true</div><div class="line">var none2 = R.none(isEven)([1, 3, 5, 7, 8, 11]) // false</div><div class="line">console.log(none2); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="6-2-数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）"><a href="#6-2-数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）" class="headerlink" title="6.2 数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）"></a>6.2 数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）</h5><pre><code>head：返回数组的第一个成员。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var head1 = R.head([1, 2, 3]);</div><div class="line">// console.log(head1); // 1</div></pre></td></tr></table></figure>

last：返回数组的最后一个成员。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var last1 = R.last(&apos;fan&apos;);</div><div class="line">console.log(last1); // n</div></pre></td></tr></table></figure>

tail：返回第一个成员以外的所有成员组成的新数组。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var tail1 = R.tail([1, 2, 3]);</div><div class="line">// console.log(tail1);  // [2, 3]</div></pre></td></tr></table></figure>

init：返回最后一个成员以外的所有成员组成的新数组。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var init1 = R.init([1, 2, 3]);</div><div class="line">// console.log(init1);  // [1, 2]</div></pre></td></tr></table></figure>

nth：取出指定位置的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var list = [1, 2, 3, 4];</div><div class="line">var nth1 = R.nth(0)(list);</div><div class="line">// console.log(nth1); // 1</div></pre></td></tr></table></figure>

take：取出前 n 个成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var take1 = R.take(3)([1, 2, 3, 4]);</div><div class="line">// console.log(take1); // [1, 2, 3]</div></pre></td></tr></table></figure>

takeLast：取出后 n 个成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var takeLast1 = R.takeLast(3)([1, 2, 3, 4]);</div><div class="line">// console.log(takeLast1); // [2, 3, 4]</div></pre></td></tr></table></figure>

slice：从起始位置（包括）开始，到结束位置（不包括）为止，从原数组截取出一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var slice1 = R.slice(1, 3)([1, 2, 3, 4]);</div><div class="line">// console.log(slice1); // [2, 3]</div></pre></td></tr></table></figure>

remove：移除开始位置后的n个成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var remove1 = R.remove(2, 3)([1, 2, 3, 4, 5, 6, 7, 8]);</div><div class="line">// console.log(remove1); // [1, 2, 6, 7, 8]</div></pre></td></tr></table></figure>

insert：在指定位置插入给定值。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var insert1 = R.insert(2, &apos;x&apos;)([1, 2, 3]);</div><div class="line">// console.log(insert1); // [1, 2, &quot;x&quot;, 3]</div></pre></td></tr></table></figure>

insertAll：在指定位置，插入另一个数组的所有成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var insertAll1 = R.insertAll(2, [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])([1, 2, 3, 4]);</div><div class="line">// console.log(insertAll1); // [1, 2, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, 3, 4]</div></pre></td></tr></table></figure>

prepend：在数组头部插入一个成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var prepend1 = R.prepend(&apos;fee&apos;)([&apos;ss&apos;, &apos;ee&apos;]);</div><div class="line">// console.log(prepend1); // [&quot;fee&quot;, &quot;ss&quot;, &quot;ee&quot;]</div></pre></td></tr></table></figure>

append：在数组尾部追加新的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var append1 = R.append(&apos;test&apos;)([&apos;ss&apos;]);</div><div class="line">// console.log(append1); // [&quot;ss&quot;, &quot;test&quot;]</div></pre></td></tr></table></figure>

intersperse：在数组成员之间插入表示分隔的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var intersperse1 = R.intersperse(&apos;/&apos;)([&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;]);</div><div class="line">// console.log(intersperse1); // [&quot;aa&quot;, &quot;/&quot;, &quot;bb&quot;, &quot;/&quot;, &quot;cc&quot;]</div></pre></td></tr></table></figure>

join：将数组合并成一个字符串，并在成员之间插入分隔符。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var join1 = R.join(&apos;|&apos;)([1, 2, 3]);</div><div class="line">// console.log(join1); // 1|2|3</div></pre></td></tr></table></figure>
</code></pre><h5 id="6-3-数组的过滤（filter、reject、takeWhile、dropWhile、without）"><a href="#6-3-数组的过滤（filter、reject、takeWhile、dropWhile、without）" class="headerlink" title="6.3 数组的过滤（filter、reject、takeWhile、dropWhile、without）"></a>6.3 数组的过滤（filter、reject、takeWhile、dropWhile、without）</h5><pre><code>filter：过滤出符合条件的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var isEven = n =&gt; n % 2 === 0;</div><div class="line">var filter1 = R.filter(isEven)([1, 2, 3]);</div><div class="line">// console.log(filter1); // [2]</div></pre></td></tr></table></figure>

reject：过滤出所有不满足条件的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var isEven = n =&gt; n % 2 === 0;</div><div class="line">var reject1 = R.reject(isEven)([1, 2, 3]);</div><div class="line">// console.log(reject1); // [1, 3]</div></pre></td></tr></table></figure>

takeWhile：一旦满足条件，取出前面的所有成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var isNotFour = x =&gt; x !== 4;</div><div class="line">var takeWhile1 = R.takeWhile(isNotFour)([1, 2, 3, 4, 3])</div><div class="line">// console.log(takeWhile1); // [1, 2, 3]</div></pre></td></tr></table></figure>

dropWhile：一旦满足条件，取出剩余的所有成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var lteTwo = x =&gt; x &lt;= 2;</div><div class="line">var dropWhile1 = R.dropWhile(lteTwo)([1, 2, 3, 4, 3, 2, 1]);</div><div class="line">// console.log(dropWhile1); // [3, 4, 3, 2, 1]</div></pre></td></tr></table></figure>

without：返回指定值以外的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var without1 = R.without([1, 2])([1, 2, 1, 3, 4]);</div><div class="line">// console.log(without1); // [3, 4]</div></pre></td></tr></table></figure>
</code></pre><h5 id="6-4-单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）"><a href="#6-4-单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）" class="headerlink" title="6.4 单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）"></a>6.4 单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）</h5><pre><code>countBy：对每个成员执行指定函数以后，返回一个对象，表示各种执行结果分别包含多少成员。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];</div><div class="line">var countBy1 = R.countBy(Math.floor)(numbers);</div><div class="line">// console.log(countBy1); // &#123;1: 3, 2: 2, 3: 1&#125;</div></pre></td></tr></table></figure>

splitAt：在给定位置，将原数组分成两个部分。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var splitAt1 = R.splitAt(1)([1, 2, 3]);</div><div class="line">// console.log(splitAt1); // [[1],[2, 3]]</div></pre></td></tr></table></figure>

splitEvery：按照指定的个数，将原数组分成多个部分。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var splitEvery1 = R.splitEvery(3)([1, 2, 3, 4, 5, 6, 7]);</div><div class="line">// console.log(splitEvery1); // [[1, 2, 3], [4, 5, 6], [7]]</div></pre></td></tr></table></figure>

splitWhen：以第一个满足指定函数的成员为界，将数组分成两个部分。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var splitEvery1 = R.splitEvery(3)([1, 2, 3, 4, 5, 6, 7]);</div><div class="line">// console.log(splitEvery1); // [[1, 2, 3], [4, 5, 6], [7]]</div></pre></td></tr></table></figure>

aperture：每个成员与其后给定数量的成员分成一组，这些组构成一个新的数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var aperture1 = R.aperture(3)([1, 2, 3, 4, 5, 6, 7]);</div><div class="line">// console.log(aperture1); // [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]</div></pre></td></tr></table></figure>

partition：根据是否满足指定函数，将成员分区。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var partition1 = R.partition(R.contains(&apos;s&apos;))([&apos;aaa&apos;, &apos;bbb&apos;, &apos;sss&apos;]);</div><div class="line">// console.log(partition1); // [[&apos;sss&apos;], [&quot;aaa&quot;, &quot;bbb&quot;]]</div></pre></td></tr></table></figure>

indexOf：某个值在数组中第一次出现的位置。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var indexOf1 = R.indexOf(3)([1, 2, 3, 4]);</div><div class="line">// console.log(indexOf1); // 2</div></pre></td></tr></table></figure>

lastIndexOf：某个值在数组中最后一次出现的位置。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lastIndexOf1 = R.lastIndexOf(3)([-1, 3, 3, 0, 1, 2, 3, 4]);</div><div class="line">// console.log(lastIndexOf1); // 6</div></pre></td></tr></table></figure>

map：数组的每个成员依次执行某个函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var double = x =&gt; x * 2;</div><div class="line">var map1 = R.map(double)([1, 2, 3]);</div><div class="line">// console.log(map1); // [2, 4, 6]</div></pre></td></tr></table></figure>

mapIndexed：与map类似，区别是遍历函数可以额外获得两个参数：索引位置和原数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var mapIndexed = R.addIndex(R.map);</div><div class="line">var mapIndex1 = mapIndexed((val, idx) =&gt; idx + &apos;-&apos; + val, [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;, &apos;b&apos;, &apos;a&apos;, &apos;r&apos;]);</div><div class="line">// console.log(mapIndex1); // [&quot;0-f&quot;, &quot;1-o&quot;, &quot;2-o&quot;, &quot;3-b&quot;, &quot;4-a&quot;, &quot;5-r&quot;]</div></pre></td></tr></table></figure>

forEach：数组的每个成员依次执行某个函数，总是返回原数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var printXPlusFive = x =&gt; console.log(x + 5);</div><div class="line">var forEach1 = R.forEach(printXPlusFive, [1, 2, 3]); </div><div class="line">// console.log(forEach1); // [1, 2, 3]</div></pre></td></tr></table></figure>

reduce：数组成员依次执行指定函数，每一次的运算结果都会进入一个累积变量。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var mySubtract = function (a, b) &#123;</div><div class="line">	return a - b;</div><div class="line">&#125;;</div><div class="line">var reduce1 = R.reduce(mySubtract, 0)([1, 2, 3, 4]);</div><div class="line">// console.log(reduce1); // -10</div></pre></td></tr></table></figure>

reduceRight：与reduce类似，区别是数组成员从左到右执行。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reduceRight1 = R.reduceRight(R.subtract, 0)([1, 2, 3, 4]);</div><div class="line">// console.log(reduceRight1); // -2</div></pre></td></tr></table></figure>

reduceWhile：与reduce类似，区别是有一个判断函数，一旦数组成员不符合条件，就停止累积。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var isOdd = (acc, x) =&gt; x % 2 === 1;</div><div class="line">var ys = [2, 4, 6];</div><div class="line">var reduceWhile1 = R.reduceWhile(isOdd, R.add, 111)(ys);</div><div class="line">// console.log(reduceWhile1); // 111</div></pre></td></tr></table></figure>

sort：按照给定函数，对数组进行排序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var diff = function (a, b) &#123; return a -b; &#125;;</div><div class="line">var sort1 = R.sort(diff)([4, 2, 7, 5]);</div><div class="line">// console.log(sort1); // [2, 4, 5, 7]</div></pre></td></tr></table></figure>

sortWith：按照给定的一组函数，进行多重排序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var alice = &#123;</div><div class="line">	name: &apos;alice&apos;,</div><div class="line">	age: 40</div><div class="line">&#125;;</div><div class="line">var bob = &#123;</div><div class="line">	name: &apos;bob&apos;,</div><div class="line">	age: 30</div><div class="line">&#125;;</div><div class="line">var clara = &#123;</div><div class="line">	name: &apos;clara&apos;,</div><div class="line">	age: 40</div><div class="line">&#125;;</div><div class="line">var people = [clara, bob, alice];</div><div class="line">var ageNameSort = R.sortWith([</div><div class="line">		// R.descend(R.prop(&apos;age&apos;)),</div><div class="line">		R.ascend(R.prop(&apos;name&apos;))</div><div class="line">	]);</div><div class="line">var sortWith1 = ageNameSort(people);</div><div class="line">console.log(sortWith1); // [&#123;name: &quot;alice&quot;, age: 40&#125;, &#123;name: &quot;bob&quot;, age: 30&#125;, &#123;name: &quot;clara&quot;, age: 40&#125;]</div></pre></td></tr></table></figure>

adjust：对指定位置的成员执行给定的函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var adjust1 = R.adjust(R.add(10) ,1)([1, 2, 3]);</div><div class="line">// console.log(adjust1); // [1, 12, 3]</div></pre></td></tr></table></figure>

ap：数组成员分别执行一组函数，将结果合成为一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var ap1 = R.ap([R.multiply(2), R.add(3)])([1, 2, 3]);</div><div class="line">// console.log(ap1); // [2, 4, 6, 4, 5, 6]</div></pre></td></tr></table></figure>

flatten：将嵌套数组铺平。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var flatten1 = R.flatten([1, 2, [ 3, 4, 5, [6]]]);</div><div class="line">// console.log(flatten1); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure>

groupWith：将数组成员依次按照指定条件两两比较，并按照结果将所有成员放入子数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var groupWith1 = R.groupWith(R.equals)([0, 1, 1, 2, 3, 5, 8, 13, 21]);</div><div class="line">// console.log(groupWith1); // [[0], [1, 1], [2], [3], [5], [8], [13], [21]]</div></pre></td></tr></table></figure>
</code></pre><h5 id="6-5-双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）"><a href="#6-5-双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）" class="headerlink" title="6.5 双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）"></a>6.5 双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）</h5><pre><code>concat：将两个数组合并成一个数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var concat1 = R.concat([1, 2])([&apos;a&apos;, &apos;b&apos;]);</div><div class="line">console.log(concat1); // [1, 2, &quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure>

zip：将两个数组指定位置的成员放在一起，生成一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var zip1 = R.zip([1, 2, 3])([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</div><div class="line">// console.log(zip1); // [[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]]</div></pre></td></tr></table></figure>

zipObj：将两个数组指定位置的成员分别作为键名和键值，生成一个新对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var zip1 = R.zip([1, 2, 3])([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</div><div class="line">// console.log(zip1); // [[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]]</div></pre></td></tr></table></figure>

xprod：将两个数组的成员两两混合，生成一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var xprod1 = R.xprod([1, 2])([&apos;a&apos;, &apos;b&apos;]);</div><div class="line">// console.log(xprod1); // [[1, &quot;a&quot;], [1, &quot;b&quot;], [2, &quot;a&quot;], [2, &quot;b&quot;]]</div></pre></td></tr></table></figure>

intersection：返回两个数组相同的成员组成的新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var intersection1 = R.intersection([1, 2, 3, 4])([4, 3, 8]);</div><div class="line">// console.log(intersection1); // [4, 3]</div></pre></td></tr></table></figure>

intersectionWith：返回经过某种运算，有相同结果的两个成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var buffaloSpringfield = [</div><div class="line">  &#123;id: 824, name: &apos;Richie Furay&apos;&#125;,</div><div class="line">  &#123;id: 177, name: &apos;Neil Young&apos;&#125;</div><div class="line">];</div><div class="line">var csny = [</div><div class="line">  &#123;id: 204, name: &apos;David Crosby&apos;&#125;,</div><div class="line">  &#123;id: 177, name: &apos;Neil Young&apos;&#125;</div><div class="line">];</div><div class="line">var intersectionWith1 = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield)(csny);</div><div class="line">// console.log(intersectionWith1); // [&#123;id: 177, name: &quot;Neil Young&quot;&#125;]</div></pre></td></tr></table></figure>

difference：返回第一个数组不包含在第二个数组里面的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var difference1 = R.difference([1, 2, 3, 4])([7, 6, 5, 4, 3]);</div><div class="line">// console.log(difference1); // [1, 2]</div></pre></td></tr></table></figure>

differenceWith：返回执行指定函数后，第一个数组里面不符合条件的所有成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var cmp = (x, y) =&gt; x.a === y.a;</div><div class="line">var l1 = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];</div><div class="line">var l2 = [&#123;a: 3&#125;, &#123;a: 4&#125;];</div><div class="line">var differenceWith1 = R.differenceWith(cmp, l1)(l2);</div><div class="line">console.log(differenceWith1); // [&#123;a: 1&#125;, &#123;a: 2&#125;]</div></pre></td></tr></table></figure>

symmetricDifference：返回两个数组的非共有成员所组成的一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var symmetricDifference1 = R.symmetricDifference([1, 2, 3, 4])([7, 6, 5, 4, 3]);</div><div class="line">// console.log(symmetricDifference1); // [1, 2, 7, 6, 5]</div></pre></td></tr></table></figure>

symmetricDifferenceWith：根据指定条件，返回两个数组所有运算结果不相等的成员所组成的新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var eqA = R.eqBy(R.prop(&apos;a&apos;));</div><div class="line">var l1 = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;, &#123;a: 4&#125;];</div><div class="line">var l2 = [&#123;a: 3&#125;, &#123;a: 4&#125;, &#123;a: 5&#125;, &#123;a: 6&#125;];</div><div class="line">var symmetricDifferenceWith1 = R.symmetricDifferenceWith(eqA, l1, l2);</div><div class="line">// console.log(symmetricDifferenceWith1); // [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 5&#125;, &#123;a: 6&#125;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="6-6-复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）"><a href="#6-6-复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）" class="headerlink" title="6.6 复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）"></a>6.6 复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）</h5><pre><code>find：返回符合指定条件的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xs = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];</div><div class="line">var find1 = R.find(R.propEq(&apos;a&apos;, 2))(xs);</div><div class="line">// console.log(find1); // [&#123;a: 2&#125;]</div></pre></td></tr></table></figure>

findIndex：返回符合指定条件的成员的位置。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xs = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];</div><div class="line">var findIndex1 = R.findIndex(R.propEq(&apos;a&apos;, 2))(xs);</div><div class="line">// console.log(findIndex1); // 1</div></pre></td></tr></table></figure>

findLast：返回最后一个符合指定条件的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xs = [&#123;a: 1, b: 0&#125;, &#123;a:1, b: 1&#125;];</div><div class="line">var findLast1 = R.findLast(R.propEq(&apos;a&apos;, 1))(xs);</div><div class="line">// console.log(findLast1); // &#123;a: 1, b: 1&#125;</div></pre></td></tr></table></figure>

findLastIndex：返回最后一个符合指定条件的成员的位置。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xs = [&#123;a: 1, b: 0&#125;, &#123;a:1, b: 1&#125;];</div><div class="line">var findLastIndex1 = R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs);</div><div class="line">// console.log(findLastIndex1); // 1</div></pre></td></tr></table></figure>

pluck：取出数组成员的某个属性，组成一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var pluck1 = R.pluck(&apos;a&apos;)([&#123;a: 1&#125;, &#123;a: 2&#125;]);</div><div class="line">// console.log(pluck1); // [1, 2]</div></pre></td></tr></table></figure>

project：取出数组成员的多个属性，组成一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var abby = &#123;name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2&#125;;</div><div class="line">var fred = &#123;name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7&#125;;</div><div class="line">var kids = [abby, fred];</div><div class="line">var project1 = R.project([&apos;name&apos;, &apos;grade&apos;])(kids);</div><div class="line">// console.log(project1); // [&#123;name: &apos;Abby&apos;, grade: 2&#125;, &#123;name: &apos;Fred&apos;, grade: 7&#125;]</div></pre></td></tr></table></figure>

transpose：将每个成员相同位置的值，组成一个新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var transpose1 = R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]);</div><div class="line">// console.log(transpose1); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</div></pre></td></tr></table></figure>

mergeAll：将数组的成员合并成一个对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var mergeAll1 = R.mergeAll([&#123;foo: 1&#125;, &#123;bar: 2&#125;, &#123;baz: 3&#125;]);</div><div class="line">// console.log(mergeAll1); // &#123;foo:1,bar:2,baz:3&#125;</div></pre></td></tr></table></figure>

fromPairs：将嵌套数组转为一个对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var fromPairs1 = R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]])</div><div class="line">// console.log(fromPairs1); // &#123;a: 1, b: 2, c: 3&#125;</div></pre></td></tr></table></figure>

groupBy：将数组成员按照指定条件分组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var byGrade = R.groupBy(function (student) &#123;</div><div class="line">	let score = student.score;</div><div class="line">	return score &lt; 60 ? &apos;F&apos; :</div><div class="line">			score &lt; 70 ? &apos;D&apos; :</div><div class="line">			score &lt; 80 ? &apos;C&apos; :</div><div class="line">			score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;</div><div class="line">&#125;);</div><div class="line">var students = [&#123;name: &apos;Abby&apos;, score: 84&#125;,</div><div class="line">				&#123;name: &apos;Eddy&apos;, score: 58&#125;,</div><div class="line">				&#123;name: &apos;Jack&apos;, score: 90&#125;];</div><div class="line">var groupBy1 = byGrade(students);</div><div class="line">// console.log(groupBy1); </div><div class="line">// &#123;</div><div class="line">//   &apos;A&apos;: [&#123;name: &apos;Jack&apos;, score: 90&#125;],</div><div class="line">//   &apos;B&apos;: [&#123;name: &apos;Abby&apos;, score: 84&#125;]</div><div class="line">//   &apos;F&apos;: [&#123;name: &apos;Eddy&apos;, score: 58&#125;]</div><div class="line">// &#125;</div></pre></td></tr></table></figure>

sortBy：根据成员的某个属性排序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sortByFirstItem = R.sortBy(R.prop(0));</div><div class="line">var sortBy1 = sortByFirstItem([[-1, 1], [-2, 2], [-3, 3]])</div><div class="line">// console.log(sortBy1); // // [[-3, 3], [-2, 2], [-1, 1]]</div></pre></td></tr></table></figure>
</code></pre><h4 id="七、对象"><a href="#七、对象" class="headerlink" title="七、对象"></a>七、对象</h4><h5 id="7-1-对象的特征判断（has、hasIn、propEq、whereEq、where）"><a href="#7-1-对象的特征判断（has、hasIn、propEq、whereEq、where）" class="headerlink" title="7.1 对象的特征判断（has、hasIn、propEq、whereEq、where）"></a>7.1 对象的特征判断（has、hasIn、propEq、whereEq、where）</h5><pre><code>has: 返回一个布尔值，表示对象自身是否具有该属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var hasName = R.has(&apos;name&apos;);</div><div class="line">var has1 = hasName(&#123;name: &apos;fan&apos;&#125;);</div><div class="line">// console.log(has1); // true</div></pre></td></tr></table></figure>

hasIn：返回一个布尔值，表示对象自身或原型链上是否具有某个属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Rectangle (width, height) &#123;</div><div class="line">	this.width = width;</div><div class="line">	this.height = height;</div><div class="line">&#125;</div><div class="line">Rectangle.prototype.area = function () &#123;</div><div class="line">	return this.width * this.height;</div><div class="line">&#125;;</div><div class="line">var square = new Rectangle(2, 2);</div><div class="line">var hasIn1 = R.hasIn(&apos;width&apos;)(square); // 自身的</div><div class="line">var hasIn2 = R.hasIn(&apos;area&apos;)(square); // 原型的</div><div class="line">// console.log(hasIn1, hasIn2); // true true</div></pre></td></tr></table></figure>

propEq：如果单个属性等于给定值，返回true。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var abby = &#123;name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;&#125;;</div><div class="line">var fred = &#123;name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;&#125;;</div><div class="line">var rusty = &#123;name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;&#125;;</div><div class="line">var alois = &#123;name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;&#125;;</div><div class="line">var kids = [abby, fred, rusty, alois];</div><div class="line">var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;);</div><div class="line">var propEq1 = R.filter(hasBrownHair)(kids) // [fred, rusty]</div><div class="line">// console.log(propEq1); // // [fred, rusty]</div></pre></td></tr></table></figure>

whereEq：如果多个属性等于给定值，返回true。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var pred = R.whereEq(&#123;a: 1, b: 2&#125;);</div><div class="line">var whereEq1 = pred(&#123;a: 1, b: 2&#125;);</div><div class="line">// console.log(whereEq1); // true</div></pre></td></tr></table></figure>

where：如果各个属性都符合指定条件，返回true。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var pred = R.where(&#123;</div><div class="line">	a: R.equals(&apos;foo&apos;),</div><div class="line">	b: R.equals(&apos;bzr&apos;),</div><div class="line">	x: R.gt(10),</div><div class="line">	y: R.lt(20)</div><div class="line">&#125;);</div><div class="line">var where1 = pred(&#123;a: &apos;foo&apos;, b: &apos;bzr&apos;, x: 12, y: 15&#125;);</div><div class="line">console.log(where1); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="7-2-对象的过滤（omit、filter、reject）"><a href="#7-2-对象的过滤（omit、filter、reject）" class="headerlink" title="7.2 对象的过滤（omit、filter、reject）"></a>7.2 对象的过滤（omit、filter、reject）</h5><pre><code>omit：过滤指定属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var omit1 = R.omit([&apos;a&apos;, &apos;b&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</div><div class="line">// console.log(omit1); // &#123;b: 2, c: 3&#125;</div></pre></td></tr></table></figure>

filter：返回所有满足条件的属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var isEven = n =&gt; n % 2 === 0;</div><div class="line">var filter1 = R.filter(isEven)(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</div><div class="line">// console.log(filter1); // &#123;b: 2, d: 4&#125;</div></pre></td></tr></table></figure>

reject：返回所有不满足条件的属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var isOdd = n =&gt; n % 2 === 1;</div><div class="line">var reject1 = R.reject(isOdd)(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</div><div class="line">// console.log(reject1); // &#123;b: 2, d: 4&#125;</div></pre></td></tr></table></figure>

reject：返回所有不满足条件的属性。
</code></pre><h5 id="7-3-对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）"><a href="#7-3-对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）" class="headerlink" title="7.3 对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）"></a>7.3 对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）</h5><pre><code>dissoc：过滤指定属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dissoc1 = R.dissoc(&apos;b&apos;)(&#123;a: 1, b: 2, c: 3&#125;);</div><div class="line">// console.log(dissoc1); // &#123;a: 1, c: 3&#125;</div></pre></td></tr></table></figure>

assoc：添加或改写某个属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var assoc1 = R.assoc(&apos;c&apos;, 3)(&#123;a: 1, b: 2&#125;);</div><div class="line">// console.log(assoc1); // &#123;a: 1, b: 2, c: 3&#125;</div></pre></td></tr></table></figure>

partition：根据属性值是否满足给定条件，将属性分区。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var partition1 = R.partition(R.contains(&apos;s&apos;))(&#123;a: &apos;ssss&apos;, b: &apos;ttt&apos;, foo: &apos;bars&apos;&#125;);</div><div class="line">// console.log(partition1); // [ &#123; a: &apos;sss&apos;, foo: &apos;bars&apos; &#125;, &#123; b: &apos;ttt&apos; &#125;  ]</div></pre></td></tr></table></figure>

pick：返回指定属性组成的新对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var pick1 = R.pick([&apos;a&apos;, &apos;d&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</div><div class="line">// console.log(pick1); // &#123;a: 1, d: 4&#125;</div></pre></td></tr></table></figure>

pickAll：与pick类似，但会包括不存在的属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var pickAll1 = R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;f&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</div><div class="line">// console.log(pickAll1); // &#123;a: 1, d: 4, f: undefined&#125;</div></pre></td></tr></table></figure>

pickBy：返回符合条件的属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var isUpperCase = (val, key) =&gt; key.toUpperCase() === key;</div><div class="line">var pickBy1 = R.pickBy(isUpperCase)(&#123;a: 1, b: 2, A: 3, B: 4&#125;);</div><div class="line">// console.log(pickBy1); // &#123;A: 3, B: 4&#125;</div></pre></td></tr></table></figure>

keys：返回对象自身属性的属性名组成的新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var keys1 = R.keys(&#123;a: 1, b: 2&#125;);</div><div class="line">// console.log(keys1); // [&apos;a&apos;, &apos;b&apos;]</div></pre></td></tr></table></figure>

keysIn：返回对象自身的和继承的属性的属性名组成的新数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var F = function () &#123;this.x = &apos;X&apos;&#125;;</div><div class="line">F.prototype.y = &apos;Y&apos;;</div><div class="line">var f = new F();</div><div class="line">var keysIn1 = R.keysIn(f);</div><div class="line">// console.log(keysIn1); // [&apos;x&apos;, &apos;y&apos;]</div></pre></td></tr></table></figure>

values：返回对象自身的属性的属性值组成的数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var values1 = R.values(&#123;a: 1, b: 2, c: 3&#125;);</div><div class="line">// console.log(values1); // [1, 2, 3]</div></pre></td></tr></table></figure>

valuesIn：返回对象自身的和继承的属性的属性值组成的数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var F = function() &#123; this.x = &apos;X&apos;; &#125;;</div><div class="line">F.prototype.y = &apos;Y&apos;;</div><div class="line">var f = new F();</div><div class="line">var valuesIn1 = R.valuesIn(f);</div><div class="line">// console.log(valuesIn1); // [&quot;X&quot;, &quot;Y&quot;]</div></pre></td></tr></table></figure>

invertObj：将属性值和属性名互换。如果多个属性的属性值相同，只返回最后一个属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var raceResultsByFirstName = &#123;</div><div class="line">  first: &apos;alice&apos;,</div><div class="line">  second: &apos;jake&apos;,</div><div class="line">  third: &apos;alice&apos;,</div><div class="line">&#125;;</div><div class="line">var invertObj1 = R.invertObj(raceResultsByFirstName);</div><div class="line">// console.log(invertObj1); // &#123;alice: &quot;third&quot;, jake: &quot;second&quot;&#125;</div></pre></td></tr></table></figure>

invert：将属性值和属性名互换，每个属性值对应一个数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var raceResultsByFirstName = &#123;</div><div class="line">  first: &apos;alice&apos;,</div><div class="line">  second: &apos;jake&apos;,</div><div class="line">  third: &apos;alice&apos;,</div><div class="line">&#125;;</div><div class="line">var invert1 = R.invert(raceResultsByFirstName);</div><div class="line">console.log(invert1); // // &#123; &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] &#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="7-4-对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）"><a href="#7-4-对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）" class="headerlink" title="7.4 对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）"></a>7.4 对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）</h5><pre><code>prop：返回对象的指定属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var prop1 = R.prop(&apos;x&apos;)(&#123;x: 100&#125;);</div><div class="line">// console.log(prop1); // 100</div></pre></td></tr></table></figure>

map：对象的所有属性依次执行某个函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var double = x =&gt; x * 2;</div><div class="line">var map1 = R.map(double)(&#123;x: 1, y: 2, z: 3&#125;);</div><div class="line">// console.log(map1); // &#123;x: 2, y: 4, z: 6&#125;</div></pre></td></tr></table></figure>

mapObjIndexed：与map类似，但是会额外传入属性名和整个对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var values = &#123;x: 1, y: 2, z: 3&#125;;</div><div class="line">var prependkeyAndDouble = (num, key, obj) =&gt; key + (num * 2);</div><div class="line">var mapObjIndexed1 = R.mapObjIndexed(prependkeyAndDouble)(values);</div><div class="line">// console.log(mapObjIndexed1); // &#123;x: &quot;x2&quot;, y: &quot;y4&quot;, z: &quot;z6&quot;&#125;</div></pre></td></tr></table></figure>

forEachObjIndexed：每个属性依次执行给定函数，给定函数的参数分别是属性值和属性名，返回原对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var printkeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value);</div><div class="line">var forEachObjIndexed1 = R.forEachObjIndexed(printkeyConcatValue)(&#123;x: 1,y: 2&#125;);</div><div class="line">// console.log(forEachObjIndexed1); // &#123;x: 1,y: 2&#125;</div></pre></td></tr></table></figure>

merge：合并两个对象，如果有同名属性，后面的值会覆盖掉前面的值。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var merge1 = R.merge(&#123;&apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10&#125;)(&#123;&apos;age&apos;: 40&#125;);</div><div class="line">// console.log(merge1); // &#123;name: &quot;fred&quot;, age: 40&#125;</div></pre></td></tr></table></figure>

mergeWith：合并两个对象，如果有同名属性，会使用指定的函数处理。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var mergeWith1 = R.mergeWith(</div><div class="line">		R.concat,</div><div class="line">		&#123;a: true, values: [10, 20]&#125;,</div><div class="line">		&#123;b: true, values: [15, 35]&#125;</div><div class="line">	);</div><div class="line">// console.log(mergeWith1); // &#123; a: true, b: true, values: [10, 20, 15, 35] &#125;</div></pre></td></tr></table></figure>

eqProps：比较两个对象的指定属性是否相等。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</div><div class="line">var o2 = &#123;a: 10, b: 20, c: 3, d: 40&#125;;</div><div class="line">var eqProps1 = R.eqProps(&apos;c&apos;, o1)(o2);</div><div class="line">// console.log(eqProps1); //true</div></pre></td></tr></table></figure>

evolve：对象的属性分别经过一组函数的处理，返回一个新对象。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var tomato = &#123;</div><div class="line">	firstName: &apos;Tomato&apos;,</div><div class="line">	data: &#123;elapsed: 100, remaining: 1400&#125;,</div><div class="line">	id: 123</div><div class="line">&#125;;</div><div class="line">var transformations = &#123;</div><div class="line">	firstName: R.trim,</div><div class="line">	lastName: R.trim,</div><div class="line">	data: &#123;elapsed: R.add(1), remaining: R.add(-1)&#125;</div><div class="line">&#125;;</div><div class="line">var evolve1 = R.evolve(transformations)(tomato);</div><div class="line">// console.log(evolve1);</div><div class="line">// &#123;</div><div class="line">//   firstName: &apos;Tomato&apos;,</div><div class="line">//   data: &#123;elapsed: 101, remaining: 1399&#125;,</div><div class="line">//   id: 123</div><div class="line">// &#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="7-5-复合对象（path、pathEq、assocPath）"><a href="#7-5-复合对象（path、pathEq、assocPath）" class="headerlink" title="7.5 复合对象（path、pathEq、assocPath）"></a>7.5 复合对象（path、pathEq、assocPath）</h5><pre><code>path：取出数组中指定路径的值。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var path1 = R.path([&apos;a&apos;, &apos;b&apos;], &#123;a: &#123;b: 2&#125;&#125;);</div><div class="line">// console.log(path1); // 2</div></pre></td></tr></table></figure>

pathEq：返回指定路径的值符合条件的成员。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var user1 = &#123;address: &#123;zipCode: 11111&#125;&#125;;</div><div class="line">var user2 = &#123;address: &#123;zipCode: 22222&#125;&#125;;</div><div class="line">var user3 = &#123;address: &#123;zipCode: 33333&#125;&#125;;</div><div class="line">var users = [user1, user2, user3];</div><div class="line">var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 11111);</div><div class="line">var pathEq1 = R.filter(isFamous)(users);</div><div class="line">// console.log(pathEq1); // [user1]</div></pre></td></tr></table></figure>

assocPath：添加或改写指定路径的属性的值。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var assocPath1 = R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42)(&#123;a: &#123;b: &#123;c: 0&#125;&#125;&#125;);</div><div class="line">// console.log(assocPath1); // &#123;a: &#123;b: &#123;c: 42&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br><a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="external">阮老师–Ramda 函数库参考教程</a><br><a href="http://ramda.cn/" target="_blank" rel="external">Ramda 中文</a>        </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanerge/Ramda-study.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;学习源代码&lt;/a&gt;&lt;br&gt;经过4个晚上的学习，了解了ramda库120多个api的用法，下一步继续深入学习
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象编程-非构造函数的继承</title>
    <link href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-2/"/>
    <id>https://fanerge.github.io/2017/08/13/js面向对象编程-2/</id>
    <published>2017-08-13T08:08:41.000Z</published>
    <updated>2017-08-13T09:29:49.351Z</updated>
    
    <content type="html"><![CDATA[<p>重新复习 – js面向对象编程知识，本文介绍-对象之间的非构造函数实现”继承”。</p>
<h4 id="先来两个对象（父类和子类）"><a href="#先来两个对象（父类和子类）" class="headerlink" title="先来两个对象（父类和子类）"></a>先来两个对象（父类和子类）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let Chinese = &#123;</div><div class="line">	nation: &apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let Doctor = &#123;</div><div class="line">	career: &apos;医生&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h4 id="一、object-方法"><a href="#一、object-方法" class="headerlink" title="一、object()方法"></a>一、object()方法</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let Chinese = &#123;</div><div class="line">	nation: &apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function object (o) &#123;</div><div class="line">	function F () &#123;&#125;;</div><div class="line">	F.prototype = o;</div><div class="line">	return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">let Doctor = object(Chinese);</div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line">console.log(Doctor.nation) // 中国</div></pre></td></tr></table></figure>

这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。
</code></pre><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code>把父对象的属性，全部拷贝给子对象，也能实现继承。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let Chinese = &#123;</div><div class="line">	nation: &apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function extendCopy (p) &#123;</div><div class="line">	let c = &#123;&#125;;</div><div class="line">	for (let i in p) &#123;</div><div class="line">		c[i] = p[i];</div><div class="line">	&#125;</div><div class="line">	return c;</div><div class="line">&#125;</div><div class="line">let Doctor = extendCopy(Chinese);</div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line">console.log(Doctor.nation) // 中国</div></pre></td></tr></table></figure>

存在问题：只拷贝基本类型，对于引用类型拷贝内存地址，存在父对象别篡改的可能。
</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><pre><code>所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let Chinese = &#123;</div><div class="line">	nation: &apos;中国&apos;,</div><div class="line">	cities: [&apos;成都&apos;, &apos;北京&apos;]</div><div class="line">&#125;;</div><div class="line">function deepCopy(p, c) &#123;</div><div class="line">	var c = c || &#123;&#125;;</div><div class="line">	for (let i in p) &#123;</div><div class="line">		if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">			c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">			deepCopy(p[i], c[i]);</div><div class="line">		&#125; else &#123;</div><div class="line">			c[i] = p[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return c;</div><div class="line">&#125; </div><div class="line">let Doctor = deepCopy(Chinese);</div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line">console.log(Doctor.cities)  // [&quot;成都&quot;, &quot;北京&quot;]</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考：<br>    <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">阮老师-Javascript面向对象编程（三）：非构造函数的继承</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新复习 – js面向对象编程知识，本文介绍-对象之间的非构造函数实现”继承”。&lt;/p&gt;
&lt;h4 id=&quot;先来两个对象（父类和子类）&quot;&gt;&lt;a href=&quot;#先来两个对象（父类和子类）&quot; class=&quot;headerlink&quot; title=&quot;先来两个对象（父类和子类）&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="面向对象编程" scheme="https://fanerge.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="面向对象编程" scheme="https://fanerge.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象编程-构造函数的继承</title>
    <link href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-1/"/>
    <id>https://fanerge.github.io/2017/08/13/js面向对象编程-1/</id>
    <published>2017-08-13T06:52:40.000Z</published>
    <updated>2017-08-13T09:29:45.783Z</updated>
    
    <content type="html"><![CDATA[<p>重新复习 – js面向对象编程知识，本文介绍-对象之间的”继承”的五种方法。</p>
<h4 id="先来两个构造函数（父类和子类）"><a href="#先来两个构造函数（父类和子类）" class="headerlink" title="先来两个构造函数（父类和子类）"></a>先来两个构造函数（父类和子类）</h4><pre><code>现有一个&quot;动物&quot;对象的构造函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Animal () &#123;</div><div class="line">	this.species = &quot;动物&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

再来一只&quot;猫&quot;对象的构造函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat (name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="一、构造函数绑定"><a href="#一、构造函数绑定" class="headerlink" title="一、构造函数绑定"></a>一、构造函数绑定</h4><pre><code>使用call或apply方法，将父对象的构造函数绑定在子对象上。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Cat (name, color) &#123;</div><div class="line">	Animal.call(this, arguments); // 构造函数绑定-继承</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</div><div class="line">console.log(cat1); // &#123;species: &quot;动物&quot;, name: &quot;小白&quot;, color: &quot;红色&quot;&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="二、prototype模式"><a href="#二、prototype模式" class="headerlink" title="二、prototype模式"></a>二、prototype模式</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Animal () &#123;</div><div class="line">	this.species = &quot;动物&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Cat (name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line">Cat.prototype = new Animal(); // prototype模式-继承</div><div class="line">Cat.prototype.constructor = Cat; // 重新将constructor指向Cat</div><div class="line"></div><div class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</div><div class="line">console.log(cat1.species); // 动物</div></pre></td></tr></table></figure>
</code></pre><h4 id="三、直接继承prototype"><a href="#三、直接继承prototype" class="headerlink" title="三、直接继承prototype"></a>三、直接继承prototype</h4><pre><code>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Animal () &#123; &#125;</div><div class="line">Animal.prototype.species = &apos;动物&apos;;</div><div class="line"></div><div class="line">function Cat (name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">Cat.prototype = Animal.prototype; // 直接继承prototype</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line"></div><div class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</div><div class="line">console.log(cat1.species); // 动物</div></pre></td></tr></table></figure>

与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。
console.log(Animal.prototype.constructor); // Cat
</code></pre><h4 id="四、利用空对象作为中介"><a href="#四、利用空对象作为中介" class="headerlink" title="四、利用空对象作为中介"></a>四、利用空对象作为中介</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Animal () &#123; &#125;</div><div class="line">Animal.prototype.species = &apos;动物&apos;;</div><div class="line"></div><div class="line">function Cat (name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 空对象作为中介</div><div class="line">let F = function () &#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line"></div><div class="line">Cat.prototype = new F(); </div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line"></div><div class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</div><div class="line">console.log(cat1.species); // 动物</div></pre></td></tr></table></figure>

还可以单独封装成方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let extend = function (child, parent) &#123;</div><div class="line">	let F = function () &#123;&#125;;</div><div class="line">	F.prototype = parent.prototype;</div><div class="line">	child.prototype = new F();</div><div class="line">	child.prototype.constructor = child;</div><div class="line">&#125;;</div><div class="line">extend(Cat, Animal);</div><div class="line">let cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</div><div class="line">console.log(cat1.species); // 动物</div></pre></td></tr></table></figure>
</code></pre><h4 id="五、拷贝继承"><a href="#五、拷贝继承" class="headerlink" title="五、拷贝继承"></a>五、拷贝继承</h4><pre><code>简单说，如果把父对象的所有属性和方法，拷贝进子对象。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Animal () &#123; &#125;</div><div class="line">Animal.prototype.species = &apos;动物&apos;;</div><div class="line"></div><div class="line">function Cat (name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 拷贝继承</div><div class="line">function extend2 (child, parent) &#123;</div><div class="line">	let p = parent.prototype;</div><div class="line">	let c = child.prototype;</div><div class="line">	for (let i in p) &#123;</div><div class="line">		c[i] = p[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">extend2(Cat, Animal);</div><div class="line">let cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</div><div class="line">console.log(cat1.species) // 动物</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考：<br>    <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">阮老师-Javascript面向对象编程（二）：构造函数的继承</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新复习 – js面向对象编程知识，本文介绍-对象之间的”继承”的五种方法。&lt;/p&gt;
&lt;h4 id=&quot;先来两个构造函数（父类和子类）&quot;&gt;&lt;a href=&quot;#先来两个构造函数（父类和子类）&quot; class=&quot;headerlink&quot; title=&quot;先来两个构造函数（父类和子类）&quot;
    
    </summary>
    
      <category term="面向对象编程" scheme="https://fanerge.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="面向对象编程" scheme="https://fanerge.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象编程-&quot;封装&quot;（Encapsulation）</title>
    <link href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://fanerge.github.io/2017/08/13/js面向对象编程/</id>
    <published>2017-08-13T02:44:00.000Z</published>
    <updated>2017-08-13T09:26:43.360Z</updated>
    
    <content type="html"><![CDATA[<p>重新复习 – js面向对象编程知识</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Cat (name, color) &#123;</div><div class="line">	this.name = name; // 使用动态作用域this</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line">Cat.prototype.type = &apos;猫科动物&apos;;</div><div class="line">Cat.prototype.eat = function () &#123;</div><div class="line">	console.log(&apos;吃老鼠&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let cat1 =new Cat(&apos;大毛&apos;, &apos;黄色&apos;);</div><div class="line">let cat2 =new Cat(&apos;小毛&apos;, &apos;黑色&apos;);</div></pre></td></tr></table></figure>
</code></pre><h4 id="constructor-—-每个实例都有一个constructor属性，指向它们的构造函数"><a href="#constructor-—-每个实例都有一个constructor属性，指向它们的构造函数" class="headerlink" title="constructor — 每个实例都有一个constructor属性，指向它们的构造函数"></a>constructor — 每个实例都有一个constructor属性，指向它们的构造函数</h4><pre><code>// console.log(cat1.constructor == Cat) true
</code></pre><h4 id="instanceof-—-验证原型对象与实例之间的关系"><a href="#instanceof-—-验证原型对象与实例之间的关系" class="headerlink" title="instanceof — 验证原型对象与实例之间的关系"></a>instanceof — 验证原型对象与实例之间的关系</h4><pre><code>// console.log(cat1 instanceof Cat) true
// console.log(cat1.type); 猫科动物
// console.log(cat1.type === cat2.type) true 都从原型中获得
// cat1.eat() 吃老鼠
</code></pre><h5 id="isPrototypeOf-—-某个proptotype对象和某个实例之间的关系。"><a href="#isPrototypeOf-—-某个proptotype对象和某个实例之间的关系。" class="headerlink" title="isPrototypeOf() — 某个proptotype对象和某个实例之间的关系。"></a>isPrototypeOf() — 某个proptotype对象和某个实例之间的关系。</h5><pre><code>// console.log(Cat.prototype.isPrototypeOf(cat1)) true
</code></pre><h5 id="hasOwnProperty-—-每个实例对象都有一个hasOwnProperty-方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。"><a href="#hasOwnProperty-—-每个实例对象都有一个hasOwnProperty-方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。" class="headerlink" title="hasOwnProperty() — 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。"></a>hasOwnProperty() — 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</h5><pre><code>// console.log(cat1.hasOwnProperty(&apos;name&apos;)); true
// console.log(cat1.hasOwnProperty(&apos;eat&apos;)); false
</code></pre><h5 id="in运算符-—-某个实例是否含有某个属性，不管是不是本地属性"><a href="#in运算符-—-某个实例是否含有某个属性，不管是不是本地属性" class="headerlink" title="in运算符 — 某个实例是否含有某个属性，不管是不是本地属性"></a>in运算符 — 某个实例是否含有某个属性，不管是不是本地属性</h5><pre><code>// console.log(&apos;name&apos; in cat1); true
// console.log(&apos;eat&apos; in cat1); true
</code></pre><h4 id="总结对象属性的遍历"><a href="#总结对象属性的遍历" class="headerlink" title="总结对象属性的遍历"></a>总结对象属性的遍历</h4><pre><code>1.    in --- 遍历**可枚举的自身属性和继承属性**
2.    Object.getOwnPropertyNames() --- 遍历所有的自身属性
3.    Object.keys(obj) --- 遍历**可枚举的自身属性**，返回一个属性数组
</code></pre><blockquote>
<p>   参考：<br>    <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">阮老师-Javascript面向对象编程（一）：封装</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新复习 – js面向对象编程知识&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
    
    </summary>
    
      <category term="面向对象编程" scheme="https://fanerge.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="面向对象编程" scheme="https://fanerge.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>js函数式编程-读书笔记</title>
    <link href="https://fanerge.github.io/2017/08/11/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7/"/>
    <id>https://fanerge.github.io/2017/08/11/js函数式编程-读书笔记-7/</id>
    <published>2017-08-11T12:59:55.000Z</published>
    <updated>2017-08-13T03:08:05.210Z</updated>
    
    <content type="html"><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="基于流的编程-or-无类编程"><a href="#基于流的编程-or-无类编程" class="headerlink" title="基于流的编程 or 无类编程"></a>基于流的编程 or 无类编程</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function createPerson () &#123;</div><div class="line">	let firstName = &apos;&apos;;</div><div class="line">	let lastName = &apos;&apos;;</div><div class="line">	let age = 0;</div><div class="line">	return &#123;</div><div class="line">		setFirstName: function (fn) &#123;</div><div class="line">			firstName = fn;</div><div class="line">			return this;	</div><div class="line">		&#125;,</div><div class="line">		setLastName: function (fn) &#123;</div><div class="line">			lastName = fn;</div><div class="line">			return this;	</div><div class="line">		&#125;,</div><div class="line">		setAge: function (fn) &#123;</div><div class="line">			age = fn;</div><div class="line">			return this;</div><div class="line">		&#125;,</div><div class="line">		toString: function () &#123;</div><div class="line">			return [firstName, lastName, age].join(&apos; &apos;);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">let dd = createPerson()</div><div class="line">		.setFirstName(&apos;yu&apos;)</div><div class="line">		.setLastName(&apos;fan&apos;)</div><div class="line">		.setAge(11)</div><div class="line">		.toString();</div><div class="line">console.log(dd) // yu fan 11</div></pre></td></tr></table></figure>
</code></pre><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><pre><code>pipeline(a, _.compact, _.initial, _.rest, rev) // 对数据a进行一系列的操作
</code></pre><h4 id="数据流与控制流"><a href="#数据流与控制流" class="headerlink" title="数据流与控制流"></a>数据流与控制流</h4><h3 id="无类编程"><a href="#无类编程" class="headerlink" title="无类编程"></a>无类编程</h3><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="数据导向"><a href="#数据导向" class="headerlink" title="数据导向"></a>数据导向</h4><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">类层次结构</div><div class="line">function ContainerClass () &#123;&#125;</div><div class="line">function ObservedContainerClass () &#123;&#125;</div><div class="line">function HoleClass () &#123;&#125;</div><div class="line">function CASClass () &#123;&#125;</div><div class="line">function TableBaseClass () &#123;&#125;</div><div class="line"></div><div class="line">ObservedContainerClass.prototype = new ContainerClass();</div><div class="line">HoleClass.prototype = new ObservedContainerClass();</div><div class="line">CASClass.prototype = new HoleClass();</div><div class="line">TableBaseClass.prototype = new HoleClass();</div><div class="line"></div><div class="line">// 用Mixin扁平化层级结构</div><div class="line">function Container (val) &#123;</div><div class="line">	this._value = val;</div><div class="line">	this.init(val);</div><div class="line">&#125;</div><div class="line">Container.prototype.init = _.identity;</div><div class="line">let Hole = function (val) &#123;</div><div class="line">	Container.call(this, val);</div><div class="line">&#125;</div><div class="line">let HoleMixin = &#123;</div><div class="line">	setValue: function (newValue) &#123;</div><div class="line">		let oldVal = this._value;</div><div class="line">		this.validate(newValue);</div><div class="line">		this._value = newValue;</div><div class="line">		this.notify(oldVal, newValue);</div><div class="line">		return this._value;</div><div class="line">	&#125;,</div><div class="line">&#125;;</div><div class="line">let ObserverMixin = (function () &#123;</div><div class="line">	let _watchers = [];</div><div class="line">	return &#123;</div><div class="line">		watch: function (fun) &#123;</div><div class="line">			_watchers.push(fun);</div><div class="line">			return _.size(_watchers);</div><div class="line">		&#125;,</div><div class="line">		notify: function (oldVal, newVal) &#123;</div><div class="line">			_.each(_._watchers, function (watcher) &#123;</div><div class="line">				watcher.call(this, oldVal, newVal);</div><div class="line">			&#125;);</div><div class="line">			return _.size(_watchers);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line">let ValidateMixin = &#123;</div><div class="line">	addValidator: function (fun) &#123;</div><div class="line">		this._validator = fun;</div><div class="line">	&#125;,</div><div class="line">	init: function (val) &#123;</div><div class="line">		this.validate(val);</div><div class="line">	&#125;,</div><div class="line">	validate: function (val) &#123;</div><div class="line">		if (existy(this._validator) &amp;&amp;</div><div class="line">			!this._validator(val)) &#123;</div><div class="line">			fail(&apos;Attrmpted to set invalid value&apos; + polyToString(val));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">_.extend(Hole.prototype, HoleMixin, ValidateMixin, ObserverMixin); // 同级继承</div><div class="line">let h = new Hole(43);</div><div class="line">h.addValidator(always(false));</div><div class="line">console.log(h); // 43</div><div class="line"></div><div class="line">let SwapMixin = &#123;</div><div class="line">	swap: function (fun) &#123;</div><div class="line">		let args = _.rest(arguemnts);</div><div class="line">		let newValue = fun.apply(this, _.identity);</div><div class="line">		return this.setValue(newValue);</div><div class="line">	&#125;,</div><div class="line">&#125;;</div><div class="line">let o = &#123;_value: 0, setValue: _.identity&#125;</div><div class="line">_.extend(o, SwapMixin);</div><div class="line">o.swap(construct, [1, 2, 3]); //[0, 1, 2, 3]</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="external">函数式编程-读书笔记</a></p>
</blockquote>
<pre><code>```
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸&lt;strong&gt;函数式编程&lt;/strong&gt;。&lt;br&gt;&lt;em&gt;如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于流的编程-or-无类编程&quot;&gt;&lt;a href=&quot;#基于流的编程
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
