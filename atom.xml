<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2018-01-27T06:44:08.038Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web Worker</title>
    <link href="https://fanerge.github.io/html5-webWorker.html"/>
    <id>https://fanerge.github.io/html5-webWorker.html</id>
    <published>2018-01-26T13:06:15.000Z</published>
    <updated>2018-01-27T06:44:08.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/H5WebWorker/static/?_blank">先放上demo，打开控制台试试</a></p><h1 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker"></a>什么是Web Worker</h1><p>Web Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。<br>局限性：在worker内不能直接操作DOM节点，或者使用window对象的默认方法和属性。</p><h1 id="Worker特性检测"><a href="#Worker特性检测" class="headerlink" title="Worker特性检测"></a>Worker特性检测</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(window.Worker)&#123;</div><div class="line">// todo</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持web Worker</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>PS：假设页面为index.html，页面js为main.js，这里的path是相对于index.html到该worker.js。</p><h1 id="专用Worker"><a href="#专用Worker" class="headerlink" title="专用Worker"></a>专用Worker</h1><h2 id="生成一个专用worker"><a href="#生成一个专用worker" class="headerlink" title="生成一个专用worker"></a>生成一个专用worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myWorker = new Worker(&apos;worker.js&apos;);</div></pre></td></tr></table></figure><p>PS：假设页面为index.html，页面主线程js为main.js，这里的path是相对于index.html到该worker.js。</p><h2 id="主线程js和Worker的通信（数据交互）"><a href="#主线程js和Worker的通信（数据交互）" class="headerlink" title="主线程js和Worker的通信（数据交互）"></a>主线程js和Worker的通信（数据交互）</h2><h3 id="主线程js（main-js-用来生成-myWorker）"><a href="#主线程js（main-js-用来生成-myWorker）" class="headerlink" title="主线程js（main.js 用来生成 myWorker）"></a>主线程js（main.js 用来生成 myWorker）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let myWorker</div><div class="line">if(window.Worker)&#123;</div><div class="line">// todo</div><div class="line">myWorker = new Worker(&apos;./js/worker.js&apos;)</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持web Worker</div><div class="line">alert(&apos;不支持web Worker&apos;)</div><div class="line">&#125;</div><div class="line">let app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    num: 1000000,</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">computed () &#123;</div><div class="line">console.log(`Message posted to worker=$&#123;this.num&#125;`);</div><div class="line">// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</div><div class="line">myWorker.postMessage(this.num)</div><div class="line">&#125;  </div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>PS：如果想发送多个消息，可以这样myWorker.postMessage([msg1, msg2…])，对应接收的e.data对象也就是一个数组了，若是对象的话需要序列化，接收的时候需要反序列化。</p><h3 id="myWorker脚本代码"><a href="#myWorker脚本代码" class="headerlink" title="myWorker脚本代码"></a>myWorker脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 有数据发过来，就触发</div><div class="line">onmessage = function(e) &#123;</div><div class="line">let num1 = e.data;</div><div class="line">let num2 = 0;</div><div class="line"></div><div class="line">console.time(&apos;计算耗时&apos;)</div><div class="line">for(let i = 0; i &lt; num1; i++)&#123;</div><div class="line">num2 += i;</div><div class="line">&#125;</div><div class="line">console.timeEnd(&apos;计算耗时&apos;)</div><div class="line"></div><div class="line">console.log(`Worker 计算结果=$&#123;num2&#125;`)</div><div class="line"></div><div class="line">// 当我们计算出结果，应该回传</div><div class="line">postMessage(num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我向一个Worker发送一个较大num，然后求出该1到num的整数和。<br>在页面中input的值分别为：1000000、10000000、100000000各执行了一次计算，最后一次花费了11s左右（算的上耗时计算了吧）。<br>下面是我的测试截图<br><img src="http://p26lefllv.bkt.clouddn.com/WebWorker.png" alt=""><br>就这么简单，我们就实现了主线程js和WebWorker的双向通信。</p><h2 id="终止worker"><a href="#终止worker" class="headerlink" title="终止worker"></a>终止worker</h2><h3 id="在主线程中终止"><a href="#在主线程中终止" class="headerlink" title="在主线程中终止"></a>在主线程中终止</h3><p>如果你需要从主线程中立刻终止一个运行中的worker，可以调用worker的terminate 方法：<br><code>myWorker.terminate();</code><br>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p><h3 id="在Worker中终止（自杀）"><a href="#在Worker中终止（自杀）" class="headerlink" title="在Worker中终止（自杀）"></a>在Worker中终止（自杀）</h3><p><code>close()</code></p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>当然我们刚刚仅仅考虑了正常情况，还有需要错误等待我们处理呢？<br>当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。<br>它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。<br>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。<br>错误事件有以下三个用户关心的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message</div><div class="line">可读性良好的错误消息。</div><div class="line">filename</div><div class="line">发生错误的脚本文件名。</div><div class="line">lineno</div><div class="line">发生错误时所在脚本文件的行号。</div></pre></td></tr></table></figure></p><h2 id="生成subworker"><a href="#生成subworker" class="headerlink" title="生成subworker"></a>生成subworker</h2><p>如果需要的话 worker 能够生成更多的 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>而且，subworker 解析 URI 时会相对于父 worker 的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。</p><h2 id="在Worker中引入脚本与库"><a href="#在Worker中引入脚本与库" class="headerlink" title="在Worker中引入脚本与库"></a>在Worker中引入脚本与库</h2><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">importScripts();                       </div><div class="line">importScripts(&apos;cube.js&apos;);                </div><div class="line">importScripts(&apos;cube1.js&apos;, &apos;cube2&apos;);</div></pre></td></tr></table></figure></p><h1 id="共享Worker（SharedWorker）"><a href="#共享Worker（SharedWorker）" class="headerlink" title="共享Worker（SharedWorker）"></a>共享Worker（SharedWorker）</h1><p>一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。<br>由于SharedWorker 与 专有Worker 非常相似，这里我只是提一下它们的区别。<br>读者若需要做测试的话，可以考虑在2个html页面中的javascript代码使用的是同一个worker。</p><h2 id="生成一个共享worker"><a href="#生成一个共享worker" class="headerlink" title="生成一个共享worker"></a>生成一个共享worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myWorker = new SharedWorker(&apos;worker.js&apos;);</div><div class="line">// 父级线程中的调用</div><div class="line">myWorker.port.start();</div><div class="line">// worker线程中的调用, 假设port变量代表一个端口  </div><div class="line">port.start();</div></pre></td></tr></table></figure><p>一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。<br>在使用start()方法打开端口连接时，如果父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。</p><h2 id="共享worker中消息的接收和发送"><a href="#共享worker中消息的接收和发送" class="headerlink" title="共享worker中消息的接收和发送"></a>共享worker中消息的接收和发送</h2><h3 id="主线程发送消息给Worker"><a href="#主线程发送消息给Worker" class="headerlink" title="主线程发送消息给Worker"></a>主线程发送消息给Worker</h3><p>改写我们的computed方法（vue组件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed () &#123;</div><div class="line">console.log(`Message posted to worker=$&#123;this.num&#125;`);</div><div class="line">// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</div><div class="line">myWorker.port.postMessage(this.num)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Worker接收到消息并处理及回传"><a href="#Worker接收到消息并处理及回传" class="headerlink" title="Worker接收到消息并处理及回传"></a>Worker接收到消息并处理及回传</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">onconnect = function(e) &#123;</div><div class="line">var port = e.ports[0];</div><div class="line"></div><div class="line">port.onmessage = function(e) &#123;</div><div class="line">// 同样e.data为主线程发送的数据</div><div class="line">console.log(e.data)</div><div class="line">//复杂的计算</div><div class="line">let result = e.data*1000*23*3</div><div class="line">// Worker需要回传至主线程</div><div class="line">port.postMessage(result);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="主线程接收并处理消息"><a href="#主线程接收并处理消息" class="headerlink" title="主线程接收并处理消息"></a>主线程接收并处理消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myWorker.port.onmessage = function(e) &#123;</div><div class="line">result2.textContent = e.data;</div><div class="line">console.log(&apos;Message received from worker&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：总结差异，主线程和Worker都要执行start()，通信时需要带上port。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>Worker接口会生成真正的操作系统级别的线程，如果你不太小心，那么并发(concurrency)会对你的代码产生有趣的影响。然而，对于 web worker 来说，与其他线程的通信点会被很小心的控制，这意味着你很难引起并发问题。</p><h1 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP全称Content Security Policy为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。<br>可以限制如下资源的加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">script-src：外部脚本</div><div class="line">style-src：样式表</div><div class="line">img-src：图像</div><div class="line">media-src：媒体文件（音频和视频）</div><div class="line">font-src：字体文件</div><div class="line">object-src：插件（比如 Flash）</div><div class="line">child-src：框架</div><div class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</div><div class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</div><div class="line">worker-src：worker脚本</div><div class="line">manifest-src：manifest 文件</div></pre></td></tr></table></figure></p><p>除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。<br>但它必须与report-uri选项配合使用。<br><code>Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser;</code></p><h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</code></p><h3 id="服务器上设置"><a href="#服务器上设置" class="headerlink" title="服务器上设置"></a>服务器上设置</h3><p>以下语句设置在请求头部（Header）<br><code>Content-Security-Policy &quot;default-src &#39;self&#39;;&quot;</code><br>如果要为Worker指定CSP策略，可以为Worker脚本的请求的响应的头部设置CSP策略。<br>这时这个Worker会继承它所属的文档或者创建它的Worker的CSP策略。 </p><h2 id="worker中数据的接收与发送"><a href="#worker中数据的接收与发送" class="headerlink" title="worker中数据的接收与发送"></a>worker中数据的接收与发送</h2><p>在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。<br>传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。</p><blockquote><p>   参考手册<br>    <a href="http://balance9.iteye.com/blog/1992118" target="_blank" rel="external">测试html5专用线程与共享线程的区别</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">MDN-WebWorker</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="external">WebWorkerAPI</a><br>    <a href="https://cn.vuejs.org/v2/api/#v-model" target="_blank" rel="external">vue</a><br>    <a href="http://www.runoob.com/html/html5-webworkers.html" target="_blank" rel="external">HTML5 Web Workers</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid" target="_blank" rel="external">CSP</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/H5WebWorker/static/?_blank&quot;&gt;先放上demo，打开控制台试试&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是Web-Worker&quot;&gt;&lt;a href=&quot;#什么是Web-Worker&quot; cl
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Geolocation（地理定位）</title>
    <link href="https://fanerge.github.io/html5-Geolocation.html"/>
    <id>https://fanerge.github.io/html5-Geolocation.html</id>
    <published>2018-01-24T12:11:31.000Z</published>
    <updated>2018-01-24T13:48:48.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地理位置提供定制的信息。<br>其实Geolocation 就是用来获取到当前设备的经纬度（位置）<br>带有此接口的对象可以用由 Navigator实现的属性NavigatorGeolocation.geolocation 来获得。<br>PS：鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="检测是否支持地理定位"><a href="#检测是否支持地理定位" class="headerlink" title="检测是否支持地理定位"></a>检测是否支持地理定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (navigator.geolocation) &#123;</div><div class="line">// 做相应的操作 </div><div class="line">&#125; else &#123;</div><div class="line">console.error(&apos;不支持地理&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="获取当前定位"><a href="#获取当前定位" class="headerlink" title="获取当前定位"></a>获取当前定位</h2><p>Geolocation.getCurrentPosition(success, error, options)<br>    确定设备的位置并返回一个携带位置信息的 Position 对象。<br>参数：</p><h3 id="success"><a href="#success" class="headerlink" title="success"></a>success</h3><p>成功得到位置信息时的回调函数，使用Position 对象作为唯一的参数。 </p><h4 id="Position-coords-只读（latitude、longitude、accuracy）"><a href="#Position-coords-只读（latitude、longitude、accuracy）" class="headerlink" title="Position.coords 只读（latitude、longitude、accuracy）"></a>Position.coords 只读（latitude、longitude、accuracy）</h4><p>返回一个定义了当前位置的Coordinates 对象.<br>    coords.latitude    十进制数的纬度<br>    coords.longitude    十进制数的经度<br>    coords.accuracy    位置精度<br>    coords.altitude    海拔，海平面以上以米计<br>    coords.altitudeAccuracy    位置的海拔精度<br>    coords.heading    方向，从正北开始以度计<br>    coords.speed    速度，以米/每秒计</p><h4 id="Position-timestamp-只读"><a href="#Position-timestamp-只读" class="headerlink" title="Position.timestamp 只读"></a>Position.timestamp 只读</h4><p>返回一个时间戳DOMTimeStamp， 这个时间戳表示获取到的位置的时间。</p><h3 id="error-可选"><a href="#error-可选" class="headerlink" title="error 可选"></a>error 可选</h3><p>获取位置信息失败时的回调函数，使用 PositionError 对象作为唯一的参数，这是一个可选项。 </p><h4 id="PositionError-code-只读"><a href="#PositionError-code-只读" class="headerlink" title="PositionError.code 只读"></a>PositionError.code 只读</h4><p>返回无符号的、简短的错误码。<br>    PERMISSION_DENIED–权限问题<br>    POSITION_UNAVAILABLE–内部错误<br>    TIMEOUT–超时</p><h4 id="PositionError-message-只读"><a href="#PositionError-message-只读" class="headerlink" title="PositionError.message 只读"></a>PositionError.message 只读</h4><p>返回一个开发者可以理解的 DOMString 来描述错误的详细信息。</p><h3 id="options-可选"><a href="#options-可选" class="headerlink" title="options 可选"></a>options 可选</h3><h5 id="一个可选的PositionOptions-对象。"><a href="#一个可选的PositionOptions-对象。" class="headerlink" title="一个可选的PositionOptions 对象。"></a>一个可选的PositionOptions 对象。</h5><pre><code>enableHighAccuracy: false;--是否高精度，默认false timeout: 5000;--超时事件ms maximumAge: 0; 地理位置缓存时长ms</code></pre><h2 id="监视定位"><a href="#监视定位" class="headerlink" title="监视定位"></a>监视定位</h2><p>Geolocation.watchPosition(success[, error[, options]])<br>    用于注册监听器，在设备的地理位置发生改变的时候自动被调用。也可以选择特定的错误处理函数。<br>    该方法会返回一个 ID，如要取消监听可以通过  Geolocation.clearWatch() 传入该 ID 实现取消的目的。<br>参数：</p><h3 id="success-1"><a href="#success-1" class="headerlink" title="success"></a>success</h3><p>成功时候的回调函数， 同时传入一个 Position 对象当作参数。</p><h3 id="error-可选-1"><a href="#error-可选-1" class="headerlink" title="error 可选"></a>error 可选</h3><p>失败时候的回调函数，可选， 会传入一个 PositionError 对象当作参数。</p><h3 id="options-可选-1"><a href="#options-可选-1" class="headerlink" title="options 可选"></a>options 可选</h3><p>一个可选的 PositionOptions 对象。<br>PS：Position、PositionError、PositionOptions对象和上面一样。</p><h2 id="清理监视定位"><a href="#清理监视定位" class="headerlink" title="清理监视定位"></a>清理监视定位</h2><p>Geolocation.clearWatch(id)<br>    这个方法主要用于使用 Geolocation.watchPosition() 注册的 位置/错误 监听器。<br>参数：</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>希望移除的监听器所对应的 Geolocation.watchPosition() 返回的 ID 数字。<br>    Geolocation.watchPosition()注册一个位置改变监听器，每当设备位置改变时，返回一个 long 类型的该监听器的ID值。<br>Geolocation.clearWatch()<br>    取消由 watchPosition()注册的位置监听器。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation" target="_blank" rel="external">Geolocation</a><br>    <a href="http://www.runoob.com/html/html5-geolocation.html" target="_blank" rel="external">HTML5 Geolocation（地理定位）</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionError" target="_blank" rel="external">PositionError</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionOptions" target="_blank" rel="external">PositionOptions</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/watchPosition" target="_blank" rel="external">watchPosition</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>拖放（Drag 和 Drop）</title>
    <link href="https://fanerge.github.io/html5-DragAndDrop.html"/>
    <id>https://fanerge.github.io/html5-DragAndDrop.html</id>
    <published>2018-01-23T12:20:03.000Z</published>
    <updated>2018-01-23T14:33:20.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h1><p>拖放（Drag 和 drop）是 HTML5 标准的组成部分。<br>DataTransfer 对象：拖拽对象用来传递的媒介，使用一般为Event.dataTransfer。<br>draggable 属性：为需要拖拽的元素设置该属性。<br>Event.effectAllowed 属性：就是拖拽的效果。<br>Event.preventDefault() 方法：阻止默认的些事件方法等执行。<br>在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。</p><h2 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h2><h3 id="拖动目标上触发事件"><a href="#拖动目标上触发事件" class="headerlink" title="拖动目标上触发事件"></a>拖动目标上触发事件</h3><p>ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件。<br>ondrag 事件：当元素或者选择的文本被拖动时触发 drag 事件，大约每几百毫秒的触发一次。<br>ondragend 事件：当拖拽完成后触发的事件（比如松开鼠标按键或敲“Esc”键）。</p><h3 id="释放目标时触发的事件"><a href="#释放目标时触发的事件" class="headerlink" title="释放目标时触发的事件"></a>释放目标时触发的事件</h3><p>ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件。<br>ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件。<br>ondragleave 事件：当被鼠标拖动的对象离开其容器范围内时触发此事件。<br>ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件。<br>ondragexit 事件：当一个元素不再拖动立即选择目标元素触发。</p><h1 id="DataTransfer-对象详解"><a href="#DataTransfer-对象详解" class="headerlink" title="DataTransfer 对象详解"></a>DataTransfer 对象详解</h1><p>在进行拖放操作时，DataTransfer 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>dropEffect    String<br>    设置实际的放置效果，它应该始终设置成 effectAllowed  的可能值之一 。<br>effectAllowed    String<br>    用来指定拖动时被允许的效果。<br>files     FileList<br>    包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。<br>types    DOMStringList<br>    保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>addElement(element)<br>    设置拖动源。通常你不需要改变这项，如果修改这项将会影响拖动的哪个节点和dragend事件的触发。默认目标是被拖动的节点。<br>setData(type,data)<br>    为一个给定的类型设置数据。<br>getData()<br>    根据指定的类型检索数据，如果指定类型的数据不存在或者该 DataTransfer 对象中没有数据，方法将返回一个空字符串。<br>clearData(type)<br>    删除与给定类型关联的数据。类型参数是可选的。<br>setDragImage(imgElement,offsetX,offsetY)<br>    自定义一个期望的拖动时的图片。大多数情况下，这项不用设置，因为被拖动的节点被创建成默认图片。</p><h1 id="实现拖拽"><a href="#实现拖拽" class="headerlink" title="实现拖拽"></a>实现拖拽</h1><h2 id="确定什么是可拖动的"><a href="#确定什么是可拖动的" class="headerlink" title="确定什么是可拖动的"></a>确定什么是可拖动的</h2><p>让一个元素被拖动需要添加 draggable 属性，再加上全局事件处理函数ondragstart。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">console.log(&quot;dragStart&quot;);</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="定义拖动数据"><a href="#定义拖动数据" class="headerlink" title="定义拖动数据"></a>定义拖动数据</h2><p>应用程序可以在拖动操作中包含任意数量的数据项。每个数据项都是一个  string 类型，典型的MIME类型，如：text/html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">// 添加拖拽数据</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">ev.dataTransfer.setData(&quot;text/html&quot;, &quot;&lt;p&gt;Example paragraph&lt;/p&gt;&quot;);</div><div class="line">ev.dataTransfer.setData(&quot;text/uri-list&quot;, &quot;http://developer.mozilla.org&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="定义拖动图像"><a href="#定义拖动图像" class="headerlink" title="定义拖动图像"></a>定义拖动图像</h2><p>拖动过程中，浏览器会在鼠标旁显示一张默认图片。当然，应用程序也可以通过setDragImage() 方法自定义一张图片.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123; </div><div class="line">var img = new Image(); </div><div class="line">img.src = &apos;example.gif&apos;; </div><div class="line">ev.dataTransfer.setDragImage(img, 10, 10);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：img 的 src 属性路径是以使用该 js 页面为基准。</p><h2 id="定义拖动效果"><a href="#定义拖动效果" class="headerlink" title="定义拖动效果"></a>定义拖动效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">  // Set the drag effect to copy</div><div class="line">  ev.dataTransfer.dropEffect = &quot;copy&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="定义一个放置区"><a href="#定义一个放置区" class="headerlink" title="定义一个放置区"></a>定义一个放置区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function dragover_handler(ev) &#123;</div><div class="line">// 这里必须阻止默认行为，否则没有效果</div><div class="line">ev.preventDefault();</div><div class="line">ev.dataTransfer.dropEffect = &quot;move&quot;</div><div class="line">&#125;</div><div class="line">function drop_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">// Get the id of the target and add the moved element to the target&apos;s DOM</div><div class="line">var data = ev.dataTransfer.getData(&quot;text&quot;);</div><div class="line">ev.target.appendChild(document.getElementById(data));</div><div class="line">&#125;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><h2 id="处理放置效果"><a href="#处理放置效果" class="headerlink" title="处理放置效果"></a>处理放置效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">ev.dropEffect = &quot;move&quot;;</div><div class="line">&#125;</div><div class="line">function dragover_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">// Set the dropEffect to move</div><div class="line">ev.dataTransfer.dropEffect = &quot;move&quot;</div><div class="line">&#125;</div><div class="line">function drop_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">var data = ev.dataTransfer.getData(&quot;text&quot;);</div><div class="line">ev.target.appendChild(document.getElementById(data));</div><div class="line">&#125;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</div><div class="line">&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><h2 id="拖动结束"><a href="#拖动结束" class="headerlink" title="拖动结束"></a>拖动结束</h2><p>在拖动目标元素上监听 dragend 事件，此时你可以做一起其他事情。</p><blockquote><p>   参考文档：<br>    <a href="http://www.zhangxinxu.com/wordpress/2011/02/html5-drag-drop-%E6%8B%96%E6%8B%BD%E4%B8%8E%E6%8B%96%E6%94%BE%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">HTML5 drag &amp; drop 拖拽与拖放简介</a><br>    <a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="external">HTML5 拖放（Drag 和 Drop）详解与实例</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="external">DataTransfer</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="external">Drag and Drop API</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理论介绍&quot;&gt;&lt;a href=&quot;#理论介绍&quot; class=&quot;headerlink&quot; title=&quot;理论介绍&quot;&gt;&lt;/a&gt;理论介绍&lt;/h1&gt;&lt;p&gt;拖放（Drag 和 drop）是 HTML5 标准的组成部分。&lt;br&gt;DataTransfer 对象：拖拽对象用来传递的媒介
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>面试杂项</title>
    <link href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html"/>
    <id>https://fanerge.github.io/面试杂项.html</id>
    <published>2018-01-22T14:17:21.000Z</published>
    <updated>2018-01-22T14:51:21.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防止网页被嵌入框架的代码"><a href="#防止网页被嵌入框架的代码" class="headerlink" title="防止网页被嵌入框架的代码"></a>防止网页被嵌入框架的代码</h1><h2 id="任何页面都不可嵌套"><a href="#任何页面都不可嵌套" class="headerlink" title="任何页面都不可嵌套"></a>任何页面都不可嵌套</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 判断当前的window对象是否对顶层top对象还可以使用window.top !== window.self</div><div class="line">if (window !== top) </div><div class="line">// 如果不是，将top对象的网址自动导向被嵌入网页的网址</div><div class="line">top.location.href = window.location.href;</div></pre></td></tr></table></figure><h2 id="本地域名可嵌套，其他域名不可"><a href="#本地域名可嵌套，其他域名不可" class="headerlink" title="本地域名可嵌套，其他域名不可"></a>本地域名可嵌套，其他域名不可</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">　　top.location.hostname;</div><div class="line">　　if (top.location.hostname !== window.location.hostname) &#123;</div><div class="line">　　　　top.location.href = window.location.href;</div><div class="line">　　&#125;</div><div class="line">&#125;catch(e)&#123;</div><div class="line">　　top.location.href = window.location.href;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面两种对于动态生产iframe标签和禁用js不会用效果。<br>别人可能这样禁用你的js<br><code>&lt;noscript&gt;&lt;iframe src=fillseo.html&gt;&lt;/iframe&gt;&lt;/noscript&gt;</code></p><h2 id="js如何判断是否在iframe中"><a href="#js如何判断是否在iframe中" class="headerlink" title="js如何判断是否在iframe中"></a>js如何判断是否在iframe中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//方式一 </div><div class="line">if (self.frameElement &amp;&amp; self.frameElement.tagName == &quot;IFRAME&quot;) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125; </div><div class="line">//方式二 </div><div class="line">if (window.frames.length != parent.frames.length) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125; </div><div class="line">//方式三 </div><div class="line">if (self != top) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="比较可靠的方式"><a href="#比较可靠的方式" class="headerlink" title="比较可靠的方式"></a>比较可靠的方式</h2><p>为了彻底防止别人用IFRAME框架嵌套调用自己的网页，如下方法是最可靠的.<br>这里赋值为空页面,也可赋值为你的页面的URL地址.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(top != self)&#123; </div><div class="line">location.href = &quot;about:blank&quot;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="在meta中设置"><a href="#在meta中设置" class="headerlink" title="在meta中设置"></a>在meta中设置</h2><p><code>&lt;meta http-equiv=&quot;X-FRAME-OPTIONS&quot; content=&quot;DENY&quot;&gt;</code></p><h2 id="在http的header做手脚"><a href="#在http的header做手脚" class="headerlink" title="在http的header做手脚"></a>在http的header做手脚</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">header(‘X-Frame-Options:Deny&apos;);</div><div class="line">header(&quot;X-XSS-Protection: 0&quot;);</div></pre></td></tr></table></figure><h2 id="在Apache、IIS、Nginc主机中设置"><a href="#在Apache、IIS、Nginc主机中设置" class="headerlink" title="在Apache、IIS、Nginc主机中设置"></a>在Apache、IIS、Nginc主机中设置</h2><p><code>X-Frame-Options &quot;SAMEORIGIN&quot;;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;a href=&quot;#防止网页被嵌入框架的代码&quot; class=&quot;headerlink&quot; title=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;/a&gt;防止网页被嵌入框架的代码&lt;/h1&gt;&lt;h2 id=&quot;任何页面都不可嵌套&quot;&gt;&lt;a href=&quot;#任何页面
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MathML</title>
    <link href="https://fanerge.github.io/html5-MathML.html"/>
    <id>https://fanerge.github.io/html5-MathML.html</id>
    <published>2018-01-22T12:44:44.000Z</published>
    <updated>2018-01-23T12:24:53.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。<br>MathML 是一个用于标记数学表达式的 XML 词汇表，它包含两个子语言：Presentation MathML 和 Content MathML。<br>Presentation MathML 主要负责描述数学表达式的布局（因此可与 TeX 或更早的 SGML 标记语言相比较，SGML 用于描述诸如 ISO 12083 之类格式的数学表达式的布局）。<br>Content MathML 主要负责标记表达式的某些含义或数学结构。MathML 的这一方面受到 OpenMath 语言的很大影响，在 MathML3 中，与 OpenMath 更为贴近。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;</div><div class="line">&lt;mrow&gt;</div><div class="line">&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</div><div class="line">&lt;mo&gt;+&lt;/mo&gt;</div><div class="line">&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</div><div class="line">&lt;mo&gt;=&lt;/mo&gt;</div><div class="line">&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</div><div class="line">&lt;/mrow&gt;</div><div class="line">&lt;/math&gt;</div></pre></td></tr></table></figure><p><img src="http://www.runoob.com/wp-content/uploads/2015/12/mathml1.jpg" alt="demo"></p><h1 id="MathML-元素"><a href="#MathML-元素" class="headerlink" title="MathML 元素"></a>MathML 元素</h1><p>这是一份关于 MathML 呈现型元素的、按字母表排序的清单。<br>MathML元素的细节和在桌面浏览器与移动设备浏览器上的兼容性情况。</p><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p><code>&lt;math&gt;  （顶层元素）</code></p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;maction&gt;   （绑定动作到子表达式）</div><div class="line">&lt;maligngroup&gt; （对齐分组）</div><div class="line">&lt;malignmark&gt;  （对齐点）</div></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;menclose&gt; （包含的内容）</div><div class="line">&lt;merror&gt; （包含的语法错误消息）</div></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mfenced&gt; （圆括号）</div><div class="line">&lt;mfrac&gt; （因子）</div></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><code>&lt;mglyph&gt; （显示非标准符号）</code></p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p><code>&lt;mi&gt; （标识符）</code></p><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mlabeledtr&gt;（表格或矩阵中的行标签）</div><div class="line">&lt;mlongdiv&gt;（长除法记号）</div></pre></td></tr></table></figure><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><code>&lt;mmultiscripts&gt; （惯例和张量指标）</code></p><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><p><code>&lt;mn&gt; （数量）</code></p><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mo&gt; （运算符）</div><div class="line">&lt;mover&gt; （上标）</div></pre></td></tr></table></figure><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mpadded&gt;（内容周围的填充空间）</div><div class="line">&lt;mphantom&gt; （预留空间的不可见内容）</div></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mroot&gt; （带指定根数的根号）</div><div class="line">&lt;mrow&gt; （分组后的子表达式）</div></pre></td></tr></table></figure><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;ms&gt; （字符串字面量）</div><div class="line">&lt;mscarries&gt; （诸如进位的附注）</div><div class="line">&lt;mscarry&gt; （单位进位， </div><div class="line">&lt;mscarries&gt;的子元素）</div><div class="line">&lt;msgroup&gt; （在 &lt;mstack&gt; 和 </div><div class="line">&lt;mlongdiv&gt;元素中分组后的若干行）</div><div class="line">&lt;msline&gt; （在 &lt;mstack&gt; 内部的水平行）</div><div class="line">&lt;mspace&gt; （空格）</div><div class="line">&lt;msqrt&gt; （不带根数的平方根）</div><div class="line">&lt;msrow&gt; （在&lt;mstack&gt;元素中的行）</div><div class="line">&lt;mstack&gt; （堆叠式对齐）</div><div class="line">&lt;mstyle&gt; （样式变更）</div><div class="line">&lt;msub&gt; （下角标）</div><div class="line">&lt;msup&gt; （上角标）</div><div class="line">&lt;msubsup&gt; （上下角标对）</div></pre></td></tr></table></figure><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;mtable&gt; （表格或矩阵）</div><div class="line">&lt;mtd&gt; （表格或矩阵中的单元格）</div><div class="line">&lt;mtext&gt; （文本）</div><div class="line">&lt;mtr&gt; （表格或矩阵中的行）</div></pre></td></tr></table></figure><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;munder&gt; （下标）</div><div class="line">&lt;munderover&gt; （上标-下标对）</div></pre></td></tr></table></figure><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;semantics&gt; （语义附注的容器）</div><div class="line">&lt;annotation&gt; （数据附注）</div><div class="line">&lt;annotation-xml&gt;  （XML 附注）</div></pre></td></tr></table></figure><h1 id="MathML-属性"><a href="#MathML-属性" class="headerlink" title="MathML 属性"></a>MathML 属性</h1><p>关于MathML属性的参考文档。用这些属性可以修改这些元素的显示效果。</p><iframe heigth="50vh" width="100%" src="https://developer.mozilla.org/zh-CN/docs/Web/MathML/Attribute"><br></iframe><p>PS：MathML的 mstyle 和 math 元素接受所有 MathML 的描述元素。<br>    请参阅MathML中值（values）和单位的注释值。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/MathML" target="_blank" rel="external">MDN-MathML</a><br>    <a href="http://www.runoob.com/html/html5-mathml.html" target="_blank" rel="external">html5-mathml</a><br>    <a href="https://www.ibm.com/developerworks/cn/xml/x-mathml3/" target="_blank" rel="external">MathML 介绍</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。&lt;br&gt;M
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>代码重构技巧</title>
    <link href="https://fanerge.github.io/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7.html"/>
    <id>https://fanerge.github.io/代码重构技巧.html</id>
    <published>2018-01-16T12:34:50.000Z</published>
    <updated>2018-01-22T12:34:16.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h1><p>任何不会被修改的变量都可以当做参数传入新的函数；一个变量会被修改可以把它当做返回值。</p><h1 id="重构方法-重新组织函数"><a href="#重构方法-重新组织函数" class="headerlink" title="重构方法-重新组织函数"></a>重构方法-重新组织函数</h1><h2 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h2><p>将这段代码放进一个独立地函数中，并让函数名称解释该函数的用途。<br>包装函数的粒度小，复用的几率就大。<br>适用于：为一些代码提供一个清晰的函数名。<br>函数命名：以它“做什么”来命名，而不是以它“怎么做”命名。</p><h2 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h2><p>在函数调用点插入函数本体，然后移除该函数。<br>适用于：原函数内部代码清晰易读，不需要提炼为一个单独的函数。</p><h2 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h2><p>将所有对该变量的引用动作，替换为对它赋值的哪个表达式自身。<br>适用于：只使用了一次，或许可以移除该临时变量。</p><h2 id="Replace-Temp-with-Query（以查询取代临时变量）"><a href="#Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp with Query（以查询取代临时变量）"></a>Replace Temp with Query（以查询取代临时变量）</h2><p>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其它函数使用。<br>适用于：由于临时变量作用域只在函数内部，如果把临时变量替换为一个查询，那么同一个类中的所有函数都可以获取这份信息。</p><h2 id="Introduce-Explaining-Variable（引入解释性变量）"><a href="#Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaining Variable（引入解释性变量）"></a>Introduce Explaining Variable（引入解释性变量）</h2><p>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。<br>适用于：用一个命名清晰的变量来代替难以理解的代码或函数。</p><h2 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h2><p>针对每次赋值，创造一个独立、对应的临时变量（再多一个临时变量）。<br>适用于：你的程序有某个临时变量被赋值超过一次，它即不是循环变量，而不被用于收集计算结果。</p><h2 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h2><p>以一个临时变量取代该参数的位置。<br>适用于：用一个临时变量（有意义的名字）保存参数。</p><h2 id="Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Method Object（以函数对象取代函数）"></a>Replace Method with Method Object（以函数对象取代函数）</h2><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。<br>然后你可以在同一个对象中将这个大型函数分解为多个小型函数。<br>适用于：你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。</p><h2 id="Substitute-Algorithm（替换算法）"><a href="#Substitute-Algorithm（替换算法）" class="headerlink" title="Substitute Algorithm（替换算法）"></a>Substitute Algorithm（替换算法）</h2><p>将函数本体代替为另一个算法。<br>适用于：你想要把某个算法替换为另一个更加清晰的算法。</p><h1 id="重构方法-在对象之间搬移特性"><a href="#重构方法-在对象之间搬移特性" class="headerlink" title="重构方法-在对象之间搬移特性"></a>重构方法-在对象之间搬移特性</h1><h2 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h2><p>在该函数最常引用的类中建立一个有着类似行为的新函数。<br>将旧函数编程一个单纯的委托函数，或是将旧函数完全移除。<br>适用于：一个类有太多行为，或一个类与另一个类有太多合作而形成高度耦合。</p><h2 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h2><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。<br>适用于：对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它。</p><h2 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h2><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。<br>适用于：某个类做了应该由两个类做的事。</p><h2 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h2><p>将这个类的所有特性搬移到另一个类中，然后移除原类。<br>适用于：某个类没有做太多事情。</p><h2 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h2><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。<br>适用于：客户通过一个委托类来调用另一个对象。</p><h2 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h2><p>让客户直接调用受托类。<br>适用于：某个类做了过多的简单委托动作。</p><h2 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h2><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。<br>适用于：你需要为提供服务的类添加一个函数，但你无法修改这个类。<br>外加函数终归是权益之计，尽量将其搬移到服务类中去（Introduce Local Extension）。</p><h2 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h2><p>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。<br>适用于：你需要为服务类提供一些额外函数，但你无法修改这个类。</p><h1 id="重构方法-重新组织数据"><a href="#重构方法-重新组织数据" class="headerlink" title="重构方法-重新组织数据"></a>重构方法-重新组织数据</h1><h2 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h2><p>为这个字段建立取值/设置函数，并且只以这些函数来访问字段。<br>适用于：你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。</p><h2 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h2><p>将数据项变成对象。<br>适用于：你有一个数据项，需要与其他数据和行为一起使用才有意义。</p><h2 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h2><p>将这个值对象变成引用对象。<br>适用于：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。</p><h2 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h2><p>将它变成一个值对象。<br>适用于：你有一个引用对象，很小且不可该表，而且不易管理。</p><h2 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h2><p>以对象替换数组。对于数组中的每个元素，以一个字段来表示。<br>适用于：你有一个数组，其中的元素各自代表不同的东西。</p><h2 id="Duplicate-Observed-Data（复制“被监视数据”）"><a href="#Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data（复制“被监视数据”）"></a>Duplicate Observed Data（复制“被监视数据”）</h2><p>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。<br>MVC模型</p><h2 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><p>添加一个反向指针，并使修改函数能够同时更新两条连接。<br>适用于：两个类都需要使用对方特性，但其间只有一条单向连接。</p><h2 id="Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><p>去除不必要的关联。<br>适用于：两个类之间有双向关联，但其中一个类如今不需要另一个类的特性。</p><h2 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h2><p>创造一个常量，根据其意义为它命名，并将上述的字面量替换为这个常量。<br>适用于：你有一个字面数值，带上特别含义。</p><h2 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h2><p>将它声明为private，并提供相应的访问函数get和set。<br>适用于：你的类中存在一个public字段。</p><h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>让这个函数返回集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。<br>适用于：有一个函数返回一个集合。</p><h2 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h2><p>为该记录创建一个“哑”数据对象。<br>适用于：你需要面对传统编程环境中的记录结构。</p><h2 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h2><p>以一个新的类替换该数值类型码。<br>适用于：类之中有一个数值类型码，但它并不影响类的行为。</p><h2 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h2><p>以自带取代这个类型码（多态）。<br>适用于：你有一个不可变的类型码，它会影响类的行为。</p><h2 id="Replace-Type-Code-with-State-Strategy（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy（以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy（以State/Strategy取代类型码）</h2><p>以状态对象取代类型码。<br>适用于：你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。</p><h2 id="Replace-Subclass-with-Fields（以字段取代子类）"><a href="#Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="Replace Subclass with Fields（以字段取代子类）"></a>Replace Subclass with Fields（以字段取代子类）</h2><p>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。<br>适用于：你的各个子类的唯一差别只在“返回常量数据”的函数身上。</p><h1 id="重构方法-简化条件表达式"><a href="#重构方法-简化条件表达式" class="headerlink" title="重构方法-简化条件表达式"></a>重构方法-简化条件表达式</h1><h2 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h2><p>从if、then、else三个段落中分别提炼出独立函数。<br>适用于：你有一个复杂的条件（if-then-else）语句。</p><h2 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h2><p>将这些测试合并为一个条件表达式，并将这个表达式提炼成一个独立的函数。<br>适用于：你有一系列条件测试，都得到相同结果。</p><h2 id="Consilidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consilidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consilidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consilidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将这个端重复代码搬移到条件表达式之外。<br>适用于：在条件表达式的每个分支上有着相同的一段代码。</p><h2 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h2><p>以break语句或return语句取代控制标记。<br>适用于：在一系列布尔表达式中，某个变量带有“控制标记”（control flag）的作用。</p><h2 id="Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）</h2><p>使用卫语句表现所有特殊情况（尽量不要转换成嵌套）。<br>适用于：函数中的条件逻辑使人难以看清正常的执行路径。</p><h2 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br>适用于：你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p><h2 id="Introduce-Null-Object（引入Null对象）"><a href="#Introduce-Null-Object（引入Null对象）" class="headerlink" title="Introduce Null Object（引入Null对象）"></a>Introduce Null Object（引入Null对象）</h2><p>将null值替换为null对象。<br>适用于：你需要再三检查对象是否为null。</p><h2 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h2><p>以断言明确表现这种假设。<br>适用于：某一段代码需要对程序状态做出某种假设。</p><h1 id="重构方法-简化函数调用"><a href="#重构方法-简化函数调用" class="headerlink" title="重构方法-简化函数调用"></a>重构方法-简化函数调用</h1><h2 id="Rename-Method（函数改名）"><a href="#Rename-Method（函数改名）" class="headerlink" title="Rename Method（函数改名）"></a>Rename Method（函数改名）</h2><p>修改函数的名称。<br>适用于：函数的名称未能解释函数的用途。<br>函数命名，参考“做什么”而不是“怎么做”。</p><h2 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h2><p>为此函数添加一个对象参数，让该对象带进函数所需信息。<br>适用于：某个函数需要从调用端得到更对信息。<br>这样做有一个好处，不用关心参数的位置。</p><h2 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h2><p>将该参数去除。<br>适用于：函数本体不再需要某个参数。</p><h2 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h2><p>建立两个不同的函数，其中一个负责查询，另一个负责修改。<br>适用于：某个函数既返回对象状态值，又修改对象状态。</p><h2 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h2><p>建立单一函数，以参数表达那些不同的值。<br>适用于：若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p><h2 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h2><p>针对该参数的每一个可能值，建立一个独立函数。<br>适用于：你有一个函数，其中完全取决于参数值而不采取不同行为。</p><h2 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h2><p>改为传递整个对象（传递整个对象，不要值传递对象的某些属性）。<br>适用于：你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p><h2 id="Replace-Parameter-with-Methods（以函数取代参数）"><a href="#Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="Replace Parameter with Methods（以函数取代参数）"></a>Replace Parameter with Methods（以函数取代参数）</h2><p>让参数接受者去除该项参数，并直接调用前一个函数。<br>适用于：对象调用某一个函数，并将所得结果作为参数，传递给另一个函数。<br>而接受参数的函数本身也能够用前一个函数。</p><h2 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h2><p>以一个对象取代这些参数。<br>适用于：某些参数总是很自然地同时出现。</p><h2 id="Remove-Setting-Method（移除设置函数）"><a href="#Remove-Setting-Method（移除设置函数）" class="headerlink" title="Remove Setting Method（移除设置函数）"></a>Remove Setting Method（移除设置函数）</h2><p>去掉该字段的所有设值函数。<br>适用于：类中的某个字段应该在对象创建时被设值，然后不再改变。</p><h2 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h2><p>将这个函数修改为private。<br>适用于：有一个函数，从来没有被其他任何类用到。</p><h2 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h2><p>将构造函数替换为工厂函数。<br>适用于：你希望在创建对象时不仅仅时做简单的建构动作。</p><h2 id="Enucapsulate-Downcast（封装向下转型）"><a href="#Enucapsulate-Downcast（封装向下转型）" class="headerlink" title="Enucapsulate Downcast（封装向下转型）"></a>Enucapsulate Downcast（封装向下转型）</h2><p>将向下转型动作移到函数中。<br>适用于：某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。</p><h2 id="Replace-Error-Code-with-Exception（异常取代错误代码）"><a href="#Replace-Error-Code-with-Exception（异常取代错误代码）" class="headerlink" title="Replace Error Code with Exception（异常取代错误代码）"></a>Replace Error Code with Exception（异常取代错误代码）</h2><p>改用异常。<br>适用于：某个函数返回一个特定的代码，用以表示某种错误情况。</p><h2 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h2><p>修改调用者，使它在调用函数之前先做检查。<br>适用于：面对一个调用这可以预先检查的条件，你抛出了一个异常。</p><h1 id="重构方法-处理概括关系（继承关系）"><a href="#重构方法-处理概括关系（继承关系）" class="headerlink" title="重构方法-处理概括关系（继承关系）"></a>重构方法-处理概括关系（继承关系）</h1><h2 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h2><p>将该字段移至超类。<br>适用于：两个子类都拥有相同的字段。</p><h2 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h2><p>将函数移至超类。<br>适用于：有些函数，在各个子类中产生完全相同的结果。</p><h2 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h2><p>在超类中新建一个构造函数，并在子类构造函数中调用它。<br>适用于：你在各个子类中拥有一些构造函数，它们的本体机会完全一致。</p><h2 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h2><p>将这个函数移到相关的那些子类去。<br>适用于：超类中的某个函数只与部分（而非全部）子类有关。</p><h2 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h2><p>将这个字段移到需要它的那些子类去。<br>适用于：超类中的某个字段只被部分（而非全部）子类用到。</p><h2 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h2><p>新建一个子类，将上面所说的那一部分特性移到子类中。<br>适用于：类中的某些特性只被某些（而非全部）实例用到。</p><h2 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h2><p>为这两个类建立建立一个超类，将相同特性移至超类。<br>适用于：这两个类有相似特性。</p><h2 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h2><p>将相同的子集提炼到一个独立接口中。<br>适用于：若干客户适用类接口中的同一子集，或者两个类的接口有部分相同。</p><h2 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h2><p>将它们合为一体。<br>适用于：超类和子类之间无太大区别。</p><h2 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h2><p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。<br>适用于：你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节有所不同。</p><h2 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h2><p>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。<br>适用于：某个子类只适用超类接口中的一部分，或是根本不需要继承而来的数据。</p><h2 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h2><p>让委托类继承受托类。<br>适用于：你在两个类之间委托关系，并经常为整个接口编写许多极简单的委托函数。</p><h1 id="重构方法-大型重构"><a href="#重构方法-大型重构" class="headerlink" title="重构方法-大型重构"></a>重构方法-大型重构</h1><h2 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h2><p>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。<br>适用于：某个继承体系同时承担两项责任。</p><h2 id="ConvertProcedural-Design-to-Objects（将过程化设计转化为对象设计）"><a href="#ConvertProcedural-Design-to-Objects（将过程化设计转化为对象设计）" class="headerlink" title="ConvertProcedural Design to Objects（将过程化设计转化为对象设计）"></a>ConvertProcedural Design to Objects（将过程化设计转化为对象设计）</h2><p>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。<br>适用于：你手上有一些传统过程化风格的代码。</p><h2 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h2><p>将领域逻辑分离出来，为它们建立独立地领域类。<br>适用于：某些GUI类之中包含了领域逻辑。</p><h2 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h2><p>建立继承体系，以一个子类表示一种特殊情况。<br>适用于：你有某个类做了太多工作，其中一部分工作是以大量表达式完成的。</p><h1 id="代码的坏味道–及解决方案"><a href="#代码的坏味道–及解决方案" class="headerlink" title="代码的坏味道–及解决方案"></a>代码的坏味道–及解决方案</h1><h2 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h2><p>Extract Method（提炼函数）<br>Pull Up Method（函数上移到超类）<br>Form Template Method（塑造模板函数）<br>Substitute Algorithm（替换算法）<br>Extract Class（提炼类）</p><h2 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h2><p>Extract Method（提炼函数）<br>Replace Temp with Query（以查询取代临时变量）<br>Introduce Parameter Object（引入参数对象）<br>Preserve Whole Object（保持对象完整）<br>Replace Method with Method Object（以函数对象取代函数）<br>Decompose Conditional（分解条件表达式）</p><h2 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h2><p>Extract Class（提炼类）<br>Extract Subclass（提炼子类）<br>Extract Interface（提炼接口）<br>Duplicate Observed Data（复制“被监视数据”）</p><h2 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h2><p>Replace Parameter with Method（用函数替换参数）<br>Preserve Whole Object（保持对象完整）<br>Introduce Parameter Object（引入参数对象）</p><h2 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h2><p>Extract Class（提炼类）</p><h2 id="Shotgun-Surgery（霰xian弹式修改）"><a href="#Shotgun-Surgery（霰xian弹式修改）" class="headerlink" title="Shotgun Surgery（霰xian弹式修改）"></a>Shotgun Surgery（霰xian弹式修改）</h2><p>Move Method（移动函数）<br>Move Field（移动字段）<br>Inline Class（内联类）</p><h2 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h2><p>Move Method（移动函数）<br>Extract Method（提炼方法）</p><h2 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h2><p>Extract Class（提炼类）<br>Introduce Parameter Object（引入参数对象）<br>Preserve Whole Object（保持整个对象）</p><h2 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h2><p>Replace Data Value with Object（用对象替换数据值）<br>Replace Type Code with Class（用类替换类型代码）<br>Extract Class（提炼类）<br>Introduce Parameter Object（引入参数对象）<br>Replace Array with Object（用对象代替数组）</p><h2 id="Switch-Statements（switch-惊悚现身）"><a href="#Switch-Statements（switch-惊悚现身）" class="headerlink" title="Switch Statements（switch 惊悚现身）"></a>Switch Statements（switch 惊悚现身）</h2><p>Extract Method（提炼函数）<br>Move Method（移动函数）<br>Replace Type Code with Subclass（以子类替换类型代码）<br>Replace Type Code with State/Strategy（以State/Strategy取代类型码）<br>Replace Conditional with Polymorphism（以多态取代条件表达式）<br>Replace Parameter with Explicit Methods（以明确函数取代参数）<br>Introduce Null Object（引入null对象）</p><h2 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h2><p>Move Method（移动函数）<br>Move Field（移动字段）</p><h2 id="Lazy-Class（冗赘类）"><a href="#Lazy-Class（冗赘类）" class="headerlink" title="Lazy Class（冗赘类）"></a>Lazy Class（冗赘类）</h2><p>Collapse Hierarchy（折叠继承体系）<br>Inline Class（内联类）</p><h2 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h2><p>Collapse Hierarchy（折叠继承体系）<br>Inline Class（内联类）<br>Remove Parameter（移除参数）<br>Rename Method（移除函数）</p><h2 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h2><p>Extract Class（提炼类）<br>Introduce Null Object（引入Null对象）</p><h2 id="Message-Chains（过渡耦合的消息链）"><a href="#Message-Chains（过渡耦合的消息链）" class="headerlink" title="Message Chains（过渡耦合的消息链）"></a>Message Chains（过渡耦合的消息链）</h2><p>Hide Delegate（隐藏“委托关系”）<br>Extract Method（提炼函数）<br>Move Method（移动函数）</p><h2 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h2><p>Remove Middle Man（中间人）<br>Inline Method（内联方法）<br>Replace Delegation with Inheritance（以继承取代委托）</p><h2 id="Inappropriate-Intimacy（狎昵关系）–两个类过于亲密"><a href="#Inappropriate-Intimacy（狎昵关系）–两个类过于亲密" class="headerlink" title="Inappropriate Intimacy（狎昵关系）–两个类过于亲密"></a>Inappropriate Intimacy（狎昵关系）–两个类过于亲密</h2><p>Move Method（移动函数）<br>Move Field（移动字段）<br>Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）<br>Extract Class（提炼类）<br>Hide Delegate（隐藏“委托关系”）<br>Replace Inheritance with Delegation（以委托取代继承）</p><h2 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h2><p>Rename Method（重命名函数）<br>Move Method（移动函数）<br>Extract Superclass（提炼超类）</p><h2 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h2><p>Move Method（移动函数）<br>Intorduce Foreign Method（引入外加函数）<br>Introduce Local Extension（引入本地扩展）</p><h2 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h2><p>Encapsulate Field（自封装字段）<br>Encapsulate Collection（封装集合）<br>Remove Setting Method（移除设置函数）<br>Move Method（移除函数）<br>Extract Method（提炼函数）<br>Hide Method（隐藏函数）</p><h2 id="Refused-Bequest（被拒绝的馈赠）"><a href="#Refused-Bequest（被拒绝的馈赠）" class="headerlink" title="Refused Bequest（被拒绝的馈赠）"></a>Refused Bequest（被拒绝的馈赠）</h2><p>Push Down Method（函数下移）–移动子类<br>Push Down Field（字段下移）<br>Replace Inheritance with Delegation（以委托取代继承）</p><h2 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h2><p>Rename Metho（重命名方法）<br>Introduce Assertion（引入断言）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文整理于《重构改善既有代码的设计》，这本书是用java写的，整理的目的是为了自己能写出更健壮、更具扩展性的代码，为以后的编码做参考。<br>个人能力有限，如有理解不当还望指出，更深入的了解还请参阅次书籍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构技巧&quot;&gt;&lt;a href=&quot;#重构技巧&quot; class=&quot;headerlink&quot; title=&quot;重构技巧&quot;&gt;&lt;/a&gt;重构技巧&lt;/h1&gt;&lt;p&gt;任何不会被修改的变量都可以当做参数传入新的函数；一个变量会被修改可以把它当做返回值。&lt;/p&gt;
&lt;h1 id=&quot;重构方法-重新
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码重构" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>git使用手册</title>
    <link href="https://fanerge.github.io/git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/git使用手册.html</id>
    <published>2018-01-13T12:50:00.000Z</published>
    <updated>2018-01-14T14:01:12.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git基础知识"><a href="#git基础知识" class="headerlink" title="git基础知识"></a>git基础知识</h1><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的 工作目录，它持有实际文件；<br>第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；<br>最后是 HEAD，它指向你最后一次提交的结果。<br>下图展示其关系<br><img src="http://www.runoob.com/manual/git-guide/img/trees.png" alt="git工作流"></p><h2 id="git配置用户信息"><a href="#git配置用户信息" class="headerlink" title="git配置用户信息"></a>git配置用户信息</h2><p>Git是分布式版本控制系统，SVN都是集中式的版本控制系统（需要中央服务器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;Your Name&quot;</div><div class="line">git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure></p><p>PS：注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir dirname </div><div class="line">cd dirname</div><div class="line">pwd // pwd命令用于显示当前目录(绝对路径)</div><div class="line">git init // 把这个目录变成Git可以管理的仓库</div></pre></td></tr></table></figure></p><p>PS：目录名和文件名不可有中文<br>    .git 文件就是Git来跟踪管理版本库，千万别手动更改。<br>    如果没有.git 文件（系统隐藏关键文件），可以 ls -ah命令来查看</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>第一步，用命令git add告诉Git，把文件<span style="color: red">添加</span>到仓库：<br>实际上就是把文件修改添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add fileName</div><div class="line">git add *.js // 通配符</div></pre></td></tr></table></figure></p><p>PS：可以向git库多次添加文件，并一次提交<br>第二步，用命令git commit告诉Git，把文件<span style="color: red">提交</span>到仓库：<br>实际上就是把暂存区的所有内容提交到当前分支（默认是master分支）<br><code>git commit -m &quot;说明文本&quot;</code><br>PS：-m后面输入的是本次提交的说明，方便以后查看<br>更好的理解：需要提交的文件修改通过放到暂存区，然后，一次性提交暂存区的所有修改。<br><code>git commit -am &#39;说明&#39;</code><br>PS：git add 和 git commit的简写<br>清屏<br><code>reset + Enter</code><br>该命令可以让我们时刻掌握仓库当前的状态（当前是否有需要提交的修改）<br><code>git mv &lt;oldName&gt; &lt;nemeName&gt;</code><br>PS：git mv 命令用于移动或重命名一个文件、目录、软连接。<br><code>git status</code><br>PS：列出当前目录所有还没有被git管理的文件和 被git管理且被修改但还未提交（git commit）的文件。<br>查看具体修改了什么内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git diff</div><div class="line">git diff HEAD -- fileName // 比对某个文件</div><div class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</div><div class="line">比对两个分支</div><div class="line">尚未缓存的改动：git diff</div><div class="line">查看已缓存的改动： git diff --cached</div><div class="line">查看已缓存的与未缓存的所有改动：git diff HEAD</div><div class="line">显示摘要而非整个 diff：git diff --stat</div></pre></td></tr></table></figure></p><p>PS：提交仓库前最好看一下，这是不是我们更改的。<br>经过对比后，就可以放心的添加和提交文件了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add fileName</div><div class="line">git commit -m &apos;note&apos;</div></pre></td></tr></table></figure></p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>该命令显示从最近到最远的提交日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git log // 下面命令仅仅显示commit id（版本号），它是16进制数</div><div class="line">git log --oneline // 历史记录的简洁的版本</div><div class="line">git log --oneline --graph // 查看历史中什么时候出现了分支、合并</div><div class="line">git log --reverse --oneline // 逆向显示所有日志</div><div class="line">git log --author=fanerge // 查找指定用户的提交日志</div><div class="line">git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges </div><div class="line">// --since 和 --before，但是你也可以用 --until 和 --after</div></pre></td></tr></table></figure></p><p>回到上一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 当前版本是HEAD，上一个版本就是HEAD^，上上一个版本就是HEAD^^，前100的版本HEAD~100</div><div class="line">git reset --hard HEAD^ // 回到上一个版本</div></pre></td></tr></table></figure></p><p>回到未来的版本<br><code>git reset --hard 版本号 // 版本号可以只写几位，git帮我们完善</code><br>显示文件<br><code>cat fileName</code><br>如果忘记版本号想回到最新的版本怎么办？该命令可以查看到版本号<br><code>git reflog</code><br>PS：可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><pre><code>就是之前mkdir生产的目录，存放git项目的目录。</code></pre><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><pre><code>工作区有一个隐藏目录.git，这个就是Git的版本库。</code></pre><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>PS：其实git add fileName命令就是讲对应的文件添加到暂存区<br>    其实git commit 命令仅仅是将暂存区的东西提交到当前分支</p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>Git跟踪并管理的是修改，而非文件。<br>Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>把 fileName 文件在工作区的修改全部撤销，这里有三种情况：</p><ol><li>一是 fileName 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>二是 fileName 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li><li>三是 fileName 已经提交到本地版本库中，请使用 git reset –hard HEAD^<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。</li></ol><p>处理方式：</p><h3 id="尚未存在暂存区"><a href="#尚未存在暂存区" class="headerlink" title="尚未存在暂存区"></a>尚未存在暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- fileName</div></pre></td></tr></table></figure><p>PS：git checkout -- fileName命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。</p><h3 id="已存在暂存区"><a href="#已存在暂存区" class="headerlink" title="已存在暂存区"></a>已存在暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset HEAD fileName</div><div class="line">git checkout -- fileName // 必须要使用第一点的方式</div></pre></td></tr></table></figure><p>PS：git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。<br><img src="http://marklodato.github.io/visual-git-guide/basic-usage.svg" alt="工作区-暂存区-HEAD"><br>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p><ul><li>git add files 把当前文件放入暂存区域。</li><li>git commit 给暂存区域生成快照并提交。</li><li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li><li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>直接右键或命令删除文件<br><code>rm fileName</code><br>PS：此时，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了<br>这是有两种处理方式：</p><ol><li><p>真的想删除这个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm fileName // git中删除对应文件</div><div class="line">git commit -m &apos;说明&apos; // 同步工作区和版本库</div></pre></td></tr></table></figure></li><li><p>删错了，你想从版本库中恢复（无论工作区是修改还是删除，都可以“一键还原”）<br><code>git checkout -- fieName</code><br>PS：命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。    </p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="设置ssh（以github举例）"><a href="#设置ssh（以github举例）" class="headerlink" title="设置ssh（以github举例）"></a>设置ssh（以github举例）</h2><p>第1步：创建SSH Key。<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa（私钥）和id_rsa.pub（公钥）两个文件<br>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>这里包括title和key字段</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p><code>git remote add origin git@github.com:fanerge/repositoryName.git</code><br>把本地库与远程库进行关联（在本地库目录下进行）<br>远程库的名字就是origin，这是Git默认的叫法<br><code>git push -u origin master</code><br>把本地库的所有内容推送到远程库上<br>其实git push 是把当前分支如 master 推送到远程<br>PS：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>以后推送只需下面命令：<br><code>git push origin master</code>    </p><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:fanerge/仓库名.git</div><div class="line">or</div><div class="line">git clone &lt;repo&gt; &lt;directory&gt; // 克隆到指定的目录</div><div class="line">cd 仓库名</div><div class="line">ls</div></pre></td></tr></table></figure></li></ol><p>PS：git支持多种协议 ssh、https等</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。    </p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout -b branchName</div><div class="line">git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</div><div class="line">git branch branchName // 创建分支</div><div class="line">git checkout branchName // 切换到分支</div><div class="line">git branch</div><div class="line">查看分支</div></pre></td></tr></table></figure></p><p>PS：git branch 命令会列出所有分支，当前分支前面会标一个*号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">dev分支的工作完成，我们就可以切换回master分支</div><div class="line">git merge branchName</div><div class="line">git merge命令用于合并指定分支到当前分支（这里是将dev合并到master）。</div></pre></td></tr></table></figure></p><p>PS：这个操作只能在主分支master上进行。<br>    Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p><code>git branch -d branchName</code></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。<br>    假如 readme.txt 存在冲突。<br>第一步：打开 readme.txt 文件手动处理冲突<br>第二步：添加到暂存区 git add readme.txt<br>第三步：提交到当前分支 git commit -m ‘说明’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log --graph --pretty=oneline --abbrev-commit</div><div class="line">用带参数的git log也可以看到分支的合并情况</div><div class="line">用git log --graph命令可以看到分支合并图。</div></pre></td></tr></table></figure></p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev</div><div class="line">git add readme.txt </div><div class="line">git commit -m &quot;add merge&quot;</div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</div><div class="line">准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward。</div><div class="line">因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</div></pre></td></tr></table></figure></p><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>所有人都在 dev 分支上开发，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br>使用场景，在开发过程中新接收到一个bug需要紧急处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line">Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</div></pre></td></tr></table></figure></p><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git checkout -b issue-101</div></pre></td></tr></table></figure></p><h3 id="创建bug分支"><a href="#创建bug分支" class="headerlink" title="创建bug分支"></a>创建bug分支</h3><p>修复bug之后（提交修复bug相关的代码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git add readme.txt </div><div class="line">git commit -m &quot;fix bug 101&quot;</div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line">git branch -d issue-101</div></pre></td></tr></table></figure></p><p>现在需要切换到原来分支继续开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout dev</div><div class="line">git status</div><div class="line">git stash list</div></pre></td></tr></table></figure></p><p>PS：工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一种 git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除<br>一种 git stash pop，恢复的同时把stash内容也删了<br>PS：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>    当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br><code>git branch -D branchName</code><br>    强行删除一个没有合并的分支<br>PS：开发一个新feature，最好新建一个分支；<br>    如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。    </name></p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。<br><code>git remote</code><br>    查看远程库的信息（origin）<br><code>git remote -v</code><br>    显示更详细的信息，显示了可以抓取（fetch）和推送（push）的origin的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<br><code>git push origin master</code><br>    master 表示你要往远程那个分支推送<br>PS：一般 master、dev 分支需要推送到远程库，其它分支不需要。</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p><code>git branch --set-upstream dev origin/dev</code><br>    把本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接<br><code>git fetch</code><br>PS：相当于是从远程获取最新版本到本地，不会自动merge<br><code>git pull</code><br>PS：相当于是从远程获取最新版本并merge到本地（git fetch + git merge）<br>    把最新的提交从origin/dev抓下来（提交前需要拉取分支的最新代码）<br>手动处理冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;说明&quot;</div><div class="line">git push origin dev</div></pre></td></tr></table></figure></p><pre><code>推送到远程dev分支</code></pre><p>多人协作的工作模式的步骤：    </p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</li></ol><p>PS：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。    </p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。    </p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git checkout master</div><div class="line">切换到需要打标签的分支</div><div class="line">git tag tagName</div><div class="line">打标签</div><div class="line">git tag -a tagName </div><div class="line">-a 选项意为&quot;创建一个带注解的标签&quot;（谁打的，什么时候打的）</div><div class="line">git tag</div><div class="line">查看所有标签</div><div class="line">git tag tagName commitId</div><div class="line">给特定版本号打标签</div><div class="line">git show tagName</div><div class="line">查看标签信息</div><div class="line">git tag -a tagName -m &quot;说明&quot; commitId</div><div class="line">创建带有说明的标签，用-a指定标签名，-m指定说明文字</div><div class="line">git tag -s tagName -m &quot;说明&quot; commitId</div><div class="line">通过-s用私钥签名（PGP签名标签）一个标签</div></pre></td></tr></table></figure><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p><code>git tag -d tagName</code><br>    如果标签打错了，也可以删除<br>PS：因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git push origin tagName</div><div class="line">推送某一个标签到远端</div><div class="line">git push origin --tags</div><div class="line">推送全部尚未推送到远端的本地标签</div><div class="line">git tag -d tagName</div><div class="line">git push origin :refs/tags/tagName</div><div class="line">如果标签已经推送到远程，先本地删除，再远程删除。</div></pre></td></tr></table></figure></p><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;fanerge&quot;</div><div class="line">git config --global user.email fanerge@example.com</div><div class="line">配置用户信息</div><div class="line">git config --global color.ui true</div><div class="line">让Git显示颜色，会让命令输出看起来更醒目。</div><div class="line">git config --global core.editor notepad++</div><div class="line">配置文本编辑器</div><div class="line">git config --global merge.tool vimdiff</div><div class="line">配置差异分析工具</div><div class="line">git config --list</div><div class="line">查看全部配置信息</div><div class="line">git config configName</div><div class="line">查看单个配置信息</div></pre></td></tr></table></figure><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>创建一个特殊的.gitignore文件，把需要忽略的文件名填进去就可。<br>    在这个目录的文件<br>    <a href="https://github.com/github/gitignore" target="_blank" rel="external">所有配置文件可以直接在线浏览</a><br>忽略文件的原则是：<br>    忽略操作系统自动生成的文件，比如缩略图等；<br>    忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>    忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br>有时需要向git添加文件，但又添加不上，需要检查.gitignore哪里写错了<br><code>git check-ignore -v fileName</code><br>暴力向git添加文件<br><code>git add -f fileName // 不建议使用</code></p><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st status</div><div class="line">为status 设置为 st 别名</div><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>每个仓库的Git配置文件都放在.git/config文件中。<br>cat .git/config<br>    查看本仓库的配置</p><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">具体步骤</a><br><a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="external">管理公钥</a><br><a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">管理权限</a></p><h1 id="附上参考手册"><a href="#附上参考手册" class="headerlink" title="附上参考手册"></a>附上参考手册</h1><p><embed id="pdfPlayer" src="http://oxpnrlb4j.bkt.clouddn.com/git-cheatsheet.pdf" type="application/pdf" width="100%" height="500px">    </p><blockquote><p>   参考文档：<br>    <a href="https://git-scm.com/" target="_blank" rel="external">git官网</a><br>    <a href="http://www.runoob.com/manual/git-guide/" target="_blank" rel="external">git - 简明指南</a><br>    <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="external">廖雪峰-git教程</a><br>    <a href="http://www.runoob.com/git/git-basic-operations.html" target="_blank" rel="external">Git 教程</a><br>    <a href="http://blog.csdn.net/hudashi/article/details/7664457" target="_blank" rel="external">Git fetch和git pull的区别</a><br>    <a href="http://blog.csdn.net/ibingow/article/details/7541402" target="_blank" rel="external">git reflog</a><br>    <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解git</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git基础知识&quot;&gt;&lt;a href=&quot;#git基础知识&quot; class=&quot;headerlink&quot; title=&quot;git基础知识&quot;&gt;&lt;/a&gt;git基础知识&lt;/h1&gt;&lt;h2 id=&quot;git工作流&quot;&gt;&lt;a href=&quot;#git工作流&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="代码管理" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://fanerge.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>canvas开发参考手册</title>
    <link href="https://fanerge.github.io/canvas%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/canvas开发参考手册.html</id>
    <published>2018-01-03T13:20:06.000Z</published>
    <updated>2018-01-10T12:14:40.784Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://fanerge.github.io/canvas_solar_system/" width="700" height="350" frameborder="0"></iframe></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://fanerge.github.io/canvas_solar_system/">学完canvas的相关知识可以做一些小动画了</a><br>最早由Apple引入WebKit，用于Mac OS X 的 Dashboard。<br>canvas 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，交互式游戏，甚至可以进行实时视频处理或渲染。</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>canvas 它是一个元素，当然具有元素通用的属性，如id、class等。</p><h2 id="渲染上下文（The-rendering-context）"><a href="#渲染上下文（The-rendering-context）" class="headerlink" title="渲染上下文（The rendering context）"></a>渲染上下文（The rendering context）</h2><p>canvas 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 获取渲染上下文</div><div class="line">let canvas = document.querySelector(&apos;#canvas&apos;)</div><div class="line">let ctx = canvas.getContext(&apos;2d&apos;)</div></pre></td></tr></table></figure></p><h2 id="检查支持性"><a href="#检查支持性" class="headerlink" title="检查支持性"></a>检查支持性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (canvas.getContext) &#123;</div><div class="line">// 支持</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h1><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p>fillRect(x, y, width, height)<br>    绘制一个填充的矩形<br>strokeRect(x, y, width, height)<br>    绘制一个矩形的边框<br>clearRect(x, y, width, height)<br>    清除指定矩形区域，让清除部分完全透明。<br>    常用于清理画布。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p><ol><li>首先，你需要创建路径起始点。</li><li>然后你使用画图命令去画出路径。</li><li>之后你把路径封闭。</li><li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。<br>beginPath()<br>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br>closePath()<br>闭合路径之后图形绘制命令又重新指向到上下文中。<br>stroke() – 轮廓<br>通过线条来绘制图形轮廓。<br>fill() – 整体<br>通过填充路径的内容区域生成实心的图形。<br>PS：fill会自动闭合儿stroke不会。<br>moveTo(x, y) – 移动笔触<br>将笔触移动到指定的坐标x以及y上。<br>当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径<br>lineTo(x, y) – 直线<br>绘制一条从当前位置到指定x以及y位置的直线。<br>arc(x, y, radius, startAngle, endAngle, anticlockwise) – 圆弧<br>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。<br>arcTo(x1, y1, x2, y2, radius)<br>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。<br>PS：角度是以x轴为基准且为弧度，转化公式：radians=(Math.PI/180)*degrees<br>quadraticCurveTo(cp1x, cp1y, x, y) – 二次贝塞尔曲线<br>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) – 三次贝塞尔曲线<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。<br>PS：贝塞尔曲线都会以开始路径作为起点，实际上二次贝塞尔曲线由3个点控制，N次贝塞尔曲线由n+1个点控制。<br><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="external">wiki-贝塞尔曲线</a><br>绘制矩形的额外方法<br>rect(x, y, width, height)<br>绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。    <h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3>为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径。<br>Path2D()<br>Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。<br>Path2D.addPath(path [, transform])​<br>添加了一条路径到当前路径（可能添加了一个变换矩阵）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 使用 SVG paths</div><div class="line">var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);</div></pre></td></tr></table></figure></li></ol><h1 id="使用样式和颜色"><a href="#使用样式和颜色" class="headerlink" title="使用样式和颜色"></a>使用样式和颜色</h1><h2 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h2><p>fillStyle = color<br>    设置图形的填充颜色。<br>strokeStyle = color<br>    设置图形轮廓的颜色。<br>PS：orange、#ffa500、rgb(255, 165, 0)、rgba(255, 165, 0, 1)、hsl(360, 50%, 50%)、hsla(360, 50%, 50%, 1)</p><h2 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h2><p>globalAlpha = transparencyValue<br>    这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。<br>ctx.strokeStyle = “rgba(255,0,0,0.5)”;<br>ctx.fillStyle = “rgba(255,0,0,0.5)”;    </p><h2 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h2><p>可以通过一系列属性来设置线的样式。<br>lineWidth = value<br>    设置线条宽度。<br>    线宽是指给定路径的中心到两边距离之和的粗细。换句话说就是在路径的两边各绘制线宽的一半。<br>lineCap = type<br>    设置线条末端样式。<br>    butt，round 和 square。<br>    默认是 butt。<br>lineJoin = type<br>    设定线条与线条间接合处的样式。<br>    round, bevel 和 miter。<br>    默认是 miter。<br>miterLimit = value<br>    限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。<br>getLineDash()<br>    返回一个包含当前虚线样式，长度为非负偶数的数组。<br>    [a, b] a表示实线，b表示空白，这样交替出现。<br>setLineDash(segments)<br>    设置当前虚线样式。<br>lineDashOffset = value<br>    设置虚线样式的起始偏移量。</p><h2 id="渐变-Gradients（新建的渐变对象）"><a href="#渐变-Gradients（新建的渐变对象）" class="headerlink" title="渐变 Gradients（新建的渐变对象）"></a>渐变 Gradients（新建的渐变对象）</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>let lineargradient = createLinearGradient(x1, y1, x2, y2)<br>    createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</p><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>let radialgradient = createRadialGradient(x1, y1, r1, x2, y2, r2)<br>    createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。<br>gradient.addColorStop(position, color)<br>    addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。</p><h2 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h2><p>createPattern(image, type)<br>    该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。<br>    你需要确认 image 对象已经装载(onload)完毕，否则图案可能效果不对的。</p><h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h2><p>shadowOffsetX = float<br>    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。<br>shadowOffsetY = float<br>    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。<br>shadowBlur = float<br>    shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。<br>shadowColor = color<br>    shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</p><h2 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h2><p>当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。<br>“nonzero”: 默认值.<br>“evenodd”</p><h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p>canvas 提供了两种方法来渲染文本:<br>fillText(text, x, y [, maxWidth])<br>    在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.<br>strokeText(text, x, y [, maxWidth])<br>    在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</p><h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>font = value<br>    当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。<br>textAlign = value<br>    文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。<br>textBaseline = value<br>    基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。<br>direction = value<br>    文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</p><h2 id="先进的文本测量"><a href="#先进的文本测量" class="headerlink" title="先进的文本测量"></a>先进的文本测量</h2><p>当你需要获得更多的文本细节时，下面的方法可以给你测量文本的方法。<br>measureText()<br>    将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。<br><code>var text = ctx.measureText(&quot;foo&quot;); // TextMetrics objecttext.width; // 16;</code>    </p><h1 id="使用图像-Using-images"><a href="#使用图像-Using-images" class="headerlink" title="使用图像 Using images"></a>使用图像 Using images</h1><p>canvas更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。<br>引入图像到canvas里需要以下两步基本操作：    </p><ol><li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片（参见例子）</li><li>使用drawImage()函数将图片绘制到画布上<h2 id="获得需要绘制的图片"><a href="#获得需要绘制的图片" class="headerlink" title="获得需要绘制的图片"></a>获得需要绘制的图片</h2>HTMLImageElement<br>这些图片是由Image()函数构造出来的，或者任何的<img>元素<br>HTMLVideoElement<br>用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像<br>HTMLCanvasElement<br>可以使用另一个 <canvas> 元素作为你的图片源。<br>ImageBitmap<br>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。<br>PS：这些源统一由 CanvasImageSource类型来引用。    </canvas></video></li><li>使用相同页面内的图片<br>document.images集合<br>document.getElementsByTagName()方法<br>document.getElementById()获得这个图片    </li><li>使用其它域名下的图片<br>在 HTMLImageElement上使用crossOrigin属性，你可以请求加载其它域名上的图片。    </li><li>由零开始创建图像（需要onload保证图片加载完毕）<br><code>var img = new Image();   // 创建一个&lt;img&gt;元素img.src = &#39;myImage.png&#39;; // 设置图片源地址</code>    </li><li>通过 data: url 方式嵌入图像<br><code>img.src = &#39;data:image/gif;base64,...&#39;</code></li><li>使用视频帧<br><code>return document.getElementById(&#39;myvideo&#39;);</code>    <h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2>drawImage(image, x, y)<br>其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。    <h2 id="缩放-Scaling"><a href="#缩放-Scaling" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2>drawImage(image, x, y, width, height)<br>这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小<h2 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片 Slicing"></a>切片 Slicing</h2>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)<br>第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。    <h2 id="控制图像的缩放行为-Controlling-image-scaling-behavior"><a href="#控制图像的缩放行为-Controlling-image-scaling-behavior" class="headerlink" title="控制图像的缩放行为 Controlling image scaling behavior"></a>控制图像的缩放行为 Controlling image scaling behavior</h2>Gecko 1.9.2 引入了 mozImageSmoothingEnabled 属性，值为 false 时，图像不会平滑地缩放。默认是 true 。<br><code>cx.mozImageSmoothingEnabled = false;</code><h1 id="变形-Transformations"><a href="#变形-Transformations" class="headerlink" title="变形 Transformations"></a>变形 Transformations</h1><h2 id="状态的保存和恢复-Saving-and-restoring-state"><a href="#状态的保存和恢复-Saving-and-restoring-state" class="headerlink" title="状态的保存和恢复 Saving and restoring state"></a>状态的保存和恢复 Saving and restoring state</h2>save()restore()<br>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。<br>PS：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。    <h2 id="绘画状态包括："><a href="#绘画状态包括：" class="headerlink" title="绘画状态包括："></a>绘画状态包括：</h2>当前应用的变形（即移动，旋转和缩放，见下）<br>strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值<br>当前的裁切路径（clipping path）<h2 id="移动-Translating"><a href="#移动-Translating" class="headerlink" title="移动 Translating"></a>移动 Translating</h2>我们先介绍 translate 方法，它用来移动 canvas 和它的原点到一个不同的位置。<br>translate(x, y)<br>translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。<br>PS：在做变形之前先保存状态是一个良好的习惯。<br>在绘制螺旋（spirograph）图案，如果不使用 translate 方法，那么只能看见其中的四分之一。<h2 id="旋转-Rotating"><a href="#旋转-Rotating" class="headerlink" title="旋转 Rotating"></a>旋转 Rotating</h2>它用于以原点为中心旋转 canvas。<br>rotate(angle)<br>这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。<br>旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。<h2 id="缩放-Scaling-1"><a href="#缩放-Scaling-1" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2>我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。<br>scale(x, y)<br>scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。<br>PS：默认情况下，canvas 的 1 单位就是 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。<h2 id="变形-Transforms"><a href="#变形-Transforms" class="headerlink" title="变形 Transforms"></a>变形 Transforms</h2>允许对变形矩阵直接修改。<br>transform(m11, m12, m21, m22, dx, dy)<br>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：<br><code>m11 m21 dxm12 m22 dy0     0     1</code><br>m11：水平方向的缩放<br>m12：水平方向的偏移<br>m21：竖直方向的偏移<br>m22：竖直方向的缩放<br>dx：水平方向的移动<br>dy：竖直方向的移动<br>setTransform(m11, m12, m21, m22, dx, dy)<br>这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。<br>从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。<br>resetTransform()<br>重置当前变形为单位矩阵，它和调用以下语句是一样的：<br>ctx.setTransform(1, 0, 0, 1, 0, 0);<h1 id="组合-Compositing"><a href="#组合-Compositing" class="headerlink" title="组合 Compositing"></a>组合 Compositing</h1>对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。此外, clip属性允许我们隐藏不想看到的部分图形.    <h2 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h2>globalCompositeOperation = type<br>这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。<br>具体type值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">source-over默认。在目标图像上显示源图像。</div><div class="line">source-atop在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。</div><div class="line">source-in在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。</div><div class="line">source-out在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。</div><div class="line">destination-over在源图像上方显示目标图像。</div><div class="line">destination-atop在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。</div><div class="line">destination-in在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。</div><div class="line">destination-out在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。</div><div class="line">lighter显示源图像 + 目标图像。</div><div class="line">copy显示源图像。忽略目标图像。</div><div class="line">xor使用异或操作对源图像与目标图像进行组合。</div></pre></td></tr></table></figure></li></ol><h2 id="裁切路径-Clipping-paths"><a href="#裁切路径-Clipping-paths" class="headerlink" title="裁切路径 Clipping paths"></a>裁切路径 Clipping paths</h2><p>裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。<br>clip()<br>    来创建一个新的裁切路径。<br>    默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p><h1 id="基本的动画"><a href="#基本的动画" class="headerlink" title="基本的动画"></a>基本的动画</h1><p>如果需要移动Canvas中的shape，我们不得不对所有东西（包括之前的）进行重绘。重绘是相当费时的，而且性能很依赖于电脑的速度。    </p><h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><p>1.清空 canvas<br>    除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。<br>2.保存 canvas 状态<br>    如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。<br>3.绘制动画图形（animated shapes）<br>    这一步才是重绘动画帧。<br>4.恢复 canvas 状态<br>    如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。    </p><h2 id="操控动画-Controlling-an-animation"><a href="#操控动画-Controlling-an-animation" class="headerlink" title="操控动画 Controlling an animation"></a>操控动画 Controlling an animation</h2><p>为了实现动画，我们需要一些可以定时执行重绘的方法。</p><h3 id="有安排的更新画布-Scheduled-updates"><a href="#有安排的更新画布-Scheduled-updates" class="headerlink" title="有安排的更新画布 Scheduled updates"></a>有安排的更新画布 Scheduled updates</h3><p>window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。<br>requestAnimationFrame(callback)<br>    方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。<br>    该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。<br>window.cancelAnimationFrame(ID)<br>    以取消回调函数。    </p><h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><h3 id="添加速率"><a href="#添加速率" class="headerlink" title="添加速率"></a>添加速率</h3><p>window.requestAnimationFrame(callback) 该方式帮助我们控制动画。<br>ctx.clearRect(0,0, canvas.width, canvas.height) 在callback前面调用清除画布。    </p><h3 id="设置边界"><a href="#设置边界" class="headerlink" title="设置边界"></a>设置边界</h3><p>物体碰到边缘，反弹回来，将速度更换方向即可。<br><code>if (ball.y + ball.vy &gt; canvas.height || ball.y + ball.vy &lt; 0 ) {    ball.vy = -ball.vy;}</code><br>PS：这里对垂直方向上分析，水平方向类似。<br>小球的y坐标+小球y的速度大于canvas的高度（下边缘）或者小球的y坐标+小球y的速度小于0（上边缘）反向</p><h3 id="添加加速度"><a href="#添加加速度" class="headerlink" title="添加加速度"></a>添加加速度</h3><p><code>ball.vy *= .99;ball.vy += .25;</code>    </p><h3 id="长尾效果"><a href="#长尾效果" class="headerlink" title="长尾效果"></a>长尾效果</h3><p>用一个半透明的 fillRect 函数取代之，就可轻松制作长尾效果。<br><code>ctx.fillStyle = &#39;rgba(255,255,255,0.3)&#39;;ctx.fillRect(0,0,canvas.width,canvas.height);</code>    </p><h3 id="添加鼠标控制"><a href="#添加鼠标控制" class="headerlink" title="添加鼠标控制"></a>添加鼠标控制</h3><p>为canvas元素添加 mousemove、 mouseout、click等事件，在通过 canvas 的 shape 来进行精确控制</p><h2 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h2><p>可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。    </p><h3 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h3><p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：<br>width<br>    图片宽度，单位是像素<br>height<br>    图片高度，单位是像素<br>data<br>    Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。<br>    每一个像素又数组4为组成，分别对应r、g、b、a</p><h3 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h3><p>去创建一个新的，空白的ImageData对象，你应该会使用createImageData() 方法。有2个版本的createImageData()方法。<br>var myImageData = ctx.createImageData(width, height);<br>    上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。<br>var myImageData = ctx.createImageData(anotherImageData);<br>    你也可以创建一个被anotherImageData对象指定的相同像素的ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。</p><h3 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h3><p>为了获得一个包含画布场景像素数据的ImageData对像，你可以用getImageData()方法：<br>var myImageData = ctx.getImageData(left, top, width, height);<br>    这个方法会返回一个ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为(left, top), (left + width, top), (left, top + height), 以及(left + width, top + height)四个点。这些坐标点被设定为画布坐标空间元素。</p><h3 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h3><p>你可以用putImageData()方法去对场景进行像素数据的写入。<br>ctx.putImageData(myImageData, dx, dy);<br>    dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标。</p><h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p>在drawImage() 方法， 第二个画布和imageSmoothingEnabled 属性的帮助下，我们可以放大显示我们的图片及看到详情内容。<br>因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。<br>禁用反锯齿<br><code>ctx.imageSmoothingEnabled = false;ctx.mozImageSmoothingEnabled = true;ctx.webkitImageSmoothingEnabled = true;ctx.msImageSmoothingEnabled = true;</code>        </p><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>HTMLCanvasElement  提供一个toDataURL()方法，此方法在保存图片的时候非常有用。<br>它返回一个包含被类型参数规定的图像表现格式的数据链接。返回的图片分辨率是96dpi。<br>canvas.toDataURL(‘image/png’)<br>    默认设定。创建一个PNG图片。<br>canvas.toDataURL(‘image/jpeg’, quality)<br>    创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。<br>canvas.toBlob(callback, type, encoderOptions)<br>    这个创建了一个在画布中的代表图片的Blob对像。<br>PS：这里是canvas对象上的方法，而不是画布上下文对象的方法。    </p><h2 id="点击区域和无障碍访问"><a href="#点击区域和无障碍访问" class="headerlink" title="点击区域和无障碍访问"></a>点击区域和无障碍访问</h2><p>canvas 标签只是一个位图，它并不提供任何已经绘制在上面的对象的信息。    </p><h3 id="内容兼容"><a href="#内容兼容" class="headerlink" title="内容兼容"></a>内容兼容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas&gt; ... &lt;/canvas&gt;标签里的内容被可以对一些不支持canvas的浏览器提供兼容。</div></pre></td></tr></table></figure><h3 id="ARIA-规则"><a href="#ARIA-规则" class="headerlink" title="ARIA 规则"></a>ARIA 规则</h3><p>Accessible Rich Internet Applications (ARIA) 定义了让Web内容和Web应用更容易被有身体缺陷的人获取的办法。你可以用ARIA属性来描述canvas元素的行为和存在目的    </p><h3 id="点击区域（hit-region）"><a href="#点击区域（hit-region）" class="headerlink" title="点击区域（hit region）"></a>点击区域（hit region）</h3><p>判断鼠标坐标是否在canvas上一个特定区域里一直是个有待解决的问题。hit region API让你可以在canvas上定义一个区域，这让无障碍工具获取canvas上的交互内容成为可能。它能让你更容易地进行点击点击检测并把事件转发到DOM元素去。这个API有以下三个方法（都是实验性特性，请先在浏览器兼容表上确认再使用）。<br>CanvasRenderingContext2D.addHitRegion()<br>    在canvas上添加一个点击区域。<br>    ctx.addHitRegion({control: element});<br>    addHitRegion()方法也可以带一个control选项来指定把事件转发到哪个元素上（canvas里的元素）。<br>ctx.removeHitRegion()<br>    从canvas上移除指定id的点击区域。<br>ctx.clearHitRegions()<br>    移除canvas上的所有点击区域。<br>PS：实验性方法，浏览器暂不支持    </p><h2 id="焦点圈"><a href="#焦点圈" class="headerlink" title="焦点圈"></a>焦点圈</h2><p>当用键盘控制时，焦点圈是一个能帮我们在页面上快速导航的标记。要在canvas上绘制焦点圈，可以使用drawFocusIfNeeded 属性。<br>ctx.drawFocusIfNeeded()<br>    如果给定的元素获得了焦点，这个方法会沿着在当前的路径画个焦点圈。<br>ctx.scrollPathIntoView()<br>    把当前的路径或者一个给定的路径滚动到显示区域内。<br>    scrollPathIntoView()方法可以让一个元素获得焦点的时候在屏幕上可见(滚动到元素所在的区域)。    </p><h2 id="canvas的优化"><a href="#canvas的优化" class="headerlink" title="canvas的优化"></a>canvas的优化</h2><h3 id="性能贴士"><a href="#性能贴士" class="headerlink" title="性能贴士"></a>性能贴士</h3><p>下面是一些改善性能的建议    </p><ol><li><p>在离屏canvas上预渲染相似的图形或重复的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myEntity.offscreenCanvas = document.createElement(&quot;canvas&quot;);</div><div class="line">myEntity.offscreenCanvas.width = myEntity.width;</div><div class="line">myEntity.offscreenCanvas.height = myEntity.height;</div><div class="line">myEntity.offscreenContext = myEntity.offscreenCanvas.getContext(&quot;2d&quot;);</div><div class="line">myEntity.render(myEntity.offscreenContext);</div></pre></td></tr></table></figure></li><li><p>避免浮点数的坐标点，用整数取而代之    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">当你画一个没有整数坐标点的对象时会发生子像素渲染。</div><div class="line">ctx.drawImage(myImage, 0.3, 0.5);</div><div class="line">浏览器为了达到抗锯齿的效果会做额外的运算。为了避免这种情况，请保证在你调用drawImage()函数时，用Math.floor()函数对所有的坐标点取整。</div></pre></td></tr></table></figure></li><li><p>不要在用drawImage时缩放图像（多个 canvas 元素）<br>在离屏canvas中缓存图片的不同尺寸，而不要用drawImage()去缩放它们。        </p></li><li>使用多层画布去画一个复杂的场景<br>你可能会发现，你有些元素不断地改变或者移动，而其它的元素，例如外观，永远不变。这种情况的一种优化是去用多个画布元素去创建不同层次。    <h3 id="用CSS设置大的背景图"><a href="#用CSS设置大的背景图" class="headerlink" title="用CSS设置大的背景图"></a>用CSS设置大的背景图</h3>如果像大多数游戏那样，你有一张静态的背景图，用一个静态的<div>元素，结合background 特性，以及将它置于画布元素之后。这么做可以避免在每一帧在画布上绘制大图。    </div></li><li>用CSS transforms特性缩放画布<br>CSS transforms 特性由于调用GPU，因此更快捷。最好的情况是，不要将小画布放大，而是去将大画布缩小。    </li><li>使用moz-opaque属性(仅限Gecko)<br>如果你的游戏使用画布而且不需要透明，请在画布上设置moz-opaque属性。这能够用于内部渲染优化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;mycanvas&quot; moz-opaque&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure></li></ol><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）<br>避免不必要的画布状态改变<br>渲染画布中的不同点，而非整个新状态<br>尽可能避免 shadowBlur特性<br>尽可能避免text rendering<br>使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)<br>有动画，请使用window.requestAnimationFrame() 而非window.setInterval()<br>请谨慎使用大型物理库<br>用JSPerf测试性能<br><a href="https://fanerge.github.io/canvas_solar_system/">demo地址</a><br><a href="https://antv.alipay.com/zh-cn/index.html" target="_blank" rel="external">这里向大家推荐一下阿里开源的数据可视化库antV（g2、g6、f2）</a></p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">MDN-canvas教程</a><br>    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449990549914b596ac1da54a228a6fa9643e88bc0c000" target="_blank" rel="external">廖雪峰老师的Canvas</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="external">MDN-canvas标签</a><br>    <a href="https://segmentfault.com/a/1190000004469449" target="_blank" rel="external">Canvas 的基本原理</a><br>    <a href="http://www.webhek.com/post/html5-canvas-cheat-sheet.html" target="_blank" rel="external">HTML5画布(CANVAS)速查简表</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://fanerge.github.io/canvas_solar_system/&quot; width=&quot;700&quot; height=&quot;350&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>移动端总结</title>
    <link href="https://fanerge.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/移动端总结.html</id>
    <published>2017-12-27T12:09:35.000Z</published>
    <updated>2017-12-27T14:34:24.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;</code><br>    width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。<br>    height：和 width 相对应，指定高度。<br>    initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。<br>    maximum-scale：允许用户缩放到的最大比例。<br>    minimum-scale：允许用户缩放到的最小比例。<br>    user-scalable：用户是否可以手动缩放。</p><h3 id="IOS中safari允许全屏浏览"><a href="#IOS中safari允许全屏浏览" class="headerlink" title="IOS中safari允许全屏浏览"></a>IOS中safari允许全屏浏览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div><div class="line">&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;</div><div class="line">```</div><div class="line">###IOS中Safari顶端状态条样式</div><div class="line">`&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;`</div><div class="line">PS：如果要去除全部的，就把default ：状态栏背景是白色。</div><div class="line">black ：状态栏背景是黑色。</div><div class="line">black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。</div><div class="line">如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。</div><div class="line">###忽略将数字变为电话号码</div><div class="line">`&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;`</div><div class="line">###忽略识别email</div><div class="line">`&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; &gt;`</div><div class="line">###添加到主屏后的标题（IOS）</div><div class="line">`&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;`</div><div class="line">###百度禁止转码</div><div class="line">`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;`</div><div class="line">###优先使用最新版本 IE 和 Chrome</div><div class="line">`&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;`</div><div class="line">###设置缓存</div><div class="line">`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;`</div><div class="line">##小技巧</div><div class="line">###select 下拉选择设置右对齐</div></pre></td></tr></table></figure><p>select option {<br>    direction: rtl;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###消除 IE10 里面的那个叉号</div><div class="line">`input:-ms-clear&#123;display:none;&#125;`</div><div class="line">###关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)</div></pre></td></tr></table></figure></p><p>-webkit-text-size-adjust: 100%;<br>-ms-text-size-adjust: 100%;<br>text-size-adjust: 100%;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">###关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</div><div class="line">可以通过正则去掉</div><div class="line">`this.value = this.value.replace(/\u2006/g, &apos;&apos;);`</div><div class="line">###移动端 HTML5 input date 不支持 placeholder 问题</div><div class="line">`&lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot;  id=&quot;date&quot;&gt;`</div><div class="line">###部分机型存在type为search的input，自带close按钮样式修改方法</div></pre></td></tr></table></figure></p><p>#Search::-webkit-search-cancel-button{<br>    display: none;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###开启电话功能和短信和发邮件</div></pre></td></tr></table></figure></p><p><a href="tel:123456" target="_blank" rel="external">123456</a><br><a href="sms:123456" target="_blank" rel="external">123456</a><br>&lt;a mailto:dooyoe@gmail.com”&gt;dooyoe@gmail.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">###IOS Web app启动动画</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-640x960.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-2048x1496.png&quot; media=&quot;(device-width: 1536px)  and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">（landscape：横屏 | portrait：竖屏）</div><div class="line">###添加到主屏后的APP图标</div></pre></td></tr></table></figure></p><!-- 设计原图 --> <p><link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed"><br><!-- 添加高光效果 --> </p><p><link href="short_cut_114x114.png" rel="apple-touch-icon"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###去除webkit的滚动条</div></pre></td></tr></table></figure></p><p>element::-webkit-scrollbar{<br>    display: none;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PS：如果要去除全部的，就把 element去掉。</div><div class="line">添加这个属性滚动如丝般顺滑： -webkit-overflow-scrolling : touch;</div><div class="line">###去除button在ios上的默认样式</div><div class="line">```</div><div class="line">-webkit-appearance: none;</div><div class="line">border-radius: 0;</div></pre></td></tr></table></figure></p><h3 id="长时间按住页面出现闪退"><a href="#长时间按住页面出现闪退" class="headerlink" title="长时间按住页面出现闪退"></a>长时间按住页面出现闪退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element &#123;</div><div class="line">-webkit-touch-callout: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Retina屏的1px边框"><a href="#Retina屏的1px边框" class="headerlink" title="Retina屏的1px边框"></a>Retina屏的1px边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element&#123;</div><div class="line">border-width: thin;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="transition闪屏"><a href="#transition闪屏" class="headerlink" title="transition闪屏"></a>transition闪屏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/设置内嵌的元素在 3D 空间如何呈现：保留3D /</div><div class="line">-webkit-transform-style: preserve-3d;</div><div class="line">/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /</div><div class="line">-webkit-backface-visibility:hidden;</div></pre></td></tr></table></figure><h3 id="旋转屏幕时，字体大小调整的问题"><a href="#旋转屏幕时，字体大小调整的问题" class="headerlink" title="旋转屏幕时，字体大小调整的问题"></a>旋转屏幕时，字体大小调整的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123;</div><div class="line">-webkit-text-size-adjust:100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="placeholder元素样式的修改"><a href="#placeholder元素样式的修改" class="headerlink" title="placeholder元素样式的修改"></a>placeholder元素样式的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">input::-webkit-input-placeholder&#123;color:red;&#125;</div><div class="line">input:focus::-webkit-input-placeholder&#123;color:green;&#125;</div></pre></td></tr></table></figure><h3 id="不想让按钮-touch时有蓝色的边框或半透明灰色遮罩"><a href="#不想让按钮-touch时有蓝色的边框或半透明灰色遮罩" class="headerlink" title="不想让按钮 touch时有蓝色的边框或半透明灰色遮罩"></a>不想让按钮 touch时有蓝色的边框或半透明灰色遮罩</h3><p>对于a,button,input,textarea<br><code>-webkit-tap-highlight-color:rgba(0,0,0,0);</code></p><h3 id="移动端做动画效果采用css3"><a href="#移动端做动画效果采用css3" class="headerlink" title="移动端做动画效果采用css3"></a>移动端做动画效果采用css3</h3><p>transition、transform（scale、translate、rotate、skew）或者 animation<br>动画尽量少用margin、top等集合属性，因为这样会触发浏览器重排（reflow）</p><h3 id="使用图片时去除图片下4px的空白"><a href="#使用图片时去除图片下4px的空白" class="headerlink" title="使用图片时去除图片下4px的空白"></a>使用图片时去除图片下4px的空白</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img&#123;display:block&#125;；</div><div class="line">img&#123;vertical-align:top&#125;</div></pre></td></tr></table></figure><h3 id="如何禁止保存或拷贝图像（IOS）"><a href="#如何禁止保存或拷贝图像（IOS）" class="headerlink" title="如何禁止保存或拷贝图像（IOS）"></a>如何禁止保存或拷贝图像（IOS）</h3><p><code>img { -webkit-touch-callout: none; }</code></p><h3 id="手机拍照和上传图片"><a href="#手机拍照和上传图片" class="headerlink" title="手机拍照和上传图片"></a>手机拍照和上传图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 选择照片 --&gt; </div><div class="line">&lt;input type=file accept=&quot;image/*&quot;&gt; </div><div class="line">&lt;!-- 选择视频 --&gt; </div><div class="line">&lt;input type=file accept=&quot;video/*&quot;&gt;</div></pre></td></tr></table></figure><h3 id="弹性盒子的过渡"><a href="#弹性盒子的过渡" class="headerlink" title="弹性盒子的过渡"></a>弹性盒子的过渡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display:-webkit-box; // 早期的版本</div><div class="line">display:-webkit-box-flex; // 过渡版本</div><div class="line">display:-webkit-flex; // 最新的版本</div></pre></td></tr></table></figure><h3 id="禁止用户选中文字"><a href="#禁止用户选中文字" class="headerlink" title="禁止用户选中文字"></a>禁止用户选中文字</h3><p><code>-webkit-user-select:none;</code></p><h3 id="定义新的盒模型"><a href="#定义新的盒模型" class="headerlink" title="定义新的盒模型"></a>定义新的盒模型</h3><p><code>box-sizing:border-box</code></p><h3 id="css权重（逐次降低）"><a href="#css权重（逐次降低）" class="headerlink" title="css权重（逐次降低）"></a>css权重（逐次降低）</h3><pre><code>style--1000!importantid--100class--10标签--1</code></pre><h3 id="使用rem"><a href="#使用rem" class="headerlink" title="使用rem"></a>使用rem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">font-size: 625%; // 相当于 12px *6.25 = 100px</div><div class="line">&#125;</div><div class="line">以后的元素的width、height、padding等集合属性都可以用rem来表示。</div><div class="line">```</div><div class="line">###移动端字体</div><div class="line">`font-family: Helvetica,sans-serif;`</div><div class="line">###iphone原生键盘统计字数时</div><div class="line">在 iphone原生键盘上用 keyup统计字符数时，系统不会自动监控你选择文字的事件，应该使用input事件。</div><div class="line">###毛玻璃效果</div><div class="line">实现毛玻璃效果，透过背景看其他元素模糊，自身元素不模糊。</div></pre></td></tr></table></figure><p>-webkit-backdrop-filter: saturate(180%) blur(20px);<br>background: rgba(0,0,0,0.5);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###需要展示小于12px的文字</div><div class="line">`transform:scale(%);`</div><div class="line">###禁止IOS弹出各种操作窗口及关闭自动大写与自动修正</div></pre></td></tr></table></figure></p><p>-webkit-touch-callout:none</p><p><input type="text" autocapitalize="off" autocorrect="off"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">###Andriod 上去掉语音输入按钮</div><div class="line">`input::-webkit-input-speech-button &#123;display: none&#125;`</div><div class="line">#js部分</div><div class="line">##移动端事件</div><div class="line">click事件有300ms的延迟</div><div class="line">###触摸事件touch类事件</div><div class="line">touchstart：手指触摸到屏幕会触发</div><div class="line">touchmove：当手指在屏幕上移动时，会触发</div><div class="line">touchend：当手指离开屏幕时，会触发</div><div class="line">touchcancel：可由系统进行的触发，比如手指触摸屏幕的时候，突然alert了一下，或者系统中其他打断了touch的行为，则可以触发该事件</div><div class="line">###敲击事件tap类事件</div><div class="line">tap: 手指碰一下屏幕会触发</div><div class="line">longTap: 手指长按屏幕会触发</div><div class="line">singleTap: 手指碰一下屏幕会触发</div><div class="line">doubleTap: 手指双击屏幕会触发</div><div class="line">###swipe类事件</div><div class="line">swipe：手指在屏幕上滑动时会触发</div><div class="line">swipeLeft：手指在屏幕上向左滑动时会触发</div><div class="line">swipeRight：手指在屏幕上向右滑动时会触发</div><div class="line">swipeUp：手指在屏幕上向上滑动时会触发</div><div class="line">swipeDown：手指在屏幕上向下滑动时会触发</div><div class="line">###旋转屏幕事件</div><div class="line">`onorientationchange`</div><div class="line">###audio、video默认播放事件</div><div class="line">window.onload或计时器等都不能触发播放，必须用 JS写事件让用户手动点击触发才会开始播放</div></pre></td></tr></table></figure></p><p>$(document).one(‘touchstart’,function(){<br>    audio.play();<br>})<br>```</p><h3 id="移动事件三方库"><a href="#移动事件三方库" class="headerlink" title="移动事件三方库"></a>移动事件三方库</h3><p><a href="http://hammerjs.github.io" target="_blank" rel="external">Hammer.JS</a><br><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="external">FastClick</a></p><p>参考文档：<br>    <a href="https://www.cnblogs.com/imwtr/p/5882166.html" target="_blank" rel="external">移动端前端常见的触摸相关事件touch、tap、swipe等整理</a><br>    <a href="http://mp.weixin.qq.com/s/KpRaX4gPnqvadIZijSmYSQ" target="_blank" rel="external">web前端 —— 移动端知识的一些总结</a><br>    <a href="http://web.jobbole.com/85132/" target="_blank" rel="external">移动端事件介绍</a><br>    <a href="http://www.imooc.com/article/1115" target="_blank" rel="external">移动端web开发技巧</a><br>    <a href="https://masonry.desandro.com/" target="_blank" rel="external">瀑布流框架</a><br>    <a href="http://www.jb51.net/article/84973.htm" target="_blank" rel="external">倾力总结40条常见的移动端Web页面问题解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;css部分&quot;&gt;&lt;a href=&quot;#css部分&quot; class=&quot;headerlink&quot; title=&quot;css部分&quot;&gt;&lt;/a&gt;css部分&lt;/h1&gt;&lt;h2 id=&quot;meta标签&quot;&gt;&lt;a href=&quot;#meta标签&quot; class=&quot;headerlink&quot; title=&quot;m
      
    
    </summary>
    
      <category term="移动端" scheme="https://fanerge.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="https://fanerge.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识学习</title>
    <link href="https://fanerge.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://fanerge.github.io/java基础知识学习.html</id>
    <published>2017-12-26T12:25:18.000Z</published>
    <updated>2017-12-26T13:44:31.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用指令介绍"><a href="#常用指令介绍" class="headerlink" title="常用指令介绍"></a>常用指令介绍</h1><p>javac HelloWorld.java – 该命令用于将 java 源文件编译为 class 字节码文件，如： javac HelloWorld.java。如果成功编译没有错误的话，会出现一个 HelloWorld.class 的文件。<br>java HelloWorld – java 后面跟着的是java文件中的类名,例如 HelloWorld 就是类名，如: java HelloWorld。</p><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>JAVA_HOME：JDK安装在C:\jdk1.6.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串<br>path 变量：path 变量使得我们能够在系统中的任何地方运行java应用程序，比如 javac、java、javah 等等,这就要找到我们安装 JDK 的目录，假设我们的JDK安装在 C:\jdk1.6.0 目录下,那么在 C:\jdk1.6.0\bin 目录下就是我们常用的 java 应用程序,我们就需要把 C:\jdk1.6.0\bin 这个目录加到 path 环境变量里面。<br>classpath 变量：classpath 环境变量，是当我们在开发java程序时需要引用别人写好的类时，要让 java 解释器知道到哪里去找这个类。通常，sun 为我们提供了一些额外的丰富的类包，一个是 dt.jar，一个是 tools.jar，这两个 jar 包都位于 C:\jdk1.6.0\lib 目录下，所以通常我们都会把这两个 jar 包加到我们的 classpath 环境变量中 set classpath=.;C:\jdk1.6.0\lib\tools.jar;C:\jdk1.6.0\lib\dt.jar。    </p><h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><p>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>类：类是一个模板，它描述一类对象的行为和状态。<br>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。<br>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。<br>类名：对于所有的类来说，都使用大驼峰。<br>方法名：所有的方法名都应该使用小驼峰。<br>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。<br>主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。</p><h2 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h2><p>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。<br>跟其他语言类似。</p><h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><p>Java可以使用修饰符来修饰类中方法和属性。<br>访问控制修饰符 : default, public , protected, private<br>非访问控制修饰符 : final, abstract, strictfp</p><h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><p>局部变量<br>类变量（静态变量）<br>成员变量（非静态变量）</p><h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>数组是储存在堆上的对象，可以保存多个同类型变量。<br>这里有别于js的数组，同类型限制。</p><h2 id="Java枚举"><a href="#Java枚举" class="headerlink" title="Java枚举"></a>Java枚举</h2><p>枚举限制变量只能是预先设定好的值。<br>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>这些保留字不能用于常量、变量、和任何标识符的名称。<br>跟其他语言类似。</p><h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><p>单行 //<br>多行 /**/</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。<br>被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Java中，接口可理解为对象间相互通信的协议。<br>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h1 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h1><p>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br>类：类是一个模板，它描述一类对象的行为和状态。</p><h2 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Dog&#123;</div><div class="line">  String breed; // 成员变量</div><div class="line">  int age;</div><div class="line">  String color;</div><div class="line">  </div><div class="line">  // 构造方法</div><div class="line">  public Dog(String name)&#123;</div><div class="line">       // 这个构造器仅有一个参数：name</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // 入口函数</div><div class="line">  public static void main(String []args)&#123;</div><div class="line">// 下面的语句将创建一个Dog对象</div><div class="line">Dog myDog = new Dog( &quot;tommy&quot; );</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  Static demo; // 类变量</div><div class="line">  void barking()&#123;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  void hungry()&#123;</div><div class="line">String dd; // 局部变量</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  void sleeping()&#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。<br>成员变量：成员变量是定义在类中，方法体之外的变量。<br>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的名称必须与类同名，一个类可以有多个构造方法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Dog(String name)&#123;</div><div class="line">     // 这个构造器仅有一个参数：name</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">muDog = new Dog();</div><div class="line">/* 访问类中的变量 */</div><div class="line">muDog.breed;</div><div class="line">/* 访问类中的方法 */</div><div class="line">muDog.hungry();</div></pre></td></tr></table></figure></code></pre><h2 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h2><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。<br>    一个源文件中只能有一个public类<br>    一个源文件可以有多个非public类<br>    源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。<br>    如果一个类定义在某个包中，那么package语句应该在源文件的首行。<br>    如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。<br>    import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p><h2 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h2><p>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><h2 id="Import语句"><a href="#Import语句" class="headerlink" title="Import语句"></a>Import语句</h2><p>Import语句用来提供一个合理的路径，使得编译器可以找到某个类。<br>例如，下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类 import java.io.*;</p><h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。<br>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。<br>Java 的两大数据类型:<br>    内置数据类型<br>    引用数据类型</p><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>    范围：-128（-2^7） 到 127（2^7-1）；<br>    byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>    例子：byte a = 100，byte b = -50。</p><h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>    范围：-32768（-2^15） 到 32767（2^15 - 1）；<br>    Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>    例子：short s = 1000，short r = -20000。</p><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>    范围：-2,147,483,648（-2^31） 到 2,147,483,647（2^31 - 1）；<br>    一般地整型变量默认为 int 类型；<br>    例子：int a = 100000, int b = -200000。</p><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>    范围：-9,223,372,036,854,775,808（-2^63） 到 9,223,372,036,854,775,807（2^63 -1）；<br>    这种类型主要使用在需要比较大整数的系统上；<br>    例子： long a = 100000L，Long b = -200000L。</p><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>    float 在储存大型浮点数组的时候可节省内存空间；<br>    浮点数不能用来表示精确的值，如货币；<br>    例子：float f1 = 234.5f。</p><h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>    浮点数的默认类型为double类型；<br>    double类型同样不能表示精确的值，如货币；<br>    例子：double d1 = 123.4d 或者 123.4。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>boolean数据类型表示一位的信息；<br>    只有两个取值：true 和 false；<br>    默认值是 false；<br>    例子：boolean one = true。</p><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>char类型是一个单一的 16 位 Unicode 字符；<br>    范围：\u0000（即为0） 到 \uffff（即为65,535）；<br>    char 数据类型可以储存任何字符；<br>    例子：char letter = ‘A’;。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><pre><code>对象、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。例子：Site site = new Site(&quot;Runoob&quot;)。</code></pre><h2 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h2><p>常量在程序运行时是不能被修改的。<br>    在 Java 中使用 final 关键字来修饰常量。<br>    final double PI = 3.1415927;</p><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>转换从低级到高级。<br>低  ————————————&gt;  高<br>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double     </p><h2 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。<br>强制类型转换</p><pre><code>1. 条件是转换的数据类型必须是兼容的。2. 格式：(type)value type是要强制类型转换后的数据类型。        </code></pre><p>隐含强制类型转换    </p><pre><code>1. 整数的默认类型是 int。2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。</code></pre><h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的变量在使用前必须声明。<br>    声明格式：type identifier [ = value][, identifier [= value] …] ;<br>Java语言支持的变量类型有：<br>    类变量：独立于方法之外的变量，用 static 修饰。<br>    实例变量：独立于方法之外的变量，不过没有 static 修饰。<br>    局部变量：类的方法中的变量。</p><h2 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h2><pre><code>局部变量声明在方法、构造方法或者语句块中；局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；访问修饰符不能用于局部变量；局部变量只在声明它的方法、构造方法或者语句块中可见；局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</code></pre><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p>实例变量声明在一个类中，但在方法、构造方法和语句块之外；<br>当一个对象被实例化之后，每个实例变量的值就跟着确定；<br>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；<br>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；<br>实例变量可以声明在使用前或者使用后；<br>访问修饰符可以修饰实例变量；<br>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；<br>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；<br>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这个实例变量对子类可见</div><div class="line">public String name;</div><div class="line">// 私有变量，仅在该类可见</div><div class="line">private double salary;</div></pre></td></tr></table></figure></p><h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。<br>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。<br>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。<br>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。<br>静态变量在程序开始时创建，在程序结束时销毁。<br>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。<br>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。<br>静态变量可以通过：ClassName.VariableName的方式访问。<br>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</p><h1 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h1><p>Java语言提供了很多修饰符，主要分为以下两类：<br>    访问修饰符<br>    非访问修饰符</p><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Javav支持 4 种不同的访问权限。<br>    权限有4中：当前类、同一包内、子孙类、其他包<br>    public : 对所有类可见。使用对象：类、接口、变量、方法。<br>    protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>    default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>    private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>访问控制和继承<br>    父类中声明为 public 的方法在子类中也必须为 public。<br>    父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。<br>    父类中声明为 private 的方法，不能够被继承。</p><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>static 修饰符，用来修饰类方法和类变量。<br>final final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>    类中的 final 方法可以被子类继承，但是不能被子类修改。<br>abstract 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>    抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>synchronized 关键字声明的方法同一时间只能被一个线程访问。<br>transient 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>volatile volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><pre><code>算术运算符关系运算符位运算符逻辑运算符赋值运算符其他运算符instanceof 运算符    该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。    ( Object reference variable ) instanceof  (class/interface type)类别    操作符    关联性后缀    () [] . (点操作符)    左到右一元    ++ -- ！~    从右到左乘性     * /％    左到右加性     + -    左到右移位     &gt;&gt; &gt;&gt;&gt;  &lt;&lt;     左到右关系     &gt;&gt; = &lt;&lt; =     左到右相等     ==  !=    左到右按位与    ＆    左到右按位异或    ^    左到右按位或    |    左到右逻辑与    &amp;&amp;    左到右逻辑或    | |    左到右条件    ？：    从右到左赋值    = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =    从右到左逗号    ，    左到右</code></pre><p>注：只有一元、条件（三目）、赋值运算符关联性为从右向左，其余全是从左向右    </p><h1 id="Java-循环结构"><a href="#Java-循环结构" class="headerlink" title="Java 循环结构"></a>Java 循环结构</h1><pre><code>while 循环do…while 循环    对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。    do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。for 循环Java 增强 for 循环（对于数组）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(声明语句 : 表达式)</div><div class="line">&#123;</div><div class="line">   //代码句子</div><div class="line">&#125;</div></pre></td></tr></table></figure>break 关键字    break 主要用在循环语句或者 switch 语句中。    break 在循环语句中作用是跳出本层（并非本次）的循环。    break 在switch语句中作用是跳出该switch语句体。continue 关键字    continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。    在 for 循环中，continue 语句使程序立即跳转到更新语句i++。    在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。return 关键字    返回数据给函数的调用者。    函数一旦执行到了return关键字，那么该函数马上结束。 (能结束一个函数)</code></pre><h1 id="Java-分支结构"><a href="#Java-分支结构" class="headerlink" title="Java 分支结构"></a>Java 分支结构</h1><pre><code>if 语句switch 语句</code></pre><h1 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h1><p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。<br>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。    </p><h2 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。<br>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。<br>    <a href="http://www.runoob.com/java/java-number.html" target="_blank" rel="external">Number &amp; Math 类方法</a></p><h1 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h1><p>Character 类用于对单个字符进行操作。<br>Character 类在对象中包装一个基本类型 char 的值    </p><h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。<br>    <a href="http://www.runoob.com/java/java-character.html" target="_blank" rel="external">Character 类方法</a></p><h1 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h1><p>字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。<br>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。<br>如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</p><h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><pre><code>String greeting = &quot;fanerge&quot;;</code></pre><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><pre><code>int len = greeting.length();</code></pre><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p>string1.concat(string2);<br>    <a href="http://www.runoob.com/java/java-string.html" target="_blank" rel="external">String 类方法</a></p><h1 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h1><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。<br>    <a href="http://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="external">StringBuffer 和 StringBuilder 类方法</a></p><h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>格式：dataType[] arrayRefVar;   // 首选的方法<br>    dataType arrayRefVar[];  // 效果相同，但不是首选方法<br>实例：double[] myList; // 声明一个为double类型的数组    </p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：<br>    dataType[] arrayRefVar = new dataType[arraySize];</p><h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>循环处理 for<br>foreach 循环<br>    <a href="http://www.runoob.com/java/java-array.html" target="_blank" rel="external">Array类方法</a>    </p><h1 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h1><p>Date 类<br>    <a href="http://www.runoob.com/java/java-date-time.html" target="_blank" rel="external">Date类方法</a><br>    Calendar类<br>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。<br>    GregorianCalendar类<br>    Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><h1 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h1><p>java正则在java.util.regex包中<br>Pattern 类：<br>    pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。<br>Matcher 类：<br>    Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。<br>PatternSyntaxException：<br>    PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。    </p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><pre><code>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。    </code></pre><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="external">正则方法</a></p><h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><pre><code>修饰符 返回值类型 方法名(参数类型 参数名){    ...    方法体    ...    return 返回值;}</code></pre><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><pre><code>注：main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。    </code></pre><p>void 关键字<br>方法的重载<br>    创建另一个有相同名字但参数不同的方法 – 方法的重载<br>    就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。<br>变量作用域<br>    变量的范围是程序中该变量可以被引用的部分。<br>    方法的参数范围涵盖整个方法。参数实际上是一个局部变量。<br>    for循环的初始化部分声明的变量，其作用范围在整个循环。<br>    但循环体内声明的变量其适用范围是从它声明到循环体结束。<br>命令行参数的使用<br>构造方法<br>    构造方法和它所在类的名字相同，但构造方法没有返回值。（可不写）<br>可变参数<br>    语法：typeName… parameterName<br>finalize() 方法<br>    Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p><h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。<br>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><pre><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));int read( ) throws IOException</code></pre><h2 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h2><pre><code>String readLine( ) throws IOException</code></pre><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。<br>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>FileInputStream<br>    该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>FileOutputStream<br>    该类用来创建一个文件并向文件中写数据。    </p><h2 id="文件和I-O"><a href="#文件和I-O" class="headerlink" title="文件和I/O"></a>文件和I/O</h2><pre><code>File Class(类)FileReader Class(类)FileWriter Class(类)</code></pre><h2 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h2><p>创建目录：<br>    mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。<br>    mkdirs()方法创建一个文件夹和它的所有父文件夹。<br>读取目录：<br>    一个目录其实就是一个 File 对象，它包含其他文件和文件夹。<br>删除目录或文件<br>    删除文件可以使用 java.io.File.delete() 方法。</p><h1 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h1><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。<br>    通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据<br>next() 与 nextLine() 区别<br>next():<br>    1、一定要读取到有效字符后才可以结束输入。<br>    2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>    3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。<br>nextLine()：<br>    1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>    2、可以获得空白。</p><h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>异常发生的原因有很多，通常包含以下几大类：<br>    用户输入了非法数据。<br>    要打开的文件不存在。<br>    网络通信时连接中断，或者JVM内存溢出。<br>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：<br>    检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。<br>    运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。<br>    错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p><h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><pre><code>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</code></pre><h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h2 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h2><h2 id="throws-throw-关键字"><a href="#throws-throw-关键字" class="headerlink" title="throws/throw 关键字"></a>throws/throw 关键字</h2><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><h2 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class 父类 &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class 子类 extends 父类 &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><p>子类拥有父类非private的属性，方法。<br>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。<br>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。<br>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</p><h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object</p><h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p><h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class C implements A,B &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><pre><code>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。this关键字：指向自己的引用。</code></pre><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><pre><code>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：声明类：    final class 类名 {//类体}声明方法：    修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。</p><h1 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h1><h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h2><pre><code>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</code></pre><h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><p>参数列表必须完全与被重写方法的相同；<br>返回类型必须完全与被重写方法的返回类型相同；<br>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。<br>父类的成员方法只能被它的子类重写。<br>声明为final的方法不能被重写。<br>声明为static的方法不能被重写，但是能够被再次声明。<br>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。<br>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。<br>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。<br>构造方法不能被重写。<br>如果不能继承一个方法，则不能重写这个方法。</p><h3 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h3><pre><code>当需要在子类中调用父类的被重写方法时，要使用super关键字。</code></pre><h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><h1 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h1><p>多态是同一个行为具有多个不同表现形式或形态的能力。    </p><h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><pre><code>继承重写父类引用指向子类对象    Parent p = new Child();</code></pre><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><pre><code>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字super。</code></pre><h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><p>方式一：重写：<br>    这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。<br>方式二：接口</p><ol><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li><p>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。<br>方式三：抽象类和抽象方法<br> 详情请看 Java抽象类 章节。</p><h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p> 在Java语言中使用abstract class来定义抽象类。</p><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p> 尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从 Employee 类继承7个成员方法，且通过该方法可以设置或获取三个成员变量。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p> 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。<br> Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br> 声明抽象方法会造成以下两个结果：</p><pre><code>如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</code></pre><h1 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a>Java 封装</h1><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。<br>要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。<br>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h2 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h2><p>.     修改属性的可见性来限制对属性的访问（一般限制为private）<br>.     对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问getter和setter方法<br>.    采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p><h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>[可见度] interface 接口名称 [extends 其他的类名] {</p><pre><code>// 声明变量// 抽象方法</code></pre><p> }</p><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p> class Cat implements 接口名称[, 其他接口, 其他接口…, …] …</p><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p> 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p> public interface Hockey extends Sports, Event</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p> 最常用的继承接口是没有包含任何方法的接口。<br> 标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br> 标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><h1 id="Java-包-package"><a href="#Java-包-package" class="headerlink" title="Java 包(package)"></a>Java 包(package)</h1><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。<br>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。<br>语法：package pkg1[．pkg2[．pkg3…]];<br> 例如,一个Something.java 文件它的内容<br> package net.java.util<br> public class Something{</p><pre><code>...</code></pre><p> }<br> 那么它的路径应该是 net/java/util/Something.java 这样保存的。</p><h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p> 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。<br> 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。<br> 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p><h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p> 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。<br> 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条<br>语法：import package1[.package2…].(classname|<em>);<br> 用 import 关键字引入，使用通配符 “</em>“  import payroll.*;</p><h2 id="package-的目录结构"><a href="#package-的目录结构" class="headerlink" title="package 的目录结构"></a>package 的目录结构</h2><p> 1.创建 vehicle 目录<br> 2.在目录中新建 Car.java</p><pre><code>// 文件名 :  Car.javapackage vehicle;public class Car {   // 类实现  }</code></pre><h2 id="设置-CLASSPATH-系统变量"><a href="#设置-CLASSPATH-系统变量" class="headerlink" title="设置 CLASSPATH 系统变量"></a>设置 CLASSPATH 系统变量</h2><p> 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。<br>用下面的命令显示当前的CLASSPATH变量：<br> Windows 平台（DOS 命令行下）：C:> set CLASSPATH<br> UNIX 平台（Bourne shell 下）：# echo $CLASSPATH<br>删除当前CLASSPATH变量内容：<br> Windows 平台（DOS 命令行下）：C:> set CLASSPATH=<br> UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH<br>设置CLASSPATH变量:<br> Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes<br> UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用指令介绍&quot;&gt;&lt;a href=&quot;#常用指令介绍&quot; class=&quot;headerlink&quot; title=&quot;常用指令介绍&quot;&gt;&lt;/a&gt;常用指令介绍&lt;/h1&gt;&lt;p&gt;javac HelloWorld.java – 该命令用于将 java 源文件编译为 class 字节码文件
      
    
    </summary>
    
      <category term="java" scheme="https://fanerge.github.io/categories/java/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="java" scheme="https://fanerge.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我使用过的面试题</title>
    <link href="https://fanerge.github.io/%E6%88%91%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>https://fanerge.github.io/我使用过的面试题.html</id>
    <published>2017-12-24T13:31:05.000Z</published>
    <updated>2017-12-25T14:05:36.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术基础"><a href="#技术基础" class="headerlink" title="技术基础"></a>技术基础</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="doctype的作用"><a href="#doctype的作用" class="headerlink" title="doctype的作用"></a>doctype的作用</h3><p>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p><h3 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h3><p>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；<br>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p><h3 id="data-属性的作用和相关的API操作"><a href="#data-属性的作用和相关的API操作" class="headerlink" title="data-属性的作用和相关的API操作"></a>data-属性的作用和相关的API操作</h3><p>HTML 5 增加了一项新功能是 自定义数据属性 ，也就是  data-* 自定义属性。<br>    在HTML5中我们可以使用以 data- 为前缀来设置我们需要的自定义属性，来进行一些数据的存放。<br>    data数据都属于页面私有，不会被搜索引擎等外部系统引用。<br>相关的API<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;user&quot; data-id=&quot;001&quot; data-uname=&quot;fanerge&quot; data-date-of-birth=&quot;1991-10-15&quot;&gt; &lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">let dom = document.querySelector(&apos;#user&apos;)</div><div class="line">// 老的访问方式</div><div class="line">dom.getAttribute(&apos;data-uname&apos;) // fanerge</div><div class="line">dom.setAttribute(&apos;data-uname&apos;, &apos;余真帆&apos;) // 余真帆</div><div class="line"></div><div class="line">// HTML5 提供的访问方法(存在一定的兼容性)</div><div class="line">dom.dataset // 一个DOMStringMap</div><div class="line">dom.dataset.id // 001</div><div class="line">dom.dataset.dateOfBirth // 1991-10-15</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>扩展，data-属性选择器<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// css</div><div class="line">.user[data-name=&apos;fanerge&apos;] &#123;</div><div class="line">       color: brown;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">// js</div><div class="line">document.querySelectorAll(&apos;[data-text-colour=&quot;red&quot;]&apos;)</div></pre></td></tr></table></figure></p><h3 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h3><p>defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。<br>    defer (延迟脚本)<br>        相当于告诉浏览器立即下载，但延迟执行（整个页面都解析完毕）。<br>    async(异步脚本)<br>        指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容（css、图片、font等）。<br>        需要注意，异步脚本不要在加载期间修改DOM。 </p><h3 id="事件DOMContentLoaded和load的区别"><a href="#事件DOMContentLoaded和load的区别" class="headerlink" title="事件DOMContentLoaded和load的区别"></a>事件DOMContentLoaded和load的区别</h3><p>它们触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。<br>    DOM文档加载的步骤为</p><pre><code>1.    解析HTML结构。2.    加载样式表文件和外部脚本。3.    解析并执行脚本代码。4.    DOM树构建完成。//DOMContentLoaded（这里也是jquery的ready方法绑定的时机）5.    加载图片等外部文件。6.    页面加载完毕。//load</code></pre><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ol><li><p>与Cookie的比较<br>来看MDN定义：<br>  sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。<br>  localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。<br>  Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies。<br>共同点：都是保存在浏览器端、且同源的<br>区别点：<br>  1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下<br>  2.存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大<br>  3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭<br>  4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的<br>  5.web Storage提供了良好的api如length、key、setItem、getItem、removeItem、clear等方法<br>个人认为产生这些客户端存储的目的是由于 http协议 是无状态，客户端帮助存储客户的操作，发送给服务端以便服务端做出相应的判断。<br>cookie语法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">document.cookie=&quot;name=value; domain=cookieDomain; path=/; &quot;;</div><div class="line">;path=path (例如 &apos;/&apos;, &apos;/mydir&apos;) 如果没有定义，默认为当前文档位置的路径。</div><div class="line">;domain=domain (例如 &apos;example.com&apos;， &apos;.example.com&apos; (包括所有子域名), &apos;subdomain.example.com&apos;) 如果没有定义，默认为当前文档位置的路径的域名部分。</div><div class="line">;max-age=max-age-in-seconds (例如一年为60*60*24*365)</div><div class="line">;expires=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期这个值的格式参见Date.toUTCString() </div><div class="line">;secure (cookie只通过https协议传输) cookie的值字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).</div></pre></td></tr></table></figure><p>cookie的路径：（路径能解决在同一个域下访问 cookie 的问题）<br>  出于安全方面的考虑，只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置。<br>  让这个设置的cookie 能被其他目录或者父级的目录访问的方法：<br>  document.cookie = “userName = 独行冰海; path=/“;<br>cookie的域：（域能解决同一个主域下的访问问题）<br>  让 “www.baidu.com” 下的cookie被 “mp3.baidu.com” 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 “/“<br>  document.cookie = “username=独行冰海; path=/; domain=baidu.com”</p></li><li><p>扩展-缓存相关的知识<br>http头部缓存相关key<br>  request header缓存相关</p><pre><code>1.cache-control：no-cache、no-store、max-age2.if-none-match：该字段与响应中的eTag一起使用，表示检查实体是否有更新改变3.if-modified-since: 该字段与last-modified配合使用</code></pre><p>  response header缓存相关：</p><pre><code>1.Etag：2.expires：3.last-modified:</code></pre></li><li><p>应用场景<br>首次注册用户的引导等</p></li><li><p>在什么情况是失效<br>  1.浏览器清除缓存<br>  2.5M大小的限制<br>  3.IOS safari 的隐私模式（主要我查MDN上有说明，其他浏览器隐私模式会新建 Storage对象，不会与普通模式公用，且关闭隐私模式时 Storage对象 就消失）</p></li><li><p>浏览器内多个标签页之间的通信<br>1.localstorge + storage 事件<br>  页面1：localStorage.setItem(“name”, ‘测试’);<br>  页面2: window.addEventListener(‘stroge’, (e)=&gt; { console.log(<code>${e.key} = ${e.newValue}</code>) }, false)<br>2.cookie + setInterval（类似于轮询）</p></li></ol><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><pre><code>History.lengthHistory.scrollRestoration (实验性)-- 允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。History.state 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。History.back()History.forward()History.go()History.pushState()History.replaceState()</code></pre><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。<br>作用：解决上面问题，window.postMessage() 方法可以安全地实现跨源通信。<br>语法：otherWindow.postMessage(message, targetOrigin, [transfer]);<br>参数：otherWindow<br>        其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。<br>    message<br>        将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。<br>    targetOrigin（安全性从这里入手）<br>        通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。<br>    transfer 可选<br>        是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。<br>其他window监听message事件<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&quot;message&quot;, receiveMessage, false);</div><div class="line"></div><div class="line">function receiveMessage(event)&#123;</div><div class="line">  // For Chrome, the origin property is in the event.originalEvent</div><div class="line">  // object.</div><div class="line">  var origin = event.origin || event.originalEvent.origin; </div><div class="line">  if (origin !== &quot;http://example.org:8080&quot;)</div><div class="line">return;</div><div class="line"></div><div class="line">  // todo...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：message 的属性有:<br>    data<br>        从其他 window 中传递过来的对象。<br>    origin<br>        调用 postMessage  时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “<a href="https://example.org" target="_blank" rel="external">https://example.org</a> (implying port 443)”、“<a href="http://example.net" target="_blank" rel="external">http://example.net</a> (implying port 80)”、“<a href="http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。" target="_blank" rel="external">http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。</a><br>    source<br>        对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。    </p><p>关注下安全性问题<br>    1.如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。<br>    2.请始终使用origin和source属性验证发件人的身份，还应该始终验证接收到data的消息的语法。<br>    3.当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">详细需了解-MDN</a></p><h4 id="WebSocket对象"><a href="#WebSocket对象" class="headerlink" title="WebSocket对象"></a>WebSocket对象</h4><p>作用：<br>    提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。<br>    WebSocket构造器方法接受一个必须的参数和一个可选的参数：<br>语法：<br>    WebSocket WebSocket(in DOMString url,in optional DOMString[] protocols);<br>具体参数：<br>    url – 表示要连接的URL。这个URL应该为响应WebSocket的地址。<br>    protocols 可选 – 可以是一个单个的协议名字字符串或者包含多个协议名字字符串的数组。这些字符串用来表示子协议，这样做可以让一个服务器实现多种WebSocket子协议（例如你可能希望通过制定不同的协议来处理不同类型的交互）。如果没有制定这个参数，它会默认设为一个空字符串。<br>属性：<br>    binaryType、onclose、onerror、onmessage、onopen（EventListener）<br>方法：<br>    void send(in DOMString data);<br>    void close(in optional unsigned long code, in optional DOMString reason);<br>构造器方法可能抛出以下异常：<br>    SECURITY_ERR – 试图连接的端口被屏蔽。<br>示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Create WebSocket connection.</div><div class="line">const socket = new WebSocket(&apos;ws://localhost:8080&apos;);</div><div class="line"></div><div class="line">// Connection opened</div><div class="line">socket.addEventListener(&apos;open&apos;, function (event) &#123;</div><div class="line">socket.send(&apos;Hello Server!&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Listen for messages</div><div class="line">socket.addEventListener(&apos;message&apos;, function (event) &#123;</div><div class="line">console.log(&apos;Message from server&apos;, event.data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="external">MDN-WebSocket</a></p><p>扩展（Ajax轮询）这是比较原始的方案<br>    定义：轮询（polling）：客户端按规定时间定时向服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.setInterval(function()&#123;$.ajax(getting)&#125;,1000);</div></pre></td></tr></table></figure></p><pre><code>长轮询（递归）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var getting = &#123;</div><div class="line">url:&apos;server.php&apos;,</div><div class="line">dataType:&apos;json&apos;,</div><div class="line">success:function(res) &#123;</div><div class="line">// todo...</div><div class="line">$.ajax(getting); //关键在这里，回调函数内再次请求Ajax</div><div class="line">&#125;        </div><div class="line">error:function(res)&#123;</div><div class="line">$.ajax(getting);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">$.ajax(getting); // 这里第一次调用ajax</div></pre></td></tr></table></figure></code></pre><h4 id="CMD和AMD以及UMD，UMD的实现"><a href="#CMD和AMD以及UMD，UMD的实现" class="headerlink" title="CMD和AMD以及UMD，UMD的实现"></a>CMD和AMD以及UMD，UMD的实现</h4><p>AMD（浏览器环境）– RequireJS<br>CMD（Node） – CommonJS<br>UMD: 通用模块规范（兼容低版本浏览器设置在window上的属性如window.$ – 代表jquery）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 自己封装一个符合UMD的功能函数库取名 fanerge</div><div class="line">(function (window, factory) &#123;</div><div class="line">if (typeof exports === &apos;object&apos;) &#123;</div><div class="line">// UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。</div><div class="line">module.exports = factory();</div><div class="line">&#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class="line">// 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</div><div class="line">define(factory);</div><div class="line">&#125; else &#123;</div><div class="line">// 否则就绑定到全局的一个属性上，这里绑定到window对象的fanerge属性上</div><div class="line">window.fanerge = factory();</div><div class="line">&#125;</div><div class="line">&#125;)(this, function () &#123;</div><div class="line">let fanerge = &#123;&#125;;</div><div class="line">fanerge.alert = function alert() &#123;</div><div class="line">alert(&apos;fanerge&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fanerge.log = function log() &#123;</div><div class="line">console.log(&apos;fanerge&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return fanerge;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 使用时</div><div class="line">fanerge.log()</div></pre></td></tr></table></figure></p><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>分类：专用worker（一个专用worker仅仅能被生成它的脚本所使用）、共享worker<br>作用：Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。<br>限制：在worker内直接操作DOM节点，或者使用window对象的默认方法和属性。<br>主线程与worker数据传递：workers和主线程间的数据传递通过这样的消息机制进行——双方都使用postMessage()方法发送各自的消息，使用onmessage事件处理函数来响应消息（消息被包含在Message事件的data属性中）。这个过程中数据并不是被共享而是被复制。<br>终止worker：<br>    在主线程中终止：workerName.terminate(); worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。<br>    在worker中终止：close();<br>处理错误：onerror 事件处理函数会被调用，对应的参数，message – 可读性良好的错误消息；filename – 发生错误的脚本文件名；lineno – 发生错误时所在脚本文件的行号。<br>生成subworker： 在worker 中能够生成 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>引入脚本与库：Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；<br>共享worker与专有worker的区别：<br>    1.创建worker<br>        var myWorker = new Worker(‘worker.js’); // 专有<br>        var myWorker = new SharedWorker(‘worker.js’); // 共享<br>    2.通信（发送消息和接收消息都需要携带port）<br>        父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。<br>        myWorker.port.start();  // 父级线程中的调用<br>        port.start(); // worker线程中的调用, 假设port变量代表一个端口<br>        共享worker中消息的接收和发送<br>        消息可以像之前那样发送到worker了，但是postMessage() 方法必须被端口对象调用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">详情参考MDN-web Worker</a></p><h4 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h4><p>1、File- 单个文件；提供了诸如file name、file size、mimetype等只读文件属性。<br>2、FileList- 一个类数组File对象集合；<br>构造函数<br>    File()  返回一个新构建的文件对象（File）。<br>属性<br>    File.lastModified – 返回当前 File 对象所引用文件最后修改时间， 自 1970年1月1日0:00 以来的毫秒数。<br>    File.name – 返回当前 File 对象所引用文件的名字。<br>    File.size – 返回文件的大小。<br>    File.type – 返回文件的 多用途互联网邮件扩展类型。<br>获取用户选择文件的方式<br>    来自用户在一个input元素上选择文件后返回的FileList对象。<br>        e.target.files; //FileList<br>    来自拖放操作生成的 DataTransfer对象。<br>        e.dataTransfer.files; //FileList<br>    来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。</p><h4 id="FileReader-API"><a href="#FileReader-API" class="headerlink" title="FileReader API"></a>FileReader API</h4><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>构造函数<br>    FileReader() – 返回一个新构造的FileReader。<br>属性：<br>    error    DOMError    在读取文件时发生的错误. 只读.<br>    readyState    unsigned short    表明FileReader对象的当前状态. 值为State constants中的一个. 只读<br>    result    jsval    读取到的文件内容.这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的. 只读.<br>方法：<br>    void abort();<br>    void readAsArrayBuffer(in Blob blob);<br>    void readAsBinaryString(in Blob blob);<br>    void readAsDataURL(in Blob blob);<br>    void readAsText(in Blob blob, [optional] in DOMString encoding);<br>事件处理程序：<br>    onabort – 当读取操作被中止时调用.<br>    onerror – 当读取操作发生错误时调用.<br>    onload – 当读取操作成功完成时调用.<br>    onloadend – 当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用.<br>    onloadstart – 当读取操作将要开始之前调用.<br>    onprogress – 在读取数据过程中周期性调用.<br>示例（本地文件预览）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let oFReader = new FileReader(), // 新建一个 FileReader实例</div><div class="line">rFilter = /^(?:image\/bmp|image\/)$/i; // 可以读取的文件格式</div><div class="line"></div><div class="line">// 文件异步读取完成时，将设置预览组件的 src 属性</div><div class="line">oFReader.onload = function (oFREvent) &#123;</div><div class="line">document.getElementById(&quot;uploadPreview&quot;).src = oFREvent.target.result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 加载用户选择的图片</div><div class="line">function loadImageFile() &#123;</div><div class="line">// 没有选择文件</div><div class="line">if (document.getElementById(&quot;uploadImage&quot;).files.length === 0) &#123; return; &#125;</div><div class="line">var oFile = document.getElementById(&quot;uploadImage&quot;).files[0];</div><div class="line">// 文件的 MIMETYPE 不满足当前正则</div><div class="line">if (!rFilter.test(oFile.type)) &#123; return; &#125;</div><div class="line">// 读取文件</div><div class="line">oFReader.readAsDataURL(oFile);</div><div class="line">&#125;</div><div class="line">loadImageFile()</div></pre></td></tr></table></figure></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h3 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别"></a>块级元素和行内元素的区别</h3><h3 id="CSS-sprites"><a href="#CSS-sprites" class="headerlink" title="CSS sprites"></a>CSS sprites</h3><h3 id="line-height-和-vertical-align"><a href="#line-height-和-vertical-align" class="headerlink" title="line-height 和 vertical-align"></a>line-height 和 vertical-align</h3><p>line-height的值由font-size和字体类型共同决定。<br>vertical-align的值<br>    vertical-align: top / bottom，表示与 line-box 的顶部或底部对齐<br>    vertical-align: text-top / text-bottom，表示与 content-area 的顶部或底部对齐</p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>需要配合脱离文档流的属性使用，position: relative, absolute, fixed。</p><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>以Bootstrap3为例（12栅格系统）<br>    采用float + width(百分比) + @media(媒体查询实现适配)<br>以Bootstrap4为例<br>    采用容器flex布局（容器6个属性，子项目6个属性）</p><h3 id="Media-Query"><a href="#Media-Query" class="headerlink" title="Media Query"></a>Media Query</h3><p>语法：<br>    1.link元素中的CSS媒体查询<br>        <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</code><br>    2.样式表中的CSS媒体查询<br>        @media (max-width: 600px) { … }<br>逻辑操作符:<br>    all（默认）<br>    not – not 关键字应用于整个媒体查询，在媒体查询为假时返回真 (比如 monochrome 应用于彩色显示设备上或一个600像素的屏幕应用于 min-width: 700px 属性查询上 )。<br>    and – and关键字用于合并多个媒体属性或合并媒体属性与媒体类型。<br>        @media tv and (min-width: 700px) and (orientation: landscape) { … }<br>    only – only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式<br>        <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;</code></p><h3 id="CSS选择器的性能优化"><a href="#CSS选择器的性能优化" class="headerlink" title="CSS选择器的性能优化"></a>CSS选择器的性能优化</h3><p>说明：<br>    1.样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。<br>    2.如果你非常在意页面的性能那千万别使用CSS3选择器。实际上，在所有浏览器中，用 class 和 id 来渲染，比那些使用同胞，后代选择器，子选择器（sibling, descendant and child selectors）对页面性能的改善更值得关注。<br>CSS选择器的效率从高到低排序：<br>    1.id选择器（#myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[rel=”external”]）9.伪类选择器（a:hover,li:nth-child）<br>具体做法：<br>    1.不要在编写id规则时用标签名或类名<br>    2.不要在编写class规则时用标签名<br>    3.把多层标签选择规则用class规则替换，减少css查找<br>    4.避免使用子选择器<br>    5.依靠继承<br>    <a href="http://www.aliued.cn/2013/01/24/%E7%BD%91%E7%AB%99css%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%A7%E8%83%BD%E8%AE%A8%E8%AE%BA.html" target="_blank" rel="external">参考阿里文章</a></p><h3 id="CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考"><a href="#CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考" class="headerlink" title="CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考"></a>CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考</h3><p><a href="https://www.sass.hk/" target="_blank" rel="external">SASS</a></p><h3 id="Webfonts"><a href="#Webfonts" class="headerlink" title="Webfonts"></a>Webfonts</h3><p>作用：WebFont 技术可以让网页使用在线字体，而无需使用图片，从而有机会解决开头设计师提到的问题。它通过 CSS 的@font-face语句引入在线字体，使用 CSS 选择器指定运用字体的文本，与此同时专用于 Web 展示的 woff 格式字体也得到各大浏览器厂商支持，进一步减少了字体的体积。<br>语法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;</div><div class="line">  font-family: &apos;ciclefina&apos;;</div><div class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot&apos;);</div><div class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</div><div class="line"> url(&apos;fonts/cicle_fina-webfont.woff2&apos;) format(&apos;woff2&apos;);</div><div class="line">  font-weight: normal;</div><div class="line">  font-style: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>WebFont的优势：<br>    支持选中、复制<br>    支持 Ctrl+F 查找<br>    对搜索引擎友好<br>    支持工具翻译<br>    支持无障碍访问，支持朗读<br>    字体是矢量图形，支持矢量缩放，自动适配高清屏<br>    文本修改方便<br>    字形可以重复利用，节省网络资源<br>中文 WebFont 的困境：<br>    1、中文字体体积<br>    2、浏览器类型（各种壳的浏览器）<br>    3、操作系统（主要是XP系统）<br>现有的中文 WebFont 解决方案：<br>    1.本地制作<br>        通过字体制作工具来删除没有使用的字符，即制作精简版字体，这也是我之前实践过的方案。</p><pre><code>2. 字体云服务    </code></pre><p><a href="https://www.youziku.com/" target="_blank" rel="external">https://www.youziku.com/</a><br>    3开源工具<br><a href="http://font-spider.org/" target="_blank" rel="external">字蛛（Font-Spider）</a><br><a href="http://www.uisdc.com/the-great-chinese-webfont" target="_blank" rel="external">参考Webfont</a>        </p><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><p>说明：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>    由容器 Container 和 子项目 Item 构成。</p><h4 id="Container-容器相关的属性"><a href="#Container-容器相关的属性" class="headerlink" title="Container 容器相关的属性"></a>Container 容器相关的属性</h4><p>首先 display: flex / inline-flex;<br>flex-direction – 决定主轴的方向（即项目的排列方向）。<br>flex-wrap – 如果一条（主轴）轴线排不下，如何换行。<br>flex-flow – 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br>justify-content – 定义了项目在主轴上的对齐方式。<br>align-items – 定义项目在交叉轴上如何对齐。<br>align-content – 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><h4 id="Item-子项目相关的属性"><a href="#Item-子项目相关的属性" class="headerlink" title="Item 子项目相关的属性"></a>Item 子项目相关的属性</h4><p>order – 定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow – 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink – 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-basis – 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>flex – 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>align-self – 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮老师博客-Flex</a>        </p><h4 id="适配retina屏幕"><a href="#适配retina屏幕" class="headerlink" title="适配retina屏幕"></a>适配retina屏幕</h4><p>什么是retina屏幕适配？<br>    当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。<br>    换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。<br>适配方法：<br>1.直接加载2倍大小的图片。<br>    假如要显示的图片大小为200px<em>300px，你准备的实际图片大小应该为400px</em>600px，并且使用以下代码控制即可：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;pic.png&quot; height=&quot;200px&quot; width=&quot;300px&quot; /&gt;</div></pre></td></tr></table></figure></p><pre><code>缺点：    对于普通屏来说加载多倍图势必会导致页面加载时间加长，用户体验不佳。更好的方案：</code></pre><p><a href="http://imulus.github.io/retinajs/" target="_blank" rel="external">开源retina.js</a><br>原理是通过window.devicePixelRatio &gt; 1判断是不同屏还是retina屏，然后再加载对应的几倍图。<br>2.Image-set控制<br>    假如要显示的图片大小为200px<em>300px，你准备的图片应有两张：一张大小为200px</em>300px，命名为pic.png；另一张大小为400px*600px，命名为pic@2x.png（@2x是Retina图标的标准命名方式），然后使用以下css代码控制：<br>    背景方式使用：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#logo &#123;</div><div class="line">background: url(pic.png) 0 0 no-repeat;</div><div class="line">background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x);</div><div class="line">background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);</div><div class="line">background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);</div><div class="line">background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>在img标签属性中使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;pic.png&quot; srcset=&quot;pic@2x.png 2x&quot; /&gt;</div></pre></td></tr></table></figure></code></pre><p>3.使用@media控制<br>    实际是判断屏幕的像素比来取舍是否显示高分辨率图像，代码如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@media only screen and (-webkit-min-device-pixel-ratio: 1.5),</div><div class="line">  only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */</div><div class="line">  only screen and (-o-min-device-pixel-ratio: 3/2),</div><div class="line">  only screen and (min-device-pixel-ratio: 1.5) &#123;</div><div class="line">#logo &#123;</div><div class="line">background-image: url(pic@2x.png);</div><div class="line">background-size: 100px auto;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="http://www.ui.cn/detail/24556.html" target="_blank" rel="external">参考文章</a>        </p><h4 id="CSS3新增伪类以含义"><a href="#CSS3新增伪类以含义" class="headerlink" title="CSS3新增伪类以含义"></a>CSS3新增伪类以含义</h4><p>p:first-letter    选择每一个P元素的第一个字母<br>p:first-line    选择每一个P元素的第一行<br>p:first-child    指定只有当p元素是其父级的第一个子级的样式<br>p:last-child    选择每个p元素是其父级的最后一个子级。<br>p:first-of-type    选择每个p元素是其父级的第一个p元素<br>p:last-of-type    选择每个p元素是其父级的最后一个p元素<br>p:only-of-type    选择每个p元素是其父级的唯一p元素<br>p:only-child    选择每个p元素是其父级的唯一子元素<br>p:nth-child(2)    选择每个p元素是其父级的第二个子元素<br>p:nth-last-child(2)    选择每个p元素的是其父级的第二个子元素，从最后一个子项计数<br>p:nth-of-type(2)    选择每个p元素是其父级的第二个p元素<br>p:nth-last-of-type(2)    选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</p><p>:root    选择文档的根元素<br>p:empty    选择每个没有任何子级的p元素（包括文本节点）<br>input:enabled    选择每一个已启用的输入元素<br>input:disabled    选择每一个禁用的输入元素<br>input:checked    选择每个选中的输入元素<br>:not(p)    选择每个并非p元素的元素<br>::selection    匹配元素中被用户选中或处于高亮状态的部分</p><p>a[src^=”https”]    选择每一个src属性的值以”https”开头的元素<br>a[src$=”.pdf”]    选择每一个src属性的值以”.pdf”结尾的元素<br>a[src*=”runoob”]    选择每一个src属性的值包含子字符串”runoob”的元素</p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="JavaScript语言"><a href="#JavaScript语言" class="headerlink" title="JavaScript语言"></a>JavaScript语言</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>定义：定义在一个函数内部的函数（将函数内部的变量保留在内存中，这样外部就可以改函数内相关的变量）。<br>    闭包就是能够读取其他函数内部变量的函数。<br>用途：一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>    1.匿名自执行函数 (function(){ // todo… })()<br>    2.缓存（针对于复杂的计算，每次计算前先读缓存如果没有在进行计算并添加到缓存）<br>    3.实现封装（可以将函数内部的变量通过暴露接口在函数外可以访问）<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person = function()&#123;    </div><div class="line">//变量作用域为函数内部，外部无法访问    </div><div class="line">var name = &quot;default&quot;;       </div><div class="line">   </div><div class="line">return &#123;    </div><div class="line">   getName : function()&#123;    </div><div class="line">   return name; // 可以访问 name 属性    </div><div class="line">   &#125;,    </div><div class="line">   setName : function(newName)&#123;    </div><div class="line">   name = newName; // 可以为 name 赋值    </div><div class="line">   &#125;    </div><div class="line">&#125;    </div><div class="line">&#125;();</div></pre></td></tr></table></figure></p><pre><code>4.闭包的另一个重要用途是实现面向对象中的对象    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;    </div><div class="line">var name = &quot;default&quot;;       </div><div class="line">   </div><div class="line">return &#123;    </div><div class="line">   getName : function()&#123;    </div><div class="line">   return name;    </div><div class="line">   &#125;,    </div><div class="line">   setName : function(newName)&#123;    </div><div class="line">   name = newName;    </div><div class="line">   &#125;    </div><div class="line">&#125;    </div><div class="line">&#125;;    </div><div class="line">  </div><div class="line">var john = Person();    </div><div class="line">john.getName();   </div><div class="line">john.setName(&quot;john&quot;);    </div><div class="line">john.getName();</div></pre></td></tr></table></figure></code></pre><p><a href="http://www.jb51.net/article/57259.htm" target="_blank" rel="external">51脚本</a></p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量作用域<br>函数作用域<br>块级作用域<br>    ES6提出，let 和 const 声明。{}范围为该区域<br>    建议在支持的环境尽量使用 let 和 const 代替 var。<br>作用域链<br>    动态作用域 – 函数执行时才确定的。this（4种情况，资料较多这里不再阐述）<br>    静态作用域 – 函数定义时就确定的。<br>    函数的可以允许嵌套的。例如有一个全局函数a， 在 a 在有又定义了函数 b，此时就形成了一条作用域链。<br>        b -&gt; a -&gt; window(浏览器)/global(Node环境)</p><h4 id="原型（-gt-代表指向）"><a href="#原型（-gt-代表指向）" class="headerlink" title="原型（-&gt; 代表指向）"></a>原型（-&gt; 代表指向）</h4><p>Number.prototype(有一些自己的方法如，toFixed) -&gt; Object.prototype (对象所有的方法) -&gt; undefined(原型链的顶层，为null)<br>Number、String、Boolean、Array、Date、RegExp、都是上面的原型链。<br>Math对象有点特殊，无需在使用这个对象之前对它进行定义。类似于在该对象上定义了许多静态属性和静态方法，可以直接使用（Math.PI、Math.abs(-3)）。<br><img src="http://oxpnrlb4j.bkt.clouddn.com/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="搞懂这张就好了"></p><h4 id="面向对象-继承"><a href="#面向对象-继承" class="headerlink" title="面向对象/继承"></a>面向对象/继承</h4><p><a href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象</a><br><a href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-1/">继承</a><br><a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="external">JS实现继承的几种方式</a></p><h4 id="this（也就是说的动态作用域）"><a href="#this（也就是说的动态作用域）" class="headerlink" title="this（也就是说的动态作用域）"></a>this（也就是说的动态作用域）</h4><p>1.普通函数（挂载到全局上面）<br>    在 ‘use strict’ 严格模式中指向 undefined<br>    在非严格模式中指向window/global（适执行环境而定）<br>2.对象的方法<br>    this 指向该对象<br>3.作为构造函数调用<br>    this 指向该构造函数的实例<br>4.call、apply以及bind方法可以改变this指向<br>    this 均指向第一个参数<br>    区别：call、apply返回值是你调用的方法的返回值；而bind返回由指定的this值和初始化参数改造的原函数拷贝。<br>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">这三个方法的区别，请访问MDN</a></p><h4 id="call和apply的作用，以及区别"><a href="#call和apply的作用，以及区别" class="headerlink" title="call和apply的作用，以及区别"></a>call和apply的作用，以及区别</h4><p>参见上面        </p><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>1.过去常用于设计为一个独立的作用域<br>    (function(形参){ // todo })(实参);<br>2.函数声明也是匿名函数<br>    let demo = function(){};        </p><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>1.描述几个正则的语法含义，比如：[]、{}、\w、\d、\s等<br>    [abc]    查找方括号之间的任何字符。<br>    [^abc]    查找任何不在方括号之间的字符。<br>    [0-9]    查找任何从 0 至 9 的数字。<br>    n{X}    匹配包含 X 个 n 的序列的字符串。<br>    n{X,}    前面的模式 n 连续出现至少 X 次时匹配。<br>    n{X,Y}    前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。<br>    PS：所有的大写均表示非。<br>    \w    查找单词字符。<br>    \d    查找数字。<br>    \s    查找空白字符。包括空格符、制表符、回车符、换行符、垂直换行符、换页符<br>    \b    匹配单词边界。<br>2.i/g/m等的含义（ES6中添加u、y）<br>    i – ignore（忽略大小写）<br>    g – global（全局匹配及查找所有匹配而非在找到第一个匹配后停止）<br>    m – multiple（执行多行匹配）<br>    ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。<br>    ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。<br>3.replace方法<br>    第二个参数为string – string.replace(searchvalue,newvalue)<br>    第二个参数是回调函数<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">this.replace(/(^\s+)|(\s+$)/g,function(result,$1,$2,offset,source)&#123;</div><div class="line">//arguments中的每个元素对应一个参数</div><div class="line">console.log(arguments);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>具体参数说明：<br>result: 本次匹配到的结果<br>$1,…$9: 正则表达式中有几个()，就会传递几个参数，$1~$9分别代表本次匹配中每个()提取的结果，最多9个<br>offset:记录本次匹配的开始位置<br>source:接受匹配的原始字符串<br>4.匹配任意字符（使用互补的方式来实现）<br>    [\s\S] 或 [\w\W] 或 [.\r\n]<br>    注：\w 等价于 [A-Za-z0-9_]<br><a href="http://www.jb51.net/article/80544.htm" target="_blank" rel="external">51job</a>            </p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>1.DOM事件流<br>    冒泡：事件冒泡的过程是：a –&gt; div –&gt; body 。<br>        产生的原因：因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。<br>        处理问题：event.stopPropagation()阻止事件的传递行为。<br>        应用：事件委托<br>    捕获：事件从Document节点自上而下向目标节点传播的阶段<br>    完整的DOM事件流模型：<br>        捕获阶段 、目标阶段 、冒泡阶段<br>2.兼容性问题（优先级逐渐升高）<br>    html的onclick属性绑定<br>    dom.onclick = function(){}<br>    dom.attachEvent(“onclick”, callback) // dom.detachEvent(“onclick”, callback)<br>    dom.addEventListener(‘click’, callback, userCapture) // dom.removeEventListener(‘click’, callback, userCapture)<br>3.事件代理<br>    原理为事件冒泡<br>    例如一下DOM结构<br>    ul<br>        li<br>        li<br>    对ul绑定事件，而不是对li绑定事件。在通targe.tagName，以及点的是哪一个li做不用的操作。<br>4.自定义事件<br>    如何实现一个自定义事件的系统<br>    定义：自定义事件就是自己定义事件类型，自己定义事件处理函数，在合适的时候需要哪个事件类型，就去调用哪个处理程。<br>    实现过程：（其实就是发布订阅模式或监听者模式）<br>1.定义自定义事件构造函数<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function EventTarget()&#123;</div><div class="line">//保存事件处理程序数组集合，每个实例不共享</div><div class="line">this.handlers = &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2.在构造函数的原型上添加实例共享的方法<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EventTarget.prototype = &#123;</div><div class="line">constructor: EventTarget, // 矫正原型链指向</div><div class="line">addEvent: function(type, handler) &#123;&#125;, // 添加一个事件处理函数</div><div class="line">addEvents: function(obj)&#123;&#125;, // 批量添加事件</div><div class="line">removeEvent: function(type, handler)&#123;&#125;, // 移除一个事件处理函数</div><div class="line">removeEvents: function(params) &#123;&#125;, // 批量移除事件</div><div class="line">fireEvent: function(type) &#123;&#125;, // 触发一个事件</div><div class="line">fireEvents: function(array) &#123;&#125; // 批量触发事件</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>3.调用<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function b()&#123;</div><div class="line">  console.log(123);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var target = new EventTarget();</div><div class="line">target.addEvent(&quot;eat&quot;, b);</div><div class="line"> </div><div class="line">target.fireEvent(&#123; type: &quot;eat&quot; &#125;); // 12</div></pre></td></tr></table></figure></p><p><a href="http://blog.csdn.net/wkyseo/article/details/53609509" target="_blank" rel="external">详细信息参考博客</a></p><h4 id="BOM-DOM"><a href="#BOM-DOM" class="headerlink" title="BOM/DOM"></a>BOM/DOM</h4><p>BOM – 浏览器对象模型（Browser Object Model，简称BOM）。<br>    提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本，对Cookie的支持等。<br>    Window 对象<br>    Navigator 对象<br>    Screen 对象<br>    History 对象<br>    Location 对象<br>DOM – 文档对象模型（Document Object Model，简称DOM）。<br>    DOM 就是针对 HTML 和 XML 提供的一个API。<br>    兼容性问题<br>    常规的增删改查等操作的原生方法的考核<br>    查：<br>        getElementById()、<br>        getElementsByTagName()、<br>        getElementsByName()、<br>        getElementsByClassName()、<br>        querySelector()、<br>        querySelectorAll()<br>    改：<br>        document.getElementById(id).innerHTML=new value：修改HTML元素<br>        document.getElementById(id).attribute=new value：修改元素属性<br>        document.getElementById(id).style.property=new style：修改元素CSS<br>        setAttribute()：setAttribute()方法将设置元素中某个属性和值<br>        parent.replaceChild(child,oldElem)：替换节点<br>    增：<br>        A.append(B) : 把B追加到A内部（所有的A元素，以下类似）<br>        A.appendTo(B) : 把A追加到B内部<br>        A.prepend(B) : 把B追加到A内部的内容前(即B成为A第一个子元素)<br>        A.prependTo(B) : 把A追加到B的内容前（即A成为B第一个子元素）<br>        A.after(B) : 在A后追加B<br>        A.before(B): 在A前追加B<br>        node.insertBefore(A,B): 在父节点node里面的B节点前面追加A<br>        parent.replaceChild(child,oldElem)：替换节点<br>    删：<br>        dom.remove()：删除该元素<br>        parent.removeChild(child)：删除子元素</p><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>1.JS实现一个动画的方式<br>    setTimeout、<br>    setInterval、<br>    setImmediate（window.clearImmediate）微软取消该方法，不建议使用、<br>    window.requestAnimationFrame(callback)（window.cancelAnimationFrame() ）<br>        参数：一个在每次需要重新绘制动画时调用的包含指定函数的参数。<br>        这个回调函数有一个传参，DOMHighResTimeStamp，指示从触发 requestAnimationFrame 回调到现在的时间。<br>2.CSS3的动画<br>    申明一个动画：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@keyframes animationName &#123;</div><div class="line">from &#123;background: red;&#125;</div><div class="line">to &#123;background: yellow;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>    PS：参数说明，animationname、keyframes-selector（from（0%）、to（100%））、css-styles使用一个动画：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div:hover &#123;</div><div class="line">animation: animationName 5s;</div><div class="line">&#125;</div><div class="line">PS：animation: name duration timing-function delay iteration-count direction fill-mode play-state;</div></pre></td></tr></table></figure></code></pre><p>3.如何优化动画的流畅度<br>    每一帧都需要在16ms内渲染<br>    动画添加到opacity和transform等属性之上。<br>    将内容藏在不起眼的地方，使用pointer-events:通过透明度为0来隐藏元素。<br>    不要同一时间所有元素都做动画，除非使用编排。<br>    轻微地增加延迟，让编排动作变得简单。<br>    使用全局倍数来设计慢动画，然后加速之后所有的元素。<br>    拍下你的UI，并且重放他们，以获取有价值的第三方关点。<br>    网络活动导致滞后，你需要提前或者滞后加载大的http请求。<br>    不要直接绑定滚动。<br>    尽早&amp;经常在手机上测试。<br>    在不同的设备上经常测试，屏幕大小，像素，或者设备都有着极大的暗示。<br>4.animation-fill-mode<br>    animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。<br>    属性值：none | forwards | backwards | both<br><a href="http://www.open-open.com/lib/view/open1480991763196.html" target="_blank" rel="external">流畅web动画的十个法则</a></p><h4 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h4><h4 id="动画事件-自定义事件（start、process、end等）"><a href="#动画事件-自定义事件（start、process、end等）" class="headerlink" title="动画事件/自定义事件（start、process、end等）"></a>动画事件/自定义事件（start、process、end等）</h4><p>animationstart - CSS 动画开始后触发<br>animationiteration - CSS 动画重复播放时触发<br>animationend - CSS 动画完成后触发</p><h4 id="shim和polyfill"><a href="#shim和polyfill" class="headerlink" title="shim和polyfill"></a>shim和polyfill</h4><p>polyfill 是 shim 的一种。<br>shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；<br>polyfill 特指 shim 成的 api 是遵循标准的，其典型做法是在IE浏览器中增加 window.XMLHttpRequest ，内部实现使用 ActiveXObject。</p><h4 id="Ajax-跨域"><a href="#Ajax-跨域" class="headerlink" title="Ajax/跨域"></a>Ajax/跨域</h4><p>1.对Ajax的作用、API方法的理解<br>    Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。<br>    XMLHttpRequest(ActiveXObject 兼容版本ie)或新的Fetch API<br>    重点研究下Fetch API<br>        Fetch API提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。<br>        Fetch 接口<br>GlobalFetch<br>    包含了 fetch() 方法，用于获取资源。<br>Headers（构造器）<br>    相当于 response/request 的头信息，可以修改它，或者针对不同的结果做不同的操作。<br>    Headers.append()<br>        给现有的header添加一个值, 或者添加一个未存在的header并赋值.<br>    Headers.delete()<br>        从Headers对象中删除指定header.<br>    Headers.get()<br>        从Headers对象中返回指定header的第一个值.<br>    Headers.getAll()<br>        以数组的形式从Headers对象中返回指定header的全部值.<br>    Headers.has()<br>        以布尔值的形式从Headers对象中返回是否存在指定的header.<br>    Headers.keys()<br>        以迭代器的形式返回Headers对象中所有存在的header名.<br>    Headers.set()<br>        替换现有的header的值, 或者添加一个未存在的header并赋值.<br>    Headers.values()<br>        以迭代器的形式返回Headers对象中所有存在的header的值.<br>    Headers.entries()<br>        以 迭代器 的形式返回Headers对象中所有的键值对.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myHeaders = new Headers();</div><div class="line">myHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);</div><div class="line">myHeaders.set(&quot;Content-Type&quot;, &quot;text/html&quot;);</div><div class="line">console.log(myHeaders.get(&quot;Content-Length&quot;)); // 11</div><div class="line">myHeaders.delete(&quot;X-Custom-Header&quot;);</div><div class="line">myHeaders.has(&quot;Content-Type&quot;)</div></pre></td></tr></table></figure></p><p>Body<br>    代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。<br>    Body.bodyUsed（属性）<br>        包含一个指示body是否被读取过的 Boolean 值。<br>    Body.arrayBuffer()<br>        使用一个buffer数组来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.blob()<br>        使用一个Blob对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.formData()<br>        使用一个 FormData 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.json()<br>        使用一个 JSON 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.text()<br>        使用一个USVString (文本) 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body" target="_blank" rel="external">MDN-Fetch-body</a><br>Request（构造器）<br>    相当于一个资源请求。<br>    Request.method 只读<br>        请求使用的方法 (GET, POST, 等.)<br>    Request.url 只读<br>        请求使用的 URL。<br>    Request.headers 只读<br>        请求所关联的 Headers 对象。<br>    Request.context 只读<br>        请求的上下文 例如：(例如：audio, image, iframe, 等)<br>    Request.referrer 只读<br>        请求的来源 (例如：client).<br>    Request.mode 只读<br>        请求的模式 (例如： cors, no-cors, same-origin).<br>    Request.credentials 只读<br>        请求的凭证 (例如： omit, same-origin).<br>    Request.redirect 只读<br>        如何处理重定向模式 (例如： follow, error, or manual)<br>    Request.integrity 只读<br>        请求内容的 subresource integrity 值 (例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).<br>    Request.cache 只读<br>        请求的缓存模式 (例如： default, reload, no-cache).<br>    Body.bodyUsed 只读<br>        指示body是否被使用， 类型为Boolean<br>    Request.clone()<br>        创建当前request的副本。</p><pre><code>Request implements Body, so it also has the following methods available to it:    Body.arrayBuffer()    Returns a promise that resolves with an ArrayBuffer representation of the request body.    Body.blob()    Returns a promise that resolves with an Blob representation of the request body.    Body.formData()    Returns a promise that resolves with an FormData representation of the request body.    Body.json()    Returns a promise that resolves with an JSON representation of the request body.    Body.text()    Returns a promise that resolves with an USVString (text) representation of the request body.</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request" target="_blank" rel="external">MDN-Fetch-request</a><br>Response（构造器）<br>    相当于请求的响应。<br>    Response.type 只读<br>        包含Response的类型 (例如, basic, cors).<br>    Response.url 只读<br>        包含Response的URL.<br>    Response.useFinalURL<br>        包含了一个布尔值来标示这是否是该Response的最终URL.<br>    Response.status 只读<br>        包含Response的状态码 (例如, 200 成功).<br>    Response.ok 只读<br>        包含了一个布尔值来标示该Response成功(状态码200-299) 还是失败.<br>    Response.redirected 只读<br>        表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个<br>    Response.statusText 只读<br>        包含了与该Response状态码一致的状态信息 (例如, OK对应200).<br>    Response.headers 只读<br>        包含此Response所关联的Headers 对象.<br>    Response 实现了 Body, 所以以下属性同样可用:<br>    Body.bodyUsed 只读<br>     包含了一个布尔值来标示该Response是否读取过Body.<br>    Response.clone()<br>        创建一个Response对象的克隆<br>    Response.error()<br>        返回一个绑定了网络错误的新的Response对象<br>    Response.redirect()<br>        用另一个URL创建一个新的 response.<br>    Response 实现了 Body, 所以以下方法同样可用:<br>        Body.arrayBuffer()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为ArrayBuffer格式的promise对象<br>        Body.blob()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为Blob格式的promise对象<br>        Body.formData()<br>        读取Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为FormData格式的promise对象<br>        Body.json()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为JSON格式的promise对象<br>        Body.text()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为USVString格式的promise对象<br>        参数：<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myHeaders = new Headers();</div><div class="line">var myInit = &#123; method: &apos;GET&apos;,</div><div class="line">   headers: myHeaders,</div><div class="line">   mode: &apos;cors&apos;,</div><div class="line">   cache: &apos;default&apos; &#125;;</div><div class="line">fetch(&apos;flowers.jpg&apos;,myInit)</div></pre></td></tr></table></figure></p><pre><code>返回值：    Promise 对象    PS：就算是404也会返回promise resolved 还需要使用Response.ok 是不是为 true进一步判断。</code></pre><p>2.同步和异步<br>3.同源策略<br>    作用：同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>    定义：同domain（或ip）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。<br>    同源主要的限制：<br>        （1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>        （2） DOM和js对象无法获得。<br>        （3） AJAX 请求不能发送。<br>4.跟后端的数据交互的方式：JSON/XML，JS如何解析JSON为对象<br>    // json字符串<br>    var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’;<br>    // json对象<br>    var str2 = { “name”: “cxh”, “sex”: “man” };</p><pre><code>// JSON字符串转换为JSON对象方法一// var obj = eval(&apos;(&apos; + str1 + &apos;)&apos;);// JSON字符串转换为JSON对象方法二// var obj = JSON.parse(str1)// JSON对象转换为JSON字符串方法一JSON.stringify(str2)</code></pre><h4 id="对HTTP协议的理解"><a href="#对HTTP协议的理解" class="headerlink" title="对HTTP协议的理解"></a>对HTTP协议的理解</h4><p>1.常见的状态码<br>    200 OK<br>    301 Moved Permanently<br>    302 Found<br>    304 Not Modified<br>    307 Temporary Redirect<br>    400 Bad Request<br>    401 Unauthorized<br>    403 Forbidden<br>    404 Not Found<br>    410 Gone<br>    500 Internal Server Error<br>    501 Not Implemented<br>    <a href="https://fanerge.github.io/2017/11/05/%E5%89%8D%E7%AB%AF%E5%90%8C%E5%AD%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/">前端同学需要了解的通信知识</a><br>2.常见的HTTP请求和响应<br>    <a href="https://www.cnblogs.com/honghong87/articles/6941436.html" target="_blank" rel="external">参考博客</a><br>3.1同源策略限制了一下行为：<br>    1.Cookie、LocalStorage 和 IndexDB 无法读取<br>    2.DOM 和 JS 对象无法获取<br>    3.Ajax请求发送不出去<br>3.2解决跨域的方法<br>    window.name + iframe<br>    location.hash + iframe<br>    jsonp（jsonp的原理和优缺点）<br>        1.原理：动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本,通过这个特性(也可以说漏洞),服务器端不在返回json格式,而是返回一段调用某个函数的js代码（该页面中存在该函数），在src中进行了调用，这样实现了跨域。<br>        前面3中方式均只支持get方式<br>    document.domain + iframe（跨子域）<br>    HTML5中postMessage方案<br>        window.postMessage(msg,targetOrigin)<br>        window.addEventListener(‘message’,function(e) {}<br>    跨域资源共享 CORS<br>    WebSocket协议跨域<br>        后端主要配置，Access-Control-Allow-Origin<br>    node代理跨域<br>    nginx代理跨域<br>    详细请自行参考MDN相关文档<br>    <a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="external">正确面对跨域，别慌</a><br>4.JSONP请求如何取消？<br>    删除script标签（存在兼容性问题）<br>    将callback函数置为空函数<br>5.GET/POST方法的区别和使用场景<br>    get只应该用于获取数据，post用于提交数据（存在副作用）。<br>6.JavaScript模板引擎<br>    Template.js<br>    pug<br>    Mustache<br>    <a href="https://segmentfault.com/a/1190000000502743" target="_blank" rel="external">参考segmentfault</a><br>7.JavaScript设计模式<br>    <a href="https://fanerge.github.io/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">javascript设计模式</a></p><h3 id="Mobile-Web"><a href="#Mobile-Web" class="headerlink" title="Mobile Web"></a>Mobile Web</h3><p>重要概念<br>    设备像素：设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。<br>    CSS像素：这是一个抽象的像素概念，它是为web开发者创造的（是可以改变的，取决于用于是否缩放）。<br>    设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)<br>    最重要的两个视口，布局视口和理想<br>        布局视口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。<br>        理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：理想的布局视口。<br>        下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：<br>            <meta name="viewport" content="width=device-width"><br>屏幕适配 – 主要是屏幕分辨率、尺寸、屏幕方向这些因素。<br>    CSS3的媒体查询（media query）<br>    <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0&quot; /&gt;</code><br>        width=device-width - 布局视口等于理想视口<br>        device-width - 设备的宽度<br>        initial-scale - 初始的缩放比例<br>        minimum-scale - 允许用户缩放到的最小比例<br>        maximum-scale - 允许用户缩放到的最大比例<br>        user-scalable - 用户是否可以手动缩放<br>    <code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot; &gt;</code><br>    //禁止自动识别电话号码和邮箱<br>    <code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; &gt;</code><br>    //苹果手机：会删除默认的工具栏和菜单栏，网站开启对web app程序的支持<br>    <code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</code><br>    //苹果手机：在web app应用下状态条（屏幕顶部条）的颜色,默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。<br>    <code>&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;</code><br>    //苹果手机：如果把一个web app添加到了主屏幕中，那么从主屏幕中打开这个web app则全屏显示<br>    <code>&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/static/images/identity/HTML5_Badge_64.png&quot; /&gt;</code><br>    //苹果手机：将应用添加到手机主屏幕，会有一个icon可以直接进入<br>重置部分css<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line"> font: 16px/1.5 Helvetica, Arial;</div><div class="line">//这里是设置字体，Helvetica字体在移动端各系统都支持（都不支持微软雅黑）</div><div class="line">-webkit-text-size-adjust: none; </div><div class="line">//设置文本不会放大，普通网页在移动端打开文本是会跟随网页结构缩放的</div><div class="line">&#125;</div><div class="line">* &#123;</div><div class="line">-webkit-tap-highlight-color: transparent;</div><div class="line">//在一些手机上，如iphone，点击按钮等元素会出现点击态的背景色，设置为透明就看不出来了</div><div class="line">-webkit-user-select:none;</div><div class="line">//设置元素内的文字及其子元素将不会被选中</div><div class="line">&#125;</div><div class="line">// 去除webkit的滚动条</div><div class="line">::-webkit-scrollbar&#123;</div><div class="line">   display: none;</div><div class="line">&#125;</div><div class="line">div &#123;</div><div class="line">-webkit-overflow-scrolling : touch;</div><div class="line">&#125;</div><div class="line">// 去除button在ios上的默认样式</div><div class="line">button &#123;</div><div class="line">-webkit-appearance: none;</div><div class="line">border-radius: 0;</div><div class="line">&#125;</div><div class="line">// placeholder元素样式的修改</div><div class="line">input::-webkit-input-placeholder&#123;color:red;&#125;</div><div class="line">input:focus::-webkit-input-placeholder&#123;color:green;&#125;</div><div class="line">// 使用css3的transition、transform（translate、scale、rotate、skew）、或者animation来进行动画或过度。</div><div class="line">// 使用图片时，会发现图片下总是有大概4px的空白</div><div class="line">img&#123;display:block&#125;；</div><div class="line">img&#123;vertical-align:top&#125;</div></pre></td></tr></table></figure></p><p>事件<br>    touchstart：当手指放在屏幕上触发;<br>    touchmove：当手指在屏幕上滑动时，连续地触发;<br>    touchend：当手指从屏幕上离开时触发;<br>    touchcancel： 当系统停止跟踪时触发;<br>        event.touches.length // 当前几个手指在触屏上</p><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>1.对AMD、CMD（node.js）、UMD等规范的了解，以及ES6中关于模块的标准定义<br>2.使用过常用的模块化框架：Requirejs、Seajs等<br>3.使用模块化的方式，能够解决什么问题？<br>    命名空间冲突（全局变量覆盖）<br>    文件依赖管理<br>    立即执行函数 + 闭包(实现模块的基本方法)<br>4.动态加载JavaScript有几种方式？<br>    1.使用document.write/writeln(）方式<br>        document.writeln(“<script src="\"http://lib.sinaapp.com/js/jquery/1.6/jquery.min.js\""></script>“);<br>    2.使用jquery getScript(url,callback)方法实现动态加载js文件<br>        $.getScript(‘test.js’,function(){<br>            // TODO…<br>        });<br>    3.动态改变已有script的src属性<br>    4.使用原生js 动态创建script标签，并指定script的src属性<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function loadJs(url,callback)&#123;</div><div class="line">var script=document.createElement(&apos;script&apos;);</div><div class="line"></div><div class="line">script.type=&quot;text/javascript&quot;;</div><div class="line">if(typeof(callback)!=&quot;undefined&quot;)&#123;</div><div class="line">if(script.readyState)&#123;</div><div class="line">script.onreadystatechange=function()&#123;</div><div class="line"></div><div class="line">if(script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</div><div class="line">script.onreadystatechange=null;</div><div class="line">callback();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line">script.onload=function()&#123;</div><div class="line">callback();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">script.src=url;</div><div class="line">document.body.appendChild(script);</div><div class="line">&#125;</div><div class="line">loadJs(&quot;test.js&quot;,function()&#123;</div><div class="line">// todo...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><pre><code>5.用XHR取得要脚本的内容，再创建 Script 对象。6.如何判断动态脚本是否加载完成    为scriptdom节点添加监听事件 onload 和 onreadystatechange    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scriptDom.onload = scriptDom.onreadystatechange = function()&#123;  </div><div class="line">// 这里处理了兼容性，不同浏览器 readyState 的值不一样</div><div class="line">   if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;)&#123;  </div><div class="line">   // todo...</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>5.动态加载CSS方法<br>    1.导入css文件<br>        @import url(style.css);<br>    2.简单的在页面中加载一个外部CSS文件<br>        document.createStyleSheet(cssFile);<br>    3.用createElement方法创建CSS的Link标签<br>7.分析依赖的方式<br>    动态分析，也是运行时分析<br>    本地编译分析出依赖链<br>8.如何做好模块加载的性能优化    </p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><pre><code>参见阮一峰教程</code></pre><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>Angularjs<br>React （重点）<br>Babkbone<br>Vuejs （重点）    </p><h4 id="前端安全（XSS、CSRF等，攻击和防范方案）"><a href="#前端安全（XSS、CSRF等，攻击和防范方案）" class="headerlink" title="前端安全（XSS、CSRF等，攻击和防范方案）"></a>前端安全（XSS、CSRF等，攻击和防范方案）</h4><p>在项目中有遇到过前端方面的安全问题吗？<br>什么是XSS、CSRF？<br>常见的漏洞场景有哪些？<br>如何防范XSS、CSRF<br>网站登陆都加验证码是为了解决哪方面的安全问题？有没有更好的方案？    </p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>1.请减少HTTP请求（代理模式合并http请求）<br>    合并图片（css sprites），合并CSS和JS文件；图片较多的页面也可以使用 lazyLoad 等技术进行优化。<br>2.请正确理解 Repaint重绘 和 Reflow重排<br>3.减少DOM操作（缓存dom节点）<br>    对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。<br>4.尽量使用json数据与后端交互而不是xml<br>5.高效使用HTML标签和CSS样式    （语义化利于seo）<br>6.使用CDN加速（内容分发网络）<br>7.将CSS和JS放到外部文件中引用，CSS放头，JS放尾<br>8.精简CSS和JS文件（压缩）<br>9.压缩图片和使用图片Sprite技术<br>10.注意控制Cookie大小和污染（使用storage代替）<br>    cookie会在每次http请求自动添加，有点浪费<br>11.按需加载资源<br>12.缓存（主要是http头部字段和service workers）    </p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>1.有哪几种浏览器内核<br>    Trident – ie4-ie8<br>    Gecko   – 网景-firefox<br>    Presto  – Opera（Opera现已改用Google Chrome的Blink内核）<br>    Webkit  – Chrome、Safari<br>2.排版引擎<br>    KHTML<br>    WebCore<br>3.浏览器兼容性<br>    css前缀<br>    js自带方法的适配<br>    对各种资源的支持webP图片格式<br>4.浏览器渲染页面的原理（不同浏览器不一样）<br>    DOM Tree：浏览器将HTML解析成树形的数据结构。<br>    CSS Rule Tree：浏览器将CSS解析成树形的数据结构。<br>    Render Tree: DOM和CSSOM合并后生成Render Tree。<br>    layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br>    painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。<br>    reflow（重排）和repaint（重绘）<br>    <a href="https://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="external">参考</a><br>5.浏览器检测和识别<br>    根据浏览器特性来判断<br>    根据UA来检测 – navigator.userAgent 字符串比较</p><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>1.框架的设计方案</p><p>2.解决哪些问题    </p><h4 id="前端架构设计"><a href="#前端架构设计" class="headerlink" title="前端架构设计"></a>前端架构设计</h4><p>前端架构是一系列工具和流程的集合，旨在提升前端代码质量，并实现高效、可持续的工作流。<br>1.前端架构四个核心：<br>    ● 代码——如何实现系统架构中的HTML、CSS和JavaScript<br>    ● 流程——构建高效并且防止出错的工作流所需要的工具和流程<br>    ● 测试——为网站搭建稳固基础<br>    ● 文档——规划好系统设计蓝图<br>2.前端架构师职责：<br>    ● 体系设计——清晰描绘产品和代码的最终形态<br>    ● 工作规划——制定完整开发工作流<br>    ● 监督跟进——保证项目高效率完成    </p><h4 id="跨终端开发"><a href="#跨终端开发" class="headerlink" title="跨终端开发"></a>跨终端开发</h4><p>1.响应性设计（Mobile web），Media Queries<br>    栅格系统（bootstrap）具体实现float + width百分比 + @media query<br>    松软盒子flex 具体实现flex布局 + width百分比 + @media query<br>2.Hybird APP（PhoneGap、AppCan、Titanium等）大致的原理，以及解决的问题<br>    Web App、Hybrid App、 Native App<br>    原理：通过JSBridge,web页面可以调用Native的api,Native也可调用web页面的api或者通知H5页面回调。<br>3.React Native 和 weex<br>4.重构<br>    主要考虑（性能优化和扩展性）<br>    <a href="https://www.cnblogs.com/depsi/p/5063965.html" target="_blank" rel="external">性能优化</a><br>5.前端工程化<br>    借助Node.js的功能（读写文件、搭建服务器、读写数据库等等）帮我们完成如图片、代码压缩、代码检测等事情。<br>    模块化与组件化: npm, es6, react/angularjs<br>    代码版本管理: git<br>    代码风格管理: jscs, editorconfig<br>    代码编译: babel, scss, imgmin, csssprit, inline-svg<br>    代码质量管理 (QA): eslint, mocha<br>    代码构建: webpack<br>    项目脚手架: yeoman<br>    持续集成/持续交付/持续部署: jenkins<br>    本地化与国际化<br>6.系统架构/设计</p><h1 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h1><ol><li>描述一个你遇到过的技术问题，你是如何解决的？        </li><li><p>是否有设计过通用的组件？<br>请设计一个 Dialog（弹出层）等组件<br>你会提供什么接口？<br>调用过程是怎样的？可能会遇到什么细节问题？<br>API<br>  visible – 对话框是否可见<br>  title – 标题<br>  closable – 是否显示右上角的关闭按钮<br>  mask – 是否展示遮罩<br>  maskClosable – 点击蒙层是否允许关闭<br>  maskStyle – 遮罩样式<br>  bodyStyle – Dialog body 样式<br>  footer – 底部内容，当不需要默认底部按钮时，可以设为 footer={null}<br>  cancelText – 取消按钮文字<br>  okText – 确认按钮文字<br>  onCancel – 点击遮罩层或右上角叉或取消按钮的回调<br>  onOk – 点击确定回调<br>  zIndex    设置 Modal 的 z-index（特殊情况使用）</p></li><li><p>请描述一下你做过的哪个前端方面的功能让你特别有成就感    </p></li><li>在制作一个Web应用或Web站点的过程中，你是如何考虑它的UI、安全性、高性能、SEO、可维护性以及技术因素的？        </li><li>说说最近最流行的一些东西吧？常去哪些网站？        </li></ol><h1 id="潜力（加分项）"><a href="#潜力（加分项）" class="headerlink" title="潜力（加分项）"></a>潜力（加分项）</h1><ol><li>熟悉一门非前端语言，并且有项目开发经验，包括且不限于C/C++/Python/PHP/Java/Ruby等</li><li>在Native开发上有相关的经验（iOS、Android）等</li><li>有自己的独立博客并且有自己的思考和总结性质的文章、github有自己维护的仓库并且活跃（即开源项目）</li><li>对技术的追求有热情，特别对新技术的敏感性，能够积极主动学习新技术，并且能够有实践性的应用，比如：HTML5、Nodejs、MVVM、Promise、React、React Native、Angular等等</li><li>有较好的产品意识，并且有积极推动业务进步并拿到结果的案例</li><li>主动性、逻辑性、沟通、协同等方面的软实力良好</li><li>项目管理PM角色的经历（团队合作、沟通、协调能力）    </li></ol><h1 id="你对break和continue的理解"><a href="#你对break和continue的理解" class="headerlink" title="你对break和continue的理解"></a>你对break和continue的理解</h1><p>break 关键字<br>    break 主要用在循环语句或者 switch 语句中。<br>    break 在循环语句中作用是跳出本层（并非本次）的循环。<br>    break 在switch语句中作用是跳出该switch语句体。<br>continue 关键字<br>    continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。<br>    在 for 循环中，continue 语句使程序立即跳转到更新语句i++。<br>    在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技术基础&quot;&gt;&lt;a href=&quot;#技术基础&quot; class=&quot;headerlink&quot; title=&quot;技术基础&quot;&gt;&lt;/a&gt;技术基础&lt;/h1&gt;&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fanerge.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://fanerge.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html"/>
    <id>https://fanerge.github.io/移动端适配.html</id>
    <published>2017-12-22T13:17:45.000Z</published>
    <updated>2017-12-22T14:23:16.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单webApp的处理方案"><a href="#简单webApp的处理方案" class="headerlink" title="简单webApp的处理方案"></a>简单webApp的处理方案</h1><p>这种app是一种典型的弹性布局：关键元素高宽和位置都不变，只有容器元素在做伸缩变换。对于这类app，记住一个开发原则就好：文字流式，控件弹性，图片等比缩放。</p><h1 id="网易的做法（以设计稿为640的计算，还有750等等）"><a href="#网易的做法（以设计稿为640的计算，还有750等等）" class="headerlink" title="网易的做法（以设计稿为640的计算，还有750等等）"></a>网易的做法（以设计稿为640的计算，还有750等等）</h1><p>（1）先拿设计稿竖着的横向分辨率除以100得到body元素的宽度<br>    如果设计稿基于iphone4/5，横向分辨率为640，body的width为640 / 100 = 6.4rem<br>（2）布局时，设计图标注的尺寸除以100得到css中的尺寸<br>    播放器高度为210px，写样式的时候css应该这么写：height: 2.1rem。之所以取一个100作为参照，就是为了这里计算rem的方便！<br>（3）在dom ready以后，通过以下代码设置html的font-size。<br>    document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + ‘px’;<br>    这里的目的是保证，1rem等于100px，方便后面计算<br>（4）font-size可能需要额外的媒介查询，并且font-size不能使用rem<br>    @media screen and (max-width:321px){<br>        .m-navlist{font-size:15px}<br>    }<br>    @media screen and (min-width:321px) and (max-width:400px){<br>        .m-navlist{font-size:16px}<br>    }<br>PS：第一，需要设置视口<br>        <meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"><br>    第二，当deviceWidth大于设计稿的横向分辨率时，html的font-size始终等于横向分辨率/body元素宽<br>        var deviceWidth = document.documentElement.clientWidth;<br>        if(deviceWidth &gt; 640) deviceWidth = 640;<br>        document.documentElement.style.fontSize = deviceWidth / 6.4 + ‘px’;<br>    第三，当物理分辨率大于1280时，应该去访问PC网站了。</p><h1 id="淘宝的做法"><a href="#淘宝的做法" class="headerlink" title="淘宝的做法"></a>淘宝的做法</h1><p>（1）动态设置viewport的scale<br>    var scale = 1 / devicePixelRatio;<br>    document.querySelector(‘meta[name=”viewport”]’).setAttribute(‘content’,’initial-scale=’ + scale + ‘, maximum-scale=’ + scale + ‘, minimum-scale=’ + scale + ‘, user-scalable=no’);<br>（2）动态计算html的font-size<br>    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + ‘px’;<br>（3）布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10<br>（4）font-size可能需要额外的媒介查询，并且font-size不使用rem，这一点跟网易是一样的。<br>PS：第一，当设备竖着时横向物理分辨率大于1080时，应该去访问PC网站了。</p><h1 id="淘宝开源的布局库"><a href="#淘宝开源的布局库" class="headerlink" title="淘宝开源的布局库"></a>淘宝开源的布局库</h1><p><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">lib-flexible</a><br><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="external">详细介绍</a></p><p><a href="http://www.cnblogs.com/lyzg/p/4877277.html" target="_blank" rel="external">整理于互联网</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单webApp的处理方案&quot;&gt;&lt;a href=&quot;#简单webApp的处理方案&quot; class=&quot;headerlink&quot; title=&quot;简单webApp的处理方案&quot;&gt;&lt;/a&gt;简单webApp的处理方案&lt;/h1&gt;&lt;p&gt;这种app是一种典型的弹性布局：关键元素高宽和位置都
      
    
    </summary>
    
      <category term="移动端" scheme="https://fanerge.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端, 布局" scheme="https://fanerge.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>常用dos命令总结</title>
    <link href="https://fanerge.github.io/%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/常用dos命令总结.html</id>
    <published>2017-11-26T12:39:57.000Z</published>
    <updated>2017-11-28T12:44:20.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DOS命令"><a href="#什么是DOS命令" class="headerlink" title="什么是DOS命令"></a>什么是DOS命令</h1><p>DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h2><h3 id="md-mkdir"><a href="#md-mkdir" class="headerlink" title="md/mkdir"></a>md/mkdir</h3><p>作用：创建一个子目录（make directory）。<br>语法：md[C:][path]〈subPath〉</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>作用：改变或显示当前目录（change directory）。<br>语法：cd [C:][path]<br>PS：路径可以使用绝对路径和相对路径两种。<br>    cd\ 表示退回到根目录。<br>    cd.. 表示退回到上级目录。<br>    如果只有cd而没有参数，则只显示当前路径。<br>    注意：子目录中一定有两个“特殊目录”，即“.”“..”，其中一点表示当前目录，两点表示上一层目录。<br>    从简单实用的角度来看，我们只要学会逐层进入（cd 下一层某目录名），和逐层退出（cd..）就可以解决所有问题。</p><h3 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h3><p>作用：删除空子目录（remove directory）。<br>语法：rd [c:][path]<br>PS：rd是专门删除空子目录的命令。<br>    del 删除文件命令。<br>    注意两条：一是不能删除非空目录；二是不能删除当前目录。     </p><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>作用：主要用来显示一个目录下的文件和子目录。(directory)<br>语法：dir [C:][path][filename][/o][/s][/p][/w][/a]<br>PS：斜杠表示后面的内容是参数。<br>    /p 显示信息满一屏时，暂停显示，按任意键后显示下一屏<br>    /o 排序显示。o后面可以接不同意义的字母<br>    /w 只显示文件名目录名，每行五个文件名。即宽行显示<br>    /s 将目录及子目录的全部目录文件都显示<br>    /a 显示隐藏文件</p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>作用：设备可执行文件的搜索路径，只对文件有效。<br>语法：path[盘符1：][路径1][盘符2：][路径2]…<br>PS：当运行一个可执行文件时，dos会先在当前目录中搜索该文件，若找到则运行之；若找不到该文件，则根据path命令所设置的路径，顺序逐条地到目录中搜索该文件</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>作用：显示指定驱动器上所有目录路径和这些目录下的所有文件名。<br>语法：tree [盘符：][/f][&gt;prn]</p><h3 id="deltree"><a href="#deltree" class="headerlink" title="deltree"></a>deltree</h3><p>作用：删除目录树。<br>语法：DELTREE [C1:][path1]<br>PS：这个命令将整个指定目录树全部消灭，而不管它是否是只读、隐藏与否。使用应特别小心。它是一个危险命令。</p><h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p>作用：将整个计算机的进程显示出来，同任务管理器。<br>语法：tasklist</p><h2 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>作用：磁盘格式化。<br>语法：format〈盘符：〉[/s][/4][/q]    </p><h3 id="unformat"><a href="#unformat" class="headerlink" title="unformat"></a>unformat</h3><p>作用：对进行过格式化误操作丢失数据的磁盘进行恢复。<br>语法：unformat〈盘符〉[/l][/u][/p][/test]    </p><h3 id="chkdsk"><a href="#chkdsk" class="headerlink" title="chkdsk"></a>chkdsk</h3><p>作用：显示磁盘状态、内存状态和指定路径下指定文件的不连续数目。<br>语法：chkdsk [盘符：][路径][文件名][/f][/v]<br>PS：PS：例如要检查A盘使用情况，就输入chkdsk　A: ，检查c盘使用情况，就输入chkdsk　C: ，如果直接输入chkdsk，就检查当前磁盘的使用情况。    </p><h3 id="diskcopy"><a href="#diskcopy" class="headerlink" title="diskcopy　"></a>diskcopy　</h3><p>作用：复制格式和内容完全相同的软盘。<br>语法：diskcopy[盘符1：][盘符2：]</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>作用：建立、更改、删除磁盘卷标。<br>语法：label[盘符：][卷标名]    </p><h3 id="vol"><a href="#vol" class="headerlink" title="vol"></a>vol</h3><p>作用：查看磁盘卷标号。<br>语法：vol[盘符：]</p><h3 id="scandisk"><a href="#scandisk" class="headerlink" title="scandisk"></a>scandisk</h3><p>作用：检测磁盘的fat表、目录结构、文件系统等是否有问题，并可将检测出的问题加以修复。<br>语法：scandisk[盘符1：]{[盘符2：]…}[/all]</p><h3 id="defrag"><a href="#defrag" class="headerlink" title="defrag"></a>defrag</h3><p>作用：整理磁盘，消除磁盘碎块。<br>语法：defrag[盘符：][/f]<br>PS：选用/f参数，将文件中存在盘上的碎片消除，并调整磁盘文件的安排，确保文件之间毫无空隙。从而加快读盘速度和节省磁盘空间。</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>作用：将当前驱动器上的dos系统文件io.sys,msdos.sys和command 传送到指定的驱动器上。<br>语法：sys[盘符：]    </p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>作用：拷贝一个或多个文件到指定盘上。<br>语法：copy [源盘][路径]（源文件名） [目标盘][路径](目标文件名）</p><h3 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h3><p>作用：复制指定的目录和目录下的所有文件连同目录结构。<br>语法：xcopy [源盘：]〈源路径名〉[目标盘符：][目标路径名][/s][/v][/e]<br>PS：xcopy是copy的扩展，可以把指定的目录连文件和目录结构一并拷贝，但不能拷贝隐藏文件和系统文件。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>作用：显示ascii码文件的内容。<br>语法：type [C:][path][filename.ext]<br>PS：type命令用来在屏幕上快速、简便地显示文本文件的内容，扩展名为TXT的文件是文本文件。    </p><h3 id="ren"><a href="#ren" class="headerlink" title="ren"></a>ren</h3><p>作用：对指定磁盘、目录中的一个文件或一组文件更改名称（rename）。<br>语法：ren[盘符：][路径]〈旧文件名〉〈新文件名〉<br>PS：改名操作只限于某个文件某组文件的名称，它不会更改文件所在的目录。    </p><h3 id="fc"><a href="#fc" class="headerlink" title="fc"></a>fc</h3><p>作用：比较文件的异同，并列出差异处。<br>语法：fc[盘符：][路径名]〈文件名〉[盘符：][路径名][文件名][/a][/c][/n]</p><h3 id="attrib"><a href="#attrib" class="headerlink" title="attrib"></a>attrib</h3><p>作用：修改指定文件的属性。<br>语法：attrib[文件名][r][—r][a][—a][h][—h][—s]</p><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>作用：删除指定的文件。<br>语法：del[盘符：][路径]〈文件名〉[/p]    </p><h3 id="undelete"><a href="#undelete" class="headerlink" title="undelete"></a>undelete</h3><p>作用：恢复被误删除文件。<br>语法：undelete[盘符：][路径名]〈文件名〉[/dos][/list][/all]    </p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol><li>cls——清屏幕命令    </li><li>ver查看系统版本号命令    </li><li>date日期设置命令<br>date[mm——dd——yy]</li><li>time系统时钟设置命令<br>time[hh：mm：ss：xx]</li><li>mem显示系统的硬件和操作系统的状况。<br>mem[/c][/f][/m][/p]</li><li>msg显示系统的硬件和操作系统的状况。<br>msg[/s]</li></ol><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><h3 id="Ping命令的独特用法"><a href="#Ping命令的独特用法" class="headerlink" title="Ping命令的独特用法"></a>Ping命令的独特用法</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：ping +空格+“IP地址或者域名” [-t][-l][-n]<br>PS：-t：不停的Ping对方的机器，直到用户按Ctrl＋C键终止。因为如果想用Ping命令测试网络传输质量，至少要查看Ping命令三分钟到五分钟的结果。<br>    -l：定义echo数据包大小。我们可以将数据包的大小定义在极限值附近，以此可以测试出网络传输质量的优劣，尤其是测试外网的传输质量，非常明显。<br>    -n：在默认情况下，Ping命令一般都会发送四个数据包，通过这个命令可以自己定义发送的个数，对测试网络传输质量很有帮助。我们结合实例说明一下如何通过Ping命令的测试结果判断网络传输质量。</p><h3 id="tracert命令的使用技巧"><a href="#tracert命令的使用技巧" class="headerlink" title="tracert命令的使用技巧"></a>tracert命令的使用技巧</h3><p>作用：tracert命令可以测试路由器的工作是否正常（部分网站无法访问）。<br>    我们根据返回的结果来判断，哪一个环节的网络出现了问题。<br>语法：tracert +空格+“IP地址或者域名”</p><h3 id="用netstat命令判断是否被攻击"><a href="#用netstat命令判断是否被攻击" class="headerlink" title="用netstat命令判断是否被攻击"></a>用netstat命令判断是否被攻击</h3><p>作用：netstat命令可以查看单位的网络是否被攻击。<br>语法：netstat [-a][-n][-b]<br>PS：-a：显示所有连接和监听端口<br>　　-n：以数字形式显示地址和端口号<br>　　-b：显示包含于创建每个连接或监听端口的可执行组件。另外，使用该参数之后，还可以显示占用TCP协议端口的一些程序名称</p><h3 id="巧用ARP命令防范ARP病毒"><a href="#巧用ARP命令防范ARP病毒" class="headerlink" title="巧用ARP命令防范ARP病毒"></a>巧用ARP命令防范ARP病毒</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：arp -s ip地址 MAC</p><h3 id="灵活使用ipconfig命令"><a href="#灵活使用ipconfig命令" class="headerlink" title="灵活使用ipconfig命令"></a>灵活使用ipconfig命令</h3><p>作用：ipconfig这个命令查看计算机当前的网络配置信息。<br>ps：Ipconfig /all：完全显示计算机的网络信息，IP地址、MAC地址及其他相关的信息，都可以显示出来。<br>　　Ipconfig /release：释放计算机当前获得的IP地址。对于使用动态IP地址的单位来说，如果发现机器无法上网，而计算机从DHCP服务器处获得的IP地址等相关信息不完全，可以将该地址释放。<br>　　Ipconfig /renew：从DHCP服务器重新获得IP地址。释放了IP地址及相关信息之后，必须重新获得一个IP地址，直接输入此命令之后，便可以从DHCP服务器处获得一个IP地址。如果不用此命令，要想重新获得一个IP地址信息，需要重新启动计算机或注销计算机才行。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>net 系列</li><li>tlist -t 以树行列表显示进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li><li>kill -f 进程名 加-f参数后强制结束某进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li></ol><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>shutdown.exe -a　取消关机<br>shutdown.exe -s 关机<br>shutdown.exe -f　强行关闭应用程序。<br>shutdown.exe -m \计算机名　控制远程计算机。<br>shutdown.exe -i　显示图形用户界面，但必须是Shutdown的第一个参数。<br>shutdown.exe -l　注销当前用户。<br>shutdown.exe -r　关机并重启。<br>shutdown.exe -t时间　设置关机倒计时。<br>shutdown.exe -c”消息内容”　输入关机对话框中的消息内容（不能超127个字符）。<br>示例：<br>    电脑要在24:00关机 – at 24:00 Shutdown -s<br>    倒计时的方式关机 – Shutdown.exe -s -t 7200</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h3><p>作用：该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，使用这个命令你可以得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等。在此我们就有必要了解几个基本的参数。<br>PS：-a 使用这个参数，只要你知道了远程主机的机器名称，就可以得到它的NETBIOS信息（下同）。<br>    -A 这个参数也可以得到远程主机的NETBIOS信息，但需要你知道它的IP。<br>    -n 列出本地机器的NETBIOS信息。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>作用：这是一个用来查看网络状态的命令，操作简便功能强大。<br>PS：-a 查看本地机器的所有开放端口，可以有效发现和预防木马，可以知道机器所开的服务等信息<br>    这里可以看出本地机器开放有FTP服务、Telnet服务、邮件服务、WEB服务等。用法：netstat -a IP。<br>    -r 列出当前的路由信息，告诉我们本地机器的网关、子网掩码等信息。用法：netstat -r IP。</p><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>作用：跟踪路由信息，使用此命令可以查出数据从本地机器传输到目标主机所经过的所有途径，这对我们了解网络布局和结构很有帮助。</p><h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><p>作用：这个命令是网络命令中最重要的一个，必须透彻掌握它的每一个子命令的用法，因为它的功能实在是太强大了在这里，我们重点掌握几个常用的子命令。</p><ol><li>net view<br>使用此命令查看远程主机的所有共享资源。命令格式为net view \IP。</li><li>net use<br>把远程主机的某个共享资源影射为本地盘符，图形界面方便使用。命令格式为net use x: \IP\sharename。</li><li>net start<br>使用它来启动远程主机上的服务。用法：net start servername</li><li>net stop<br>入侵后发现远程主机的某个服务碍手碍脚，怎么办？利用这个命令停掉就ok了，用法和net start同。</li><li>net user<br>查看和帐户有关的情况，包括新建帐户、删除帐户、查看特定帐户、激活帐户、帐户禁用等。<br>1，net user abcd 1234 /add，新建一个用户名为abcd，密码为1234的帐户，默认为user组成员。<br>2，net user abcd /del，将用户名为abcd的用户删除。<br>3，net user abcd /active:no，将用户名为abcd的用户禁用。<br>4，net user abcd /active:yes，激活用户名为abcd的用户。<br>5，net user abcd，查看用户名为abcd的用户的情况</li><li>net localgroup　<br>查看所有和用户组有关的信息和进行相关操作。</li><li>net time<br>这个命令可以查看远程主机当前的时间。</li></ol><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>作用：这个命令的作用是安排在特定日期或时间执行某个特定的命令和程序。<br>    用法：at time command \computer    </p><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>作用：首先在命令行键入ftp回车，出现ftp的提示符，这时候可以键入“help”来查看帮助（任何DOS命令都可以使用此方法查看其帮助）。<br>    1.ftp<br>    2.open 主机IP ftp端口<br>    3.录入用户名和密码，就可以进行相应操作了。<br>    dir 跟DOS命令一样，用于查看服务器的文件，直接敲上dir回车，就可以看到此ftp服务器上的文件。<br>    cd 进入某个文件夹。<br>    get 下载文件到本地机器。<br>    put 上传文件到远程服务器。这就要看远程ftp服务器是否给了你可写的权限了，如果可以，呵呵，该怎么 利用就不多说了，大家就自由发挥去吧。<br>    delete 删除远程ftp服务器上的文件。这也必须保证你有可写的权限。<br>    bye 退出当前连接。<br>    quit 同上。</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>作用：功能强大的远程登陆命令，几乎所有的入侵者都喜欢用它，屡试不爽。为什么？它操作简单，如同使用自己的机器一样，只要你熟悉DOS命令，在成功以administrator身份连接了远程机器后，就可以用它来**想干的一切了。下面介绍一下使用方法，首先键入telnet回车，再键入help查看其帮助信息。    </p><h1 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h1><ol><li>向上箭头”↑”和向下箭头”↓”—–回看上一次执行的命令        </li><li>“Ctrl+C” 组合键或”Break”键 —–中断操作        </li><li>鼠标操作”标记” —————–用来选中文本        </li><li>鼠标操作”粘贴” —————–用来把剪贴板内容粘贴到提示符下        </li></ol><h2 id="程序进程"><a href="#程序进程" class="headerlink" title="程序进程"></a>程序进程</h2><p>作用：ntsd 是一条dos命令，功能是用于结束一些常规下结束不了的死进程。<br>使用：<br>    1.利用进程的PID结束进程<br>        命令格式：ntsd -c q -p pid<br>        命令范例：ntsd -c q -p 1332 （结束explorer.exe进程）<br>    2.利用进程名结束进程<br>        命令格式：ntsd -c q -pn <strong><em>.exe （</em></strong>.exe 为进程名，exe不能省）<br>        命令范例：ntsd -c q -pn explorer.exe<br>    3.taskkill结束进程<br>        命令格式：taskkill /pid 1234 /f （ 也可以达到同样的效果）</p><blockquote><p>   参考文档：<br>    <a href="http://www.jb51.net/article/30526.htm" target="_blank" rel="external">20种常用的DOS命令小结</a><br>    <a href="http://www.360doc.com/content/10/0712/19/1822972_38550278.shtml" target="_blank" rel="external">DOS中的PING命令的几种用法</a><br>    <a href="https://baike.baidu.com/item/DOS%E5%91%BD%E4%BB%A4/5143255?fr=aladdin#7" target="_blank" rel="external">百度文库-dos命令</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是DOS命令&quot;&gt;&lt;a href=&quot;#什么是DOS命令&quot; class=&quot;headerlink&quot; title=&quot;什么是DOS命令&quot;&gt;&lt;/a&gt;什么是DOS命令&lt;/h1&gt;&lt;p&gt;DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作
      
    
    </summary>
    
      <category term="杂项" scheme="https://fanerge.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="dos命令" scheme="https://fanerge.github.io/tags/dos%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构与算法</title>
    <link href="https://fanerge.github.io/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"/>
    <id>https://fanerge.github.io/JavaScript数据结构与算法.html</id>
    <published>2017-11-26T12:33:32.000Z</published>
    <updated>2017-12-22T14:31:37.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组及矩阵（二维数组）和多维数组（a-b-均为数组）"><a href="#数组及矩阵（二维数组）和多维数组（a-b-均为数组）" class="headerlink" title="数组及矩阵（二维数组）和多维数组（a, b 均为数组）"></a>数组及矩阵（二维数组）和多维数组（a, b 均为数组）</h1><p>最好使用数组存储一系列同一种数据类型的值（与其它语言保持一致）。<br>数组的优点：可以直接访问数组的某一项（相对于链表）。<br>数组的缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管我们已经学过的JavaScript的 Array 类方法可以帮我们做这些事，但背后的情况同样是这样）。</p><h2 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h2><h3 id="模拟栈数据结构"><a href="#模拟栈数据结构" class="headerlink" title="模拟栈数据结构"></a>模拟栈数据结构</h3><p>a.pop()  删除数组的最后一个元素并返回删除的元素。<br>a.push(item1, item2, …, itemX)  向数组的末尾添加一个或更多元素，并返回新的长度。</p><h3 id="模拟队列数据结构"><a href="#模拟队列数据结构" class="headerlink" title="模拟队列数据结构"></a>模拟队列数据结构</h3><p>a.shift()  删除并返回数组的第一个元素。<br>a.unshift(item1,item2, …, itemX)  可向数组的开头添加一个或更多元素，并返回新的长度。</p><h3 id="排序相关方法"><a href="#排序相关方法" class="headerlink" title="排序相关方法"></a>排序相关方法</h3><p>a.sort(sortfunction)  方法用于对数组的元素进行排序。<br>a.reverse()  用于颠倒数组中元素的顺序。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>a.splice(index,howmany,item1,…..,itemX)  用于插入、删除或替换数组的元素。<br>    参数说明：1.规定从何处添加/删除元素。2.删除多少元素。3.插入的项目。<br>    这里返回类型为数组!!!<br>a.copyWithin(target, start, end)  从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>    参数说明：1.复制到指定目标索引位置。2,3为复制的起始和结束位置。<br>a.fill(value, start, end)  将一个固定值替换数组的元素。</p><p style="color: red;">PS：删除元素的方法，返回被删除的元素。<br>    添加元素的方法，返回数组长度。</p><h2 id="不操作原数组方法"><a href="#不操作原数组方法" class="headerlink" title="不操作原数组方法"></a>不操作原数组方法</h2><h3 id="返回Boolean值的方法"><a href="#返回Boolean值的方法" class="headerlink" title="返回Boolean值的方法"></a>返回Boolean值的方法</h3><p>a.every(function(currentValue,index,arr), thisValue)  检测数值元素的每个元素是否都符合条件。<br>a.some(function(currentValue,index,arr),thisValue)  用于检测数组中的元素是否满足指定条件（函数提供）。<br>a.includes(searchElement, fromIndex) 判断该数组是否存在该数组中。</p><h3 id="返回新数组的方法"><a href="#返回新数组的方法" class="headerlink" title="返回新数组的方法"></a>返回新数组的方法</h3><p>a.concat(b)  连接两个或更多的数组，并返回连接后的数组。<br>a.filter(function(currentValue,index,arr), thisValue)  创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>a.slice(start, end)  可从已有的数组中返回选定的元素。<br>a.map(function(currentValue,index,arr), thisValue)   返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><h3 id="返回数组中的某项索引值"><a href="#返回数组中的某项索引值" class="headerlink" title="返回数组中的某项索引值"></a>返回数组中的某项索引值</h3><p>a.findIndex(function(currentValue, index, arr), thisValue)  返回符合传入测试（函数）条件的数组元素索引。<br>a.indexOf(item,start)  返回某个指定的字符串值在字符串中首次出现的位置。<br>a.lastIndexOf(item,start)   返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p><h3 id="返回数组中的某项值"><a href="#返回数组中的某项值" class="headerlink" title="返回数组中的某项值"></a>返回数组中的某项值</h3><p>a.find(function(currentValue, index, arr),thisValue)  返回传入一个测试条件（函数）符合条件的数组第一个元素。</p><h3 id="输出为字符串的方法"><a href="#输出为字符串的方法" class="headerlink" title="输出为字符串的方法"></a>输出为字符串的方法</h3><p>a.join(separator)  用于把数组中的所有元素通过分隔符转换一个字符串。<br>a.toString()  返回已逗号分割元素的字符串。</p><h3 id="其它对数组进行操作"><a href="#其它对数组进行操作" class="headerlink" title="其它对数组进行操作"></a>其它对数组进行操作</h3><p>a.forEach(function(currentValue, index, arr), thisValue)  （not return a new array! &amp; no return value!）对数组的每个元素执行一次提供的函数。<br>a.reduce(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从左到右）。<br>a.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从右到左）。<br><a href="http://www.runoob.com/jsref/jsref-obj-array.html" target="_blank" rel="external">Array方法参考手册</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈，一种具有特殊行为的数组，具有后进先出（LIFO）原则的有序集合。<br>    （数组头部）栈底[]栈顶（数组尾部）</p><h2 id="栈应该具有的方法"><a href="#栈应该具有的方法" class="headerlink" title="栈应该具有的方法"></a>栈应该具有的方法</h2><p>push(element(s)) ：添加一个（或几个）新元素到栈顶。<br>pop() ：移除栈顶的元素，同时返回被移除的元素。<br>peek() ：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。<br>isEmpty() ：如果栈里没有任何元素就返回 true ，否则返回 false 。<br>clear() ：移除栈里的所有元素。<br>size() ：返回栈里的元素个数。这个方法和数组的 length 属性很类似。</p><h2 id="构建栈及相应的方法"><a href="#构建栈及相应的方法" class="headerlink" title="构建栈及相应的方法"></a>构建栈及相应的方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">function Stack() &#123;</div><div class="line"></div><div class="line">// 使用数组来模拟栈</div><div class="line">let items = [];</div><div class="line"></div><div class="line">// push方法</div><div class="line">this.push = function(element)&#123;</div><div class="line">items.push(element);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// pop方法</div><div class="line">this.pop = function()&#123;</div><div class="line">return items.pop();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// peek方法</div><div class="line">this.peek = function()&#123;</div><div class="line">return items[items.length-1];</div><div class="line">// return items.slice().pop();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// isEmpty方法</div><div class="line">this.isEmpty = function()&#123;</div><div class="line">return items.length === 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// size方法</div><div class="line">this.size = function()&#123;</div><div class="line">return items.length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// clear方法</div><div class="line">this.clear = function()&#123;</div><div class="line">items = [];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// print调试方法</div><div class="line">this.print = function()&#123;</div><div class="line">console.log(items.toString());</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">let stack1 = new Stack();</div><div class="line">stack1.print(); // &apos;&apos;</div><div class="line">stack1.push(1);</div><div class="line">stack1.print(); // &apos;1&apos;</div><div class="line">stack1.clear();  </div><div class="line">stack1.print(); // &apos;&apos;</div></pre></td></tr></table></figure></code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function divideBy2(decNumber)&#123;</div><div class="line">let remStack = new Stack(),</div><div class="line">rem,</div><div class="line">binaryString = &apos;&apos;;</div><div class="line"></div><div class="line">while (decNumber &gt; 0)&#123; //&#123;1&#125;</div><div class="line">rem = Math.floor(decNumber % 2); //&#123;2&#125;</div><div class="line">remStack.push(rem); //&#123;3&#125;</div><div class="line">decNumber = Math.floor(decNumber / 2); //&#123;4&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">while (!remStack.isEmpty())&#123; //&#123;5&#125;</div><div class="line">binaryString += remStack.pop().toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line">return binaryString;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。</p><h2 id="队列需要的方法"><a href="#队列需要的方法" class="headerlink" title="队列需要的方法"></a>队列需要的方法</h2><p>enqueue(element(s)) ：向队列尾部添加一个（或多个）新的项。<br>dequeue() ：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。<br>front() ：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。<br>isEmpty() ：如果队列中不包含任何元素，返回 true ，否则返回 false 。<br>size() ：返回队列包含的元素个数，与数组的 length 属性类似。</p><h2 id="构建队列"><a href="#构建队列" class="headerlink" title="构建队列"></a>构建队列</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function Queue() &#123;</div><div class="line"></div><div class="line">// 保存数据</div><div class="line">let items = [];</div><div class="line"></div><div class="line">// enqueue方法</div><div class="line">this.enqueue = function(element)&#123;</div><div class="line">items.push(element);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// dequeue 方法</div><div class="line">this.dequeue = function()&#123;</div><div class="line">return items.shift();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// front 方法</div><div class="line">this.front = function()&#123;</div><div class="line">return items[0];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// isEmpty 方法</div><div class="line">this.isEmpty = function()&#123;</div><div class="line">return items.length === 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// size方法</div><div class="line">this.size = function()&#123;</div><div class="line">return items.length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// print 调试方法</div><div class="line">this.print = function()&#123;</div><div class="line">console.log(items.toString());</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="可以设置优先级的队列"><a href="#可以设置优先级的队列" class="headerlink" title="可以设置优先级的队列"></a>可以设置优先级的队列</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function PriorityQueue() &#123;</div><div class="line">let items = [];</div><div class="line"></div><div class="line">function QueueElement (element, priority)&#123; // &#123;1&#125;</div><div class="line">this.element = element;</div><div class="line">this.priority = priority;</div><div class="line">&#125;</div><div class="line"></div><div class="line">this.enqueue = function(element, priority)&#123;</div><div class="line">var queueElement = new QueueElement(element, priority);</div><div class="line"></div><div class="line">if (this.isEmpty())&#123;</div><div class="line">items.push(queueElement); // &#123;2&#125;</div><div class="line">&#125; else &#123;</div><div class="line">var added = false;</div><div class="line"></div><div class="line">for (var i=0; i&lt;items.length; i++)&#123;</div><div class="line">if (queueElement.priority &lt; items[i].priority)&#123;</div><div class="line">items.splice(i,0,queueElement); // &#123;3&#125;</div><div class="line">added = true;</div><div class="line">break; // &#123;4&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!added)&#123; //&#123;5&#125;</div><div class="line">items.push(queueElement);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">//其他方法和默认的Queue实现相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试代码var priorityQueue = new PriorityQueue();</div><div class="line">priorityQueue.enqueue(&quot;John&quot;, 2);</div><div class="line">priorityQueue.enqueue(&quot;Jack&quot;, 1);</div><div class="line">priorityQueue.enqueue(&quot;Camila&quot;, 1);</div><div class="line">priorityQueue.print(); // Jack, Camila, John</div></pre></td></tr></table></figure></code></pre><h2 id="循环队列–击鼓传花"><a href="#循环队列–击鼓传花" class="headerlink" title="循环队列–击鼓传花"></a>循环队列–击鼓传花</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function hotPotato (nameList, num)&#123;</div><div class="line">var queue = new Queue(); // &#123;1&#125;</div><div class="line"></div><div class="line">for (var i=0; i&lt;nameList.length; i++)&#123;</div><div class="line">queue.enqueue(nameList[i]); // &#123;2&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var eliminated = &apos;&apos;;</div><div class="line"></div><div class="line">while (queue.size() &gt; 1)&#123;</div><div class="line">for (var i=0; i&lt;num; i++)&#123;</div><div class="line">queue.enqueue(queue.dequeue()); // &#123;3&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">eliminated = queue.dequeue();// &#123;4&#125;</div><div class="line">console.log(eliminated + &apos;在击鼓传花游戏中被淘汰。&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return queue.dequeue();// &#123;5&#125;</div><div class="line">&#125;</div><div class="line">var names = [&apos;John&apos;,&apos;Jack&apos;,&apos;Camila&apos;,&apos;Ingrid&apos;,&apos;Carl&apos;];</div><div class="line">var winner = hotPotato(names, 7);</div><div class="line">console.log(&apos;胜利者：&apos; + winner);</div></pre></td></tr></table></figure></code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。<br>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。<br>然而，链表需要使用指针，因此实现链表时需要额外注意。<br>数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。<br>链表的优点：相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。<br>链表的缺点：数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p><h2 id="创建一个链表"><a href="#创建一个链表" class="headerlink" title="创建一个链表"></a>创建一个链表</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">function LinkedList() &#123;</div><div class="line"></div><div class="line">// 表示要加入列表的项</div><div class="line">let Node = function(element)&#123; // &#123;1&#125;</div><div class="line">this.element = element; // 填加到列表的值</div><div class="line">this.next = null; // 列表中下一个节点项的引用</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let length = 0; // &#123;2&#125;</div><div class="line"></div><div class="line">// 用于存在第一个节点的引用</div><div class="line">let head = null; </div><div class="line"></div><div class="line">// 取得链表首元素</div><div class="line">this.getHead = function()&#123;</div><div class="line">return head;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 向列表尾部添加一个新的项</div><div class="line">this.append = function(element)&#123;</div><div class="line">let node = new Node(element);</div><div class="line">current;</div><div class="line"></div><div class="line">if (head === null) &#123; // 列表中第一节点</div><div class="line">head = node;</div><div class="line">&#125; else &#123;</div><div class="line">current = head; </div><div class="line"></div><div class="line">// 循环列表，直到找到最后一项</div><div class="line">wihle(current.next)&#123;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 找到最后一项，将其next赋值为node，建立链接</div><div class="line">current.next = node;</div><div class="line">&#125;</div><div class="line"></div><div class="line">length++; // 链表长度加1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 向列表的特定位置插入一个新的项</div><div class="line">this.insert = function(position, element)&#123;</div><div class="line"></div><div class="line">//检查越界值</div><div class="line">if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; //&#123;1&#125;</div><div class="line">var node = new Node(element),</div><div class="line">current = head,</div><div class="line">previous,</div><div class="line">index = 0;</div><div class="line"></div><div class="line">if (position === 0)&#123; //在第一个位置添加</div><div class="line">node.next = current; //&#123;2&#125;</div><div class="line">head = node;</div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">while (index++ &lt; position)&#123; //&#123;3&#125;</div><div class="line">previous = current;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">node.next = current; //&#123;4&#125;</div><div class="line">previous.next = node; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">length++; //更新列表的长度</div><div class="line">return true;</div><div class="line">&#125; else &#123;</div><div class="line">return false; //&#123;6&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 从列表的特定位置移除一项</div><div class="line">this.removeAt = function(position)&#123;</div><div class="line">//检查越界值</div><div class="line">if (position &gt; -1 &amp;&amp; position &lt; length)&#123; // &#123;1&#125;</div><div class="line">var current = head, // &#123;2&#125;</div><div class="line">previous, // &#123;3&#125;</div><div class="line">index = 0; // &#123;4&#125;</div><div class="line"></div><div class="line">//移除第一项</div><div class="line">if (position === 0)&#123; // &#123;5&#125;</div><div class="line">head = current.next;</div><div class="line">&#125; else &#123;</div><div class="line">while (index++ &lt; position)&#123; // &#123;6&#125;</div><div class="line">previous = current; // &#123;7&#125;</div><div class="line">current = current.next; // &#123;8&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将previous与current的下一项链接起来：跳过current，从而移除它</div><div class="line">previous.next = current.next; // &#123;9&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">length--; // &#123;10&#125;</div><div class="line">return current.element;</div><div class="line">&#125; else &#123;</div><div class="line">return null; // &#123;11&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 从列表中移除一项</div><div class="line">this.remove = function(element)&#123;</div><div class="line">var index = this.indexOf(element);</div><div class="line">return this.removeAt(index);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回元素在列表中的索引</div><div class="line">this.indexOf = function(element)&#123;</div><div class="line">var current = head, //&#123;1&#125;</div><div class="line">index = -1;</div><div class="line">while (current) &#123; //&#123;2&#125;</div><div class="line">if (element === current.element) &#123;</div><div class="line">return index; //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">index++; //&#123;4&#125;</div><div class="line">current = current.next; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line">return -1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 如果链表中不包含任何元素，返回 true ，如果链表长度大于0则返回 false</div><div class="line">this.isEmpty = function() &#123;</div><div class="line">return length === 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回链表包含的元素个数。与数组的 length 属性类似</div><div class="line">this.size = function() &#123;</div><div class="line">return length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 由于列表项使用了 Node 类，就需要重写继承自JavaScript对象默认的toString 方法，让其只输出元素的值</div><div class="line">this.toString = function()&#123;</div><div class="line">var current = head, //&#123;1&#125;</div><div class="line">string = &apos;&apos;; //&#123;2&#125;</div><div class="line"></div><div class="line">while (current) &#123; //&#123;3&#125;</div><div class="line">string = current.element; //&#123;4&#125;</div><div class="line">current = current.next; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return string; //&#123;6&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 调试方法</div><div class="line">this.print = function()&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表的特点：双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。<br>当我们访问链表项时，在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">function  DoublyLinkedList()&#123;</div><div class="line">var Node = function(element)&#123;</div><div class="line">this.element = element;</div><div class="line">this.next = null;</div><div class="line">this.prev = null; //新增的</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var length = 0;</div><div class="line">var head = null;</div><div class="line">var tail = null; //新增的</div><div class="line"></div><div class="line">this.insert = function(position, element)&#123;</div><div class="line">//检查越界值</div><div class="line">if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123;</div><div class="line">var node = new Node(element),</div><div class="line">current = head,</div><div class="line">previous,</div><div class="line">index = 0;</div><div class="line">if (position === 0)&#123; //在第一个位置添加</div><div class="line">if (!head)&#123; //新增的 &#123;1&#125;</div><div class="line">head = node;</div><div class="line">tail = node;</div><div class="line">&#125; else &#123;</div><div class="line">node.next = current;</div><div class="line">current.prev = node; //新增的 &#123;2&#125;</div><div class="line">head = node;</div><div class="line">&#125;</div><div class="line">&#125; else if (position === length) &#123; //最后一项 //新增的</div><div class="line">current = tail; // &#123;3&#125;</div><div class="line">current.next = node;</div><div class="line">node.prev = current;</div><div class="line">tail = node;</div><div class="line">&#125; else &#123;</div><div class="line">while (index++ &lt; position)&#123; //&#123;4&#125;</div><div class="line">previous = current;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line">node.next = current; //&#123;5&#125;</div><div class="line">previous.next = node;</div><div class="line">current.prev = node; //新增的</div><div class="line">node.prev = previous; //新增的</div><div class="line">&#125;</div><div class="line">length++; //更新列表的长度</div><div class="line">return true;</div><div class="line">&#125; else &#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.removeAt = function(position)&#123;</div><div class="line">//检查越界值</div><div class="line">if (position &gt; -1 &amp;&amp; position &lt; length)&#123;</div><div class="line">var current = head,</div><div class="line">previous,</div><div class="line">index = 0;</div><div class="line">//移除第一项</div><div class="line">if (position === 0)&#123;</div><div class="line">head = current.next; // &#123;1&#125;</div><div class="line">//如果只有一项，更新tail //新增的</div><div class="line">if (length === 1)&#123; // &#123;2&#125;</div><div class="line">tail = null;</div><div class="line">&#125; else &#123;</div><div class="line">head.prev = null; // &#123;3&#125;</div><div class="line">&#125;</div><div class="line">&#125; else if (position === length-1)&#123; //最后一项 //新增的</div><div class="line">current = tail; // &#123;4&#125;</div><div class="line">tail = current.prev;</div><div class="line">tail.next = null;</div><div class="line">&#125; else &#123;</div><div class="line">while (index++ &lt; position)&#123; // &#123;5&#125;</div><div class="line">previous = current;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line">//将previous与current的下一项链接起来——跳过current</div><div class="line">previous.next = current.next; // &#123;6&#125;</div><div class="line">current.next.prev = previous; //新增的</div><div class="line">&#125;</div><div class="line">length--;</div><div class="line">return current.element;</div><div class="line">&#125; else &#123;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单向循环链表的特点：循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用 null ，而是指向第一个元素（ head ）。<br>双向循环链表有指向 head 元素的 tail.next ，和指向 tail 元素的 head.prev 。</p><h1 id="集合（es6的Set）"><a href="#集合（es6的Set）" class="headerlink" title="集合（es6的Set）"></a>集合（es6的Set）</h1><p>集合的定义：集合是由一组无序且唯一（即不能重复）的项组成的。<br>集合的操作：集合也有并集、交集、差集等基本操作。</p><h2 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Set()&#123;</div><div class="line">let items = &#123;&#125;; // js对象不允许两个不同的属性，保证集合元素的唯一性</div><div class="line"></div><div class="line">this.has = function(value)&#123;</div><div class="line">// 区别 in可以查找原型链而 hasOwnProperty方法只会查找自身</div><div class="line">// return value in items;</div><div class="line">return items.hasOwnProperty(value);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.add = function(value)&#123;</div><div class="line">if (!this.has(value)) &#123;</div><div class="line">items[value] = value;</div><div class="line">return ture;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(value)&#123;</div><div class="line">if (this.has(value)) &#123;</div><div class="line">delete items[value];</div><div class="line">return ture;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.clear = function()&#123;</div><div class="line">items = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.size = function()&#123;</div><div class="line">return Object.keys(items).length;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.values = function()&#123;</div><div class="line">return Object.keys(items);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。<br>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。<br>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。<br>子集：验证一个给定集合是否是另一集合的子集。<br>一下假设A、B为两个集合。</p><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>运算公式：A∪B = { x | x ∈ A∨x ∈ B }<br>为Set类的union方法<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 思路先将原集合和新集合循环添加到并集合中</div><div class="line">this.union = function(otherSet)&#123;</div><div class="line">let unionSet = new Set();</div><div class="line">let values = this.values();</div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">unionSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">values = otherSet.values();</div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">unionSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">return unionSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>运算公式：A∩B = { x | x ∈ A∧x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.intersection = function(otherSet)&#123;</div><div class="line">let intersectionSet = new Set();</div><div class="line">let values = this.values();</div><div class="line"></div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">if (otherSet.has(values[i])) &#123;</div><div class="line">intersectionSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return intersectionSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>计算公式：AB = { x | x ∈ A ∧ x   B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.difference = function(otherSet)&#123;</div><div class="line">let differenceSet = new Set();</div><div class="line">let values = this.values();</div><div class="line"></div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">if (!otherSet.has(values[i])) &#123;</div><div class="line">differenceSet.add(values[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return differenceSet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>运算公式：∀x { x ∈ A → x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">this.subset = function(otherSet)&#123;</div><div class="line">if (this.size() &gt; otherSet.size()) &#123;</div><div class="line">return false;</div><div class="line">&#125; else &#123;</div><div class="line">values = this.values();</div><div class="line">for (let i = 0; i &lt; values.length; i++) &#123;</div><div class="line">if (!otherSet.has(values[i])) &#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h1 id="字典（映射es6的Map）"><a href="#字典（映射es6的Map）" class="headerlink" title="字典（映射es6的Map）"></a>字典（映射es6的Map）</h1><p>字典和散列表是用来存储唯一值（不重复的值）的数据结构。<br>两者都是[键，值]的形式来存储数据    </p><h2 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">function  Dictionary()&#123;</div><div class="line">let items = &#123;&#125;;</div><div class="line"></div><div class="line">this.has = function(key)&#123;</div><div class="line">return key in items;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.set = function(key, value)&#123;</div><div class="line">items[key] = value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">if (this.has(key)) &#123;</div><div class="line">delete items[key];</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">return this.has(key) ? items[key] : undefined;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.values = function()&#123;</div><div class="line">let values = &#123;&#125;;</div><div class="line">for (let k in items) &#123;</div><div class="line">if (this.has(k)) &#123;</div><div class="line">values.push(items[k]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return values;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.clear = function()&#123;</div><div class="line">items = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.getItems = function()&#123;</div><div class="line">return items;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列算法的作用是尽可能快地在数据结构中找到一个值。<br>使用散列函数，就知道值的具体位置，因此能够快速检索到该值。<br>散列函数的作用是给定一个键值，然后返回值在表中的地址。</p><h2 id="创建一个散列表"><a href="#创建一个散列表" class="headerlink" title="创建一个散列表"></a>创建一个散列表</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function HashTable()&#123;</div><div class="line">var table = [];</div><div class="line">// 私有方法-散列函数</div><div class="line">let loseloseHashCode = function(key)&#123;</div><div class="line">let hash = 0;</div><div class="line">for (let i = 0; i &lt; key.length; i++) &#123;</div><div class="line">hash += key.charCodeAt(i);</div><div class="line">&#125;</div><div class="line">return hash % 37;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.put = function(key, value)&#123;</div><div class="line">let position = loseloseHashCode(key);</div><div class="line">console.log(position + &apos; - &apos; + key); //&#123;6&#125;</div><div class="line">table[position] = value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">return table[loseloseHashCode(key)];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">table[loseloseHashCode(key)] = undefined;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="处理散列表的冲突（同名的地址覆盖）"><a href="#处理散列表的冲突（同名的地址覆盖）" class="headerlink" title="处理散列表的冲突（同名的地址覆盖）"></a>处理散列表的冲突（同名的地址覆盖）</h2><p>可以通过分离链接、线性探查和双散列法来解决冲突。</p><h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>定义：包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>为了实现一个使用了分离链接的 HashTable 实例，我们需要一个新的辅助类来表示将要加入LinkedList 实例的元素。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">let ValuePair = function(key, value)&#123;</div><div class="line">this.key = key;</div><div class="line">this.value = value;</div><div class="line">this.toString = function() &#123;</div><div class="line">return &apos;[&apos; + this.key + &apos; - &apos; + this.value + &apos;]&apos;;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.put = function(key, value)&#123;</div><div class="line">let position = loseloseHashCode(key);</div><div class="line">if (table[position] == undefined) &#123;</div><div class="line">table[position] = new LinkedList();</div><div class="line">&#125;</div><div class="line">table[position].append(new ValuePair(key, value));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key)&#123;</div><div class="line">let position = loseloseHashCode(key);</div><div class="line"></div><div class="line">if (table[position] !== undefined) &#123;</div><div class="line">// 遍历链表来寻找键/值</div><div class="line">let current = table[position].getHead();</div><div class="line">while (current.next) &#123;</div><div class="line">if (current.elment.key === key) &#123;</div><div class="line">return current.element.value;</div><div class="line">&#125;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检查元素在链表第一个或最后一个节点的情况</div><div class="line">if (current.element.key === key)&#123; //&#123;9&#125;</div><div class="line">return current.element.value;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return undefined;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.remove = function(key)&#123;</div><div class="line">var position = loseloseHashCode(key);</div><div class="line">if (table[position] !== undefined)&#123;</div><div class="line">var current = table[position].getHead();</div><div class="line">while(current.next)&#123;</div><div class="line">if (current.element.key === key)&#123; //&#123;11&#125;</div><div class="line">table[position].remove(current.element); //&#123;12&#125;</div><div class="line">if (table[position].isEmpty())&#123; //&#123;13&#125;</div><div class="line">table[position] = undefined; //&#123;14&#125;</div><div class="line">&#125;</div><div class="line">return true; //&#123;15&#125;</div><div class="line">&#125;</div><div class="line">current = current.next;</div><div class="line">&#125;</div><div class="line">// 检查是否为第一个或最后一个元素</div><div class="line">if (current.element.key === key)&#123; //&#123;16&#125;</div><div class="line">table[position].remove(current.element);</div><div class="line">if (table[position].isEmpty())&#123;</div><div class="line">table[position] = undefined;</div><div class="line">&#125;</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return false; //&#123;17&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">this.put = function(key, value)&#123;</div><div class="line">var position = loseloseHashCode(key); // &#123;1&#125;</div><div class="line">if (table[position] == undefined) &#123; // &#123;2&#125;</div><div class="line">table[position] = new ValuePair(key, value); // &#123;3&#125;</div><div class="line">&#125; else &#123;</div><div class="line">var index = ++position; // &#123;4&#125;</div><div class="line">while (table[index] != undefined)&#123; // &#123;5&#125;</div><div class="line">index++; // &#123;6&#125;</div><div class="line">&#125;</div><div class="line">table[index] = new ValuePair(key, value); // &#123;7&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.get = function(key) &#123;</div><div class="line">var position = loseloseHashCode(key);</div><div class="line">if (table[position] !== undefined)&#123; //&#123;8&#125;</div><div class="line">if (table[position].key === key) &#123; //&#123;9&#125;</div><div class="line">return table[position].value; //&#123;10&#125;</div><div class="line">&#125; else &#123;</div><div class="line">var index = ++position;</div><div class="line">while (table[index] === undefined || table[index].key !== key)&#123; //&#123;11&#125;</div><div class="line">index++;</div><div class="line">&#125;</div><div class="line">if (table[index].key === key) &#123; //&#123;12&#125;</div><div class="line">return table[index].value; //&#123;13&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return undefined; //&#123;14&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="创建更好的散列函数"><a href="#创建更好的散列函数" class="headerlink" title="创建更好的散列函数"></a>创建更好的散列函数</h3><p>比较好的散列函数，不会产生太多的冲突。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var djb2HashCode = function (key) &#123;</div><div class="line">var hash = 5381; //&#123;1&#125;</div><div class="line">for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125;</div><div class="line">hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">return hash % 1013; //&#123;4&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树，它对于存储需要快速查找的数据非常有用。<br>树是一种分层数据的抽象模型。</p><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p>位于树顶部的节点叫作根节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。<br>有关树的另一个术语是子树。子树由节点和它的后代构成。<br>树的高度取决于所有节点深度的最大值。</p><h2 id="二叉树和二叉搜索树（BST）"><a href="#二叉树和二叉搜索树（BST）" class="headerlink" title="二叉树和二叉搜索树（BST）"></a>二叉树和二叉搜索树（BST）</h2><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。<br>这些定义有助于我们写出更高效的向树中插入、查找和删除节点的算法。<br>二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。<br>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。<br>访问树的所有节点有三种方式：中序、先序和后序。<br>中序遍历 – 是以从最小到最大的顺序访问所有节点（第二层到第一层左中右）。<br>先序遍历 – 是以优先于后代节点的顺序访问每个节点的（第一层到第二层中左右）。<br>后序遍历 – 是先访问节点的后代节点，再访问节点本身（第二层到第一层左右中）。<br>中序遍历的一种应用就是对树进行排序操作。<br>先序遍历的一种应用是打印一个结构化的文档。<br>后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line">function BinarySearchTree() &#123;</div><div class="line">let Node = function(key)&#123;</div><div class="line">this.key = key;</div><div class="line">this.left = null;</div><div class="line">this.right = null;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 根节点</div><div class="line">let root = null;</div><div class="line"></div><div class="line">// 插入节点，小的节点插入left，大的节点插入right</div><div class="line">let insertNode = function(node, newNode)&#123;</div><div class="line">if (newNode.key &lt; node.key) &#123;</div><div class="line">if (node.left === null) &#123;</div><div class="line">node.left = newNode;</div><div class="line">&#125; else &#123;</div><div class="line">insertNode(node.left, newNode);</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">if (node.right === null) &#123;</div><div class="line">node.right = newNode;</div><div class="line">&#125; else &#123;</div><div class="line">insertNode(node.right, newNode);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 向树中插入一个新的键</div><div class="line">this.insert = function (key)&#123;</div><div class="line">var newNode = new Node(key); //&#123;1&#125;</div><div class="line">if (root === null)&#123; //&#123;2&#125;</div><div class="line">root = newNode;</div><div class="line">&#125; else &#123;</div><div class="line">// 递归</div><div class="line">insertNode(root,newNode); //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-中序遍历</div><div class="line">let inOrderTraverseNode = function(node, callback)&#123;</div><div class="line">if (node !== null) &#123;</div><div class="line">inOrderTraverseNode(node.left, callback);</div><div class="line">callback(node.key);</div><div class="line">inOrderTraverseNode(node.right, callback);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 中序遍历（左中右）小到大</div><div class="line">this.inOrderTraverse = function(callback)&#123;</div><div class="line">inOrderTraverseNode(root, callback);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-先序遍历</div><div class="line">var preOrderTraverseNode = function (node, callback) &#123;</div><div class="line">if (node !== null) &#123;</div><div class="line">callback(node.key); //&#123;1&#125;</div><div class="line">preOrderTraverseNode(node.left, callback); //&#123;2&#125;</div><div class="line">preOrderTraverseNode(node.right, callback); //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 先序遍历（中左右）</div><div class="line">this.preOrderTraverse = function(callback)&#123;</div><div class="line">preOrderTraverseNode(root, callback);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-后序遍历</div><div class="line">var postOrderTraverseNode = function (node, callback) &#123;</div><div class="line">if (node !== null) &#123;</div><div class="line">postOrderTraverseNode(node.left, callback); //&#123;1&#125;</div><div class="line">postOrderTraverseNode(node.right, callback); //&#123;2&#125;</div><div class="line">callback(node.key); //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 后序遍历（左右中）</div><div class="line">this.postOrderTraverse = function(callback)&#123;</div><div class="line">postOrderTraverseNode(root, callback);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-最小值</div><div class="line">let minNode = function(node)&#123;</div><div class="line">if (node) &#123;</div><div class="line">while (node &amp;&amp; node.left !== null) &#123;</div><div class="line">node = node.left</div><div class="line">&#125;</div><div class="line">return node.key;</div><div class="line">&#125;</div><div class="line">return null;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 搜索最小值</div><div class="line">this.min = function()&#123;</div><div class="line">return minNode(node);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-最大值</div><div class="line">var maxNode = function (node) &#123;</div><div class="line">if (node)&#123;</div><div class="line">while (node &amp;&amp; node.right !== null) &#123; //&#123;5&#125;</div><div class="line">node = node.right;</div><div class="line">&#125;</div><div class="line">return node.key;</div><div class="line">&#125;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 搜索最大值</div><div class="line">this.max = function() &#123;</div><div class="line">return maxNode(root);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-搜索节点</div><div class="line">var searchNode = function(node, key)&#123;</div><div class="line">if (node === null)&#123; //&#123;2&#125;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">if (key &lt; node.key)&#123; //&#123;3&#125;</div><div class="line">return searchNode(node.left, key); //&#123;4&#125;</div><div class="line">&#125; else if (key &gt; node.key)&#123; //&#123;5&#125;</div><div class="line">return searchNode(node.right, key); //&#123;6&#125;</div><div class="line">&#125; else &#123;</div><div class="line">return true; //&#123;7&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 搜索节点</div><div class="line">this.search = function(key)&#123;</div><div class="line">return searchNode(root, key); //&#123;1&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 私有方法-移除节点</div><div class="line">var removeNode = function(node, key)&#123;</div><div class="line">if (node === null)&#123; //&#123;2&#125;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line">if (key &lt; node.key)&#123; //&#123;3&#125;</div><div class="line">node.left = removeNode(node.left, key); //&#123;4&#125;</div><div class="line">return node; //&#123;5&#125;</div><div class="line">&#125; else if (key &gt; node.key)&#123; //&#123;6&#125;</div><div class="line">node.right = removeNode(node.right, key); //&#123;7&#125;</div><div class="line">return node; //&#123;8&#125;</div><div class="line">&#125; else &#123; //键等于node.key</div><div class="line">//第一种情况——一个叶节点</div><div class="line">if (node.left === null &amp;&amp; node.right === null)&#123; //&#123;9&#125;</div><div class="line">node = null; //&#123;10&#125;</div><div class="line">return node; //&#123;11&#125;</div><div class="line">&#125;</div><div class="line">//第二种情况——一个只有一个子节点的节点</div><div class="line">if (node.left === null)&#123; //&#123;12&#125;</div><div class="line">node = node.right; //&#123;13&#125;</div><div class="line">return node; //&#123;14&#125;</div><div class="line">&#125; else if (node.right === null)&#123; //&#123;15&#125;</div><div class="line">node = node.left; //&#123;16&#125;</div><div class="line">return node; //&#123;17&#125;</div><div class="line">&#125;</div><div class="line">//第三种情况——一个有两个子节点的节点</div><div class="line">var aux = findMinNode(node.right); //&#123;18&#125;</div><div class="line">node.key = aux.key; //&#123;19&#125;</div><div class="line">node.right = removeNode(node.right, aux.key); //&#123;20&#125;</div><div class="line">return node; //&#123;21&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 移除节点</div><div class="line">this.remove = function(key)&#123;</div><div class="line">root = removeNode(root, key); //&#123;1&#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="更多关于二叉树的知识"><a href="#更多关于二叉树的知识" class="headerlink" title="更多关于二叉树的知识"></a>更多关于二叉树的知识</h2><p>BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深<br>    有一种树叫作阿德尔森-维尔斯和兰迪斯树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。<br>相关知识：红黑树、堆积树</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h2><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。<br>任何二元关系都可以用图来表示。<br>一个图G = (V, E)由以下元素组成。<br>    V：一组顶点<br>    E：一组边，连接V中的顶点<br>相邻顶点：由一条边连接在一起的顶点称为相邻顶点。<br>顶点的度：一个顶点的度是其相邻顶点的数量。<br>路径：路径是顶点v 1 , v 2 ,…,v k 的一个连续序列，其中v i 和v i+1 是相邻的。<br>图是无环：如果图中不存在环，则称该图是无环的。<br>图是连通：如果图中每两个顶点间都存在路径，则该图是连通的。<br>有向图和无向图：图可以是无向的（边没有方向）或是有向的（有向图）。<br>图是强连通：如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。<br>图是加权：图还可以是未加权的或是加权的。</p><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>每个节点都和一个整数相关联，该整数将作为数组的索引。<br>我们用一个二维数组来表示顶点之间的连接。<br>如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0<br>存在的问题：不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表由图中每个顶点的相邻顶点列表所组成。<br>存在好几种方式来表示这种数据结构。<br>我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。</p><h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><p>在关联矩阵中，矩阵的行表示顶点，列表示边。<br>我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。<br>    使用场景：关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p><h2 id="创建图类"><a href="#创建图类" class="headerlink" title="创建图类"></a>创建图类</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Graph()&#123;</div><div class="line">let vertices = [];</div><div class="line">let adjList = new Dictionary();</div><div class="line"></div><div class="line">// 添加顶点，参数为一个顶点</div><div class="line">this.addVertex = function(v)&#123;</div><div class="line">vertices.push(v);</div><div class="line">adjList.set(v, []);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 添加顶点之间的边，参数为两个顶点</div><div class="line">this.addEdge = function(v, w)&#123;</div><div class="line">adjList.get(v).push(w);</div><div class="line">adjList.get(w).push(v);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>字典将会使用顶点的名字作为键，邻接顶点列表作为值。<br>vertices数组和 adjList 字典两者都是我们 Graph 类的私有属性。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。<br>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。<br>深度优先搜索  栈  通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻点就去访问<br>广度优先搜索  队列  通过将顶点存入队列中，最先入队列的顶点先被探索</p><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。先宽后深地访问顶点。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var initializeColor = function()&#123;</div><div class="line">var color = [];</div><div class="line">for (var i=0; i&lt;vertices.length; i++)&#123;</div><div class="line">color[vertices[i]] = &apos;white&apos;; //&#123;1&#125;</div><div class="line">&#125;</div><div class="line">return color;</div><div class="line">&#125;;</div><div class="line">this.bfs = function(v, callback)&#123;</div><div class="line">var color = initializeColor(), //&#123;2&#125;</div><div class="line">queue = new Queue(); //&#123;3&#125;</div><div class="line">queue.enqueue(v); //&#123;4&#125;</div><div class="line">while (!queue.isEmpty())&#123; //&#123;5&#125;</div><div class="line">var u = queue.dequeue(), //&#123;6&#125;</div><div class="line">neighbors = adjList.get(u); //&#123;7&#125;</div><div class="line">color[u] = &apos;grey&apos;; // &#123;8&#125;</div><div class="line">for (var i=0; i&lt;neighbors.length; i++)&#123; // &#123;9&#125;</div><div class="line">var w = neighbors[i]; // &#123;10&#125;</div><div class="line">if (color[w] === &apos;white&apos;)&#123; // &#123;11&#125;</div><div class="line">color[w] = &apos;grey&apos;; // &#123;12&#125;</div><div class="line">queue.enqueue(w); // &#123;13&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">color[u] = &apos;black&apos;; // &#123;14&#125;</div><div class="line">if (callback) &#123; // &#123;15&#125;</div><div class="line">callback(u);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>1.使用BFS寻找最短路径<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">this.BFS = function(v)&#123;</div><div class="line">var color = initializeColor(),</div><div class="line">queue = new Queue(),</div><div class="line">d = [], //&#123;1&#125;</div><div class="line">pred = []; //&#123;2&#125;</div><div class="line">queue.enqueue(v);</div><div class="line">for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;3&#125;</div><div class="line">d[vertices[i]] = 0; //&#123;4&#125;</div><div class="line">pred[vertices[i]] = null; //&#123;5&#125;</div><div class="line">&#125;</div><div class="line">while (!queue.isEmpty())&#123;</div><div class="line">var u = queue.dequeue(),</div><div class="line">neighbors = adjList.get(u);</div><div class="line">color[u] = &apos;grey&apos;;</div><div class="line">for (i=0; i&lt;neighbors.length; i++)&#123;</div><div class="line">var w = neighbors[i];</div><div class="line">if (color[w] === &apos;white&apos;)&#123;</div><div class="line">color[w] = &apos;grey&apos;;</div><div class="line">d[w] = d[u] + 1; //&#123;6&#125;</div><div class="line">pred[w] = u; //&#123;7&#125;</div><div class="line">queue.enqueue(w);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">color[u] = &apos;black&apos;;</div><div class="line">&#125;</div><div class="line">return &#123; //&#123;8&#125;</div><div class="line">distances: d,</div><div class="line">predecessors: pred</div><div class="line">&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>2.深入学习最短路径算法<br>    如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法）    </p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">this.dfs = function(callback)&#123;</div><div class="line">var color = initializeColor(); //&#123;1&#125;</div><div class="line">for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;2&#125;</div><div class="line">if (color[vertices[i]] === &apos;white&apos;)&#123; //&#123;3&#125;</div><div class="line">dfsVisit(vertices[i], color, callback); //&#123;4&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">var dfsVisit = function(u, color, callback)&#123;</div><div class="line">color[u] = &apos;grey&apos;; //&#123;5&#125;</div><div class="line">if (callback) &#123; //&#123;6&#125;</div><div class="line">callback(u);</div><div class="line">&#125;</div><div class="line">var neighbors = adjList.get(u); //&#123;7&#125;</div><div class="line">for (var i=0; i&lt;neighbors.length; i++)&#123; //&#123;8&#125;</div><div class="line">var w = neighbors[i]; //&#123;9&#125;</div><div class="line">if (color[w] === &apos;white&apos;)&#123; //&#123;10&#125;</div><div class="line">dfsVisit(w, color, callback); //&#123;11&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">color[u] = &apos;black&apos;; //&#123;12&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><p>1.探索深度优先算法<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var time = 0; //&#123;1&#125;</div><div class="line">this.DFS = function()&#123;</div><div class="line">var color = initializeColor(), //&#123;2&#125;</div><div class="line">d = [],</div><div class="line">f = [],</div><div class="line">p = [];</div><div class="line">time = 0;</div><div class="line">for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;3&#125;</div><div class="line">f[vertices[i]] = 0;</div><div class="line">d[vertices[i]] = 0;</div><div class="line">p[vertices[i]] = null;</div><div class="line">&#125;</div><div class="line">for (i=0; i&lt;vertices.length; i++)&#123;</div><div class="line">if (color[vertices[i]] === &apos;white&apos;)&#123;</div><div class="line">DFSVisit(vertices[i], color, d, f, p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return &#123; //&#123;4&#125;</div><div class="line">discovery: d,</div><div class="line">finished: f,</div><div class="line">predecessors: p</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">var DFSVisit = function(u, color, d, f, p)&#123;</div><div class="line">console.log(&apos;discovered &apos; + u);</div><div class="line">color[u] = &apos;grey&apos;;</div><div class="line">d[u] = ++time; //&#123;5&#125;</div><div class="line">var neighbors = adjList.get(u);</div><div class="line">for (var i=0; i&lt;neighbors.length; i++)&#123;</div><div class="line">var w = neighbors[i];</div><div class="line">if (color[w] === &apos;white&apos;)&#123;</div><div class="line">p[w] = u; // &#123;6&#125;</div><div class="line">DFSVisit(w,color, d, f, p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">color[u] = &apos;black&apos;;</div><div class="line">f[u] = ++time; //&#123;7&#125;</div><div class="line">console.log(&apos;explored &apos; + u);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>2.拓扑排序——使用深度优先搜索</p><h1 id="排序和搜索排序"><a href="#排序和搜索排序" class="headerlink" title="排序和搜索排序"></a>排序和搜索排序</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><pre><code>冒泡排序选择排序插入排序归并排序快速排序</code></pre><p><a href="">算法我这里就不再多讲了，如果感兴趣可以查看我之前的系列算法文章</a></p><h2 id="搜索排序"><a href="#搜索排序" class="headerlink" title="搜索排序"></a>搜索排序</h2><h3 id="顺序排序"><a href="#顺序排序" class="headerlink" title="顺序排序"></a>顺序排序</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">this.sequentialSearch = function(item)&#123;</div><div class="line">for (var i=0; i&lt;array.length; i++)&#123; //&#123;1&#125;</div><div class="line">if (item === array[i]) //&#123;2&#125;</div><div class="line">return i; //&#123;3&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return -1; //&#123;4&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。<br>(4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">this.binarySearch = function(item)&#123;</div><div class="line">this.quickSort(); //&#123;1&#125;</div><div class="line">var low = 0, //&#123;2&#125;</div><div class="line">high = array.length - 1, //&#123;3&#125;</div><div class="line">mid, element;</div><div class="line">while (low &lt;= high)&#123; //&#123;4&#125;</div><div class="line">mid = Math.floor((low + high) / 2); //&#123;5&#125;</div><div class="line">element = array[mid]; //&#123;6&#125;</div><div class="line">if (element &lt; item) &#123; //&#123;7&#125;</div><div class="line">low = mid + 1; //&#123;8&#125;</div><div class="line">&#125; else if (element &gt; item) &#123; //&#123;9&#125;</div><div class="line">high = mid - 1; //&#123;10&#125;</div><div class="line">&#125; else &#123;</div><div class="line">return mid; //&#123;11&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return -1; //&#123;12&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h1 id="算法补充知识"><a href="#算法补充知识" class="headerlink" title="算法补充知识"></a>算法补充知识</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>每款浏览器的javascript调用栈大小的限制。<br>    ECMAScript 6有尾调用优化（tail call optimization），使递归变快了。<br>    斐波那契数列</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划那样计算更大的格局。</p><h2 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h2><p>时间复杂度O(n)的代码只有一层循环，而O(n 2 )的代码有双层嵌套循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很可能就是O(n 3 )。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="序列数据结构"><a href="#序列数据结构" class="headerlink" title="序列数据结构"></a>序列数据结构</h2><p>1.数组（列表）<br>2.栈<br>3.队列<br>&nbsp;&nbsp;普通队列<br>&nbsp;&nbsp;优先队列<br>&nbsp;&nbsp;循环队列<br>4.链表<br>&nbsp;&nbsp;单向链表<br>&nbsp;&nbsp;双向链表<br>&nbsp;&nbsp;循环单向链表<br>&nbsp;&nbsp;循环双向链表<br>5.集合 Set</p><h2 id="非序列数据结构"><a href="#非序列数据结构" class="headerlink" title="非序列数据结构"></a>非序列数据结构</h2><p>1.散列<br>2.字典 Map</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组及矩阵（二维数组）和多维数组（a-b-均为数组）&quot;&gt;&lt;a href=&quot;#数组及矩阵（二维数组）和多维数组（a-b-均为数组）&quot; class=&quot;headerlink&quot; title=&quot;数组及矩阵（二维数组）和多维数组（a, b 均为数组）&quot;&gt;&lt;/a&gt;数组及矩阵（二
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-总结性文章</title>
    <link href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E6%80%A7%E6%96%87%E7%AB%A0.html"/>
    <id>https://fanerge.github.io/排序算法-总结性文章.html</id>
    <published>2017-11-23T12:26:14.000Z</published>
    <updated>2017-12-22T13:11:13.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法的基本概念"><a href="#排序算法的基本概念" class="headerlink" title="排序算法的基本概念"></a>排序算法的基本概念</h1><h2 id="什么叫排序？"><a href="#什么叫排序？" class="headerlink" title="什么叫排序？"></a>什么叫排序？</h2><p>排序(Sorting) 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。</p><h2 id="排序算法的性质"><a href="#排序算法的性质" class="headerlink" title="排序算法的性质"></a>排序算法的性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。<br>反之，不稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中S在R之前。</p><h3 id="时间复杂度（最差、平均、和最好性能）T-n"><a href="#时间复杂度（最差、平均、和最好性能）T-n" class="headerlink" title="时间复杂度（最差、平均、和最好性能）T(n)"></a>时间复杂度（最差、平均、和最好性能）T(n)</h3><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。<br>    T(n) = O(f(n))<br>一般而言，好的性能是 O(nlogn)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">查看时间复杂度计算方式</a></p><h3 id="空间复杂度S-n"><a href="#空间复杂度S-n" class="headerlink" title="空间复杂度S(n)"></a>空间复杂度S(n)</h3><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。</p><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>内排序：所有排序操作都在内存中完成。<br>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">更多详情</a></p><h1 id="先来张总结性图片"><a href="#先来张总结性图片" class="headerlink" title="先来张总结性图片"></a>先来张总结性图片</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt=""></p><h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（尾部），故名。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个（因为每次最后遍历的最后一个数都是最大的，所以不需要再次比较了）。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>选择排序法是对定位比较交换法（也就是冒泡排序法）的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</p><h2 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换，<br>2.第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换，<br>3.以此类推…<br>4.第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，<br>5.使有序序列不断增长直到全部排序完毕。<br>PS：冒泡排序是逐次把当前序列中最大值<span style="color: red;">推</span>到后面去。<br>    选择排序是逐次把当前序列中最小值<span style="color: red;">放</span>到前面去。<br><a href="https://fanerge.github.io/2017/11/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。<br>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。</p><h2 id="直接插入排序实现步骤"><a href="#直接插入排序实现步骤" class="headerlink" title="直接插入排序实现步骤"></a>直接插入排序实现步骤</h2><p>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：<br>①初始状态：无序区为R[1..n]，有序区为空。<br>②第1趟排序<br>在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br>……<br>③第i趟排序<br>第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。</p><h2 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.二分法查找插入位置<br>    如果R&lt;R[m]成立，那右指针就要向左移动中间指针一位，否则，左指针要向右移动中间指针一位。反复查找，直到左指针大于右指针时停止。<br>2.后移，有点迷惑，什么时候需要后移呢？有哪些记录需要移动呢？<br>    虽然我们很清楚的知道，我们需要后移那些排序码大于R的记录，但难免会问自己这样几个问题。其实它相当于需要移动从i-1到左指针的记录。<br>3.插入<br>    由1中得到的左指针其实就是元素要插入的位置。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p><h2 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>对数组arr，长度为n进行排序<br>1.第一个增量为Math.floor(n/2)，再最每个小的分租进行直接插入排序；<br>2.第二个增量为Math.floor(n/4)，再最每个小的分租进行直接插入排序；<br>3.以此类推…，直到增量为1，这是排序完成。<br><a href="https://fanerge.github.io/2017/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h2 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾,这时完成排序。<br><a href="https://fanerge.github.io/2017/11/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h2 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>一趟快速排序的算法是：排序序列A，N为排序序列长度<br>1.找基准（一般是以当前数组的第一项的值）<br>2.遍历数组，小于基准的放在left，大于基准的放在right<br>3.递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br><a href="https://fanerge.github.io/2017/11/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><h2 id="实现步骤-6"><a href="#实现步骤-6" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br><a href="https://fanerge.github.io/2017/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h2><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p><h2 id="实现步骤-7"><a href="#实现步骤-7" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出待排序的数组中最大和最小的元素；<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>4.反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br><a href="https://fanerge.github.io/2017/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="桶排序-Bucket-SORT）"><a href="#桶排序-Bucket-SORT）" class="headerlink" title="桶排序 (Bucket SORT）"></a>桶排序 (Bucket SORT）</h1><h2 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h2><p>输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。</p><h2 id="实现步骤-8"><a href="#实现步骤-8" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br><a href="https://fanerge.github.io/2017/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95/">或许你还是不太了解，这里有该算法的详细实现过程</a></p><h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h2><p>基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><h2 id="实现步骤-9"><a href="#实现步骤-9" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p></li><li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br><a href="https://fanerge.github.io/2017/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些算法我还记得在大学时学过的，只不过当然并没有太在意，这也许就是–欠下的债，终究是要还的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法的基本概念&quot;&gt;&lt;a href=&quot;#排序算法的基本概念&quot; class=&quot;headerlink&quot; title=&quot;排序算法的基本概念&quot;&gt;&lt;/a&gt;排序算法的基本概念&lt;/h1&gt;&lt;h2 id=&quot;什么叫排序？&quot;&gt;&lt;a href=&quot;#什么叫排序？&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-基数排序</title>
    <link href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html"/>
    <id>https://fanerge.github.io/排序算法-基数排序.html</id>
    <published>2017-11-22T12:04:29.000Z</published>
    <updated>2017-12-22T13:10:26.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序（radix-sort）的基础"><a href="#基数排序（radix-sort）的基础" class="headerlink" title="基数排序（radix sort）的基础"></a>基数排序（radix sort）的基础</h1><p>技术排序的定义：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><h1 id="基数排序步骤"><a href="#基数排序步骤" class="headerlink" title="基数排序步骤"></a>基数排序步骤</h1><p>以LSD为例，排序数组arr = [73, 22, 93, 43, 55, 14, 28, 65, 39, 81];<br>    注：最低位优先(Least Significant Digit first)法，简称LSD法<br>        最高位优先(Most Significant Digit first)法，简称MSD法</p><ol><li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p></li><li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>PS：LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line">//LSD Radix Sort</div><div class="line">function radixSort(array, maxDigit) &#123;</div><div class="line">var mod = 10;</div><div class="line">var dev = 1;</div><div class="line">var counter = [];</div><div class="line">var arr = array.slice();</div><div class="line">console.time(&apos;基数排序耗时&apos;);</div><div class="line">for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</div><div class="line">for(var j = 0; j &lt; arr.length; j++) &#123;</div><div class="line">var bucket = parseInt((arr[j] % mod) / dev);</div><div class="line">if(counter[bucket]== null) &#123;</div><div class="line">counter[bucket] = [];</div><div class="line">&#125;</div><div class="line">counter[bucket].push(arr[j]);</div><div class="line">&#125;</div><div class="line">var pos = 0;</div><div class="line">for(var j = 0; j &lt; counter.length; j++) &#123;</div><div class="line">var value = null;</div><div class="line">if(counter[j]!=null) &#123;</div><div class="line">while ((value = counter[j].shift()) != null) &#123;</div><div class="line">  arr[pos++] = value;</div><div class="line">&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">console.timeEnd(&apos;基数排序耗时&apos;);</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">var demo = radixSort(arr,2);</div><div class="line">console.log(arr); // [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(demo); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</div></pre></td></tr></table></figure></code></pre><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图">    </p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="external">基数排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基数排序（radix-sort）的基础&quot;&gt;&lt;a href=&quot;#基数排序（radix-sort）的基础&quot; class=&quot;headerlink&quot; title=&quot;基数排序（radix sort）的基础&quot;&gt;&lt;/a&gt;基数排序（radix sort）的基础&lt;/h1&gt;&lt;p&gt;技术
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-桶排序</title>
    <link href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95.html"/>
    <id>https://fanerge.github.io/排序算法-桶排算法.html</id>
    <published>2017-11-21T12:01:12.000Z</published>
    <updated>2017-12-22T13:10:50.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序的基础"><a href="#桶排序的基础" class="headerlink" title="桶排序的基础"></a>桶排序的基础</h1><p>桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。<br>桶排序的说明：桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O(n)）。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p><h1 id="桶排序的步骤"><a href="#桶排序的步骤" class="headerlink" title="桶排序的步骤"></a>桶排序的步骤</h1><div style="color: red;"><br>1.    找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.    计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.    再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.    将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.    将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br></div><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">// 插入排序</div><div class="line">function insertionSort(arr) &#123;</div><div class="line">var len = arr.length;</div><div class="line">var preIndex, current;</div><div class="line">for (var i = 1; i &lt; len; i++) &#123;</div><div class="line">preIndex = i - 1;</div><div class="line">current = arr[i];</div><div class="line">while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">arr[preIndex+1] = arr[preIndex];</div><div class="line">preIndex--;</div><div class="line">&#125;</div><div class="line">arr[preIndex+1] = current;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶排序</div><div class="line">function bucketSort(array, bucketSize) &#123;</div><div class="line">let arr = array.slice();</div><div class="line">let i;</div><div class="line">let minValue = arr[0];</div><div class="line">let maxValue = arr[0];</div><div class="line"></div><div class="line">// 空数组时直接返回空数组</div><div class="line">if (arr.length === 0) &#123;</div><div class="line">  return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for (i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">  if (arr[i] &lt; minValue) &#123;</div><div class="line">  minValue = arr[i];                //输入数据的最小值</div><div class="line">  &#125; else if (arr[i] &gt; maxValue) &#123;</div><div class="line">  maxValue = arr[i];                //输入数据的最大值</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶的初始化</div><div class="line">let DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5</div><div class="line">bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</div><div class="line">let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   </div><div class="line">let buckets = new Array(bucketCount);</div><div class="line"></div><div class="line">// 二维数组，每个桶初始化为空数组</div><div class="line">for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">buckets[i] = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 利用映射函数将数据分配到各个桶中</div><div class="line">for (i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">arr.length = 0;</div><div class="line">for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">insertionSort(buckets[i]);                      //对每个桶进行插入排序</div><div class="line">for (var j = 0; j &lt; buckets[i].length; j++) &#123;</div><div class="line">arr.push(buckets[i][j]);                      </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109];</div><div class="line">var demo = bucketSort(arr, 4); // 这里我分配了4个桶，桶越多越快但需要的内存就越多</div><div class="line">console.log(arr); // [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]</div><div class="line">console.log(demo); // [13, 28, 47, 51, 63, 67, 98, 101, 109, 117, 121, 133, 139, 141, 156, 157, 157, 181, 189, 194]</div></pre></td></tr></table></figure></code></pre><p>PS：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br>什么时候最快（Best Cases）：<br>  当输入的数据可以均匀的分配到每一个桶中<br>什么时候最慢（Worst Cases）：<br>  当输入的数据被分配到了同一个桶中</li></ol><h1 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg" alt="图片展示"></p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin#4_2" target="_blank" rel="external">桶排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序的基础&quot;&gt;&lt;a href=&quot;#桶排序的基础&quot; class=&quot;headerlink&quot; title=&quot;桶排序的基础&quot;&gt;&lt;/a&gt;桶排序的基础&lt;/h1&gt;&lt;p&gt;桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-计数排序</title>
    <link href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html"/>
    <id>https://fanerge.github.io/排序算法-计数排序.html</id>
    <published>2017-11-20T12:15:37.000Z</published>
    <updated>2017-12-22T13:10:32.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序的基础"><a href="#计数排序的基础" class="headerlink" title="计数排序的基础"></a>计数排序的基础</h1><p>定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）<br>计数排序对输入的数据有附加的限制条件：<br>    1、输入的线性表的元素属于有限偏序集S；<br>    2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。    </p><h1 id="计数排序算法思想"><a href="#计数排序算法思想" class="headerlink" title="计数排序算法思想"></a>计数排序算法思想</h1><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p><h1 id="现实计数算法"><a href="#现实计数算法" class="headerlink" title="现实计数算法"></a>现实计数算法</h1><h2 id="具体算法实现步骤"><a href="#具体算法实现步骤" class="headerlink" title="具体算法实现步骤"></a>具体算法实现步骤</h2><p><1>. 找出待排序的数组中最大和最小的元素；</1></p><p><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></p><p><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></p><p><4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function countingSort(arr)&#123;</div><div class="line">let len = arr.length,</div><div class="line">Result = [], // 保存排序后的数组</div><div class="line">Count = [], // 保存各项出现次数的数组</div><div class="line">min = max = arr[0];</div><div class="line">console.time(&apos;计数排序计时&apos;);</div><div class="line"></div><div class="line">// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数</div><div class="line">for(var i = 0; i &lt; len; i++)&#123;</div><div class="line">Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数</div><div class="line">min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值</div><div class="line">max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 从最小值-&gt;最大值,将计数逐项相加</div><div class="line">for(var j = min; j &lt; max; j++)&#123;</div><div class="line">Count[j+1] = (Count[j+1]||0)+(Count[j]||0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</div><div class="line">for(var k = len - 1; k &gt;= 0;k--)&#123;</div><div class="line">/*Result[位置] = arr数据*/</div><div class="line">Result[Count[arr[k]] - 1] = arr[k];</div><div class="line">/*减少Count数组中保存的计数*/</div><div class="line">Count[arr[k]]--;</div><div class="line">/*显示Result数组每一步详情*/</div><div class="line">console.log(Result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.timeEnd(&apos;计数排序计时&apos;);</div><div class="line">return Result;</div><div class="line">&#125;</div><div class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</div><div class="line">console.log(countingSort(arr));</div></pre></td></tr></table></figure></4></p><pre><code>PS：时间复杂度：T(n) = O(n)空间复杂度：S(n) = O(k)是否稳定：是排序方式：外排序</code></pre><p>运行结果为:<br>[ , , , , , , , , , , , , , 48 ]<br>[ , , , , , , , , , , , , , 48, 50 ]<br>[ , , , , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>计数排序计时: 16ms<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图 | center"></p><blockquote><p>   参考文档：<br>    <a href="http://hao.jser.com/archive/13600/" target="_blank" rel="external">基本算法学习(四)之计数排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin" target="_blank" rel="external">计数排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数排序的基础&quot;&gt;&lt;a href=&quot;#计数排序的基础&quot; class=&quot;headerlink&quot; title=&quot;计数排序的基础&quot;&gt;&lt;/a&gt;计数排序的基础&lt;/h1&gt;&lt;p&gt;定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-堆排序</title>
    <link href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F.html"/>
    <id>https://fanerge.github.io/排序算法-堆排序.html</id>
    <published>2017-11-15T11:47:34.000Z</published>
    <updated>2017-12-22T13:09:58.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序（Heapsort）的基础"><a href="#堆排序（Heapsort）的基础" class="headerlink" title="堆排序（Heapsort）的基础"></a>堆排序（Heapsort）的基础</h1><p>定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><h1 id="我们需要了解什么叫堆"><a href="#我们需要了解什么叫堆" class="headerlink" title="我们需要了解什么叫堆"></a>我们需要了解什么叫堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：<br>        (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点<br>        若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p><h2 id="来个例子说明"><a href="#来个例子说明" class="headerlink" title="来个例子说明"></a>来个例子说明</h2><p>【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。<br>    小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。<br>    大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。<br>    注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。<br>    来张图表示一下：<br>    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b360e14f7bec54e755e1124cd851f035/43a7d933c895d1433f14885273f082025aaf0764.jpg" alt="大跟堆和小跟堆"></p><h2 id="堆的高度"><a href="#堆的高度" class="headerlink" title="堆的高度"></a>堆的高度</h2><p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p><div style="color: red;"><br>    <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>    <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>    <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br></3></2></1></div>    </p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>```/** * 对数组中的前n项整理成堆 * @param array * @param n */function refreshHeap(array, n){    if(array.length&lt;n)n = array.length;    //array[n/2-1]表示的是最后一个有子节点的节点    for(let i=Math.floor(n/2)-1;i&gt;=0;i--){        //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点        //这个while是判断当前节点与其子节点是否需要调整        while(2*i+1&lt;n){            let j = 2*i+1;            //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点            if(j+1&lt;n){                //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点）                if(array[j]&lt;a[j+1]){                    j++;                }            }            //如果最大子节点大于其父节点，则交换            if(a[i]&lt;a[j]){                let tmp = a[i];                a[i] = a[j];                a[j] = tmp;                //交换之后整个堆被破坏，需要重新调整，故令i=j                //这个调整表示的是从j节点开始判断堆是否需要调整                //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整                i = j;            }else{                break;            }        }    }    return array;}function heapSort(array, n){    if(array.length&lt;n)n = array.length;    while(n&gt;0){        //刷新堆之后，将array[0]（最大值）与最后一个子节点交换        //然后重新刷新堆(不包括最后那些排好序的节点了)        refreshHeap(array, n--);        let tmp = array[n];        array[n] = array[0];        array[0] = tmp;    }    return array;}var a = [16,7,3,20,17,8];console.log(a); // [16, 7, 3, 20, 17, 8]heapSort(a,a.length);console.log(a); // [3, 7, 8, 16, 17, 20]```    </code></pre><p>时间复杂度：T(n) = O(nlogn)<br>空间复杂度：S(n) = O(1)<br>稳定性：不稳定<br>排序方式：内排序    </p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F" alt="动图">    </p><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/liuyaqi1993/article/details/69569059" target="_blank" rel="external">JavaScript数据结构之 堆排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="external">堆排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆排序（Heapsort）的基础&quot;&gt;&lt;a href=&quot;#堆排序（Heapsort）的基础&quot; class=&quot;headerlink&quot; title=&quot;堆排序（Heapsort）的基础&quot;&gt;&lt;/a&gt;堆排序（Heapsort）的基础&lt;/h1&gt;&lt;p&gt;定义：堆排序(Heapsor
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-快速排序</title>
    <link href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>https://fanerge.github.io/排序算法-快速排序.html</id>
    <published>2017-11-14T12:13:47.000Z</published>
    <updated>2017-12-22T13:10:38.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序（Quicksort）的基础"><a href="#快速排序（Quicksort）的基础" class="headerlink" title="快速排序（Quicksort）的基础"></a>快速排序（Quicksort）的基础</h1><p>定义：快速排序（Quicksort）是对冒泡排序的一种改进。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="快速排序算法的介绍"><a href="#快速排序算法的介绍" class="headerlink" title="快速排序算法的介绍"></a>快速排序算法的介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br>一趟快速排序的算法是：<br>    1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>    2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>    3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>    4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>    5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><h1 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h1><p>假设用户输入了如下数组：<br><span style="padding-left: 24px; color: red;">6, 2, 7, 3, 8, 9</span><br>1.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。<br>我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：<br><span style="padding-left: 24px; color: red;">3, 2, 7, 6, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=0 j=3 k=6</span><br>接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=2 j=3 k=6</span><br>称上面两次比较为一个循环。<br>接着，再递减变量j，不断重复进行上面的循环比较。<br>在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br>如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。<br>然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。<br>注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前面讲了那么多了，简单就记住下面的步骤就好了。</p><p><div style="color: red;"><br>1、找基准（一般是以当前数组的第一项的值）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br></div><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function quickSort(array)&#123;</div><div class="line">let arr = array.slice();</div><div class="line"></div><div class="line">//如果数组&lt;=1,则直接返回</div><div class="line">if(arr.length&lt;=1)&#123;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//找基准，并把基准从原数组删除</div><div class="line">var pivot=arr.splice(0,1)[0];</div><div class="line">//定义左右数组</div><div class="line">var left=[];</div><div class="line">var right=[];</div><div class="line"></div><div class="line">//比基准小的放在left，比基准大的放在right</div><div class="line">for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">if(arr[i]&lt;=pivot)&#123;</div><div class="line">left.push(arr[i]);</div><div class="line">&#125;</div><div class="line">else&#123;</div><div class="line">right.push(arr[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//递归</div><div class="line">return quickSort(left).concat([pivot],quickSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [6, 2, 7, 3, 8, 9];</div><div class="line">let demo = quickSort(arr);</div><div class="line"></div><div class="line">console.log(arr); // [6, 2, 7, 3, 8, 9];</div><div class="line">console.log(demo); // [2, 3, 6, 7, 8, 9];</div></pre></td></tr></table></figure></p><p>时间复杂度：T(n) = O(n^2)<br>空间复杂度：S(n) = O(logn)<br>稳定性：不稳定<br>是否为内排序：是</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源网络，在次表示感谢</a></p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dll-ft/p/5850487.html" target="_blank" rel="external">JS实现快速排序</a><br>    <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&amp;fromid=2084344&amp;fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#3_7" target="_blank" rel="external">快速排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序（Quicksort）的基础&quot;&gt;&lt;a href=&quot;#快速排序（Quicksort）的基础&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quicksort）的基础&quot;&gt;&lt;/a&gt;快速排序（Quicksort）的基础&lt;/h1&gt;&lt;p&gt;定义：快速排
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
