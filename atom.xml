<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2018-06-18T08:40:35.512Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS技巧</title>
    <link href="https://fanerge.github.io/2018/CSS%E6%8A%80%E5%B7%A7.html"/>
    <id>https://fanerge.github.io/2018/CSS技巧.html</id>
    <published>2018-06-13T14:29:35.000Z</published>
    <updated>2018-06-18T08:40:35.512Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结日常CSS技巧，大多收集于网络、<a href="http://www.ituring.com.cn/book/1695" target="_blank" rel="external">《CSS揭秘》</a></p><h2 id="半透明边框"><a href="#半透明边框" class="headerlink" title="半透明边框"></a>半透明边框</h2><p>思路：默认 background 是从  border-box 裁切，我们可以通过 background-clip 属性来改变 background 裁切区域如 padding-box，在使用 rgba 或者 hsla 来指定边框颜色即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.border &#123;</div><div class="line">border: 10px solid hsla(0,0%,100%,.5);</div><div class="line">background: white;</div><div class="line">background-clip: padding-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/translucent-borders">半透明边框</a><br>PS：根据 stack context 层级关系 background 在 border 下层。</p><h2 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h2><h3 id="box-shadow-方案"><a href="#box-shadow-方案" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><p>思路：首先要知道 box-shadow 的参数：vl hl blurl spreadl color inset，并且支持多重阴影。<br><a href="play.csssecrets.io/multiple-borders">demo</a><br>PS：box-shadow 不影响布局（不占用空间）、不受 box-sizing 的控制、不适用于增加热点区域。</p><h3 id="outline-方案"><a href="#outline-方案" class="headerlink" title="outline 方案"></a>outline 方案</h3><p>只适用于两层边框。<br>PS：当 border 为圆角时，outline 不会贴合元素的圆角，需要使用 box-shadow 来填补。 </p><h2 id="灵活的背景定位"><a href="#灵活的背景定位" class="headerlink" title="灵活的背景定位"></a>灵活的背景定位</h2><h3 id="background-position-的扩展语法方案"><a href="#background-position-的扩展语法方案" class="headerlink" title="background-position 的扩展语法方案"></a>background-position 的扩展语法方案</h3><p><code>background-position: right 20px bottom 10px;</code><br>PS：背景定位于 right 的 20px处，bottom 的 10px处。<br><a href="play.csssecrets.io/extended-bg-position">bg-position</a></p><h3 id="background-origin-方案"><a href="#background-origin-方案" class="headerlink" title="background-origin 方案"></a>background-origin 方案</h3><p>background-origin 属性指定 background-position 属性应该是相对位置。<br><a href="play.csssecrets.io/background-origin">background-origin</a></p><h3 id="calc-方案"><a href="#calc-方案" class="headerlink" title="calc() 方案"></a>calc() 方案</h3><p><code>background-position: calc(100% - 20px) calc(100% - 10px);</code><br>PS：需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)。<br><a href="play.csssecrets.io/background-position-calc">background-position-calc</a></p><h2 id="边框内圆角"><a href="#边框内圆角" class="headerlink" title="边框内圆角"></a>边框内圆角</h2><p>我们知道box-shadow是会紧贴border-radius圆角边的，但是，描边outline并不会与圆角边border-radius贴合，我们可以将两者组合，通过box-shadow去填补描边outline所产生的间隙来达到我们想要的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">border-radius: 8px;</div><div class="line">    outline: 6px solid #b4a078;</div><div class="line">    box-shadow: 0 0 0 5px #b4a078; // 用于填充 outline 不能紧靠 border-radius</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://lhammer.cn/You-need-to-know-css/#/inner-rounding" target="_blank" rel="external">边框内圆角</a></p><h2 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h2><h3 id="横向条纹（默认横向渐变）"><a href="#横向条纹（默认横向渐变）" class="headerlink" title="横向条纹（默认横向渐变）"></a>横向条纹（默认横向渐变）</h3><p>如形成三条间隔条纹背景。<br><code>background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);</code><br>PS：#58a 0 的作用为直接填充 &gt; 33.3% 的部分。<br><a href="play.csssecrets.io/horizontal-stripes">horizontal-stripes</a></p><h3 id="垂直条纹"><a href="#垂直条纹" class="headerlink" title="垂直条纹"></a>垂直条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(to right, /* 或 90deg */#fb3 50%, #58a 0);</div><div class="line">background-size: 30px 100%;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/vertical-stripes">vertical-stripes</a></p><h3 id="斜向条纹"><a href="#斜向条纹" class="headerlink" title="斜向条纹"></a>斜向条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);</div><div class="line">background-size: 42.426406871px 42.426406871px;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/diagonal-stripes">diagonal-stripes</a><br><a href="play.csssecrets.io/diagonal-stripes-60deg">diagonal-stripes-60deg</a></p><h3 id="灵活的同色系条纹"><a href="#灵活的同色系条纹" class="headerlink" title="灵活的同色系条纹"></a>灵活的同色系条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: #58a;</div><div class="line">background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/subtle-stripes">subtle-stripes</a></p><h2 id="复杂的背景图案"><a href="#复杂的背景图案" class="headerlink" title="复杂的背景图案"></a>复杂的背景图案</h2><p><a href="play.csssecrets.io/blueprint">网格</a><br><a href="play.csssecrets.io/polka">波点</a><br><a href="play.csssecrets.io/test-conic-gradient">角向渐变</a><br><a href="http://lea.verou.me/css3patterns/" target="_blank" rel="external">css3patterns</a><br><a href="http://bennettfeely.com/gradients/" target="_blank" rel="external">图案库</a></p><h2 id="连续的图像边框"><a href="#连续的图像边框" class="headerlink" title="连续的图像边框"></a>连续的图像边框</h2><p>设置多层背景，再通过 background-clip 来裁剪各层背景。<br><a href="play.csssecrets.io/continuous-image-borders">图像边框</a><br><a href="play.csssecrets.io/vintage-envelope">信封背景</a><br><a href="play.csssecrets.io/marching-ants">蚂蚁行军边框</a><br><a href="play.csssecrets.io/footnote">footnote</a></p><h2 id="自适应的椭圆"><a href="#自适应的椭圆" class="headerlink" title="自适应的椭圆"></a>自适应的椭圆</h2><p>前提为 width === height<br>圆形：<code>border-radius: 100px;</code><br>椭圆：<code>border-radius: 100px / 75px;</code><br>适应性椭圆：<code>border-radius: 50%;</code><br>PS：50%; === 50% / 50%;分别为该元素的宽的50%和高的50%。<br><a href="play.csssecrets.io/ellipse">适应性椭圆</a><br>适应性的半椭圆：<code>border-radius: 100% 0 0 100% / 50%;</code><br>PS：上面的写法，分别为四个角设置。<br><a href="play.csssecrets.io/half-ellipse">适应性的半椭圆</a><br>四分之一椭圆：<code>border-radius: 100% 0 0 0;</code><br>PS：其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。<br><a href="play.csssecrets.io/quarter-ellipse">quarter-ellipse</a></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p>需求为让容器元素为平行四边形，但文本不可倾斜。</p><h3 id="嵌套元素方案"><a href="#嵌套元素方案" class="headerlink" title="嵌套元素方案"></a>嵌套元素方案</h3><p><a href="play.csssecrets.io/parallelograms">抵消策略</a><br>PS：对容器进行 skew() 变形，对内容再应用一次反向的 skew() 变形，从而抵消容器的变形效果</p><h3 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><p><a href="play.csssecrets.io/parallelograms-pseudo">parallelograms-pseudo</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p><h2 id="菱形图片"><a href="#菱形图片" class="headerlink" title="菱形图片"></a>菱形图片</h2><h3 id="基于变形的方案"><a href="#基于变形的方案" class="headerlink" title="基于变形的方案"></a>基于变形的方案</h3><p><a href="play.csssecrets.io/diamond-images">diamond-images</a><br>PS：运用 rotate(-45deg) 再使用 scale(1.42) 填满菱形区域。</p><h3 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p><code>clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);</code><br><a href="play.csssecrets.io/diamond-clip">diamond-clip</a></p><h2 id="切角效果"><a href="#切角效果" class="headerlink" title="切角效果"></a>切角效果</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p><a href="play.csssecrets.io/bevel-corners-gradients">线性渐变</a></p><h3 id="弧形切角"><a href="#弧形切角" class="headerlink" title="弧形切角"></a>弧形切角</h3><p><a href="play.csssecrets.io/scoop-corners">径向渐变</a></p><h3 id="内联-SVG-与-border-image-方案"><a href="#内联-SVG-与-border-image-方案" class="headerlink" title="内联 SVG 与 border-image 方案"></a>内联 SVG 与 border-image 方案</h3><p>相关 SVG 支持，以背景形式引入 SVG。<br><a href="play.csssecrets.io/bevel-corners">bevel-corners</a></p><h3 id="裁切路径方案-1"><a href="#裁切路径方案-1" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p>主要使用 clip-path 属性。<br><a href="play.csssecrets.io/bevel-corners-clipped">bevel-corners-clipped</a></p><h2 id="梯形标签页"><a href="#梯形标签页" class="headerlink" title="梯形标签页"></a>梯形标签页</h2><p>需求为让容器元素为梯形，但文本不可倾斜。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform: perspective(.5em) rotateX(5deg);</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/trapezoid-tabs">trapezoid-tabs</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p><h2 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h2><h3 id="基于-transform-的解决方案"><a href="#基于-transform-的解决方案" class="headerlink" title="基于 transform 的解决方案"></a>基于 transform 的解决方案</h3><p><a href="play.csssecrets.io/pie-animated">pie-animated</a><br><a href="play.csssecrets.io/pie-static">pie-static</a></p><h3 id="SVG-解决方案"><a href="#SVG-解决方案" class="headerlink" title="SVG 解决方案"></a>SVG 解决方案</h3><p><a href="play.csssecrets.io/pie-svg">pie-svg</a></p><h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>box-shadow: hl vl blur spread color;<br>PS：hl为水平位置，vl为垂直位置，blur为模糊距离（模糊面积越大，阴影就越大越淡），spread为阴影大小（取正值时，阴影扩大；取负值时，阴影收缩）。    </p><h3 id="单侧投影"><a href="#单侧投影" class="headerlink" title="单侧投影"></a>单侧投影</h3><p><code>box-shadow: 0 5px 4px -4px black;</code><br><a href="play.csssecrets.io/shadow-one-side">shadow-one-side</a><br>PS：第四个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。</p><h3 id="对边投影"><a href="#对边投影" class="headerlink" title="对边投影"></a>对边投影</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box-shadow: 5px 0 5px -5px black,</div><div class="line">-5px 0 5px -5px black;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/shadow-opposite-sides">shadow-opposite-sides</a><br>PS：利用 box-shadow 可以设置多重阴影。</p><h2 id="不规则投影"><a href="#不规则投影" class="headerlink" title="不规则投影"></a>不规则投影</h2><h3 id="filter-之-drop-shadow"><a href="#filter-之-drop-shadow" class="headerlink" title="filter 之 drop-shadow()"></a>filter 之 drop-shadow()</h3><p><a href="https://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/" target="_blank" rel="external">drop-shadow滤镜与box-shadow区别应用</a><br><a href="https://www.zhangxinxu.com/study/201605/drop-shadow-point-to.html" target="_blank" rel="external">demo</a><br><a href="play.csssecrets.io/drop-shadow">demo1</a><br>PS：drop-shadow 没有 inset，不能叠加，有颜色就会有阴影（不特定于盒模型）。</p><h2 id="染色效果"><a href="#染色效果" class="headerlink" title="染色效果"></a>染色效果</h2><h3 id="基于滤镜的方案"><a href="#基于滤镜的方案" class="headerlink" title="基于滤镜的方案"></a>基于滤镜的方案</h3><p><a href="play.csssecrets.io/color-tint-filter">color-tint-filter</a><br><a href="http://www.runoob.com/cssref/css3-pr-filter.html" target="_blank" rel="external">滤镜文档</a></p><h3 id="基于混合模式的方案"><a href="#基于混合模式的方案" class="headerlink" title="基于混合模式的方案"></a>基于混合模式的方案</h3><p>background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。<br><a href="play.csssecrets.io/color-tint">color-tint</a></p><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p><a href="play.csssecrets.io/frosted-glass">frosted-glass</a><br>PS：伪类来实现效果，原本元素放文本，就不会导致文本模糊。</p><h2 id="折角效果"><a href="#折角效果" class="headerlink" title="折角效果"></a>折角效果</h2><h3 id="45°折角的解决方案"><a href="#45°折角的解决方案" class="headerlink" title="45°折角的解决方案"></a>45°折角的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">background: #58a; /* 回退样式 */</div><div class="line">background: linear-gradient(to left bottom,</div><div class="line">transparent 50%, rgba(0,0,0,.4) 0)</div><div class="line">no-repeat 100% 0 / 2em 2em,</div><div class="line">linear-gradient(-135deg,</div><div class="line">transparent 1.5em, #58a 0);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/folded-corner">folded-corner</a></p><h3 id="其他角度的解决方案"><a href="#其他角度的解决方案" class="headerlink" title="其他角度的解决方案"></a>其他角度的解决方案</h3><p><a href="play.csssecrets.io/folded-corner-realistic">folded-corner-realistic</a><br><a href="play.csssecrets.io/folded-corner-mixin">folded-corner-mixin</a></p><h2 id="连字符断行"><a href="#连字符断行" class="headerlink" title="连字符断行"></a>连字符断行</h2><p>CSS 属性 hyphens 告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。<br><a href="play.csssecrets.io/hyphenation">hyphenation</a></p><h2 id="插入换行"><a href="#插入换行" class="headerlink" title="插入换行"></a>插入换行</h2><p><a href="play.csssecrets.io/line-breaks">line-breaks</a><br>PS：有一个 Unicode 字符是专门代表换行符的： 0x000A ① 。在 CSS 中，这个字符可以写作 “\000A” ，或简化为 “\A” ，类似于 br 标签。</p><h2 id="文本行的斑马条纹"><a href="#文本行的斑马条纹" class="headerlink" title="文本行的斑马条纹"></a>文本行的斑马条纹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">padding: .5em;</div><div class="line">line-height: 1.5;</div><div class="line">background: beige;</div><div class="line">background-size: auto 3em;</div><div class="line">background-origin: content-box;</div><div class="line">background-image: linear-gradient(rgba(0,0,0,.2) 50%,</div><div class="line">transparent 0);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/zebra-lines">zebra-lines</a></p><h2 id="调整-tab-的宽度"><a href="#调整-tab-的宽度" class="headerlink" title="调整 tab 的宽度"></a>调整 tab 的宽度</h2><p>tab-size 属性规定制表符（tab）字符的空格长度，只对 textarea 和 pre 有效。<br><a href="play.csssecrets.io/tab-size">tab-size</a></p><h2 id="连字"><a href="#连字" class="headerlink" title="连字"></a>连字</h2><p>font-variant-ligatures<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures;</div></pre></td></tr></table></figure></p><h2 id="未来的文本下划线"><a href="#未来的文本下划线" class="headerlink" title="未来的文本下划线"></a>未来的文本下划线</h2><p>text-decoration-color 用于自定义下划线或其他装饰效果的颜色。<br>text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。<br>text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。<br>text-underline-position 用于微调下划线的具体摆放位置。<br><a href="play.csssecrets.io/underlines">underlines</a></p><h2 id="现实中的文字效果"><a href="#现实中的文字效果" class="headerlink" title="现实中的文字效果"></a>现实中的文字效果</h2><p><a href="play.csssecrets.io/letterpress">凸版印刷效果</a><br><a href="play.csssecrets.io/stroked-text">空心字效果</a><br><a href="play.csssecrets.io/glow">文字外发光效果</a><br><a href="play.csssecrets.io/extruded">文字凸起效果</a></p><h2 id="环形文字"><a href="#环形文字" class="headerlink" title="环形文字"></a>环形文字</h2><p><a href="play.csssecrets.io/circular-text">SVG实现</a></p><h2 id="选用合适的鼠标光标"><a href="#选用合适的鼠标光标" class="headerlink" title="选用合适的鼠标光标"></a>选用合适的鼠标光标</h2><h3 id="提示禁用状态"><a href="#提示禁用状态" class="headerlink" title="提示禁用状态"></a>提示禁用状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</div><div class="line">cursor: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/disabled">disabled</a></p><h3 id="隐藏鼠标光标"><a href="#隐藏鼠标光标" class="headerlink" title="隐藏鼠标光标"></a>隐藏鼠标光标</h3><p>适用于播放 video 等情形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cursor: url(&apos;transparent.gif&apos;); // 兼容低版本</div><div class="line">cursor: none;</div></pre></td></tr></table></figure></p><h2 id="扩大可点击区域"><a href="#扩大可点击区域" class="headerlink" title="扩大可点击区域"></a>扩大可点击区域</h2><h3 id="Fitts-法则-或-菲茨定律-或-费茨法则"><a href="#Fitts-法则-或-菲茨定律-或-费茨法则" class="headerlink" title="Fitts 法则 或 菲茨定律 或 费茨法则"></a>Fitts 法则 或 菲茨定律 或 费茨法则</h3><p>人机交互的一个法则<br>Fitts 法则认为，人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。</p><h3 id="border-增加用户交互区域"><a href="#border-增加用户交互区域" class="headerlink" title="border 增加用户交互区域"></a>border 增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">border: 10px solid transparent;</div><div class="line">box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;</div><div class="line">background-clip: padding-box;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/hit-area-border">hit-area-border</a></p><h3 id="伪类增加用户交互区域"><a href="#伪类增加用户交互区域" class="headerlink" title="伪类增加用户交互区域"></a>伪类增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">button &#123;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">button::before &#123;</div><div class="line">content: &apos;&apos;;</div><div class="line">position: absolute;</div><div class="line">top: -10px; right: -10px;</div><div class="line">bottom: -10px; left: -10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/hit-area">hit-area</a></p><h2 id="自定义复选框"><a href="#自定义复选框" class="headerlink" title="自定义复选框"></a>自定义复选框</h2><p><a href="play.csssecrets.io/checkboxes">checkboxes</a><br><a href="play.csssecrets.io/toggle-buttons">toggle-buttons</a></p><h2 id="通过阴影来弱化背景"><a href="#通过阴影来弱化背景" class="headerlink" title="通过阴影来弱化背景"></a>通过阴影来弱化背景</h2><h3 id="伪元素方案-1"><a href="#伪元素方案-1" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body.dimmed::before &#123;</div><div class="line">position: fixed;</div><div class="line">top: 0;</div><div class="line">right: 0;</div><div class="line">bottom: 0;</div><div class="line">left: 0;</div><div class="line">z-index: 1;</div><div class="line">background: rgba(0,0,0,.8);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="box-shadow-方案-1"><a href="#box-shadow-方案-1" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);</div></pre></td></tr></table></figure><p><a href="box-shadow: 0 0 0 50vmax rgba(0,0,0,.8" target="_blank" rel="external">box-shadow</a>;)</p><h3 id="backdrop-方案"><a href="#backdrop-方案" class="headerlink" title="backdrop 方案"></a>backdrop 方案</h3><p><a href="play.csssecrets.io/native-modal">backdrop</a><br>PS：dialog 元素（ <dialog> 元素可以由它的 showModal() 方法显示出来），那么根据浏览器的默认样式，它会自带一个遮罩层（ ::backdrop 伪元素）。</dialog></p><h2 id="通过模糊来弱化背景"><a href="#通过模糊来弱化背景" class="headerlink" title="通过模糊来弱化背景"></a>通过模糊来弱化背景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main.de-emphasized &#123;</div><div class="line">filter: blur(3px) contrast(.8) brightness(.8);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/deemphasizing-blur">滤镜效果</a></p><h2 id="滚动提示"><a href="#滚动提示" class="headerlink" title="滚动提示"></a>滚动提示</h2><p><a href="play.csssecrets.io/scrolling-hints">上下滚动</a></p><h2 id="交互式的图片对比控件"><a href="#交互式的图片对比控件" class="headerlink" title="交互式的图片对比控件"></a>交互式的图片对比控件</h2><p><a href="play.csssecrets.io/image-slider">image-slider</a></p><h2 id="自适应内部元素"><a href="#自适应内部元素" class="headerlink" title="自适应内部元素"></a>自适应内部元素</h2><p>width 新添了一些属性，如min-content。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">figure &#123;</div><div class="line">max-width: 300px;</div><div class="line">max-width: min-content;</div><div class="line">margin: auto;</div><div class="line">&#125;</div><div class="line">figure &gt; img &#123; max-width: inherit; &#125;</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/intrinsic-sizing">intrinsic-sizing</a></p><h2 id="精确控制表格列宽"><a href="#精确控制表格列宽" class="headerlink" title="精确控制表格列宽"></a>精确控制表格列宽</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table &#123;</div><div class="line">table-layout: fixed;</div><div class="line">width: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/table-column-widths">table-column-widths</a></p><h2 id="根据兄弟元素的数量来设置样式"><a href="#根据兄弟元素的数量来设置样式" class="headerlink" title="根据兄弟元素的数量来设置样式"></a>根据兄弟元素的数量来设置样式</h2><h3 id="相当于li-only-child"><a href="#相当于li-only-child" class="headerlink" title="相当于li:only-child"></a>相当于li:only-child</h3><p>li:first-child:nth-last-child(1)</p><h3 id="当列表正好包含四项时，命中所有列表项"><a href="#当列表正好包含四项时，命中所有列表项" class="headerlink" title="当列表正好包含四项时，命中所有列表项"></a>当列表正好包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(4),<br>li:first-child:nth-last-child(4) ~ li</p><h3 id="当列表至少包含四项时，命中所有列表项"><a href="#当列表至少包含四项时，命中所有列表项" class="headerlink" title="当列表至少包含四项时，命中所有列表项"></a>当列表至少包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+4),<br>li:first-child:nth-last-child(n+4) ~ li</p><h3 id="当列表最多包含四项时，命中所有列表项"><a href="#当列表最多包含四项时，命中所有列表项" class="headerlink" title="当列表最多包含四项时，命中所有列表项"></a>当列表最多包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(-n+4),<br>li:first-child:nth-last-child(-n+4) ~ li </p><h3 id="当列表包含2～6项时，命中所有列表项"><a href="#当列表包含2～6项时，命中所有列表项" class="headerlink" title="当列表包含2～6项时，命中所有列表项"></a>当列表包含2～6项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+2):nth-last-child(-n+6),<br>li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li<br><a href="play.csssecrets.io/styling-sibling-count">styling-sibling-count</a></p><h2 id="满幅的背景，定宽的内容"><a href="#满幅的背景，定宽的内容" class="headerlink" title="满幅的背景，定宽的内容"></a>满幅的背景，定宽的内容</h2><p><a href="play.csssecrets.io/fluid-fixed">fluid-fixed</a></p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">position: absolute;</div><div class="line">top: 50%;</div><div class="line">left: 50%;</div><div class="line">transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">width: 18em;</div><div class="line">padding: 1em 1.5em;</div><div class="line">margin: 50vh auto 0; // 这里不能使用50%，详细请了解包含快知识</div><div class="line">transform: translateY(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">&#125;</div><div class="line">main &#123;</div><div class="line">margin: auto; // 水平和垂直都可以居中</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案（匿名容器）"><a href="#基于-Flexbox-的解决方案（匿名容器）" class="headerlink" title="基于 Flexbox 的解决方案（匿名容器）"></a>基于 Flexbox 的解决方案（匿名容器）</h3><p>PS：匿名容器即为没有被标签包裹的文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">align-items: center;</div><div class="line">justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="紧贴底部的页脚"><a href="#紧贴底部的页脚" class="headerlink" title="紧贴底部的页脚"></a>紧贴底部的页脚</h2><p>下列 header、main、footer 为 body 的子元素。</p><h3 id="固定高度的解决方案"><a href="#固定高度的解决方案" class="headerlink" title="固定高度的解决方案"></a>固定高度的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">min-height: calc(100vh - footerHeight);</div><div class="line">/* 避免内边距或边框搞乱高度的计算： */</div><div class="line">box-sizing: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="flex的解决方案"><a href="#flex的解决方案" class="headerlink" title="flex的解决方案"></a>flex的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">display: flex;</div><div class="line">flex-flow: column;</div><div class="line">min-height: 100vh;</div><div class="line">&#125;</div><div class="line">main &#123; </div><div class="line">// 自动伸展并占满所有的可用空间</div><div class="line">flex: 1; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="缓动效果（动画和过渡）"><a href="#缓动效果（动画和过渡）" class="headerlink" title="缓动效果（动画和过渡）"></a>缓动效果（动画和过渡）</h2><p><a href="play.csssecrets.io/bounce">回弹动画</a><br><a href="play.csssecrets.io/elastic">弹性过渡</a><br>PS：对颜色过渡时小心，RGB 三个通道的值是独立进行插值运算的，在过渡过程中会产生其他颜色。<br>一般通过 transition-property 设置指定过渡属性来避免。</p><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p>运动曲线适用性：贝塞尔曲线适用于平滑运动， steps(步进数, [start || end])适用于逐帧动画<br>PS：参数一为步进数（把动画分为多少步，然后在逐步运行），参数二用于指定动画在每个循环周期的什么位置发生帧的切换动作。<br><a href="play.csssecrets.io/frame-by-frame">逐帧动画</a></p><h3 id="闪烁效果"><a href="#闪烁效果" class="headerlink" title="闪烁效果"></a>闪烁效果</h3><p>animation-direction 属性定义是否循环交替反向播放动画。<br>reverse    动画反向播放。<br>alternate    动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。<br>alternate-reverse    动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。<br><a href="play.csssecrets.io/blink">闪烁效果</a></p><h3 id="打字动画"><a href="#打字动画" class="headerlink" title="打字动画"></a>打字动画</h3><p><a href="play.csssecrets.io/typing">打字动画</a></p><h3 id="状态平滑的动画"><a href="#状态平滑的动画" class="headerlink" title="状态平滑的动画"></a>状态平滑的动画</h3><p>animation–play-state 属性指定动画是否正在运行或已暂停。<br>paused    指定暂停动画<br>running    指定正在运行的动画<br><a href="play.csssecrets.io/state-animations">指定暂停动画</a></p><h2 id="first-letter"><a href="#first-letter" class="headerlink" title="::first-letter"></a>::first-letter</h2><p>定义：::first-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。</p><ol><li>::first-letter 伪元素生效的前提，常见的标点符号、各类括号和引号在::first-letter 伪元素眼中全部都是“辅助类”字符，不会作为第一个字符计算。</li><li>与::before使用（::before 若有字符，会参与计算及 伪类的 content 的字符会被::first-letter生效）。</li><li>::first-letter 伪元素可以生效的 CSS 属性有：字体属性、背景属性、color、padding、border、margin等。</li></ol><p>PS：“辅助类”包括·@#%&amp;<em>()（）[]【】{}:：”“”;；’‘’》《,，.。？?!！…</em>、/\。<br><a href="https://github.com/cubiq/iscroll/" target="_blank" rel="external">iScroll, smooth scrolling for the web</a></p><h2 id="CJK（中文-日文-韩文）两端对齐"><a href="#CJK（中文-日文-韩文）两端对齐" class="headerlink" title="CJK（中文/日文/韩文）两端对齐"></a>CJK（中文/日文/韩文）两端对齐</h2><p>text-align: justify;<br>text-justify: inter-ideograph;</p><h2 id="用户交互反馈（通用的按钮及连接交互反馈）"><a href="#用户交互反馈（通用的按钮及连接交互反馈）" class="headerlink" title="用户交互反馈（通用的按钮及连接交互反馈）"></a>用户交互反馈（通用的按钮及连接交互反馈）</h2><p>通用的连接和按钮交互反馈，原理为：background-color 总是在最底下的位置，所以这里的 background-image 一定是覆盖在按钮等元素背景色之上的，不会影响按钮原来的背景色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[href]:active, button:active &#123;</div><div class="line">background-image: linear-gradient(to top, rgba(0,0,0,.05), rgba(0,0,0,.05));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="script-标签"><a href="#script-标签" class="headerlink" title="script 标签"></a>script 标签</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，同时不渲染，不进行资源加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/html&quot;&gt;</div><div class="line">&lt;img src=&quot;1.jpg&quot;&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>PS：script标签隐藏内容获取使用 script.innerHTML</p><h3 id="display-none-隐藏"><a href="#display-none-隐藏" class="headerlink" title="display:none 隐藏"></a>display:none 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但资源有加载，DOM 可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.dn &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="visibility-hidden-隐藏"><a href="#visibility-hidden-隐藏" class="headerlink" title="visibility: hidden 隐藏"></a>visibility: hidden 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但显隐的时候可以有 transition 淡入淡出效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.hidden &#123;</div><div class="line">position: absolute;</div><div class="line">visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果希望元素不可见，不能点击，辅助设备无法访问，但占据空间保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.hidden &#123;</div><div class="line">visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="clip-剪裁隐藏"><a href="#clip-剪裁隐藏" class="headerlink" title="clip 剪裁隐藏"></a>clip 剪裁隐藏</h3><p>如果希望元素不可见，不能点击，不占据空间，但键盘可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.clip &#123;</div><div class="line">position: absolute;</div><div class="line">clip: rect(0 0 0 0);</div><div class="line">&#125;</div><div class="line">.out &#123;</div><div class="line">position: relative;</div><div class="line">left: -999em;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="relative-隐藏"><a href="#relative-隐藏" class="headerlink" title="relative 隐藏"></a>relative 隐藏</h3><p>如果希望元素不可见，不能点击，但占据空间，且键盘可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.lower &#123;</div><div class="line">position: relative;</div><div class="line">z-index: -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="透明度隐藏"><a href="#透明度隐藏" class="headerlink" title="透明度隐藏"></a>透明度隐藏</h3><p>如果希望元素不可见，但可以点击，而且不占据空间，则可以使用透明度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.opacity &#123;</div><div class="line">position: absolute;</div><div class="line">opacity: 0;</div><div class="line">filter: Alpha(opacity=0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果单纯希望元素看不见，但位置保留，依然可以点可以选，则直接让透明度为 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.opacity &#123;</div><div class="line">opacity: 0;</div><div class="line">filter: Alpha(opacity=0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：img元素，设置 display:none 在所有浏览器下依旧都会请求图片资源（浪费了宽带）。</p><h3 id="流向的改"><a href="#流向的改" class="headerlink" title="流向的改"></a>流向的改</h3><p>direction（改变水平流向）<br>unicode-bidi（文字流向）<br>writing-mode（改变 CSS 世界纵横规则）<br>writing-mode: lr-tb | tb-rl | tb-lr (IE8+);<br>writing-mode: horizontal-tb | vertical-rl | vertical-lr;</p><h2 id="1px边框（移动端）"><a href="#1px边框（移动端）" class="headerlink" title="1px边框（移动端）"></a>1px边框（移动端）</h2><h3 id="box-shadow-border-transform"><a href="#box-shadow-border-transform" class="headerlink" title="box-shadow/border + transform"></a>box-shadow/border + transform</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.border &#123;</div><div class="line">width: 100%;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.border::after &#123;</div><div class="line">content:&apos;&apos;;</div><div class="line">position: absolute;</div><div class="line">bottom: 0;left: 0;</div><div class="line">width: 100%;</div><div class="line">box-shadow: 0 0 0 1px red;</div><div class="line">transform-origin: 0 bottom;</div><div class="line">transform: scaleY(.5);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：还可以结合 @media (min-resolution: xdppx)做进一步处理。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background-origin: padding-box; 默认<br>background-position: top 20px left 20px; 参照点为默认padding-box<br>background-size: x y;<br>圆锥渐变<br>background: conic-gradient(red, yellow, lime, aqua, blue, fuchsia, red);<br>background缩写语法<br>background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><ol><li>可以通过’/‘设置水平水平和垂直半径，如<code>border-radius: 100px / 75px;</code></li><li>它不仅可以接受长度值，还可以接受百分比值（这个百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。）。</li><li></li></ol><h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>指定元素内的空白怎样处理。<br>normal    默认。空白会被浏览器忽略。<br>pre    空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。<br>nowrap    文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。<br>pre-wrap    保留空白符序列，但是正常地进行换行。<br>pre-line    合并空白符序列，但是保留换行符。<br>inherit    规定应该从父元素继承 white-space 属性的值。</pre></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>line-height 的百分比时相对于 font-size 计算的。<br>vertical-align 的百分比时相对于 line-height 计算的。<br>ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。)<br>ch 数字 0 的宽度，使用场景（需要配合等宽字体）：全数字输入框：手机号等。<br>font-weight 运行原理：字体不同粗细需要字体文件是否存在该粗细的字体。<br>font-style  同样有效的前提为字体文件中存在该类型的字体，italic 和 oblique。<br>font-family: system-ui; // 让网页的字体跟系统走，，网站字体能时时刻刻与时俱进。<br>text-transform 属性控制文本的大小写，支持capitalize、uppercase、lowercase。<br>适用场景：身份证输入，最后以为X，帮助用户转为大写；验证码输入，帮助用户转为大写。<br>::backdrop CSS 伪元素 是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结日常CSS技巧，大多收集于网络、&lt;a href=&quot;http://www.ituring.com.cn/book/1695&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《CSS揭秘》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;半透明边框&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记</title>
    <link href="https://fanerge.github.io/2018/CSS%E7%AC%94%E8%AE%B0.html"/>
    <id>https://fanerge.github.io/2018/CSS笔记.html</id>
    <published>2018-06-06T12:45:51.000Z</published>
    <updated>2018-06-12T13:28:13.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。</p><h1 id="CSS方法"><a href="#CSS方法" class="headerlink" title="CSS方法"></a>CSS方法</h1><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p>用来获取选择到的元素的某一HTML属性值，并用于其样式。</p><h2 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h2><p>可以通过计算来决定一个CSS属性的值了。<br>PS：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px);</code></p><h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p><code>counter-reset</code>属性创建或重置一个或多个计数器。<br><code>counter-increment</code>属性递增一个或多个计数器值。<br><code>counter(name)</code>方法用于获取计数器的值。<br>PS：<code>counter-reset</code>属性通常是和<code>counter-increment</code>属性，<code>content</code>属性一起使用。</p><h2 id="cubic-bezier"><a href="#cubic-bezier" class="headerlink" title="cubic-bezier()"></a>cubic-bezier()</h2><p>它主要作用于动画和过渡的运动曲线函数 animation-timing-function 和 transition-timing-function 。<br><a href="http://cubic-bezier.com/" target="_blank" rel="external">cubic-bezier转换网站</a></p><h2 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h2><h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h3><p>线性渐变<br><code>background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);</code><br><code>repeating-linear-gradient</code> – 重复线性渐变<br><code>background: repeating-linear-gradient(to top left, lightpink, lightpink 5px, white 5px, white 10px);</code></p><h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient"></a>radial-gradient</h3><p>径向渐变<br><code>background: radial-gradient(red, yellow, rgb(30, 144, 255));</code><br><code>repeating-radial-gradient</code> – 重复径向渐变<br><code>background: repeating-radial-gradient(powderblue, powderblue 8px, white 8px, white 16px);</code></p><h2 id="image-set"><a href="#image-set" class="headerlink" title="image-set()"></a>image-set()</h2><p>可以根据用户设备的分辨率匹配合适的图像。<br><code>background-image: image-set( &quot;test.png&quot; 1x, &quot;test-2x.png&quot; 2x, &quot;test-print.png&quot; 600dpi );</code></p><h3 id="img-的-srcset属性"><a href="#img-的-srcset属性" class="headerlink" title="img 的 srcset属性"></a>img 的 srcset属性</h3><p>以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。<br><code>&lt;img src=&quot;mm-width-128px.jpg&quot; srcset=&quot;mm-width-128px.jpg 1x, mm-width-256px.jpg 2x&quot;&gt;</code><br>PS：img的srcset属性方便的解决了页面图片适应不同屏幕密度的情况。</p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h2><p>matrix() 指定了一个由指定的 6 个值组成的 2D 变换矩阵。这种矩阵的常量值是隐含的，而不是由参数传递的；其他的参数是以列优先的顺序描述的。<br>matrix3d() 参数为 9 个值，对应 3D 变换。<br>PS：所有的 transform 参数值都可以用矩阵来表示。</p><h2 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h2><p>var()函数可以代替元素中任何属性中的值的任何部分。<br>语法：<code>var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? )</code><br>ps：带有前缀–的属性名，比如–example–name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。</p><h1 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h1><h2 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h2><p>指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。</p><h2 id="cross-fade"><a href="#cross-fade" class="headerlink" title="cross-fade"></a>cross-fade</h2><p>作用：CSS3背景图片透明叠加属性。<br>方法：<code>background-image: -webkit-cross-fade(url(1.jpg), url(2.jpg), 50%);</code><br>PS：透明度是作用在第二张图片上的。<br><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-background-image-cross-fade/" target="_blank" rel="external">Cross-fade</a></p><h2 id="caret-color"><a href="#caret-color" class="headerlink" title="caret-color"></a>caret-color</h2><p>用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。</p><h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><p>可以创建一个只有元素的部分区域可以显示的剪切区域（也就是说可以让一个元素显示出不同的形式，如圆形、椭圆、多边形等等）。<br><a href="http://yunkus.com/css-clip-path/" target="_blank" rel="external">CSS3 clip-path 用法详解</a></p><h2 id="shape-outside"><a href="#shape-outside" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>属性指定使用下面列表的值来定义浮动元素的浮动区域。这个浮动区域决定了行内内容（浮动元素）所包裹的形状。<br>其中还包括basic-shape有inset()、 circle()、ellipse()、polygon()</p><h2 id="resolution"><a href="#resolution" class="headerlink" title="resolution"></a>resolution</h2><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>每英寸包含点的数量（dots per inch）<br>普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx）。</p><h3 id="dpcm"><a href="#dpcm" class="headerlink" title="dpcm"></a>dpcm</h3><p>每厘米包含点的数量（dots per centimeter）</p><h3 id="dppx"><a href="#dppx" class="headerlink" title="dppx"></a>dppx</h3><p>每像素包含点的数量（dots per pixel）<br>基本的换算单位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1dppx = 96dpi</div><div class="line">1dpi ≈ 0.39dpcm</div><div class="line">1dpcm ≈ 2.54dpi</div><div class="line">1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px</div></pre></td></tr></table></figure></p><h2 id="empty-cells"><a href="#empty-cells" class="headerlink" title="empty-cells"></a>empty-cells</h2><p>渲染表格 table 中没有可见内容的单元格的边框和背景，取值为show 和 hide。</p><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>width属性又多了几个关键字成员，fill-available, max-content, min-content, 以及fit-content，兼容性还有很大问题，暂不深究。</p><h3 id="max-content"><a href="#max-content" class="headerlink" title="max-content"></a>max-content</h3><p>固有的首选宽度.</p><h3 id="min-content"><a href="#min-content" class="headerlink" title="min-content"></a>min-content</h3><p>这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素）。</p><h3 id="available"><a href="#available" class="headerlink" title="available"></a>available</h3><p>包含块的宽度减去水平 margin, border 和 padding.</p><h3 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h3><p>以下两种情况下的较大值:固有的最小宽度 或 固有首选宽度（max-content）和可用宽度（available）的较小值  </p><h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><p>之前的 length 或 percentage 应用到元素的边框盒子.</p><h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><p>之前的 length 或 percentage 应用到元素的内容盒子.</p><h2 id="hanging-punctuation"><a href="#hanging-punctuation" class="headerlink" title="hanging-punctuation"></a>hanging-punctuation</h2><p>指定了标点符号应该放在文本句子的开头还是结尾。悬挂标点符号可能被放在线框外。</p><h2 id="hyphens"><a href="#hyphens" class="headerlink" title="hyphens"></a>hyphens</h2><p>告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。</p><h2 id="image-rendering"><a href="#image-rendering" class="headerlink" title="image-rendering"></a>image-rendering</h2><p>决定浏览器对缩放图像采取的缩放算法.它适用于元素本身和有其他属性的图像.它对非缩放图像没有影响。</p><h2 id="image-orientation"><a href="#image-orientation" class="headerlink" title="image-orientation"></a>image-orientation</h2><p>用来修正某些图片的预设方向。<br>PS：该属性不是用来对图片进行任意角度旋转的, 它是用来修正那些带有不正确的预设方向的图片的. 因此该属性值会被四舍五入到 90 度的整数倍.</p><h2 id="通用关键字"><a href="#通用关键字" class="headerlink" title="通用关键字"></a>通用关键字</h2><p><code>inherit</code> – 关键字使得元素获取其父元素的计算值(computed value )，当然肯定只针对可继承属性。<br><code>initial</code> – 是将属性的初始值( initial value)赋给元素，至于那些为<a href="https://www.w3.org/TR/CSS2/propidx.html" target="_blank" rel="external">不同属性的初始值，请参见W3C</a>。<br><code>unset</code> – CSS 关键字 unset 是 关键字 initial 和 inherit的组合（换句话说这个unset关键字会优先用inherit的样式，其次会应该用initial的样式）。<br><code>all</code> – CSS all简写属性重设除了unicode-bidi 和 direction 之外的所有属性至它们的初始值或继承值。</p><h2 id="inline-size"><a href="#inline-size" class="headerlink" title="inline-size"></a>inline-size</h2><p>定义元素的块的水平或垂直大小，这取决于它的写入模式。它对应于 width 或 height，取决于 writing-mode 属性。</p><h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>定义该元素是否必须创建一个新的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="external">stacking context</a>。<br>PS：该属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。</p><h2 id="支持欠佳的属性，暂不深究"><a href="#支持欠佳的属性，暂不深究" class="headerlink" title="支持欠佳的属性，暂不深究"></a>支持欠佳的属性，暂不深究</h2><p>margin-block-start 和 margin-block-end<br>定义元素的逻辑块结束余量，该元素根据元素的writing-mode、方向性和文本方向映射到物理量度。<br>margin-inline-start 和 margin-inline-end<br>min-block-size 和 min-inline-size<br>offset-block-start 和 offset-block-end<br>offset-inline-start 和 offset-inline-end<br>padding-block-start 和 padding-block-end<br>padding-inline-end 和 padding-inline-start</p><h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。<br>遮罩mask是一个复合属性，包括mask-image、mask-mode、mask-repeat、mask-position、mask-clip、mask-origin、mask-size、mask-composite这8个属性</p><h3 id="mask-image"><a href="#mask-image" class="headerlink" title="mask-image"></a>mask-image</h3><p>默认值为none，值为透明图片，或透明渐变</p><h3 id="mask-repeat"><a href="#mask-repeat" class="headerlink" title="mask-repeat"></a>mask-repeat</h3><p>默认值为repeat，可选值与background-repeat相同</p><h3 id="mask-position"><a href="#mask-position" class="headerlink" title="mask-position"></a>mask-position</h3><p>默认值为0 0，可选值与background-position相同</p><h3 id="mask-clip"><a href="#mask-clip" class="headerlink" title="mask-clip"></a>mask-clip</h3><p>默认值为border-box，可选值与background-clip相同</p><h3 id="mask-origin"><a href="#mask-origin" class="headerlink" title="mask-origin"></a>mask-origin</h3><p>默认值为border-box，可选值与background-origin相同</p><h3 id="mask-size"><a href="#mask-size" class="headerlink" title="mask-size"></a>mask-size</h3><p>默认值为auto，可选值与background-size相同</p><h3 id="mask-mode"><a href="#mask-mode" class="headerlink" title="mask-mode"></a>mask-mode</h3><p>默认值为match-source，可选值为alpha、luminance、match-source，或者它们的组合</p><h3 id="mask-composite"><a href="#mask-composite" class="headerlink" title="mask-composite"></a>mask-composite</h3><p>默认值为add，可选值为add、subtract、intersect、exclude</p><h2 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h2><p>描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p><h2 id="作用于替换元素，如img"><a href="#作用于替换元素，如img" class="headerlink" title="作用于替换元素，如img"></a>作用于替换元素，如img</h2><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p>指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</p><h3 id="object-position"><a href="#object-position" class="headerlink" title="object-position"></a>object-position</h3><p>指定元素的替换内容在其盒子内的对齐方式。</p><h2 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h2><p>是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。<br>PS：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。</p><h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><p>指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。</p><h2 id="quotes"><a href="#quotes" class="headerlink" title="quotes"></a>quotes</h2><p>设置嵌套引用的引号类型。<br>PS：当4个参数时，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。</p><h2 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h2><p>CSS 规则关联了一组嵌套的CSS语句,这些语句被放置在一个CSS区块中,该区块以大括号分割, 还有一个由多个CSS声明检测组成的条件,它是一个键值组合, 由逻辑与,逻辑或,逻辑非组合而成. 这样的条件语句称为支持条件.<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@supports &lt;supports_condition&gt; &#123;</div><div class="line">  /* specific rules */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：在 supports_condition 中还支持 not、or、and 逻辑。</p><h2 id="tab-size"><a href="#tab-size" class="headerlink" title="tab-size"></a>tab-size</h2><p>用于自定义制表符 (U+0009) 的宽度。</p><h2 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h2><p>用于布局表格单元格，行和列的算法。</p><h2 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h2><p>描述的是一段文本中最后一行在被强制换行之前的对齐规则。</p><h2 id="text-combine-upright"><a href="#text-combine-upright" class="headerlink" title="text-combine-upright"></a>text-combine-upright</h2><p>文本结合 writing-mode（为vertical-rl 或 vertical-lr） 指定多个字符的组合到单个字符的空间中。</p><h2 id="text-emphasis"><a href="#text-emphasis" class="headerlink" title="text-emphasis"></a>text-emphasis</h2><p>主要效果为文本强调。<br>text-emphasis-color<br>text-emphasis-position<br>text-emphasis-style</p><h2 id="text-orientation"><a href="#text-orientation" class="headerlink" title="text-orientation"></a>text-orientation</h2><p>设置文本的方向。</p><h2 id="text-rendering"><a href="#text-rendering" class="headerlink" title="text-rendering"></a>text-rendering</h2><p>CSS 属性定义浏览器渲染引擎如何渲染字体。浏览器会在速度、清晰度、几何精度之间进行权衡。</p><h2 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h2><p>CSS属性指定如何将元素的文本大小写。</p><h2 id="text-underline-position"><a href="#text-underline-position" class="headerlink" title="text-underline-position"></a>text-underline-position</h2><p>当 text-decoration属性的值设置为 underline 之后，可以用 text-underline-position 属性为其设置下划线的位置。</p><h2 id="touch-action"><a href="#touch-action" class="headerlink" title="touch-action"></a>touch-action</h2><p>用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。</p><h2 id="transform-box"><a href="#transform-box" class="headerlink" title="transform-box"></a>transform-box</h2><p>defines the layout box, to which the transform and transform-origin properties relate to.</p><h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><p>确定元素的子元素是否位于3D空间中，还是在该元素所在的平面内被扁平化。</p><h2 id="unicode-bidi"><a href="#unicode-bidi" class="headerlink" title="unicode-bidi"></a>unicode-bidi</h2><p>CSS 的 unicode-bidi 属性和 direction 属性一起决定了如何处理文档中的双向文本（bidirectional text）。</p><h2 id="unicode-range"><a href="#unicode-range" class="headerlink" title="unicode-range"></a>unicode-range</h2><p>属性值可以是单个字符编码、字符编码区间、通配符区间、多个值等，如小写字母：[0x61,0x7a]（或十进制[97, 122]）<br>CSS unicode-range 特定字符使用 font-face 自定义字体。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。<br><code>baseline</code><br>元素基线与父元素的基线对齐。<br>对于一些 可替换元素，比如 textarea ， HTML标准没有说明它的基线，这意味着对其使用这个关键字，各浏览器表现可能不一样。<br><code>sub</code><br>元素基线与父元素的下标基线对齐。<br><code>super</code><br>元素基线与父元素的上标基线对齐。<br><code>text-top</code><br>元素顶端与父元素字体的顶端对齐。<br><code>text-bottom</code><br>元素底端与父元素字体的底端对齐。<br><code>middle</code><br>元素中垂线与父元素的基线加上小写x一半的高度值对齐。<br><code>length</code><br>元素基线超过父元素的基线指定高度。可以取负值。<br><code>percentage</code><br>同 length , 百分比相对于 line-height 。<br>以下两个值是相对于整行来说的：<br><code>top</code><br> 元素及其后代的顶端与整行的顶端对齐。<br><code>bottom</code><br>元素及其后代的底端与整行的底端对齐。</p><h2 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h2><p>CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。<br>PS：这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p><h2 id="增加热区的范围"><a href="#增加热区的范围" class="headerlink" title="增加热区的范围"></a>增加热区的范围</h2><ol><li>border 可以增加热区（与用户交互的区域），outline 和 box-shadow 是不能办到的。</li><li>伪元素同样可以代表其宿主元素来响应鼠标交互。</li></ol><p>通常的做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">border: 10px solid transparent;</div></pre></td></tr></table></figure></p><h1 id="filter-滤镜效果"><a href="#filter-滤镜效果" class="headerlink" title="filter(滤镜效果)"></a>filter(滤镜效果)</h1><p>CSS滤镜（filter）属提供的图形特效，像模糊，锐化或元素变色。过滤器通常被用于调整图片，背景和边界的渲染。<br>filter 可以开启浏览器的硬件加速GPU，优化性能。</p><h2 id="blur"><a href="#blur" class="headerlink" title="blur()"></a>blur()</h2><p>给图像设置高斯模糊。filter: blur(number);</p><h2 id="brightness"><a href="#brightness" class="headerlink" title="brightness()"></a>brightness()</h2><p>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</p><h2 id="drop-shadow"><a href="#drop-shadow" class="headerlink" title="drop-shadow()"></a>drop-shadow()</h2><p>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 </p><h2 id="contrast"><a href="#contrast" class="headerlink" title="contrast()"></a>contrast()</h2><p>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</p><h2 id="grayscale"><a href="#grayscale" class="headerlink" title="grayscale()"></a>grayscale()</h2><p>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p><h2 id="hue-rotate"><a href="#hue-rotate" class="headerlink" title="hue-rotate()"></a>hue-rotate()</h2><p>给图像应用色相旋转。“angle”一值设定图像会被调整的色环角度值。</p><h2 id="invert"><a href="#invert" class="headerlink" title="invert()"></a>invert()</h2><p>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</p><h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity()"></a>opacity()</h2><p>转化图像的透明程度。</p><h2 id="saturate"><a href="#saturate" class="headerlink" title="saturate()"></a>saturate()</h2><p>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。</p><h2 id="sepia"><a href="#sepia" class="headerlink" title="sepia()"></a>sepia()</h2><p>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。<br>PS：你可以组合任意数量的函数来控制渲染。下面的例子可以增强图像的对比度和亮度。<br><code>filter: contrast(175%) brightness(3%)</code></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background 是CSS简写属性，用来集中设置各种背景属性。background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat,background-size, background-attachment。</p><h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p>如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。</p><h2 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h2><p>定义该元素的背景图片，以及背景色如何混合。</p><h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>置元素的背景（背景图片或颜色）是否延伸到边框下面。<br>PS：简写形式background:bg-color bg-image bg-position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p><h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><h2 id="active"><a href="#active" class="headerlink" title=":active"></a>:active</h2><p>:active CSS伪类匹配被用户激活的元素。<br>PS：当多伪类同时使用时，需要注意顺序，否则就会发生被覆盖，如链接:link — :visited — :hover — :active。</p><h2 id="target"><a href="#target" class="headerlink" title=":target"></a>:target</h2><p>代表一个唯一的页面元素(目标元素)，其ID与当前URL片段匹配.</p><h2 id="default"><a href="#default" class="headerlink" title=":default"></a>:default</h2><p>表示一组相关元素中的默认表单元素。<br><code>该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用。</code></p><h2 id="dir"><a href="#dir" class="headerlink" title=":dir"></a>:dir</h2><p>伪类匹配特定文字书写方向的元素。在HTML中, 文字方向由dir属性决定。</p><h2 id="enabled"><a href="#enabled" class="headerlink" title=":enabled"></a>:enabled</h2><p>表示任何启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入）或获取焦点，则该元素是启用的。</p><h2 id="disabled"><a href="#disabled" class="headerlink" title=":disabled"></a>:disabled</h2><p>表示任何被禁用的元素。如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。</p><h2 id="read-only"><a href="#read-only" class="headerlink" title=":read-only"></a>:read-only</h2><p>表示元素不可被用户编辑的状态（如锁定的文本输入框）。</p><h2 id="read-write"><a href="#read-write" class="headerlink" title=":read-write"></a>:read-write</h2><p>代表一个元素（例如可输入文本的 input元素）可以被用户编辑。<br>PS：这个选择器不仅仅选择 input 元素，它也会选择所有可以被用户编辑的元素，例如设置了 contenteditable 属性的 p 元素。</p><h2 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h2><p>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格），无论一个元素是否为 (empty 或 not), 注释或处理指令都不会产生影响。</p><h2 id="not"><a href="#not" class="headerlink" title=":not()"></a>:not()</h2><p>是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。<br>PS：:not伪类不像其它伪类，它不会增加选择器的优先级。</p><h2 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h2><p>表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。</p><h2 id="fullscreen"><a href="#fullscreen" class="headerlink" title=":fullscreen"></a>:fullscreen</h2><p>应用于当前处于全屏显示模式的元素。 它不仅仅选择顶级元素，还包括所有已显示的栈内元素。</p><h2 id="in-range"><a href="#in-range" class="headerlink" title=":in-range"></a>:in-range</h2><p>代表一个 input 元素，其当前值处于属性min 和max 限定的范围之内.</p><h2 id="out-of-range"><a href="#out-of-range" class="headerlink" title=":out-of-range"></a>:out-of-range</h2><p>代表一个 input 元素，其当前值不在属性min 和max 限定的范围之内.</p><h2 id="indeterminate"><a href="#indeterminate" class="headerlink" title=":indeterminate"></a>:indeterminate</h2><p>表示状态不确定的表单元素.</p><h2 id="invalid"><a href="#invalid" class="headerlink" title=":invalid"></a>:invalid</h2><p>表示任意内容未通过验证的 input 或其他 form 元素 .</p><h2 id="valid"><a href="#valid" class="headerlink" title=":valid"></a>:valid</h2><p>表示任意内容通过验证的 input 或其他 form 元素 .</p><h2 id="required"><a href="#required" class="headerlink" title=":required"></a>:required</h2><p>表示 任意 input 元素表示任意拥有required属性的 input 或 textarea 元素使用它. 它允许表单在提交之前容易的展示必填字段并且渲染其外观. </p><h2 id="lang"><a href="#lang" class="headerlink" title=":lang()"></a>:lang()</h2><p>基于元素语言来匹配页面元素。</p><h2 id="optional"><a href="#optional" class="headerlink" title=":optional"></a>:optional</h2><p>表示任意没有required属性的 input，select 或  textarea 元素使用它。</p><h2 id="only-child"><a href="#only-child" class="headerlink" title=":only-child"></a>:only-child</h2><p>代表了属于某个父元素的唯一一个子元素.<br>PS：等价的方法还有:first-child:last-child或者:nth-child(1):nth-last-child(1)</p><h2 id="root"><a href="#root" class="headerlink" title=":root"></a>:root</h2><p>这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 html 元素，除了优先级更高之外，与 html 选择器相同。</p><h2 id="scope"><a href="#scope" class="headerlink" title=":scope"></a>:scope</h2><p>它将会匹配作为选择符匹配元素的参考点(css的作用域或作用点)。在HTML中，可以使用 style 的scoped属性来重新定义新的参考点。如果HTML中没有使用这个属性，那么默认的参考点(css的作用域或作用点)是 html。</p><h2 id="scroll-behavior"><a href="#scroll-behavior" class="headerlink" title="scroll-behavior"></a>scroll-behavior</h2><p>当由于导航或者CSSOM滚动api产生滚动时，CSS属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。<br>PS：可以配合 a 链接来实现平滑滚动到对应锚点位置。<br><a href="https://codepen.io/fanerge/pen/ERPELJ" target="_blank" rel="external">可以在Chrome浏览器中测试下</a></p><h2 id="scroll-snap-type"><a href="#scroll-snap-type" class="headerlink" title="scroll-snap-type"></a>scroll-snap-type</h2><p>CSS属性定义在滚动容器中的一个snap点如何被严格的执行。<br>PS：此属性不能用来指定任何精确的动画或者物理运动效果来执行snap点，而是交给用户代理来处理。</p><h2 id="shape-outside-1"><a href="#shape-outside-1" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>CSS 属性定义了一个行内内容应该包裹的形状。默认表现是行内元素包裹该形状的margin box。</p><h2 id="shape-image-threshold"><a href="#shape-image-threshold" class="headerlink" title="shape-image-threshold"></a>shape-image-threshold</h2><p>CSS property defines the alpha channel threshold used to extract the shape using an image as the value for shape-outside.</p><h2 id="shape-margin"><a href="#shape-margin" class="headerlink" title="shape-margin"></a>shape-margin</h2><p>CSS property specifies a margin for a CSS shape created using shape-outside.</p><h1 id="page"><a href="#page" class="headerlink" title="@page"></a>@page</h1><p>@page 规则用于在打印文档时修改某些CSS属性。<br>你不能用@page规则来修改所有的CSS属性，而是只能修改margin,orphans,widow 和 page breaks of the document。对其他属性的修改是无效的。</p><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>指定页面盒模型所在的容器的大小和方向。一般情况下，因为一个页面盒模型被渲染到一面纸张上，所以这个属性也指示了目标纸张的大小。</p><h2 id="marks"><a href="#marks" class="headerlink" title="marks"></a>marks</h2><p>向文档添加剪切标记和/或注册标记。</p><h2 id="bleed"><a href="#bleed" class="headerlink" title="bleed"></a>bleed</h2><p>指定一个超出页面盒模型的区域，在这个区域的页面内容将被裁剪。</p><h2 id="first"><a href="#first" class="headerlink" title=":first"></a>:first</h2><p>需要和 @page 配套使用，打印文档的时候，第一页的样式。</p><h2 id="left"><a href="#left" class="headerlink" title=":left"></a>:left</h2><p>需要和 @page 配套使用, 对打印文档的左侧页设置CSS样式.</p><h2 id="right"><a href="#right" class="headerlink" title=":right"></a>:right</h2><p>需要和 @page 配套使用, 对打印文档的右侧页设置CSS样式.</p><h2 id="blank"><a href="#blank" class="headerlink" title=":blank"></a>:blank</h2><p>与 :empty 关系类似，浏览器支持不佳。</p><h2 id="两个实验性"><a href="#两个实验性" class="headerlink" title="两个实验性"></a>两个实验性</h2><p>:recto 和 :verso </p><h2 id="page-break-after"><a href="#page-break-after" class="headerlink" title="page-break-after"></a>page-break-after</h2><p>CSS 属性调整当前元素之后的分页符</p><h2 id="page-break-before"><a href="#page-break-before" class="headerlink" title="page-break-before"></a>page-break-before</h2><p>CSS属性调整当前元素之前的分页符。</p><h2 id="page-break-inside"><a href="#page-break-inside" class="headerlink" title="page-break-inside"></a>page-break-inside</h2><p>CSS 属性调整当前元素内的分页符。</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><h2 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h2><p>::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。<br>PS：这个虚拟元素默认是行内元素。</p><h2 id="fitst-letter"><a href="#fitst-letter" class="headerlink" title="::fitst-letter"></a>::fitst-letter</h2><p>会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。<br>PS：你可能还不知道，::before 伪元素 和 content 属性结合起来有可能会在元素前面注入一些文本。如此，::first-letter 将会匹配到content文本的首字母。<br>首行只在 block-container box内部才有意义, 因此 ::first-letter 伪元素 只在display属性值为block, inline-block, table-cell, list-item 或者 table-caption的元素上才起作用. 其他情况下, ::first-letter 毫无意义.</p><h2 id="backdrop"><a href="#backdrop" class="headerlink" title="::backdrop"></a>::backdrop</h2><p>是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p><h2 id="placeholder"><a href="#placeholder" class="headerlink" title="::placeholder"></a>::placeholder</h2><p>可以选择一个表单元素的占位文本，它允许开发者和设计师自定义占位文本的样式。</p><h2 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h2><p>应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。</p><h2 id="slotted"><a href="#slotted" class="headerlink" title="::slotted()"></a>::slotted()</h2><p>CSS pseudo-element represents any element that has been placed into a slot inside an HTML template (see Using templates and slots for more information).</p><h1 id="css3-布局"><a href="#css3-布局" class="headerlink" title="css3 布局"></a>css3 布局</h1><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>place-content<br><a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/0320%E6%80%BB%E7%BB%93flex%E5%B8%83%E5%B1%80.txt" target="_blank" rel="external">Study-Notes</a></p><h2 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h2><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>通过设置 display: grid;  可以定义一个 CSS 网格。然后使用 grid-template-rows 和 grid-template-columns 属性来定义网格的 columns 和 rows。<br>PS：grid-template-rows 和 grid-template-columns 有较多种参数。<br>minmax(min, max)<br>可以设置最小值和最大值，当某个值为 auto 时不限制。<br>repeat( [ <positive-integer> | auto-fill | auto-fit ] , <track-list> )<br>重复的多个 track，第一个参数指定了 repeat 的次数。<br>auto-fit<br>倾向于使用最少列数占满当前行空间，浏览器先是和 auto-fill 一样，暗中创建一些列来填充多出来的行空间，然后坍缩（collapse）这些列以便腾出空间让其余列扩张。<br>auto-fill<br>倾向于容纳更多的列，所以如果在满足宽度限制的前提下还有空间能容纳新列，那么它会暗中创建一些列来填充当前行。</track-list></positive-integer></p><h3 id="Grid-Areas"><a href="#Grid-Areas" class="headerlink" title="Grid Areas"></a>Grid Areas</h3><p>网格区域是网格中由一个或者多个网格单元格组成的一个矩形区域。当你使用基于网格线位置放置一个项目或者使用命名的网格区域定义区域时，网格区域被创建。<br>通常用 grid-area 属性命名它们（为子网格命名），然后用 grid-template-areas 把它们放在网格上。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_areas" target="_blank" rel="external">Grid Areas</a></p><h3 id="Grid-Lines"><a href="#Grid-Lines" class="headerlink" title="Grid Lines"></a>Grid Lines</h3><p>使用Grid布局在显式网格中定义轨道的同时会创建网格线。<br>网格线可以用它们的编号来寻址，线编号遵循文档的写入模式，因此在从右到左的语言中，列线1行将位于网格的右侧。<br>PS：主要给下列属性使用grid-column-start、grid-column-end、grid-row-start、grid-row-end。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_lines" target="_blank" rel="external">Grid Lines</a></p><h3 id="Gutters"><a href="#Gutters" class="headerlink" title="Gutters"></a>Gutters</h3><p>网格间距是网格轨道之间的间距，可以通过 grid-column-gap 或者 grid-row-gap 在Grid布局中创建。</p><h1 id="动画和过渡和转换"><a href="#动画和过渡和转换" class="headerlink" title="动画和过渡和转换"></a>动画和过渡和转换</h1><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>animation属性是如下属性的一个简写属性形式: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode.</p><h2 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h2><p>指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。</p><h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p>CSS属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。</p><h2 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h2><p>CSS 属性指示动画是否反向播放，它通常在简写属性animation中设定。</p><h2 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h2><p>用来指定在动画执行之前和之后如何给动画的目标应用样式。</p><h2 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h2><p>定义动画在结束前运行的次数 可以是1次 无限循环。</p><h2 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h2><p>定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。</p><h2 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h2><p>定义CSS动画在每一动画周期中执行的节奏。</p><h2 id="perspective-或-perspective"><a href="#perspective-或-perspective" class="headerlink" title="perspective 或 perspective()"></a>perspective 或 perspective()</h2><p>指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。</p><h2 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h2><p>指定了观察者的位置，在属性perspective中被用作消失点。</p><h1 id="百分比属性参照对象"><a href="#百分比属性参照对象" class="headerlink" title="百分比属性参照对象"></a>百分比属性参照对象</h1><h2 id="参照包含块宽高"><a href="#参照包含块宽高" class="headerlink" title="参照包含块宽高"></a>参照包含块宽高</h2><ol><li>参照包含块的width（margin、padding、width、left、right、font-size、text-index）</li><li>参照包含块的height（height、top、bottom）</li></ol><h2 id="参照自身盒子宽高"><a href="#参照自身盒子宽高" class="headerlink" title="参照自身盒子宽高"></a>参照自身盒子宽高</h2><ol><li>盒子模型中的border-radius</li><li>背景中的background-size</li><li>在transform变换中，translate()、transform-origin、scale()<br><a href="https://juejin.im/post/5b0bc994f265da092918d421" target="_blank" rel="external">你知道我们平时在CSS中写的%都是相对于谁吗？</a></li></ol><h1 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h1><h2 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h2><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>相对长度单位，这个单位表示元素的font-size的计算值。如果用在font-size 属性本身，它会继承父元素的font-size。</p><h3 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h3><p>这个单位表示元素font的 x-height 。在含有“x”字母的字体中，它是该字体的小写字母的高度；对于很多字体， 1ex ≈ 0.5em。</p><h3 id="ch"><a href="#ch" class="headerlink" title="ch"></a>ch</h3><p>这一单位代表元素所用字体 font中“0”这一字形的宽度（“0”，Unicode字符U+0030），或更准确地说是“0”这一字形的预测尺寸（advance measure）。</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>这个单位代表根元素的 font-size 大小（html 元素的font-size）。</p><h3 id="lh"><a href="#lh" class="headerlink" title="lh"></a>lh</h3><p>等于元素行高line-height的计算值。</p><h3 id="rlh"><a href="#rlh" class="headerlink" title="rlh"></a>rlh</h3><p>等于根元素行高line-height的计算值。</p><h2 id="视口比例的长度"><a href="#视口比例的长度" class="headerlink" title="视口比例的长度"></a>视口比例的长度</h2><h3 id="vh"><a href="#vh" class="headerlink" title="vh"></a>vh</h3><p>视口高度的 1/100。</p><h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h3><p>视口宽度的 1/100。</p><h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>等于初始包含块的大小的1%，在根元素的内联轴的方向上。</p><h3 id="vb"><a href="#vb" class="headerlink" title="vb"></a>vb</h3><p>等于初始包含块的大小的1%，在根元素的块轴的方向上。</p><h3 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a>vmin</h3><p>视口高度和宽度之间的最小值的 1/100。</p><h3 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a>vmax</h3><p>视口高度和宽度之间的最大值的 1/100。</p><h2 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h2><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>对于屏幕显示，通常是一个设备像素（点）的显示。</p><h3 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h3><p>毫米。</p><h3 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h3><p>厘米（10毫米）。</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>英寸（2.54厘米）。</p><h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>磅（1/72 英寸）。</p><h3 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h3><p>12 点活字 (1 pc 等于 12 点)。</p><h1 id="color"><a href="#color" class="headerlink" title="color"></a>color</h1><h2 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h2><p>black（黑） 、silver（银）、gray[*]（灰）、white（白）等等。</p><h2 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h2><p>transparent 关键字，是 rgba(0,0,0,0) 的简写。<br>currentColor 关键字，取当前 color 的值。</p><h2 id="颜色表达式"><a href="#颜色表达式" class="headerlink" title="颜色表达式"></a>颜色表达式</h2><p>十六进制符号 #RRGGBB<br>rgb(r, g, b)<br>rgba(r, g, b, a)<br>hsl(h, s, l) // 分别代表：色相、饱和度、亮度<br>hsla(h, s, l, a)</p><h1 id="angle"><a href="#angle" class="headerlink" title="angle"></a>angle</h1><p>用于表示角的大小，单位为度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）。在 gradient 和 transform 的某些方法等场景中有所应用。</p><h2 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h2><p>度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。</p><h2 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h2><p>百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。</p><h2 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h2><p>弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。</p><h2 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h2><p>圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。</p><h1 id="cusor（各属性使用的场景）"><a href="#cusor（各属性使用的场景）" class="headerlink" title="cusor（各属性使用的场景）"></a>cusor（各属性使用的场景）</h1><h2 id="not-allowed"><a href="#not-allowed" class="headerlink" title="not-allowed"></a>not-allowed</h2><p>提示禁用状态，如按钮禁用、禁止拖动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</div><div class="line">cursor: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p>隐藏鼠标光标，如播放视频等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">video &#123;</div><div class="line">cursor: url(transparent.gif); // 兼容</div><div class="line">cursor: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。&lt;/p&gt;
&lt;h1 id=&quot;CSS方法&quot;&gt;&lt;a href=&quot;#CSS方法&quot; class=&quot;headerlink&quot; title=&quot;CSS方法&quot;&gt;&lt;/a&gt;CSS方
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>记录一些有趣的repo</title>
    <link href="https://fanerge.github.io/2018/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84repo.html"/>
    <id>https://fanerge.github.io/2018/记录一些有趣的repo.html</id>
    <published>2018-05-31T12:22:58.000Z</published>
    <updated>2018-06-21T12:59:03.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hellogithub.com/" target="_blank" rel="external">大量开源项目hellogithub</a></p><h1 id="best-resume-ever"><a href="#best-resume-ever" class="headerlink" title="best-resume-ever"></a>best-resume-ever</h1><p>用Vue和LESS简单、快速建立许多漂亮的简历，并创建你最好的简历。<br><a href="https://github.com/salomonelli/best-resume-ever" target="_blank" rel="external">best-resume-ever</a><br><a href="https://salomonelli.github.io/best-resume-ever/#/" target="_blank" rel="external">官网地址</a></p><h1 id="css知识"><a href="#css知识" class="headerlink" title="css知识"></a>css知识</h1><p><a href="https://github.com/l-hammer/You-need-to-know-css" target="_blank" rel="external">You-need-to-know-css</a></p><h1 id="Web性能测试工具"><a href="#Web性能测试工具" class="headerlink" title="Web性能测试工具"></a>Web性能测试工具</h1><p><a href="https://github.com/pod4g/hiper" target="_blank" rel="external">hiper</a></p><h1 id="实现数字动画"><a href="#实现数字动画" class="headerlink" title="实现数字动画"></a>实现数字动画</h1><p><a href="https://github.com/inorganik/CountUp.js" target="_blank" rel="external">countUp.js</a></p><h1 id="Web页面加载进度条"><a href="#Web页面加载进度条" class="headerlink" title="Web页面加载进度条"></a>Web页面加载进度条</h1><p><a href="https://github.com/rstacruz/nprogress/" target="_blank" rel="external">nprogress</a><br><a href="https://github.com/jacoborus/nanobar" target="_blank" rel="external">nanobar</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hellogithub.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大量开源项目hellogithub&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;best-resume-ever&quot;&gt;&lt;a href=&quot;#best-resu
      
    
    </summary>
    
      <category term="杂项" scheme="https://fanerge.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="优秀项目" scheme="https://fanerge.github.io/tags/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Chrome调试</title>
    <link href="https://fanerge.github.io/2018/chrome%E8%B0%83%E8%AF%95.html"/>
    <id>https://fanerge.github.io/2018/chrome调试.html</id>
    <published>2018-05-24T14:13:30.000Z</published>
    <updated>2018-05-24T14:21:21.194Z</updated>
    
    <content type="html"><![CDATA[<p>记录Chrome DevTools比较少用但又很重要的技巧。</p><h1 id="检查动画"><a href="#检查动画" class="headerlink" title="检查动画"></a>检查动画</h1><p>使用Chrome DevTools Animations(动画)检查器检查和修改动画。<br>功能：<br>通过打开Animation Inspector(动画检查器)捕获动画。它会自动检测动画并将它们分组。<br>通过减慢动画，重播动画，或查看源代码，来检查动画。<br>通过更改动画的时间，延迟，持续时间或关键帧偏移来修改动画。</p><h1 id="设置DOM断点"><a href="#设置DOM断点" class="headerlink" title="设置DOM断点"></a>设置DOM断点</h1><p>设置DOM断点可以用来调试复杂的JavaScript应用程序。例如，如果你的JavaScript改变了DOM元素的样式，设置一个DOM断点当元素的属性被修改时触发。<br>在以下DOM更改都会触发断点：子树的变化，属性改变，节点删除。<br>设置DOM断点<br>Elements –&gt; Break on –&gt; Subtree Modifications/Attributes Modifications/Node Removal<br>查看DOM断点（包含断点类型）<br>Elements –&gt; DOM Breakpoints</p><h1 id="查看元素事件监听器"><a href="#查看元素事件监听器" class="headerlink" title="查看元素事件监听器"></a>查看元素事件监听器</h1><p>在Event Listeners(事件侦听器)窗格中查看与DOM节点相关联的JavaScript事件。<br>查看事件<br>Elements –&gt; Event Listeners<br>当取消勾选Framework listeners(框架侦听器)复选框时，事件侦听器代码可能会解析框架或库代码中的某处。</p><h1 id="模拟传感器"><a href="#模拟传感器" class="headerlink" title="模拟传感器"></a>模拟传感器</h1><p>Main menu –&gt; More Tools –&gt; Sensors<br>模拟地理位置坐标以测试地理位置覆盖。<br>模拟设备方向来测试加速计数据。</p><h1 id="在XHR上中断"><a href="#在XHR上中断" class="headerlink" title="在XHR上中断"></a>在XHR上中断</h1><p>有两种方法可以触发XHR上的断点：当任何XHR到达XHR生命周期的某个阶段时（readystatechange，load等），或者当XHR的URL与某个字符串匹配时。</p><h1 id="调试杂项"><a href="#调试杂项" class="headerlink" title="调试杂项"></a>调试杂项</h1><p>命名函数可以提高调用堆栈的可读性，不限于回掉函数。</p><h2 id="把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等"><a href="#把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等" class="headerlink" title="把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等"></a>把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等</h2><p>1.打开 DevTools Settings(设置)。<br>2.在左侧的导航菜单中，单击Blackboxing(黑箱)。<br>3.点击Add pattern…(添加模式)按钮。<br>4.在Pattern(模式)文本框输入您希望从调用堆栈中排除的文件名模式。DevTools 会排除该模式匹配的任何脚本。<br>5.在文本字段右侧的下拉菜单中，选择Blackbox(黑箱)以执行脚本文件但是排除来自调用堆栈的调用，或选择6.Disabled(禁用)来阻止文件执行。<br>7.点击 Add(添加) 保存。<br>下次运行页面并触发断点时，DevTools 将在Call Stack(调用堆栈)中隐藏任何来自放入黑盒脚本函数的调用。<br><a href="http://www.css88.com/doc/chrome-devtools/javascript/step-code/" target="_blank" rel="external">把第三方代码放入Blackbox</a><br>管理线程执行<br>使用Sources(源文件)面板上的Threads(线程)窗格暂停，step into(步入)，并检查其他线程，例如service worker 或 web worker 线程。</p><h2 id="启动-JavaScript-CPU-状态分析"><a href="#启动-JavaScript-CPU-状态分析" class="headerlink" title="启动 JavaScript CPU 状态分析"></a>启动 JavaScript CPU 状态分析</h2><p>启动一个JavaScript CPU 状态分析，可以添加一个可选标签名。要停止分析，请调用console.profileEnd()。每个分析结果都将添加到Profiles(分析)面板。<br>console.profile([label])<br>console.profileEnd();<br>在调用该方法的地方打印堆栈跟踪。<br>console.trace(object)</p><h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>monitorEvents()方法指示DevTools记录指定目标事件的信息。<br>monitorEvents(document.body, “click”);<br>要停止监听事件，请调用unmonitorEvents()方法,传递一个停止监视对象的参数。<br>unmonitorEvents(document.body);<br>查看在对象上注册事件监听器<br>getEventListeners() API返回在指定对象上注册事件的监听器。<br>返回值是一个对象，其中包含每个已注册事件类型的数组（例如，click 或 keydown）。 每个数组的成员都是对象，描述每中类型的已注册监听器。</p><blockquote><p>   参考文档：<br><a href="http://www.css88.com/doc/chrome-devtools/" target="_blank" rel="external">参考</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录Chrome DevTools比较少用但又很重要的技巧。&lt;/p&gt;
&lt;h1 id=&quot;检查动画&quot;&gt;&lt;a href=&quot;#检查动画&quot; class=&quot;headerlink&quot; title=&quot;检查动画&quot;&gt;&lt;/a&gt;检查动画&lt;/h1&gt;&lt;p&gt;使用Chrome DevTools Animat
      
    
    </summary>
    
      <category term="调试" scheme="https://fanerge.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://fanerge.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Web知识</title>
    <link href="https://fanerge.github.io/2018/Web%E6%9C%AF%E8%AF%AD.html"/>
    <id>https://fanerge.github.io/2018/Web术语.html</id>
    <published>2018-05-14T12:53:23.000Z</published>
    <updated>2018-06-13T14:31:30.832Z</updated>
    
    <content type="html"><![CDATA[<p>本文所有知识点，点到即止，详细内容请看各部分的连接。</p><h2 id="XSS（跨站脚本攻击Cross-Site-Script）"><a href="#XSS（跨站脚本攻击Cross-Site-Script）" class="headerlink" title="XSS（跨站脚本攻击Cross Site Script）"></a>XSS（跨站脚本攻击Cross Site Script）</h2><p>定义：XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。<br>方案：CSP(Content Security Policy)、对特殊字符转义，不要相信任何来自用户的输入（包括请求体、queryString甚至是请求Headers）<br><a href="https://www.zhuyingda.com/blog/article.html?id=2" target="_blank" rel="external">XSS漏洞的原理</a></p><h2 id="CSRF（跨站点脚本Cross-site-request-forgery）"><a href="#CSRF（跨站点脚本Cross-site-request-forgery）" class="headerlink" title="CSRF（跨站点脚本Cross-site request forgery）"></a>CSRF（跨站点脚本Cross-site request forgery）</h2><p>定义：是指在黑客已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器 CRUD 来执行读写操作。<br>方案：token + Referer(Request Header)、验证码<br>PS：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。<br><a href="https://www.zhuyingda.com/blog/article.html?id=5" target="_blank" rel="external">CSRF漏洞的原理</a></p><h2 id="clickjacking（点击劫持）"><a href="#clickjacking（点击劫持）" class="headerlink" title="clickjacking（点击劫持）"></a>clickjacking（点击劫持）</h2><p>定义：点击劫持其实是一种视觉上的欺骗手段，攻击者将一个透明的、不可见的iframe覆盖在一个网页上，通过调整iframe页面位置，诱使用户在页面上进行操作，在不知情的情况下用户的点击恰好是点击在iframe页面的一些功能按钮上。<br>方案：防止或限制网页内嵌（http头部X-FRAME-OPTIONS）、<a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">JS防止潜入</a><br>PS：http头部X-FRAME-OPTIONS为非标准的（但所有浏览器都支持），你可以使用CSP的frame-ancestors（标准属性）。<br><a href="https://www.zhuyingda.com/blog/article.html?id=6" target="_blank" rel="external">ClickJacking漏洞的原理</a></p><h2 id="点击穿透（多见于移动端模态框等浮层）"><a href="#点击穿透（多见于移动端模态框等浮层）" class="headerlink" title="点击穿透（多见于移动端模态框等浮层）"></a>点击穿透（多见于移动端模态框等浮层）</h2><p>产生：上层元素触发touch事件-&gt;上层元素消失（300ms之内）-&gt;底层元素click事件触发<br>PS：touch事件之后会有300ms延迟在执行click事件是因为，在这300ms中若再次tap行为则认定为double tap事件，否则就触发click事件。<br>方案：只用touch事件、只用click事件（不推荐）、fastclick类库等<br><a href="https://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>定义：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br>方案：使用参数化的过滤性语句、输入验证、错误消息处理、加密处理、存储过程来执行所有的查询、使用专业的漏洞扫描工具、确保数据库安全、安全审评</p><h2 id="MIMT-中间人攻击Man-in-the-middle-attacks"><a href="#MIMT-中间人攻击Man-in-the-middle-attacks" class="headerlink" title="MIMT(中间人攻击Man-in-the-middle-attacks)"></a>MIMT(中间人攻击Man-in-the-middle-attacks)</h2><p>定义：Client &lt;–&gt; Proxy Server(Middle Man) &lt;–&gt; Web Server真实的服务器<br>Client 发出的请求 和 Web Server返回的数据都经过Proxy Server 转发，这个Proxy Server 就起到了一个Middle Man的作用，如果这个“中间人” 够黑，那么整个代理过程的数据都可以由这个“中间人”控制，“中间人”可以进行截取敏感数据、代码注射、Proxp worm操作。<br>方案：启用虚拟专用网(VPN)、https(传输报文加密)<br><a href="https://www.zhuyingda.com/blog/article.html?id=7" target="_blank" rel="external">web中间人攻击的威胁</a></p><h2 id="DDOS（分布式拒绝服务Distributed-Denial-of-Service）"><a href="#DDOS（分布式拒绝服务Distributed-Denial-of-Service）" class="headerlink" title="DDOS（分布式拒绝服务Distributed Denial of Service）"></a>DDOS（分布式拒绝服务Distributed Denial of Service）</h2><p>定义：最基本的DDOS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。<br>方案：高防服务器、黑名单、DDoS 清洗、CDN（隐藏真实IP及分流）<br><a href="https://www.zhihu.com/question/22259175" target="_blank" rel="external">知乎-什么是 DDoS 攻击？</a></p><h2 id="cookie防篡改（实现思路）"><a href="#cookie防篡改（实现思路）" class="headerlink" title="cookie防篡改（实现思路）"></a>cookie防篡改（实现思路）</h2><ol><li>服务端提供一个签名生成算法secret</li><li>根据方法生成签名secret(wall)=34Yult8i</li><li>将生成的签名放入对应的Cookie项username=wall|34Yult8i。其中，内容和签名用|隔开。</li><li>服务端根据接收到的内容和签名，校验内容是否被篡改（签名和服务器之前生成的不一致则表示cookie被篡改了）。</li></ol><p><a href="https://juejin.im/post/5b02fe326fb9a07ab1117c82" target="_blank" rel="external">Cookie防篡改机制</a></p><h2 id="CSP（内容安全策略Content-Security-Policy）"><a href="#CSP（内容安全策略Content-Security-Policy）" class="headerlink" title="CSP（内容安全策略Content-Security-Policy）"></a>CSP（内容安全策略Content-Security-Policy）</h2><p>定义：内容安全策略 (Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>定义：CORS (跨域资源共享)是一个系统, 包括传输的 HTTP headers, 其确定是否阻止或完成从该资源所在的域外的另一个域的网页上的受限资源的请求。<br>PS：同源安全策略( same-origin security policy)默认禁止“跨域”请求. CORS 给予Web服务器跨域访问控制, 启用安全的跨域数据传输。<br><a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" target="_blank" rel="external">CORS</a></p><h2 id="BFC（块格式化上下文Block-Formatting-Context）"><a href="#BFC（块格式化上下文Block-Formatting-Context）" class="headerlink" title="BFC（块格式化上下文Block Formatting Context）"></a>BFC（块格式化上下文Block Formatting Context）</h2><p>定义：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br>如何触发BFC：<br>• html 根元素；<br>• float 的值不为 none；<br>• overflow 的值为 auto、scroll 或 hidden；<br>• display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；<br>• position 的值不为 relative 和 static。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">块格式化上下文</a></p><h2 id="containing-block（包含块）"><a href="#containing-block（包含块）" class="headerlink" title="containing block（包含块）"></a>containing block（包含块）</h2><p>定义：在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。<br>PS：主要作用是以百分比（相关于包含块）计算自身的width、height、top、left、padding、margin等css Layout 属性。<br><a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">我所了解的CSS包含块</a>    </p><h2 id="FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）"><a href="#FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）" class="headerlink" title="FOUC（无样式内容闪烁Flash Of Unstyled Content）"></a>FOUC（无样式内容闪烁Flash Of Unstyled Content）</h2><p>定义：指的是加载网页时出现的短暂的CSS样式失效。<br>方案：head头部放css、避免使用import<br><a href="https://www.cnblogs.com/fsjohnhuang/p/6739064.html" target="_blank" rel="external">FOUC</a></p><h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>定义：由于不同的浏览器对CSS的支持程度不同，同样CSS的样式代码在不同浏览器当中的表现可能出现不一致。为了让所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。<br>方案：属性前缀法、选择器前缀法、条件注释法（<!--[if lt IE 8]-->）</p><h2 id="Domain-Name（域名）"><a href="#Domain-Name（域名）" class="headerlink" title="Domain Name（域名）"></a>Domain Name（域名）</h2><p>域名（英语：Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>顶级域名又称为跟域名（TLD）共1058+（.com、.net、.cn等等）<br>13个根域名服务器（不代表只有13台服务器，事实上517+台服务器）</p><h2 id="DNS（网域名称系统Domain-Name-System）"><a href="#DNS（网域名称系统Domain-Name-System）" class="headerlink" title="DNS（网域名称系统Domain Name System）"></a>DNS（网域名称系统Domain Name System）</h2><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p><h2 id="a链接问题"><a href="#a链接问题" class="headerlink" title="a链接问题"></a>a链接问题</h2><p>a链接使用绑定 mousedown 事件且 event.preventDefault() 会导致 :active 伪类失效（Firefox）。<br>PS：Firefox 认为 mousedown 事件在 :active 之前发生。</p><h2 id="min-width、max-width、width、-important优先级"><a href="#min-width、max-width、width、-important优先级" class="headerlink" title="min-width、max-width、width、!important优先级"></a>min-width、max-width、width、!important优先级</h2><p>如果min-width、max-width、width、!important同时存在时，优先级顺序：min-width &gt;&gt; max-width &gt;&gt; !important &gt;&gt; width</p><h2 id="巧用css-兄弟选择器（如导航分割线）"><a href="#巧用css-兄弟选择器（如导航分割线）" class="headerlink" title="巧用css 兄弟选择器（如导航分割线）"></a>巧用css 兄弟选择器（如导航分割线）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;</div><div class="line">// 这样排除第一个元素</div><div class="line">a + a:before &#123;</div><div class="line">content: &quot;&quot;;</div><div class="line">font-size: 0;</div><div class="line">padding: 10px 3px 1px;</div><div class="line">margin-left: 6px;</div><div class="line">border-left: 1px solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="img-在firefox和其他浏览器的差异"><a href="#img-在firefox和其他浏览器的差异" class="headerlink" title="img 在firefox和其他浏览器的差异"></a>img 在firefox和其他浏览器的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">// width 和 height 无效，需要设置display: inline-block;</div><div class="line">width: xx;</div><div class="line">height: xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="关于百分比设置下列属性"><a href="#关于百分比设置下列属性" class="headerlink" title="关于百分比设置下列属性"></a>关于百分比设置下列属性</h2><p>left（right）、width、padding、margin、background-position、text-index设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>的width值<br>top（bottom）、height设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>height值</p><h2 id="滚动容器底部留白"><a href="#滚动容器底部留白" class="headerlink" title="滚动容器底部留白"></a>滚动容器底部留白</h2><p>滚动容器底部留白使用 margin-bottom，使用 padding-bottom 存在兼容性问题。</p><h2 id="margin-合并（只存在垂直方向）"><a href="#margin-合并（只存在垂直方向）" class="headerlink" title="margin 合并（只存在垂直方向）"></a>margin 合并（只存在垂直方向）</h2><ol><li>相邻兄弟元素 margin 合并。</li><li>父级和第一个、父级和最后一个子元素。（虽然是在子元素上设置的 margin-top，但实际上就等同于在父元素上设置了 margin-top）</li><li>空块级元素的 margin 合并。</li></ol><p>PS：合并规则，正正取大值，正负值相加，负负最小值。</p><h2 id="margin-auto-的理解"><a href="#margin-auto-的理解" class="headerlink" title="margin: auto;的理解"></a>margin: auto;的理解</h2><p>margin: auto; 表示对剩余空白进行分配。<br>下面元素 .son 的 margin-left 为 300 - 200 -80 = 20px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-right: 80px;</div><div class="line">margin-left: auto; // 20px</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 margin 来进行 right 对齐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-left: auto; // 此时 auto 值为100px</div><div class="line">// flot: right; 等价</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：块级元素的左中右对齐使用 margin ，内联元素使用 text-align 控制左中右对戏。<br>水平和垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px; height:150px;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">position: absolute; // 很关键</div><div class="line">top: 0; right: 0; bottom: 0; left: 0;</div><div class="line">width: 200px; height: 100px;</div><div class="line">margin: auto; // 很关键</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="border-的一些秘密"><a href="#border-的一些秘密" class="headerlink" title="border 的一些秘密"></a>border 的一些秘密</h2><p>border-width 不支持百分比值（outline、box-shadow、text-shadow同样）<br>border-style:double 至少 3px 才有效果。<br>border-style:dashed 不同浏览器不一致（虚线颜色区的宽高比以及颜色区和透明区的宽度比例），如chrome上为方形ie为圆形。<br>thin（1px）、medium（默认值3px）、thick（4px）。</p><h2 id="border-技巧"><a href="#border-技巧" class="headerlink" title="border 技巧"></a>border 技巧</h2><p>等腰三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>直角三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>边框 3D 效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 10px; height: 10px;</div><div class="line">border: 10px solid;</div><div class="line">border-color: #f30 #00f #396 #0f0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="http://www.cnblogs.com/xiaohuochai/p/5457127.html" target="_blank" rel="external">等高布局</a></p><h2 id="css-度量单位-ex"><a href="#css-度量单位-ex" class="headerlink" title="css 度量单位 ex"></a>css 度量单位 ex</h2><p>相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。<br>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>作用：基于ex单位的天然垂直居中对齐效果</p><h2 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h2><p>行距 = line-height - font-size</p><h2 id="line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？"><a href="#line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？" class="headerlink" title="line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？"></a>line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？</h2><p>因为继承细节有所差别，如果使用数值作为 line-height 的属性值，那么所有的子元素继承的都是这个值（如1.5）；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值（16px*150%=24px，此时继承的就是24px这个值，不是150%）。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>作用：只能应用于内联元素以及 display 值为 table-cell 的元素。<br>定义：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。<br>线类，如 baseline（默认值）、top、middle、bottom；<br>文本类，如 text-top、text-bottom；<br>上标下标类，如 sub、super；<br>数值百分比类，如 20px、2em、20%等<br>PS：其实middle为基线往上 1/2 x-height 处（ x-height 为 x 的高度）</p><h2 id="消除图片下间隙"><a href="#消除图片下间隙" class="headerlink" title="消除图片下间隙"></a>消除图片下间隙</h2><ol><li>display:block;</li><li>vertical-align:top; // top，text-top，bottom，text-bottom 均可</li><li>font-size:0; // 父级设置</li><li>overflow:hidden;</li><li>float:left;</li></ol><p><a href="http://www.cnblogs.com/luojianqun/archive/2013/07/08/3177969.html" target="_blank" rel="external">CSS图片下面产生间隙的6种解决方案</a></p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>规范约定了浮动元素和内联元素在一行显示。<br>浮动元素会生成一个块级框，而不论它本身是何种元素。</p><h2 id="clip属性"><a href="#clip属性" class="headerlink" title="clip属性"></a>clip属性</h2><p>fixed 固定定位的剪裁<br>最佳可访问性隐藏（clip: rect(0,0,0,0)）</p><h2 id="stacking-context（层叠上下文）"><a href="#stacking-context（层叠上下文）" class="headerlink" title="stacking context（层叠上下文）"></a>stacking context（层叠上下文）</h2><p>层叠上下文，英文称作 stacking context，是 HTML 中的一个三维的概念。</p><h3 id="层叠水平（stacking-level-（逐渐升高）"><a href="#层叠水平（stacking-level-（逐渐升高）" class="headerlink" title="层叠水平（stacking level)（逐渐升高）"></a>层叠水平（stacking level)（逐渐升高）</h3><ol><li>层叠上下文（background/border） – 充当背景色</li><li>负的z-index</li><li>block块状水平盒子 – 布局</li><li>float浮动盒子</li><li>inline水平盒子（inline/inline-block/inline-table） – 内容</li><li>z-index:anto 或 看成 z-index:0</li><li>正的z-index</li></ol><p>一般情况都会满足满足上面的规则，详情可以看下面demo：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="pKverE" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/pKverE/" target="_blank" rel="external">stackingContext</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="external">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="如何触发一个元素形成堆叠上下文？"><a href="#如何触发一个元素形成堆叠上下文？" class="headerlink" title="如何触发一个元素形成堆叠上下文？"></a>如何触发一个元素形成堆叠上下文？</h3><ol><li>根元素 (HTML),</li><li>z-index 值不为 “auto”的 绝对/相对定位，</li><li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li><li>transform 属性值不为 “none”的元素，</li><li>mix-blend-mode 属性值不为 “normal”的元素，</li><li>filter值不为“none”的元素，</li><li>perspective值不为“none”的元素，</li><li>isolation 属性被设置为 “isolate”的元素，</li><li>position: fixed</li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li></ol><p>PS：使用了上述属性就会形成一个stacking context（堆叠上下文）。此时，要对两者进行层叠排列，就需要 z-index ，z-index 越高的层叠层级越高。<br>做了一个上述情况的demo：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="JZoWWp" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext2" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/JZoWWp/" target="_blank" rel="external">stackingContext2</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="external">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><a href="https://www.cnblogs.com/coco1s/p/5899089.html" target="_blank" rel="external">层叠顺序与堆栈上下文知多少</a></p><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。<br><a href="https://segmentfault.com/a/1190000014457824" target="_blank" rel="external">你应该知道的requestIdleCallback</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文所有知识点，点到即止，详细内容请看各部分的连接。&lt;/p&gt;
&lt;h2 id=&quot;XSS（跨站脚本攻击Cross-Site-Script）&quot;&gt;&lt;a href=&quot;#XSS（跨站脚本攻击Cross-Site-Script）&quot; class=&quot;headerlink&quot; title=&quot;XS
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Web" scheme="https://fanerge.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Web安全</title>
    <link href="https://fanerge.github.io/2018/web%E5%AE%89%E5%85%A8.html"/>
    <id>https://fanerge.github.io/2018/web安全.html</id>
    <published>2018-05-09T14:05:43.000Z</published>
    <updated>2018-06-20T15:04:23.480Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲一些标准的规范使我们的Web更加安全，常见的Web安全问题将会在后面介绍（XSS、CSRF、MITM、SQL注入等），如有理解不当，还望指出，在此感谢。<br>文章略长，主体线索为首先介绍浏览器 <code>源Origin</code> 相关知识，它是Web安全的基石，后面的小节大多依赖该小节。</p><h1 id="信息安全的三要素（CIA）"><a href="#信息安全的三要素（CIA）" class="headerlink" title="信息安全的三要素（CIA）"></a>信息安全的三要素（CIA）</h1><p>(1)保密性（Confidentiality）:是指网络信息不被泄露给非授权的用户、实体或过程。即信息只为授权用户使用。保密性是在可靠性和可用性基础之上，保障网络信息安全的重要手段。<br>(2)完整性（Integrity）：指在传输、存储信息或数据的过程中，确保信息或数据不被采授权的用户篡改或在篡改后能够被迅速发现。<br>(3)可用性（Availability）:保证合法用户对信息和资源的使用不会被不正当地拒绝（DOS拒绝服务攻击就属于该类）。</p><h1 id="同源策略（Same-origin-policy）"><a href="#同源策略（Same-origin-policy）" class="headerlink" title="同源策略（Same-origin policy）"></a>同源策略（Same-origin policy）</h1><p>同源策略限制了一个源（origin）中加载的文档或脚本与其他源（origin）中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。</p><h2 id="一个源的定义"><a href="#一个源的定义" class="headerlink" title="一个源的定义"></a>一个源的定义</h2><p>如果两个页面的协议、域名、端口（如果有指定）和都相同，则两个页面具有相同的源。</p><h2 id="源的继承"><a href="#源的继承" class="headerlink" title="源的继承"></a>源的继承</h2><p>data：URLs获得一个新的，空的安全上下文。<br>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。<br>例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  机制）。 如果此弹出窗口也包含代码，则该代码将继承与创建它的脚本相同的源。data: URL会得到一个新的空的安全上下文。<br>值得一提的时 IE 例外，当涉及到同源策略时，Internet Explorer 有两个主要的不同点授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。<br>端口：IE 未将端口号加入到同源策略的组成部分之中，因此 <code>http://company.com:81/index.html</code> 和 <code>http://company.com/index.html</code> 属于同源并且不受任何限制。</p><h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h2><p>页面可能会因某些限制而改变他的源。脚本可以将 document.domain 的值设置为其当前域或其当前域的超级域。如果将其设置为其当前域的超级域，则较短的域将用于后续源检查。<br>假设 <code>http://store.company.com/dir/other.html</code> 文档中的一个脚本执行以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.domain = &quot;company.com&quot;;</div></pre></td></tr></table></figure></p><p>这条语句执行之后，页面将会成功地通过对 <code>http://company.com/dir/page.html</code> 的同源检测（假设<code>http://company.com/dir/page.html</code> 将其 document.domain 设置为“company.com”）。然而，company.com 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的超级域。<br>PS：在根域范围内，浏览器允许你把domain属性的值设置为它的上一级域。例如，在 <code>cicada.alipay.com</code> 域内，可以把domain设置为 <code>alipay.com</code> 但不能设置为 <code>alipay.org</code> 或者 <code>com</code>。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain" target="_blank" rel="external">查看document.domain的用法</a><br>PS：浏览器单独保存端口号。任何的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此 <code>company.com:8080</code> 不能仅通过设置 document.domain = <code>company.com</code> 来与 <code>company.com</code> 通信，还必须在他们双方中都进行赋值，以确保端口号都为 null 。<br>使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。</p><h2 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h2><p>同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest 或 img 标签时则会受到同源策略的约束<br>这些交互通常分为三类：</p><ol><li>通常允许跨域写操作（Cross-origin writes）。例如链接（links）、重定向、表单提交。</li><li>通常允许跨域资源嵌入（Cross-origin embedding）。</li><li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法等。</li></ol><p>以下是可能嵌入跨源的资源的一些示例：</p><ol><li>script 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。</li><li>link 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。</li><li>img 嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,…</li><li>video 和 audio 嵌入多媒体资源。</li><li>object, embed 和 applet 的插件。</li><li>@font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</li><li>frame（已废弃） 和 iframe 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</li></ol><h2 id="允许-阻止跨域访问"><a href="#允许-阻止跨域访问" class="headerlink" title="允许/阻止跨域访问"></a>允许/阻止跨域访问</h2><h3 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a>如何允许跨源访问</h3><p>CORS、JSONP、document.domain、window.name、window.postMessage、CSST (CSS Text Transformation)这个比较少见的方案<br>以上方式各有使用场景，具体实现请看<a href="https://zhuanlan.zhihu.com/p/24198444" target="_blank" rel="external">知乎-关于前端跨域的整理</a></p><h3 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a>如何阻止跨源访问</h3><p>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。<br>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。<br>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Conten-Type 消息头。例如，如果您在HTML文档中指定 <code>&lt;script\&gt;</code> 标记，则浏览器将尝试将HTML解析为JavaScript。 当你的资源不是你网站的入口点时，你还可以使用CSRF令牌来防止嵌入。</p><h2 id="跨源脚本API访问"><a href="#跨源脚本API访问" class="headerlink" title="跨源脚本API访问"></a>跨源脚本API访问</h2><p>不同浏览器可能有差异，下面以标准为准。<br>Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制。<br>PS：为了在不同源中文档进一步交流，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a>。</p><h3 id="window（方法和属性）"><a href="#window（方法和属性）" class="headerlink" title="window（方法和属性）"></a>window（方法和属性）</h3><p>window.blur<br>window.close<br>window.focus<br>window.postMessage<br>window.closed    只读.<br>window.frames    只读.<br>window.length    只读.<br>window.location    读/写.<br>window.opener    只读.<br>window.parent    只读.<br>window.self    只读.<br>window.top    只读.<br>window.window  只读.</p><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>location.replace<br>location.href      只写.</p><h2 id="跨源数据存储访问"><a href="#跨源数据存储访问" class="headerlink" title="跨源数据存储访问"></a>跨源数据存储访问</h2><p>存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。<br>Cookies 使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。<br>PS：Public Suffix为互联网名称与数字地址分配机构)提供的 TLD(Top Level Domain，顶级域名)列表，如com、net、org等都属于这个列表。</p><h1 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP (内容安全策略)"></a>CSP (内容安全策略)</h1><p>内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。<br>其实CSP的本质是以白名单的机制对网站加载或执行的资源起作用。</p><h2 id="适用方式"><a href="#适用方式" class="headerlink" title="适用方式"></a>适用方式</h2><ol><li>可以通过配置你的网络服务器返回  Content-Security-Policy  HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部，它是旧版本)。</li><li>在html页面中meta元素中使用，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="支持的策略指令"><a href="#支持的策略指令" class="headerlink" title="支持的策略指令"></a>支持的策略指令</h2><h3 id="base-uri"><a href="#base-uri" class="headerlink" title="base-uri"></a>base-uri</h3><p>base-uri 指令定义了 URI，它可以作为文档的基准 URL。</p><h3 id="connect-src"><a href="#connect-src" class="headerlink" title="connect-src"></a>connect-src</h3><p>connect-src 指令定义了请求、XMLHttpRequest、WebSocket 和 EventSource（Server-Sent Events(简称SSE)） 的连接来源。</p><h3 id="default-src"><a href="#default-src" class="headerlink" title="default-src"></a>default-src</h3><p>default-src 指令定义了那些没有被更精确指令指定的（默认）安全策略。<br>该指令包含了以下指令：connect-src、font-src、img-src、media-src、object-src、script-src、style-src</p><h3 id="font-src"><a href="#font-src" class="headerlink" title="font-src"></a>font-src</h3><p>font-src 指令定义了通过 @font-face加载字体的有效源。</p><h3 id="form-action"><a href="#form-action" class="headerlink" title="form-action"></a>form-action</h3><p>指定form提交的源。</p><h3 id="frame-ancestors"><a href="#frame-ancestors" class="headerlink" title="frame-ancestors"></a>frame-ancestors</h3><p>frame、iframe的src属性源。</p><h3 id="img-src"><a href="#img-src" class="headerlink" title="img-src"></a>img-src</h3><p>img元素的src属性源。</p><h3 id="media-src"><a href="#media-src" class="headerlink" title="media-src"></a>media-src</h3><p>audio、video的加载源。</p><h3 id="object-src"><a href="#object-src" class="headerlink" title="object-src"></a>object-src</h3><p>object、embed、applet的加载源。</p><h3 id="plugin-types"><a href="#plugin-types" class="headerlink" title="plugin-types"></a>plugin-types</h3><p>plugin源。</p><h3 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h3><h3 id="script-src"><a href="#script-src" class="headerlink" title="script-src"></a>script-src</h3><p>script源，且禁用内联脚本和eval()。</p><h3 id="style-src"><a href="#style-src" class="headerlink" title="style-src"></a>style-src</h3><p>style的源。</p><h2 id="内容源"><a href="#内容源" class="headerlink" title="内容源"></a>内容源</h2><h3 id="源列表"><a href="#源列表" class="headerlink" title="源列表"></a>源列表</h3><p>源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的 URL 协议和/或端口号。<br><a href="http://*.foo.com" target="_blank" rel="external">http://*.foo.com</a><br>匹配所有使用 http: 协议加载 foo.com 任何子域名的尝试。<br>mail.foo.com:443<br>匹配所有访问 mail.foo.com 的 443 端口 的尝试。<br><a href="https://store.foo.com" target="_blank" rel="external">https://store.foo.com</a><br>匹配所有使用 https: 协议访问 store.foo.com 的尝试。<br>如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>‘none’<br>代表空集；即不匹配任何 URL。<br>‘self’<br>代表和文档同源，包括相同的 URL 协议和端口号。<br>‘unsafe-inline’<br>允许使用内联资源，如内联的 <code>script</code> 元素、javascript: URL、内联的事件处理函数和内联的 <code>style</code> 元素。<br>‘unsafe-eval’<br>允许使用 eval() 等通过字符串创建代码的方法。</p><h1 id="安全环境"><a href="#安全环境" class="headerlink" title="安全环境"></a>安全环境</h1><p>当浏览器满足安全的最低要求时将进入一种安全环境。安全环境允许浏览器暴露那些只有在被安全地传输给用户时才被允许的 APIs。<br>作用：安全上下文的主要目标是防止攻击者访问功能强大的api,可进一步妥协的攻击的受害者。</p><h2 id="检测环境是否安全"><a href="#检测环境是否安全" class="headerlink" title="检测环境是否安全"></a>检测环境是否安全</h2><p>你可以使用特征检测来判断上下文是否处于安全的上下文之中通过使用在全局作用域下公共的isSecureContext返回的布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 在安全环境下使用serviceWorker执行offline-worker.js</div><div class="line">if (window.isSecureContext) &#123;</div><div class="line">  // 页面是是个安全的上下文，服务可以正常使用。</div><div class="line">  navigator.serviceWorker.register(&quot;/offline-worker.js&quot;).then(function () &#123;</div><div class="line">    ...</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="如何保护我们站点"><a href="#如何保护我们站点" class="headerlink" title="如何保护我们站点"></a>如何保护我们站点</h1><h2 id="用户信息安全"><a href="#用户信息安全" class="headerlink" title="用户信息安全"></a>用户信息安全</h2><h3 id="如何关闭表单的自动补全功能"><a href="#如何关闭表单的自动补全功能" class="headerlink" title="如何关闭表单的自动补全功能"></a>如何关闭表单的自动补全功能</h3><p>许多浏览器表单字段支持自动补全功能; 因此他们的值可以被推荐和下一次用户访问你的网站时自动恢复。某一类型的数据, 你可能希望禁止这个功能。<br>默认情况下，浏览器会记录用户网页上提交的输入框的信息。这样浏览器便能够做到自动完成（在用户开始输入的时候给用户提供可能的内容）和自动填充（在加载的时候预先填充某些字段）功能。</p><h4 id="如何禁用自动填充？"><a href="#如何禁用自动填充？" class="headerlink" title="如何禁用自动填充？"></a>如何禁用自动填充？</h4><p>为整个表单设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;post&quot; action=&quot;/form&quot; autocomplete=&quot;off&quot;&gt;</div><div class="line">[…]</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p><p>为单个字段设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;post&quot; action=&quot;/form&quot;&gt;</div><div class="line">  […]</div><div class="line">&lt;label&gt;name：</div><div class="line">&lt;input type=&quot;text&quot; id=&quot;cc&quot; name=&quot;cc&quot; autocomplete=&quot;off&quot;&gt;</div><div class="line">&lt;/label&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p><p>在这里设置 autocomplete=”off” 会有两种效果：</p><ol><li>它会阻止浏览器为了以后自动完成类似的表单来自动保存表单数据，但是浏览器是不一样的。</li><li>它会阻止浏览器历史记录缓存中的表单数据。当表单数据来自缓存的时候，当用户点击返回按钮来返回的时候，用户填写的信息是可见的。</li></ol><p>PS：在某些情况下，即使浏览器的自动填充设置为off，浏览器依然会继续提示自动完成的值。这可能会让开发者百思不得其解。强制浏览器不自动填充的方法是为autocomplete设置一个随机的字符串，这个随机字符串不能为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input#attr-autocomplete" target="_blank" rel="external">autocomplete</a> 属性的可选值。</p><h4 id="自动填充属性和登录"><a href="#自动填充属性和登录" class="headerlink" title="自动填充属性和登录"></a>自动填充属性和登录</h4><p>现代浏览器继承了密码管理：当用户使用用户名和密码在一个网站上登录了，浏览器会替用户记住它（用户名和密码）。当用户再次访问站点你的时候，浏览器会自动使用存储的数据自动填充登录模块。<br>由于这个原因，许多现代浏览器都不支持在登录模块中设置 autocomplete=”off” ：</p><ol><li>如果一个网站为表单设置了autocomplete=”off”，如果表单包含了用户名和密码，浏览器依然会记住登录信息，并且如果用户同意，浏览器会在下一次用户访问网站的时候自动填充信息。</li><li>如果网站给用户名和密码的输入框设置了autocomplete=”off”，浏览器依然会记住这次登录，如果用户同意，浏览器将会在用户下次访问的时候自动填充登录信息。</li></ol><p>如果想要阻止在用户管理页面中填写密码字段，用户可以为自己以外的人指定新的密码，虽然所有的浏览器都还不支持，但是autocomplete = “new-password”应该被指定。</p><h3 id="隐私与-visited选择器"><a href="#隐私与-visited选择器" class="headerlink" title="隐私与:visited选择器"></a>隐私与:visited选择器</h3><h4 id="为什么说-visited选择器暴露了用户隐私？"><a href="#为什么说-visited选择器暴露了用户隐私？" class="headerlink" title="为什么说:visited选择器暴露了用户隐私？"></a>为什么说:visited选择器暴露了用户隐私？</h4><p>曾经，CSS选择器 :visited 被网站用来查看用户的浏览记录。通过使用 getComputedStyle() 或其他方法扫描用户的浏览记录来获取用户访问了哪些网站。这很容易实现，不仅能够判断用户是否曾经访问过这个页面，还能猜测出大量的用户身份信息。</p><h4 id="浏览器的处理"><a href="#浏览器的处理" class="headerlink" title="浏览器的处理"></a>浏览器的处理</h4><p>浏览器会在某些情况下对网页程序撒谎，尤其是 getComputedStyle() 和类似的功能，比如 element.querySelector() 总是返回值表示用户从未访问过网页上的任何一个链接。<br>另外，如果用到了兄弟选择器，如 :visited + span，\<span\> 显示为未访问的样式。<br>而且，在极少的情况下，如果用到了嵌套链接元素并且这个匹配的元素与历史记录中的不同，这个链接也以未访问的样式绘制。</span\></p><h4 id="对已访问链接样式的限制"><a href="#对已访问链接样式的限制" class="headerlink" title="对已访问链接样式的限制"></a>对已访问链接样式的限制</h4><p>你仍然可以给已访问链接设置视觉样式，但是对可用样式作出了限制。只有下列的属性才能被应用到已访问链接：</p><ol><li>color</li><li>background-color</li><li>border-color (and its sub-properties)</li><li>outline-color</li><li>fill 和 stroke 属性的颜色部分（SVG中使用）</li></ol><h2 id="内容安全"><a href="#内容安全" class="headerlink" title="内容安全"></a>内容安全</h2><h3 id="正确配置服务器的MIME-Types"><a href="#正确配置服务器的MIME-Types" class="headerlink" title="正确配置服务器的MIME Types"></a>正确配置服务器的MIME Types</h3><h4 id="什么是MIME-Types？"><a href="#什么是MIME-Types？" class="headerlink" title="什么是MIME Types？"></a>什么是MIME Types？</h4><p>MIME类型描述内容的媒体类型在电子邮件或由web服务器或web应用程序,旨在帮助指导web浏览器如何处理并显示内容。<br>常用的MIME Types？</p><ol><li>text/html for normal web pages</li><li>text/plain for plain text</li><li>text/css for Cascading Style Sheets</li><li>text/javascript for scripts</li><li>application/octet-stream meaning “download this file”</li><li>application/x-java-applet for Java applets</li><li>application/pdf for PDF documents</li></ol><h4 id="为什么是正确的MIME类型"><a href="#为什么是正确的MIME类型" class="headerlink" title="为什么是正确的MIME类型?"></a>为什么是正确的MIME类型?</h4><p>如果web服务器或应用程序设置了的不正确的MIME类型，一个web浏览器没有方法通过HTTP规范从而知道作者想要怎样处理它。<br>大多数浏览器允许错误配置MIME Types的web服务器和应用程序可以通过猜测其MIME Types。<br>服务内容使用正确的MIME类型也可以是重要的出于安全原因;恶意内容可能影响用户的计算机，冒充一个安全的类型的文档。</p><h4 id="如何设置您的服务器发送正确的MIME类型？"><a href="#如何设置您的服务器发送正确的MIME类型？" class="headerlink" title="如何设置您的服务器发送正确的MIME类型？"></a>如何设置您的服务器发送正确的MIME类型？</h4><p>如果你使用Apache web服务器,只需将这个示例. htaccess文件复制到目录,其中包含您想要发送的文件正确的MIME类型。如果你有一个完整的子目录的文件,就把文件在父目录;你不需要把它在每个子目录。<br>如果你使用Microsoft IIS,<a href="https://blog.csdn.net/xcymorningsun/article/details/53195521" target="_blank" rel="external">看到这篇文章</a>。<br>如果您正在使用一个服务器端脚本（Perl, PHP, ASP, or Java）生成内容,通常可以添加一行脚本的顶部。只需要设置正确的 Content-Type。</p><h3 id="严格使用HTTPS（HSTS）"><a href="#严格使用HTTPS（HSTS）" class="headerlink" title="严格使用HTTPS（HSTS）"></a>严格使用HTTPS（HSTS）</h3><p>HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP。</p><h4 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h4><p>你连接到一个免费WiFi接入点，然后开始浏览网站，访问你的网上银行，查看你的支出，并且支付一些订单。很不幸，你接入的WiFi实际上是黑客的笔记本热点，他们拦截了你最初的HTTP请求，然后跳转到一个你银行网站一模一样的钓鱼网站。 现在，你的隐私数据暴露给黑客了。<br>Strict Transport Security解决了这个问题；只要你通过HTTPS请求访问银行网站，并且银行网站配置好Strict Transport Security，你的浏览器知道自动使用HTTPS请求，这可以阻止黑客的中间人攻击的把戏。</p><h4 id="浏览器如何处理？"><a href="#浏览器如何处理？" class="headerlink" title="浏览器如何处理？"></a>浏览器如何处理？</h4><p>你的网站第一次通过HTTPS请求，服务器响应Strict-Transport-Security 头，浏览器记录下这些信息，然后后面尝试访问这个网站的请求都会自动把HTTP替换为HTTPS。<br>当HSTS头设置的过期时间到了，后面通过HTTP的访问恢复到正常模式，不会再自动跳转到HTTPS。<br>每次浏览器接收到Strict-Transport-Security头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。<br>Chrome、Firefox等浏览器里，当您尝试访问该域名下的内容时，会产生一个307 Internal Redirect（内部跳转），自动跳转到HTTPS请求。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Strict-Transport-Security: max-age=&lt;expire-time&gt;</div><div class="line">Strict-Transport-Security: max-age=&lt;expire-time&gt;; includeSubDomains</div><div class="line">Strict-Transport-Security: max-age=&lt;expire-time&gt;; preload</div></pre></td></tr></table></figure><h2 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h2><p>CORS属于HTTP访问控制特性，以下内容大多针对于XMLHttpRequest，有些并不适用于 Fetch 。<br>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。<br>比如，站点 <code>http://domain-a.com</code> 的某 HTML 页面通过 <code>img</code> 的 <code>src</code> 请求 <code>http://domain-b.com/image.jpg</code>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。<br>PS：跨域并非不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）<br>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><h3 id="CORS分类"><a href="#CORS分类" class="headerlink" title="CORS分类"></a>CORS分类</h3><p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。<br>相关请求头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Origin: http://api.bob.com</div></pre></td></tr></table></figure></p><p>PS：上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>相关响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div></pre></td></tr></table></figure></p><p>PS：<br>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>整个过程（<code>预检请求/响应-&gt;正常请求/响应</code>）<br><code>预检请求</code><br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>相关请求头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Origin: http://api.bob.com</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div></pre></td></tr></table></figure></p><p>PS：<br>（1）Origin代表请求源。<br>（2）Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。<br>（3）Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>相关响应头<br>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure></p><p>PS：<br>（1）Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（2）Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（3）Access-Control-Allow-Credentials<br>该字段与简单请求时的含义相同。<br>（4）Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<br><code>正常请求</code><br>预检请求成功后就可以进行正常请求了，相应的请求头和响应头与简单请求类似。</p><h4 id="相关请求头和响应头总结"><a href="#相关请求头和响应头总结" class="headerlink" title="相关请求头和响应头总结"></a>相关请求头和响应头总结</h4><p><code>请求头</code><br>Origin<br>语法：Origin: <origin><br>作用：表明预检请求或实际请求的源站。<br>Access-Control-Request-Method<br>语法：Access-Control-Request-Method: <method><br>作用：用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。<br>Access-Control-Request-Headers<br>语法：Access-Control-Request-Headers: <field-name>[, <field-name>]<em><br>作用：用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。<br><code>响应头</code><br>Access-Control-Allow-Origin<br>语法：Access-Control-Allow-Origin: origin | `</em><code>作用：允许访问该资源的外域 URI。Access-Control-Expose-Headers语法：Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header作用：在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。Access-Control-Max-Age语法：Access-Control-Max-Age: delta-seconds作用：Access-Control-Max-Age 头指定了预检请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。Access-Control-Allow-Credentials语法：Access-Control-Allow-Credentials: true作用：指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。Access-Control-Allow-Methods语法：Access-Control-Allow-Methods:  method[, method]</code><em><code>作用：用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。Access-Control-Allow-Headers语法：Access-Control-Allow-Headers: field-name [, field-name]</code></em>`<br>作用：用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</field-name></field-name></method></origin></p><h1 id="X-Frame-Options-响应头"><a href="#X-Frame-Options-响应头" class="headerlink" title="X-Frame-Options 响应头"></a>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>frame</code>（已废弃）, <code>iframe</code> 或者 <code>object</code> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p><h2 id="使用-X-Frame-Options"><a href="#使用-X-Frame-Options" class="headerlink" title="使用 X-Frame-Options"></a>使用 X-Frame-Options</h2><p>X-Frame-Options 有三个值:<br>DENY<br>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。<br>SAMEORIGIN<br>表示该页面可以在相同域名页面的 frame 中展示。<br>ALLOW-FROM uri<br>表示该页面可以在指定来源的 frame 中展示。<br>PS：如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:<br><code>Header always append X-Frame-Options SAMEORIGIN</code></p><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:<br><code>add_header X-Frame-Options SAMEORIGIN;</code></p><h3 id="配置-IIS"><a href="#配置-IIS" class="headerlink" title="配置 IIS"></a>配置 IIS</h3><p>配置 IIS 发送 X-Frame-Options 响应头，添加下面的配置到 Web.config 文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;system.webServer&gt;</div><div class="line">  ...</div><div class="line">  &lt;httpProtocol&gt;</div><div class="line">    &lt;customHeaders&gt;</div><div class="line">      &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt;</div><div class="line">    &lt;/customHeaders&gt;</div><div class="line">  &lt;/httpProtocol&gt;</div><div class="line">  ...</div><div class="line">&lt;/system.webServer&gt;</div></pre></td></tr></table></figure></p><p>PS：注意: CSP Level 2 规范中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用。<br><a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">除了通过服务器配置防止自己网页被iframe形式嵌入，还可以使用js处理。</a></p><h1 id="子资源完整性（SRI）"><a href="#子资源完整性（SRI）" class="headerlink" title="子资源完整性（SRI）"></a>子资源完整性（SRI）</h1><p>子资源完整性(Subresource Integrity)是允许浏览器检查其获得的资源（例如从 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CDN" target="_blank" rel="external">CDN</a> 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。<br>子资源完整性 (SRI) 是一种安全功能，允许浏览器验证所获取的文件 (比如，从一个 CDN 内容分发网络) 是无意外操作而交付的。它的工作原理是允许你提供一个获取文件必须匹配的加密哈希。</p><h2 id="SRI-如何工作"><a href="#SRI-如何工作" class="headerlink" title="SRI 如何工作"></a>SRI 如何工作</h2><p>使用 内容分发网络 (CDN) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件)），因此可能潜在地攻击所有从该 CDN 获取文件的站点。<br>子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。</p><h2 id="如何使用-SRI"><a href="#如何使用-SRI" class="headerlink" title="如何使用 SRI"></a>如何使用 SRI</h2><p>将使用 base64 编码过后的文件哈希值写入你所引用的 \<script\> 或 \<link\> 标签的 integrigy 属性值中即可启用子资源完整性功能。<br>PS：integrity 值分成两个部分，第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。<br>integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。</link\></script\></p><h3 id="内容安全策略（CSP）和子资源完整性（SRI）共同使用"><a href="#内容安全策略（CSP）和子资源完整性（SRI）共同使用" class="headerlink" title="内容安全策略（CSP）和子资源完整性（SRI）共同使用"></a>内容安全策略（CSP）和子资源完整性（SRI）共同使用</h3><p>你可以根据内容安全策略来配置你的服务器使得指定类型的文件遵守 SRI。这是通过在 CSP 头部添加 require-sri-for 指令实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这条指令规定了所有 JavaScript 都要有 integrity 属性，且通过验证才能被加载。</div><div class="line">Content-Security-Policy: require-sri-for script;</div><div class="line">// 你也可以指定所有样式表也要通过 SRI 验证：</div><div class="line">Content-Security-Policy: require-sri-for style;</div></pre></td></tr></table></figure></p><p>你也可以对两者都加上验证。</p><h2 id="生成-SRI-哈希的工具"><a href="#生成-SRI-哈希的工具" class="headerlink" title="生成 SRI 哈希的工具"></a>生成 SRI 哈希的工具</h2><h3 id="openssl-在命令行"><a href="#openssl-在命令行" class="headerlink" title="openssl 在命令行"></a>openssl 在命令行</h3><p>你可以用 openssl 在命令行中执行如下命令来生成 SRI 哈希值：<br><code>cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A</code><br><a href="https://www.srihash.org/" target="_blank" rel="external">在线生成 SRI 哈希值的工具</a><br>下面以知乎的一个js文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原js文件地址</div><div class="line">https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js</div><div class="line">// 生成的脚本标签</div><div class="line">&lt;script src=&quot;https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js&quot; integrity=&quot;sha384-B4YDh2AljLezOmNwiezobW8FJbJQfyZxm1SksT7THfKULK6SVxN+dRNSvLxEmXtA&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><h3 id="shasum-在命令行"><a href="#shasum-在命令行" class="headerlink" title="shasum 在命令行"></a>shasum 在命令行</h3><p><code>shasum -b -a 384 FILENAME.js | xxd -r -p | base64</code></p><h1 id="用户密码是泄漏的原因？"><a href="#用户密码是泄漏的原因？" class="headerlink" title="用户密码是泄漏的原因？"></a>用户密码是泄漏的原因？</h1><p> HTTPS 协议旨在保护用户数据在网络上不被窃听（机密性） 和不被篡改（完整性）。处理用户数据的网站应该使用 HTTPS 协议保护他们的用户不受黑客的侵害。如果网站使用 HTTP 协议而不是 HTTPS 协议，窃取用户信息（比如他们的登录凭证）将会轻而易举。这曾经被 <a href="http://codebutler.github.io/firesheep/" target="_blank" rel="external">Firesheep</a> 很好地演示过。<br>这里罗列出密码所牵涉到的安全问题：</p><ol><li>在HTTP之上运行登录表单. 即使表单的action对象是HTTPS链接,用户的登录表单信息也会受到威胁,因为攻击者能够通过用户修改用户接收到的页面(例如,攻击者插入键盘记录脚本来盗取用户输入的密码.他们还能改变表单目的页从而将敏感信息传递到受他们控制的服务器).</li><li>在表单的action链接中使用HTTP链接.在这种情况下,用户输入的任何信息都将以明文方式通过网络传递.这样,从密码离开用户的电脑到密码到达服务器过程中,用户的密码将清楚地展现在任何嗅探用户网络的人眼前.</li><li>在网页iframe中递交登录表单(或是嵌入在HTTP frame中的HTTPS frame).即使最上层页面是HTTPS,但在HTTP iframe中包含密码域和在HTTP页面中包含密码域是没有区别的.攻击者同样能够修改这个页面以及偷取用户信息.</li><li>有时网页需要用户名及密码,但实际上却没有存储这些敏感的信息.例如,一个新闻页面可能存储一个用户想要再次阅读的文章,却没有存储任何关于这位用户的其他信息.这个新闻站点的网页开发者可能没有动力去对于提高他的网站的安全性以及保护他们用户的信息.不幸的是,密码重用也是一个大问题.用户可能在不同的站点使用相同的密码(新闻网页,社交网络,电子邮箱及其银行).因此即使通过用户名及密码登陆你的网页对你来说不是很大的问题,对于重复使用相同用户名及密码来登陆他们银行账户的用户来说却是一个极大的威胁.网络攻击者正变得越来越聪明.他们在一个网站同时盗取用户名及密码然后在另一个可能能给他们带来金钱的网站上使用这些密码.</li></ol><h1 id="弱签名算法"><a href="#弱签名算法" class="headerlink" title="弱签名算法"></a>弱签名算法</h1><p>在签署数字证书时，哈希算法的完整性是决定证书安全性的关键因素。哈希算法的弱点可能导致攻击者在某些情况下能够获得伪造的证书。由于技术的升级和已知的新型攻击，此类攻击的可行性已经大为提升。因此，不推荐使用旧算法，对于旧算法的支持最终也会停止。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>对基于MD5的签名的支持已在2012年初停止。</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>基于SHA-1的签名非常普遍；截至2015年5月，大约45%的数字证书皆使用此算法。但是，SHA-1已经过时因而不再推荐使用。<br>SHA-1的证书将从2017开始不再被主流浏览器厂商视为安全的。</p><h2 id="SHA-2（推荐使用）"><a href="#SHA-2（推荐使用）" class="headerlink" title="SHA-2（推荐使用）"></a>SHA-2（推荐使用）</h2><p>SHA-2是一个哈希算法家族，其中包括SHA-256和SHA-512。截至2015年，SHA-2家族被认为足够安全强大。许多证书颁发机构颁发新的证书使用SHA-256。<br>———-下列内容更新于2018-06-20————–</p><h1 id="Secure-By-Default-原则"><a href="#Secure-By-Default-原则" class="headerlink" title="Secure By Default 原则"></a>Secure By Default 原则</h1><ol><li>黑名单、白名单</li><li>最小权限原则</li><li>纵深防御原则</li><li>不可预测性原则<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1></li><li>同源策略（Same Origin Policy）</li><li>浏览器沙箱Sandbox 和 多线程架构</li><li>恶意网址拦截（大多基于黑名单）<br><a href="https://www.phishtank.com/" target="_blank" rel="external">PhishTank恶意网址黑名单</a><br>Google 的SafeBrowsing API<br>EVSSL证书</li><li>更安全的浏览器进化<br>IE8 的 XSS Filter功能<br>Firefox 的 CSP（Content Security Policy）<br>浏览器插件安全问题</li></ol><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">浏览器的同源策略</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://publicsuffix.org/" target="_blank" rel="external">PUBLIC SUFFIX LIST</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://www.srihash.org/" target="_blank" rel="external">SRI Hash Generator</a><br><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">HTTPS</a><br><a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt，免费好用的 HTTPS 证书</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲一些标准的规范使我们的Web更加安全，常见的Web安全问题将会在后面介绍（XSS、CSRF、MITM、SQL注入等），如有理解不当，还望指出，在此感谢。&lt;br&gt;文章略长，主体线索为首先介绍浏览器 &lt;code&gt;源Origin&lt;/code&gt; 相关知识，它是Web安全的
      
    
    </summary>
    
      <category term="安全" scheme="https://fanerge.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://fanerge.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>dom接口</title>
    <link href="https://fanerge.github.io/2018/dom%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://fanerge.github.io/2018/dom接口.html</id>
    <published>2018-05-08T12:43:18.000Z</published>
    <updated>2018-05-08T14:24:35.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CustomEvent"><a href="#CustomEvent" class="headerlink" title="CustomEvent"></a>CustomEvent</h1><p>创建一个自定义事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 添加一个适当的事件监听器</div><div class="line">obj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;)</div><div class="line"></div><div class="line">// 创建一个自定义事件</div><div class="line">var event = new CustomEvent(&quot;cat&quot;, &#123;&quot;detail&quot;:&#123;&quot;hazcheeseburger&quot;:true&#125;&#125;)</div><div class="line">// 分发事件</div><div class="line">obj.dispatchEvent(event)</div></pre></td></tr></table></figure></p><h1 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h1><p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。<br>DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。</p><h2 id="创建一个DocumentFragment"><a href="#创建一个DocumentFragment" class="headerlink" title="创建一个DocumentFragment"></a>创建一个DocumentFragment</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let ul = document.querySelector(`[data-uid=&quot;ul&quot;]`);</div><div class="line">let frag = document.createDocumentFragment();</div><div class="line">const list = [</div><div class="line">&apos;IE&apos;,</div><div class="line">&apos;Chrome&apos;</div><div class="line">];</div><div class="line">list.forEach(item =&gt; &#123;</div><div class="line">let li = document.creteElement(&apos;li&apos;);</div><div class="line">li.textContent = item;</div><div class="line">frag.appendChild(li);</div><div class="line">&#125;);</div><div class="line">// 只进行一次dom操作，触发一次reflow</div><div class="line">ul.appendChild(frag);</div><div class="line">```</div><div class="line">##其他方法（实例方法）</div></pre></td></tr></table></figure><p>documentFragment.find()<br>返回 DocumentFragment 树里第一个匹配的元素 Element 。<br>documentFragment.findAll()<br>返回 DocumentFragment 树里所有匹配的元素  NodeList。<br>documentFragment.querySelector()<br>documentFragment.querySelectorAll()<br>documentFragment.getElementById()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#MutationObserver</div><div class="line">给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</div><div class="line">##实例方法</div><div class="line">observe()</div><div class="line">给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.</div><div class="line">disconnect()</div><div class="line">让该观察者对象停止观察指定目标的DOM变化.即使再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.</div><div class="line">takeRecords()</div><div class="line">清空观察者对象的记录队列,并返回里面的内容.</div><div class="line">##示例</div></pre></td></tr></table></figure></p><p>let target = document.querySelector(‘#some-id’);</p><p>// 创建观察者对象<br>let observer = new MutationObserver(function(mutations) {<br>  mutations.forEach(function(mutation) {<br>    console.log(mutation.type);<br>  });<br>});</p><p>// 配置观察选项:<br>let config = { attributes: true, childList: true, characterData: true }</p><p>// 传入目标节点和观察选项<br>observer.observe(target, config);</p><p>// 随后,你还可以停止观察<br>observer.disconnect();<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CustomEvent&quot;&gt;&lt;a href=&quot;#CustomEvent&quot; class=&quot;headerlink&quot; title=&quot;CustomEvent&quot;&gt;&lt;/a&gt;CustomEvent&lt;/h1&gt;&lt;p&gt;创建一个自定义事件。&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>git工具书</title>
    <link href="https://fanerge.github.io/2018/git%E5%B7%A5%E5%85%B7%E4%B9%A6.html"/>
    <id>https://fanerge.github.io/2018/git工具书.html</id>
    <published>2018-04-23T14:41:30.000Z</published>
    <updated>2018-05-09T12:18:24.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%86.png" alt="git原理"><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">图片来源</a><br>PS：<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="git托管项目（新建-or-clone一个git项目）"><a href="#git托管项目（新建-or-clone一个git项目）" class="headerlink" title="git托管项目（新建 or clone一个git项目）"></a>git托管项目（新建 or clone一个git项目）</h2><p>mkdir gitdemo // 在当前目录创建gitdemo目录<br>cd gitdemo<br>pwd // 显示当前目录<br>git init // 将当前目录设置为git管理的仓库<br>git init [projectName] // 新建一个目录，将其初始化为Git代码库<br>or<br>git clone [ssh/https]</p><h2 id="工作区-gt-gt-暂存区（add为添加文件rm为移除文件）"><a href="#工作区-gt-gt-暂存区（add为添加文件rm为移除文件）" class="headerlink" title="工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）"></a>工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）</h2><p>git add [fileName] // 单个或多个文件<br>git add *.js // 通配符<br>git add -u  // 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .  // 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件<br>git add -A  // 提交所有变化（是git add .和git add -u的结合，git add -all的简写</p><p>git rm [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区<br>git rm --cached [fileName] // 停止追踪指定文件，但该文件会保留在工作区<br>git mv [fileNameOld] [fileNameNew] // 改名文件，并且将这个改名放入暂存区</p><h2 id="暂存区-gt-gt-本地仓库"><a href="#暂存区-gt-gt-本地仓库" class="headerlink" title="暂存区&gt;&gt;本地仓库"></a>暂存区&gt;&gt;本地仓库</h2><p>git commit -m ‘说明信息’ // 提交<br>git commit -am ‘说明’ // git add . 和 git commit的简写（一次完成两个动作）<br>常用commit type</p><ul><li>feat: 新功能</li><li>fix: 修复问题</li><li>docs: 修改文档</li><li>style: 修改代码格式，不影响代码逻辑</li><li>refactor: 重构代码，理论上不影响现有功能</li><li>perf: 提升性能</li><li>test: 增加修改测试用例</li><li>chore: 修改工具相关（包括但不限于文档、代码生成等）</li></ul><h2 id="本地仓库-gt-gt-远程仓库"><a href="#本地仓库-gt-gt-远程仓库" class="headerlink" title="本地仓库&gt;&gt;远程仓库"></a>本地仓库&gt;&gt;远程仓库</h2><p>git push ssh://git@dev.fanerge.com/gitdemo.git master // 把本地仓库提交到远程仓库的master分支中<br>git push -u origin master // 当前分支提交到远程 master 分支<br>git push // 如果当前分支与远程分支存在追踪关系</p><h2 id="远程仓库-gt-gt-本地仓库"><a href="#远程仓库-gt-gt-本地仓库" class="headerlink" title="远程仓库&gt;&gt;本地仓库"></a>远程仓库&gt;&gt;本地仓库</h2><p>git fetch [远程主机名] [分支名] // 远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地<br>git fetch origin master<br>git clone [ssh/https]// 从远程主机克隆一个版本库<br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">更详细的资料</a></p><h2 id="远程仓库-gt-gt-工作区"><a href="#远程仓库-gt-gt-工作区" class="headerlink" title="远程仓库&gt;&gt;工作区"></a>远程仓库&gt;&gt;工作区</h2><p>git pull [远程主机名] [远程分支名]:[本地分支名] // 远程主机某个分支的更新，再与本地的指定分支合并<br>git pull // 当前分支只有一个追踪分支时可省略部分参数</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>git branch // 查看本地所有分支（*表示当前分支）<br>git branch -v // 查看本地所有分支及最近一次提交信息<br>git branch -vv // 查看本地所有分支及最近一次提交信息和远程追踪分支<br>git branch -r // 查看远程所有分支<br>git branch -a // 查看本地/远程所有分支</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout [branchName] // 切换分支<br>git checkout - // 切换到上一个分支</p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>git branch [branchName] // 新建一个分支（但仍然留在当前分支）<br>git checkout -b [branchName] // 新建一个分支（并切换到该分支）<br>git branch [branchName] [commitId] // 新建一个分支（并指向指定的commitId）<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>如：新建 test 分支，并指向远程的 orign/dev 分支<br>git branch --track test origin/dev</p><h2 id="新建远程分支（新建本地分支，推送的远程作为远程分支）"><a href="#新建远程分支（新建本地分支，推送的远程作为远程分支）" class="headerlink" title="新建远程分支（新建本地分支，推送的远程作为远程分支）"></a>新建远程分支（新建本地分支，推送的远程作为远程分支）</h2><p>git branch [branchName]<br>git push origin [branchName]:[remoteBranchName]<br>还需要为新建本地分支和远程分支建立追踪关系<br>如：本地的 test 分支作为远程的 dev 分支<br>git push origin test:dev</p><h2 id="建立追踪关系（当前分支和远程分支）"><a href="#建立追踪关系（当前分支和远程分支）" class="headerlink" title="建立追踪关系（当前分支和远程分支）"></a>建立追踪关系（当前分支和远程分支）</h2><p>作用：用来描述当前和远程分支的位置关系，在使用git pull 和 git push 的时候可以省略远程参数<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>git branch –-set-upstream-to=origin/[branchName]<br>如：当前分支和远程 dev 分支建立追踪关系<br>git branch –-set-upstream-to=origin/dev</p><h2 id="合并分支（branchName合并到当前分支）"><a href="#合并分支（branchName合并到当前分支）" class="headerlink" title="合并分支（branchName合并到当前分支）"></a>合并分支（branchName合并到当前分支）</h2><p>git merge [branchName]<br>git rebase [branchName]<br>PS：<br>git merge dev（当前分支为master）<br>会在 master 分支产生一个新的commit。<br>git rebase dev（当前分支为master）<br>会将master上的提交推至顶端。</p><h2 id="删除分支（本地）"><a href="#删除分支（本地）" class="headerlink" title="删除分支（本地）"></a>删除分支（本地）</h2><p>git branch -d [branchName] // 删除分支（本地）<br>git push origin --delete [branchName] // 删除分支（远程）<br>git branch -dr [remoteBranchName] // 删除分支（远程）</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>tag作用类似于里程碑，可以快速找到里程碑的代码。</p><h2 id="查看所有tag"><a href="#查看所有tag" class="headerlink" title="查看所有tag"></a>查看所有tag</h2><p>git tag</p><h2 id="新建tag在当前commit"><a href="#新建tag在当前commit" class="headerlink" title="新建tag在当前commit"></a>新建tag在当前commit</h2><p>git tag [tagName]</p><h2 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h2><p>git tag [tagName] [commitId]</p><h2 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h2><p>git tag -d [tagName]</p><h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><p>git push origin :refs/tags/[tagName]</p><h2 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h2><p>git show [tagName]</p><h2 id="向远程提交指定tag"><a href="#向远程提交指定tag" class="headerlink" title="向远程提交指定tag"></a>向远程提交指定tag</h2><p>git push [remoteBranchName] [tagName]</p><h2 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h2><p>git checkout -b [branchName] [tagName]</p><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><h2 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h2><p>git status</p><h2 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h2><p>git log</p><h2 id="显示当前分支的版本历史（包括commit发生变更的文件）"><a href="#显示当前分支的版本历史（包括commit发生变更的文件）" class="headerlink" title="显示当前分支的版本历史（包括commit发生变更的文件）"></a>显示当前分支的版本历史（包括commit发生变更的文件）</h2><p>git log –stat</p><h2 id="显示当前分支的版本历史（通过关键词）"><a href="#显示当前分支的版本历史（通过关键词）" class="headerlink" title="显示当前分支的版本历史（通过关键词）"></a>显示当前分支的版本历史（通过关键词）</h2><p>git log -S [keyword]</p><h2 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h2><p>git log [tagName] HEAD –pretty=format:%s</p><h2 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h2><p>git log [tagName] HEAD –grep feature</p><h2 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h2><p>git log –follow [fileName]<br>git whatchanged [fileName]</p><h2 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h2><p>git log -p [fileName]</p><h2 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h2><p>git log -5 –pretty –oneline</p><h2 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h2><p>git shortlog -sn</p><h2 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h2><p>git blame [file]</p><h2 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h2><p>git biff</p><h2 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h2><p>git diff –cached [fileName]</p><h2 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h2><p>git diff HEAD</p><h2 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h2><p>git diff [first-branch]…[second-branch]</p><h2 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h2><p>git diff –shortstat “@{0 day ago}”</p><h2 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h2><p>git show [commitId]</p><h2 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h2><p>git show –name-only [commitId]</p><h2 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h2><p>git show [commitId]:[fileName]</p><h2 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h2><p>git reflog</p><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h2><p>git fetch [ssh/https]</p><h2 id="显示所有远程仓库（包括fetch和push地址）"><a href="#显示所有远程仓库（包括fetch和push地址）" class="headerlink" title="显示所有远程仓库（包括fetch和push地址）"></a>显示所有远程仓库（包括fetch和push地址）</h2><p>git remote -v</p><h2 id="显示某一远程仓库的信息"><a href="#显示某一远程仓库的信息" class="headerlink" title="显示某一远程仓库的信息"></a>显示某一远程仓库的信息</h2><p>git remote show [remoteRepositoryName]</p><h2 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h2><p>git remote add [shortname] [url]</p><h2 id="取回远程仓库的变化，并与本地分支合并（merge）"><a href="#取回远程仓库的变化，并与本地分支合并（merge）" class="headerlink" title="取回远程仓库的变化，并与本地分支合并（merge）"></a>取回远程仓库的变化，并与本地分支合并（merge）</h2><p>git pull [remote] [remoteBranchName]<br>PS：remote 一般为 origin ，当建立追踪关系，可以git pull 省略两个参数</p><h2 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h2><p>git push [remote] [branchName]</p><h2 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h2><p>git push [remote] –force</p><h2 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h2><p>git push [remote] –all</p><h1 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销/恢复"></a>撤销/恢复</h1><h2 id="撤销工作区修改（指定文件）"><a href="#撤销工作区修改（指定文件）" class="headerlink" title="撤销工作区修改（指定文件）"></a>撤销工作区修改（指定文件）</h2><p>git chekout – [fileName]</p><h2 id="撤销工作区（所有文件）"><a href="#撤销工作区（所有文件）" class="headerlink" title="撤销工作区（所有文件）"></a>撤销工作区（所有文件）</h2><p>git checkout – .</p><h2 id="暂存区–-gt-工作区（指定文件）"><a href="#暂存区–-gt-工作区（指定文件）" class="headerlink" title="暂存区–&gt;工作区（指定文件）"></a>暂存区–&gt;工作区（指定文件）</h2><p>git reset HEAD [fileName] // 撤销暂存区的修改<br>git checkout [fileName] // 撤销工作区的修改</p><h2 id="重置暂存区到上次提交commit（工作区不变）"><a href="#重置暂存区到上次提交commit（工作区不变）" class="headerlink" title="重置暂存区到上次提交commit（工作区不变）"></a>重置暂存区到上次提交commit（工作区不变）</h2><p>git reset [fileName]</p><h2 id="重置暂存区、工作区到上次提交commit"><a href="#重置暂存区、工作区到上次提交commit" class="headerlink" title="重置暂存区、工作区到上次提交commit"></a>重置暂存区、工作区到上次提交commit</h2><p>git reset –hard<br>git reset HEAD^ –hard // 回到上一次commit<br>git reset HEAD^^ –hard // 回到上一次的上一次commit</p><h2 id="重置暂存区、当前分支指定commitId（工作区不变）"><a href="#重置暂存区、当前分支指定commitId（工作区不变）" class="headerlink" title="重置暂存区、当前分支指定commitId（工作区不变）"></a>重置暂存区、当前分支指定commitId（工作区不变）</h2><p>git reset [commitId]</p><h2 id="重置暂存区、工作区、当前分支为指定commitId"><a href="#重置暂存区、工作区、当前分支为指定commitId" class="headerlink" title="重置暂存区、工作区、当前分支为指定commitId"></a>重置暂存区、工作区、当前分支为指定commitId</h2><p>git reset –hard [commitId]</p><h2 id="重置当前HEAD为指定commitId（暂存区、工作区不表）"><a href="#重置当前HEAD为指定commitId（暂存区、工作区不表）" class="headerlink" title="重置当前HEAD为指定commitId（暂存区、工作区不表）"></a>重置当前HEAD为指定commitId（暂存区、工作区不表）</h2><p>git reset –keep [commitId]</p><h2 id="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"><a href="#新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）" class="headerlink" title="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"></a>新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）</h2><p>git revert [commitId]</p><h2 id="暂时将未提交的变化存于stash，后续再从stash中取出"><a href="#暂时将未提交的变化存于stash，后续再从stash中取出" class="headerlink" title="暂时将未提交的变化存于stash，后续再从stash中取出"></a>暂时将未提交的变化存于stash，后续再从stash中取出</h2><p>git stash list // 查看 stash 列表<br>git stash // 保存当前暂未提交的修改<br>git stash apply // 从stash中恢复，但不清除该stash<br>git stash drop  // 清除该stash<br>git stash pop // 从stash中恢复并清除该stash<br>PS：一般用于停下手中活，处理更加紧急的任务，处理完任务后在回过头继续。<br>git stash pop = git stash apply + git stash drop</p><blockquote><p>   参考文档：<br><a href="https://git-scm.com/" target="_blank" rel="external">git 官网</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="external">Git教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%
      
    
    </summary>
    
      <category term="代码管理" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://fanerge.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>js算法集合</title>
    <link href="https://fanerge.github.io/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html"/>
    <id>https://fanerge.github.io/2018/js算法集合.html</id>
    <published>2018-04-08T14:20:17.000Z</published>
    <updated>2018-04-25T14:04:52.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断文本是否为回文"><a href="#判断文本是否为回文" class="headerlink" title="判断文本是否为回文"></a>判断文本是否为回文</h1><p>定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。</p><h2 id="方法一（字符串、数组内置方法）"><a href="#方法一（字符串、数组内置方法）" class="headerlink" title="方法一（字符串、数组内置方法）"></a>方法一（字符串、数组内置方法）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome1(val)&#123;</div><div class="line">// 允许输入字符串和数字和布尔值</div><div class="line">if (typeof val !== &apos;string&apos;) val = val.toString();</div><div class="line">let newVal = val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line"></div><div class="line">return val === newVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome1(121) // true</div><div class="line">isPalindrome1(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>// PS：方法简单，但效率不高，会产生一个新的变量</p><h2 id="方法二（循环）"><a href="#方法二（循环）" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome2(val)&#123;</div><div class="line">val = val + &apos;&apos;; // 非字符串转化为字符串</div><div class="line"></div><div class="line">// 这里为什么 i &lt;= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！</div><div class="line">for(let i = 0, j = val.length - 1; i &lt; j; i++, j--)&#123;</div><div class="line">if(val.charAt(i) !== val.charAt(j))&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome2(121) // true</div><div class="line">isPalindrome2(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>PS：网上还有其他解法，大多为以上两种的变形。</p><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="方法一（字符串、数组内置方法））"><a href="#方法一（字符串、数组内置方法））" class="headerlink" title="方法一（字符串、数组内置方法））"></a>方法一（字符串、数组内置方法））</h2><p>借用反转字符串的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal1(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">return val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法二（循环）-1"><a href="#方法二（循环）-1" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><p>循环系列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal2(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">i = 0,</div><div class="line">len = val.length;</div><div class="line">while(i &lt; len)&#123;</div><div class="line">str += val.charAt(len - 1 - i);</div><div class="line">i++; </div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal3(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">len = val.length;</div><div class="line">for(let i = len - 1; i &gt;= 0; i--)&#123;</div><div class="line">str += val.charAt(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：reverseVal(‘abc’) // ‘cba’</p><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="方法一（递归）"><a href="#方法一（递归）" class="headerlink" title="方法一（递归）"></a>方法一（递归）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize1(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line"></div><div class="line">// 建议不要使用 arguments.callee，目前已经废弃了。</div><div class="line">return n * factorialize1(n - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</p><h2 id="方法二（ES6尾调用优化）"><a href="#方法二（ES6尾调用优化）" class="headerlink" title="方法二（ES6尾调用优化）"></a>方法二（ES6尾调用优化）</h2><p>（递归优化版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize2(n, total = 1)&#123;</div><div class="line">if(typeof n !== &apos;number&apos; || typeof total !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return total;</div><div class="line"></div><div class="line">return factorialize2(n - 1, n * total)</div><div class="line">// f(3) =&gt; f(2, 3 * 2) =&gt; f(1, 6) =&gt; 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="external">ES6尾调用优化</a>但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><h2 id="方法三（循环）"><a href="#方法三（循环）" class="headerlink" title="方法三（循环）"></a>方法三（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize3(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line">let total = 1;</div><div class="line"></div><div class="line">while(n&gt;1)&#123;</div><div class="line">total = n * total;</div><div class="line">n--;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：factorialize1(3) // 6</p><h1 id="随机生成长度为n字符串"><a href="#随机生成长度为n字符串" class="headerlink" title="随机生成长度为n字符串"></a>随机生成长度为n字符串</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString1(n)&#123;</div><div class="line">let str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;</div><div class="line">let tem = &apos;&apos;,</div><div class="line">i = 0;</div><div class="line"></div><div class="line">// Math.random 函数产生值的范围[0,1)</div><div class="line">while(i&lt;n)&#123;</div><div class="line">tem += str.charAt(Math.floor(Math.random() * str.length))</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：Math.round(Math.random() <em> (str.length - 1))<br>Math.ceil(Math.random() </em> (str.length - 1))<br>Math.floor(Math.random() * str.length)<br>这三种方式等价，都能生成[0, str.length-1]随机数</p><h2 id="方法二（进制转化）"><a href="#方法二（进制转化）" class="headerlink" title="方法二（进制转化）"></a>方法二（进制转化）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString2(n)&#123;</div><div class="line">return Math.random().toString(36).substr(2).slice(0, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法原理为随机产生的数转换为指定进制字符串<br>toString(n)，n为[2,36]，n&lt;=10时只产生0-9也就是10进制数字<br>该方法有个缺点，产生字符串的长度有一定的限制。</p><h2 id="方法三（随机码点）"><a href="#方法三（随机码点）" class="headerlink" title="方法三（随机码点）"></a>方法三（随机码点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString3(n)&#123;</div><div class="line">let str = &apos;&apos;;</div><div class="line"></div><div class="line">function randomChar()&#123;</div><div class="line">let l = Math.floor(Math.random() * 62);</div><div class="line">if(l &lt; 10) return l; // 数字部分 0-9</div><div class="line">if(l &lt; 36) return String.fromCharCode(l + 55); // 大写字母</div><div class="line"></div><div class="line">return String.fromCharCode(l + 61); // 小写字母</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(str.length &lt; n) str += randomChar();</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以参考对于的<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="external">ASCII码表</a>。<br>测试：randomString1(3) // ‘1sd’</p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="方法一（ES6的Set数据结构）"><a href="#方法一（ES6的Set数据结构）" class="headerlink" title="方法一（ES6的Set数据结构）"></a>方法一（ES6的Set数据结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique1(ary)&#123;</div><div class="line">return [...new Set(ary)];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法二（对象的key唯一性）"><a href="#方法二（对象的key唯一性）" class="headerlink" title="方法二（对象的key唯一性）"></a>方法二（对象的key唯一性）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique2(ary)&#123;</div><div class="line">let obj = &#123;&#125;,</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(!obj[ary[i]])&#123;</div><div class="line">obj[ary[i]] = true; // 如果不存在</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">return Object.keys(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串。<br>会把数字1和字符串’1’，会被视为同一个值。</p><h2 id="方法三（临时数组判断插入）"><a href="#方法三（临时数组判断插入）" class="headerlink" title="方法三（临时数组判断插入）"></a>方法三（临时数组判断插入）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique3(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">// tem.indexOf() === -1 同理</div><div class="line">!tem.includes(ary[i]) ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法四（判断首次出现的位置）"><a href="#方法四（判断首次出现的位置）" class="headerlink" title="方法四（判断首次出现的位置）"></a>方法四（判断首次出现的位置）</h2><p>如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique4(ary)&#123;</div><div class="line">let tem = [ary[0]],</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">for(let i = 1; i &lt; len; i++ )&#123;</div><div class="line">// 核心，首次的索引出现是否为当前的索引</div><div class="line">if(ary.indexOf(ary[i]) === i) tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法五（排序后逐个比较插入）"><a href="#方法五（排序后逐个比较插入）" class="headerlink" title="方法五（排序后逐个比较插入）"></a>方法五（排序后逐个比较插入）</h2><p>给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; array 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique5(array)&#123;</div><div class="line">let ary = array.slice();</div><div class="line">ary.sort();</div><div class="line">let tem = [ary[0]];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">ary[i] !== tem[tem.length - 1] ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：返回的数组顺序发生了改变。</p><h2 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h2><p>获取没有重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique6(ary)&#123;</div><div class="line">let tem = [];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">for(let j = i + 1; j &lt; len; j++)&#123;</div><div class="line">if(ary[i] === ary[j]) j = ++i;</div><div class="line">&#125;</div><div class="line">tem.push(ary[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：unique1([1, 2, 3, 2]) // [1, 2, 3]</p><h1 id="出现次数最多的字符"><a href="#出现次数最多的字符" class="headerlink" title="出现次数最多的字符"></a>出现次数最多的字符</h1><h2 id="方法一（对象key的唯一性进行累加）"><a href="#方法一（对象key的唯一性进行累加）" class="headerlink" title="方法一（对象key的唯一性进行累加）"></a>方法一（对象key的唯一性进行累加）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function maxNum1(str)&#123;</div><div class="line">if(typeof(str) !== &apos;string&apos;) str = str.toString();</div><div class="line">let obj = &#123;&#125;,</div><div class="line">maxChar = []; // 使用数组保存出现最多次的某些字符</div><div class="line">str.split(&apos;&apos;).forEach( (val) =&gt; &#123;</div><div class="line">if(!obj[val])&#123;</div><div class="line">let demo = obj[val] = 1;</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line">obj[val]++;</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">let maxCount =  Math.max.apply(null, Object.values(obj))</div><div class="line"></div><div class="line">// forEach方法总是返回 undefined 且 没有办法中止或者跳出 forEach 循环。</div><div class="line">Object.entries(obj).forEach( item =&gt; &#123;</div><div class="line">if(item[1] == maxCount)&#123;</div><div class="line">maxChar.push(item[0])</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return maxChar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：maxNum1(‘11223333’) // ‘3’</p><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>实现方法：Array.prototype.flatten(depth)，参数depth表示需要扁平化的层数，返回一个新的数组。 </p><h2 id="方法一（递归遍历数组拼接）"><a href="#方法一（递归遍历数组拼接）" class="headerlink" title="方法一（递归遍历数组拼接）"></a>方法一（递归遍历数组拼接）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function flatten1(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(Array.isArray(ary[i]))&#123;</div><div class="line">// 递归进行上面步骤</div><div class="line">// [].concat(...ary)，它的参数可以为数组或值，作用为将数组或值连接成新数组。</div><div class="line">tem = tem.concat(flatten1(ary[i]))</div><div class="line">&#125;else&#123;</div><div class="line">tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法二（reduce结合concat）"><a href="#方法二（reduce结合concat）" class="headerlink" title="方法二（reduce结合concat）"></a>方法二（reduce结合concat）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.reduce((pre, cur) =&gt; &#123;</div><div class="line">return pre.concat(Array.isArray(cur) ? flatten2(cur) : cur)</div><div class="line">&#125;, [])</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法三（转化为字符串）"><a href="#方法三（转化为字符串）" class="headerlink" title="方法三（转化为字符串）"></a>方法三（转化为字符串）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.toString().split(&apos;,&apos;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：返回的数组项将为字符串。</p><h2 id="方法四（解构数组）"><a href="#方法四（解构数组）" class="headerlink" title="方法四（解构数组）"></a>方法四（解构数组）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function flatten4(ary)&#123;</div><div class="line"></div><div class="line">let tem = []</div><div class="line">ary.forEach(item =&gt; &#123;</div><div class="line">if(Array.isArray(item))&#123;</div><div class="line">tem = tem.concat(...item);</div><div class="line">&#125;else&#123;</div><div class="line">tem = tem.concat(item);</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：只能处理2维数组。<br>测试：getMaxProfit1([1, 2, 3, [4, 5, 6]]) // [1, 2, 3, 4, 5, 6]</p><h1 id="数组中最大差值"><a href="#数组中最大差值" class="headerlink" title="数组中最大差值"></a>数组中最大差值</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getMaxProfit1(ary)&#123;</div><div class="line">return Math.max.apply(null, ary) - Math.min.apply(null, ary);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：getMaxProfit1([1, 2, 3, 4]) // 3 </p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>这里我们只实现通项公式</p><h2 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fib1(n)&#123;</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return fib1(n - 1) + fib1(n - 2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(2^n)，空间复杂度为O(n)</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let tem = [1, 1];</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 数组索引从0开始，数列索引从1开始</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">tem[i] = tem[i-1] + tem[i-2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem[n-1];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(n)</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let prev = 1, </div><div class="line">next = 1,</div><div class="line">res;</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">res = prev + next;  </div><div class="line">prev = next; </div><div class="line">next = res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(1)<br>测试：fib2(3) // 2 </p><h1 id="判断是否为质数（prime-number）素数"><a href="#判断是否为质数（prime-number）素数" class="headerlink" title="判断是否为质数（prime number）素数"></a>判断是否为质数（prime number）素数</h1><p>质数：只能被1和自己整除且大于1的数。<br>合数：数大于1且因数多余2个（大于1的数质数的补集）。</p><h2 id="方法一（循环）"><a href="#方法一（循环）" class="headerlink" title="方法一（循环）"></a>方法一（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">if(n &lt; 2) return false;</div><div class="line">if(n === 2) return true; // 最小的质数</div><div class="line"></div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">if(n % i === 0)&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：isPrimeNumber1(2) // true</p><h2 id="方法二（正则）"><a href="#方法二（正则）" class="headerlink" title="方法二（正则）"></a>方法二（正则）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">  return n&lt;2?false:!/^(11+?)\1+$/.test(Array(n+1).join(&apos;1&apos;))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法很巧妙，于2018-04-25在掘金上发现。<br><a href="https://juejin.im/post/5adeb462f265da0b9c104358" target="_blank" rel="external">方法详解</a></p><h1 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function greatestCommonDivisor1(a, b)&#123;</div><div class="line">if(a &lt; 0 || b &lt; 0) throw new Error(&apos;参数只能为正整数&apos;);</div><div class="line">if(a &lt; 2 || b &lt; 2) return 1;</div><div class="line">let min = a,</div><div class="line">max = b,</div><div class="line">arymin = [];</div><div class="line"></div><div class="line">if(a &gt; b) &#123;</div><div class="line">min = b;</div><div class="line">max = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(let i = 1; i &lt;= min; i++)&#123;</div><div class="line">if(min % i === 0)&#123;</div><div class="line">arymin.push(i);</div><div class="line">console.log(1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">arymin.reverse();</div><div class="line"></div><div class="line">for(let j = 0, len = arymin.length; j &lt; len; j++)&#123;</div><div class="line">if(max % arymin[j] === 0)&#123;</div><div class="line">return arymin[j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：greatestCommonDivisor1(5, 10) // 5</p><h1 id="金额转大写"><a href="#金额转大写" class="headerlink" title="金额转大写"></a>金额转大写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function money2Chinese(num) &#123;</div><div class="line">  if(typeof num) throw new Error(&apos;参数为数字&apos;)</div><div class="line">  let strOutput = &quot;&quot;</div><div class="line">  let strUnit = &apos;仟佰拾亿仟佰拾万仟佰拾元角分&apos;</div><div class="line">  num += &quot;00&quot;</div><div class="line">  const intPos = num.indexOf(&apos;.&apos;)</div><div class="line">  if (intPos &gt;= 0) &#123;</div><div class="line">    num = num.substring(0, intPos) + num.substr(intPos + 1, 2)</div><div class="line">  &#125;</div><div class="line">  strUnit = strUnit.substr(strUnit.length - num.length)</div><div class="line">  for (let i = 0; i &lt; num.length; i++) &#123;</div><div class="line">    strOutput += &apos;零壹贰叁肆伍陆柒捌玖&apos;.substr(num.substr(i, 1), 1) + strUnit.substr(i, 1)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  return strOutput.replace(/零角零分$/, &apos;整&apos;).replace(/零[仟佰拾]/g, &apos;零&apos;).replace(/零&#123;2,&#125;/g, &apos;零&apos;).replace(/零([亿|万])/g, &apos;$1&apos;).replace(/零+元/, &apos;元&apos;).replace(/亿零&#123;0,3&#125;万/, &apos;亿&apos;).replace(/^元/, &quot;零元&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：money2Chinese(1234) // 壹仟贰佰叁拾肆元整</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断文本是否为回文&quot;&gt;&lt;a href=&quot;#判断文本是否为回文&quot; class=&quot;headerlink&quot; title=&quot;判断文本是否为回文&quot;&gt;&lt;/a&gt;判断文本是否为回文&lt;/h1&gt;&lt;p&gt;定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我所了解的CSS包含块</title>
    <link href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://fanerge.github.io/2018/一次详细的包含块学习.html</id>
    <published>2018-03-29T11:53:04.000Z</published>
    <updated>2018-05-27T03:00:44.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指出错误观念"><a href="#指出错误观念" class="headerlink" title="指出错误观念"></a>指出错误观念</h1><p>许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！<br>一个元素的尺寸和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。<br>下面我们看看盒模型：<br>当浏览器展示一个文档的时候，对于每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域：</p><ol><li>内容区</li><li>内边距区</li><li>边框区</li><li>外边距区<br><img src="http://p677fntmi.bkt.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></li></ol><h1 id="什么是包含块？"><a href="#什么是包含块？" class="headerlink" title="什么是包含块？"></a>什么是包含块？</h1><p>包含块有分为根元素包含块和其他元素的包含块。</p><h2 id="根元素包含块"><a href="#根元素包含块" class="headerlink" title="根元素包含块"></a>根元素包含块</h2><p>根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。<br>可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。<br>对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。</p><h2 id="其他元素的包含块"><a href="#其他元素的包含块" class="headerlink" title="其他元素的包含块"></a>其他元素的包含块</h2><p>大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样，下面就来学习如何确定这些元素的包含块。</p><h1 id="如何确定元素的包含块？"><a href="#如何确定元素的包含块？" class="headerlink" title="如何确定元素的包含块？"></a>如何确定元素的包含块？</h1><p>确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景：</p><ol><li>如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）或格式化上下文<a href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#BFC">BFC</a>(比如说 a table container, flex container, grid container, or the block container itself)的<span style="color: red">内容区的边缘</span>组成的。</li><li>如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的<span style="color: red">内边距区的边缘</span>组成的。</li><li>如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in  the case of paged media) 组成的。</li><li>如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的<span style="color: red">内边距区的边缘</span>组成的：<br>A transform or perspective value other than none<br>A will-change value of transform or perspective<br>A filter value other than none or a will-change value of filter (only works on Firefox).</li></ol><h1 id="元素包含块的作用？"><a href="#元素包含块的作用？" class="headerlink" title="元素包含块的作用？"></a>元素包含块的作用？</h1><p>元素的尺寸和位置经常受其包含块的影响。对于一个绝对定位的元素来说（他的 position 属性被设定为 absolute 或 fixed），如果它的 width, height, padding, margin, 和 offset 这些属性的值是一个比例值（如百分比等）的话，那这些值的计算值就是由它的包含块计算而来的。<br>简单来说，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</p><ol><li>height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。</li><li>width, left, right, padding, margin, text-indent(2018-05-27修改)这些属性由包含块的 width 属性的值来计算它的百分值。</li></ol><h1 id="下面看些例子"><a href="#下面看些例子" class="headerlink" title="下面看些例子"></a>下面看些例子</h1><p>下面示例公用HTML代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;section&gt;</div><div class="line">    &lt;p&gt;This is a paragraph!&lt;/p&gt;</div><div class="line">  &lt;/section&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: block;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;   /* == 400px * .5 = 200px */</div><div class="line">  height: 25%;  /* == 160px * .25 = 40px */</div><div class="line">  margin: 5%;   /* == 400px * .05 = 20px */</div><div class="line">  padding: 5%;  /* == 400px * .05 = 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk1.png" alt=""></p><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: inline;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;     /* == half the body&apos;s width */</div><div class="line">  height: 200px;  /* Note: a percentage would be 0 */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk2.png" alt=""></p><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  transform: rotate(0deg);</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 80px;</div><div class="line">  top: 30px;</div><div class="line">  width: 50%;   /* == 200px */</div><div class="line">  height: 25%;  /* == 40px */</div><div class="line">  margin: 5%;   /* == 20px */</div><div class="line">  padding: 5%;  /* == 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk3.png" alt=""></p><h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 30px;</div><div class="line">  top: 30px;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  padding: 30px 20px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  width: 50%;   /* == (400px + 20px + 20px) * .5 = 220px */</div><div class="line">  height: 25%;  /* == (160px + 30px + 30px) * .25 = 55px */</div><div class="line">  margin: 5%;   /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  padding: 5%;  /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk4.png" alt=""></p><h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  width: 300px;</div><div class="line">  height: 300px;</div><div class="line">  margin: 30px;</div><div class="line">  padding: 15px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: fixed;</div><div class="line">  width: 50%;   /* == (50vw - (width of vertical scrollbar)) */</div><div class="line">  height: 50%;  /* == (50vh - (height of horizontal scrollbar)) */</div><div class="line">  margin: 5%;   /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  padding: 5%;  /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk5.png" alt=""></p><p>如果本文对你有帮助，记得给我的博客项目<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="external">star</a>(⊙﹏⊙)，<a href="https://fanerge.github.io">顺便找找成都氛围好的前端团队，也许我就是你们要找的の</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指出错误观念&quot;&gt;&lt;a href=&quot;#指出错误观念&quot; class=&quot;headerlink&quot; title=&quot;指出错误观念&quot;&gt;&lt;/a&gt;指出错误观念&lt;/h1&gt;&lt;p&gt;许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！&lt;br&gt;一个元素的尺
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>全面了解Object对象</title>
    <link href="https://fanerge.github.io/2018/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Object%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://fanerge.github.io/2018/全面了解Object对象.html</id>
    <published>2018-03-20T12:36:46.000Z</published>
    <updated>2018-03-21T12:13:35.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么一切皆为对象"><a href="#为什么一切皆为对象" class="headerlink" title="为什么一切皆为对象"></a>为什么一切皆为对象</h1><p>‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一探究竟吧？<br>为了解决这个问题，我们的从javascript的原型链说起。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在js几乎任何对象有一个 [[prototype]] 属性，在标准中，这是一个隐藏属性。<br>虽然说 [[prototype]] 是一个隐藏属性，但很多浏览器都给每一个对象提供 __proto__ 这一属性，这个属性就是该对象的[[prototype]]。</p><blockquote><p>   Object.prototype 的 __proto__  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部 [[Prototype]] (一个对象或 null)。<br>使用 __proto__ 是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__ 属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 赞成Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf 来获取或设置对象的原型链。</p></blockquote><p>下面我们用标准的方法来获取对象的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 基本数据类型（Number,String,Boolean,Symbol）</div><div class="line">let str = &apos;strstr&apos;;</div><div class="line">// 1</div><div class="line">Object.getPrototypeOf(str) // String对象（这里包括字符串原型链上的所有方法如slice、indexOf等）</div><div class="line">// 2</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(str)) // Object对象</div><div class="line">// 3</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(str))) // null</div><div class="line">console.dir(Object.getPrototypeOf(str))</div><div class="line"></div><div class="line">// 其他类型（Object,Function,Array,Error,Math,Date,Map,Set,WeakMap,WeakSet,JSON）</div><div class="line">function demo() &#123;&#125;</div><div class="line">// 4</div><div class="line">Object.getPrototypeOf(demo) // anonymous函数</div><div class="line">// 5</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(demo)) // Object对象</div><div class="line">// 6</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(demo))) // null</div></pre></td></tr></table></figure></p><p>PS：博主分别以基本数据类型Number,String,Boolean,Symbol（这里不考虑undefined和null，因为它们是特殊的两个值，木有原型）做了测试，上面代码注释1,2,3最终到达原型链的顶端null。<br>对于其他类型也是同样的，通过4,5,6到达原型链顶端Object.prototype === null。<br>从上面可以整个javascript语法系统都是基于这个原型链来实现方法和属性的继承的，并且可以看到原型链是有终点的值为 null。</p><p>搞清楚了原型链，在回到‘一切皆为对象’。<br>明白了javascript的原型链，明白了所有的继承终点都到了Object上，就不难理解‘一切皆为对象’了吧。</p><h1 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 27,</div><div class="line">city: &apos;chengdu&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是大家最熟悉的创建方式。</p><h2 id="Object实例化"><a href="#Object实例化" class="headerlink" title="Object实例化"></a>Object实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let obj = new Object(&#123;</div><div class="line">// name: &apos;yzf&apos;,</div><div class="line">// age: 27,</div><div class="line">// city: &apos;chengdu&apos;</div><div class="line">&#125;);</div><div class="line">obj.name = &apos;yzf&apos;;</div><div class="line">obj.age = 27;</div><div class="line">obj.city = &apos;chengdu&apos;;</div></pre></td></tr></table></figure><p>这里两种方式，为obj赋值，一种在实例化是进行，一种在实例化之后添加。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, city)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.city = city;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let fanerge = new Person(&apos;yzf&apos;, 27, &apos;chengdu&apos;)</div></pre></td></tr></table></figure><h1 id="Object对象的方法"><a href="#Object对象的方法" class="headerlink" title="Object对象的方法"></a>Object对象的方法</h1><p>Object对象的方法分为Object静态方法和Object的实例方法，静态方法定义在Object自身上，而实例方法定义在Object.prototype上；<br>在使用方式上也有区别，静态方法使用’如Object.keys(obj)’而实例方法使用’如obj.hasOwnProperty(prop)’。<br>我认为我们学习API是需要重点了解一个API的使用方式、定义、参数说明、返回值，下面我给出Object标准库中的方法，其中有部分是ES6+的方法，存在一定的兼容性问题。</p><h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><h3 id="Object-assign-target-…sources"><a href="#Object-assign-target-…sources" class="headerlink" title="Object.assign(target, …sources)"></a>Object.assign(target, …sources)</h3><p>定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>参数：target为目标对象，sources为源对象。<br>返回：目标对象。</p><h3 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [propertiesObject])"></a>Object.create(proto, [propertiesObject])</h3><p>定义：创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>参数：proto为新创建对象的原型对象，propertiesObject为相关属性的描述符。<br>返回：新对象。</p><h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>定义：会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>参数：obj为要在其上定义属性的对象，prop为要定义或修改的属性的名称，descriptor为将被定义或修改的属性描述符。<br>返回：obj。</p><h3 id="Object-defineProperties-obj-props"><a href="#Object-defineProperties-obj-props" class="headerlink" title="Object.defineProperties(obj, props)"></a>Object.defineProperties(obj, props)</h3><p>定义：直接在一个对象上定义新的属性或修改现有属性，并返回该对象。<br>参数：obj为要在其上定义属性的对象，props为要定义或修改的一个或多个属性的描述符。<br>返回：obj。</p><h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><p>定义：返回一个由一个给定对象的自身可枚举属性组成的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个表示给定对象的所有可枚举属性的字符串数组。</p><h3 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个包含对象自身的所有可枚举属性值的数组。</p><h3 id="Object-values-obj-1"><a href="#Object-values-obj-1" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：给定对象自身可枚举属性的键值（键值对也为数组）对数组。</p><h3 id="Object-preventExtensions-obj"><a href="#Object-preventExtensions-obj" class="headerlink" title="Object.preventExtensions(obj)"></a>Object.preventExtensions(obj)</h3><p>定义：让一个对象变的不可扩展，也就是永远不能再添加新的属性。<br>参数：obj为将要变得不可扩展的对象。<br>返回：已经不可扩展的对象。<br>PS：该对象的属性可能仍然可删除，且对象的原型仍然可以添加属性。</p><h3 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h3><p>定义：判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否可扩展的一个Boolean 。</p><h3 id="Object-seal-obj"><a href="#Object-seal-obj" class="headerlink" title="Object.seal(obj)"></a>Object.seal(obj)</h3><p>定义：封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。<br>参数：obj为将要被密封的对象。<br>返回：被密封的对象。<br>PS：属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性（get）。</p><h3 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h3><p>定义：判断一个对象是否被密封。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被密封的一个Boolean。</p><h3 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h3><p>定义：可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。<br>参数：obj为要被冻结的对象。<br>返回：要被冻结的对象。</p><h3 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h3><p>定义：判断一个对象是否被冻结。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被冻结的Boolean。</p><h3 id="Object-getOwnPropertyDescriptor-obj-prop"><a href="#Object-getOwnPropertyDescriptor-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptor(obj, prop)"></a>Object.getOwnPropertyDescriptor(obj, prop)</h3><p>定义：返回指定对象上一个自有属性对应的属性描述符。<br>参数：obj为需要查找的目标对象，prop为目标对象内属性名称（String类型）。<br>返回：如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</p><h3 id="Object-getOwnPropertyDescriptors-obj"><a href="#Object-getOwnPropertyDescriptors-obj" class="headerlink" title="Object.getOwnPropertyDescriptors(obj)"></a>Object.getOwnPropertyDescriptors(obj)</h3><p>定义：用来获取一个对象的所有自身属性的描述符。<br>参数：obj为需要查找的目标对象。<br>返回：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p><h3 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>返回：在给定对象上找到的属性对应的字符串数组。</p><h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为要返回 Symbol 属性的对象。<br>返回：在给定对象自身上找到的所有 Symbol 属性的数组。</p><h3 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h3><p>定义：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或null。<br>参数：obj为要设置其原型的对象，prototype为该对象的新原型(一个对象 或 null)。<br>返回：返回obj对象。</p><h3 id="Object-getPrototypeOf-object"><a href="#Object-getPrototypeOf-object" class="headerlink" title="Object.getPrototypeOf(object)"></a>Object.getPrototypeOf(object)</h3><p>定义：返回指定对象的原型（内部[[Prototype]]属性的值）。<br>参数：要返回其原型的对象。<br>返回：给定对象的原型。如果没有继承属性，则返回null。</p><h3 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2);"></a>Object.is(value1, value2);</h3><p>定义：判断两个值是否是相同的值。<br>参数：value1为需要比较的第一个值，value2为需要比较的第二个值。<br>返回：表示两个参数是否相同的Boolean 。</p><h2 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>下面obj为Object的实例。</p><h3 id="obj-hasOwnProperty-prop"><a href="#obj-hasOwnProperty-prop" class="headerlink" title="obj.hasOwnProperty(prop)"></a>obj.hasOwnProperty(prop)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：prop为要检测的属性String或者Symbol。<br>返回：用来判断某个对象是否含有指定的属性的Boolean。</p><h3 id="prototypeObj-isPrototypeOf-obj"><a href="#prototypeObj-isPrototypeOf-obj" class="headerlink" title="prototypeObj.isPrototypeOf(obj)"></a>prototypeObj.isPrototypeOf(obj)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：obj为在该对象的原型链上搜寻。<br>返回：表示调用对象是否在另一个对象的原型链上的Boolean。</p><h3 id="obj-propertyIsEnumerable-prop"><a href="#obj-propertyIsEnumerable-prop" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个布尔值，表示指定的属性是否可枚举。<br>参数：prop为需要测试的属性名。<br>返回：用来表示指定的属性名是否可枚举的Boolean。</p><h3 id="obj-toLocaleString"><a href="#obj-toLocaleString" class="headerlink" title="obj.toLocaleString()"></a>obj.toLocaleString()</h3><p>定义：方法返回一个该对象的字符串表示。<br>返回：表示对象的字符串。</p><h3 id="obj-propertyIsEnumerable-prop-1"><a href="#obj-propertyIsEnumerable-prop-1" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个表示该对象的字符串。<br>返回：表示该对象的字符串。<br>PS：ES6之前经常这样用Object.prototype.toString.call(obj) === ‘[object Object]’ 来区别Object和Array。</p><h3 id="ob-valueOf"><a href="#ob-valueOf" class="headerlink" title="ob.valueOf()"></a>ob.valueOf()</h3><p>定义：返回指定对象的原始值。<br>返回：返回值为该对象的原始值。</p><h3 id="object-instanceof-constructor"><a href="#object-instanceof-constructor" class="headerlink" title="object instanceof constructor"></a>object instanceof constructor</h3><p>定义：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>参数：object为要检测的对象，constructor为某个构造函数。<br>返回：boolean值。[2018-03-21]</p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="external">MDN__proto__</a><br><a href="https://www.zhihu.com/question/34183746/answer/58068402" target="_blank" rel="external">__proto__和prototype的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Object</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么一切皆为对象&quot;&gt;&lt;a href=&quot;#为什么一切皆为对象&quot; class=&quot;headerlink&quot; title=&quot;为什么一切皆为对象&quot;&gt;&lt;/a&gt;为什么一切皆为对象&lt;/h1&gt;&lt;p&gt;‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript标准库总结</title>
    <link href="https://fanerge.github.io/2018/javascript%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/2018/javascript标准库总结.html</id>
    <published>2018-03-19T13:56:38.000Z</published>
    <updated>2018-04-04T12:47:12.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="值属性"><a href="#值属性" class="headerlink" title="值属性"></a>值属性</h1><p>这部分属性只是简单的值，它们没有自己的属性和方法。</p><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><pre><code>全局属性 Infinity 是一个数值，表示无穷大。</code></pre><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><pre><code>全局属性 NaN 的值表示不是一个数字（Not-A-Number）。</code></pre><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><pre><code>全局属性undefined表示原始值undefined。它是一个JavaScript的 原始数据类型 。</code></pre><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><pre><code>值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。</code></pre><h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。    </p><h3 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h3><pre><code>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。</code></pre><p>PS：eval会造成安全和性能方面的问题，具体参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval#Don.27t_use_eval.21" target="_blank" rel="external">避免在不必要的情况下使用 eval</a>。</p><h3 id="isFinite-arg"><a href="#isFinite-arg" class="headerlink" title="isFinite(arg)"></a>isFinite(arg)</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为有限值。</code></pre><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为NaN。</code></pre><p>PS：使用Number.isNaN()来代替更有语义性。</p><h3 id="parseFloat-str"><a href="#parseFloat-str" class="headerlink" title="parseFloat(str)"></a>parseFloat(str)</h3><pre><code>parseFloat() 函数解析一个字符串参数并返回一个浮点数。</code></pre><p>PS：如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略.<br>    如果第一个字符不能解析，直接返回NaN。</p><h3 id="parseInt-str-radix"><a href="#parseInt-str-radix" class="headerlink" title="parseInt(str, radix);"></a>parseInt(str, radix);</h3><pre><code>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</code></pre><p>PS：radix一个介于2和36之间的整数，表示上述字符串的基数（默认为10）。</p><h3 id="encodeURI-URI"><a href="#encodeURI-URI" class="headerlink" title="encodeURI(URI)"></a>encodeURI(URI)</h3><p>函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。<br>PS：encodeURI 字母、数字、;、,、/、?、:、@、&amp;、=、+、$、-、_、.、!、~、*、’、(、)、#、之外的所有字符。</p><h3 id="decodeURI-encodeURI"><a href="#decodeURI-encodeURI" class="headerlink" title="decodeURI(encodeURI)"></a>decodeURI(encodeURI)</h3><pre><code>decodeURI() 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。</code></pre><h3 id="encodeURIComponent-str"><a href="#encodeURIComponent-str" class="headerlink" title="encodeURIComponent(str)"></a>encodeURIComponent(str)</h3><pre><code>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。</code></pre><p>PS：encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。<br>    为了避免服务器收到不可预知的请求，对任何用户输入的作为URI部分的内容你都需要用encodeURIComponent进行转义。</p><h3 id="decodeURIComponent-encodedURI"><a href="#decodeURIComponent-encodedURI" class="headerlink" title="decodeURIComponent(encodedURI)"></a>decodeURIComponent(encodedURI)</h3><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><h3 id="encodeURI和encodeURIComponent的区别与使用场景"><a href="#encodeURI和encodeURIComponent的区别与使用场景" class="headerlink" title="encodeURI和encodeURIComponent的区别与使用场景"></a>encodeURI和encodeURIComponent的区别与使用场景</h3><pre><code>区别在于编码的字符范围不同。</code></pre><p>encodeURI使用于编码整个URI而encodeURIComponent主要query部分（当你需要编码URL中的参数）。<br><a href="https://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="external">简单明了区分escape、encodeURI和encodeURIComponent</a></p><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。</p><h2 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>定义：指明函数的形参个数（确定多少个必须要传入的参数）区别于arguments.length实参个数（确定函数被调用时的实际传参个数）。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>定义：返回创建实例对象的 Object 构造函数的引用。</p><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="func-apply-thisArg-argsArray"><a href="#func-apply-thisArg-argsArray" class="headerlink" title="func.apply(thisArg, [argsArray])"></a>func.apply(thisArg, [argsArray])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为func函数执行时this的指向，argsArray为类数组参数数组。<br>返回：调用有指定this值和参数的函数的结果。</p><h3 id="fun-call-thisArg-arg1-arg2-…"><a href="#fun-call-thisArg-arg1-arg2-…" class="headerlink" title="fun.call(thisArg, arg1, arg2, …)"></a>fun.call(thisArg, arg1, arg2, …)</h3><p>定义：调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。<br>参数：thisArg为func函数执行时this的指向，arg1, arg2, …为指定的参数列表。<br>返回：返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。<br>运用：1.使用call方法调用父构造函数（在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承）<br>  2.使用call方法调用匿名函数3.使用call方法调用函数并且指定上下文的’this’<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#示例" target="_blank" rel="external">运用举例</a></p><h3 id="fun-bind-thisArg-arg1-arg2-…"><a href="#fun-bind-thisArg-arg1-arg2-…" class="headerlink" title="fun.bind(thisArg[, arg1[, arg2[, …]]])"></a>fun.bind(thisArg[, arg1[, arg2[, …]]])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为当绑定函数被调用时，该参数会作为原函数运行时的 this 指向，arg1、arg2…为当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。<br>返回：由指定的this值和初始化参数改造的原函数拷贝（返回一个函数）。<br>运用：1.创建绑定函数（显式绑定this）2.偏函数（使一个函数拥有预设的初始参数）。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#示例" target="_blank" rel="external">运用举例</a></p><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>定义：返回一个表示当前函数源代码的字符串。<br>参数：null。<br>返回：表示函数源代码的一个字符串。</p><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。<br>Number()，如果参数无法被转换为数字，则返回 NaN。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>两个可表示(representable)数之间的最小间隔，在进行计算时误差在这个范围内被认为是合理的。</p><h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>JavaScript 中最大的安全整数 (2^53 - 1)。</p><h3 id="Number-MIN-SAFE-INTEGER"><a href="#Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MIN_SAFE_INTEGER"></a>Number.MIN_SAFE_INTEGER</h3><p>JavaScript 中最小的安全整数 (-(2^53 - 1)).</p><h3 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h3><p>能表示的最大正数。最小的负数是 -MAX_VALUE。</p><h3 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h3><p>能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。</p><h3 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h3><p>Not A Number.</p><h3 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h3><p>特殊的负无穷大值，在溢出时返回该值。</p><h3 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h3><p>特殊的正无穷大值，在溢出时返回改值。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>下列方法均不会发生将String转化为Number的过程。</p><h3 id="Number-isNaN-value"><a href="#Number-isNaN-value" class="headerlink" title="Number.isNaN(value)"></a>Number.isNaN(value)</h3><p>定义：确定传递的值是否为 NaN和其类型是 Number。它是用于代替原始的全局isNaN()。<br>参数：要被检测是否是 NaN 的值。<br>返回：一个布尔值，表示给定的值是否是 NaN。<br>PS：该方法不同于全局的isNaN()，不会将字符串转换为数字。</p><h3 id="Number-isFinite-value"><a href="#Number-isFinite-value" class="headerlink" title="Number.isFinite(value)"></a>Number.isFinite(value)</h3><p>定义：用来检测传入的参数是否是一个有穷数（finite number）。<br>参数：value要被检测有穷性的值。<br>返回：一个布尔值表示给定的值是否是一个有穷数。<br>PS：和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值。</p><h3 id="Number-isInteger-value"><a href="#Number-isInteger-value" class="headerlink" title="Number.isInteger(value)"></a>Number.isInteger(value)</h3><p>定义：用来判断给定的参数是否为整数。<br>参数：value要判断此参数是否为整数。<br>返回：判断给定值是否是整数的 Boolean 值。</p><h3 id="Number-isSafeInteger-testValue"><a href="#Number-isSafeInteger-testValue" class="headerlink" title="Number.isSafeInteger(testValue)"></a>Number.isSafeInteger(testValue)</h3><p>定义：用来判断传入的参数值是否是一个“安全整数”（safe integer）。<br>参数：testValue需要检测的参数。<br>返回：一个布尔值 表示给定的值是否是一个安全整数（safe integer）。</p><h3 id="Number-parseFloat-string"><a href="#Number-parseFloat-string" class="headerlink" title="Number.parseFloat(string)"></a>Number.parseFloat(string)</h3><p>定义：可以把一个字符串解析成浮点数。<br>参数：string被解析的字符串。<br>返回：对应的浮点数。<br>PS：与全局函数 parseFloat()一样。</p><h3 id="Number-parseInt-string-radix"><a href="#Number-parseInt-string-radix" class="headerlink" title="Number.parseInt(string[, radix])"></a>Number.parseInt(string[, radix])</h3><p>定义：可以根据给定的进制数的一个字符串数解析成整数。<br>参数：string要解析的值，radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>下列方法均返回为字符串。</p><h3 id="numObj-toExponential-fractionDigits"><a href="#numObj-toExponential-fractionDigits" class="headerlink" title="numObj.toExponential([fractionDigits])"></a>numObj.toExponential([fractionDigits])</h3><p>定义：以指数表示法返回该数值字符串表示形式。<br>参数：fractionDigits一个整数，用来指定小数点后有几位数字。<br>返回：一个用幂的形式 (科学记数法) 来表示Number 对象的字符串。</p><h3 id="numObj-toFixed-digits"><a href="#numObj-toFixed-digits" class="headerlink" title="numObj.toFixed(digits)"></a>numObj.toFixed(digits)</h3><p>定义：使用定点表示法来格式化一个数。<br>参数：digits小数点后数字的个数。<br>返回：所给数值的定点数表示法的字符串形式。</p><h3 id="numObj-toPrecision-precision"><a href="#numObj-toPrecision-precision" class="headerlink" title="numObj.toPrecision(precision)"></a>numObj.toPrecision(precision)</h3><p>定义：以指定的精度返回该数值对象的字符串表示。<br>参数：precision一个用来指定有效数个数的整数。<br>返回：以定点表示法或指数表示法表示的一个数值对象的字符串表示。</p><h3 id="numObj-toLocaleString-locales-options"><a href="#numObj-toLocaleString-locales-options" class="headerlink" title="numObj.toLocaleString([locales [, options]])"></a>numObj.toLocaleString([locales [, options]])</h3><p>定义：返回这个数字在特定语言环境下的表示字符串。<br>参数：locales为指定本地要使用的编号系统，options为有下列属性（localeMatcher、style、currency等等但存在一定的兼容性）<br>返回：返回一个语言环境下的表示字符串。<br>PS：通常用于格式化为某种货币形式。</p><h3 id="numObj-toString-radix"><a href="#numObj-toString-radix" class="headerlink" title="numObj.toString([radix])"></a>numObj.toString([radix])</h3><p>定义：返回指定 Number 对象的字符串表示形式。<br>参数：radix指定要用于数字到字符串的转换的基数(从2到36)。<br>返回：转换后的字符串。</p><h3 id="numObj-valueOf"><a href="#numObj-valueOf" class="headerlink" title="numObj.valueOf()"></a>numObj.valueOf()</h3><p>定义：返回一个被 Number 对象包装的原始值。<br>返回：表示指定 Number 对象的原始值的数字。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode-num1-…-numN"><a href="#String-fromCharCode-num1-…-numN" class="headerlink" title="String.fromCharCode(num1, …, numN)"></a>String.fromCharCode(num1, …, numN)</h3><p>定义：返回使用指定的Unicode值序列创建的字符串。</p><h3 id="String-fromCodePoint-num1-…-numN"><a href="#String-fromCodePoint-num1-…-numN" class="headerlink" title="String.fromCodePoint(num1[, …[, numN]])"></a>String.fromCodePoint(num1[, …[, numN]])</h3><p>定义：返回使用指定的代码点序列创建的字符串，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p><h3 id="String-raw-callSite-…substitutions-String-rawtemplateString"><a href="#String-raw-callSite-…substitutions-String-rawtemplateString" class="headerlink" title="String.raw(callSite, …substitutions) || String.rawtemplateString"></a>String.raw(callSite, …substitutions) || String.raw<code>templateString</code></h3><p>是用来获取一个模板字符串的原始字面量值的。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h3><p>返回：字符串的长度。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>返回：第N个字符串，但不能更改。</p><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="str-charAt-index"><a href="#str-charAt-index" class="headerlink" title="str.charAt(index)"></a>str.charAt(index)</h3><p>定义：从一个字符串中返回指定index的字符，缺省参数为0。</p><h3 id="str-charCodeAt-index"><a href="#str-charCodeAt-index" class="headerlink" title="str.charCodeAt(index)"></a>str.charCodeAt(index)</h3><p>定义：返回给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。</p><h3 id="str-codePointAt-index"><a href="#str-codePointAt-index" class="headerlink" title="str.codePointAt(index)"></a>str.codePointAt(index)</h3><p>定义：返回 一个 Unicode 编码点值的非负整数。</p><h3 id="str-concat-string2-string3-…-stringN"><a href="#str-concat-string2-string3-…-stringN" class="headerlink" title="str.concat(string2, string3[, …, stringN])"></a>str.concat(string2, string3[, …, stringN])</h3><p>定义：将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p><h3 id="str-includes-searchString-index"><a href="#str-includes-searchString-index" class="headerlink" title="str.includes(searchString[, index])"></a>str.includes(searchString[, index])</h3><p>定义：判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。</p><h3 id="str-startsWith-searchString-index"><a href="#str-startsWith-searchString-index" class="headerlink" title="str.startsWith(searchString [, index])"></a>str.startsWith(searchString [, index])</h3><p>定义：用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。</p><h3 id="str-endsWith-searchString-index"><a href="#str-endsWith-searchString-index" class="headerlink" title="str.endsWith(searchString [, index]);"></a>str.endsWith(searchString [, index]);</h3><p>定义：判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p><h3 id="str-indexOf-searchValue-index"><a href="#str-indexOf-searchValue-index" class="headerlink" title="str.indexOf(searchValue[, index])"></a>str.indexOf(searchValue[, index])</h3><p>定义：第一次出现的指定值的索引，开始在Index进行搜索，否则返回-1。</p><h3 id="str-lastIndexOf-searchValue-index"><a href="#str-lastIndexOf-searchValue-index" class="headerlink" title="str.lastIndexOf(searchValue[, index])"></a>str.lastIndexOf(searchValue[, index])</h3><p>定义：返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</p><h3 id="str-localeCompare-compareString-locales-options"><a href="#str-localeCompare-compareString-locales-options" class="headerlink" title="str.localeCompare(compareString[, locales[, options]])"></a>str.localeCompare(compareString[, locales[, options]])</h3><p>定义：localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。</p><h3 id="str-match-regexp"><a href="#str-match-regexp" class="headerlink" title="str.match(regexp);"></a>str.match(regexp);</h3><p>定义：当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。</p><h3 id="str-normalize-form"><a href="#str-normalize-form" class="headerlink" title="str.normalize([form]);"></a>str.normalize([form]);</h3><p>定义：会按照指定的一种 Unicode 正规形式将当前字符串正规化。</p><h3 id="str-padStart-targetLength-padString"><a href="#str-padStart-targetLength-padString" class="headerlink" title="str.padStart(targetLength [, padString])"></a>str.padStart(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之前（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p><h3 id="str-padEnd-targetLength-padString"><a href="#str-padEnd-targetLength-padString" class="headerlink" title="str.padEnd(targetLength [, padString])"></a>str.padEnd(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之后（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p><h3 id="str-repeat-count"><a href="#str-repeat-count" class="headerlink" title="str.repeat(count);"></a>str.repeat(count);</h3><p>定义：返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。<br>PS：参数从零开始。</p><h3 id="str-replace-regexp-substr-newSubStr-function"><a href="#str-replace-regexp-substr-newSubStr-function" class="headerlink" title="str.replace(regexp|substr, newSubStr|function)"></a>str.replace(regexp|substr, newSubStr|function)</h3><p>定义：返回一个由替换值替换一些或所有匹配的模式后的新字符串。<br>如果第一个参数为regexp第二个参数为function时，该函数参数说明<br>参数1：匹配模式的字符串。<br>参数2–：子表达是匹配的子字符串（就是捕获分组）。<br>倒数参数2：声明匹配在string中出现的位置。<br>倒数参数1：进行匹配的sting本身。</p><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>定义：行正则表达式和 String对象之间的一个搜索匹配。<br>返回：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p><h3 id="str-slice-beginSlice-endSlice"><a href="#str-slice-beginSlice-endSlice" class="headerlink" title="str.slice(beginSlice[, endSlice])"></a>str.slice(beginSlice[, endSlice])</h3><p>定义：提取一个字符串的一部分，并返回一新的字符串。<br>参数：beginSlice从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度。<br>endSlice在该索引（以 0 为基数）处结束提取字符串，同样可为负数。</p><h3 id="str-split-separator-limit"><a href="#str-split-separator-limit" class="headerlink" title="str.split([separator[, limit]])"></a>str.split([separator[, limit]])</h3><p>定义：使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 </p><h3 id="str-substr-start-length"><a href="#str-substr-start-length" class="headerlink" title="str.substr(start[, length])"></a>str.substr(start[, length])</h3><p>定义：返回一个字符串中从指定位置开始到指定字符数的字符。<br>PS：start &gt;=str.length 或 length &lt;= 0 返回空字符串;start &lt; 0 则转换为start + str.length。</p><h3 id="str-substring-indexStart-indexEnd"><a href="#str-substring-indexStart-indexEnd" class="headerlink" title="str.substring(indexStart[, indexEnd])"></a>str.substring(indexStart[, indexEnd])</h3><p>定义：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。<br>PS：一些特殊情况。<br>如果 indexStart 等于 indexEnd，substring 返回一个空字符串。<br>如果省略 indexEnd，substring 提取字符一直到字符串末尾。<br>如果任一参数小于 0 或为 NaN，则被当作 0。<br>如果任一参数大于 stringName.length，则被当作 stringName.length。<br>如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。</p><h3 id="str-toLowerCase"><a href="#str-toLowerCase" class="headerlink" title="str.toLowerCase()"></a>str.toLowerCase()</h3><p>定义：将调用该方法的字符串值转为小写形式，并返回新字符串。</p><h3 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h3><p>定义：将调用该方法的字符串值转换为大写形式，并返回新字符串。</p><h3 id="str-toLocaleLowerCase"><a href="#str-toLocaleLowerCase" class="headerlink" title="str.toLocaleLowerCase()"></a>str.toLocaleLowerCase()</h3><p>定义：根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。<br>PS：在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同（除土耳其等）。</p><h3 id="str-toLocaleUpperCase"><a href="#str-toLocaleUpperCase" class="headerlink" title="str.toLocaleUpperCase()"></a>str.toLocaleUpperCase()</h3><p>定义：使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。</p><h3 id="str-toString"><a href="#str-toString" class="headerlink" title="str.toString()"></a>str.toString()</h3><p>定义：返回指定对象的字符串形式。</p><h3 id="str-trim"><a href="#str-trim" class="headerlink" title="str.trim()"></a>str.trim()</h3><p>定义：会从一个字符串的两端删除空白字符，返回一个新的字符串。<br>PS：str.trimLeft() 和 str.trimRight() 不是标准方法。</p><h3 id="string-Symbol-iterator"><a href="#string-Symbol-iterator" class="headerlink" title="string[Symbol.iterator]"></a>string[Symbol.iterator]</h3><p>返回一个新的Iterator对象，它遍历字符串的代码点，返回每一个代码点的字符串值。<br>PS：下列内置类型拥有默认迭代器行为Array、String、Set、Map等，而Object没有。</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><p>在 ES2015 中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。</p><h3 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike[, mapFn[, thisArg]])"></a>Array.from(arrayLike[, mapFn[, thisArg]])</h3><p>定义：从一个类似数组或可迭代对象中创建一个新的数组实例。<br>参数：<br>  arrayLike想要转换成数组的伪数组对象或可迭代对象。<br>  mapFn (可选参数)如果指定了该参数，新数组中的每个元素会执行该回调函数。<br>  thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。<br>返回：一个新的数组。<br>PS：Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg)，ES6之前的做法：Array.prototype.slice.call(arrayLike)。</p><h3 id="Array-isArray-obj"><a href="#Array-isArray-obj" class="headerlink" title="Array.isArray(obj)"></a>Array.isArray(obj)</h3><p>定义：确定传递的值是否是一个 Array。<br>返回：boolean。<br>PS：ES6之前的做法Object.prototype.toString.call(arg) === ‘[object Array]’。</p><h3 id="Array-of-element0-element1-…-elementN"><a href="#Array-of-element0-element1-…-elementN" class="headerlink" title="Array.of(element0[, element1[, …[, elementN]]])"></a>Array.of(element0[, element1[, …[, elementN]]])</h3><p>定义：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。<br>参数：任意个参数，将按顺序成为返回数组中的元素。<br>返回：参数列表组成的数组。<br>PS：Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。</p><h2 id="实例方法及属性"><a href="#实例方法及属性" class="headerlink" title="实例方法及属性"></a>实例方法及属性</h2><h3 id="ary-length"><a href="#ary-length" class="headerlink" title="ary.length"></a>ary.length</h3><p>返回：读写数组的长度。</p><h3 id="修改器方法（改变原数组）"><a href="#修改器方法（改变原数组）" class="headerlink" title="修改器方法（改变原数组）"></a>修改器方法（改变原数组）</h3><h4 id="arr-copyWithin-target-start-end"><a href="#arr-copyWithin-target-start-end" class="headerlink" title="arr.copyWithin(target[, start[, end]])"></a>arr.copyWithin(target[, start[, end]])</h4><p>定义：浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。<br>参数：<br>target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。<br>start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。<br>end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。<br>返回值：操作原数组。</p><h4 id="arr-fill-value-start-end"><a href="#arr-fill-value-start-end" class="headerlink" title="arr.fill(value[, start[, end]])"></a>arr.fill(value[, start[, end]])</h4><p>定义：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。<br>参数：<br>  value 用来填充数组元素的值。<br>  start 开始索引，默认为0。<br>  end 结束索引，默认为arr.length（不包括）。<br>返回：修改后的数组。</p><h4 id="arr-push-element1-…-elementN"><a href="#arr-push-element1-…-elementN" class="headerlink" title="arr.push(element1, …, elementN)"></a>arr.push(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br>参数：<br>  elementN 被添加到数组末尾的元素。<br>返回：操作后的数组的长度。</p><h4 id="arr-pop"><a href="#arr-pop" class="headerlink" title="arr.pop()"></a>arr.pop()</h4><p>定义：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素(当数组为空时返回undefined)。</p><h4 id="arr-reverse"><a href="#arr-reverse" class="headerlink" title="arr.reverse()"></a>arr.reverse()</h4><p>定义：将数组中元素的位置颠倒。<br>返回：颠倒数组中元素的位置，并返回该数组的引用。</p><h4 id="arr-sort-compareFunction"><a href="#arr-sort-compareFunction" class="headerlink" title="arr.sort(compareFunction)"></a>arr.sort(compareFunction)</h4><p>定义：可以根据指定方法对数组进行排序。<br>compareFunction 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>返回：返回排序后的数组。原数组已经被排序后的数组代替。</p><h4 id="arr-shift"><a href="#arr-shift" class="headerlink" title="arr.shift()"></a>arr.shift()</h4><p>定义：从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素; 如果数组为空则返回undefined。 </p><h4 id="arr-unshift-element1-…-elementN"><a href="#arr-unshift-element1-…-elementN" class="headerlink" title="arr.unshift(element1, …, elementN)"></a>arr.unshift(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br>参数：element1, …, elementN 要添加到数组开头的元素。<br>返回：当一个对象调用该方法时，返回其 length 属性值。</p><h4 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start, [deleteCount], [item1], [item2], …)"></a>array.splice(start, [deleteCount], [item1], [item2], …)</h4><p>定义：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br>参数：<br>  start 开始修改的位置。<br>  deleteCount 移除数组元素的个数。<br>  item1、item2…为添加的元素。<br>返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p><h3 id="访问方法（不直接操作原理的数组）"><a href="#访问方法（不直接操作原理的数组）" class="headerlink" title="访问方法（不直接操作原理的数组）"></a>访问方法（不直接操作原理的数组）</h3><h4 id="old-array-concat-value1-value2-…-valueN"><a href="#old-array-concat-value1-value2-…-valueN" class="headerlink" title="old_array.concat(value1[, value2[, …[, valueN]]])"></a>old_array.concat(value1[, value2[, …[, valueN]]])</h4><p>定义：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br>参数：valueN 将数组和/或值连接成新数组。<br>返回：新数组。</p><h4 id="arr-includes-searchElement-fromIndex"><a href="#arr-includes-searchElement-fromIndex" class="headerlink" title="arr.includes(searchElement, [fromIndex])"></a>arr.includes(searchElement, [fromIndex])</h4><p>定义：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：boolean。</p><h4 id="arr-join-separator"><a href="#arr-join-separator" class="headerlink" title="arr.join([separator])"></a>arr.join([separator])</h4><p>定义：将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：string。</p><h4 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin], [end])"></a>arr.slice([begin], [end])</h4><p>定义：返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。<br>返回：一个含有提取元素的新数组。</p><h4 id="arr-indexOf-searchElement-fromIndex-0"><a href="#arr-indexOf-searchElement-fromIndex-0" class="headerlink" title="arr.indexOf(searchElement[, fromIndex = 0])"></a>arr.indexOf(searchElement[, fromIndex = 0])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。</p><h4 id="arr-lastIndexOf-searchElement-fromIndex-arr-length-1"><a href="#arr-lastIndexOf-searchElement-fromIndex-arr-length-1" class="headerlink" title="arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])"></a>arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：数组中最后一个元素的索引，如未找到返回-1。</p><h4 id="arr-toString"><a href="#arr-toString" class="headerlink" title="arr.toString()"></a>arr.toString()</h4><p>定义：返回一个字符串，表示指定的数组及其元素。<br>返回：逗号分隔的字符串。</p><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="array-forEach-callback-currentValue-index-array-do-something-this"><a href="#array-forEach-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.forEach(callback(currentValue, index, array){ //do something}, this)"></a>array.forEach(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：对数组的每个元素执行一次提供的函数。<br>返回：undefined。<br>PS：没有办法中止或者跳出 forEach 循环，需要跳出请使用循环代替。<br>已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不会跳过那些值为 undefined、null 的项）。</p><h4 id="array-map-callback-currentValue-index-array-do-something-this"><a href="#array-map-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.map(callback(currentValue, index, array){ //do something}, this)"></a>array.map(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>返回：一个新数组，每个元素都是回调函数的结果。</p><h4 id="arr-keys"><a href="#arr-keys" class="headerlink" title="arr.keys()"></a>arr.keys()</h4><p>定义：返回一个新的Array迭代器，它包含数组中每个索引的键。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-values"><a href="#arr-values" class="headerlink" title="arr.values()"></a>arr.values()</h4><p>定义：返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-entries"><a href="#arr-entries" class="headerlink" title="arr.entries()"></a>arr.entries()</h4><p>定义：返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-every-callback-thisArg"><a href="#arr-every-callback-thisArg" class="headerlink" title="arr.every(callback[, thisArg])"></a>arr.every(callback[, thisArg])</h4><p>定义：测试数组的所有元素是否都通过了指定函数的测试。<br>返回：boolean。</p><h4 id="arr-some-callback-thisArg"><a href="#arr-some-callback-thisArg" class="headerlink" title="arr.some(callback[, thisArg])"></a>arr.some(callback[, thisArg])</h4><p>定义：测试数组中的某些元素是否通过由提供的函数实现的测试。<br>返回：boolean。</p><h4 id="arr-filter-callback-thisArg"><a href="#arr-filter-callback-thisArg" class="headerlink" title="arr.filter(callback[, thisArg])"></a>arr.filter(callback[, thisArg])</h4><p>定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br>返回：新数组。</p><h4 id="arr-findIndex-callback-thisArg"><a href="#arr-findIndex-callback-thisArg" class="headerlink" title="arr.findIndex(callback[, thisArg])"></a>arr.findIndex(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值的索引，否则返回 -1。</p><h4 id="arr-find-callback-thisArg"><a href="#arr-find-callback-thisArg" class="headerlink" title="arr.find(callback[, thisArg])"></a>arr.find(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。</p><h4 id="arr-reduce-callback-initialValue"><a href="#arr-reduce-callback-initialValue" class="headerlink" title="arr.reduce(callback[, initialValue])"></a>arr.reduce(callback[, initialValue])</h4><p>定义：对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<br>参数：<br>  callback 执行数组中每个值的函数，包含四个参数：<br>    accumulato 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br>    currentValue 数组中正在处理的元素。<br>    currentIndex可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。<br>    array可选 调用reduce的数组。<br>  initialValue 可选用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br>返回：函数累计处理的结果。</p><h4 id="arr-reduceRight-callback-initialValue"><a href="#arr-reduceRight-callback-initialValue" class="headerlink" title="arr.reduceRight(callback[, initialValue])"></a>arr.reduceRight(callback[, initialValue])</h4><p>定义：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。</p><h4 id="arrSymbol-iterator"><a href="#arrSymbol-iterator" class="headerlink" title="arrSymbol.iterator"></a>arr<a href="">Symbol.iterator</a></h4><p>定义：默认为数组不说了迭代器，@@iterator 属性和 values() 属性的初始值均为同一个函数对象。<br>返回：数组的 iterator 方法，默认情况下与 values() 返回值相同。</p><h4 id="arr-flatten-depth"><a href="#arr-flatten-depth" class="headerlink" title="arr.flatten(depth)"></a>arr.flatten(depth)</h4><p>定义：会递归到指定深度将所有子数组连接，并返回一个新数组。<br>参数：depth 可选指定嵌套数组中的结构深度，默认值为1。<br>返回：一个将子数组连接的新数组。</p><h4 id="arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg"><a href="#arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg" class="headerlink" title="arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])"></a>arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])</h4><p>定义：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flatten 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。<br>返回：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</p><h1 id="Proxy-amp-amp-Reflect"><a href="#Proxy-amp-amp-Reflect" class="headerlink" title="Proxy &amp;&amp; Reflect"></a>Proxy &amp;&amp; Reflect</h1><p>Proxy是一个构造函数（对对象的访问进行拦截），Reflect（操作对象提供的API）。<br>Reflect它与Proxy对象的方法是一一对应的，这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Proxy方法：target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">var person = &#123;</div><div class="line">  name: &quot;张三&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var proxy = new Proxy(person, &#123;</div><div class="line">  get: function(target, property) &#123;</div><div class="line">    if (property in target) &#123;</div><div class="line">      return target[property];</div><div class="line">    &#125; else &#123;</div><div class="line">      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">proxy.name // &quot;张三&quot;</div><div class="line">proxy.age // 抛出一个错误</div></pre></td></tr></table></figure></p><p><a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" target="_blank" rel="external">Proxy使用详解</a></p><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。<br>// 下列方法说明：target为目标对象，name为某个属性，receiver为如果name属性设置了赋值函数，则为函数的this指向<br>Reflect.apply(target, thisArg, args)<br>  Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。<br>Reflect.construct(target, args)<br>  Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。<br>Reflect.get(target, name, receiver)<br>  Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>Reflect.set(target, name, value, receiver)<br>  Reflect.set方法设置target对象的name属性等于value。<br>Reflect.defineProperty(target, name, desc)<br>  Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。<br>Reflect.deleteProperty(target, name)<br>  Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。<br>Reflect.has(target, name)<br>  Reflect.has方法对应name in obj里面的in运算符。<br>Reflect.ownKeys(target)<br>  Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。<br>Reflect.isExtensible(target)<br>  Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。<br>Reflect.preventExtensions(target)<br>  Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。<br>Reflect.getOwnPropertyDescriptor(target, name)<br>  Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。<br>Reflect.getPrototypeOf(target)<br>  Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。<br>Reflect.setPrototypeOf(target, prototype)<br>  Reflect.setPrototypeOf方法用于设置对象的<strong>proto</strong>属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。</p><h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>Event接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="bubbles（只读）"><a href="#bubbles（只读）" class="headerlink" title="bubbles（只读）"></a>bubbles（只读）</h3><p>定义：用来表示该事件是否在DOM中冒泡的boolean值。</p><h3 id="cancelBubble（废弃）"><a href="#cancelBubble（废弃）" class="headerlink" title="cancelBubble（废弃）"></a>cancelBubble（废弃）</h3><p>定义：获取或设置当前事件是否要取消冒泡（使用e.stopPropagation()代替）。</p><h3 id="cancelable（只读）"><a href="#cancelable（只读）" class="headerlink" title="cancelable（只读）"></a>cancelable（只读）</h3><p>定义：表示这个事件是否可以取消默认行为（阻止默认行为e.preventDefault()）。</p><h3 id="composed（只读）"><a href="#composed（只读）" class="headerlink" title="composed（只读）"></a>composed（只读）</h3><p>定义：表示该事件是否可以Shadow DOM 传递到一般的 DOM。</p><h3 id="currentTarget（只读）"><a href="#currentTarget（只读）" class="headerlink" title="currentTarget（只读）"></a>currentTarget（只读）</h3><p>定义：当前注册事件的对象的引用，这个值会在传递途中发生变化。</p><h3 id="deepPath"><a href="#deepPath" class="headerlink" title="deepPath"></a>deepPath</h3><p>定义：返回事件冒泡过程所有经过的节点所构成的Array数组。</p><h3 id="defaultPrevented（只读）"><a href="#defaultPrevented（只读）" class="headerlink" title="defaultPrevented（只读）"></a>defaultPrevented（只读）</h3><p>定义：返回是否已经调用了e.preventDefault()来阻止默认行为。</p><h3 id="eventPhase（只读）"><a href="#eventPhase（只读）" class="headerlink" title="eventPhase（只读）"></a>eventPhase（只读）</h3><p>定义：返回事件流正在哪个阶段。</p><h3 id="returnValue（废弃）"><a href="#returnValue（废弃）" class="headerlink" title="returnValue（废弃）"></a>returnValue（废弃）</h3><p>定义：获取或设置事件的默认操作是否已被阻止。</p><h3 id="target（只读）"><a href="#target（只读）" class="headerlink" title="target（只读）"></a>target（只读）</h3><p>定义：返回一个触发事件的对象的引用（ie的srcElement）。</p><h3 id="timeStamp（只读）"><a href="#timeStamp（只读）" class="headerlink" title="timeStamp（只读）"></a>timeStamp（只读）</h3><p>定义：事件创建时的时间戳，毫秒级别。</p><h3 id="type（只读）"><a href="#type（只读）" class="headerlink" title="type（只读）"></a>type（只读）</h3><p>定义：返回一个字符串（不区分大小写）, 表示该事件对象的事件类型。</p><h3 id="isTrusted（只读）"><a href="#isTrusted（只读）" class="headerlink" title="isTrusted（只读）"></a>isTrusted（只读）</h3><p>定义：指明事件是否是由浏览器（当用户点击实例后）或者由脚本（使用事件的创建方法，例如event.initEvent）启动。</p><h3 id="target与currentTarget的区别"><a href="#target与currentTarget的区别" class="headerlink" title="target与currentTarget的区别"></a>target与currentTarget的区别</h3><p>event.target返回触发事件的元素<br>event.currentTarget返回绑定事件的元素<br><a href="https://www.cnblogs.com/yewenxiang/p/6171411.html" target="_blank" rel="external">event对象中 target和currentTarget 属性的区别</a></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="document-createEvent-“UIEvents”"><a href="#document-createEvent-“UIEvents”" class="headerlink" title="document.createEvent(“UIEvents”)"></a>document.createEvent(“UIEvents”)</h3><p>创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化。</p><h3 id="event-initEvent-type-bubbles-cancelable"><a href="#event-initEvent-type-bubbles-cancelable" class="headerlink" title="event.initEvent(type, bubbles, cancelable)"></a>event.initEvent(type, bubbles, cancelable)</h3><p>定义：Event.initEvent() 方法可以用来初始化由Document.createEvent() 创建的 event 实例，且在触发之前event.dispatchEvent()。</p><h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h3><p>定义：如果此事件没有需要显式处理，那么它默认的动作也不要做（因为默认是要做的）。</p><h3 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation()"></a>event.stopPropagation()</h3><p>定义：阻止捕获和冒泡阶段中当前事件的进一步传播（只阻止当前侦听器）。</p><h3 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h3><p>定义：阻止调用相同事件的其他侦听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;值属性&quot;&gt;&lt;a href=&quot;#值属性&quot; class=&quot;headerlink&quot; title=&quot;值属性&quot;&gt;&lt;/a&gt;值属性&lt;/h1&gt;&lt;p&gt;这部分属性只是简单的值，它们没有自己的属性和方法。&lt;/p&gt;
&lt;h3 id=&quot;Infinity&quot;&gt;&lt;a href=&quot;#Infinity
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从对象的遍历到浅拷贝的思考</title>
    <link href="https://fanerge.github.io/2017/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E5%88%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%80%9D%E8%80%83.html"/>
    <id>https://fanerge.github.io/2017/从对象的遍历到浅拷贝的思考.html</id>
    <published>2018-03-14T12:17:36.000Z</published>
    <updated>2018-03-16T14:00:15.496Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有<span style="color: red;">String</span>类型，ES6之后对象的属性有<span style="color: red;">String和Symbol类型</span>。<br>由于文章上下文关系，本文将按照’属性描述符’-&gt;’对象的属性遍历方法介绍’-&gt;’现代ECMAScript对象的浅拷贝’进行介绍，现代ECMAScript对象的深拷贝比较复杂，有时间在分析。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。</p><h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p><h2 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</p><h2 id="属性描述符的读写操作"><a href="#属性描述符的读写操作" class="headerlink" title="属性描述符的读写操作"></a>属性描述符的读写操作</h2><p>我们可以通过Object.getOwnPropertyDescriptor(o,name)、Object.getOwnPropertyDescriptors(obj)来查看属性描述符，<br>通过Object.defineProperty(o,name,desc)、Object.defineProperties(o,descriptors)、Object.create(proto,descriptors)等方法来更改属性描述符。</p><h1 id="对象的属性遍历方法介绍"><a href="#对象的属性遍历方法介绍" class="headerlink" title="对象的属性遍历方法介绍"></a>对象的属性遍历方法介绍</h1><p>上面，我们了解了属性描述符，其中枚举这个属性描述符，在不同方法对对象属性的遍历过程产生的作用差异很大，下面我开始介绍如何遍历对象的属性。<br><strong>本小结的测试代码，我就不贴出来了，都很简单，我这里直接给出结论，感兴趣的朋友可以自己尝试。</strong></p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>定义：for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item in object) &#123;...&#125;</div><div class="line">// itme--在每次迭代时，将不同的属性名分配给变量。</div><div class="line">// object--被迭代枚举其属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.可以遍历对象自身和原型链上可枚举的属性<br>2.任意顺序，说明遍历的属性先后顺序不定（不同运行环境顺序不同）。不建议对数组使用for…in来遍历主要原因就是这个，另一方面为性能考虑for…in还会遍历到原型链上的可枚举属性。</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>定义：Object.keys() 方法会返回一个由该对象的自身的可枚举属性组成的数组。</p><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.keys(obj)</div><div class="line">// obj--要返回其枚举自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性是可枚举的<br>3.任意顺序，枚举属性的顺序和for…in/Object.getOwnPropertyNames(obj)一致<br>4.返回一个所有元素为字符串（不包括Symbol）的数组</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>定义：Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyNames(obj)</div><div class="line">// obj--一个对象，其自身的可枚举和不可枚举属性的名称被返回。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性了枚举和不可枚举都可以遍历<br>3.任意顺序，枚举属性的顺序和for…in/Object.keys(obj)一致</p><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>定义：Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertySymbols(obj)</div><div class="line">// obj--要返回 Symbol 属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性为Symbol类型</p><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><p>定义：Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Reflect.ownKeys(target)</div><div class="line">// target--获取自身属性键的目标对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>这里看，似乎能遍历出自身的所有属性，还差原型连上的属性。</p><h2 id="总结下上面的方法"><a href="#总结下上面的方法" class="headerlink" title="总结下上面的方法"></a>总结下上面的方法</h2><p>为了好归纳，我这里将对象的属性分为以下类别：1.自身可枚举的属性，2.自身不可枚举的属性，3.Symbol类型的属性，4.原型链上的可枚举属性，5.原型链上的不可枚举属性，6.原型链上的Symbol属性<strong>2018-03-16更新</strong></p><table><thead><tr><th>方法</th><th style="text-align:center">可遍历的属性类别</th></tr></thead><tbody><tr><td>for…in</td><td style="text-align:center">1，4</td></tr><tr><td>Object.keys()</td><td style="text-align:center">1</td></tr><tr><td>Object.getOwnPropertyNames()</td><td style="text-align:center">1，2</td></tr><tr><td>Object.getOwnPropertySymbols()</td><td style="text-align:center">3</td></tr><tr><td>Reflect.ownKeys()</td><td style="text-align:center">1，2，3</td></tr></tbody></table><p>从上表分析，还没有一个方法能完美解决，我们只能组合使用了。<br>PS：除了for…in其余方法均返回数组。</p><h1 id="现代ECMAScript对象的浅拷贝"><a href="#现代ECMAScript对象的浅拷贝" class="headerlink" title="现代ECMAScript对象的浅拷贝"></a>现代ECMAScript对象的浅拷贝</h1><p>本小节会我们会实现各种浅拷贝，并分析各自的劣势，最终我们将实现一种比较完美的方法（暂不考虑兼容性）。</p><h2 id="现看一个以前实现的方法"><a href="#现看一个以前实现的方法" class="headerlink" title="现看一个以前实现的方法"></a>现看一个以前实现的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function shallowCopy (obj) &#123;</div><div class="line">  if (typeof obj !== &apos;object&apos;) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  var newObj = obj instanceof Array ? [] : &#123;&#125;</div><div class="line">  for (var key in obj) &#123;</div><div class="line">    if (obj.hasOwnProperty(key)) &#123;</div><div class="line">      newObj[key] = obj[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return newObj</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这中方法对于ES6之前的确可行，毕竟我也用过这样的方法，有了Symbol之后这个就不再正确了。</p><h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><blockquote><p>   该方式在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。<br>不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的 对象 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们</p></blockquote><h2 id="Object-assign-和-展开运算符（…）"><a href="#Object-assign-和-展开运算符（…）" class="headerlink" title="Object.assign 和 展开运算符（…）"></a>Object.assign 和 展开运算符（…）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj2 = Object.assign(&#123;&#125;, obj)</div><div class="line">// obj2</div><div class="line">&#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个函数的定义：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>特点：自身的可枚举的包括Symbol类型的，不包括不可枚举的属性和原型链上的属性，不完美。</p><h2 id="Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors"><a href="#Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors" class="headerlink" title="Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()"></a>Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()</h2><p>首先需要介绍一下相关的方法，ES7的Object.getOwnPropertyDescriptors()。</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>定义：Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// 需要获取自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>4.包括了集体属性的描述符（value）<br>到这里似乎我们已经找到了，比较完美的解决方案了，我们来组合一下这3个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// obj为需要浅拷贝的对象</div><div class="line">let obj1 = Object.create(</div><div class="line">  Object.getPrototypeOf(obj), </div><div class="line">  Object.getOwnPropertyDescriptors(obj) </div><div class="line">)</div><div class="line">// obj1就是我们浅拷贝的得到的对象。</div></pre></td></tr></table></figure></p><p>PS：obj1对象通过Object.create()方法指定了自身的原型链（从原型链继承了相关属性），然后在通过Object.getOwnPropertyDescriptors()方法把自身的（包括可枚举的、不可枚举的、Symbol类型的）全部添加obj1上，这样是实现了我们的真正意义上的浅拷贝。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>数组的浅拷贝ary.slice()、 ary.concat()、[…ary]、JSON.parse(JSON.stringify(ary))<br><a href="https://fanerge.github.io/">期望加入一个技术氛围nice的团队-成都</a></p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="external">Object.getOwnPropertySymbols</a><br><a href="https://github.com/Alvin-Liu/Blog/issues/8" target="_blank" rel="external">ES6时代，你真的会克隆对象吗？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有&lt;span style=&quot;color: red;&quot;&gt;String&lt;/span&gt;类型，ES6之后对象的属性有&lt;span
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>梳理下浏览器对象模型知识（BOM）</title>
    <link href="https://fanerge.github.io/2018/%E6%A2%B3%E7%90%86%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%EF%BC%88BOM%EF%BC%89.html"/>
    <id>https://fanerge.github.io/2018/梳理下浏览器对象模型知识（BOM）.html</id>
    <published>2018-03-12T12:41:17.000Z</published>
    <updated>2018-03-16T14:03:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。</p><h1 id="BOM介绍"><a href="#BOM介绍" class="headerlink" title="BOM介绍"></a>BOM介绍</h1><p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。<br>浏览器对象模型的构成<br><img src="http://p5hb0ypha.bkt.clouddn.com/BOM.svg" alt="浏览器对象模型的构成"></p><h1 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h1><p>Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。<br>在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。</p><h2 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" alt="Window对象的属性"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" target="_blank" rel="external">看不清，点这里</a></p><h2 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" alt="Window对象的方法"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h1><p>Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。<br>Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。<br><img src="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" alt="Location对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h1><p>History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。<br><img src="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" alt="History对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h1><p>Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。<br><img src="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" alt="Navigator对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h1><p>Screen 对象包含有关用户屏幕的信息。<br><img src="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" alt="Screen对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h1><p>Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。<br><img src="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" alt="document对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。&lt;/p&gt;
&lt;h1 id=&quot;BOM介绍&quot;&gt;&lt;a href=&quot;#BOM介绍&quot; class=&quot;head
      
    
    </summary>
    
      <category term="BOM" scheme="https://fanerge.github.io/categories/BOM/"/>
    
    
      <category term="BOM" scheme="https://fanerge.github.io/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj2</title>
    <link href="https://fanerge.github.io/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj2.html"/>
    <id>https://fanerge.github.io/2018/前端常识-gj2.html</id>
    <published>2018-03-11T12:19:13.000Z</published>
    <updated>2018-03-11T13:08:28.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h1><ol><li>在浏览器地址栏输入URL</li><li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control<br>  HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期<br>  HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间    </li><li>浏览器解析URL获取协议，主机，端口，path    </li><li>浏览器组装一个HTTP（GET）请求报文    </li><li>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存<br>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li><li>打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z</li><li>TCP链接建立后发送HTTP请求    </li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序    </li><li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码    </li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作    </li><li>服务器将响应报文通过TCP连接发送回浏览器    </li><li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同    </li><li>如果资源可缓存，进行缓存    </li><li>对响应进行解码（例如gzip压缩）    </li><li>根据资源类型决定如何处理（假设资源为HTML文档）    </li><li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释    </li><li>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树    </li><li>解析过程中遇到图片、样式表、js文件，启动下载    </li><li>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</li><li>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式</li><li>js解析如下：<br>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading<br>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素<br>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</li><li>显示页面（HTML解析过程中会逐步显示页面）<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="CSS选择器有哪些"><a href="#CSS选择器有哪些" class="headerlink" title="CSS选择器有哪些"></a>CSS选择器有哪些</h2></li></ol><ul><li>通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+<br>#X id选择器：选择id值为X的元素，兼容性：IE6+<br>.X 类选择器： 选择class包含X的元素，兼容性：IE6+<br>X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+<br>X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+<br>:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+<br>X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+<br>X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+<br>X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+<br>[attr]：选择所有设置了attr属性的元素，兼容性IE7+<br>[attr=value]：选择属性值刚好为value的元素<br>[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素<br>[attr|=value]：选择属性值刚好为value或者value-开头的元素<br>[attr^=value]：选择属性值以value开头的元素<br>[attr$=value]：选择属性值以value结尾的元素<br>[attribute*=value]：选择属性值中包含value的元素<br>X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+<br>:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+<br>:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+<br>::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+<br>::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+<br>:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+<br>:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+<br>X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+<br>X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+<br>X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+<br>X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+<br>X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+<br>X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+<br>X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+<h2 id="css-sprite是什么-有什么优缺点"><a href="#css-sprite是什么-有什么优缺点" class="headerlink" title="css sprite是什么,有什么优缺点"></a>css sprite是什么,有什么优缺点</h2>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。<br>优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br>缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要从新布局整个图片，样式<h2 id="display-none-与visibility-hidden-的区别"><a href="#display-none-与visibility-hidden-的区别" class="headerlink" title="display: none;与visibility: hidden;的区别"></a>display: none;与visibility: hidden;的区别</h2>相同点：它们都能让元素不可见<br>区别：<br>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见<br>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式<br>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。<br>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容<h2 id="specified-value-computed-value-used-value计算方法"><a href="#specified-value-computed-value-used-value计算方法" class="headerlink" title="specified value,computed value,used value计算方法"></a>specified value,computed value,used value计算方法</h2>specified value: 计算方法如下：<br>  如果样式表设置了一个值，使用这个值<br>  如果没有设置值，这个属性是继承属性，从父元素继承<br>  如果没设置，并且不是继承属性，使用css规范指定的初始值及浏览器初始值<br>computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承<br>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局，<br>  background-position<br>  bottom, left, right, top<br>  height, width<br>  margin-bottom, margin-left, margin-right, margin-top<br>  min-height, min-width<br>  padding-bottom, padding-left, padding-right, padding-top<br>  text-indent<h2 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h2>  link是HTML方式， @import是CSS方式<br>  link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC无样式内容闪烁(Flash Of Unstyled Content)<br>  link可以通过rel=”alternate stylesheet”指定候选样式<br>  浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br>  @import必须在样式规则之前，可以在css文件中引用其他文件<br>  总体来说：link优于@import<h2 id="display-block-和display-inline-的区别"><a href="#display-block-和display-inline-的区别" class="headerlink" title="display: block;和display: inline;的区别"></a>display: block;和display: inline;的区别</h2>block元素特点：<br>  1.处于常规流中时，如果width没有设置，会自动填充满父容器<br>  2.可以应用margin/padding<br>  3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素<br>  4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）<br>  5.忽略vertical-align<br>inline元素特点<br>  1.水平方向上根据direction依次布局<br>  2.不会在元素前后进行换行<br>  3.受white-space控制<br>  4.margin/padding在竖直方向上无效，水平方向上有效<br>  5.width/height属性对非替换行内元素无效，宽度由元素内容决定<br>  6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定<br>  6.浮动或绝对定位时会转换为block<br>  7.vertical-align属性生效<h2 id="PNG-GIF-JPG-webp-svg的区别及如何选"><a href="#PNG-GIF-JPG-webp-svg的区别及如何选" class="headerlink" title="PNG,GIF,JPG,webp,svg的区别及如何选"></a>PNG,GIF,JPG,webp,svg的区别及如何选</h2>GIF:<br>  8位像素，256色<br>  无损压缩<br>  支持简单动画<br>  支持boolean透明<br>  适合简单动画<br>JPEG：<br>  颜色限于256<br>  有损压缩<br>  可控制压缩质量<br>  不支持透明<br>  适合照片<br>PNG：<br>  有PNG8和truecolor PNG<br>  PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画<br>  适合图标、背景、按钮<br>未来趋势：<br>  webp（google推出的图片格式，目前存在浏览器兼容）<br>  svg（矢量图如：iconfont）<h2 id="CSS有哪些继承属性"><a href="#CSS有哪些继承属性" class="headerlink" title="CSS有哪些继承属性"></a>CSS有哪些继承属性</h2>关于文字排版的属性如：<br>  font<br>  word-break<br>  letter-spacing<br>  text-align<br>  text-rendering<br>  word-spacing<br>  white-space<br>  text-indent<br>  text-transform<br>  text-shadow<br>line-height<br>color<br>visibility<br>cursor<h2 id="容器包含若干浮动元素时如何清理-包含-浮动"><a href="#容器包含若干浮动元素时如何清理-包含-浮动" class="headerlink" title="容器包含若干浮动元素时如何清理(包含)浮动"></a>容器包含若干浮动元素时如何清理(包含)浮动</h2>容器元素闭合标签前添加额外元素并设置clear: both<br>父元素触发块级格式化上下文(见块级可视化上下文部分)<br>设置容器元素伪元素进行清理推荐的清理浮动方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 在标准浏览器下使用</div><div class="line">* 1 content内容为空格用于修复opera下文档中出现</div><div class="line">*   contenteditable属性时在清理浮动元素上下的空白</div><div class="line">* 2 使用display使用table而不是block：可以防止容器和</div><div class="line">*   子元素margin-top折叠,这样能使清理效果与BFC，IE6/7</div><div class="line">*   zoom: 1;一致</div><div class="line">* 3 overflow: hidden;</div><div class="line">**/</div><div class="line"></div><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">    content: &quot; &quot;; /* 1 */</div><div class="line">    display: table; /* 2 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">.clearfix:after &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* IE 6/7下使用</div><div class="line">* 通过触发hasLayout实现包含浮动</div><div class="line">**/</div><div class="line">.clearfix &#123;</div><div class="line">    *zoom: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="什么是FOUC-如何避免"><a href="#什么是FOUC-如何避免" class="headerlink" title="什么是FOUC?如何避免"></a>什么是FOUC?如何避免</h2><p>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head使用link元素。</p><h2 id="什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用"><a href="#什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用" class="headerlink" title="什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用"></a>什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于布局中的普通流。<br>创建规则：<br>    根元素<br>    浮动元素（float不是none）<br>    绝对定位元素（position取值为absolute或fixed）<br>    display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素<br>    overflow不是visible的元素<br>作用：<br>    可以包含浮动元素（父布局overflow: hidden）<br>    不被浮动元素覆盖（两列自适应布局：子1浮动，子2不浮动且有overflow: hidden）<br>    阻止父子元素的margin折叠（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中）<br><img src="https://zhuanlan.zhihu.com/p/25321647" alt="https://zhuanlan.zhihu.com/p/25321647"></p><h2 id="display-float-position的关系"><a href="#display-float-position的关系" class="headerlink" title="display,float,position的关系"></a>display,float,position的关系</h2><p>如果display为none，那么position和float都不起作用，这种情况下元素不产生框<br>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。<br>否则，如果float不是none，框是浮动的，display根据下表进行调整<br>否则，如果元素是根元素，display根据下表进行调整<br>其他情况下display的值为指定值<br>总结起来：绝对定位、浮动、根元素都需要调整display</p><h2 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h2><p>毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下：<br>1.两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠<br>2.浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠<br>3.创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠<br>4.元素自身的margin-bottom和margin-top相邻时也会折叠</p><h2 id="如何确定一个元素的包含块-containing-block"><a href="#如何确定一个元素的包含块-containing-block" class="headerlink" title="如何确定一个元素的包含块(containing block)"></a>如何确定一个元素的包含块(containing block)</h2><p>1.根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。<br>2.position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成。<br>3.如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area<br>4.如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下：<br>    如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element.<br>    其他情况下包含块由祖先节点的padding edge组成<br>如果找不到定位的祖先元素，包含块为初始包含块</p><h2 id="stacking-context-布局规则"><a href="#stacking-context-布局规则" class="headerlink" title="stacking context,布局规则"></a>stacking context,布局规则</h2><p>z轴上的默认层叠顺序如下（从下到上）：<br>    根元素的边界和背景<br>    常规流中的元素按照html中顺序<br>    浮动块<br>    positioned元素按照html中出现顺序<br>如何创建stacking context：<br>    根元素<br>    z-index不为auto的定位元素<br>    a flex item with a z-index value other than ‘auto’<br>    opacity小于1的元素<br>    在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context</p><h2 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h2><p>如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现<br>如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。<br>如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto</p><h2 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h2><p>需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height<br><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="external">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术</a><br><a href="http://vanseodesign.com/css/vertical-centering/" target="_blank" rel="external">6 Methods For Vertical Centering With CSS</a></p><h1 id="JavaScript概念部分"><a href="#JavaScript概念部分" class="headerlink" title="JavaScript概念部分"></a>JavaScript概念部分</h1><h2 id="DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系"><a href="#DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系" class="headerlink" title="DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系"></a>DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</h2><p>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性<br>e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问<br>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）<br>e.propName返回值可能是字符串、布尔值、对象、undefined等<br>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性<br>一些布尔属性’<input hidden>‘的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property<br>像’<a href="../index.html">link</a>‘中href属性，转换成property的时候需要通过转换得到完整URL<br>一些attribute和property不是一一对应如：form控件中’input value=”hello”‘对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</p><h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h2><p>offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同<br>clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸</p><h2 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h2><p>1.readyState:表示请求状态的整数，取值：<br>    UNSENT（0）：对象已创建<br>    OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求<br>    HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到<br>    LOADING(3)：响应体正在接收<br>    DONE(4)：数据传输完成或者传输产生错误<br>2.onreadystatechange：readyState改变时调用的函数<br>3.status：服务器返回的HTTP状态码（如，200， 404）<br>4.statusText:服务器返回的HTTP状态信息（如，OK，No Content）<br>5.responseText:作为字符串形式的来自服务器的完整响应<br>6.responseXML: Document对象，表示服务器的响应解析成的XML文档<br>7.abort():取消异步HTTP请求<br>8.getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行<br>9.getResponseHeader(headerName):返回headName对应的报头值<br>10.open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证<br>11.setRequestHeader(name, value):设置HTTP报头<br>12.send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</p><h2 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h2><p>mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持<br>mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能<br>标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素</p><h2 id="sessionStorage-localStorage-cookie区别"><a href="#sessionStorage-localStorage-cookie区别" class="headerlink" title="sessionStorage,localStorage,cookie区别"></a>sessionStorage,localStorage,cookie区别</h2><p>都会在浏览器端保存，有大小限制，同源限制<br>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器<br>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie<br>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除<br>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享<br>localStorage的修改会促发其他文档窗口的update事件<br>cookie有secure属性要求HTTPS传输<br>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</p><h2 id="javascript跨域通信"><a href="#javascript跨域通信" class="headerlink" title="javascript跨域通信"></a>javascript跨域通信</h2><p>同源：两个文档同源需满足<br>    协议相同<br>    域名相同<br>    端口相同<br>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法<br>如果是log之类的简单单项通信，新建img,script,link,iframe元素，通过src，href属性设置为目标url。实现跨域请求<br>如果请求json数据，使用script进行jsonp请求<br>现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用<br>内部服务器代理请求跨域url，然后返回数据<br>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源</p><h2 id="javascript有哪几种数据类型"><a href="#javascript有哪几种数据类型" class="headerlink" title="javascript有哪几种数据类型"></a>javascript有哪几种数据类型</h2><p>六种基本数据类型<br>    undefined<br>    null<br>    string<br>    boolean<br>    number<br>    symbol(ES6)<br>一种引用类型<br>    Object</p><h2 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h2><p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：<br>    函数本身作用域。<br>    闭包定义时的作用域。<br>    全局作用域。<br>闭包常见用途：<br>    创建特权方法用于访问控制<br>    事件处理程序及回调</p><h2 id="javascript有哪几种方法定义函数"><a href="#javascript有哪几种方法定义函数" class="headerlink" title="javascript有哪几种方法定义函数"></a>javascript有哪几种方法定义函数</h2><p>函数声明表达式<br>function操作符<br>Function 构造函数<br>ES6:arrow function</p><h2 id="应用程序存储和离线web应用"><a href="#应用程序存储和离线web应用" class="headerlink" title="应用程序存储和离线web应用"></a>应用程序存储和离线web应用</h2><p>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:’<html manifest="myapp.appcache">‘，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"></div><div class="line">CACHE:</div><div class="line">myapp.html</div><div class="line">myapp.css</div><div class="line">myapp.js</div><div class="line"></div><div class="line">FALLBACK:</div><div class="line">videos/ offline_help.html</div><div class="line"></div><div class="line">NETWORK:</div><div class="line">cgi/</div></pre></td></tr></table></figure></html></p><h2 id="客户端存储localStorage和sessionStorage"><a href="#客户端存储localStorage和sessionStorage" class="headerlink" title="客户端存储localStorage和sessionStorage"></a>客户端存储localStorage和sessionStorage</h2><p>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前<br>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。<br>Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key</p><h2 id="cookie及其操作"><a href="#cookie及其操作" class="headerlink" title="cookie及其操作"></a>cookie及其操作</h2><p>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。<br>通过读写cookie检测是否支持<br>cookie属性有name，value，max-age，path, domain，secure；<br>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期<br>cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问<br>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下<br>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</p><h2 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h2><p>对象字面量： var obj = {};<br>构造函数： var obj = new Object();<br>Object.create(): var obj = Object.create(Object.prototype); // Object.create(proto[, propertiesObject])</p><h2 id="运算符判断相等的流程是怎样的"><a href="#运算符判断相等的流程是怎样的" class="headerlink" title="===运算符判断相等的流程是怎样的"></a>===运算符判断相等的流程是怎样的</h2><p>如果两个值不是相同类型，它们不相等<br>如果两个值都是null或者都是undefined，它们相等<br>如果两个值都是布尔类型true或者都是false，它们相等<br>如果其中有一个是NaN，它们不相等<br>如果都是数值型并且数值相等，他们相等， -0等于0<br>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同和=都认为他们不相等<br>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</p><h2 id="运算符判断相等的流程是怎样的-1"><a href="#运算符判断相等的流程是怎样的-1" class="headerlink" title="==运算符判断相等的流程是怎样的"></a>==运算符判断相等的流程是怎样的</h2><p>如果两个值类型相同，按照===比较方法进行比较<br>如果类型不同，使用如下规则进行比较<br>如果其中一个值是null，另一个是undefined，它们相等<br>如果一个值是数字另一个是字符串，将字符串转换为数字进行比较<br>如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较<br>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较<br>其他所有情况都认为不相等</p><h2 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h2><p>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果<br>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果<br>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</p><h2 id="对象到数字的转换步骤"><a href="#对象到数字的转换步骤" class="headerlink" title="对象到数字的转换步骤"></a>对象到数字的转换步骤</h2><ol><li>如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果</li><li>否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果</li><li>否则，throws a TypeError<h2 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;,&gt;,&lt;=,&gt;=的比较规则"></a>&lt;,&gt;,&lt;=,&gt;=的比较规则</h2>所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:<br>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错<br>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）<br>否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较<h2 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h2>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象<br>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参<br>arguments.length为实参的个数（Function.length表示形参长度）<br>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化<br>arguments.caller为调用当前函数的函数（已被遗弃）<br>转换为数组：var args = Array.prototype.slice.call(arguments, 0);    <h2 id="列举数组相关的常用方法"><a href="#列举数组相关的常用方法" class="headerlink" title="列举数组相关的常用方法"></a>列举数组相关的常用方法</h2>参考答案: push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter<h2 id="列举字符串相关的常用方法"><a href="#列举字符串相关的常用方法" class="headerlink" title="列举字符串相关的常用方法"></a>列举字符串相关的常用方法</h2>参考答案: indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase<h2 id="请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”"><a href="#请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”" class="headerlink" title="请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”"></a>请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];</div><div class="line">var date = new Date();</div><div class="line"></div><div class="line">console.log(&apos;今天是星期&apos; + days[date.getDay()]);</div></pre></td></tr></table></figure></li></ol><h2 id="js里的作用域是什么样子的？"><a href="#js里的作用域是什么样子的？" class="headerlink" title="js里的作用域是什么样子的？"></a>js里的作用域是什么样子的？</h2><p>参考答案：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined.</p><pre><code>var globalVar = &apos;global var&apos;;function test() {alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义var globalVar = &apos;overrided var&apos;; //　globalVar在本函数内被重定义alert(globalVar);　// overrided var}alert(globalVar); // global var，使用全局变量</code></pre><h2 id="js里边的this指的是什么"><a href="#js里边的this指的是什么" class="headerlink" title="js里边的this指的是什么?"></a>js里边的this指的是什么?</h2><p>参考答案: this指的是对象本身，而不是构造函数．    </p><h2 id="apply-call和bind有什么区别"><a href="#apply-call和bind有什么区别" class="headerlink" title="apply, call和bind有什么区别?"></a>apply, call和bind有什么区别?</h2><p>参考答案：三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，    </p><h2 id="caller-callee和arguments分别是什么"><a href="#caller-callee和arguments分别是什么" class="headerlink" title="caller, callee和arguments分别是什么?"></a>caller, callee和arguments分别是什么?</h2><p>参考答案: caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot;&gt;&lt;a href=&quot;#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot; class=&quot;headerlink&quot; title=&quot;从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)&quot;&gt;&lt;/a&gt;从
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Babel工作原理及Babel插件开发探索</title>
    <link href="https://fanerge.github.io/2018/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8ABabel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2.html"/>
    <id>https://fanerge.github.io/2018/Babel工作原理及Babel插件开发探索.html</id>
    <published>2018-03-04T12:46:18.000Z</published>
    <updated>2018-03-04T13:25:41.481Z</updated>
    
    <content type="html"><![CDATA[<p>在掘金上看见了<a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒</a>，正巧自己对Babel工作原理和Babel插件开发也不够了解，赶紧来补一波吧。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>首先我们这里需要了解一些基本的概念，<a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">这篇文章介绍的很详细</a>，我这边只提一下。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。<br>意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。<br>和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。<br>一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote><p>   静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。<br>静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p></blockquote><h1 id="Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）"><a href="#Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）" class="headerlink" title="Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）"></a>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接收代码并输出AST。这个步骤又分为两个阶段：词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段把字符串形式的代码转换成令牌（tokens）流。<br>你可以把令牌看作是一个扁平化的语法片段数组。<br>如：n*n代码经过词法分析转换成令牌<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// n*n</div><div class="line">[</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</div><div class="line">  ...</div><div class="line">]</div></pre></td></tr></table></figure></p><p>每一个type有一组属性来描述该令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &#123;</div><div class="line">    label: &apos;name&apos;,</div><div class="line">    keyword: undefined,</div><div class="line">    beforeExpr: false,</div><div class="line">    startsExpr: true,</div><div class="line">    rightAssociative: false,</div><div class="line">    isLoop: false,</div><div class="line">    isAssign: false,</div><div class="line">    prefix: false,</div><div class="line">    postfix: false,</div><div class="line">    binop: null,</div><div class="line">    updateContext: null</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析阶段会把一个令牌(tokens)流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。<br>这个过程我们可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">astexplorer</a>来查看我们代码生成的AST。<br>这个时候我们的AST就产生了，如下图。<br><img src="http://p52glq5m1.bkt.clouddn.com/ASTdemo1.png" alt="源代码到AST"><br>PS：上图左边为我们的源代码，右边为对应生成的抽象语法树AST。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。<br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。<br>Babel工作原理见下图表示。<br><img src="http://p52glq5m1.bkt.clouddn.com/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="Babel工作原理"><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">图片来源，探索 babel 和 babel 插件是怎么工作的</a></p><h1 id="开发一个Babel插件"><a href="#开发一个Babel插件" class="headerlink" title="开发一个Babel插件"></a>开发一个Babel插件</h1><h2 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a>Visitors（访问者）</h2><p>当我们谈及“进入”一个节点，实际上是说我们在访问它们， 之所以使用这样的术语是因为有一个访问者模式（visitor）的概念。<br>访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const MyVisitor = &#123;</div><div class="line">  Identifier: &#123;</div><div class="line">// 当进入Identifier节点的时候执行</div><div class="line">enter() &#123; </div><div class="line">  console.log(&quot;Entered&quot;);</div><div class="line">&#125;,</div><div class="line">// 当退出Identifier节点的时候执行</div><div class="line">exit() &#123;</div><div class="line">      console.log(&quot;Exited!&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>PS： 许多时候我们只需要关心进入节点，就可以使用简写 Identifier() { … } 或者 Identifier: { enter() { … } } 。<br>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier里面的enter方法和exit方法。</p><h2 id="Paths（路径）"><a href="#Paths（路径）" class="headerlink" title="Paths（路径）"></a>Paths（路径）</h2><blockquote><p>   我们通过 visitor可以在遍历到对应节点执行对应的函数，当需要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置 （即和其他节点间的关系）, visitor在遍历到对应节点执行对应函数时候会给我们传入 path参数，辅助我们完成上面这些操作。注意 Path 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了 Identifier节点，它传入的 path参数看起来是这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;parent&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;VariableDeclarator&quot;,</div><div class="line">    &quot;id&quot;: &#123;</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    ....</div><div class="line">  &#125;,</div><div class="line">  &quot;node&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;Identifier&quot;,</div><div class="line">    &quot;name&quot;: &quot;...&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里就可以通过：path.node.name 获得当前节点的name；path.parent.id 获得父节点的id<br>另外path对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。</p><h2 id="开始动手写插件了"><a href="#开始动手写插件了" class="headerlink" title="开始动手写插件了"></a>开始动手写插件了</h2><p>输入的源代码为：<br><code>yuzhenfan === wangkemei</code><br>生成的AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &quot;BinaryExpression&quot;,</div><div class="line">  operator: &quot;===&quot;,</div><div class="line">  left: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;,</div><div class="line">  right: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>省略部分属性，可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">http://astexplorer.net</a>查看全部属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const babel = require(&apos;babel-core&apos;)</div><div class="line"></div><div class="line">// 我们的babel插件</div><div class="line">let MyVisitor = function(&#123; types: t &#125;) &#123;</div><div class="line">  return &#123;</div><div class="line">    visitor: &#123;</div><div class="line"></div><div class="line">      BinaryExpression(path) &#123;</div><div class="line">  </div><div class="line">        if (path.node.operator !== &quot;===&quot;) &#123;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 改变当前节点的left、right（插件的核心代码）</div><div class="line">path.node.left = t.identifier(&quot;fanerge1&quot;);</div><div class="line">path.node.right = t.identifier(&quot;fanerge2&quot;);</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const code = `yuzhenfan === wangkemei;`;</div><div class="line"></div><div class="line">let demo = babel.transform(code, &#123;</div><div class="line">  // 使用我们的插件</div><div class="line">  plugins: [MyVisitor]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(demo); // fanerge1===fanerge2</div></pre></td></tr></table></figure></p><p>输出的代码为（经过我们的插件处理）：<br><code>fanerge1===fanerge2</code><br>下图为node打印出Balbel输出的代码：<br><img src="http://p52glq5m1.bkt.clouddn.com/result.png" alt="babel转换的代码"><br><a href="https://github.com/fanerge/babel_plugin" target="_blank" rel="external">项目地址，非常简单的Babel插件，后续再继续学习</a></p><blockquote><p>   参考文档<br><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-introduction" target="_blank" rel="external">Babel 插件手册</a><br><a href="https://github.com/estree/estree" target="_blank" rel="external">ESTree</a><br><a href="http://astexplorer.net/" target="_blank" rel="external">AST Explorer</a><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">探索 babel 和 babel 插件是怎么工作的</a><br><a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">掘金-babel插件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在掘金上看见了&lt;a href=&quot;https://juejin.im/post/5a9315e46fb9a0633a711f25&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒&lt;/a&gt;，正
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="Babel" scheme="https://fanerge.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>浏览器工作原理-webkit内核研究</title>
    <link href="https://fanerge.github.io/2018/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html"/>
    <id>https://fanerge.github.io/2018/浏览器工作原理-webkit内核研究.html</id>
    <published>2018-03-03T02:10:00.000Z</published>
    <updated>2018-03-17T12:32:49.119Z</updated>
    
    <content type="html"><![CDATA[<p>从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。<br>主要查阅了<a href="https://book.douban.com/subject/25910556/" target="_blank" rel="external">WebKit技术内幕</a>、<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>、<a href="https://www.w3.org/" target="_blank" rel="external">W3C</a>等网站资料，下文中有若干图片摘自于《WebKit技术内幕》，在此表示感谢。<br>本文略长，如有不适，实属意外。如有不正确的地方，还望指正，毕竟传播真理才不会误导其他同学，共同进步才是目的。</p><h1 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h1><p>浏览器内核由渲染引擎和JS引擎组成，不同的浏览器、即使同一浏览器不同型号可能渲染引擎和JS引擎都不一样。</p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>1)Trident渲染引擎 –&gt; 老版本IE系列浏览器<br>2)Edge渲染引擎 -&gt; Win10中IE浏览器<br>3)Gecko渲染引擎 –&gt; Mozilla Firefox<br>4)Presto渲染引擎 –&gt; Opera<br>5)KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome<br>6)Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器<br>7)Blink渲染引擎 -&gt; 新版本的Chromium浏览器Google项目</p><h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h2><p>1)JScript引擎 –&gt; IE系列浏览器<br>2)spiderMonkey引擎 –&gt; Mozilla Firefox<br>3)V8引擎 –&gt; Google Chrome<br>4)linear b/futhark引擎 –&gt; Opera</p><h2 id="浏览器渲染引擎的进度史"><a href="#浏览器渲染引擎的进度史" class="headerlink" title="浏览器渲染引擎的进度史"></a>浏览器渲染引擎的进度史</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" alt="浏览器渲染引擎的进度史"><br>为大家提供两个开发常用查询网站：<br><a href="http://html5test.com/" target="_blank" rel="external">该浏览器对html5的支持程度</a><br><a href="https://caniuse.com" target="_blank" rel="external">不同与Can I use</a></p><h1 id="浏览器的渲染引擎及依赖模块分析"><a href="#浏览器的渲染引擎及依赖模块分析" class="headerlink" title="浏览器的渲染引擎及依赖模块分析"></a>浏览器的渲染引擎及依赖模块分析</h1><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%9F%E8%83%BD.png" alt="渲染引擎的功能"><br>上图中虚线部分表示渲染引擎所提供的功能。<br>这里渲染引擎包含了JavaScript引擎，许多时候两者都不太区分。<br>下面的内容大部分都是基于这张图来分析的，我们将逐步解释从用户输入URL到页面展示给用户这个过程中都发生了什么？<br>我们先了解网页的基础知识。</p><h1 id="网页基础知识"><a href="#网页基础知识" class="headerlink" title="网页基础知识"></a>网页基础知识</h1><p>html – 结构<br>css – 样式<br>JavaScript – 行为<br>还需要一些静态资源：png、gif、webp、MP4、font、svg等等。<br>由上面几部分就构成我们的网页。</p><h2 id="输入URL到页面展示简图"><a href="#输入URL到页面展示简图" class="headerlink" title="输入URL到页面展示简图"></a>输入URL到页面展示简图</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/url%E5%88%B0dom%E6%A0%91.png" alt="URL到页面展示"><br>读者不要太关心上图所标的顺序，在某些时候可能会有出入。</p><h2 id="浏览器内核各部分解释"><a href="#浏览器内核各部分解释" class="headerlink" title="浏览器内核各部分解释"></a>浏览器内核各部分解释</h2><blockquote><p>   HTML解释器：解释HTML文本的解释器，主要作用是将HTML文本解释成DOM树，DOM是一种文档表示方法。<br>CSS解释器：级联样式表的解释器，它的作用是为DOM中的各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。<br>布局：在DOM创建之后，webkit需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部比偶表示模型。<br>JavaScript引擎：使用JavaScript代码可以修改网页的内容，也能修改CSS的信息，JavaScript引擎能过解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染结果。<br>绘图：使用图形库将布局计算后的各个网页的节点绘制成图像结果。</p></blockquote><p>PS：这些模块依赖许多其他基础模块，其中包括网络、存储、2D/3D图形、音频视频和图片解码器等。这里就不对基础模块做相应说明了。</p><p>下面，我就逐个过程进行分析，我这里省略一些非本文目的的过程，如DNS环节。</p><h1 id="HTML解释器"><a href="#HTML解释器" class="headerlink" title="HTML解释器"></a>HTML解释器</h1><p>先来看看HTML解释器工作原理<br><img src="http://p4yvw0vpm.bkt.clouddn.com/html%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="HTML解释器工作原理"><br>字节流（Bytes）–&gt; 字符流（Characters）–&gt; 词语（Tokens）–&gt; 节点 –&gt; DOM树</p><blockquote><p>   首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），时候经过分析器构建成节点，最后这些节点被组建成一棵DOM树。<br>词法分析：HTMLTokenizer 类（作用是词法分析，类似于状态机），输入的是字符串，输出的是一个个的词语。<br>XSSAuditor验证词语：XSSAuditor （验证词语流Token Stream）XSS指的是Cross Site Security，主要是针对安全方面的考虑。<br>词语到节点：webkit用来构建DOM节点，这一步骤由HTMLDocumentParser 类调用 HTMLTreeBuilder 类的 constructTree的函数来实现。<br>节点到DOM树：树中的元素节点创建属性节点等工作由HTMLConstructionSite类来完成，该类中包含一个 HTMLElementStack 作为保存元素节点的栈。<br>JavaScript的执行：webkit将DOM树创建过程中需要执行得我Javascript代码交由HTMLScriptRunner类来负责。<br>DOM的事件机制：webkit中用EventTarget类来表示DOM规范中Events部分定义的事件目标，Node 节点继承自 EventTarget类，所以Node拥有EventTarget类的相关的方法。</p></blockquote><p>这里需要提一下W3C新规范，影子（Shadow）DOM<br>Shadow DOM API的 ShadowRoot接口是一个DOM子树的根节点, 它与文档的主DOM树分开渲染。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ShadowRoot" target="_blank" rel="external">MDN-影子节点</a></p><h2 id="影子（Shadow）DOM"><a href="#影子（Shadow）DOM" class="headerlink" title="影子（Shadow）DOM"></a>影子（Shadow）DOM</h2><p>定义：Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。<br>ShadowRoot 类继承自 DocumentFragment 类。<br>PS：可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.</p><h1 id="CSS解释器和样式布局"><a href="#CSS解释器和样式布局" class="headerlink" title="CSS解释器和样式布局"></a>CSS解释器和样式布局</h1><p>先看看CSS怎么和DOM结合展示页面的呢？<br><img src="http://p4yvw0vpm.bkt.clouddn.com/css%E5%92%8Cdom%E6%A0%91%E5%88%B0%E7%BB%98%E5%88%B6%E7%BD%91%E9%A1%B5.png" alt="CSS+DOM形成简单页面"><br>css解释器和规则匹配处于DOM树建立之后，RenderObject树建立之前，css解释器解释后的结果会保存起来，然后RenderObject树基于该结果来进行规范匹配和布局计算。</p><h2 id="CSSOM（CSS-Object-Model）"><a href="#CSSOM（CSS-Object-Model）" class="headerlink" title="CSSOM（CSS Object Model）"></a>CSSOM（CSS Object Model）</h2><p>CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动。<br>document.styleSheets 可以查看当前页面的StyleSheetList对象，每个link、style都会产生 CSSStyleSheet 作为 StyleSheetList对象的value。</p><h2 id="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"><a href="#CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）" class="headerlink" title="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"></a>CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）</h2><p>DocumentStyleSheetCollection类（属于Document类），该类包含了所有CSS样式表，还包括了webkit的内部表示类CSSStyleSheet，它包含了CSS的href、类型、内容等信息。<br>CSS解释过程：css字符串经过css解释器处理后变成渲染引擎的内部规则的过程，使用CSSParser类来负责该过程。<br>在解释网页中自定义的CSS样式之前，实际上webkit渲染引擎会为每个网页设置一个默认样式，这也是我们为什么要重置浏览器样式的根本原因。<br>规则匹配：StyleResolver类为DOM的元素节点匹配样式，StyleResolver类根据元素的信息，例如标签名、类别等，从样式规则中查找最匹配的规则，然后将样式信息保存到新建的RenderStyle对象中。最后，这些RenderStyle对象被RenderObject类所管理和使用。<br>    其中，规则的匹配则是由ElementRuleCollector类来计算并获得，它根据元素的属性等信息，并从DocumentRuleSets类中获取规则集合，依次按照ID、CLASS、标签等选择器信息逐次匹配获得元素的样式。<br>    然后webkit对这些规则进行排序，对于该元素需要的样式属性，webkit选择从高优先级规则中选取，并将样式属性值返回。<br>这里，我引入一个不太相关的知识点，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">不太了解的同学，请异步MDN-BFC</a></p><h1 id="webkit布局"><a href="#webkit布局" class="headerlink" title="webkit布局"></a>webkit布局</h1><p>当webkit创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息的过程称为布局计算/排版。<br>    布局计算分类：第一类是对整个RenderObject树进行的计算；第二类是对RenderObject树中某个子树的计算，常见于文本元素或者overflow：auto块的计算。<br>    布局计算：布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。</p><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>我们常说的reflow和repaint。涉及到元素的几何属性改变会造成reflow会降低性能（transform、opacity等属性不会造成reflow）。<br>扩展为什么说transform实现动画较直接设置几何属性性能较好？<br>1.webkit渲染过程：style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite，transform是位于’Composite（渲染层合并）‘，而width、left、margin等则是位于‘Layout（布局）’层，这必定导致reflow。<br>2.现代浏览器针对transform等开启GPU加速。<br>    style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite（transform发生在这个时候）<br>由这个过程我们可以看出，这也是为什么发生reflow必定会发生repaint的根本原因。<br><a href="https://www.w3cplus.com/animation/animation-performance.html" target="_blank" rel="external">CSS Animation性能优化</a><br><a href="https://segmentfault.com/a/1190000008650975" target="_blank" rel="external">从重绘重排角度讲解transform的动画性能</a></p><h1 id="渲染过程的一些理论"><a href="#渲染过程的一些理论" class="headerlink" title="渲染过程的一些理论"></a>渲染过程的一些理论</h1><p>RenderObject树同其他树（如RenderLayer树等），构成了webkit渲染的主要基础设施。</p><h2 id="RenderObject树（DOM树-gt-RenderObject树）"><a href="#RenderObject树（DOM树-gt-RenderObject树）" class="headerlink" title="RenderObject树（DOM树 -&gt; RenderObject树）"></a>RenderObject树（DOM树 -&gt; RenderObject树）</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/DOM%E5%88%B0RenderObject.png" alt="DOM到RenderObject"><br>一个RenderObject对象保存了为绘制DOM节点所需要的各种信息，例如样式布局信息，经过webkit的处理之后，RenderObject对象知道如何绘制自己。<br>下列情况会使DOM树节点创建一个RenderObject对象（DOM和RenderObject并非一一对应）。<br>1.DOM树的document节点。<br>2.DOM树种的可视节点，例如html、body、div等。而webkit不会为非可视化节点创建RenderObject节点，例如meta、script。<br>3.某些情况下webkit需要建立匿名的RenderObject节点，该节点不对应于DOM树种的任何节点，而是webkit处理上的需要，典型的例子例如匿名的RenderBlock节点。<br>在html组建页面结构时，webkit为了提升网页性能，会引入分层结构。</p><h2 id="网页层次结构（css也会对网页的分层策略产生重要影响）"><a href="#网页层次结构（css也会对网页的分层策略产生重要影响）" class="headerlink" title="网页层次结构（css也会对网页的分层策略产生重要影响）"></a>网页层次结构（css也会对网页的分层策略产生重要影响）</h2><p>对于一个html文件webkit会为某些元素和它的子节点建立新层，这样webkit可以单独对某层操作提升性能，下列情况会产生新层。<br>1.video标签 – webkit在新层中有效的处理视频解码器和浏览器之间的交互和渲染问题。<br>2.div、p等普通标签 – 涉及到3D变换时。<br>3.canvas标签 – 复杂的2D和3D绘图操作。</p><h2 id="RenderLayer树"><a href="#RenderLayer树" class="headerlink" title="RenderLayer树"></a>RenderLayer树</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/RenderObject%E5%88%B0RenderLayer.png" alt="RenderObject到RenderLayer"><br>webkit会为网页的层次创建相应的RenderLayer对象。当某些类型RenderObject的节点或者某些css样式的RenderObject节点出现的时候，webkit就会为这些节点创建RenderLayer对象。<br>RenderLayer树是基于RenderObject树建立起来的一棵新树。RenderLayer节点和RenderObject节点不是一一对应关系，而是一对多的关系。<br>哪些情况下的RenderObject节点需要建立新的RenderLayer节点呢？<br>1.DOM树的Document节点对应的RenderView节点。<br>2.DOM树中的Document的子节点，也就是HTML节点对应RenderBlock节点。<br>3.显式的制定css位置的RenderObject节点。<br>4.有透明效果的RenderObject节点。<br>5.节点有溢出（overflow）、alpha或者反射效果的RenderObject节点。<br>6.使用Canvas 2D和3D（WebGL）技术的RenderObject节点。<br>7.Video节点对应的RenderObject节点。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><p>绘图上下文（绘图上下文可以分成两种类型）：<br>    第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）。<br>    第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）。<br>网页的三种渲染方式：<br>1.软件渲染（CPU内存）<br>2.使用软件绘图的合成化渲染（GPU内存）css3D、WebGL<br>3.硬件加速的合成化渲染（GPU内存）</p><h2 id="webkit软件渲染技术"><a href="#webkit软件渲染技术" class="headerlink" title="webkit软件渲染技术"></a>webkit软件渲染技术</h2><p>在不需要硬件加速内容的时候（包括但不限于css3 3D变形、css3 3D变换、WebGL和视频），webkit就可以使用软件渲染技术来完成页面绘制。<br>对于每个RenderObject对象，需要三个阶段绘制自己：<br>第一阶段是绘制该层中所有块的背景和边框。<br>第二阶段是绘制浮动内容。<br>第三阶段是前景（Foreground），也就是内容部分、轮廓、字体颜色、大小等（内嵌元素的背景、边框等发生在这一阶段）。</p><h2 id="硬件加速机制"><a href="#硬件加速机制" class="headerlink" title="硬件加速机制"></a>硬件加速机制</h2><p>硬件加速技术是指使用GPU的硬件能力来帮助渲染网页（GPU的作用主要是用来绘制3D图形并且性能特别好）。</p><h3 id="Chrome的硬件加速机制"><a href="#Chrome的硬件加速机制" class="headerlink" title="Chrome的硬件加速机制"></a>Chrome的硬件加速机制</h3><p>canvas开发，可以将画布分解为更小的画布，这样在更新时只需要更新小画布从而减少开销。<br>css3 3D变形技术，它能过让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果（只触发Composite而不用触发style -&gt; Layout(reflow发生在这) -&gt; Paint）。</p><h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><p>WebGL是Khronous组织提出的一套基于3D图形定义的javascript接口。<br>它基于canvas元素，跟canvas2D不同的是，Web开发者可以使用3D图形接口来绘制各种3D图形。</p><h3 id="css-3D变形"><a href="#css-3D变形" class="headerlink" title="css 3D变形"></a>css 3D变形</h3><p>这里包括3D变形和动画。<br>webkit会建立一个新层来处理，从而提升性能。</p><h1 id="JavaScript引擎-1"><a href="#JavaScript引擎-1" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h1><p>推动JavaScript运行速度提高的利器JIT（Just-In-Time）。<br>JIT：就是代码在目标平台上运行的时候，实时的把代码编译为目标机器上的机器码。<br>编译原理：<br>C++：源代码 –&gt; 抽象语法树 –&gt; 本地代码<br>Java：源代码 –&gt; 抽象语法树  –&gt; 字节码（跨平台） –&gt; JIT –&gt; 本地代码</p><h2 id="V8的一些特性（这里太多了，读者可以自己深究）"><a href="#V8的一些特性（这里太多了，读者可以自己深究）" class="headerlink" title="V8的一些特性（这里太多了，读者可以自己深究）"></a>V8的一些特性（这里太多了，读者可以自己深究）</h2><p>常用的javascript引擎有v8和JavaScriptCore<br>工作原理<br>在js中，基本数据类型Boolean、Number、String、Null、Undefined、Symbol，其他数据都是对象。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>在V8中，数据的表示分成两个部分<br>    第一部分是数据的实际内容，它们是变长的，而且内容的类型也不一样，如String、对象等。<br>    第二部分是数据的句柄，句柄的大小是固定的，句柄中包含指向数据的指针。</p><h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>Handle：句柄类，主要用来管理基础数据和对象，以便被垃圾回收器操作。<br>主要有两个类型，一个Local类（继承自Handle类），表示本地栈上的数据，所以比较轻量。<br>另一个是Persistent类（继承自Handle类）表示函数间的数据和对象访问。<br>对于整形数据，由Handle本身来存储，同时也为了快速访问。<br>其他的数据都是从堆中申请内存来存储它们，由于其他数据类型，受限于Handle的大小和变长等原因，都存储在堆中。<br>V8的延迟（deferred）特性：它使的许多javascript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销。<br><img src="http://p4yvw0vpm.bkt.clouddn.com/javascript%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81.png" alt="v8将源代码-本地代码"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="常见的语言类型"><a href="#常见的语言类型" class="headerlink" title="常见的语言类型"></a>常见的语言类型</h3><p>机器语言（它是计算机唯一能直接执行的语言，电子计算机的机器指令是一列二进制数字。）<br>汇编语言 汇编指令是机器指令便于记忆的书写格式，但他需要进过编译器转换为机器语言，这样机器才能执行。</p><h3 id="使用setTimeout或setInterval较requestAnimationFrame的缺点？"><a href="#使用setTimeout或setInterval较requestAnimationFrame的缺点？" class="headerlink" title="使用setTimeout或setInterval较requestAnimationFrame的缺点？"></a>使用setTimeout或setInterval较requestAnimationFrame的缺点？</h3><p>时间间隔应该设置为多少才合适呢。<br>跟屏幕的分辨率有关吗（不同浏览器存在一个极小值）。<br>设置的时间会按照会准确执行吗。<br>动画会被平滑地显示效果吗。<br>回调函数时复杂的好还是简单的好呢。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame</a></p><h1 id="其他浏览器相关知识"><a href="#其他浏览器相关知识" class="headerlink" title="其他浏览器相关知识"></a>其他浏览器相关知识</h1><h2 id="插件和Javascript扩展"><a href="#插件和Javascript扩展" class="headerlink" title="插件和Javascript扩展"></a>插件和Javascript扩展</h2><p>在早期的浏览器能力十分有限，Web前端开发者们希望能够通过一些机制来扩展浏览器的能力（插件机制如flash插件）。</p><h3 id="NPAPI全称叫-Netscape-plugin-API"><a href="#NPAPI全称叫-Netscape-plugin-API" class="headerlink" title="NPAPI全称叫 Netscape plugin API"></a>NPAPI全称叫 Netscape plugin API</h3><p>NPAPI是当今最流行的插件架构，几乎所有浏览器都支持，不过存在很大的安全隐患，插件可以窃取系统底层权限，发起恶意攻击。</p><h3 id="PPAPI也就是Pepper-Plugin-API"><a href="#PPAPI也就是Pepper-Plugin-API" class="headerlink" title="PPAPI也就是Pepper Plugin API"></a>PPAPI也就是Pepper Plugin API</h3><p>2010年，Google开发了新的PPAPI，将外挂插件全部放到沙盒里运行，2012年Windows、Mac版本的Chrome浏览器先后升级了PPAPI Flash Player，并希望今年底之前彻底淘汰NPAPI。</p><h2 id="JavaScript引擎的扩展机制"><a href="#JavaScript引擎的扩展机制" class="headerlink" title="JavaScript引擎的扩展机制"></a>JavaScript引擎的扩展机制</h2><p>通过如下url参看当前chrome浏览器安装的extensions<br>chrome://extensions/ </p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><p>WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="external">MDN-WebRTC</a><br>最重要的方法：navigator.mediaDevices.getUserMedia(constraints)<br>还有Video、Audio等。</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><p>第一部分是网页的安全，包括但是不限于网页数据安全传输、跨域访问、用户数据安全等。<br>第二部分是浏览器的安全，具体是指虽然网页或者Javascript代码有一些安全问题或者存在安全漏洞，浏览器也能够在运行它们的时候保证吱声的安全，不受到攻击从而泄漏数据或者使系统遭受破坏。</p><h3 id="网页安全模型"><a href="#网页安全模型" class="headerlink" title="网页安全模型"></a>网页安全模型</h3><p>安全模型基础：<br>域（Same Origin Policy）XMLHttpRequest、cookie的读写、DOM对象操作等。<br>XSS（Cross Site Scripting）执行跨域的js脚本代码。开发者可以将用户输入的数据进行字符转换来避免。webkit通过XSSAuditor对象帮我们过滤（默认开启）。<br>CSP （Content-Security-Policy）HTTP首部字段，内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。<br>CORS（Cross Origin Resource Sharing）跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。<br>    具体服务端代码设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 请求头</div><div class="line">header(&apos;Access-Control-Allow-Origin: http://arunranga.com&apos;); // </div><div class="line">header(&apos;Access-Control-Allow-Methods: POST, GET, OPTIONS&apos;);</div><div class="line">header(&apos;Access-Control-Allow-Headers: X-PINGARUNER&apos;);</div><div class="line">// 响应头</div><div class="line">Access-Control-Allow-Origin、</div><div class="line">Access-Control-Allow-Credentials、</div><div class="line">Access-Control-Allow-Headers、</div><div class="line">Access-Control-Expose-Headers、</div><div class="line">Access-Control-Allow-Methods、</div><div class="line">Access-Control-Max-Age</div></pre></td></tr></table></figure></p><p>Cross Document Messaging 通过 window.postMessage 和 message 事件来通信。<br>HTTPS（安全传输协议）<br>SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。    SPDY核心思想为多路复用。<br>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。</p><h4 id="CSP和CORS的区别："><a href="#CSP和CORS的区别：" class="headerlink" title="CSP和CORS的区别："></a>CSP和CORS的区别：</h4><p>CSP定义了网页自身能够访问的某些域和资源。<br>CORS定义一个网页如何才能访问被同源策略禁止的跨域资源，并规定了两者交互的协议和方式。</p><h3 id="沙箱模型"><a href="#沙箱模型" class="headerlink" title="沙箱模型"></a>沙箱模型</h3><p>浏览器的沙箱模型是利用系统提供的安全技术，让网页在执行过程中不会修改操作系统或者是访问系统中的隐私数据，而需要访问系统资源或者说是系统调用的时候，通过一个代理机制来完成。</p><h1 id="chrome浏览其使用技巧（以实用性排列）"><a href="#chrome浏览其使用技巧（以实用性排列）" class="headerlink" title="chrome浏览其使用技巧（以实用性排列）"></a>chrome浏览其使用技巧（以实用性排列）</h1><p>一下url直接输入在浏览器中，enter即可</p><table><thead><tr><th>URL</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>chrome://inspect</td><td style="text-align:center">移动端网页调试</td></tr><tr><td>chrome://net-internals</td><td style="text-align:center">net-internals是一套工具集合，用于帮助诊断网络请求与访问方面的问题，它通过监听和搜集 DNS，Sockets，SPDY，Caches等事件与数据来向开发者反馈各种网络请求的过程、状态以及可能产生影响的因素。如，查看DNS主机解析缓存chrome://net-internals/#dns</td></tr><tr><td>chrome://view-http-cache/</td><td style="text-align:center">查看内部存储内容及其详情</td></tr><tr><td>chrome://downloads/</td><td style="text-align:center">下载内容管理，其快捷键是Ctrl+J</td></tr><tr><td>chrome://extensions/</td><td style="text-align:center">扩展管理</td></tr><tr><td>chrome://bookmarks/</td><td style="text-align:center">书签管理  </td></tr><tr><td>chrome://history</td><td style="text-align:center">访问历史管理  </td></tr><tr><td>chrome://restart</td><td style="text-align:center">重启chrome浏览器 </td></tr><tr><td>chrome://apps</td><td style="text-align:center">chrome网上应用店  </td></tr><tr><td>chrome://flags/</td><td style="text-align:center">新特性管理 </td></tr><tr><td>chrome://dns</td><td style="text-align:center">查看DNS预取命名（从超链接等处来预测）  </td></tr><tr><td>chrome://quota-internals</td><td style="text-align:center">查看浏览器所使用磁盘空间配额 </td></tr><tr><td>chrome://settings</td><td style="text-align:center">浏览器的设置</td></tr><tr><td>chrome://sync-internals</td><td style="text-align:center">查看chrome 的同步状态 </td></tr><tr><td>chrome://about/</td><td style="text-align:center">查看所有chrome命令 </td></tr></tbody></table><p><a href="https://fanerge.github.io">期望加入一个技术氛围nice的团队-成都</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。&lt;br&gt;主要查阅了&lt;a href=&quot;https://book.douban.com/subject/25
      
    
    </summary>
    
      <category term="webkit" scheme="https://fanerge.github.io/categories/webkit/"/>
    
    
      <category term="浏览器" scheme="https://fanerge.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj</title>
    <link href="https://fanerge.github.io/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj.html"/>
    <id>https://fanerge.github.io/2018/前端常识-gj.html</id>
    <published>2018-02-09T12:36:22.000Z</published>
    <updated>2018-05-06T02:55:50.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-virtualDOM（batching）"><a href="#React-virtualDOM（batching）" class="headerlink" title="React virtualDOM（batching）"></a>React virtualDOM（batching）</h2><p>在React中，render执行的结果返回的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。<br>通过 React 的 diff，再由虚拟 DOM 来确保只对界面上真正变化的部分进行实际的DOM操作，这样就极大提升了性能。<br>batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。</p><blockquote><p>DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起30次（潜在的）布局重算，30次（潜在的）重绘。<br>当你在这个单独的 virtualDOM 树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。<br>一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。</p></blockquote><p><a href="https://www.jianshu.com/p/f75c1f0af3f0" target="_blank" rel="external">React中一个没人能解释清楚的问题——为什么要使用Virtual DOM</a></p><h2 id="React-diff"><a href="#React-diff" class="headerlink" title="React diff"></a>React diff</h2><p>React diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础。<br>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。<br>React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。<br>diff 策略（—为具体比对）<br>1.Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 — tree diff<br>2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 — component diff<br>3.对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 — element diff</p><h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%85.jpg" alt="tree-diff"></p><h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。<br>1.如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。<br>2.如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。<br>3.对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%851.jpg" alt="component diff"></p><h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。<br>1.INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。<br>2.MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。<br>3.REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。<br>React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，这也是为什么React建议我们在列表项目中添加key属性的原因！</p><p><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%852.jpg" alt="element diff"><br><a href="https://zhuanlan.zhihu.com/purerender/20346379" target="_blank" rel="external">知乎专栏-react diff，写的很不错</a></p><h2 id="webkit-渲染机制"><a href="#webkit-渲染机制" class="headerlink" title="webkit 渲染机制"></a>webkit 渲染机制</h2><p>先看下简单版的（我们从浏览器地址栏输入网址开始到web页面被完整的呈现在眼前做了哪些事，暂不考虑DNS缓存、本地资源缓存）<br>网址被DNS解析为IP地址 -&gt; 通过IP地址建立TCP连接 -&gt; 发送HTTP请求 -&gt; 服务器处理请求并返回响应 -&gt;  浏览器解析渲染页面 -&gt; 断开TCP连接</p><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>一般渲染引擎主要包括HTML解释器、CSS解释器、Javascript引擎、布局、绘图等模块。<br>HTML解释器 ：HTML解释器的工作就是将网络或者本地磁盘获取到的HTML网页和资源从字节流解释成DOM树的结构（首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（TOKENS），经过语法分析器构建成节点，最后这些节点被组建成一颗DOM树）<br>CSS解释器 ：CSS字符串被CSS解释器处理后变成渲染引擎的内部规则表示。（样式规则建立完成之后，webkit会保存规则结果，当DOM的节点建立之后，webkit会为可视化节点选择合适的样式信息，即作样式规则匹配）<br>Javascript引擎 ：将Javascript代码处理并执行，一个Javascript引擎可以包括以下几个部分<br>　　编译器 -&gt; 主要工作是将源代码编译成抽象语法树，在某些引擎中还包括将抽象语法树转换为字节码（JavascriptCore 引擎）。<br>　　解释器  -&gt; 在某些引擎中，解释器主要是接收字节码，解释执行字节码，同时也依赖垃圾回收机制等。<br>　　JIT工具 -&gt; 将字节码或者抽象语法树转换为本地代码 （V8 引擎）。<br>　　垃圾回收器和分析工具。<br>布局 ：计算RenderObject对象的位置、大小等信息。<br>绘图 ：将构建好的渲染内部表示模型使用图形库绘制出来。<br><img src="http://p26lefllv.bkt.clouddn.com/webkitflow.png" alt="webkit渲染过程"><br><a href="http://www.sohu.com/a/115715208_472885" target="_blank" rel="external">WEBKIT渲染不可不知的这四棵树</a><br><a href="https://www.cnblogs.com/tianheila/p/6413586.html" target="_blank" rel="external">webkit 渲染机制</a></p><h2 id="http1-1-amp-2较1有哪些新东西？"><a href="#http1-1-amp-2较1有哪些新东西？" class="headerlink" title="http1.1&amp;2较1有哪些新东西？"></a>http1.1&amp;2较1有哪些新东西？</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p><h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p><h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</p><h2 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h2><p>1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可<br>2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页<br>3.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br>4.重要内容不要用js输出：爬虫不会执行js获取内容（目前chrome浏览器可以了）<br>5.少用iframe：搜索引擎不会抓取iframe中的内容<br>6.非装饰性图片必须加alt<br>7.提高网站速度：网站速度是搜索引擎排序的一个重要指标</p><h2 id="点击穿透"><a href="#点击穿透" class="headerlink" title="点击穿透"></a>点击穿透</h2><p>如何产生：<br>    现在有两层DOM结构（但不嵌套），底层和弹出层（底层在弹出层下面且弹出层的投影在底层内部），弹出层有一个 touchend 事件，底层有一个 click 事件。<br>当点击弹出层就会触发 touchend 事件（弹出层立即消失，这时事件的 target 为弹出层），300ms后触发 click 事件（由于弹出层消失了，这时事件的 target 就为底层了）。<br>看出来了吗？这样就发生了‘点击穿透’。<br>产生的原因：<br>    click事件延迟且弹出层消失了。<br>解决方案：<br>    1.只用touch事件<br>    2.只用click事件（不推荐只用click事件，这样所有点击都有延迟了，实在要使用可以使用事件库 fastclick）<br>    3.可以延迟（&gt;300ms,好像不太科学）弹出层消失<br><a href="http://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="服务器’推‘技术"><a href="#服务器’推‘技术" class="headerlink" title="服务器’推‘技术"></a>服务器’推‘技术</h2><p>webSocket、Comet、轮询<br>Comet主要是利用客户端向服务器发出请求时，服务器发回响应内容，并利用javascript建立一个长时间链接的“长连接”，这个连接在没有接收到服务器或者没有到达连接时间限制时会一直等待服务器的消息，如果服务器有消息传来，立即显示最新信息。长连接每隔一段时间会重新向服务器发出连接请求。服务器在有新消息产生的时候立即检查消息的接收方是否存在长连接，如果存在马上发送，如果没有则不发送。</p><h2 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h2><p>1.cookie（一般不能存关键字段，最好存sessionID配合session使用）<br>2.session<br>3.url重写<br>4.隐藏input<br>5.ip地址</p><h2 id="img的title和alt有什么区别"><a href="#img的title和alt有什么区别" class="headerlink" title="img的title和alt有什么区别"></a>img的title和alt有什么区别</h2><p>title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。<br>alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p><h2 id="doctype是什么-举例常见doctype及特点"><a href="#doctype是什么-举例常见doctype及特点" class="headerlink" title="doctype是什么,举例常见doctype及特点"></a>doctype是什么,举例常见doctype及特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写</div><div class="line">&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</div><div class="line">现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</div><div class="line">在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</div><div class="line">HTML5不基于SGML，所以不用指定DTD</div></pre></td></tr></table></figure><h3 id="常见dotype"><a href="#常见dotype" class="headerlink" title="常见dotype"></a>常见dotype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</div><div class="line">HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">HTML4.01 Frameset:允许表现性元素，废弃元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</div><div class="line">XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</div><div class="line">XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</div><div class="line">HTML 5: &lt;!doctype html&gt;</div></pre></td></tr></table></figure><h2 id="HTML全局属性-global-attribute-有哪些"><a href="#HTML全局属性-global-attribute-有哪些" class="headerlink" title="HTML全局属性(global attribute)有哪些"></a>HTML全局属性(global attribute)有哪些</h2><p>accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素<br>class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class、classList属性获取元素<br>contenteditable: 指定元素内容是否可编辑<br>contextmenu: 自定义鼠标右键弹出菜单内容<br>data-*: 为元素增加自定义属性<br>dir: 设置元素文本方向<br>draggable: 设置元素是否可拖拽<br>dropzone: 设置元素拖放类型： copy, move, link<br>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果<br>id: 元素id，文档内唯一<br>lang: 元素内容的的语言<br>spellcheck: 是否启动拼写和语法检查<br>style: 行内css样式<br>tabindex: 设置元素可以获得焦点，通过tab可以导航<br>title: 元素相关的建议信息<br>translate: 元素和子孙节点内容是否需要本地化</p><h2 id="什么是web语义化-有什么好处"><a href="#什么是web语义化-有什么好处" class="headerlink" title="什么是web语义化,有什么好处"></a>什么是web语义化,有什么好处</h2><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。<br>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构<br>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息<br>为什么需要语义化：<br>1.去掉样式后页面呈现清晰的结构<br>2.搜索引擎更好地理解页面，有利于收录<br>3.便团队项目的可持续运作及维护<br>5.盲人使用读屏器更好地阅读</p><h2 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。<br>GET是最常用的方法，通常用于请求服务器发送某个资源。<br>HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分<br>PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它<br>POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。<br>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。<br>OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。<br>DELETE请求服务器删除请求URL指定的资源。</p><h2 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h2><p>首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF<br>首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束<br>请求头和消息实体之间有一个CRLF分隔<br>根据实际请求需要可能包含一个消息实体<br>一个请求报文例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</div><div class="line">Host: www.w3.org</div><div class="line">Connection: keep-alive</div><div class="line">Cache-Control: max-age=0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</div><div class="line">Referer: https://www.google.com.hk/</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</div><div class="line">Cookie: authorstyle=yes</div><div class="line">If-None-Match: &quot;2cc8-3e3073913b100&quot;</div><div class="line">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</div><div class="line"></div><div class="line">name=fanerge&amp;age=26</div></pre></td></tr></table></figure></p><h2 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h2><p>首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF<br>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部<br>响应头部和响应实体之间用一个CRLF空行分隔<br>最后是一个可能的消息实体<br>响应报文例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 08 Jul 2014 05:28:43 GMT</div><div class="line">Server: Apache/2</div><div class="line">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</div><div class="line">ETag: &quot;40d7-3e3073913b100&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: 16599</div><div class="line">Cache-Control: max-age=21600</div><div class="line">Expires: Tue, 08 Jul 2014 11:28:43 GMT</div><div class="line">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</div><div class="line">Content-Type: text/html; charset=iso-8859-1</div><div class="line"></div><div class="line">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</div></pre></td></tr></table></figure></p><h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><h3 id="content方面"><a href="#content方面" class="headerlink" title="content方面"></a>content方面</h3><p>减少HTTP请求：合并文件、CSS精灵、inline Image<br>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br>避免重定向：多余的中间访问<br>使Ajax可缓存<br>非必须组件延迟加载<br>未来所需组件预加载<br>减少DOM元素数量<br>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br>减少iframe数量<br>不要404</p><h3 id="Server方面"><a href="#Server方面" class="headerlink" title="Server方面"></a>Server方面</h3><p>使用CDN<br>添加Expires或者Cache-Control响应头<br>对组件使用Gzip压缩<br>配置ETag<br>Flush Buffer Early<br>Ajax使用GET进行请求<br>避免空src的img标签</p><h3 id="Cookie方面"><a href="#Cookie方面" class="headerlink" title="Cookie方面"></a>Cookie方面</h3><p>减小cookie大小<br>引入资源的域名不要包含cookie</p><h3 id="css方面"><a href="#css方面" class="headerlink" title="css方面"></a>css方面</h3><p>将样式表放到页面顶部<br>不使用CSS表达式<br>使用不使用@import<br>不使用IE的Filter</p><h3 id="Javascript方面"><a href="#Javascript方面" class="headerlink" title="Javascript方面"></a>Javascript方面</h3><p>将脚本放到页面底部<br>将javascript和css从外部引入<br>压缩javascript和css<br>删除不需要的脚本<br>减少DOM访问<br>合理设计事件监听器</p><h3 id="图片方面"><a href="#图片方面" class="headerlink" title="图片方面"></a>图片方面</h3><p>优化图片：根据实际颜色需要选择色深、压缩<br>优化css精灵<br>不要在HTML中拉伸图片<br>保证favicon.ico小并且可缓存</p><h3 id="移动方面"><a href="#移动方面" class="headerlink" title="移动方面"></a>移动方面</h3><p>保证组件小于25k<br>Pack Components into a Multipart Document<br><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">yahoo Best Practices for Speeding Up Your Web Site</a></p><h2 id="什么是渐进增强"><a href="#什么是渐进增强" class="headerlink" title="什么是渐进增强"></a>什么是渐进增强</h2><p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。<br>核心原则如下:<br>所有浏览器都必须能访问基本内容<br>所有浏览器都必须能使用基本功能<br>所有内容都包含在语义化标签中<br>通过外部CSS提供增强的布局<br>通过非侵入式、外部javascript提供增强功能<br>end-user web browser preferences are respected</p><h2 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h2><p>1XX：信息状态码<br>100 Continue：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求之后向客户端发送一个最终响应。<br>101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。<br>2XX：成功状态码<br>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回<br>201 Created：<br>202 Accepted：<br>203 Non-Authoritative Information：<br>204 No Content：<br>205 Reset Content：<br>206 Partial Content：<br>3XX：重定向<br>300 Multiple Choices：<br>301 Moved Permanently：<br>302 Found：<br>303 See Other：<br>304 Not Modified：<br>305 Use Proxy：<br>306 （unused）：<br>307 Temporary Redirect：<br>4XX：客户端错误<br>400 Bad Request:<br>401 Unauthorized:<br>402 Payment Required:<br>403 Forbidden:<br>404 Not Found:<br>405 Method Not Allowed:<br>406 Not Acceptable:<br>407 Proxy Authentication Required:<br>408 Request Timeout:<br>409 Conflict:<br>410 Gone:<br>411 Length Required:<br>412 Precondition Failed:<br>413 Request Entity Too Large:<br>414 Request-URI Too Long:<br>415 Unsupported Media Type:<br>416 Requested Range Not Satisfiable:<br>417 Expectation Failed:<br>5XX: 服务器错误<br>500 Internal Server Error:<br>501 Not Implemented:<br>502 Bad Gateway:<br>503 Service Unavailable:<br>504 Gateway Timeout:<br>505 HTTP Version Not Supported:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-virtualDOM（batching）&quot;&gt;&lt;a href=&quot;#React-virtualDOM（batching）&quot; class=&quot;headerlink&quot; title=&quot;React virtualDOM（batching）&quot;&gt;&lt;/a&gt;React vi
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>IndexDB探索之路</title>
    <link href="https://fanerge.github.io/2018/html5-IndexDB.html"/>
    <id>https://fanerge.github.io/2018/html5-IndexDB.html</id>
    <published>2018-02-06T12:20:04.000Z</published>
    <updated>2018-03-17T12:34:15.757Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/indexedDB/static/">demo地址</a></p><h1 id="什么是-IndexDB？"><a href="#什么是-IndexDB？" class="headerlink" title="什么是 IndexDB？"></a>什么是 IndexDB？</h1><p>IndexedDB 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供索引功能以实现高性能查找. 像其他基于 SQL 的 关系型数据库管理系统 (RDBMS) 一样, IndexedDB 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的.</p><h2 id="IndexDB-的特点"><a href="#IndexDB-的特点" class="headerlink" title="IndexDB 的特点"></a>IndexDB 的特点</h2><p>IndexDB 和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。<br>IndexDB API包含异步(asynchronous) API 和同步(synchronous)API两种。  异步API适合大多数情况, 同步API必须同 WebWorkers一同使用.</p><h2 id="为什么我们要使用-IndexDB？"><a href="#为什么我们要使用-IndexDB？" class="headerlink" title="为什么我们要使用 IndexDB？"></a>为什么我们要使用 IndexDB？</h2><p>WebStorage在浏览器中有大小限制，存放较大的数据就不能满足了。<br>IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql.<br>IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）.</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IndexedDB-数据库使用key-value键值对储存数据"><a href="#IndexedDB-数据库使用key-value键值对储存数据" class="headerlink" title="IndexedDB 数据库使用key-value键值对储存数据"></a>IndexedDB 数据库使用key-value键值对储存数据</h2><p>key可以是二进制对象。<br>values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。<br>你可以对对象的某个属性创建索引（index）以实现快速查询和列举排序。</p><h2 id="IndexedDB-是事务模式的数据库"><a href="#IndexedDB-是事务模式的数据库" class="headerlink" title="IndexedDB 是事务模式的数据库"></a>IndexedDB 是事务模式的数据库</h2><p>任何操作都发生在事务(transaction)中。<br>IndexedDB API提供了索引(indexes), 表(tables), 指针(cursors)等等,<br>但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。<br>当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。<br>如果没有事务操作的支持，这两个实例就会互相影响对方的修改。</p><h2 id="IndexedDB-API-基本上是异步的"><a href="#IndexedDB-API-基本上是异步的" class="headerlink" title="IndexedDB API 基本上是异步的"></a>IndexedDB API 基本上是异步的</h2><p>IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。<br>执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。<br>当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。<br>类似于XMLHttpRequest。</p><h2 id="IndexedDB数据库“请求”无处不在"><a href="#IndexedDB数据库“请求”无处不在" class="headerlink" title="IndexedDB数据库“请求”无处不在"></a>IndexedDB数据库“请求”无处不在</h2><p>数据库“请求”负责接受成功或失败的DOM事件。<br>每一个“请求”都包含onsuccess和onerror事件属性，同时你还对“事件”调用addEventListener()和removeEventListener()。<br>“请求”还包括readyState，result和errorCode属性，用来表示“请求”的状态。<br>result属性尤其神奇，他可以根据“请求”生成的方式变成不同的东西，例如：IDBCursor实例、刚插入数据库的数值对应的键值（key）等。</p><h2 id="IndexedDB在结果准备好之后通过DOM事件通知用户"><a href="#IndexedDB在结果准备好之后通过DOM事件通知用户" class="headerlink" title="IndexedDB在结果准备好之后通过DOM事件通知用户"></a>IndexedDB在结果准备好之后通过DOM事件通知用户</h2><p>DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。<br>DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。<br>成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。<br>这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。</p><h2 id="IndexedDB是面向对象的"><a href="#IndexedDB是面向对象的" class="headerlink" title="IndexedDB是面向对象的"></a>IndexedDB是面向对象的</h2><p>indexedDB不是用二维表来表示集合的关系型数据库。这一点非常重要，将影响你设计和建立你的应用程序。​​​​<br>传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象存储(object Store)，只要这种数据一个JavaScript对象即可。<br>每个对象存储都有一个索引(index)集合以方便查询和迭代遍历。</p><h2 id="indexedDB不使用结构化查询语言（SQL）"><a href="#indexedDB不使用结构化查询语言（SQL）" class="headerlink" title="indexedDB不使用结构化查询语言（SQL）"></a>indexedDB不使用结构化查询语言（SQL）</h2><p>它通过索引(index)所产生的指针(cursor)来完成查询操作，从而使你可以迭代遍历到结果集合。</p><h2 id="IndexedDB遵循同源（same-origin）策略"><a href="#IndexedDB遵循同源（same-origin）策略" class="headerlink" title="IndexedDB遵循同源（same-origin）策略"></a>IndexedDB遵循同源（same-origin）策略</h2><p>“源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。<br>在同一个“源”内的所有数据库都有唯一、可区别的名称。</p><h1 id="使用-IndexedDB"><a href="#使用-IndexedDB" class="headerlink" title="使用 IndexedDB"></a>使用 IndexedDB</h1><h2 id="检测浏览器支持情况"><a href="#检测浏览器支持情况" class="headerlink" title="检测浏览器支持情况"></a>检测浏览器支持情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (window.indexedDB) &#123;</div><div class="line">// todo</div><div class="line">&#125; else &#123;</div><div class="line">alert(&apos;您的浏览器不支持indexdb&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我将会以demo来做常用的数据库操作说明，使用火狐浏览器做测试。</p><h2 id="新建数据库-关闭数据库"><a href="#新建数据库-关闭数据库" class="headerlink" title="新建数据库/关闭数据库"></a>新建数据库/关闭数据库</h2><p>indexedDB 有一个open(indexDbName[, version])，这个方法会打开某个数据库，若不存在则新建。<br>第一个参数为数据库名称 ‘demo’，第二个参数为 版本号。<br>db为打开数据库成功回掉 event.target.result 戴白哦数据库实例，有 close() 为关闭该数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function createDatabase(indexDbName) &#123;</div><div class="line"></div><div class="line">// 不存在则新建，存在则打开</div><div class="line">let openRequest = indexedDB.open(indexDbName);</div><div class="line"></div><div class="line">openRequest.onerror = function(event) &#123;</div><div class="line">        console.log(&quot;Database error: &quot; + event.target.errorCode);</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">console.log(&quot;Database created&quot;);</div><div class="line">let db = event.target.result;</div><div class="line">// db.close();</div><div class="line">console.log(&quot;this is :&quot;+db);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//更改数据库，或者存储对象时候在这里处理</div><div class="line">openRequest.onupgradeneeded = function (e) &#123;</div><div class="line">console.log(e);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBIns.png" alt="新建数据库"></p><h2 id="确定数据结构并添加数据"><a href="#确定数据结构并添加数据" class="headerlink" title="确定数据结构并添加数据"></a>确定数据结构并添加数据</h2><p>onupgradeneeded 唯一可以修改数据库结构的地方。<br>在 indexedDB 中一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。<br>创建 objectStore 的方法为数据库实例的 createObjectStore(name[, options]);<br>删除 objectStore 的方法为数据库实例的 deleteObjectStore(name);<br>其中options 有两个可选key，分别是 keyPath（选择objectStore中某个指定字段作为键值）、autoIncrement（若为true，objectStore有一个key generator）<br>我们创建好的 objectStore 也有一些方法：<br>createIndex(indexName, keyPath[, objectParameters]) 该方法作用为创建一个索引来通过 indexName 搜索 objectStore 里的数据。<br>objectStore.add(value[, key]) 该方法作用为将数据添加到 objectStore 中。<br>介绍了相关的方法，我们就通过循环来向 objectStore 添加数据。<br>下面是具体实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function insertData(indexDbName)&#123;</div><div class="line">// 带写入的数据</div><div class="line">const customerData = [</div><div class="line">  &#123; ssn: &quot;444-44-4444&quot;, name: &quot;Bill&quot;, age: 35, email: &quot;bill@company.com&quot; &#125;,</div><div class="line">  &#123; ssn: &quot;555-55-5555&quot;, name: &quot;Donna&quot;, age: 32, email: &quot;donna@home.org&quot; &#125;</div><div class="line">];</div><div class="line"></div><div class="line">// 如果在没有新建数据库时写入数据，这里只能带高版本的数据库版本才能出发 onupgradeneeded 事件</div><div class="line">let openRequest = indexedDB.open(indexDbName, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">console.log(&quot;Database created&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onupgradeneeded = function(event) &#123;</div><div class="line"></div><div class="line">console.log(&quot;开始写入数据&quot;);</div><div class="line">let db = event.target.result;</div><div class="line">// keyPath、autoIncrement</div><div class="line">let objectStore = db.createObjectStore(&quot;customers&quot;, &#123; keyPath: &quot;ssn&quot; &#125;);</div><div class="line">objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125;);</div><div class="line">objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, &#123; unique: true &#125;);</div><div class="line"></div><div class="line">for (let item of customerData) &#123;</div><div class="line">objectStore.add(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 删除 objectStore</div><div class="line">// db.deleteObjectStore(&quot;customers&quot;);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexed%20DBIns1.png" alt="新建数据库"><br>PS： 这里有个坑，需要说明一下。<br>onupgradeneeded事件在下列情况下被触发：<br>1.数据库第一次被打开时即新建<br>2.打开数据库时指定的版本号高于当前被持久化的数据库版本号</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>添加数据在 onsuccess 钩子中进行。<br>IndexedDB 添加数据通过事务来添加数据。<br>下面重点介绍下 transaction(storeNames[, mode]);<br>第一个参数是事务希望跨越的对象存储空间的列表。<br>第二个参数事务中可以执行的访问类型。<br>返回一个事务对象。<br>事务可以接收三种不同类型的 DOM 事件： error，abort，以及 complete。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function addData(storeName) &#123;</div><div class="line">const datas = [</div><div class="line">  &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;,</div><div class="line">  &#123; ssn: &quot;777-77-7777&quot;, name: &quot;sdsd&quot;, age: 22, email: &quot;sdsd@home.org&quot; &#125;</div><div class="line">];</div><div class="line"></div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction=db.transaction(storeName,&apos;readwrite&apos;);</div><div class="line">        let store=transaction.objectStore(storeName); </div><div class="line"></div><div class="line">for(let i=0;i&lt;datas.length;i++)&#123;</div><div class="line">            store.add(datas[i]);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBAdd.png" alt="添加数据"></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>同样删除数据也使用 transaction。<br>唯一区别是使用了 objectStore的 delete(key)，该方法为删除指定key的数据项。<br>objectStore 还有一个方法 clear()清空该 store 中的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function del66(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.delete(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">console.log(&apos;删除成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;删除失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>同样查找数据也使用 transaction。<br>唯一区别是使用了 objectStore的 get(key)，该方法为删除指定key的数据项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function getDataByKey(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.get(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">let item =event.target.result; </div><div class="line">console.log(item); // 获得的该数据项</div><div class="line">console.log(&apos;查找成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;查找失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>可以调用object store的put方法更新数据，会自动替换键值相同的记录，达到更新目的，没有相同的则添加，以使用keyPath做键为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function updateDataByKey(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.get(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">let item =event.target.result; </div><div class="line"> // &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;</div><div class="line">item.ssn = &quot;666-66-6666&quot;</div><div class="line">item.name = &quot;yuzhenfan&quot;</div><div class="line">item.age = 18</div><div class="line">item.email = &quot;yzf@alipay.com&quot;</div><div class="line">            store.put(item); </div><div class="line">console.log(&apos;更新成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;更新失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBupdate.png" alt="更新数据"></p><blockquote><p>   参考文档<br><a href="https://www.cnblogs.com/lovelgx/articles/6026957.html" target="_blank" rel="external">数据库写入时机</a><br><a href="http://www.php.cn/html5-tutorial-359628.html" target="_blank" rel="external">html5使用indexdb的代码实例分享</a><br><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="external">wiki-数据库事务</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IndexedDB" target="_blank" rel="external">MDN-IndexedDB</a><br><a href="http://w3c.github.io/IndexedDB/" target="_blank" rel="external">w3c-IndexDB-API</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB" target="_blank" rel="external">IndexDB-Guides</a><br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（一：基本使用）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/indexedDB/static/&quot;&gt;demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是-IndexDB？&quot;&gt;&lt;a href=&quot;#什么是-IndexDB？&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>html5-svg开发手册</title>
    <link href="https://fanerge.github.io/2018/html5-svg%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/2018/html5-svg开发手册.html</id>
    <published>2018-01-30T12:28:14.000Z</published>
    <updated>2018-05-07T11:56:01.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h2><ol><li>img的src</li><li>background-image: url()</li><li>object: data</li><li>embed: src</li><li>foreignObject<br>foreignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。<h2 id="样式的写法（优先级逐渐降低）"><a href="#样式的写法（优先级逐渐降低）" class="headerlink" title="样式的写法（优先级逐渐降低）"></a>样式的写法（优先级逐渐降低）</h2>1.内联style<br><code>&lt;g style=&quot;fill: red;&quot;&gt;&lt;/g&gt;</code><br>2.class<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;g class=&quot;font&quot;&gt;&lt;/g&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[</div><div class="line">.font &#123;</div><div class="line">fill: red;</div><div class="line">&#125;</div><div class="line">]]&gt;&lt;/style&gt;</div></pre></td></tr></table></figure></li></ol><p>3.外链样式表<br><code>&lt;?xml-stylesheet href=&quot;style.css&quot; type=&quot;text\css&quot; ?&gt;</code><br>4.样式属性<br><code>&lt;g fill=&quot;red&quot;&gt;&lt;/g&gt;</code></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;![CDATA[解析器忽略的内容]]&gt;</div><div class="line">作用：xml解析器忽略解析，将表示为纯文本。</div></pre></td></tr></table></figure><p>默认用户坐标（视口svg的width和height）<br>指定用户坐标（viewBox属性）<br>保持宽高比（SVG的宽高和viewBox的宽高比是不一样），使用preserveAspectRatio属性<br>preserveAspectRatio=”xMidYMid meet”<br>第1个值表示，viewBox如何与SVG viewport对齐；第2个值表示，如何维持高宽比（如果有）。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><p>class、style</p><h2 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h2><p>color、display、opacity、overflow<br>fill、fill-opacity、fill-rule<br>stroke、stroke-dasharray、stroke-dashoffset、stroke-linecap、stroke-linejoin、stroke-miterlimit、stroke-opacity、stroke-width</p><h2 id="动画事件属性"><a href="#动画事件属性" class="headerlink" title="动画事件属性"></a>动画事件属性</h2><p>onbegin, onend, onload, onrepeat</p><h2 id="动画属性目标属性"><a href="#动画属性目标属性" class="headerlink" title="动画属性目标属性"></a>动画属性目标属性</h2><p>attributeType, attributeName</p><h2 id="动画定时属性"><a href="#动画定时属性" class="headerlink" title="动画定时属性"></a>动画定时属性</h2><p>begin, dur, end, min, max, restart, repeatCount, repeatDur, fill</p><h2 id="动画值属性"><a href="#动画值属性" class="headerlink" title="动画值属性"></a>动画值属性</h2><p>calcMode, values, keyTimes, keySplines, from, to, by, autoReverse, accelerate, decelerate</p><h2 id="动画累加属性"><a href="#动画累加属性" class="headerlink" title="动画累加属性"></a>动画累加属性</h2><p>additive, accumulate</p><h2 id="条件处理属性"><a href="#条件处理属性" class="headerlink" title="条件处理属性"></a>条件处理属性</h2><p>requiredExtensions, requiredFeatures, systemLanguage.</p><h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><p>id, xml:base, xml:lang, xml:space</p><h2 id="文档事件属性"><a href="#文档事件属性" class="headerlink" title="文档事件属性"></a>文档事件属性</h2><p>onabort, onerror, onresize, onscroll, onunload, onzoom</p><h2 id="过滤器原始属性"><a href="#过滤器原始属性" class="headerlink" title="过滤器原始属性"></a>过滤器原始属性</h2><p>height, result, width, x, y</p><h2 id="图形事件属性"><a href="#图形事件属性" class="headerlink" title="图形事件属性"></a>图形事件属性</h2><p>onactivate, onclick, onfocusin, onfocusout, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup</p><h1 id="svg-元素"><a href="#svg-元素" class="headerlink" title="svg 元素"></a>svg 元素</h1><h2 id="基本形状元素"><a href="#基本形状元素" class="headerlink" title="基本形状元素"></a>基本形状元素</h2><h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><p>line元素是一个SVG基本形状，用来创建一条连接两个点的线。<br>属性：x1、y1、x2、y2<br><code>&lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;5&quot; y2=&quot;5&quot;&gt;&lt;/line&gt;</code></p><h3 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h3><p>用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形。<br>属性：x、y、width、height、rx、ry<br><code>&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; rx=&quot;3&quot; ry=&quot;3&quot;&gt;&lt;/rect&gt;</code></p><h3 id="circle"><a href="#circle" class="headerlink" title="circle"></a>circle</h3><p>用来创建圆,基于一个圆心和一个半径。<br>属性：cx、cy、r<br><code>&lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;5&quot;&gt;&lt;/circle&gt;</code></p><h3 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse"></a>ellipse</h3><p>用来创建一个椭圆，基于一个中心坐标以及它们的x半径和y半径。<br>利用transform属性椭圆的倾斜。<br>属性：cx、cy、rx、ry<br><code>&lt;ellipse cx=&quot;60&quot; cy=&quot;60&quot; rx=&quot;50&quot; ry=&quot;25&quot;/&gt;</code></p><h3 id="polygon"><a href="#polygon" class="headerlink" title="polygon"></a>polygon</h3><p>polygon元素定义了一个由一组点左边的构成的闭合多边形形状。<br>属性：points<br><code>&lt;polygon points=&quot;100,40 100,80 60,100 20,80 20,40&quot;/&gt;</code></p><h3 id="polyline"><a href="#polyline" class="headerlink" title="polyline"></a>polyline</h3><p>用来创建一系列直线连接多个点。典型的一个polyline是用来创建一个开放的形状，最后一点不与第一点相连。<br>属性：points<br><code>&lt;polyline fill=&quot;none&quot; stroke=&quot;black&quot; points=&quot;20,100 40,60 70,80 100,20&quot;/&gt;</code></p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path元素是用来定义形状的通用元素。所有的基本形状都可以用path元素来创建。<br>属性：d（data）、pathLength<br>PS：d属性有下列值（大写字母为绝对坐标，小写字母为相对坐标）<br>M（m）-x，y-移动到给定坐标。<br>L（l）-x，y-绘制一条到给定坐标的线，可以提供多组坐标来绘制折线。<br>H（h）-x-绘制一条到给定x坐标的水平线。<br>V（v）-y-绘制一条到指定y坐标的竖线。<br>A（a）-rx ry x-axis-rotation large-arc-flag sweep-flag x y。<br>Q（q）-x1，y1，x，y-绘制一条从当前点到（x，y），控制点为（x1，y1）的二次贝塞尔曲线。<br>T（t）-x，y-绘制一条从当前点到（x，y）的二次贝塞尔曲线，控制点是前一个Q命令的控制点的中心对称点。如果没有前一条曲线，当前点会被用作控制点。<br>C（c）-x1，y1，x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，x1和x2分别为开始和终点控制点。<br>S（s）-x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，使用x2作为终点控制点，开始控制点为前一个C命令的终点控制点的中心对称点。<br><code>&lt;path d=&quot;M 100 100 L 300 100 L 200 300 z&quot; /&gt;</code><br>PS：x-axis-rotation为x轴旋转角度，large-arc-flag为角度大小，sweep-flag（弧线方向）<br>large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。<br>sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。</p><h2 id="功能元素"><a href="#功能元素" class="headerlink" title="功能元素"></a>功能元素</h2><h3 id="title（提升可访问性）"><a href="#title（提升可访问性）" class="headerlink" title="title（提升可访问性）"></a>title（提升可访问性）</h3><p>SVG绘图中的每个窗口元素或图形元素都可以提供一个title描述性字符串，该描述只能是纯文本。<br>title元素必须是它的父元素的第一个子元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;g&gt;</div><div class="line">   &lt;title&gt;SVG Title Demo example&lt;/title&gt;</div><div class="line">   &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;200&quot; height=&quot;50&quot; style=&quot;fill:none; stroke:blue; stroke-width:1px&quot;/&gt;</div><div class="line">&lt;desc&gt;提升可访问性&lt;/desc&gt;</div><div class="line">&lt;/g&gt;</div></pre></td></tr></table></figure></p><h3 id="desc（提升可访问性）"><a href="#desc（提升可访问性）" class="headerlink" title="desc（提升可访问性）"></a>desc（提升可访问性）</h3><p>SVG绘画中的每个容器元素或图形元素都可以提供一个desc描述性字符串，这些描述只是纯文本的。</p><h3 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h3><p>SVG 允许我们定义以后需要重复使用的图形元素， 建议把所有需要再次使用的引用元素定义在defs元素里面。<br>需要使用\<use\>元素来呈现defs定义的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">&lt;linearGradient id=&quot;Gradient01&quot;&gt;</div><div class="line">&lt;stop offset=&quot;20%&quot; stop-color=&quot;#39F&quot; /&gt;</div><div class="line">&lt;stop offset=&quot;90%&quot; stop-color=&quot;#F3F&quot; /&gt;</div><div class="line">&lt;/linearGradient&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;60&quot; height=&quot;10&quot; fill=&quot;url(#Gradient01)&quot;  /&gt;</div><div class="line">PS：radialGradient、linearGradient、pattern等元素必须要放在defs元素中</div></pre></td></tr></table></figure></use\></p><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>use元素在SVG文档内取得目标节点，并在别的地方复制它们。<br>属性：x、y、width、height、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;g id=&quot;Port&quot;&gt;</div><div class="line">      &lt;circle style=&quot;fill: inherit;&quot; r=&quot;10&quot;/&gt;</div><div class="line">    &lt;/g&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;use x=&quot;50&quot; y=&quot;10&quot; href=&quot;#Port&quot; /&gt;</div><div class="line">&lt;use x=&quot;50&quot; y=&quot;30&quot; href=&quot;#Port&quot; class=&quot;classA&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>使用 SVG 的锚元素\<a\>定义一个超链接。<br>属性：href、target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;www.alipay.com&quot; target=&quot;_blank&quot;&gt;</div><div class="line">    &lt;rect height=&quot;30&quot; width=&quot;120&quot; y=&quot;0&quot; x=&quot;0&quot; rx=&quot;15&quot;/&gt;</div><div class="line">    &lt;text fill=&quot;white&quot; text-anchor=&quot;middle&quot; y=&quot;21&quot; x=&quot;60&quot;&gt;SVG on MDN&lt;/text&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure></a\></p><h3 id="clipPath"><a href="#clipPath" class="headerlink" title="clipPath"></a>clipPath</h3><p>clipPath用于指定可绘制区域（超出了剪切路径所指定的区域，将不会被绘制。）。<br>属性：clipPathUnits=”userSpaceOnUse’或’objectBoundingBox”。第二个值childern一个对象的边框，会使用掩码的一小部分单位（默认：”userSpaceOnUse”）”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;clipPath id=&quot;myClip&quot;&gt;</div><div class="line">      &lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;20&quot;/&gt;</div><div class="line">    &lt;/clipPath&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; clip-path=&quot;url(#myClip)&quot;/&gt;</div></pre></td></tr></table></figure></p><p>PS：其他元素通过clip-path=”引用剪贴路径和引用剪贴路径交叉”</p><h3 id="color-profile"><a href="#color-profile" class="headerlink" title="color-profile"></a>color-profile</h3><p>该元素允许描述用于图像的颜色配置文件。<br>属性：local、name、rendering-intent、href</p><h3 id="foreignObject"><a href="#foreignObject" class="headerlink" title="foreignObject"></a>foreignObject</h3><p>foreignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。这个被包含的外来图形内容服从SVG变形和合成。<br>foreignObject元素通常与 switch 元素和requiredExtensions属性联用，来做兼容。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>SVG文档中的SVG元素包含图像信息。它表现为图像文件或者其他SVG文件。<br>属性：x、y、width、height、href、preserveAspectRatio（控制图像比例）</p><h3 id="linearGradient"><a href="#linearGradient" class="headerlink" title="linearGradient"></a>linearGradient</h3><p>linearGradient元素用来定义线性渐变，用于图形元素的填充或描边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;linearGradient id=&quot;MyGradient&quot;&gt;</div><div class="line">        &lt;stop offset=&quot;5%&quot;  stop-color=&quot;green&quot;/&gt;</div><div class="line">        &lt;stop offset=&quot;95%&quot; stop-color=&quot;gold&quot;/&gt;</div><div class="line">    &lt;/linearGradient&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;rect fill=&quot;url(#MyGradient)&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;</div></pre></td></tr></table></figure></p><p>属性：gradientUnits、gradientTransform、x1、y1、x2、y2、spreadMethod、href</p><h3 id="radialGradient"><a href="#radialGradient" class="headerlink" title="radialGradient"></a>radialGradient</h3><p>radialGradient用来定义径向，用于图形元素的填充或描边。<br>属性：gradientUnits、gradientTransform、cx、cy、r、fx、fy、spreadMethod、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;radialGradient id=&quot;exampleGradient&quot;&gt;</div><div class="line">      &lt;stop offset=&quot;10%&quot; stop-color=&quot;gold&quot;/&gt;</div><div class="line">      &lt;stop offset=&quot;95%&quot; stop-color=&quot;green&quot;/&gt;</div><div class="line">    &lt;/radialGradient&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;circle fill=&quot;url(#exampleGradient)&quot; cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>一个渐变上的颜色坡度，是用stop元素定义的。<br>stop元素可以是linearGradient、radialGradient的子元素。</p><h3 id="marker"><a href="#marker" class="headerlink" title="marker"></a>marker</h3><p>marker元素定义了在特定的path、line、polyline、polygon上绘制的箭头或者多边标记图形。<br>属性：marker-end、marker-mid、marker-start、markerUnits、refx、refy、markerWidth、markerHeight、orient<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;marker id=&quot;Triangle&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;1&quot; refY=&quot;5&quot; markerWidth=&quot;6&quot; markerHeight=&quot;6&quot; orient=&quot;auto&quot;&gt;</div><div class="line">      &lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; /&gt;</div><div class="line">    &lt;/marker&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;polyline points=&quot;10,90 50,80 90,20&quot; fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#Triangle)&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><p>在SVG中，你可以指一个透明的遮罩层和当前对象合成，形成背景。属性mask用来引用一个遮罩元素。<br>属性：maskUnits、maskContentUnits、x、y、width、height</p><h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>metadata是数据的结构化数据。</p><h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>使用预定义的图形对一个对象进行填充或描边，就要用到pattern元素，在下轴或y轴上重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;pattern id=&quot;Triangle&quot; width=&quot;10&quot; height=&quot;10&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;</div><div class="line">&lt;polygon points=&quot;5,0 10,10 0,10&quot;/&gt;</div><div class="line">&lt;/pattern&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;circle cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;url(#Triangle)&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>text元素定义了一个由文字组成的图形。注意：我们可以将渐变、图案、剪切路径、遮罩或者滤镜应用到text上。<br>属性：x、y、dx、dy、text-anchor、rotate、textLength、lengthAdjust<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;text x=&quot;0&quot; y=&quot;20&quot; transform=&quot;rotate(30 20,40)&quot;&gt;</div><div class="line">    SVG Text Rotation example</div><div class="line">&lt;/text&gt;</div></pre></td></tr></table></figure></p><h3 id="textPath"><a href="#textPath" class="headerlink" title="textPath"></a>textPath</h3><p>textPath使用path来展示文字。<br>属性：startOffset、method、spacing、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path id=&quot;MyPath&quot; fill=&quot;none&quot; stroke=&quot;red&quot; d=&quot;M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50&quot; /&gt;</div><div class="line">&lt;text&gt;</div><div class="line">&lt;textPath href=&quot;#MyPath&quot;&gt;</div><div class="line">  The quick brown fox jumps over the lazy dog.</div><div class="line">&lt;/textPath&gt;</div><div class="line">&lt;/text&gt;</div></pre></td></tr></table></figure></p><h3 id="tspan"><a href="#tspan" class="headerlink" title="tspan"></a>tspan</h3><p>在text元素中，利用内含的tspan元素，可以调整文本和字体的属性以及当前文本的位置、绝对或相对坐标值。<br>属性：x、y、dx、dy、rotate、textLength、lengthAdjust<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;text x=&quot;15&quot; y=&quot;30&quot;&gt;</div><div class="line">    You are </div><div class="line">    &lt;tspan&gt;not&lt;/tspan&gt; </div><div class="line">    a banana</div><div class="line">&lt;/text&gt;</div></pre></td></tr></table></figure></p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view元素是查看图片的一个限定方法，就像一个缩放级别或者一个详细视图。<br>属性：viewBox、preserveAspectRatio、zoomAndPan、viewTarget</p><h2 id="不显示元素"><a href="#不显示元素" class="headerlink" title="不显示元素"></a>不显示元素</h2><h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><p>元素g是用来组合对象的容器，对与transform、属性会作用与子元素。<br>通过\<use\>    元素来实现组合对象的复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;g stroke=&quot;green&quot; fill=&quot;white&quot; stroke-width=&quot;5&quot;&gt;</div><div class="line">    &lt;circle cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;</div><div class="line">    &lt;circle cx=&quot;40&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;</div><div class="line">&lt;/g&gt;</div></pre></td></tr></table></figure></use\></p><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>一个SVG脚本元素等同于HTML中的script元素。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set元素可以用来设定一个属性值，并为该值赋予一个持续时间。</p><h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>style元素元素样式表直接在SVG内容中间嵌入。</p><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>如果svg不是根元素，svg 元素可以用于在当前文档内嵌套一个独立的svg片段 。<br>这个独立片段拥有独立的视口和坐标系统。<br>属性：version、baseProfile、x、y、width、height、preserveAspectRatio、contentScriptType、contentStyleType、viewBox</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch元素对它的直接子元素上的属性requiredFeatures、属性requiredExtensions 和 属性systemLanguage按照顺序进行评估，然后处理和呈现第一个评估为true的子元素。<br>属性：allowReorder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;switch&gt;</div><div class="line">&lt;text systemLanguage=&quot;ar&quot;&gt;مرحبا&lt;/text&gt;</div><div class="line">&lt;text systemLanguage=&quot;ja&quot;&gt;こんにちは&lt;/text&gt;</div><div class="line">&lt;text&gt;☺&lt;/text&gt;</div><div class="line">   &lt;/switch&gt;</div></pre></td></tr></table></figure></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。<br>symbol元素对图形的作用是在同一文档中多次使用，添加结构和语义。<br>属性：preserveAspectRatio、viewBox<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt;</div><div class="line">&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot;/&gt;</div><div class="line">&lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot;/&gt;</div><div class="line">&lt;/symbol&gt;</div><div class="line">&lt;!-- actual drawing by &quot;use&quot; element --&gt;</div><div class="line">&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot;/&gt;</div><div class="line">&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot;/&gt;</div></pre></td></tr></table></figure></p><h2 id="动画元素"><a href="#动画元素" class="headerlink" title="动画元素"></a>动画元素</h2><h3 id="animate"><a href="#animate" class="headerlink" title="animate"></a>animate</h3><p>动画元素放在形状元素的内部，用来定义一个元素的某个属性根据时间点如何改变。<br>属性：attributeName、attributeType（CSS/XML）、from、to、dur、repeatCount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;</div><div class="line">    &lt;animate attributeType=&quot;XML&quot; attributeName=&quot;x&quot; from=&quot;-100&quot; to=&quot;120&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;/&gt;</div><div class="line">&lt;/rect&gt;</div></pre></td></tr></table></figure></p><h3 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h3><p>animateMotion元素导致引用的元素沿着运动路径移动。<br>属性：calcMode、path、keyPoints、rotate、origin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110&quot; stroke=&quot;lightgrey&quot; stroke-width=&quot;2&quot;  fill=&quot;none&quot; id=&quot;theMotionPath&quot;/&gt;</div><div class="line">&lt;circle cx=&quot;&quot; cy=&quot;&quot; r=&quot;5&quot; fill=&quot;red&quot;&gt;</div><div class="line">    &lt;animateMotion dur=&quot;6s&quot; repeatCount=&quot;indefinite&quot;&gt;</div><div class="line">&lt;mpath xlink:href=&quot;#theMotionPath&quot;/&gt;</div><div class="line">    &lt;/animateMotion&gt;</div><div class="line">&lt;/circle&gt;</div></pre></td></tr></table></figure></p><h3 id="mpath"><a href="#mpath" class="headerlink" title="mpath"></a>mpath</h3><p>animateMotion元素的 mpath 子元素使 animateMotion 元素能够引用一个外部的 path 元素作为运动路径的定义。<br>属性：href</p><h3 id="animateTransform"><a href="#animateTransform" class="headerlink" title="animateTransform"></a>animateTransform</h3><p>animateTransform元素变动了目标元素上的一个变形属性，从而允许动画控制转换、缩放、旋转或斜切。<br>属性：by、from、to、type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;polygon points=&quot;60,30 90,90 30,90&quot;&gt;</div><div class="line">    &lt;animateTransform attributeName=&quot;transform&quot;</div><div class="line">attributeType=&quot;XML&quot;</div><div class="line">type=&quot;rotate&quot;</div><div class="line">from=&quot;0 60 70&quot;</div><div class="line">to=&quot;360 60 70&quot;</div><div class="line">dur=&quot;10s&quot;</div><div class="line">repeatCount=&quot;indefinite&quot;/&gt;</div><div class="line">&lt;/polygon&gt;</div></pre></td></tr></table></figure></p><h2 id="滤镜元素"><a href="#滤镜元素" class="headerlink" title="滤镜元素"></a>滤镜元素</h2><h3 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h3><p>x、y、width、height属性置顶应用滤镜的画布的尺寸。<br>filterUnits指定用来定义滤镜范围的单位。<br>primitiveUnits为滤镜基元中的各种长度值指定坐标系统。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter元素作用是作为原子滤镜操作的容器。它不能直接呈现。可以利用目标SVG元素上的filter属性引用一个滤镜。<br>属性：x、y、width、height、filterRes、filterUnits、primitiveUnits、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;blurMe&quot;&gt;</div><div class="line">&lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot;/&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;circle cx=&quot;60&quot;  cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; /&gt;</div><div class="line">&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="feBlend"><a href="#feBlend" class="headerlink" title="feBlend"></a>feBlend</h3><p>feBlend滤镜把两个对象组合在一起，使它们受特定的混合模式控制。这类似于图像编辑软件中混合两个图层。该模式由属性mode定义。<br>属性：in、in2、mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;filter id=&quot;spotlight&quot;&gt;</div><div class="line">&lt;feFlood result=&quot;floodFill&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; flood-color=&quot;green&quot; flood-opacity=&quot;1&quot;/&gt;</div><div class="line">&lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;floodFill&quot; mode=&quot;multiply&quot;/&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;image xlink:href=&quot;/files/6457/mdn_logo_only_color.png&quot; x=&quot;10%&quot; y=&quot;10%&quot; width=&quot;80%&quot; height=&quot;80%&quot; style=&quot;filter:url(#spotlight);&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="feColorMatrix（颜色转换滤镜）"><a href="#feColorMatrix（颜色转换滤镜）" class="headerlink" title="feColorMatrix（颜色转换滤镜）"></a>feColorMatrix（颜色转换滤镜）</h3><p>该滤镜基于转换矩阵对颜色进行变换。每一像素的颜色值(一个表示为[R,G,B,A] 的矢量)都经过矩阵乘法计算出的新颜色。<br>属性：in、type、values</p><h3 id="feComponentTransfer"><a href="#feComponentTransfer" class="headerlink" title="feComponentTransfer"></a>feComponentTransfer</h3><p>SVG滤镜基元对每个像素执行颜色分量的数据重映射.它允许进行像亮度调整,对比度调整,色彩平衡或阈值的操作。<br>属性：in</p><h3 id="feFuncR"><a href="#feFuncR" class="headerlink" title="feFuncR"></a>feFuncR</h3><p>该滤镜为它的父<fecomponenttransfer>元素的输入图形的红色成分定义了变换函数。<br>属性：type、tableValues、slope、intercept、amplitude、exponent、offset</fecomponenttransfer></p><h3 id="feFuncG"><a href="#feFuncG" class="headerlink" title="feFuncG"></a>feFuncG</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的绿色成分定义了变换函数。</p><h3 id="feFuncB"><a href="#feFuncB" class="headerlink" title="feFuncB"></a>feFuncB</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的蓝色成分定义了变换函数。</p><h3 id="feFuncA"><a href="#feFuncA" class="headerlink" title="feFuncA"></a>feFuncA</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的alpha成分定义了变换函数。</p><h3 id="feComposite（合成滤镜）"><a href="#feComposite（合成滤镜）" class="headerlink" title="feComposite（合成滤镜）"></a>feComposite（合成滤镜）</h3><p>该滤镜执行两个输入图像的智能像素组合，在图像空间中使用以下Porter-Duff合成操作之一：over、in、atop、xor<br>属性：in、in2、operator、k1、k2、k3、k4</p><h3 id="feConvolveMatrix"><a href="#feConvolveMatrix" class="headerlink" title="feConvolveMatrix"></a>feConvolveMatrix</h3><p>feConvolveMatrix元素应用了一个矩阵卷积滤镜效果。一个卷积在输入图像中把像素与邻近像素组合起来制作出结果图像。<br>属性：in、order、kernelMatrix、divisor、bias、targetX、targetY、edgeMode、kernelUnitLength、preserveAlpha</p><h3 id="feDiffuseLighting（散开照明滤镜）"><a href="#feDiffuseLighting（散开照明滤镜）" class="headerlink" title="feDiffuseLighting（散开照明滤镜）"></a>feDiffuseLighting（散开照明滤镜）</h3><p>滤镜光照一个图像，使用alpha通道作为隆起映射。<br>属性：in、surfaceScale、diffuseConstant、kernelUnitLength</p><h3 id="feDisplacementMap"><a href="#feDisplacementMap" class="headerlink" title="feDisplacementMap"></a>feDisplacementMap</h3><p>映射置换滤镜，该滤镜用来自图像中从in2到空间的像素值置换图像从in到空间的像素值。<br>属性：in、in2、scale、xChannelSelector、yChannelSelector</p><h3 id="feDistantLight（平行光滤镜）"><a href="#feDistantLight（平行光滤镜）" class="headerlink" title="feDistantLight（平行光滤镜）"></a>feDistantLight（平行光滤镜）</h3><p>该滤镜定义了一个距离光源，可以用在灯光滤镜feDiffuseLighting元素或feSpecularLighting元素的内部。<br>属性：azimuth、elevation</p><h3 id="feFlood"><a href="#feFlood" class="headerlink" title="feFlood"></a>feFlood</h3><p>该滤镜用flood-color元素定义的颜色和flood-opacity元素定义的不透明度填充了滤镜子区域。<br>属性：flood-color、flood-opacity</p><h3 id="feGaussianBlur（高斯模糊滤镜）"><a href="#feGaussianBlur（高斯模糊滤镜）" class="headerlink" title="feGaussianBlur（高斯模糊滤镜）"></a>feGaussianBlur（高斯模糊滤镜）</h3><p>该滤镜对输入图像进行高斯模糊，属性stdDeviation中指定的数量定义了钟形。<br>属性：in、stdDeviation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;blurMe&quot;&gt;</div><div class="line">    &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot; /&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="feImage（图片滤镜）"><a href="#feImage（图片滤镜）" class="headerlink" title="feImage（图片滤镜）"></a>feImage（图片滤镜）</h3><p>feImage滤镜从外部来源取得图像数据，并提供像素数据作为输出（意味着如果外部来源是一个SVG图像，这个图像将被栅格化。）<br>属性：preserveAspectRatio、href</p><h3 id="feMerge（合并滤镜）"><a href="#feMerge（合并滤镜）" class="headerlink" title="feMerge（合并滤镜）"></a>feMerge（合并滤镜）</h3><p>feMerge滤镜允许同时应用滤镜效果而不是按顺序应用滤镜效果。利用result存储别的滤镜的输出可以实现这一点，然后在一个feMergeNode子元素中访问它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;feOffset&quot; x=&quot;-40&quot; y=&quot;-20&quot; width=&quot;100&quot; height=&quot;200&quot;&gt;</div><div class="line">    &lt;feMerge&gt;</div><div class="line">&lt;feMergeNode in=&quot;blur2&quot; /&gt;</div><div class="line">&lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt;</div><div class="line">    &lt;/feMerge&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;rect x=&quot;40&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #000000; fill: green; filter: url(#feOffset);&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="feMergeNode"><a href="#feMergeNode" class="headerlink" title="feMergeNode"></a>feMergeNode</h3><p>feMergeNode元素拿另一个滤镜的结果，让它的父feMerge元素处理。<br>属性：in</p><h3 id="feMorphology（扩张滤镜）"><a href="#feMorphology（扩张滤镜）" class="headerlink" title="feMorphology（扩张滤镜）"></a>feMorphology（扩张滤镜）</h3><p>该滤镜用来侵蚀或扩张输入的图像。它在增肥或瘦身效果方面特别有用。<br>属性：in、operator、radius</p><h3 id="feOffset（位移滤镜）"><a href="#feOffset（位移滤镜）" class="headerlink" title="feOffset（位移滤镜）"></a>feOffset（位移滤镜）</h3><p>该输入图像作为一个整体，在属性dx和属性dy的值指定了它的偏移量。<br>属性：in、dx、dy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;offset&quot; width=&quot;180&quot; height=&quot;180&quot;&gt;</div><div class="line">    &lt;feOffset in=&quot;SourceGraphic&quot; dx=&quot;60&quot; dy=&quot;60&quot; /&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; stroke=&quot;black&quot; fill=&quot;green&quot; filter=&quot;url(#offset)&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="fePointLight（点光源滤镜）"><a href="#fePointLight（点光源滤镜）" class="headerlink" title="fePointLight（点光源滤镜）"></a>fePointLight（点光源滤镜）</h3><p>SVG创建一个点光源效果。<br>属性：x、y、z</p><h3 id="feSpecularLighting（镜子照明滤镜）"><a href="#feSpecularLighting（镜子照明滤镜）" class="headerlink" title="feSpecularLighting（镜子照明滤镜）"></a>feSpecularLighting（镜子照明滤镜）</h3><p>该滤镜照亮一个源图形，使用alpha通道作为隆起映射。<br>属性：in、surfaceScale、specularConstant、specularExponent、kernelUnitLength</p><h3 id="feSpotLight（斑点照明滤镜）"><a href="#feSpotLight（斑点照明滤镜）" class="headerlink" title="feSpotLight（斑点照明滤镜）"></a>feSpotLight（斑点照明滤镜）</h3><p>feSpotLight元素是一种光源元素，用于SVG文件。<br>属性：x、y、z、pointsAtX、pointsAtY、pointsAtZ、specularExponent、limitingConeAngle</p><h3 id="feTile（平铺滤镜）"><a href="#feTile（平铺滤镜）" class="headerlink" title="feTile（平铺滤镜）"></a>feTile（平铺滤镜）</h3><p>输入图像是平铺的，结果用来填充目标。它的效果近似于一个pattern图案对象。<br>属性：in</p><h3 id="feTurbulence"><a href="#feTurbulence" class="headerlink" title="feTurbulence"></a>feTurbulence</h3><p>该滤镜利用Perlin噪声函数创建了一个图像。它实现了人造纹理比如说云纹、大理石纹的合成。<br>属性：baseFrequency、numOctaves、seed、stitchTiles、type</p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="external">MDN-SVG系列资料</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute#Transfer_function_attributes" target="_blank" rel="external">svg-属性参考</a><br><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/an-in-depth-svg-tutorial.md" target="_blank" rel="external">掘金翻译-深入浅出 SVG</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;svg的使用&quot;&gt;&lt;a href=&quot;#svg的使用&quot; class=&quot;headerlink&quot; title=&quot;svg的使用&quot;&gt;&lt;/a&gt;s
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="svg" scheme="https://fanerge.github.io/tags/svg/"/>
    
  </entry>
  
</feed>
