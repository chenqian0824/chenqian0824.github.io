<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-11-22T13:27:24.310Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法-基数排序</title>
    <link href="https://fanerge.github.io/2017/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/22/排序算法-基数排序/</id>
    <published>2017-11-22T12:04:29.000Z</published>
    <updated>2017-11-22T13:27:24.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序（radix-sort）的基础"><a href="#基数排序（radix-sort）的基础" class="headerlink" title="基数排序（radix sort）的基础"></a>基数排序（radix sort）的基础</h1><p>技术排序的定义：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><h1 id="基数排序步骤"><a href="#基数排序步骤" class="headerlink" title="基数排序步骤"></a>基数排序步骤</h1><p>以LSD为例，排序数组arr = [73, 22, 93, 43, 55, 14, 28, 65, 39, 81];<br>    注：最低位优先(Least Significant Digit first)法，简称LSD法<br>        最高位优先(Most Significant Digit first)法，简称MSD法</p><ol><li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p></li><li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>PS：LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line">//LSD Radix Sort</div><div class="line">function radixSort(array, maxDigit) &#123;</div><div class="line">var mod = 10;</div><div class="line">var dev = 1;</div><div class="line">var counter = [];</div><div class="line">var arr = array.slice();</div><div class="line">console.time(&apos;基数排序耗时&apos;);</div><div class="line">for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</div><div class="line">for(var j = 0; j &lt; arr.length; j++) &#123;</div><div class="line">var bucket = parseInt((arr[j] % mod) / dev);</div><div class="line">if(counter[bucket]== null) &#123;</div><div class="line">counter[bucket] = [];</div><div class="line">&#125;</div><div class="line">counter[bucket].push(arr[j]);</div><div class="line">&#125;</div><div class="line">var pos = 0;</div><div class="line">for(var j = 0; j &lt; counter.length; j++) &#123;</div><div class="line">var value = null;</div><div class="line">if(counter[j]!=null) &#123;</div><div class="line">while ((value = counter[j].shift()) != null) &#123;</div><div class="line">  arr[pos++] = value;</div><div class="line">&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">console.timeEnd(&apos;基数排序耗时&apos;);</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">var demo = radixSort(arr,2);</div><div class="line">console.log(arr); // [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(demo); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</div></pre></td></tr></table></figure></code></pre><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图">    </p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="external">基数排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基数排序（radix-sort）的基础&quot;&gt;&lt;a href=&quot;#基数排序（radix-sort）的基础&quot; class=&quot;headerlink&quot; title=&quot;基数排序（radix sort）的基础&quot;&gt;&lt;/a&gt;基数排序（radix sort）的基础&lt;/h1&gt;&lt;p&gt;技术
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-桶排序</title>
    <link href="https://fanerge.github.io/2017/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/21/排序算法-桶排算法/</id>
    <published>2017-11-21T12:01:12.000Z</published>
    <updated>2017-11-21T13:08:28.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序的基础"><a href="#桶排序的基础" class="headerlink" title="桶排序的基础"></a>桶排序的基础</h1><p>桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。<br>桶排序的说明：桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O(n)）。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p><h1 id="桶排序的步骤"><a href="#桶排序的步骤" class="headerlink" title="桶排序的步骤"></a>桶排序的步骤</h1><div style="color: red;"><br>1.    找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.    计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.    再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.    将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.    将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br></div><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">// 插入排序</div><div class="line">function insertionSort(arr) &#123;</div><div class="line">var len = arr.length;</div><div class="line">var preIndex, current;</div><div class="line">for (var i = 1; i &lt; len; i++) &#123;</div><div class="line">preIndex = i - 1;</div><div class="line">current = arr[i];</div><div class="line">while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">arr[preIndex+1] = arr[preIndex];</div><div class="line">preIndex--;</div><div class="line">&#125;</div><div class="line">arr[preIndex+1] = current;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶排序</div><div class="line">function bucketSort(array, bucketSize) &#123;</div><div class="line">let arr = array.slice();</div><div class="line">let i;</div><div class="line">let minValue = arr[0];</div><div class="line">let maxValue = arr[0];</div><div class="line"></div><div class="line">// 空数组时直接返回空数组</div><div class="line">if (arr.length === 0) &#123;</div><div class="line">  return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for (i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">  if (arr[i] &lt; minValue) &#123;</div><div class="line">  minValue = arr[i];                //输入数据的最小值</div><div class="line">  &#125; else if (arr[i] &gt; maxValue) &#123;</div><div class="line">  maxValue = arr[i];                //输入数据的最大值</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 桶的初始化</div><div class="line">let DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5</div><div class="line">bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</div><div class="line">let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   </div><div class="line">let buckets = new Array(bucketCount);</div><div class="line"></div><div class="line">// 二维数组，每个桶初始化为空数组</div><div class="line">for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">buckets[i] = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 利用映射函数将数据分配到各个桶中</div><div class="line">for (i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">arr.length = 0;</div><div class="line">for (i = 0; i &lt; buckets.length; i++) &#123;</div><div class="line">insertionSort(buckets[i]);                      //对每个桶进行插入排序</div><div class="line">for (var j = 0; j &lt; buckets[i].length; j++) &#123;</div><div class="line">arr.push(buckets[i][j]);                      </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109];</div><div class="line">var demo = bucketSort(arr, 4); // 这里我分配了4个桶，桶越多越快但需要的内存就越多</div><div class="line">console.log(arr); // [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]</div><div class="line">console.log(demo); // [13, 28, 47, 51, 63, 67, 98, 101, 109, 117, 121, 133, 139, 141, 156, 157, 157, 181, 189, 194]</div></pre></td></tr></table></figure></code></pre><p>PS：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br>什么时候最快（Best Cases）：<br>  当输入的数据可以均匀的分配到每一个桶中<br>什么时候最慢（Worst Cases）：<br>  当输入的数据被分配到了同一个桶中</li></ol><h1 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg" alt="图片展示"></p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin#4_2" target="_blank" rel="external">桶排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序的基础&quot;&gt;&lt;a href=&quot;#桶排序的基础&quot; class=&quot;headerlink&quot; title=&quot;桶排序的基础&quot;&gt;&lt;/a&gt;桶排序的基础&lt;/h1&gt;&lt;p&gt;桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-计数排序</title>
    <link href="https://fanerge.github.io/2017/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/20/排序算法-计数排序/</id>
    <published>2017-11-20T12:15:37.000Z</published>
    <updated>2017-11-20T13:47:37.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序的基础"><a href="#计数排序的基础" class="headerlink" title="计数排序的基础"></a>计数排序的基础</h1><p>定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）<br>计数排序对输入的数据有附加的限制条件：<br>    1、输入的线性表的元素属于有限偏序集S；<br>    2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。    </p><h1 id="计数排序算法思想"><a href="#计数排序算法思想" class="headerlink" title="计数排序算法思想"></a>计数排序算法思想</h1><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p><h1 id="现实计数算法"><a href="#现实计数算法" class="headerlink" title="现实计数算法"></a>现实计数算法</h1><h2 id="具体算法实现步骤"><a href="#具体算法实现步骤" class="headerlink" title="具体算法实现步骤"></a>具体算法实现步骤</h2><p><1>. 找出待排序的数组中最大和最小的元素；</1></p><p><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></p><p><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></p><p><4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function countingSort(arr)&#123;</div><div class="line">let len = arr.length,</div><div class="line">Result = [], // 保存排序后的数组</div><div class="line">Count = [], // 保存各项出现次数的数组</div><div class="line">min = max = arr[0];</div><div class="line">console.time(&apos;计数排序计时&apos;);</div><div class="line"></div><div class="line">// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数</div><div class="line">for(var i = 0; i &lt; len; i++)&#123;</div><div class="line">Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数</div><div class="line">min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值</div><div class="line">max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 从最小值-&gt;最大值,将计数逐项相加</div><div class="line">for(var j = min; j &lt; max; j++)&#123;</div><div class="line">Count[j+1] = (Count[j+1]||0)+(Count[j]||0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</div><div class="line">for(var k = len - 1; k &gt;= 0;k--)&#123;</div><div class="line">/*Result[位置] = arr数据*/</div><div class="line">Result[Count[arr[k]] - 1] = arr[k];</div><div class="line">/*减少Count数组中保存的计数*/</div><div class="line">Count[arr[k]]--;</div><div class="line">/*显示Result数组每一步详情*/</div><div class="line">console.log(Result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.timeEnd(&apos;计数排序计时&apos;);</div><div class="line">return Result;</div><div class="line">&#125;</div><div class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</div><div class="line">console.log(countingSort(arr));</div></pre></td></tr></table></figure></4></p><pre><code>PS：时间复杂度：T(n) = O(n)空间复杂度：S(n) = O(k)是否稳定：是排序方式：外排序</code></pre><p>运行结果为:<br>[ , , , , , , , , , , , , , 48 ]<br>[ , , , , , , , , , , , , , 48, 50 ]<br>[ , , , , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>计数排序计时: 16ms<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图 | center"></p><blockquote><p>   参考文档：<br>    <a href="http://hao.jser.com/archive/13600/" target="_blank" rel="external">基本算法学习(四)之计数排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin" target="_blank" rel="external">计数排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数排序的基础&quot;&gt;&lt;a href=&quot;#计数排序的基础&quot; class=&quot;headerlink&quot; title=&quot;计数排序的基础&quot;&gt;&lt;/a&gt;计数排序的基础&lt;/h1&gt;&lt;p&gt;定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-堆排序</title>
    <link href="https://fanerge.github.io/2017/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/15/排序算法-堆排序/</id>
    <published>2017-11-15T11:47:34.000Z</published>
    <updated>2017-11-15T15:20:38.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序（Heapsort）的基础"><a href="#堆排序（Heapsort）的基础" class="headerlink" title="堆排序（Heapsort）的基础"></a>堆排序（Heapsort）的基础</h1><p>定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><h1 id="我们需要了解什么叫堆"><a href="#我们需要了解什么叫堆" class="headerlink" title="我们需要了解什么叫堆"></a>我们需要了解什么叫堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：<br>        (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点<br>        若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p><h2 id="来个例子说明"><a href="#来个例子说明" class="headerlink" title="来个例子说明"></a>来个例子说明</h2><p>【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。<br>    小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。<br>    大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。<br>    注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。<br>    来张图表示一下：<br>    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b360e14f7bec54e755e1124cd851f035/43a7d933c895d1433f14885273f082025aaf0764.jpg" alt="大跟堆和小跟堆"></p><h2 id="堆的高度"><a href="#堆的高度" class="headerlink" title="堆的高度"></a>堆的高度</h2><p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p><div style="color: red;"><br>    <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>    <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>    <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br></3></2></1></div>    </p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>```/** * 对数组中的前n项整理成堆 * @param array * @param n */function refreshHeap(array, n){    if(array.length&lt;n)n = array.length;    //array[n/2-1]表示的是最后一个有子节点的节点    for(let i=Math.floor(n/2)-1;i&gt;=0;i--){        //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点        //这个while是判断当前节点与其子节点是否需要调整        while(2*i+1&lt;n){            let j = 2*i+1;            //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点            if(j+1&lt;n){                //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点）                if(array[j]&lt;a[j+1]){                    j++;                }            }            //如果最大子节点大于其父节点，则交换            if(a[i]&lt;a[j]){                let tmp = a[i];                a[i] = a[j];                a[j] = tmp;                //交换之后整个堆被破坏，需要重新调整，故令i=j                //这个调整表示的是从j节点开始判断堆是否需要调整                //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整                i = j;            }else{                break;            }        }    }    return array;}function heapSort(array, n){    if(array.length&lt;n)n = array.length;    while(n&gt;0){        //刷新堆之后，将array[0]（最大值）与最后一个子节点交换        //然后重新刷新堆(不包括最后那些排好序的节点了)        refreshHeap(array, n--);        let tmp = array[n];        array[n] = array[0];        array[0] = tmp;    }    return array;}var a = [16,7,3,20,17,8];console.log(a); // [16, 7, 3, 20, 17, 8]heapSort(a,a.length);console.log(a); // [3, 7, 8, 16, 17, 20]```    </code></pre><p>时间复杂度：T(n) = O(nlogn)<br>空间复杂度：S(n) = O(1)<br>稳定性：不稳定<br>排序方式：内排序    </p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F" alt="动图">    </p><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/liuyaqi1993/article/details/69569059" target="_blank" rel="external">JavaScript数据结构之 堆排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="external">堆排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆排序（Heapsort）的基础&quot;&gt;&lt;a href=&quot;#堆排序（Heapsort）的基础&quot; class=&quot;headerlink&quot; title=&quot;堆排序（Heapsort）的基础&quot;&gt;&lt;/a&gt;堆排序（Heapsort）的基础&lt;/h1&gt;&lt;p&gt;定义：堆排序(Heapsor
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-快速排序</title>
    <link href="https://fanerge.github.io/2017/11/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/14/排序算法-快速排序/</id>
    <published>2017-11-14T12:13:47.000Z</published>
    <updated>2017-11-14T14:18:55.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序（Quicksort）的基础"><a href="#快速排序（Quicksort）的基础" class="headerlink" title="快速排序（Quicksort）的基础"></a>快速排序（Quicksort）的基础</h1><p>定义：快速排序（Quicksort）是对冒泡排序的一种改进。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="快速排序算法的介绍"><a href="#快速排序算法的介绍" class="headerlink" title="快速排序算法的介绍"></a>快速排序算法的介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br>一趟快速排序的算法是：<br>    1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>    2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>    3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>    4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>    5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><h1 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h1><p>假设用户输入了如下数组：<br><span style="padding-left: 24px; color: red;">6, 2, 7, 3, 8, 9</span><br>1.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。<br>我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：<br><span style="padding-left: 24px; color: red;">3, 2, 7, 6, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=0 j=3 k=6</span><br>接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=2 j=3 k=6</span><br>称上面两次比较为一个循环。<br>接着，再递减变量j，不断重复进行上面的循环比较。<br>在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br>如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。<br>然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。<br>注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前面讲了那么多了，简单就记住下面的步骤就好了。</p><p><div style="color: red;"><br>1、找基准（一般是以当前数组的第一项的值）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br></div><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function quickSort(array)&#123;</div><div class="line">let arr = array.slice();</div><div class="line"></div><div class="line">//如果数组&lt;=1,则直接返回</div><div class="line">if(arr.length&lt;=1)&#123;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//找基准，并把基准从原数组删除</div><div class="line">var pivot=arr.splice(0,1)[0];</div><div class="line">//定义左右数组</div><div class="line">var left=[];</div><div class="line">var right=[];</div><div class="line"></div><div class="line">//比基准小的放在left，比基准大的放在right</div><div class="line">for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">if(arr[i]&lt;=pivot)&#123;</div><div class="line">left.push(arr[i]);</div><div class="line">&#125;</div><div class="line">else&#123;</div><div class="line">right.push(arr[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//递归</div><div class="line">return quickSort(left).concat([pivot],quickSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [6, 2, 7, 3, 8, 9];</div><div class="line">let demo = quickSort(arr);</div><div class="line"></div><div class="line">console.log(arr); // [6, 2, 7, 3, 8, 9];</div><div class="line">console.log(demo); // [2, 3, 6, 7, 8, 9];</div></pre></td></tr></table></figure></p><p>时间复杂度：T(n) = O(n^2)<br>空间复杂度：S(n) = O(logn)<br>稳定性：不稳定<br>是否为内排序：是</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源网络，在次表示感谢</a></p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dll-ft/p/5850487.html" target="_blank" rel="external">JS实现快速排序</a><br>    <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&amp;fromid=2084344&amp;fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#3_7" target="_blank" rel="external">快速排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序（Quicksort）的基础&quot;&gt;&lt;a href=&quot;#快速排序（Quicksort）的基础&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quicksort）的基础&quot;&gt;&lt;/a&gt;快速排序（Quicksort）的基础&lt;/h1&gt;&lt;p&gt;定义：快速排
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-归并算法</title>
    <link href="https://fanerge.github.io/2017/11/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/13/排序算法-归并算法/</id>
    <published>2017-11-13T12:18:58.000Z</published>
    <updated>2017-11-14T12:16:45.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序（MERGE-SORT）基础"><a href="#归并排序（MERGE-SORT）基础" class="headerlink" title="归并排序（MERGE-SORT）基础"></a>归并排序（MERGE-SORT）基础</h1><p>定义：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>实现过程：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p><h1 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h1><p>归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>假设要对数组C进行归并排序，步骤是：<br>    let C = [10, 4, 6, 3, 8, 2, 5, 7];<br>    1.先将C划分为两个数组A和B（即把数组C从中间分开 n = Math.floor(C.length/2)）<br>    2.再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。<br>    3.然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。<br>    4.依次类推，直到合并到最上层结束，这时数据的排序已经完成了。</p><h2 id="算法划分和合并过程"><a href="#算法划分和合并过程" class="headerlink" title="算法划分和合并过程"></a>算法划分和合并过程</h2><p><div style="color: red;"><br>    先划分：              [10, 4, 6, 3, 8, 2, 5, 7]<br>    第一次划分：[10, 4, 6, 3]         [8, 2, 5, 7]<br>    第二次划分：[10, 4]   [6, 3]      [8, 2]  [5, 7]<br>    第三次划分：[10] [4] [6] [3]      [8] [2] [5] [7]<br>    再合并：<br>    第一次合并：[4, 10] [3, 6]      [2, 8] [5, 7]<br>    第二次合并：[3, 4, 6, 10]      [2, 5, 7, 8]<br>    第三次合并：[2, 3, 4, 5, 6, 7, 8, 10]<br></div><br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt="图解">    </p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function　merge(left, right)&#123;</div><div class="line">var　result=[];</div><div class="line">while(left.length &amp;&amp; right.length)&#123;</div><div class="line">if(left[0] &lt; right[0])&#123;</div><div class="line">/*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/</div><div class="line">result.push(left.shift());</div><div class="line">&#125;else&#123;</div><div class="line">result.push(right.shift());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return　result.concat(left).concat(right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function　mergeSort(items)&#123;</div><div class="line">if(items.length === 1)&#123;</div><div class="line">return　items;</div><div class="line">&#125;</div><div class="line">let　middle = Math.floor(items.length/2),</div><div class="line">left = items.slice(0, middle), //得到下标从0~index-1的数组</div><div class="line">right = items.slice(middle); //得到下标从index开始到末尾的数组</div><div class="line">return　merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line">let arr = [10, 4, 6, 3, 8, 2, 5, 7];</div><div class="line">let demo = mergeSort(arr)</div><div class="line">console.log(arr); // [10, 4, 6, 3, 8, 2, 5, 7]</div><div class="line">console.log(demo); // [2, 3, 4, 5, 6, 7, 8, 10]</div></pre></td></tr></table></figure></code></pre><p>ps：使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。<br>    时间复杂度：O(n log n)<br>    空间复炸都：O（n)<br>    稳定性：稳定<br>    排序方式：外排序</p><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源，在此表示感谢</a>    </p><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/fendou_dexiaoniao/article/details/46594125" target="_blank" rel="external">JS实现归并排序</a><br>    <a href="https://www.cnblogs.com/lizhancheng/p/3989809.html" target="_blank" rel="external">js归并排序法</a><br>    <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin#5_10" target="_blank" rel="external">归并排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序（MERGE-SORT）基础&quot;&gt;&lt;a href=&quot;#归并排序（MERGE-SORT）基础&quot; class=&quot;headerlink&quot; title=&quot;归并排序（MERGE-SORT）基础&quot;&gt;&lt;/a&gt;归并排序（MERGE-SORT）基础&lt;/h1&gt;&lt;p&gt;定义：归并排
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS常用设计模式总结</title>
    <link href="https://fanerge.github.io/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/11/12/设计模式总结/</id>
    <published>2017-11-12T11:48:47.000Z</published>
    <updated>2017-11-12T13:22:13.841Z</updated>
    
    <content type="html"><![CDATA[<p>花了一个多月，终于把js中常用的设计模式整理了一遍。其中主要参阅了曾探的《JavaScript设计模式与开发实践》，讲真这本书写的真的很不错。<br>还参考了wiki、博客、掘金、CSDN等的文章，在此表示感谢，如有理解不当，还望指正。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><h1 id="工厂模式（Factory）"><a href="#工厂模式（Factory）" class="headerlink" title="工厂模式（Factory）"></a>工厂模式（Factory）</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）、<br>    自行车售卖（山地、公路）、<br>    饮料机（咖啡、牛奶、水）、<br>    RPG中职业（战士、法师、射手）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：：模态框、<br>    登录控件、<br>    注销控件<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）、<br>    计算年终奖（工资、效绩）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例： 图片预加载、图片懒加载、<br>    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、<br>    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、<br>    缓存代理（缓存请求结果、计算结果）<br><a href="https://fanerge.github.io/2017/10/15/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：手机购买页面（颜色、数量、内存、价格）、<br>    MVC模式（控制层便是位于表现层与模型层之间的中介者）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="装饰者模式（Decorator）"><a href="#装饰者模式（Decorator）" class="headerlink" title="装饰者模式（Decorator）"></a>装饰者模式（Decorator）</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。<br>举例：雷霆战机（吃道具的例子）<br><a href="https://fanerge.github.io/2017/10/16/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="发布订阅模式（Observer）"><a href="#发布订阅模式（Observer）" class="headerlink" title="发布订阅模式（Observer）"></a>发布订阅模式（Observer）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。<br>举例：模块通信、<br>    售楼中心<br><a href="https://fanerge.github.io/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>举例：常用于接口适配、<br>    兼容多个库（如Prototype库的$函数和YUI的get方法）<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>举例：jquery的$.each()、<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>举例：用桥接模式联结多个类、<br>    事件监控<br><a href="https://fanerge.github.io/2017/10/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>举例：兼容浏览器事件绑定、<br>    兼容浏览器阻止冒泡、<br>    默认事件<br><a href="https://fanerge.github.io/2017/10/22/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br>举例：<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>举例：泡饮品（茶 和 coffee）<br>    公司面试（百度面试 和 阿里面试）<br><a href="https://fanerge.github.io/2017/11/01/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>举例：文件扫描、<br>    dom节点操作<br><a href="https://fanerge.github.io/2017/11/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。<br>举例：分页控件、<br>    撤销组件<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。<br>举例：交押金预定手机、<br>    挤公交投币<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成。<br>举例：文件下载（开始、暂停、完成、失败等）、<br>    红绿灯<br><a href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p><h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。<br>举例：内衣厂展示许多商品展示、<br>    地图应用（对象池）<br><a href="https://fanerge.github.io/2017/11/07/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">需要详细了解该模式，请访问该链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了一个多月，终于把js中常用的设计模式整理了一遍。其中主要参阅了曾探的《JavaScript设计模式与开发实践》，讲真这本书写的真的很不错。&lt;br&gt;还参考了wiki、博客、掘金、CSDN等的文章，在此表示感谢，如有理解不当，还望指正。&lt;/p&gt;
&lt;h1 id=&quot;设计模式&quot;&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-希尔排序</title>
    <link href="https://fanerge.github.io/2017/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/12/排序算法-希尔排序/</id>
    <published>2017-11-12T07:06:49.000Z</published>
    <updated>2017-11-12T09:46:47.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序（Shell-Sort）的基础"><a href="#希尔排序（Shell-Sort）的基础" class="headerlink" title="希尔排序（Shell Sort）的基础"></a>希尔排序（Shell Sort）的基础</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ol><h1 id="实现希尔排序（n为待排序arr-length）"><a href="#实现希尔排序（n为待排序arr-length）" class="headerlink" title="实现希尔排序（n为待排序arr.length）"></a>实现希尔排序（n为待排序arr.length）</h1><h2 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p><p>该方法实质上是一种分组插入方法</p><p>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。<br>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>假设待排序文件有10个记录，其关键字分别是：<br>    592,401,874,141,348,72,911,887,820,283。<br>增量序列的取值依次为：n = 10, 则增量d1 = 10/2 = 5。<br>    5，2，1<br><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" alt="计算过程"><br>    算法时间复杂度：T(n) = O(n*logn^2)<br>    内排序(内存排序就够了)<br>    不稳定(排序后原始顺序无法保证)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function shellSort(array) &#123;</div><div class="line">let arr = array.slice(),</div><div class="line">len = arr.length;</div><div class="line">for(var fraction = Math.floor(len/2); fraction &gt; 0; fraction = Math.floor(fraction/2))&#123;</div><div class="line">// 这里实质上有进行了直接插入排序</div><div class="line">for(var i = fraction; i &lt; len; i++)&#123;</div><div class="line">for(var j = i - fraction; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[fraction + j]; j -= fraction)&#123;</div><div class="line">var temp = arr[j];</div><div class="line">arr[j] = arr[fraction + j];</div><div class="line">arr[fraction + j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr1 = [592,401,874,141,348,72,911,887,820,283];</div><div class="line">let arr2 = shellSort(arr1);</div><div class="line">console.log(arr1); // [592, 401, 874, 141, 348, 72, 911, 887, 820, 283]</div><div class="line">console.log(arr2); // [72, 141, 283, 348, 401, 592, 820, 874, 887, 911]</div></pre></td></tr></table></figure></code></pre><p>PS：首个增量一般取值为 Math.floor(arr.length/2),对每个分组进行直接插入排序。<br>    重复上面过程，知道增量为1时，整个数组恰被分成一组，算法便终止。</p><blockquote><p>   参考文档：<br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="external">基本算法学习(一)之希尔排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">希尔排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;希尔排序（Shell-Sort）的基础&quot;&gt;&lt;a href=&quot;#希尔排序（Shell-Sort）的基础&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell Sort）的基础&quot;&gt;&lt;/a&gt;希尔排序（Shell Sort）的基础&lt;/h1&gt;&lt;p&gt;希尔
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Symbol总结</title>
    <link href="https://fanerge.github.io/2017/11/12/Symbol%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/11/12/Symbol总结/</id>
    <published>2017-11-12T03:31:07.000Z</published>
    <updated>2017-11-12T04:26:01.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Symbol-基础"><a href="#Symbol-基础" class="headerlink" title="Symbol 基础"></a>Symbol 基础</h1><h2 id="Symbol-引入的原因"><a href="#Symbol-引入的原因" class="headerlink" title="Symbol 引入的原因"></a>Symbol 引入的原因</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。<br>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>语法：Symbol([description])<br>参数：description – 可选的，字符串。symbol的description可以用于调试，但无法访问到symbol本身。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol();</div><div class="line">let s2 = Symbol();</div><div class="line"></div><div class="line">s1 === s2 // false</div></pre></td></tr></table></figure></code></pre><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 这里作为对象的属性使用，独一无二</div><div class="line">let s1 = Symbol();</div><div class="line">let a = &#123;</div><div class="line">[s1]: &apos;我是Symbol类型的&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(a[s1]);</div></pre></td></tr></table></figure></code></pre><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。<br><span style="color: red;">它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</span><br>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><h1 id="Symbol-for-key-，Symbol-keyFor-key"><a href="#Symbol-for-key-，Symbol-keyFor-key" class="headerlink" title="Symbol.for(key)，Symbol.keyFor(key)"></a>Symbol.for(key)，Symbol.keyFor(key)</h1><h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p>我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&apos;foo&apos;);</div><div class="line">let s2 = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">s1 === s2 // true</div></pre></td></tr></table></figure></p><pre><code>PS：上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。    Symbol.for(key)与Symbol(desc)这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</code></pre><h2 id="Symbol-keyFor-key"><a href="#Symbol-keyFor-key" class="headerlink" title="Symbol.keyFor(key)"></a>Symbol.keyFor(key)</h2><pre><code>Symbol.keyFor方法返回一个（全局）已登记的 Symbol 类型值的key。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s1) // &quot;foo&quot;</div><div class="line"></div><div class="line">let s2 = Symbol(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s2) // undefined</div></pre></td></tr></table></figure>PS：上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。</code></pre><h1 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h1><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p><h2 id="迭代-symbols"><a href="#迭代-symbols" class="headerlink" title="迭代 symbols"></a>迭代 symbols</h2><ol><li>Symbol.iterator<br>  一个返回一个对象默认迭代器的方法。使用 for…of。</li><li>Symbol.asyncIterator（实验性API）<br>  一个返回对象默认的异步迭代器的方法。使用 for await of。</li></ol><h2 id="正则表达式-symbols"><a href="#正则表达式-symbols" class="headerlink" title="正则表达式 symbols"></a>正则表达式 symbols</h2><ol><li>Symbol.match<br>  一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match().</li><li>Symbol.replace<br>  一个替换匹配字符串的子串的方法. 使用 String.prototype.replace().</li><li>Symbol.search<br>  一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search().</li><li>Symbol.split<br>  一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split().</li></ol><h2 id="其他-symbols"><a href="#其他-symbols" class="headerlink" title="其他 symbols"></a>其他 symbols</h2><ol><li>Symbol.hasInstance<br>  一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof.</li><li>Symbol.isConcatSpreadable<br>  一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat().</li><li>Symbol.unscopables<br>  拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</li><li>Symbol.species<br>  一个用于创建派生对象的构造器函数。</li><li>Symbol.toPrimitive<br>  一个将对象转化为基本数据类型的方法。</li><li>Symbol.toStringTag<br>  用于对象的默认描述的字符串值。使用Object.prototype.toString().</li></ol><blockquote><p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">阮一峰-Symbol</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">MDN-Symbol</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Symbol-基础&quot;&gt;&lt;a href=&quot;#Symbol-基础&quot; class=&quot;headerlink&quot; title=&quot;Symbol 基础&quot;&gt;&lt;/a&gt;Symbol 基础&lt;/h1&gt;&lt;h2 id=&quot;Symbol-引入的原因&quot;&gt;&lt;a href=&quot;#Symbol-引入的原因&quot;
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Set和Map的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Set%E5%92%8CMap%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Set和Map的用法/</id>
    <published>2017-11-11T13:33:57.000Z</published>
    <updated>2017-11-11T14:23:33.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set-详解"><a href="#Set-详解" class="headerlink" title="Set 详解"></a>Set 详解</h1><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>语法：new Set([iterable]);<br>参数：如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。<br>返回值：一个新的Set对象。</p><h2 id="来个简单实例"><a href="#来个简单实例" class="headerlink" title="来个简单实例"></a>来个简单实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3]);</div><div class="line">console.log(set) // Set(3) &#123;1, 2, 3&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>Set.prototype<br>表示Set构造器的原型，允许向所有Set对象添加新的属性。</li><li>Set.prototype.constructor<br>返回实例的构造函数。默认情况下是Set。</li><li>Set.prototype.size<br>返回Set对象的值的个数。</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</li><li>Set.prototype.clear()<br>移除Set对象内的所有元素。</li><li>Set.prototype.delete(value)<br>移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</li><li>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</li><li>Set.prototype.keys()<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li><li>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li><li>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</li><li>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</li><li>Set.prototype<a href="">@@iterator</a><br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值</li></ol><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-基础"><a href="#WeakSet-基础" class="headerlink" title="WeakSet 基础"></a>WeakSet 基础</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><ol><li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li><li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<h3 id="WeakSet-具有的方法"><a href="#WeakSet-具有的方法" class="headerlink" title="WeakSet 具有的方法"></a>WeakSet 具有的方法</h3>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const ws = new WeakSet();</div><div class="line">const obj = &#123;&#125;;</div><div class="line"></div><div class="line">ws.add(window);</div><div class="line">ws.add(obj);</div><div class="line"></div><div class="line">ws.has(window); // true</div><div class="line"></div><div class="line">ws.delete(window);</div><div class="line">ws.has(window);    // false</div></pre></td></tr></table></figure></li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-出现的背景"><a href="#Map-出现的背景" class="headerlink" title="Map 出现的背景"></a>Map 出现的背景</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><h2 id="基础特性-1"><a href="#基础特性-1" class="headerlink" title="基础特性"></a>基础特性</h2><p>语法：new Map([iterable])<br>参数：iterable<br>    Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p><h2 id="简单的Map-实例"><a href="#简单的Map-实例" class="headerlink" title="简单的Map 实例"></a>简单的Map 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line"></div><div class="line">map.set(-0, 123);</div><div class="line">map.get(+0) // 123</div><div class="line"></div><div class="line">map.set(true, 1);</div><div class="line">map.set(&apos;true&apos;, 2);</div><div class="line">map.get(true) // 1</div><div class="line"></div><div class="line">map.set(undefined, 3);</div><div class="line">map.set(null, 4);</div><div class="line">map.get(undefined) // 3</div><div class="line"></div><div class="line">map.set(NaN, 123);</div><div class="line">map.get(NaN) // 123</div></pre></td></tr></table></figure></code></pre><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ol><li>Map.prototype<br>表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。</li><li>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</li><li>Map.prototype.size<br>返回Map对象的键/值对的数量。</li></ol><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol><li>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</li><li>Map.prototype.delete(key)<br>移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。</li><li>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</li><li>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</li><li>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</li><li>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</li><li>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</li><li>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li><li>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</li><li>Map.prototype<a href="">@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li></ol><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的基础"><a href="#WeakMap-的基础" class="headerlink" title="WeakMap 的基础"></a>WeakMap 的基础</h3><pre><code>WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有两点：</code></pre><ol><li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li></ol><h3 id="WeakMap-的方法"><a href="#WeakMap-的方法" class="headerlink" title="WeakMap 的方法"></a>WeakMap 的方法</h3><ol><li>get()</li><li>set()</li><li>has()</li><li>delete()</li></ol><h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>WeakMap 应用的典型场合就是 DOM 节点作为键名。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let myElement = document.getElementById(&apos;logo&apos;);</div><div class="line">let myWeakmap = new WeakMap();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">  let logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure></p><p>PS：上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">MDN-Set</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">MDN-Map</a><br>    <a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="external">阮一峰-Set和Map</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Set-详解&quot;&gt;&lt;a href=&quot;#Set-详解&quot; class=&quot;headerlink&quot; title=&quot;Set 详解&quot;&gt;&lt;/a&gt;Set 详解&lt;/h1&gt;&lt;h2 id=&quot;基础特性&quot;&gt;&lt;a href=&quot;#基础特性&quot; class=&quot;headerlink&quot; title=&quot;基
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Proxy和Reflect的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Proxy%E5%92%8CReflect%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Proxy和Reflect的用法/</id>
    <published>2017-11-11T10:51:05.000Z</published>
    <updated>2017-11-11T13:20:28.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h1><h2 id="Proxy-定义"><a href="#Proxy-定义" class="headerlink" title="Proxy 定义"></a>Proxy 定义</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><h2 id="Proxy-语法"><a href="#Proxy-语法" class="headerlink" title="Proxy 语法"></a>Proxy 语法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 目标对象，需要被拦截 或 处理的对象，数组，函数甚至是其他的代理器</div><div class="line">let target = &#123;&#125;;</div><div class="line">// 拦截器对象</div><div class="line">let handler = &#123;</div><div class="line">get(target, name)&#123;</div><div class="line">// 这里如果 target 没有name属性的话，就设定一个默认值</div><div class="line">return name in target ? target[name] : 27;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">console.log(target.name); // undefined</div><div class="line">console.log(proxy.name); // 27</div></pre></td></tr></table></figure></code></pre><p>PS：Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p><h2 id="Proxy-支持的拦截操作一览，一共13种"><a href="#Proxy-支持的拦截操作一览，一共13种" class="headerlink" title="Proxy 支持的拦截操作一览，一共13种"></a>Proxy 支持的拦截操作一览，一共13种</h2><ol><li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li><li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li><li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li><li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li><li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li><li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li><li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ol><h2 id="Proxy-revocable-可撤销的代理"><a href="#Proxy-revocable-可撤销的代理" class="headerlink" title="Proxy.revocable() 可撤销的代理"></a>Proxy.revocable() 可撤销的代理</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let target = &#123;&#125;;</div><div class="line">let handler = &#123;&#125;;</div><div class="line"></div><div class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</div><div class="line"></div><div class="line">proxy.foo = 123;</div><div class="line">console.log(proxy.foo);</div><div class="line"></div><div class="line">revoke(); // 取消Proxy实例</div><div class="line">console.log(proxy.foo); // TypeError: Revoked</div></pre></td></tr></table></figure></p><p>PS：Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。<br>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="this-的问题"><a href="#this-的问题" class="headerlink" title="this 的问题"></a>this 的问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const target = &#123;</div><div class="line">  m: function () &#123;</div><div class="line">console.log(this === proxy);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">const handler = &#123;&#125;;</div><div class="line"></div><div class="line">const proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">target.m() // false</div><div class="line">proxy.m()  // true</div></pre></td></tr></table></figure></p><h2 id="Proxy-的应用"><a href="#Proxy-的应用" class="headerlink" title="Proxy 的应用"></a>Proxy 的应用</h2><h3 id="扩展数组的属性和方法"><a href="#扩展数组的属性和方法" class="headerlink" title="扩展数组的属性和方法"></a>扩展数组的属性和方法</h3><p>需求：对于数组对象，有时候我们只想要得到数组中对象的某个键值内容。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var AddSomeFunctionHandler=&#123;</div><div class="line">get:function(obj,prop)&#123;</div><div class="line"></div><div class="line">if(prop in obj)&#123;</div><div class="line">return obj[prop]   // 按数组默认方式访问元素</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(prop === &apos;name&apos;)&#123;</div><div class="line">return obj.map(o=&gt;o.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var PersonArray=[&#123;</div><div class="line">name:&quot;Alice&quot;,age:23</div><div class="line">&#125;,&#123;</div><div class="line">name:&quot;Bob&quot;,age:45</div><div class="line">&#125;,&#123;</div><div class="line">name:&quot;Mike&quot;,age:27</div><div class="line">&#125;]</div><div class="line"></div><div class="line">var p= new Proxy(PersonArray,AddSomeFunctionHandler)</div><div class="line">console.log(p.name) // [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</div></pre></td></tr></table></figure></p><h1 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h1><h2 id="Reflect-定义"><a href="#Reflect-定义" class="headerlink" title="Reflect 定义"></a>Reflect 定义</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。<br>Reflect对象的设计目的有这样几个：</p><ol><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li></ol><h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><p>Reflect对象一共有13个静态方法。</p><ol><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)<br>PS：上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</li></ol><h2 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h2><p>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  get baz() &#123;</div><div class="line">return this.foo + this.bar;</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">Reflect.get(myObject, &apos;foo&apos;) // 1</div><div class="line">Reflect.get(myObject, &apos;bar&apos;) // 2</div><div class="line">Reflect.get(myObject, &apos;baz&apos;) // 3</div></pre></td></tr></table></figure></p><h2 id="实例–使用-Proxy-实现观察者模式"><a href="#实例–使用-Proxy-实现观察者模式" class="headerlink" title="实例–使用 Proxy 实现观察者模式"></a>实例–使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。<br>如果你还不懂<a href="">观察者模式</a><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//添加观察者</div><div class="line">const queuedObservers = new Set();</div><div class="line">const observe = fn =&gt; queuedObservers.add(fn);</div><div class="line"></div><div class="line">//proxy 的set 方法</div><div class="line">function set(target, key, value, receiver) &#123;</div><div class="line">const result = Reflect.set(target, key, value, receiver);</div><div class="line">queuedObservers.forEach(observer =&gt; observer());</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line">//创建proxy代理</div><div class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</div><div class="line">//被观察的 对象</div><div class="line">const person = observable(&#123;</div><div class="line">name: &apos;张三&apos;,</div><div class="line">age: 20</div><div class="line">&#125;);</div><div class="line"></div><div class="line">observe(print);</div><div class="line">console.log(person.name); // 张三</div><div class="line">person.name = &apos;李四&apos;;</div><div class="line">console.log(person.name); // 李四</div></pre></td></tr></table></figure></p><blockquote><p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">阮一峰-Reflect</a><br>    <a href="https://www.cnblogs.com/WhiteHorseIsNotHorse/p/7016010.html" target="_blank" rel="external">用es6 （proxy 和 reflect）轻松实现 观察者模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Proxy-详解&quot;&gt;&lt;a href=&quot;#Proxy-详解&quot; class=&quot;headerlink&quot; title=&quot;Proxy 详解&quot;&gt;&lt;/a&gt;Proxy 详解&lt;/h1&gt;&lt;h2 id=&quot;Proxy-定义&quot;&gt;&lt;a href=&quot;#Proxy-定义&quot; class=&quot;head
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Generator%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Generator函数的用法/</id>
    <published>2017-11-11T07:48:46.000Z</published>
    <updated>2017-11-11T09:57:26.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h1><p>从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p><h1 id="Generator函数的简单示例"><a href="#Generator函数的简单示例" class="headerlink" title="Generator函数的简单示例"></a>Generator函数的简单示例</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* g() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var demo = g();</div></pre></td></tr></table></figure></code></pre><p>PS：上面代码定义了一个 Generator 函数g，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br><span style="color: red">返回的是，遍历器对象（Iterator Object）。例如这里，{ value: ‘hello’, done: false }</span></p><h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h1><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。<br>    （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。<br>    （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。<br>    （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。<br>    （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p><h1 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h1><pre><code>可以遍历 数组 和 实现了 Symbol.iterator 方法的对象。</code></pre><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function *foo() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">  yield 4;</div><div class="line">  yield 5;</div><div class="line">  return 6;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let v of foo()) &#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">// 1 2 3 4 5</div></pre></td></tr></table></figure></p><h1 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a>Generator.prototype.next()</h1><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123; </div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen(); // &quot;Generator &#123; &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 1, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 2, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 3, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure></p><h1 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h1><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。    </p><h1 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h1><p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line"></div><div class="line">g.next()        // &#123; value: 1, done: false &#125;</div><div class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">g.next()        // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure></p><p>PS：遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。<br>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p><h1 id="比较一下多个异步操作的编码"><a href="#比较一下多个异步操作的编码" class="headerlink" title="比较一下多个异步操作的编码"></a>比较一下多个异步操作的编码</h1><p>step1完成才能做step2，step2完成才能做step3，step3完成才能做step4</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数("></a>回调函数(</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">step1(function (value1) &#123;</div><div class="line">  step2(value1, function(value2) &#123;</div><div class="line">step3(value2, function(value3) &#123;</div><div class="line">  step4(value3, function(value4) &#123;</div><div class="line">// Do something with value4</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><p>PS：层数多了就形成了回调地狱。</p><h2 id="Promise-组织代码"><a href="#Promise-组织代码" class="headerlink" title="Promise 组织代码"></a>Promise 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Q.fcall(step1)</div><div class="line">  .then(step2)</div><div class="line">  .then(step3)</div><div class="line">  .then(step4)</div><div class="line">  .then(function (value4) &#123;</div><div class="line">// Do something with value4</div><div class="line">  &#125;, function (error) &#123;</div><div class="line">// Handle any error from step1 through step4</div><div class="line">  &#125;)</div><div class="line">  .done();</div></pre></td></tr></table></figure></code></pre><p>PS：是不是代码稍微要清晰一些了。</p><h2 id="Generator-组织代码"><a href="#Generator-组织代码" class="headerlink" title="Generator 组织代码"></a>Generator 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function* longRunningTask() &#123;</div><div class="line">  try &#123;</div><div class="line">var value1 = yield step1();</div><div class="line">var value2 = yield step2(value1);</div><div class="line">var value3 = yield step3(value2);</div><div class="line">var value4 = yield step4(value3);</div><div class="line">// Do something with value4</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">// Handle any error from step1 through step4</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function scheduler(task) &#123;</div><div class="line">  setTimeout(function() &#123;</div><div class="line">var taskObj = task.next(task.value);</div><div class="line">// 如果Generator函数未结束，就继续调用</div><div class="line">if (!taskObj.done) &#123;</div><div class="line">  task.value = taskObj.value</div><div class="line">  scheduler(task);</div><div class="line">&#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">scheduler(longRunningTask());</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator 函数的语法</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">MDN-Generator</a><br>    <a href="http://blog.csdn.net/jiangbo_phd/article/details/51820642" target="_blank" rel="external">ES6 Generator 函数的使用</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Generator函数的定义&quot;&gt;&lt;a href=&quot;#Generator函数的定义&quot; class=&quot;headerlink&quot; title=&quot;Generator函数的定义&quot;&gt;&lt;/a&gt;Generator函数的定义&lt;/h1&gt;&lt;p&gt;从语法上，首先可以把它理解成，Generat
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Promise的用法</title>
    <link href="https://fanerge.github.io/2017/11/11/Promise%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://fanerge.github.io/2017/11/11/Promise的用法/</id>
    <published>2017-11-11T02:31:27.000Z</published>
    <updated>2017-11-11T07:40:52.349Z</updated>
    
    <content type="html"><![CDATA[<p>ES6出来了很久，Promise也一直在用，现在总结一下具体用法。</p><h1 id="Promise-定义"><a href="#Promise-定义" class="headerlink" title="Promise 定义"></a>Promise 定义</h1><p>Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="MDN"><br>    这里使用MDN的图片</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="创造了一个-Promise-实例"><a href="#创造了一个-Promise-实例" class="headerlink" title="创造了一个 Promise 实例"></a>创造了一个 Promise 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="对-Promise-实例成功-或-失败-做相应的处理"><a href="#对-Promise-实例成功-或-失败-做相应的处理" class="headerlink" title="对 Promise 实例成功 或 失败 做相应的处理"></a>对 Promise 实例成功 或 失败 做相应的处理</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(value) &#123;</div><div class="line">  // success</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><h2 id="分为三种调用形式（注意最后面需要带着错误处理函数）"><a href="#分为三种调用形式（注意最后面需要带着错误处理函数）" class="headerlink" title="分为三种调用形式（注意最后面需要带着错误处理函数）"></a>分为三种调用形式（注意最后面需要带着错误处理函数）</h2><ol><li>promise.then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li><li>promise.then((resolve) =&gt; { // 成功的处理函数 }).then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li><li>promise.then(null, (reject) =&gt; { // 错误的处理函数 })</li></ol><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个<span style="color: red">新的</span>Promise 对象，从而达到链式调用。</p><h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(resolve) &#123;</div><div class="line">  // 成功的处理函数</div><div class="line">&#125;).catch(function(error) &#123;</div><div class="line">  console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p><p>PS：Promise.all方法接受一个数组或具有Iterator 接口的对象作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>（1）只有p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure></p><p>PS：Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</div></pre></td></tr></table></figure></p><p>PS：将jQuery生成的deferred对象，转为一个新的Promise对象。</p><h2 id="根据不同参数，返回结果情况"><a href="#根据不同参数，返回结果情况" class="headerlink" title="根据不同参数，返回结果情况"></a>根据不同参数，返回结果情况</h2><ol><li>参数是一个Promise实例<br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li><li>参数是一个thenable对象（thenable对象指的是具有then方法的对象）<br>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</li><li>参数不是具有then方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</li><li>不带有任何参数<br>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。</li></ol><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br>下面两种形式一样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const p = Promise.reject(&apos;出错了&apos;);</div><div class="line">// 等同于</div><div class="line">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</div><div class="line"></div><div class="line">p.then(null, function (s) &#123;</div><div class="line">  console.log(s)</div><div class="line">&#125;);</div><div class="line">// 出错了</div></pre></td></tr></table></figure></p><h1 id="自己部署有用的方法"><a href="#自己部署有用的方法" class="headerlink" title="自己部署有用的方法"></a>自己部署有用的方法</h1><h2 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p><h3 id="部署-done-方法"><a href="#部署-done-方法" class="headerlink" title="部署 done 方法"></a>部署 done 方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.done = function (onFulfilled, onRejected) &#123;</div><div class="line">  this.then(onFulfilled, onRejected)</div><div class="line">.catch(function (reason) &#123;</div><div class="line">  // 抛出一个全局错误</div><div class="line">  setTimeout(() =&gt; &#123; throw reason &#125;, 0);</div><div class="line">&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">.then(f1)</div><div class="line">.catch(r1)</div><div class="line">.then(f2)</div><div class="line">.done();</div></pre></td></tr></table></figure></code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h2><h3 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p><h3 id="部署finally方法"><a href="#部署finally方法" class="headerlink" title="部署finally方法"></a>部署finally方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.finally = function (callback) &#123;</div><div class="line">  let P = this.constructor;</div><div class="line">  return this.then(</div><div class="line">value  =&gt; P.resolve(callback()).then(() =&gt; value),</div><div class="line">reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.listen(0)</div><div class="line">.then(function () &#123;</div><div class="line">// run test</div><div class="line">&#125;)</div><div class="line">.finally(server.stop);</div></pre></td></tr></table></figure></p><h1 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h1><p><span style="color: red">目前还为提案，Promise 库Bluebird、Q和when，提供了这个方法。</span></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。    </p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.try(f) // 这里不需要管 f 是同步还是异步函数。</div><div class="line">  .then(...)</div><div class="line">  .catch(...)</div></pre></td></tr></table></figure></code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const preloadImage = function (path) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">const image = new Image();</div><div class="line">image.onload  = resolve;</div><div class="line">image.onerror = reject;</div><div class="line">image.src = path;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">preloadImage</div><div class="line">.then((reslove) =&gt; &#123; console.log(&apos;图片加载成功了哦！&apos;) &#125;)</div><div class="line">.catch((reject) =&gt; &#123; console.log(&apos;图片加载失败了哦！&apos;) &#125;)</div></pre></td></tr></table></figure></p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN–Promiese</a><br>    <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰–Promise</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6出来了很久，Promise也一直在用，现在总结一下具体用法。&lt;/p&gt;
&lt;h1 id=&quot;Promise-定义&quot;&gt;&lt;a href=&quot;#Promise-定义&quot; class=&quot;headerlink&quot; title=&quot;Promise 定义&quot;&gt;&lt;/a&gt;Promise 定义&lt;/h1&gt;
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-插入排序</title>
    <link href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/10/排序算法-插入排序/</id>
    <published>2017-11-10T13:12:03.000Z</published>
    <updated>2017-11-10T14:02:40.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序算法定义（Insertion-Sort）"><a href="#插入排序算法定义（Insertion-Sort）" class="headerlink" title="插入排序算法定义（Insertion Sort）"></a>插入排序算法定义（Insertion Sort）</h1><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，<br>    这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序<br>    数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。<br>    是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，<br>    但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。<br>    在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><pre><code>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</code></pre><h1 id="插入排序的分类"><a href="#插入排序的分类" class="headerlink" title="插入排序的分类"></a>插入排序的分类</h1><p>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。<br>    属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个<br>    已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。<br>        例如,已知待排序的一组记录是：60,71,49,11,24,3,66<br>        假设在排序过程中，前3个记录已按关键码值递增的次序重新排列，构成一个有序序列：49,60,71<br>        将待排序记录中的第4个记录（即11）插入上述有序序列，以得到一个新的含4个记录的有序序列。<br>        首先，应找到11的插入位置，再进行插入。可以讲11放入数组的第一个单元r[0]中，这个单元称为监视哨，<br>        然后从71起从右到左查找，11小于71，将71右移一个位置，11小于60，又将60右移一个位置，11小于49，<br>        又再将49右移一个位置，这时再将11与r[0]的值比较，11≥r[0]，它的插入位置就是r[1]。<br>        假设11大于第一个值r[1]。它的插入位置应该在r[1]和r[2]之间，由于60已经右移了，留出来的位置正好留给11.<br>        后面的记录依照同样的方法逐个插入到该有序序列中。若记录数n,续进行n-1趟排序，才能完成。<br>        直接插入排序的算法思路：<br>        （1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；<br>        （2） 设置开始查找的位置j；<br>        （3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；<br>        （4） 将r[0]插入r[j+1]的位置上。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function insertSort(array)&#123;  </div><div class="line">let i,</div><div class="line">j, </div><div class="line">temp,</div><div class="line">arr = array.slice(),  // 这里对原数组拷贝</div><div class="line">n = arr.length; </div><div class="line"></div><div class="line">for(i = 1;i &lt; n;i++)&#123;   </div><div class="line">j = i-1; </div><div class="line">temp = arr[i]; // 第i项为待插入的项  </div><div class="line"></div><div class="line">while(j &lt; i &amp;&amp; arr[j] &gt; temp)&#123;   </div><div class="line">arr[j+1] = arr[j];   </div><div class="line">j--;  </div><div class="line">&#125;   </div><div class="line"></div><div class="line">arr[j+1] = temp;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;   </div><div class="line">&#125;   </div><div class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </div><div class="line">let demo = insertSort(arrayA);</div><div class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure></code></pre><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" alt="直接插入排序"><br>    最佳情况：输入数组按升序排列。T(n) = O(n)<br>    最坏情况：输入数组按降序排列。T(n) = O(n2)<br>    平均情况：T(n) = O(n2)</p><h2 id="折半插入排序（二分插入排序）"><a href="#折半插入排序（二分插入排序）" class="headerlink" title="折半插入排序（二分插入排序）"></a>折半插入排序（二分插入排序）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。<br>    在处理A[i]时，A[0]……A[i-1]已经按关键码值排好序。所谓折半比较，就是在插入A[i]时，<br>    取A[i-1/2]的关键码值与A[i]的关键码值进行比较，如果A[i]的关键码值小于A[i-1/2]的关键码值，<br>    则说明A[i]只能插入A[0]到A[i-1/2]之间，故可以在A[0]到A[i-1/2-1]之间继续使用折半比较；<br>    否则只能插入A[i-1/2]到A[i-1]之间，故可以在A[i-1/2+1]到A[i-1]之间继续使用折半比较。<br>    如此担负，直到最后能够确定插入的位置为止。一般在A[k]和A[r]之间采用折半，其中间结点为A[k+r/2]，<br>    经过一次比较即可排除一半记录，把可能插入的区间减小了一半，故称为折半。<br>    执行折半插入排序的前提是文件记录必须按顺序存储。</p><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><p>（1）计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，<br>        说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置 到中间值的位置，这样很简单的完成了折半；<br>    （2）在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，<br>        范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；<br>    （3）确定位置之后，将整个序列后移，并将元素插入到相应位置。</p><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function binaryInsertSort(array)&#123;</div><div class="line">let arr = array.slice();</div><div class="line">for (let i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">let key = arr[i], </div><div class="line">left = 0, </div><div class="line">right = i - 1;</div><div class="line"></div><div class="line">while (left &lt;= right) &#123;</div><div class="line">let middle = parseInt((left + right) / 2);</div><div class="line"></div><div class="line">if (key &lt; arr[middle]) &#123;</div><div class="line">right = middle - 1;</div><div class="line">&#125; else &#123;</div><div class="line">left = middle + 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">for (var j = i - 1; j &gt;= left; j--) &#123;</div><div class="line">  arr[j + 1] = arr[j];</div><div class="line">&#125;</div><div class="line"></div><div class="line">arr[left] = key;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </div><div class="line">let demo = binaryInsertSort(arrayA);</div><div class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure></code></pre><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="二分插入排序"><br>    最佳情况：T(n) = O(nlogn)<br>    最差情况：T(n) = O(n2)<br>    平均情况：T(n) = O(n2)</p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/90zeng/p/insert_sort.html" target="_blank" rel="external">数据结构复习：直接插入排序与二分插入排序的C++实现</a><br>    <a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="external">插入排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插入排序算法定义（Insertion-Sort）&quot;&gt;&lt;a href=&quot;#插入排序算法定义（Insertion-Sort）&quot; class=&quot;headerlink&quot; title=&quot;插入排序算法定义（Insertion Sort）&quot;&gt;&lt;/a&gt;插入排序算法定义（Inser
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-选择排序</title>
    <link href="https://fanerge.github.io/2017/11/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/09/排序算法-选择排序/</id>
    <published>2017-11-09T12:18:16.000Z</published>
    <updated>2017-11-09T13:07:31.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序算法定义（Selection-Sort）"><a href="#选择排序算法定义（Selection-Sort）" class="headerlink" title="选择排序算法定义（Selection Sort）"></a>选择排序算法定义（Selection Sort）</h1><pre><code>选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</code></pre><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。</code></pre><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><pre><code>每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</code></pre><h2 id="简单选择排序的基本思想"><a href="#简单选择排序的基本思想" class="headerlink" title="简单选择排序的基本思想"></a>简单选择排序的基本思想</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。</code></pre><h2 id="简单选择排序的存储状态"><a href="#简单选择排序的存储状态" class="headerlink" title="简单选择排序的存储状态"></a>简单选择排序的存储状态</h2><pre><code>初始序列：{49 27 65 97 76 12 38}</code></pre><p>　　第1趟：12与49交换：12{27 65 97 76 49 38}<br>　　第2趟：27不动　：12 27{65 97 76 49 38}<br>　　第3趟：65与38交换：12 27 38{97 76 49 65}<br>　　第4趟：97与49交换：12 27 38 49{76 97 65}<br>　　第5趟：76与65交换：12 27 38 49 65{97 76}<br>　　第6趟：97与76交换：12 27 38 49 65 76 97 完成</p><pre><code>PS：其中大括号内为无序区，大括号外为有序序列</code></pre><h1 id="简单选择排序的算法分析"><a href="#简单选择排序的算法分析" class="headerlink" title="简单选择排序的算法分析"></a>简单选择排序的算法分析</h1><pre><code>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，需要移动记录的次数最多为3（n-1）（此情况中待排序记录并非完全逆序，给完全逆序记录排序的移动次数应为(n/2)*3，其中n/2向下取整）。简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是∑ =(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n2)。</code></pre><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function selectionSort(array) &#123;</div><div class="line">let arr = array.slice(), // 深拷贝一份原数组</div><div class="line">len = arr.length,</div><div class="line">minIndex,</div><div class="line">temp;</div><div class="line">for (var i = 0; i &lt; len - 1; i++) &#123;</div><div class="line">minIndex = i;</div><div class="line">for (var j = i + 1; j &lt; len; j++) &#123;</div><div class="line">if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</div><div class="line">minIndex = j;                 //将最小数的索引保存</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">temp = arr[i];</div><div class="line">arr[i] = arr[minIndex];</div><div class="line">arr[minIndex] = temp;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [5, 4, 3, 2, 1];</div><div class="line">var demo = selectionSort(arr);</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>PS：建议使用不可变对象的思想进行编程。</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" alt="选择排序动图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">选择排序（Selection Sort）</a><br>    <a href="https://baike.baidu.com/item/选择排序法/2304587" target="_blank" rel="external">选择排序法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序算法定义（Selection-Sort）&quot;&gt;&lt;a href=&quot;#选择排序算法定义（Selection-Sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序算法定义（Selection Sort）&quot;&gt;&lt;/a&gt;选择排序算法定义（Selec
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法--冒泡排序</title>
    <link href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://fanerge.github.io/2017/11/08/排序算法-冒泡排序/</id>
    <published>2017-11-08T13:31:41.000Z</published>
    <updated>2017-11-09T13:05:40.909Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">或许你需要对算法的基本概念进行了解，请访问该链接。</a></p><h1 id="冒泡排序算法定义（Bubble-Sort）"><a href="#冒泡排序算法定义（Bubble-Sort）" class="headerlink" title="冒泡排序算法定义（Bubble Sort）"></a>冒泡排序算法定义（Bubble Sort）</h1><pre><code>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</code></pre><h1 id="冒泡排序算法原理"><a href="#冒泡排序算法原理" class="headerlink" title="冒泡排序算法原理"></a>冒泡排序算法原理</h1><pre><code>冒泡排序算法的运作如下：（从后往前）</code></pre><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h1 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><pre><code>若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。    C=n-1；M=0；</code></pre><p><span>所以，冒泡排序最好的时间复杂度为 O(n)。</span><br>    若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，<br>    且每次比较都必须移动记录三次来达到交换记录位置。<br>        C=n<em>(n-1)/2 = O(n^2)；M=3n</em>(n-1)/2 = O(n^2)</p><p><span>所以，冒泡排序最好的时间复杂度为 O(n^2)。</span><br>    综上，因此冒泡排序总的平均时间复杂度为  O(n^2)。        </p><h2 id="冒泡排序算法的稳定性"><a href="#冒泡排序算法的稳定性" class="headerlink" title="冒泡排序算法的稳定性"></a>冒泡排序算法的稳定性</h2><pre><code>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</code></pre><h1 id="冒泡排序算法描述"><a href="#冒泡排序算法描述" class="headerlink" title="冒泡排序算法描述"></a>冒泡排序算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(array) &#123;</div><div class="line">let len = array.length, j, arr = array.slice();</div><div class="line">let tempExchangeVal;</div><div class="line">while (len &gt; 0) &#123;</div><div class="line">for (j = 0; j &lt; len - 1; j++) &#123;</div><div class="line">if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">// 交换两个值</div><div class="line">tempExchangeVal = arr[j];</div><div class="line">arr[j] = arr[j + 1];</div><div class="line">arr[j + 1] = tempExchangeVal;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">len--;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">const arr = [5, 4, 3, 2, 1];</div><div class="line">let arrSorted = bubbleSort(arr);</div><div class="line">console.log(arrSorted); // [1, 2, 3, 4, 5]</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1];</div></pre></td></tr></table></figure>PS：这里在方法中新生成了一个数组，有不可变对象的思想。</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" alt="冒泡排序"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p><blockquote><p>   参考文档：<br>    <a href="https://www.cnblogs.com/zhouliang/p/6638010.html" target="_blank" rel="external">JS-排序详解-冒泡排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="external">冒泡排序</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;或许你需要对算法的基本概念进行了
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法基本概念</title>
    <link href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://fanerge.github.io/2017/11/08/排序算法基本概念/</id>
    <published>2017-11-08T12:19:57.000Z</published>
    <updated>2017-11-09T13:05:01.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对于评述算法优劣术语的说明"><a href="#对于评述算法优劣术语的说明" class="headerlink" title="对于评述算法优劣术语的说明"></a>对于评述算法优劣术语的说明</h1><ol><li>稳定：如果a原本在b的前面，若a=b，排序之后a仍然在b前面。</li><li>不稳定：如果a原本在b的前面，若a=b，排序之后a可能会在b的后面。</li><li>内排序：所有排序操作都在内存中完成。</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li>时间复杂度：一个算法执行所消耗的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ol><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="时间复杂度的定义-T-n-O-f-n"><a href="#时间复杂度的定义-T-n-O-f-n" class="headerlink" title="时间复杂度的定义 T(n)=O(f(n))"></a>时间复杂度的定义 T(n)=O(f(n))</h2><pre><code>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。</code></pre><h2 id="时间复杂度的计算步骤"><a href="#时间复杂度的计算步骤" class="headerlink" title="时间复杂度的计算步骤"></a>时间复杂度的计算步骤</h2><ol><li>计算出基本操作的执行次数T(n)<br>  基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。<br>  在做算法分析时，一般默认为考虑最坏的情况。</li><li>计算出T(n)的数量级<br>  求T(n)的数量级，只要将T(n)进行如下一些操作，忽略常量、低次幂和最高次幂的系数。<br>  令f(n)=T(n)的数量级。</li><li>用大O来表示时间复杂度<br>  当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。<br>  记作T(n)=O(f(n))。</li></ol><h2 id="计算一下时间复杂度"><a href="#计算一下时间复杂度" class="headerlink" title="计算一下时间复杂度"></a>计算一下时间复杂度</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)   //循环了，当然是O(n^2)</div><div class="line">       for(j=1;j&lt;=n;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure></code></pre><p>PS：这里的执行次数为 <span style="color: red;">n*n</span> 次 ，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)</div><div class="line">       for(j=1;j&lt;=i;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure></code></pre><p>PS：这里的执行次数为 <span style="color: red;">(1+2+3+…+n)≈(n^2)/2</span>次，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><h2 id="空间复杂度定义-S-n-O-f-n"><a href="#空间复杂度定义-S-n-O-f-n" class="headerlink" title="空间复杂度定义 S(n)=O(f(n))"></a>空间复杂度定义 S(n)=O(f(n))</h2><pre><code>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。</code></pre><h1 id="各种算法的总结"><a href="#各种算法的总结" class="headerlink" title="各种算法的总结"></a>各种算法的总结</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p><pre><code>总结：接着我会使用 js 来做各种排序算法的分析。 </code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="external">js十大排序算法</a><br>    <a href="http://univasity.iteye.com/blog/1164707" target="_blank" rel="external">算法时间复杂度的计算 [整理]</a><br>    <a href="http://blog.csdn.net/firefly_2002/article/details/8008987" target="_blank" rel="external">如何计算时间复杂度</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对于评述算法优劣术语的说明&quot;&gt;&lt;a href=&quot;#对于评述算法优劣术语的说明&quot; class=&quot;headerlink&quot; title=&quot;对于评述算法优劣术语的说明&quot;&gt;&lt;/a&gt;对于评述算法优劣术语的说明&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;稳定：如果a原本在b的前面，若a=b，排
      
    
    </summary>
    
      <category term="算法" scheme="https://fanerge.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://fanerge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-享元模式</title>
    <link href="https://fanerge.github.io/2017/11/07/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/11/07/js设计模式-享元模式/</id>
    <published>2017-11-07T12:59:00.000Z</published>
    <updated>2017-11-07T13:29:31.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式的基础"><a href="#享元模式的基础" class="headerlink" title="享元模式的基础"></a>享元模式的基础</h1><pre><code>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。使用场景：第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；第二种是应用在DOM层上，    享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄。作用：Flyweight中有两个重要概念--内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，    而外部信息可以在通过外部删除或者保存。</code></pre><h1 id="内衣厂展示许多商品"><a href="#内衣厂展示许多商品" class="headerlink" title="内衣厂展示许多商品"></a>内衣厂展示许多商品</h1><pre><code>说明：假设有个内衣工厂，目前的产品有50种男士内衣与50种女士内衣，为了推销产品，    工厂决定生产一些塑料模特来穿上它们的内衣拍成内衣广告。这里很显然适合使用 &lt;span style=&quot;color: red;&quot;&gt;享元模式&lt;/span&gt; 来组织代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 定义塑料模特的构造函数</div><div class="line">var Model = function (sex) &#123;</div><div class="line">this.sex = sex;</div><div class="line">&#125;</div><div class="line">// 为模特拍照</div><div class="line">Model.prototype.takePhoto = function () &#123;</div><div class="line">console.log(&apos;sex=&apos; + this.sex + &apos;underwear=&apos; + this.underwear )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实例化一个男模特 和 一个女模特</div><div class="line">var maleModel = new Model(&apos;male&apos;),</div><div class="line">female    = new Model(&apos;female&apos;);    </div><div class="line">for (var i = 1; i &lt;=50; i++)&#123;</div><div class="line">// 分别为模特换上 50 件内衣 以及 照相</div><div class="line">maleModel.underwear = &apos;underwear&apos; + i;</div><div class="line">maleModel.takePhoto();</div><div class="line">&#125;</div><div class="line">for (var i = 1; i &lt;=50; i++)&#123;</div><div class="line">// 分别为模特换上 50 件内衣 以及 照相</div><div class="line">female.underwear = &apos;underwear&apos; + i;</div><div class="line">femaleModel.takePhoto();</div><div class="line">&#125;</div></pre></td></tr></table></figure>PS：很显然，这里只需要两个对象便完成这个需求。</code></pre><h1 id="地图应用（对象池）"><a href="#地图应用（对象池）" class="headerlink" title="地图应用（对象池）"></a>地图应用（对象池）</h1><pre><code>说明：对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取对象。    如果对象池里没有空闲对象则创建一个新的对象，当获取的对象完成他的职责之后，再进入池子等待被下次获取。    假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip 。    当第一次搜索A地点时假设出现了2个小气泡，第二次搜索A附近的B地点的时候页面出现了6个小气泡，    按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。    这样第二次搜索结果页面里，我们只需要再创建4个小气泡而不是6个。</code></pre><h2 id="定义个气泡工厂"><a href="#定义个气泡工厂" class="headerlink" title="定义个气泡工厂"></a>定义个气泡工厂</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var toolTipFactory = (function () &#123;</div><div class="line">var toolTipPool  = [];   // toolTip 对象池</div><div class="line">return &#123;</div><div class="line">create : function () &#123;</div><div class="line">if(toolTipPool.length === 0)&#123;</div><div class="line">   var div = document.createElement(&apos;div&apos;);</div><div class="line">   document.body.appendChild(div);</div><div class="line">   return div;</div><div class="line">&#125; else&#123;</div><div class="line">   return toolTipPool.shift(); //shift a dom</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">recover : function (tooltipDom) &#123;</div><div class="line">return toolTipPool.push(tooltipDom);  </div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>PS：气泡工厂的对象池为数组是私有属性被包含在工厂闭包里，这个工厂又两个暴露对外的方法，    create表示获取一个div节点，recover表示回收一个div节点。</code></pre><h2 id="第一次搜索（2个气泡）"><a href="#第一次搜索（2个气泡）" class="headerlink" title="第一次搜索（2个气泡）"></a>第一次搜索（2个气泡）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [];</div><div class="line">for(var i = 0, str; str = [&apos;A&apos;,&apos;B&apos;][i++])&#123;  // get ary elem</div><div class="line">var toolTip = toolTipFactory.create();</div><div class="line">toolTip.innerHTML = str;</div><div class="line">ary.push(toolTip)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>PS：现在重新回到第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们。</code></pre><h2 id="现在开始回收节点"><a href="#现在开始回收节点" class="headerlink" title="现在开始回收节点"></a>现在开始回收节点</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(var i = 0 , toolTip ; toolTip = ary[i++])&#123;</div><div class="line">toolTip.recover(toolTip)</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="第二次搜索（6个气泡）"><a href="#第二次搜索（6个气泡）" class="headerlink" title="第二次搜索（6个气泡）"></a>第二次搜索（6个气泡）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i =0 , str; str = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;][i++]; )&#123;</div><div class="line">var toolTip = toolTipFactory.create();</div><div class="line">toolTip.innerHTML(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>PS：现在页面中已经出现了6个节点，上一次创建好的节点被共享给了下一次操作。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.jianshu.com/p/a158478c95b5" target="_blank" rel="external">三分钟教会你JS设计模式之享元模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/09/2379774.html" target="_blank" rel="external">深入理解JavaScript系列（37）：设计模式之享元模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;享元模式的基础&quot;&gt;&lt;a href=&quot;#享元模式的基础&quot; class=&quot;headerlink&quot; title=&quot;享元模式的基础&quot;&gt;&lt;/a&gt;享元模式的基础&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-状态模式</title>
    <link href="https://fanerge.github.io/2017/11/07/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/11/07/js设计模式-状态模式/</id>
    <published>2017-11-07T12:15:23.000Z</published>
    <updated>2017-11-07T12:51:47.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式的基础"><a href="#状态模式的基础" class="headerlink" title="状态模式的基础"></a>状态模式的基础</h1><pre><code>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。    状态模式是一个非常常用的设计模式，它主要有两个角色组成：    （1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。    （2）状态类：表示一种状态，包含其相应的处理方法作用：状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以可以让代码更加清晰，    提高应用程序的维护性和扩展性。使用场景：文件下载（开始、暂停、完成、失败等）、红绿灯</code></pre><h1 id="红绿灯（红绿黄灯）"><a href="#红绿灯（红绿黄灯）" class="headerlink" title="红绿灯（红绿黄灯）"></a>红绿灯（红绿黄灯）</h1><pre><code>说明：我们简单地通过一个红绿灯的例子来说明状态模式，红绿灯拥有一个状态：哪一种颜色的灯亮了，每一种颜色的灯亮了之后又各自的动作，一共有红绿黄三种颜色的灯，也就是有三种状态。</code></pre><h2 id="定义环境类（红绿灯对象）"><a href="#定义环境类（红绿灯对象）" class="headerlink" title="定义环境类（红绿灯对象）"></a>定义环境类（红绿灯对象）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var trafficLight = (function () &#123;</div><div class="line">var currentLight = null;</div><div class="line">return &#123;</div><div class="line">change: function (light) &#123;</div><div class="line">currentLight = light;</div><div class="line">currentLight.go();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>PS：上面的代码中，trafficLight是一个红绿灯对象，它有一个局部变量currentLight表示当前亮灯的对象，    同时返回一个方法，这个方法用来改变红绿灯的状态，并触发相应的处理程序。</code></pre><h2 id="定义状态类（三种不同颜色的灯）"><a href="#定义状态类（三种不同颜色的灯）" class="headerlink" title="定义状态类（三种不同颜色的灯）"></a>定义状态类（三种不同颜色的灯）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 红灯</div><div class="line">function RedLight() &#123; &#125;</div><div class="line">RedLight.prototype.go = function () &#123;</div><div class="line">console.log(&quot;this is red light&quot;);</div><div class="line">&#125;</div><div class="line">// 绿灯</div><div class="line">function GreenLight() &#123; &#125;</div><div class="line">GreenLight.prototype.go = function () &#123;</div><div class="line">console.log(&quot;this is green light&quot;);</div><div class="line">&#125;</div><div class="line">// 黄灯</div><div class="line">function YellowLight() &#123; &#125;</div><div class="line">YellowLight.prototype.go = function () &#123;</div><div class="line">console.log(&quot;this is yellow light&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>PS：这段代码分别定义了红绿黄三种颜色的灯对象，每一个对象都包含一个go方法作为亮灯之后的处理程序。</code></pre><h2 id="客户端切换不同颜色的灯"><a href="#客户端切换不同颜色的灯" class="headerlink" title="客户端切换不同颜色的灯"></a>客户端切换不同颜色的灯</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">trafficLight.change(new RedLight()); // this is red light</div><div class="line">trafficLight.change(new YellowLight()); // this is yellow light</div></pre></td></tr></table></figure>PS：通过传入灯对象到change方法中，从而改变红绿灯的状态，触发其相应的处理程序，这就是一个典型的状态模式的应用。</code></pre><h1 id="菜单组件（JS组件开发中的状态模式）"><a href="#菜单组件（JS组件开发中的状态模式）" class="headerlink" title="菜单组件（JS组件开发中的状态模式）"></a>菜单组件（JS组件开发中的状态模式）</h1><pre><code>说明：状态模式在开发JS组件时非常有用，我们平时开发组件时很多时候要切换组件的状态，每种状态有不同的处理方式，这个时候就可以使用状态模式进行开发。比如我们要开发一个菜单组件，菜单拥有最基本的两种状态：显示和隐藏，相应的显示或隐藏可能会有各自的其他操作。</code></pre><h2 id="定义一个环境类（菜单对象）"><a href="#定义一个环境类（菜单对象）" class="headerlink" title="定义一个环境类（菜单对象）"></a>定义一个环境类（菜单对象）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Menu() &#123; &#125;</div><div class="line">Menu.prototype.toggle = function (state) &#123;</div><div class="line">state();</div><div class="line">&#125;</div></pre></td></tr></table></figure>PS：这个菜单类有一个toggle方法用来切换状态，然后调用相应的处理方法。</code></pre><h2 id="定义状态类（切换菜单）"><a href="#定义状态类（切换菜单）" class="headerlink" title="定义状态类（切换菜单）"></a>定义状态类（切换菜单）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var menuStates = &#123;</div><div class="line">&quot;show&quot;: function () &#123;</div><div class="line">console.log(&quot;the menu is showing&quot;);</div><div class="line">&#125;,</div><div class="line">&quot;hide&quot;: function () &#123;</div><div class="line">console.log(&quot;the menu is hiding&quot;);</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>PS：通过一个对象menuStates来定义menu的状态，这里有两种状态show和hide，然后拥有相应的处理方法。</code></pre><h2 id="客户端切换菜单状态"><a href="#客户端切换菜单状态" class="headerlink" title="客户端切换菜单状态"></a>客户端切换菜单状态</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var menu = new Menu();</div><div class="line">menu.toggle(menuStates.show);</div><div class="line">menu.toggle(menuStates.hide);</div></pre></td></tr></table></figure>PS：这段代码实例化了一个Menu对象，然后分别切换了显示和隐藏两种状态，如果有第三种状态，我们只需要menuStates添加相应的状态和处理程序即可。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/18/2437099.html" target="_blank" rel="external">深入理解JavaScript系列（43）：设计模式之状态模式</a><br>    <a href="http://www.cnblogs.com/lrzw32/p/4994817.htm" target="_blank" rel="external">Javascript设计模式理论与实战：状态模式</a><br>    <a href="http://luopq.com/2015/11/25/design-pattern-state/" target="_blank" rel="external">Javascript设计模式理论与实战：状态模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式的基础&quot;&gt;&lt;a href=&quot;#状态模式的基础&quot; class=&quot;headerlink&quot; title=&quot;状态模式的基础&quot;&gt;&lt;/a&gt;状态模式的基础&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式-职责链模式</title>
    <link href="https://fanerge.github.io/2017/11/06/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fanerge.github.io/2017/11/06/js设计模式-职责链模式/</id>
    <published>2017-11-06T13:11:22.000Z</published>
    <updated>2017-11-06T14:11:58.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="职责链模式的基础"><a href="#职责链模式的基础" class="headerlink" title="职责链模式的基础"></a>职责链模式的基础</h1><pre><code>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。    将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。    职责链模式的名字非常形象，一系列可能会处理请求的对象被该连接成一条链，请求在这些对象之间依次传递，    直到遇到一个可以处理它的对象，我们把这些对象成为链中的节点。优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。使用场景：挤公交车递钱（只有售票元可以收钱）、交押金预定手机</code></pre><h1 id="交押金预定手机"><a href="#交押金预定手机" class="headerlink" title="交押金预定手机"></a>交押金预定手机</h1><blockquote><p>   假设一个电视网站对于某部新上市的手机经过了2轮缴纳500元定金与200元定金的预定，现在已经到了正式购买的阶段。<br>    支付了500元定金的用户在购买阶段可以使用100元优惠券，200元定金可以使用50元优惠券，普通用户没有如果没有库存不一定能买到。<br>    约定：<br>    orderType: 表示订单类型(定金或者普通用户),code的值为1时候是500元定金用户，为2是200元定金用户，为3则是普通用户。<br>    pay : 表示用户是否支付定金，用户虽然下过500元定金的订单但是如果他一直没有支付定金，那么只能降级为普通用户。<br>    stock : 仅用户普通用户的库存数量，定金用户不受限制。</p></blockquote><pre><code>首先定义三种预定的客户的订单并且让每种客户订单有满足当前预定条件和不满足当前预定条件（需后面继续处理）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 500 元客户订单</div><div class="line">var order500 = function (orderType,pay,stock) &#123;</div><div class="line">if(orderType === 1 &amp;&amp; pay)&#123;</div><div class="line"> console.log(&apos;500 rmb deposit, get 100 coupon &apos;)</div><div class="line">&#125; else &#123;</div><div class="line">return &apos;nextSuccessor&apos;  // unknow the next node but always pass to next.</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 200 元客户订单</div><div class="line">var order200 = function (orderType,pay,stock) &#123;</div><div class="line">if(orderType === 2 &amp;&amp; pay)&#123;</div><div class="line">console.log(&apos;200 rmb deposit , get 50 coupon&apos;)</div><div class="line">&#125; else&#123;</div><div class="line"> return &apos;nextSuccessor&apos;; </div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 无预约客户订单</div><div class="line">var orderNormal = function (orderType,pay,stock) &#123;</div><div class="line">if(stock &gt; 0)&#123;</div><div class="line"> console.log(&apos;normal buy no coupon&apos;)</div><div class="line">&#125; else&#123;</div><div class="line"> console.log(&apos;the stock lack&apos;)</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 定制职责链对象（作用是形成订单职责链）</div><div class="line">var Chain = function (fn) &#123;</div><div class="line">this.fn = fn;</div><div class="line">this.successor = null;</div><div class="line">&#125;;</div><div class="line">// 设置职责链</div><div class="line">Chain.prototype.setNextSuccessor = function (successor) &#123;</div><div class="line">return this.successor = successor;</div><div class="line">&#125;;</div><div class="line">// 设置每个节点的调用方式</div><div class="line">Chain.prototype.passRequest = function () &#123;</div><div class="line">var ret = this.fn.apply(this.arguments);</div><div class="line">if(ret === &apos;nextSuccessor&apos;)&#123;</div><div class="line">return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments)</div><div class="line">&#125;</div><div class="line">return ret;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 现在我们把3个订单函数分别包装成职责链的节点</div><div class="line">var chainOrder500 = new Chain(order500);</div><div class="line">var chainOrder200 = new Chain(order200);</div><div class="line">var chainOrderNormal = new Chain(orderNormal);</div><div class="line"></div><div class="line">// 这里我们把上面封装的节点连成一条线，依次判断执行</div><div class="line">chainOrder500.setNextSuccessor(chainOrder200)</div><div class="line">chainOrder200.setNextSuccessor(chainOrderNormal)</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">chainOrder500.passRequest(1,true,6); // 500 rmb deposit, get 100 coupon</div><div class="line">chainOrder500.passRequest(2,true,4); // 200 rmb deposit , get 50 coupon</div></pre></td></tr></table></figure>假如我们又想支持，300元定金购买，那我们就在改链中增加一个节点即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var order300 = function () &#123;</div><div class="line">// todo</div><div class="line">&#125;;</div><div class="line">chainOrder300 = new Chain(chainOrder300)</div><div class="line">chainOrder500.setNextSuccessor(chainOrder300)</div><div class="line">chainOrder300.setNextSuccessor(chainOrder200)</div></pre></td></tr></table></figure>我们可以自由灵活的增加移除和链中的节点顺序，这样就很简单能满足瞬息万变的需求了。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.jianshu.com/p/19b0033423be" target="_blank" rel="external">三分钟教会你JS设计模式之职责链模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/10/2435381.html" target="_blank" rel="external">深入理解JavaScript系列（38）：设计模式之职责链模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;职责链模式的基础&quot;&gt;&lt;a href=&quot;#职责链模式的基础&quot; class=&quot;headerlink&quot; title=&quot;职责链模式的基础&quot;&gt;&lt;/a&gt;职责链模式的基础&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;定义：职责链模式（Chain of responsibility）是使多个对
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
