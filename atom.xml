<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2018-05-21T12:30:06.182Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web术语</title>
    <link href="https://fanerge.github.io/2018/Web%E6%9C%AF%E8%AF%AD.html"/>
    <id>https://fanerge.github.io/2018/Web术语.html</id>
    <published>2018-05-14T12:53:23.000Z</published>
    <updated>2018-05-21T12:30:06.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全术语"><a href="#安全术语" class="headerlink" title="安全术语"></a>安全术语</h1><h2 id="XSS（跨站脚本攻击Cascading-Style-Sheets）"><a href="#XSS（跨站脚本攻击Cascading-Style-Sheets）" class="headerlink" title="XSS（跨站脚本攻击Cascading Style Sheets）"></a>XSS（跨站脚本攻击Cascading Style Sheets）</h2><p>定义：XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。<br>方案：CSP(Content Security Policy)、对特殊字符转义，不要相信任何来自用户的输入（请求体、queryString甚至是请求Headers）<br><a href="https://www.zhuyingda.com/blog/article.html?id=2" target="_blank" rel="external">XSS漏洞的原理</a></p><h2 id="CSRF（跨站点脚本Cross-site-request-forgery）"><a href="#CSRF（跨站点脚本Cross-site-request-forgery）" class="headerlink" title="CSRF（跨站点脚本Cross-site request forgery）"></a>CSRF（跨站点脚本Cross-site request forgery）</h2><p>定义：是指在黑客已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器 CRUD 来执行读写操作。<br>方案：token + Referer(Request Header)、验证码<br>PS：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。<br><a href="https://www.zhuyingda.com/blog/article.html?id=5" target="_blank" rel="external">CSRF漏洞的原理</a></p><h2 id="clickjacking（点击劫持）"><a href="#clickjacking（点击劫持）" class="headerlink" title="clickjacking（点击劫持）"></a>clickjacking（点击劫持）</h2><p>定义：点击劫持其实是一种视觉上的欺骗手段，攻击者将一个透明的、不可见的iframe覆盖在一个网页上，通过调整iframe页面位置，诱使用户在页面上进行操作，在不知情的情况下用户的点击恰好是点击在iframe页面的一些功能按钮上。<br>方案：防止或限制网页内嵌（http头部X-FRAME-OPTIONS）、<a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">JS防止潜入</a><br>PS：http头部X-FRAME-OPTIONS为非标准的（但所有浏览器都支持），你可以使用CSP的frame-ancestors为标准属性。<br><a href="https://www.zhuyingda.com/blog/article.html?id=6" target="_blank" rel="external">ClickJacking漏洞的原理</a></p><h2 id="点击穿透（多见与移动端模态框等浮层）"><a href="#点击穿透（多见与移动端模态框等浮层）" class="headerlink" title="点击穿透（多见与移动端模态框等浮层）"></a>点击穿透（多见与移动端模态框等浮层）</h2><p>产生：上层元素touch事件-&gt;上层元素消失（300ms之内）-&gt;底层元素click事件触发<br>PS：touch事件之后会有300ms延迟在执行click事件是因为，在这300ms中若再次tap行为则认定为double tap事件，否则就触发click事件。<br>方案：只用touch事件、只用click事件（不推荐）、fastclick类库等<br><a href="https://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>定义：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br>方案：使用参数化的过滤性语句、输入验证、错误消息处理、加密处理、存储过程来执行所有的查询、使用专业的漏洞扫描工具、确保数据库安全、安全审评</p><h2 id="MIMT-中间人攻击Man-in-the-middle-attacks"><a href="#MIMT-中间人攻击Man-in-the-middle-attacks" class="headerlink" title="MIMT(中间人攻击Man-in-the-middle-attacks)"></a>MIMT(中间人攻击Man-in-the-middle-attacks)</h2><p>定义：Client &lt;–&gt; Proxy Server(Middle Man) &lt;–&gt; Web Server真是服务器<br>Client 发出的请求 和 Web Server返回的数据都经过Proxy Server 转发，这个Proxy Server 就起到了一个Middle Man的作用，如果这个“中间人” 够黑，那么整个代理过程的数据都可以由这个“中间人”控制，“中间人”可以进行截取敏感数据、代码注射、Proxp worm操作。<br>方案：启用虚拟专用网(VPN)、https(传输报文加密)<br><a href="https://www.zhuyingda.com/blog/article.html?id=7" target="_blank" rel="external">web中间人攻击的威胁</a></p><h2 id="DDOS（分布式拒绝服务Distributed-Denial-of-Service）"><a href="#DDOS（分布式拒绝服务Distributed-Denial-of-Service）" class="headerlink" title="DDOS（分布式拒绝服务Distributed Denial of Service）"></a>DDOS（分布式拒绝服务Distributed Denial of Service）</h2><p>定义：最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。<br>方案：高防服务器、黑名单、DDoS 清洗、CDN（隐藏真实IP及分流）<br><a href="https://www.zhihu.com/question/22259175" target="_blank" rel="external">知乎-什么是 DDoS 攻击？</a></p><h1 id="OTHER"><a href="#OTHER" class="headerlink" title="OTHER"></a>OTHER</h1><h2 id="CSP（内容安全策略Content-Security-Policy）"><a href="#CSP（内容安全策略Content-Security-Policy）" class="headerlink" title="CSP（内容安全策略Content-Security-Policy）"></a>CSP（内容安全策略Content-Security-Policy）</h2><p>定义：内容安全策略 (Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>定义：CORS (跨域资源共享)是一个系统, 包括传输的 HTTP headers, 其确定是否阻止或完成从该资源所在的域外的另一个域的网页上的受限资源的请求,。<br>PS：同源安全策略( same-origin security policy)默认禁止“跨域”请求. CORS 给予Web服务器跨域访问控制, 启用安全的跨域数据传输。<br><a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" target="_blank" rel="external">CORS</a></p><h2 id="BFC（块格式化上下文Block-Formatting-Context）"><a href="#BFC（块格式化上下文Block-Formatting-Context）" class="headerlink" title="BFC（块格式化上下文Block Formatting Context）"></a>BFC（块格式化上下文Block Formatting Context）</h2><p>定义：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">块格式化上下文</a></p><h2 id="containing-block（包含块）"><a href="#containing-block（包含块）" class="headerlink" title="containing block（包含块）"></a>containing block（包含块）</h2><p>定义：在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。<br>PS：主要作用是以百分比（相关于包含块）计算自身的width、height、top、left、padding、margin等css Layout 属性。<br><a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">我所了解的CSS包含块</a>    </p><h2 id="FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）"><a href="#FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）" class="headerlink" title="FOUC（无样式内容闪烁Flash Of Unstyled Content）"></a>FOUC（无样式内容闪烁Flash Of Unstyled Content）</h2><p>定义：指的是加载网页时出现的短暂的CSS样式失效。<br>方案：head头部放css、少用import<br><a href="https://www.cnblogs.com/fsjohnhuang/p/6739064.html" target="_blank" rel="external">FOUC</a></p><h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>定义：由于不同的浏览器对CSS的支持程度不同，同样CSS的样式代码在不同浏览器当中的表现可能出现不一致。为了让所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。<br>方案：属性前缀法、选择器前缀法、条件注释法（<!--[if lt IE 8]-->）</p><h2 id="Domain（域名）"><a href="#Domain（域名）" class="headerlink" title="Domain（域名）"></a>Domain（域名）</h2><p>顶级域名\跟域名（TLD）共1058+（.com、.net、.cn等等）<br>13个根域名服务器（不代表只有13台服务器，事实上517+）</p><h2 id="a链接"><a href="#a链接" class="headerlink" title="a链接"></a>a链接</h2><p>a链接使用绑定 mousedown 事件且 event.preventDefault() 会导致 :active 伪类失效（Firefox）。<br>PS：Firefox 认为 mousedown 事件在 :active 之前发生。</p><h2 id="min-width、max-width、width、-important优先级"><a href="#min-width、max-width、width、-important优先级" class="headerlink" title="min-width、max-width、width、!important优先级"></a>min-width、max-width、width、!important优先级</h2><p>min-width &gt;&gt; max-width &gt;&gt; !important &gt;&gt; width</p><h2 id="巧用css-兄弟选择器（如导航分割线）"><a href="#巧用css-兄弟选择器（如导航分割线）" class="headerlink" title="巧用css 兄弟选择器（如导航分割线）"></a>巧用css 兄弟选择器（如导航分割线）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;</div><div class="line">// 这样排除第一个元素</div><div class="line">a + a:before &#123;</div><div class="line">content: &quot;&quot;;</div><div class="line">font-size: 0;</div><div class="line">padding: 10px 3px 1px;</div><div class="line">margin-left: 6px;</div><div class="line">border-left: 1px solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="img-在firefox和其他浏览器的差异"><a href="#img-在firefox和其他浏览器的差异" class="headerlink" title="img 在firefox和其他浏览器的差异"></a>img 在firefox和其他浏览器的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">// width 和 height 无效，需要设置display: inline-block;</div><div class="line">width: xx;</div><div class="line">height: xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="关于百分比设置下列属性"><a href="#关于百分比设置下列属性" class="headerlink" title="关于百分比设置下列属性"></a>关于百分比设置下列属性</h2><p> left（right）、width、padding、margin设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>的width值<br> top（bottom）、height设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>height值</p><h2 id="滚动容器底部留白"><a href="#滚动容器底部留白" class="headerlink" title="滚动容器底部留白"></a>滚动容器底部留白</h2><p>滚动容器底部留白使用 margin-bottom，使用 padding-bottom 存在兼容性问题。</p><h2 id="margin-合并（只存在垂直方向）"><a href="#margin-合并（只存在垂直方向）" class="headerlink" title="margin 合并（只存在垂直方向）"></a>margin 合并（只存在垂直方向）</h2><ol><li>相邻兄弟元素 margin 合并。</li><li>父级和第一个/最后一个子元素。（虽然是在子元素上设置的 margin-top，但实际上就等同于在父元素上设置了 margin-top）</li><li>空块级元素的 margin 合并。</li></ol><p>PS：合并规则，正正取大值，正负值相加，负负最小值。</p><h2 id="margin-auto-理解"><a href="#margin-auto-理解" class="headerlink" title="margin: auto;理解"></a>margin: auto;理解</h2><p>margin: auto; 表示对剩余空白进行分配。<br>下面元素 .son 的 margin-left 为 300 - 200 -80 = 20px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-right: 80px;</div><div class="line">margin-left: auto; // 20px</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 margin 来进行 right 对齐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-left: auto; // 此时 auto 值为100px</div><div class="line">// flot: right; 等价</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：块级元素的左中右对齐使用 margin ，内联元素使用 text-align 控制左中右对戏。<br>水平和垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px; height:150px;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">position: absolute;</div><div class="line">top: 0; right: 0; bottom: 0; left: 0;</div><div class="line">width: 200px; height: 100px;</div><div class="line">margin: auto; // 很关键</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="border-的一些秘密"><a href="#border-的一些秘密" class="headerlink" title="border 的一些秘密"></a>border 的一些秘密</h2><p>border-width 不支持百分比值（outline、box-shadow、text-shadow同样）<br>border-style:double 至少 3px 才有效果。<br>border-style:dashed 不同浏览器不一致（虚线颜色区的宽高比以及颜色区和透明区的宽度比例），如chrome上为方形ie为圆形。<br>thin（1px）、medium（默认值3px）、thick（4px）。</p><h2 id="border-特效"><a href="#border-特效" class="headerlink" title="border 特效"></a>border 特效</h2><p>等腰三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>直角三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>边框 3D 效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 10px; height: 10px;</div><div class="line">border: 10px solid;</div><div class="line">border-color: #f30 #00f #396 #0f0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="http://www.cnblogs.com/xiaohuochai/p/5457127.html" target="_blank" rel="external">登高布局</a></p><h2 id="css-度量单位-ex"><a href="#css-度量单位-ex" class="headerlink" title="css 度量单位 ex"></a>css 度量单位 ex</h2><p>相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。<br>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>作用：基于ex单位的天然垂直居中对齐效果</p><h2 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h2><p>行距 = line-height - font-size</p><p><a href="https://github.com/cubiq/iscroll/" target="_blank" rel="external">iScroll, smooth scrolling for the web</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安全术语&quot;&gt;&lt;a href=&quot;#安全术语&quot; class=&quot;headerlink&quot; title=&quot;安全术语&quot;&gt;&lt;/a&gt;安全术语&lt;/h1&gt;&lt;h2 id=&quot;XSS（跨站脚本攻击Cascading-Style-Sheets）&quot;&gt;&lt;a href=&quot;#XSS（跨站脚本攻击Ca
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Web" scheme="https://fanerge.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Web安全</title>
    <link href="https://fanerge.github.io/2018/web%E5%AE%89%E5%85%A8.html"/>
    <id>https://fanerge.github.io/2018/web安全.html</id>
    <published>2018-05-09T14:05:43.000Z</published>
    <updated>2018-05-13T14:30:08.814Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲一些标准的规范使我们的Web更加安全，常见的Web安全问题将会在后面介绍（XSS、CSRF、MITM、SQL注入等），如有理解不当，还望指出，在此感谢。<br>文章略长，主体线索为首先介绍浏览器 <code>源Origin</code> 相关知识，它是Web安全的基石，后面的小节大多依赖该小节。</p><h1 id="同源策略（Same-origin-policy）"><a href="#同源策略（Same-origin-policy）" class="headerlink" title="同源策略（Same-origin policy）"></a>同源策略（Same-origin policy）</h1><p>同源策略限制了一个源（origin）中加载的文档或脚本与其他源（origin）中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。</p><h2 id="一个源的定义"><a href="#一个源的定义" class="headerlink" title="一个源的定义"></a>一个源的定义</h2><p>如果两个页面的协议、域名、端口（如果有指定）和都相同，则两个页面具有相同的源。</p><h2 id="源的继承"><a href="#源的继承" class="headerlink" title="源的继承"></a>源的继承</h2><p>data：URLs获得一个新的，空的安全上下文。<br>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。<br>例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  机制）。 如果此弹出窗口也包含代码，则该代码将继承与创建它的脚本相同的源。data: URL会得到一个新的空的安全上下文。<br>值得一提的时 IE 例外，当涉及到同源策略时，Internet Explorer 有两个主要的不同点授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。<br>端口：IE 未将端口号加入到同源策略的组成部分之中，因此 <code>http://company.com:81/index.html</code> 和 <code>http://company.com/index.html</code> 属于同源并且不受任何限制。</p><h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h2><p>页面可能会因某些限制而改变他的源。脚本可以将 document.domain 的值设置为其当前域或其当前域的超级域。如果将其设置为其当前域的超级域，则较短的域将用于后续源检查。<br>假设 <code>http://store.company.com/dir/other.html</code> 文档中的一个脚本执行以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.domain = &quot;company.com&quot;;</div></pre></td></tr></table></figure></p><p>这条语句执行之后，页面将会成功地通过对 <code>http://company.com/dir/page.html</code> 的同源检测（假设<code>http://company.com/dir/page.html</code> 将其 document.domain 设置为“company.com”）。然而，company.com 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的超级域。<br>PS：在根域范围内，浏览器允许你把domain属性的值设置为它的上一级域。例如，在 <code>cicada.alipay.com</code> 域内，可以把domain设置为 <code>alipay.com</code> 但不能设置为 <code>alipay.org</code> 或者 <code>com</code>。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain" target="_blank" rel="external">查看document.domain的用法</a><br>PS：浏览器单独保存端口号。任何的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此 <code>company.com:8080</code> 不能仅通过设置 document.domain = <code>company.com</code> 来与 <code>company.com</code> 通信，还必须在他们双方中都进行赋值，以确保端口号都为 null 。<br>使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。</p><h2 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h2><p>同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest 或 img 标签时则会受到同源策略的约束<br>这些交互通常分为三类：</p><ol><li>通常允许跨域写操作（Cross-origin writes）。例如链接（links）、重定向、表单提交。</li><li>通常允许跨域资源嵌入（Cross-origin embedding）。</li><li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法等。</li></ol><p>以下是可能嵌入跨源的资源的一些示例：</p><ol><li>script 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。</li><li>link 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。</li><li>img 嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,…</li><li>video 和 audio 嵌入多媒体资源。</li><li>object, embed 和 applet 的插件。</li><li>@font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</li><li>frame（已废弃） 和 iframe 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</li></ol><h2 id="允许-阻止跨域访问"><a href="#允许-阻止跨域访问" class="headerlink" title="允许/阻止跨域访问"></a>允许/阻止跨域访问</h2><h3 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a>如何允许跨源访问</h3><p>CORS、JSONP、document.domain、window.name、window.postMessage、CSST (CSS Text Transformation)这个比较少见的方案<br>以上方式各有使用场景，具体实现请看<a href="https://zhuanlan.zhihu.com/p/24198444" target="_blank" rel="external">知乎-关于前端跨域的整理</a></p><h3 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a>如何阻止跨源访问</h3><p>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。<br>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。<br>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Conten-Type 消息头。例如，如果您在HTML文档中指定 <code>&lt;script\&gt;</code> 标记，则浏览器将尝试将HTML解析为JavaScript。 当你的资源不是你网站的入口点时，你还可以使用CSRF令牌来防止嵌入。</p><h2 id="跨源脚本API访问"><a href="#跨源脚本API访问" class="headerlink" title="跨源脚本API访问"></a>跨源脚本API访问</h2><p>不同浏览器可能有差异，下面以标准为准。<br>Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制。<br>PS：为了在不同源中文档进一步交流，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a>。</p><h3 id="window（方法和属性）"><a href="#window（方法和属性）" class="headerlink" title="window（方法和属性）"></a>window（方法和属性）</h3><p>window.blur<br>window.close<br>window.focus<br>window.postMessage<br>window.closed    只读.<br>window.frames    只读.<br>window.length    只读.<br>window.location    读/写.<br>window.opener    只读.<br>window.parent    只读.<br>window.self    只读.<br>window.top    只读.<br>window.window  只读.</p><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>location.replace<br>location.href      只写.</p><h2 id="跨源数据存储访问"><a href="#跨源数据存储访问" class="headerlink" title="跨源数据存储访问"></a>跨源数据存储访问</h2><p>存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。<br>Cookies 使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。<br>PS：Public Suffix为互联网名称与数字地址分配机构)提供的 TLD(Top Level Domain，顶级域名)列表，如com、net、org等都属于这个列表。</p><h1 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP (内容安全策略)"></a>CSP (内容安全策略)</h1><p>内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。<br>其实CSP的本质是以白名单的机制对网站加载或执行的资源起作用。</p><h2 id="适用方式"><a href="#适用方式" class="headerlink" title="适用方式"></a>适用方式</h2><ol><li>可以通过配置你的网络服务器返回  Content-Security-Policy  HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部，它是旧版本)。</li><li>在html页面中meta元素中使用，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="支持的策略指令"><a href="#支持的策略指令" class="headerlink" title="支持的策略指令"></a>支持的策略指令</h2><h3 id="base-uri"><a href="#base-uri" class="headerlink" title="base-uri"></a>base-uri</h3><p>base-uri 指令定义了 URI，它可以作为文档的基准 URL。</p><h3 id="connect-src"><a href="#connect-src" class="headerlink" title="connect-src"></a>connect-src</h3><p>connect-src 指令定义了请求、XMLHttpRequest、WebSocket 和 EventSource（Server-Sent Events(简称SSE)） 的连接来源。</p><h3 id="default-src"><a href="#default-src" class="headerlink" title="default-src"></a>default-src</h3><p>default-src 指令定义了那些没有被更精确指令指定的（默认）安全策略。<br>该指令包含了以下指令：connect-src、font-src、img-src、media-src、object-src、script-src、style-src</p><h3 id="font-src"><a href="#font-src" class="headerlink" title="font-src"></a>font-src</h3><p>font-src 指令定义了通过 @font-face加载字体的有效源。</p><h3 id="form-action"><a href="#form-action" class="headerlink" title="form-action"></a>form-action</h3><p>指定form提交的源。</p><h3 id="frame-ancestors"><a href="#frame-ancestors" class="headerlink" title="frame-ancestors"></a>frame-ancestors</h3><p>frame、iframe的src属性源。</p><h3 id="img-src"><a href="#img-src" class="headerlink" title="img-src"></a>img-src</h3><p>img元素的src属性源。</p><h3 id="media-src"><a href="#media-src" class="headerlink" title="media-src"></a>media-src</h3><p>audio、video的加载源。</p><h3 id="object-src"><a href="#object-src" class="headerlink" title="object-src"></a>object-src</h3><p>object、embed、applet的加载源。</p><h3 id="plugin-types"><a href="#plugin-types" class="headerlink" title="plugin-types"></a>plugin-types</h3><p>plugin源。</p><h3 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h3><h3 id="script-src"><a href="#script-src" class="headerlink" title="script-src"></a>script-src</h3><p>script源，且禁用内联脚本和eval()。</p><h3 id="style-src"><a href="#style-src" class="headerlink" title="style-src"></a>style-src</h3><p>style的源。</p><h2 id="内容源"><a href="#内容源" class="headerlink" title="内容源"></a>内容源</h2><h3 id="源列表"><a href="#源列表" class="headerlink" title="源列表"></a>源列表</h3><p>源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的 URL 协议和/或端口号。<br><a href="http://*.foo.com" target="_blank" rel="external">http://*.foo.com</a><br>匹配所有使用 http: 协议加载 foo.com 任何子域名的尝试。<br>mail.foo.com:443<br>匹配所有访问 mail.foo.com 的 443 端口 的尝试。<br><a href="https://store.foo.com" target="_blank" rel="external">https://store.foo.com</a><br>匹配所有使用 https: 协议访问 store.foo.com 的尝试。<br>如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>‘none’<br>代表空集；即不匹配任何 URL。<br>‘self’<br>代表和文档同源，包括相同的 URL 协议和端口号。<br>‘unsafe-inline’<br>允许使用内联资源，如内联的 <code>script</code> 元素、javascript: URL、内联的事件处理函数和内联的 <code>style</code> 元素。<br>‘unsafe-eval’<br>允许使用 eval() 等通过字符串创建代码的方法。</p><h1 id="安全环境"><a href="#安全环境" class="headerlink" title="安全环境"></a>安全环境</h1><p>当浏览器满足安全的最低要求时将进入一种安全环境。安全环境允许浏览器暴露那些只有在被安全地传输给用户时才被允许的 APIs。<br>作用：安全上下文的主要目标是防止攻击者访问功能强大的api,可进一步妥协的攻击的受害者。</p><h2 id="检测环境是否安全"><a href="#检测环境是否安全" class="headerlink" title="检测环境是否安全"></a>检测环境是否安全</h2><p>你可以使用特征检测来判断上下文是否处于安全的上下文之中通过使用在全局作用域下公共的isSecureContext返回的布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 在安全环境下使用serviceWorker执行offline-worker.js</div><div class="line">if (window.isSecureContext) &#123;</div><div class="line">  // 页面是是个安全的上下文，服务可以正常使用。</div><div class="line">  navigator.serviceWorker.register(&quot;/offline-worker.js&quot;).then(function () &#123;</div><div class="line">    ...</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="如何保护我们站点"><a href="#如何保护我们站点" class="headerlink" title="如何保护我们站点"></a>如何保护我们站点</h1><h2 id="用户信息安全"><a href="#用户信息安全" class="headerlink" title="用户信息安全"></a>用户信息安全</h2><h3 id="如何关闭表单的自动补全功能"><a href="#如何关闭表单的自动补全功能" class="headerlink" title="如何关闭表单的自动补全功能"></a>如何关闭表单的自动补全功能</h3><p>许多浏览器表单字段支持自动补全功能; 因此他们的值可以被推荐和下一次用户访问你的网站时自动恢复。某一类型的数据, 你可能希望禁止这个功能。<br>默认情况下，浏览器会记录用户网页上提交的输入框的信息。这样浏览器便能够做到自动完成（在用户开始输入的时候给用户提供可能的内容）和自动填充（在加载的时候预先填充某些字段）功能。</p><h4 id="如何禁用自动填充？"><a href="#如何禁用自动填充？" class="headerlink" title="如何禁用自动填充？"></a>如何禁用自动填充？</h4><p>为整个表单设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;post&quot; action=&quot;/form&quot; autocomplete=&quot;off&quot;&gt;</div><div class="line">[…]</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p><p>为单个字段设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;post&quot; action=&quot;/form&quot;&gt;</div><div class="line">  […]</div><div class="line">&lt;label&gt;name：</div><div class="line">&lt;input type=&quot;text&quot; id=&quot;cc&quot; name=&quot;cc&quot; autocomplete=&quot;off&quot;&gt;</div><div class="line">&lt;/label&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p><p>在这里设置 autocomplete=”off” 会有两种效果：</p><ol><li>它会阻止浏览器为了以后自动完成类似的表单来自动保存表单数据，但是浏览器是不一样的。</li><li>它会阻止浏览器历史记录缓存中的表单数据。当表单数据来自缓存的时候，当用户点击返回按钮来返回的时候，用户填写的信息是可见的。</li></ol><p>PS：在某些情况下，即使浏览器的自动填充设置为off，浏览器依然会继续提示自动完成的值。这可能会让开发者百思不得其解。强制浏览器不自动填充的方法是为autocomplete设置一个随机的字符串，这个随机字符串不能为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input#attr-autocomplete" target="_blank" rel="external">autocomplete</a> 属性的可选值。</p><h4 id="自动填充属性和登录"><a href="#自动填充属性和登录" class="headerlink" title="自动填充属性和登录"></a>自动填充属性和登录</h4><p>现代浏览器继承了密码管理：当用户使用用户名和密码在一个网站上登录了，浏览器会替用户记住它（用户名和密码）。当用户再次访问站点你的时候，浏览器会自动使用存储的数据自动填充登录模块。<br>由于这个原因，许多现代浏览器都不支持在登录模块中设置 autocomplete=”off” ：</p><ol><li>如果一个网站为表单设置了autocomplete=”off”，如果表单包含了用户名和密码，浏览器依然会记住登录信息，并且如果用户同意，浏览器会在下一次用户访问网站的时候自动填充信息。</li><li>如果网站给用户名和密码的输入框设置了autocomplete=”off”，浏览器依然会记住这次登录，如果用户同意，浏览器将会在用户下次访问的时候自动填充登录信息。</li></ol><p>如果想要阻止在用户管理页面中填写密码字段，用户可以为自己以外的人指定新的密码，虽然所有的浏览器都还不支持，但是autocomplete = “new-password”应该被指定。</p><h3 id="隐私与-visited选择器"><a href="#隐私与-visited选择器" class="headerlink" title="隐私与:visited选择器"></a>隐私与:visited选择器</h3><h4 id="为什么说-visited选择器暴露了用户隐私？"><a href="#为什么说-visited选择器暴露了用户隐私？" class="headerlink" title="为什么说:visited选择器暴露了用户隐私？"></a>为什么说:visited选择器暴露了用户隐私？</h4><p>曾经，CSS选择器 :visited 被网站用来查看用户的浏览记录。通过使用 getComputedStyle() 或其他方法扫描用户的浏览记录来获取用户访问了哪些网站。这很容易实现，不仅能够判断用户是否曾经访问过这个页面，还能猜测出大量的用户身份信息。</p><h4 id="浏览器的处理"><a href="#浏览器的处理" class="headerlink" title="浏览器的处理"></a>浏览器的处理</h4><p>浏览器会在某些情况下对网页程序撒谎，尤其是 getComputedStyle() 和类似的功能，比如 element.querySelector() 总是返回值表示用户从未访问过网页上的任何一个链接。<br>另外，如果用到了兄弟选择器，如 :visited + span，\<span\> 显示为未访问的样式。<br>而且，在极少的情况下，如果用到了嵌套链接元素并且这个匹配的元素与历史记录中的不同，这个链接也以未访问的样式绘制。</span\></p><h4 id="对已访问链接样式的限制"><a href="#对已访问链接样式的限制" class="headerlink" title="对已访问链接样式的限制"></a>对已访问链接样式的限制</h4><p>你仍然可以给已访问链接设置视觉样式，但是对可用样式作出了限制。只有下列的属性才能被应用到已访问链接：</p><ol><li>color</li><li>background-color</li><li>border-color (and its sub-properties)</li><li>outline-color</li><li>fill 和 stroke 属性的颜色部分（SVG中使用）</li></ol><h2 id="内容安全"><a href="#内容安全" class="headerlink" title="内容安全"></a>内容安全</h2><h3 id="正确配置服务器的MIME-Types"><a href="#正确配置服务器的MIME-Types" class="headerlink" title="正确配置服务器的MIME Types"></a>正确配置服务器的MIME Types</h3><h4 id="什么是MIME-Types？"><a href="#什么是MIME-Types？" class="headerlink" title="什么是MIME Types？"></a>什么是MIME Types？</h4><p>MIME类型描述内容的媒体类型在电子邮件或由web服务器或web应用程序,旨在帮助指导web浏览器如何处理并显示内容。<br>常用的MIME Types？</p><ol><li>text/html for normal web pages</li><li>text/plain for plain text</li><li>text/css for Cascading Style Sheets</li><li>text/javascript for scripts</li><li>application/octet-stream meaning “download this file”</li><li>application/x-java-applet for Java applets</li><li>application/pdf for PDF documents</li></ol><h4 id="为什么是正确的MIME类型"><a href="#为什么是正确的MIME类型" class="headerlink" title="为什么是正确的MIME类型?"></a>为什么是正确的MIME类型?</h4><p>如果web服务器或应用程序设置了的不正确的MIME类型，一个web浏览器没有方法通过HTTP规范从而知道作者想要怎样处理它。<br>大多数浏览器允许错误配置MIME Types的web服务器和应用程序可以通过猜测其MIME Types。<br>服务内容使用正确的MIME类型也可以是重要的出于安全原因;恶意内容可能影响用户的计算机，冒充一个安全的类型的文档。</p><h4 id="如何设置您的服务器发送正确的MIME类型？"><a href="#如何设置您的服务器发送正确的MIME类型？" class="headerlink" title="如何设置您的服务器发送正确的MIME类型？"></a>如何设置您的服务器发送正确的MIME类型？</h4><p>如果你使用Apache web服务器,只需将这个示例. htaccess文件复制到目录,其中包含您想要发送的文件正确的MIME类型。如果你有一个完整的子目录的文件,就把文件在父目录;你不需要把它在每个子目录。<br>如果你使用Microsoft IIS,<a href="https://blog.csdn.net/xcymorningsun/article/details/53195521" target="_blank" rel="external">看到这篇文章</a>。<br>如果您正在使用一个服务器端脚本（Perl, PHP, ASP, or Java）生成内容,通常可以添加一行脚本的顶部。只需要设置正确的 Content-Type。</p><h3 id="严格使用HTTPS（HSTS）"><a href="#严格使用HTTPS（HSTS）" class="headerlink" title="严格使用HTTPS（HSTS）"></a>严格使用HTTPS（HSTS）</h3><p>HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP。</p><h4 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h4><p>你连接到一个免费WiFi接入点，然后开始浏览网站，访问你的网上银行，查看你的支出，并且支付一些订单。很不幸，你接入的WiFi实际上是黑客的笔记本热点，他们拦截了你最初的HTTP请求，然后跳转到一个你银行网站一模一样的钓鱼网站。 现在，你的隐私数据暴露给黑客了。<br>Strict Transport Security解决了这个问题；只要你通过HTTPS请求访问银行网站，并且银行网站配置好Strict Transport Security，你的浏览器知道自动使用HTTPS请求，这可以阻止黑客的中间人攻击的把戏。</p><h4 id="浏览器如何处理？"><a href="#浏览器如何处理？" class="headerlink" title="浏览器如何处理？"></a>浏览器如何处理？</h4><p>你的网站第一次通过HTTPS请求，服务器响应Strict-Transport-Security 头，浏览器记录下这些信息，然后后面尝试访问这个网站的请求都会自动把HTTP替换为HTTPS。<br>当HSTS头设置的过期时间到了，后面通过HTTP的访问恢复到正常模式，不会再自动跳转到HTTPS。<br>每次浏览器接收到Strict-Transport-Security头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。<br>Chrome、Firefox等浏览器里，当您尝试访问该域名下的内容时，会产生一个307 Internal Redirect（内部跳转），自动跳转到HTTPS请求。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Strict-Transport-Security: max-age=&lt;expire-time&gt;</div><div class="line">Strict-Transport-Security: max-age=&lt;expire-time&gt;; includeSubDomains</div><div class="line">Strict-Transport-Security: max-age=&lt;expire-time&gt;; preload</div></pre></td></tr></table></figure><h2 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h2><p>CORS属于HTTP访问控制特性，以下内容大多针对于XMLHttpRequest，有些并不适用于 Fetch 。<br>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。<br>比如，站点 <code>http://domain-a.com</code> 的某 HTML 页面通过 <code>img</code> 的 <code>src</code> 请求 <code>http://domain-b.com/image.jpg</code>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。<br>PS：跨域并非不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）<br>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><h3 id="CORS分类"><a href="#CORS分类" class="headerlink" title="CORS分类"></a>CORS分类</h3><p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。<br>相关请求头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Origin: http://api.bob.com</div></pre></td></tr></table></figure></p><p>PS：上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>相关响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div></pre></td></tr></table></figure></p><p>PS：<br>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>整个过程（<code>预检请求/响应-&gt;正常请求/响应</code>）<br><code>预检请求</code><br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>相关请求头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Origin: http://api.bob.com</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div></pre></td></tr></table></figure></p><p>PS：<br>（1）Origin代表请求源。<br>（2）Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。<br>（3）Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>相关响应头<br>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure></p><p>PS：<br>（1）Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（2）Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（3）Access-Control-Allow-Credentials<br>该字段与简单请求时的含义相同。<br>（4）Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<br><code>正常请求</code><br>预检请求成功后就可以进行正常请求了，相应的请求头和响应头与简单请求类似。</p><h4 id="相关请求头和响应头总结"><a href="#相关请求头和响应头总结" class="headerlink" title="相关请求头和响应头总结"></a>相关请求头和响应头总结</h4><p><code>请求头</code><br>Origin<br>语法：Origin: <origin><br>作用：表明预检请求或实际请求的源站。<br>Access-Control-Request-Method<br>语法：Access-Control-Request-Method: <method><br>作用：用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。<br>Access-Control-Request-Headers<br>语法：Access-Control-Request-Headers: <field-name>[, <field-name>]<em><br>作用：用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。<br><code>响应头</code><br>Access-Control-Allow-Origin<br>语法：Access-Control-Allow-Origin: origin | `</em><code>作用：允许访问该资源的外域 URI。Access-Control-Expose-Headers语法：Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header作用：在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。Access-Control-Max-Age语法：Access-Control-Max-Age: delta-seconds作用：Access-Control-Max-Age 头指定了预检请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。Access-Control-Allow-Credentials语法：Access-Control-Allow-Credentials: true作用：指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。Access-Control-Allow-Methods语法：Access-Control-Allow-Methods:  method[, method]</code><em><code>作用：用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。Access-Control-Allow-Headers语法：Access-Control-Allow-Headers: field-name [, field-name]</code></em>`<br>作用：用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</field-name></field-name></method></origin></p><h1 id="X-Frame-Options-响应头"><a href="#X-Frame-Options-响应头" class="headerlink" title="X-Frame-Options 响应头"></a>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>frame</code>（已废弃）, <code>iframe</code> 或者 <code>object</code> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p><h2 id="使用-X-Frame-Options"><a href="#使用-X-Frame-Options" class="headerlink" title="使用 X-Frame-Options"></a>使用 X-Frame-Options</h2><p>X-Frame-Options 有三个值:<br>DENY<br>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。<br>SAMEORIGIN<br>表示该页面可以在相同域名页面的 frame 中展示。<br>ALLOW-FROM uri<br>表示该页面可以在指定来源的 frame 中展示。<br>PS：如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:<br><code>Header always append X-Frame-Options SAMEORIGIN</code></p><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:<br><code>add_header X-Frame-Options SAMEORIGIN;</code></p><h3 id="配置-IIS"><a href="#配置-IIS" class="headerlink" title="配置 IIS"></a>配置 IIS</h3><p>配置 IIS 发送 X-Frame-Options 响应头，添加下面的配置到 Web.config 文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;system.webServer&gt;</div><div class="line">  ...</div><div class="line">  &lt;httpProtocol&gt;</div><div class="line">    &lt;customHeaders&gt;</div><div class="line">      &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt;</div><div class="line">    &lt;/customHeaders&gt;</div><div class="line">  &lt;/httpProtocol&gt;</div><div class="line">  ...</div><div class="line">&lt;/system.webServer&gt;</div></pre></td></tr></table></figure></p><p>PS：注意: CSP Level 2 规范中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用。<br><a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">除了通过服务器配置防止自己网页被iframe形式嵌入，还可以使用js处理。</a></p><h1 id="子资源完整性（SRI）"><a href="#子资源完整性（SRI）" class="headerlink" title="子资源完整性（SRI）"></a>子资源完整性（SRI）</h1><p>子资源完整性(Subresource Integrity)是允许浏览器检查其获得的资源（例如从 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CDN" target="_blank" rel="external">CDN</a> 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。<br>子资源完整性 (SRI) 是一种安全功能，允许浏览器验证所获取的文件 (比如，从一个 CDN 内容分发网络) 是无意外操作而交付的。它的工作原理是允许你提供一个获取文件必须匹配的加密哈希。</p><h2 id="SRI-如何工作"><a href="#SRI-如何工作" class="headerlink" title="SRI 如何工作"></a>SRI 如何工作</h2><p>使用 内容分发网络 (CDN) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件)），因此可能潜在地攻击所有从该 CDN 获取文件的站点。<br>子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。</p><h2 id="如何使用-SRI"><a href="#如何使用-SRI" class="headerlink" title="如何使用 SRI"></a>如何使用 SRI</h2><p>将使用 base64 编码过后的文件哈希值写入你所引用的 \<script\> 或 \<link\> 标签的 integrigy 属性值中即可启用子资源完整性功能。<br>PS：integrity 值分成两个部分，第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。<br>integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。</link\></script\></p><h3 id="内容安全策略（CSP）和子资源完整性（SRI）共同使用"><a href="#内容安全策略（CSP）和子资源完整性（SRI）共同使用" class="headerlink" title="内容安全策略（CSP）和子资源完整性（SRI）共同使用"></a>内容安全策略（CSP）和子资源完整性（SRI）共同使用</h3><p>你可以根据内容安全策略来配置你的服务器使得指定类型的文件遵守 SRI。这是通过在 CSP 头部添加 require-sri-for 指令实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这条指令规定了所有 JavaScript 都要有 integrity 属性，且通过验证才能被加载。</div><div class="line">Content-Security-Policy: require-sri-for script;</div><div class="line">// 你也可以指定所有样式表也要通过 SRI 验证：</div><div class="line">Content-Security-Policy: require-sri-for style;</div></pre></td></tr></table></figure></p><p>你也可以对两者都加上验证。</p><h2 id="生成-SRI-哈希的工具"><a href="#生成-SRI-哈希的工具" class="headerlink" title="生成 SRI 哈希的工具"></a>生成 SRI 哈希的工具</h2><h3 id="openssl-在命令行"><a href="#openssl-在命令行" class="headerlink" title="openssl 在命令行"></a>openssl 在命令行</h3><p>你可以用 openssl 在命令行中执行如下命令来生成 SRI 哈希值：<br><code>cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A</code><br><a href="https://www.srihash.org/" target="_blank" rel="external">在线生成 SRI 哈希值的工具</a><br>下面以知乎的一个js文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原js文件地址</div><div class="line">https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js</div><div class="line">// 生成的脚本标签</div><div class="line">&lt;script src=&quot;https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js&quot; integrity=&quot;sha384-B4YDh2AljLezOmNwiezobW8FJbJQfyZxm1SksT7THfKULK6SVxN+dRNSvLxEmXtA&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><h3 id="shasum-在命令行"><a href="#shasum-在命令行" class="headerlink" title="shasum 在命令行"></a>shasum 在命令行</h3><p><code>shasum -b -a 384 FILENAME.js | xxd -r -p | base64</code></p><h1 id="用户密码是泄漏的原因？"><a href="#用户密码是泄漏的原因？" class="headerlink" title="用户密码是泄漏的原因？"></a>用户密码是泄漏的原因？</h1><p> HTTPS 协议旨在保护用户数据在网络上不被窃听（机密性） 和不被篡改（完整性）。处理用户数据的网站应该使用 HTTPS 协议保护他们的用户不受黑客的侵害。如果网站使用 HTTP 协议而不是 HTTPS 协议，窃取用户信息（比如他们的登录凭证）将会轻而易举。这曾经被 <a href="http://codebutler.github.io/firesheep/" target="_blank" rel="external">Firesheep</a> 很好地演示过。<br>这里罗列出密码所牵涉到的安全问题：</p><ol><li>在HTTP之上运行登录表单. 即使表单的action对象是HTTPS链接,用户的登录表单信息也会受到威胁,因为攻击者能够通过用户修改用户接收到的页面(例如,攻击者插入键盘记录脚本来盗取用户输入的密码.他们还能改变表单目的页从而将敏感信息传递到受他们控制的服务器).</li><li>在表单的action链接中使用HTTP链接.在这种情况下,用户输入的任何信息都将以明文方式通过网络传递.这样,从密码离开用户的电脑到密码到达服务器过程中,用户的密码将清楚地展现在任何嗅探用户网络的人眼前.</li><li>在网页iframe中递交登录表单(或是嵌入在HTTP frame中的HTTPS frame).即使最上层页面是HTTPS,但在HTTP iframe中包含密码域和在HTTP页面中包含密码域是没有区别的.攻击者同样能够修改这个页面以及偷取用户信息.</li><li>有时网页需要用户名及密码,但实际上却没有存储这些敏感的信息.例如,一个新闻页面可能存储一个用户想要再次阅读的文章,却没有存储任何关于这位用户的其他信息.这个新闻站点的网页开发者可能没有动力去对于提高他的网站的安全性以及保护他们用户的信息.不幸的是,密码重用也是一个大问题.用户可能在不同的站点使用相同的密码(新闻网页,社交网络,电子邮箱及其银行).因此即使通过用户名及密码登陆你的网页对你来说不是很大的问题,对于重复使用相同用户名及密码来登陆他们银行账户的用户来说却是一个极大的威胁.网络攻击者正变得越来越聪明.他们在一个网站同时盗取用户名及密码然后在另一个可能能给他们带来金钱的网站上使用这些密码.</li></ol><h1 id="弱签名算法"><a href="#弱签名算法" class="headerlink" title="弱签名算法"></a>弱签名算法</h1><p>在签署数字证书时，哈希算法的完整性是决定证书安全性的关键因素。哈希算法的弱点可能导致攻击者在某些情况下能够获得伪造的证书。由于技术的升级和已知的新型攻击，此类攻击的可行性已经大为提升。因此，不推荐使用旧算法，对于旧算法的支持最终也会停止。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>对基于MD5的签名的支持已在2012年初停止。</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>基于SHA-1的签名非常普遍；截至2015年5月，大约45%的数字证书皆使用此算法。但是，SHA-1已经过时因而不再推荐使用。<br>SHA-1的证书将从2017开始不再被主流浏览器厂商视为安全的。</p><h2 id="SHA-2（推荐使用）"><a href="#SHA-2（推荐使用）" class="headerlink" title="SHA-2（推荐使用）"></a>SHA-2（推荐使用）</h2><p>SHA-2是一个哈希算法家族，其中包括SHA-256和SHA-512。截至2015年，SHA-2家族被认为足够安全强大。许多证书颁发机构颁发新的证书使用SHA-256。</p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">浏览器的同源策略</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://publicsuffix.org/" target="_blank" rel="external">PUBLIC SUFFIX LIST</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://www.srihash.org/" target="_blank" rel="external">SRI Hash Generator</a><br><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">HTTPS</a><br><a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt，免费好用的 HTTPS 证书</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲一些标准的规范使我们的Web更加安全，常见的Web安全问题将会在后面介绍（XSS、CSRF、MITM、SQL注入等），如有理解不当，还望指出，在此感谢。&lt;br&gt;文章略长，主体线索为首先介绍浏览器 &lt;code&gt;源Origin&lt;/code&gt; 相关知识，它是Web安全的
      
    
    </summary>
    
      <category term="安全" scheme="https://fanerge.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://fanerge.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>dom接口</title>
    <link href="https://fanerge.github.io/2018/dom%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://fanerge.github.io/2018/dom接口.html</id>
    <published>2018-05-08T12:43:18.000Z</published>
    <updated>2018-05-08T14:24:35.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CustomEvent"><a href="#CustomEvent" class="headerlink" title="CustomEvent"></a>CustomEvent</h1><p>创建一个自定义事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 添加一个适当的事件监听器</div><div class="line">obj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;)</div><div class="line"></div><div class="line">// 创建一个自定义事件</div><div class="line">var event = new CustomEvent(&quot;cat&quot;, &#123;&quot;detail&quot;:&#123;&quot;hazcheeseburger&quot;:true&#125;&#125;)</div><div class="line">// 分发事件</div><div class="line">obj.dispatchEvent(event)</div></pre></td></tr></table></figure></p><h1 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h1><p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。<br>DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。</p><h2 id="创建一个DocumentFragment"><a href="#创建一个DocumentFragment" class="headerlink" title="创建一个DocumentFragment"></a>创建一个DocumentFragment</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let ul = document.querySelector(`[data-uid=&quot;ul&quot;]`);</div><div class="line">let frag = document.createDocumentFragment();</div><div class="line">const list = [</div><div class="line">&apos;IE&apos;,</div><div class="line">&apos;Chrome&apos;</div><div class="line">];</div><div class="line">list.forEach(item =&gt; &#123;</div><div class="line">let li = document.creteElement(&apos;li&apos;);</div><div class="line">li.textContent = item;</div><div class="line">frag.appendChild(li);</div><div class="line">&#125;);</div><div class="line">// 只进行一次dom操作，触发一次reflow</div><div class="line">ul.appendChild(frag);</div><div class="line">```</div><div class="line">##其他方法（实例方法）</div></pre></td></tr></table></figure><p>documentFragment.find()<br>返回 DocumentFragment 树里第一个匹配的元素 Element 。<br>documentFragment.findAll()<br>返回 DocumentFragment 树里所有匹配的元素  NodeList。<br>documentFragment.querySelector()<br>documentFragment.querySelectorAll()<br>documentFragment.getElementById()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#MutationObserver</div><div class="line">给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</div><div class="line">##实例方法</div><div class="line">observe()</div><div class="line">给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.</div><div class="line">disconnect()</div><div class="line">让该观察者对象停止观察指定目标的DOM变化.即使再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.</div><div class="line">takeRecords()</div><div class="line">清空观察者对象的记录队列,并返回里面的内容.</div><div class="line">##示例</div></pre></td></tr></table></figure></p><p>let target = document.querySelector(‘#some-id’);</p><p>// 创建观察者对象<br>let observer = new MutationObserver(function(mutations) {<br>  mutations.forEach(function(mutation) {<br>    console.log(mutation.type);<br>  });<br>});</p><p>// 配置观察选项:<br>let config = { attributes: true, childList: true, characterData: true }</p><p>// 传入目标节点和观察选项<br>observer.observe(target, config);</p><p>// 随后,你还可以停止观察<br>observer.disconnect();<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CustomEvent&quot;&gt;&lt;a href=&quot;#CustomEvent&quot; class=&quot;headerlink&quot; title=&quot;CustomEvent&quot;&gt;&lt;/a&gt;CustomEvent&lt;/h1&gt;&lt;p&gt;创建一个自定义事件。&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>git工具书</title>
    <link href="https://fanerge.github.io/2018/git%E5%B7%A5%E5%85%B7%E4%B9%A6.html"/>
    <id>https://fanerge.github.io/2018/git工具书.html</id>
    <published>2018-04-23T14:41:30.000Z</published>
    <updated>2018-05-09T12:18:24.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%86.png" alt="git原理"><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">图片来源</a><br>PS：<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="git托管项目（新建-or-clone一个git项目）"><a href="#git托管项目（新建-or-clone一个git项目）" class="headerlink" title="git托管项目（新建 or clone一个git项目）"></a>git托管项目（新建 or clone一个git项目）</h2><p>mkdir gitdemo // 在当前目录创建gitdemo目录<br>cd gitdemo<br>pwd // 显示当前目录<br>git init // 将当前目录设置为git管理的仓库<br>git init [projectName] // 新建一个目录，将其初始化为Git代码库<br>or<br>git clone [ssh/https]</p><h2 id="工作区-gt-gt-暂存区（add为添加文件rm为移除文件）"><a href="#工作区-gt-gt-暂存区（add为添加文件rm为移除文件）" class="headerlink" title="工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）"></a>工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）</h2><p>git add [fileName] // 单个或多个文件<br>git add *.js // 通配符<br>git add -u  // 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .  // 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件<br>git add -A  // 提交所有变化（是git add .和git add -u的结合，git add -all的简写</p><p>git rm [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区<br>git rm --cached [fileName] // 停止追踪指定文件，但该文件会保留在工作区<br>git mv [fileNameOld] [fileNameNew] // 改名文件，并且将这个改名放入暂存区</p><h2 id="暂存区-gt-gt-本地仓库"><a href="#暂存区-gt-gt-本地仓库" class="headerlink" title="暂存区&gt;&gt;本地仓库"></a>暂存区&gt;&gt;本地仓库</h2><p>git commit -m ‘说明信息’ // 提交<br>git commit -am ‘说明’ // git add . 和 git commit的简写（一次完成两个动作）<br>常用commit type</p><ul><li>feat: 新功能</li><li>fix: 修复问题</li><li>docs: 修改文档</li><li>style: 修改代码格式，不影响代码逻辑</li><li>refactor: 重构代码，理论上不影响现有功能</li><li>perf: 提升性能</li><li>test: 增加修改测试用例</li><li>chore: 修改工具相关（包括但不限于文档、代码生成等）</li></ul><h2 id="本地仓库-gt-gt-远程仓库"><a href="#本地仓库-gt-gt-远程仓库" class="headerlink" title="本地仓库&gt;&gt;远程仓库"></a>本地仓库&gt;&gt;远程仓库</h2><p>git push ssh://git@dev.fanerge.com/gitdemo.git master // 把本地仓库提交到远程仓库的master分支中<br>git push -u origin master // 当前分支提交到远程 master 分支<br>git push // 如果当前分支与远程分支存在追踪关系</p><h2 id="远程仓库-gt-gt-本地仓库"><a href="#远程仓库-gt-gt-本地仓库" class="headerlink" title="远程仓库&gt;&gt;本地仓库"></a>远程仓库&gt;&gt;本地仓库</h2><p>git fetch [远程主机名] [分支名] // 远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地<br>git fetch origin master<br>git clone [ssh/https]// 从远程主机克隆一个版本库<br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">更详细的资料</a></p><h2 id="远程仓库-gt-gt-工作区"><a href="#远程仓库-gt-gt-工作区" class="headerlink" title="远程仓库&gt;&gt;工作区"></a>远程仓库&gt;&gt;工作区</h2><p>git pull [远程主机名] [远程分支名]:[本地分支名] // 远程主机某个分支的更新，再与本地的指定分支合并<br>git pull // 当前分支只有一个追踪分支时可省略部分参数</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>git branch // 查看本地所有分支（*表示当前分支）<br>git branch -v // 查看本地所有分支及最近一次提交信息<br>git branch -vv // 查看本地所有分支及最近一次提交信息和远程追踪分支<br>git branch -r // 查看远程所有分支<br>git branch -a // 查看本地/远程所有分支</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout [branchName] // 切换分支<br>git checkout - // 切换到上一个分支</p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>git branch [branchName] // 新建一个分支（但仍然留在当前分支）<br>git checkout -b [branchName] // 新建一个分支（并切换到该分支）<br>git branch [branchName] [commitId] // 新建一个分支（并指向指定的commitId）<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>如：新建 test 分支，并指向远程的 orign/dev 分支<br>git branch --track test origin/dev</p><h2 id="新建远程分支（新建本地分支，推送的远程作为远程分支）"><a href="#新建远程分支（新建本地分支，推送的远程作为远程分支）" class="headerlink" title="新建远程分支（新建本地分支，推送的远程作为远程分支）"></a>新建远程分支（新建本地分支，推送的远程作为远程分支）</h2><p>git branch [branchName]<br>git push origin [branchName]:[remoteBranchName]<br>还需要为新建本地分支和远程分支建立追踪关系<br>如：本地的 test 分支作为远程的 dev 分支<br>git push origin test:dev</p><h2 id="建立追踪关系（当前分支和远程分支）"><a href="#建立追踪关系（当前分支和远程分支）" class="headerlink" title="建立追踪关系（当前分支和远程分支）"></a>建立追踪关系（当前分支和远程分支）</h2><p>作用：用来描述当前和远程分支的位置关系，在使用git pull 和 git push 的时候可以省略远程参数<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>git branch –-set-upstream-to=origin/[branchName]<br>如：当前分支和远程 dev 分支建立追踪关系<br>git branch –-set-upstream-to=origin/dev</p><h2 id="合并分支（branchName合并到当前分支）"><a href="#合并分支（branchName合并到当前分支）" class="headerlink" title="合并分支（branchName合并到当前分支）"></a>合并分支（branchName合并到当前分支）</h2><p>git merge [branchName]<br>git rebase [branchName]<br>PS：<br>git merge dev（当前分支为master）<br>会在 master 分支产生一个新的commit。<br>git rebase dev（当前分支为master）<br>会将master上的提交推至顶端。</p><h2 id="删除分支（本地）"><a href="#删除分支（本地）" class="headerlink" title="删除分支（本地）"></a>删除分支（本地）</h2><p>git branch -d [branchName] // 删除分支（本地）<br>git push origin --delete [branchName] // 删除分支（远程）<br>git branch -dr [remoteBranchName] // 删除分支（远程）</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>tag作用类似于里程碑，可以快速找到里程碑的代码。</p><h2 id="查看所有tag"><a href="#查看所有tag" class="headerlink" title="查看所有tag"></a>查看所有tag</h2><p>git tag</p><h2 id="新建tag在当前commit"><a href="#新建tag在当前commit" class="headerlink" title="新建tag在当前commit"></a>新建tag在当前commit</h2><p>git tag [tagName]</p><h2 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h2><p>git tag [tagName] [commitId]</p><h2 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h2><p>git tag -d [tagName]</p><h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><p>git push origin :refs/tags/[tagName]</p><h2 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h2><p>git show [tagName]</p><h2 id="向远程提交指定tag"><a href="#向远程提交指定tag" class="headerlink" title="向远程提交指定tag"></a>向远程提交指定tag</h2><p>git push [remoteBranchName] [tagName]</p><h2 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h2><p>git checkout -b [branchName] [tagName]</p><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><h2 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h2><p>git status</p><h2 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h2><p>git log</p><h2 id="显示当前分支的版本历史（包括commit发生变更的文件）"><a href="#显示当前分支的版本历史（包括commit发生变更的文件）" class="headerlink" title="显示当前分支的版本历史（包括commit发生变更的文件）"></a>显示当前分支的版本历史（包括commit发生变更的文件）</h2><p>git log –stat</p><h2 id="显示当前分支的版本历史（通过关键词）"><a href="#显示当前分支的版本历史（通过关键词）" class="headerlink" title="显示当前分支的版本历史（通过关键词）"></a>显示当前分支的版本历史（通过关键词）</h2><p>git log -S [keyword]</p><h2 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h2><p>git log [tagName] HEAD –pretty=format:%s</p><h2 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h2><p>git log [tagName] HEAD –grep feature</p><h2 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h2><p>git log –follow [fileName]<br>git whatchanged [fileName]</p><h2 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h2><p>git log -p [fileName]</p><h2 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h2><p>git log -5 –pretty –oneline</p><h2 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h2><p>git shortlog -sn</p><h2 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h2><p>git blame [file]</p><h2 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h2><p>git biff</p><h2 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h2><p>git diff –cached [fileName]</p><h2 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h2><p>git diff HEAD</p><h2 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h2><p>git diff [first-branch]…[second-branch]</p><h2 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h2><p>git diff –shortstat “@{0 day ago}”</p><h2 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h2><p>git show [commitId]</p><h2 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h2><p>git show –name-only [commitId]</p><h2 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h2><p>git show [commitId]:[fileName]</p><h2 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h2><p>git reflog</p><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h2><p>git fetch [ssh/https]</p><h2 id="显示所有远程仓库（包括fetch和push地址）"><a href="#显示所有远程仓库（包括fetch和push地址）" class="headerlink" title="显示所有远程仓库（包括fetch和push地址）"></a>显示所有远程仓库（包括fetch和push地址）</h2><p>git remote -v</p><h2 id="显示某一远程仓库的信息"><a href="#显示某一远程仓库的信息" class="headerlink" title="显示某一远程仓库的信息"></a>显示某一远程仓库的信息</h2><p>git remote show [remoteRepositoryName]</p><h2 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h2><p>git remote add [shortname] [url]</p><h2 id="取回远程仓库的变化，并与本地分支合并（merge）"><a href="#取回远程仓库的变化，并与本地分支合并（merge）" class="headerlink" title="取回远程仓库的变化，并与本地分支合并（merge）"></a>取回远程仓库的变化，并与本地分支合并（merge）</h2><p>git pull [remote] [remoteBranchName]<br>PS：remote 一般为 origin ，当建立追踪关系，可以git pull 省略两个参数</p><h2 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h2><p>git push [remote] [branchName]</p><h2 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h2><p>git push [remote] –force</p><h2 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h2><p>git push [remote] –all</p><h1 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销/恢复"></a>撤销/恢复</h1><h2 id="撤销工作区修改（指定文件）"><a href="#撤销工作区修改（指定文件）" class="headerlink" title="撤销工作区修改（指定文件）"></a>撤销工作区修改（指定文件）</h2><p>git chekout – [fileName]</p><h2 id="撤销工作区（所有文件）"><a href="#撤销工作区（所有文件）" class="headerlink" title="撤销工作区（所有文件）"></a>撤销工作区（所有文件）</h2><p>git checkout – .</p><h2 id="暂存区–-gt-工作区（指定文件）"><a href="#暂存区–-gt-工作区（指定文件）" class="headerlink" title="暂存区–&gt;工作区（指定文件）"></a>暂存区–&gt;工作区（指定文件）</h2><p>git reset HEAD [fileName] // 撤销暂存区的修改<br>git checkout [fileName] // 撤销工作区的修改</p><h2 id="重置暂存区到上次提交commit（工作区不变）"><a href="#重置暂存区到上次提交commit（工作区不变）" class="headerlink" title="重置暂存区到上次提交commit（工作区不变）"></a>重置暂存区到上次提交commit（工作区不变）</h2><p>git reset [fileName]</p><h2 id="重置暂存区、工作区到上次提交commit"><a href="#重置暂存区、工作区到上次提交commit" class="headerlink" title="重置暂存区、工作区到上次提交commit"></a>重置暂存区、工作区到上次提交commit</h2><p>git reset –hard<br>git reset HEAD^ –hard // 回到上一次commit<br>git reset HEAD^^ –hard // 回到上一次的上一次commit</p><h2 id="重置暂存区、当前分支指定commitId（工作区不变）"><a href="#重置暂存区、当前分支指定commitId（工作区不变）" class="headerlink" title="重置暂存区、当前分支指定commitId（工作区不变）"></a>重置暂存区、当前分支指定commitId（工作区不变）</h2><p>git reset [commitId]</p><h2 id="重置暂存区、工作区、当前分支为指定commitId"><a href="#重置暂存区、工作区、当前分支为指定commitId" class="headerlink" title="重置暂存区、工作区、当前分支为指定commitId"></a>重置暂存区、工作区、当前分支为指定commitId</h2><p>git reset –hard [commitId]</p><h2 id="重置当前HEAD为指定commitId（暂存区、工作区不表）"><a href="#重置当前HEAD为指定commitId（暂存区、工作区不表）" class="headerlink" title="重置当前HEAD为指定commitId（暂存区、工作区不表）"></a>重置当前HEAD为指定commitId（暂存区、工作区不表）</h2><p>git reset –keep [commitId]</p><h2 id="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"><a href="#新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）" class="headerlink" title="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"></a>新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）</h2><p>git revert [commitId]</p><h2 id="暂时将未提交的变化存于stash，后续再从stash中取出"><a href="#暂时将未提交的变化存于stash，后续再从stash中取出" class="headerlink" title="暂时将未提交的变化存于stash，后续再从stash中取出"></a>暂时将未提交的变化存于stash，后续再从stash中取出</h2><p>git stash list // 查看 stash 列表<br>git stash // 保存当前暂未提交的修改<br>git stash apply // 从stash中恢复，但不清除该stash<br>git stash drop  // 清除该stash<br>git stash pop // 从stash中恢复并清除该stash<br>PS：一般用于停下手中活，处理更加紧急的任务，处理完任务后在回过头继续。<br>git stash pop = git stash apply + git stash drop</p><blockquote><p>   参考文档：<br><a href="https://git-scm.com/" target="_blank" rel="external">git 官网</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="external">Git教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%
      
    
    </summary>
    
      <category term="代码管理" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://fanerge.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>js算法集合</title>
    <link href="https://fanerge.github.io/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html"/>
    <id>https://fanerge.github.io/2018/js算法集合.html</id>
    <published>2018-04-08T14:20:17.000Z</published>
    <updated>2018-04-25T14:04:52.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断文本是否为回文"><a href="#判断文本是否为回文" class="headerlink" title="判断文本是否为回文"></a>判断文本是否为回文</h1><p>定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。</p><h2 id="方法一（字符串、数组内置方法）"><a href="#方法一（字符串、数组内置方法）" class="headerlink" title="方法一（字符串、数组内置方法）"></a>方法一（字符串、数组内置方法）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome1(val)&#123;</div><div class="line">// 允许输入字符串和数字和布尔值</div><div class="line">if (typeof val !== &apos;string&apos;) val = val.toString();</div><div class="line">let newVal = val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line"></div><div class="line">return val === newVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome1(121) // true</div><div class="line">isPalindrome1(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>// PS：方法简单，但效率不高，会产生一个新的变量</p><h2 id="方法二（循环）"><a href="#方法二（循环）" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome2(val)&#123;</div><div class="line">val = val + &apos;&apos;; // 非字符串转化为字符串</div><div class="line"></div><div class="line">// 这里为什么 i &lt;= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！</div><div class="line">for(let i = 0, j = val.length - 1; i &lt; j; i++, j--)&#123;</div><div class="line">if(val.charAt(i) !== val.charAt(j))&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome2(121) // true</div><div class="line">isPalindrome2(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>PS：网上还有其他解法，大多为以上两种的变形。</p><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="方法一（字符串、数组内置方法））"><a href="#方法一（字符串、数组内置方法））" class="headerlink" title="方法一（字符串、数组内置方法））"></a>方法一（字符串、数组内置方法））</h2><p>借用反转字符串的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal1(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">return val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法二（循环）-1"><a href="#方法二（循环）-1" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><p>循环系列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal2(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">i = 0,</div><div class="line">len = val.length;</div><div class="line">while(i &lt; len)&#123;</div><div class="line">str += val.charAt(len - 1 - i);</div><div class="line">i++; </div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal3(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">len = val.length;</div><div class="line">for(let i = len - 1; i &gt;= 0; i--)&#123;</div><div class="line">str += val.charAt(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：reverseVal(‘abc’) // ‘cba’</p><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="方法一（递归）"><a href="#方法一（递归）" class="headerlink" title="方法一（递归）"></a>方法一（递归）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize1(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line"></div><div class="line">// 建议不要使用 arguments.callee，目前已经废弃了。</div><div class="line">return n * factorialize1(n - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</p><h2 id="方法二（ES6尾调用优化）"><a href="#方法二（ES6尾调用优化）" class="headerlink" title="方法二（ES6尾调用优化）"></a>方法二（ES6尾调用优化）</h2><p>（递归优化版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize2(n, total = 1)&#123;</div><div class="line">if(typeof n !== &apos;number&apos; || typeof total !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return total;</div><div class="line"></div><div class="line">return factorialize2(n - 1, n * total)</div><div class="line">// f(3) =&gt; f(2, 3 * 2) =&gt; f(1, 6) =&gt; 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="external">ES6尾调用优化</a>但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><h2 id="方法三（循环）"><a href="#方法三（循环）" class="headerlink" title="方法三（循环）"></a>方法三（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize3(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line">let total = 1;</div><div class="line"></div><div class="line">while(n&gt;1)&#123;</div><div class="line">total = n * total;</div><div class="line">n--;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：factorialize1(3) // 6</p><h1 id="随机生成长度为n字符串"><a href="#随机生成长度为n字符串" class="headerlink" title="随机生成长度为n字符串"></a>随机生成长度为n字符串</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString1(n)&#123;</div><div class="line">let str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;</div><div class="line">let tem = &apos;&apos;,</div><div class="line">i = 0;</div><div class="line"></div><div class="line">// Math.random 函数产生值的范围[0,1)</div><div class="line">while(i&lt;n)&#123;</div><div class="line">tem += str.charAt(Math.floor(Math.random() * str.length))</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：Math.round(Math.random() <em> (str.length - 1))<br>Math.ceil(Math.random() </em> (str.length - 1))<br>Math.floor(Math.random() * str.length)<br>这三种方式等价，都能生成[0, str.length-1]随机数</p><h2 id="方法二（进制转化）"><a href="#方法二（进制转化）" class="headerlink" title="方法二（进制转化）"></a>方法二（进制转化）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString2(n)&#123;</div><div class="line">return Math.random().toString(36).substr(2).slice(0, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法原理为随机产生的数转换为指定进制字符串<br>toString(n)，n为[2,36]，n&lt;=10时只产生0-9也就是10进制数字<br>该方法有个缺点，产生字符串的长度有一定的限制。</p><h2 id="方法三（随机码点）"><a href="#方法三（随机码点）" class="headerlink" title="方法三（随机码点）"></a>方法三（随机码点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString3(n)&#123;</div><div class="line">let str = &apos;&apos;;</div><div class="line"></div><div class="line">function randomChar()&#123;</div><div class="line">let l = Math.floor(Math.random() * 62);</div><div class="line">if(l &lt; 10) return l; // 数字部分 0-9</div><div class="line">if(l &lt; 36) return String.fromCharCode(l + 55); // 大写字母</div><div class="line"></div><div class="line">return String.fromCharCode(l + 61); // 小写字母</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(str.length &lt; n) str += randomChar();</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以参考对于的<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="external">ASCII码表</a>。<br>测试：randomString1(3) // ‘1sd’</p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="方法一（ES6的Set数据结构）"><a href="#方法一（ES6的Set数据结构）" class="headerlink" title="方法一（ES6的Set数据结构）"></a>方法一（ES6的Set数据结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique1(ary)&#123;</div><div class="line">return [...new Set(ary)];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法二（对象的key唯一性）"><a href="#方法二（对象的key唯一性）" class="headerlink" title="方法二（对象的key唯一性）"></a>方法二（对象的key唯一性）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique2(ary)&#123;</div><div class="line">let obj = &#123;&#125;,</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(!obj[ary[i]])&#123;</div><div class="line">obj[ary[i]] = true; // 如果不存在</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">return Object.keys(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串。<br>会把数字1和字符串’1’，会被视为同一个值。</p><h2 id="方法三（临时数组判断插入）"><a href="#方法三（临时数组判断插入）" class="headerlink" title="方法三（临时数组判断插入）"></a>方法三（临时数组判断插入）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique3(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">// tem.indexOf() === -1 同理</div><div class="line">!tem.includes(ary[i]) ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法四（判断首次出现的位置）"><a href="#方法四（判断首次出现的位置）" class="headerlink" title="方法四（判断首次出现的位置）"></a>方法四（判断首次出现的位置）</h2><p>如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique4(ary)&#123;</div><div class="line">let tem = [ary[0]],</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">for(let i = 1; i &lt; len; i++ )&#123;</div><div class="line">// 核心，首次的索引出现是否为当前的索引</div><div class="line">if(ary.indexOf(ary[i]) === i) tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法五（排序后逐个比较插入）"><a href="#方法五（排序后逐个比较插入）" class="headerlink" title="方法五（排序后逐个比较插入）"></a>方法五（排序后逐个比较插入）</h2><p>给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; array 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique5(array)&#123;</div><div class="line">let ary = array.slice();</div><div class="line">ary.sort();</div><div class="line">let tem = [ary[0]];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">ary[i] !== tem[tem.length - 1] ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：返回的数组顺序发生了改变。</p><h2 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h2><p>获取没有重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique6(ary)&#123;</div><div class="line">let tem = [];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">for(let j = i + 1; j &lt; len; j++)&#123;</div><div class="line">if(ary[i] === ary[j]) j = ++i;</div><div class="line">&#125;</div><div class="line">tem.push(ary[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：unique1([1, 2, 3, 2]) // [1, 2, 3]</p><h1 id="出现次数最多的字符"><a href="#出现次数最多的字符" class="headerlink" title="出现次数最多的字符"></a>出现次数最多的字符</h1><h2 id="方法一（对象key的唯一性进行累加）"><a href="#方法一（对象key的唯一性进行累加）" class="headerlink" title="方法一（对象key的唯一性进行累加）"></a>方法一（对象key的唯一性进行累加）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function maxNum1(str)&#123;</div><div class="line">if(typeof(str) !== &apos;string&apos;) str = str.toString();</div><div class="line">let obj = &#123;&#125;,</div><div class="line">maxChar = []; // 使用数组保存出现最多次的某些字符</div><div class="line">str.split(&apos;&apos;).forEach( (val) =&gt; &#123;</div><div class="line">if(!obj[val])&#123;</div><div class="line">let demo = obj[val] = 1;</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line">obj[val]++;</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">let maxCount =  Math.max.apply(null, Object.values(obj))</div><div class="line"></div><div class="line">// forEach方法总是返回 undefined 且 没有办法中止或者跳出 forEach 循环。</div><div class="line">Object.entries(obj).forEach( item =&gt; &#123;</div><div class="line">if(item[1] == maxCount)&#123;</div><div class="line">maxChar.push(item[0])</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return maxChar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：maxNum1(‘11223333’) // ‘3’</p><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>实现方法：Array.prototype.flatten(depth)，参数depth表示需要扁平化的层数，返回一个新的数组。 </p><h2 id="方法一（递归遍历数组拼接）"><a href="#方法一（递归遍历数组拼接）" class="headerlink" title="方法一（递归遍历数组拼接）"></a>方法一（递归遍历数组拼接）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function flatten1(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(Array.isArray(ary[i]))&#123;</div><div class="line">// 递归进行上面步骤</div><div class="line">// [].concat(...ary)，它的参数可以为数组或值，作用为将数组或值连接成新数组。</div><div class="line">tem = tem.concat(flatten1(ary[i]))</div><div class="line">&#125;else&#123;</div><div class="line">tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法二（reduce结合concat）"><a href="#方法二（reduce结合concat）" class="headerlink" title="方法二（reduce结合concat）"></a>方法二（reduce结合concat）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.reduce((pre, cur) =&gt; &#123;</div><div class="line">return pre.concat(Array.isArray(cur) ? flatten2(cur) : cur)</div><div class="line">&#125;, [])</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法三（转化为字符串）"><a href="#方法三（转化为字符串）" class="headerlink" title="方法三（转化为字符串）"></a>方法三（转化为字符串）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.toString().split(&apos;,&apos;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：返回的数组项将为字符串。</p><h2 id="方法四（解构数组）"><a href="#方法四（解构数组）" class="headerlink" title="方法四（解构数组）"></a>方法四（解构数组）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function flatten4(ary)&#123;</div><div class="line"></div><div class="line">let tem = []</div><div class="line">ary.forEach(item =&gt; &#123;</div><div class="line">if(Array.isArray(item))&#123;</div><div class="line">tem = tem.concat(...item);</div><div class="line">&#125;else&#123;</div><div class="line">tem = tem.concat(item);</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：只能处理2维数组。<br>测试：getMaxProfit1([1, 2, 3, [4, 5, 6]]) // [1, 2, 3, 4, 5, 6]</p><h1 id="数组中最大差值"><a href="#数组中最大差值" class="headerlink" title="数组中最大差值"></a>数组中最大差值</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getMaxProfit1(ary)&#123;</div><div class="line">return Math.max.apply(null, ary) - Math.min.apply(null, ary);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：getMaxProfit1([1, 2, 3, 4]) // 3 </p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>这里我们只实现通项公式</p><h2 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fib1(n)&#123;</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return fib1(n - 1) + fib1(n - 2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(2^n)，空间复杂度为O(n)</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let tem = [1, 1];</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 数组索引从0开始，数列索引从1开始</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">tem[i] = tem[i-1] + tem[i-2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem[n-1];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(n)</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let prev = 1, </div><div class="line">next = 1,</div><div class="line">res;</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">res = prev + next;  </div><div class="line">prev = next; </div><div class="line">next = res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(1)<br>测试：fib2(3) // 2 </p><h1 id="判断是否为质数（prime-number）素数"><a href="#判断是否为质数（prime-number）素数" class="headerlink" title="判断是否为质数（prime number）素数"></a>判断是否为质数（prime number）素数</h1><p>质数：只能被1和自己整除且大于1的数。<br>合数：数大于1且因数多余2个（大于1的数质数的补集）。</p><h2 id="方法一（循环）"><a href="#方法一（循环）" class="headerlink" title="方法一（循环）"></a>方法一（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">if(n &lt; 2) return false;</div><div class="line">if(n === 2) return true; // 最小的质数</div><div class="line"></div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">if(n % i === 0)&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：isPrimeNumber1(2) // true</p><h2 id="方法二（正则）"><a href="#方法二（正则）" class="headerlink" title="方法二（正则）"></a>方法二（正则）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">  return n&lt;2?false:!/^(11+?)\1+$/.test(Array(n+1).join(&apos;1&apos;))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法很巧妙，于2018-04-25在掘金上发现。<br><a href="https://juejin.im/post/5adeb462f265da0b9c104358" target="_blank" rel="external">方法详解</a></p><h1 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function greatestCommonDivisor1(a, b)&#123;</div><div class="line">if(a &lt; 0 || b &lt; 0) throw new Error(&apos;参数只能为正整数&apos;);</div><div class="line">if(a &lt; 2 || b &lt; 2) return 1;</div><div class="line">let min = a,</div><div class="line">max = b,</div><div class="line">arymin = [];</div><div class="line"></div><div class="line">if(a &gt; b) &#123;</div><div class="line">min = b;</div><div class="line">max = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(let i = 1; i &lt;= min; i++)&#123;</div><div class="line">if(min % i === 0)&#123;</div><div class="line">arymin.push(i);</div><div class="line">console.log(1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">arymin.reverse();</div><div class="line"></div><div class="line">for(let j = 0, len = arymin.length; j &lt; len; j++)&#123;</div><div class="line">if(max % arymin[j] === 0)&#123;</div><div class="line">return arymin[j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：greatestCommonDivisor1(5, 10) // 5</p><h1 id="金额转大写"><a href="#金额转大写" class="headerlink" title="金额转大写"></a>金额转大写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function money2Chinese(num) &#123;</div><div class="line">  if(typeof num) throw new Error(&apos;参数为数字&apos;)</div><div class="line">  let strOutput = &quot;&quot;</div><div class="line">  let strUnit = &apos;仟佰拾亿仟佰拾万仟佰拾元角分&apos;</div><div class="line">  num += &quot;00&quot;</div><div class="line">  const intPos = num.indexOf(&apos;.&apos;)</div><div class="line">  if (intPos &gt;= 0) &#123;</div><div class="line">    num = num.substring(0, intPos) + num.substr(intPos + 1, 2)</div><div class="line">  &#125;</div><div class="line">  strUnit = strUnit.substr(strUnit.length - num.length)</div><div class="line">  for (let i = 0; i &lt; num.length; i++) &#123;</div><div class="line">    strOutput += &apos;零壹贰叁肆伍陆柒捌玖&apos;.substr(num.substr(i, 1), 1) + strUnit.substr(i, 1)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  return strOutput.replace(/零角零分$/, &apos;整&apos;).replace(/零[仟佰拾]/g, &apos;零&apos;).replace(/零&#123;2,&#125;/g, &apos;零&apos;).replace(/零([亿|万])/g, &apos;$1&apos;).replace(/零+元/, &apos;元&apos;).replace(/亿零&#123;0,3&#125;万/, &apos;亿&apos;).replace(/^元/, &quot;零元&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：money2Chinese(1234) // 壹仟贰佰叁拾肆元整</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断文本是否为回文&quot;&gt;&lt;a href=&quot;#判断文本是否为回文&quot; class=&quot;headerlink&quot; title=&quot;判断文本是否为回文&quot;&gt;&lt;/a&gt;判断文本是否为回文&lt;/h1&gt;&lt;p&gt;定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我所了解的CSS包含块</title>
    <link href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://fanerge.github.io/2018/一次详细的包含块学习.html</id>
    <published>2018-03-29T11:53:04.000Z</published>
    <updated>2018-05-16T12:39:01.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指出错误观念"><a href="#指出错误观念" class="headerlink" title="指出错误观念"></a>指出错误观念</h1><p>许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！<br>一个元素的尺寸和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。<br>下面我们看看盒模型：<br>当浏览器展示一个文档的时候，对于每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域：</p><ol><li>内容区</li><li>内边距区</li><li>边框区</li><li>外边距区<br><img src="http://p677fntmi.bkt.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></li></ol><h1 id="什么是包含块？"><a href="#什么是包含块？" class="headerlink" title="什么是包含块？"></a>什么是包含块？</h1><p>包含块有分为根元素包含块和其他元素的包含块。</p><h2 id="根元素包含块"><a href="#根元素包含块" class="headerlink" title="根元素包含块"></a>根元素包含块</h2><p>根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。<br>可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。<br>对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。</p><h2 id="其他元素的包含块"><a href="#其他元素的包含块" class="headerlink" title="其他元素的包含块"></a>其他元素的包含块</h2><p>大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样，下面就来学习如何确定这些元素的包含块。</p><h1 id="如何确定元素的包含块？"><a href="#如何确定元素的包含块？" class="headerlink" title="如何确定元素的包含块？"></a>如何确定元素的包含块？</h1><p>确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景：</p><ol><li>如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）或格式化上下文<a href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#BFC">BFC</a>(比如说 a table container, flex container, grid container, or the block container itself)的<span style="color: red">内容区的边缘</span>组成的。</li><li>如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的<span style="color: red">内边距区的边缘</span>组成的。</li><li>如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in  the case of paged media) 组成的。</li><li>如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的<span style="color: red">内边距区的边缘</span>组成的：<br>A transform or perspective value other than none<br>A will-change value of transform or perspective<br>A filter value other than none or a will-change value of filter (only works on Firefox).</li></ol><h1 id="元素包含块的作用？"><a href="#元素包含块的作用？" class="headerlink" title="元素包含块的作用？"></a>元素包含块的作用？</h1><p>元素的尺寸和位置经常受其包含块的影响。对于一个绝对定位的元素来说（他的 position 属性被设定为 absolute 或 fixed），如果它的 width, height, padding, margin, 和 offset 这些属性的值是一个比例值（如百分比等）的话，那这些值的计算值就是由它的包含块计算而来的。<br>简单来说，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</p><ol><li>height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。</li><li>width, left, right, padding, margin这些属性由包含块的 width 属性的值来计算它的百分值。</li></ol><h1 id="下面看些例子"><a href="#下面看些例子" class="headerlink" title="下面看些例子"></a>下面看些例子</h1><p>下面示例公用HTML代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;section&gt;</div><div class="line">    &lt;p&gt;This is a paragraph!&lt;/p&gt;</div><div class="line">  &lt;/section&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: block;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;   /* == 400px * .5 = 200px */</div><div class="line">  height: 25%;  /* == 160px * .25 = 40px */</div><div class="line">  margin: 5%;   /* == 400px * .05 = 20px */</div><div class="line">  padding: 5%;  /* == 400px * .05 = 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk1.png" alt=""></p><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: inline;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;     /* == half the body&apos;s width */</div><div class="line">  height: 200px;  /* Note: a percentage would be 0 */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk2.png" alt=""></p><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  transform: rotate(0deg);</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 80px;</div><div class="line">  top: 30px;</div><div class="line">  width: 50%;   /* == 200px */</div><div class="line">  height: 25%;  /* == 40px */</div><div class="line">  margin: 5%;   /* == 20px */</div><div class="line">  padding: 5%;  /* == 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk3.png" alt=""></p><h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 30px;</div><div class="line">  top: 30px;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  padding: 30px 20px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  width: 50%;   /* == (400px + 20px + 20px) * .5 = 220px */</div><div class="line">  height: 25%;  /* == (160px + 30px + 30px) * .25 = 55px */</div><div class="line">  margin: 5%;   /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  padding: 5%;  /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk4.png" alt=""></p><h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  width: 300px;</div><div class="line">  height: 300px;</div><div class="line">  margin: 30px;</div><div class="line">  padding: 15px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: fixed;</div><div class="line">  width: 50%;   /* == (50vw - (width of vertical scrollbar)) */</div><div class="line">  height: 50%;  /* == (50vh - (height of horizontal scrollbar)) */</div><div class="line">  margin: 5%;   /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  padding: 5%;  /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk5.png" alt=""></p><p>如果本文对你有帮助，记得给我的博客项目<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="external">star</a>(⊙﹏⊙)，<a href="https://fanerge.github.io">顺便找找成都氛围好的前端团队，也许我就是你们要找的の</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指出错误观念&quot;&gt;&lt;a href=&quot;#指出错误观念&quot; class=&quot;headerlink&quot; title=&quot;指出错误观念&quot;&gt;&lt;/a&gt;指出错误观念&lt;/h1&gt;&lt;p&gt;许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！&lt;br&gt;一个元素的尺
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>全面了解Object对象</title>
    <link href="https://fanerge.github.io/2018/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Object%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://fanerge.github.io/2018/全面了解Object对象.html</id>
    <published>2018-03-20T12:36:46.000Z</published>
    <updated>2018-03-21T12:13:35.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么一切皆为对象"><a href="#为什么一切皆为对象" class="headerlink" title="为什么一切皆为对象"></a>为什么一切皆为对象</h1><p>‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一探究竟吧？<br>为了解决这个问题，我们的从javascript的原型链说起。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在js几乎任何对象有一个 [[prototype]] 属性，在标准中，这是一个隐藏属性。<br>虽然说 [[prototype]] 是一个隐藏属性，但很多浏览器都给每一个对象提供 __proto__ 这一属性，这个属性就是该对象的[[prototype]]。</p><blockquote><p>   Object.prototype 的 __proto__  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部 [[Prototype]] (一个对象或 null)。<br>使用 __proto__ 是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__ 属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 赞成Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf 来获取或设置对象的原型链。</p></blockquote><p>下面我们用标准的方法来获取对象的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 基本数据类型（Number,String,Boolean,Symbol）</div><div class="line">let str = &apos;strstr&apos;;</div><div class="line">// 1</div><div class="line">Object.getPrototypeOf(str) // String对象（这里包括字符串原型链上的所有方法如slice、indexOf等）</div><div class="line">// 2</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(str)) // Object对象</div><div class="line">// 3</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(str))) // null</div><div class="line">console.dir(Object.getPrototypeOf(str))</div><div class="line"></div><div class="line">// 其他类型（Object,Function,Array,Error,Math,Date,Map,Set,WeakMap,WeakSet,JSON）</div><div class="line">function demo() &#123;&#125;</div><div class="line">// 4</div><div class="line">Object.getPrototypeOf(demo) // anonymous函数</div><div class="line">// 5</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(demo)) // Object对象</div><div class="line">// 6</div><div class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(demo))) // null</div></pre></td></tr></table></figure></p><p>PS：博主分别以基本数据类型Number,String,Boolean,Symbol（这里不考虑undefined和null，因为它们是特殊的两个值，木有原型）做了测试，上面代码注释1,2,3最终到达原型链的顶端null。<br>对于其他类型也是同样的，通过4,5,6到达原型链顶端Object.prototype === null。<br>从上面可以整个javascript语法系统都是基于这个原型链来实现方法和属性的继承的，并且可以看到原型链是有终点的值为 null。</p><p>搞清楚了原型链，在回到‘一切皆为对象’。<br>明白了javascript的原型链，明白了所有的继承终点都到了Object上，就不难理解‘一切皆为对象’了吧。</p><h1 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 27,</div><div class="line">city: &apos;chengdu&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是大家最熟悉的创建方式。</p><h2 id="Object实例化"><a href="#Object实例化" class="headerlink" title="Object实例化"></a>Object实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let obj = new Object(&#123;</div><div class="line">// name: &apos;yzf&apos;,</div><div class="line">// age: 27,</div><div class="line">// city: &apos;chengdu&apos;</div><div class="line">&#125;);</div><div class="line">obj.name = &apos;yzf&apos;;</div><div class="line">obj.age = 27;</div><div class="line">obj.city = &apos;chengdu&apos;;</div></pre></td></tr></table></figure><p>这里两种方式，为obj赋值，一种在实例化是进行，一种在实例化之后添加。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, city)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.city = city;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let fanerge = new Person(&apos;yzf&apos;, 27, &apos;chengdu&apos;)</div></pre></td></tr></table></figure><h1 id="Object对象的方法"><a href="#Object对象的方法" class="headerlink" title="Object对象的方法"></a>Object对象的方法</h1><p>Object对象的方法分为Object静态方法和Object的实例方法，静态方法定义在Object自身上，而实例方法定义在Object.prototype上；<br>在使用方式上也有区别，静态方法使用’如Object.keys(obj)’而实例方法使用’如obj.hasOwnProperty(prop)’。<br>我认为我们学习API是需要重点了解一个API的使用方式、定义、参数说明、返回值，下面我给出Object标准库中的方法，其中有部分是ES6+的方法，存在一定的兼容性问题。</p><h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><h3 id="Object-assign-target-…sources"><a href="#Object-assign-target-…sources" class="headerlink" title="Object.assign(target, …sources)"></a>Object.assign(target, …sources)</h3><p>定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>参数：target为目标对象，sources为源对象。<br>返回：目标对象。</p><h3 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [propertiesObject])"></a>Object.create(proto, [propertiesObject])</h3><p>定义：创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>参数：proto为新创建对象的原型对象，propertiesObject为相关属性的描述符。<br>返回：新对象。</p><h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>定义：会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>参数：obj为要在其上定义属性的对象，prop为要定义或修改的属性的名称，descriptor为将被定义或修改的属性描述符。<br>返回：obj。</p><h3 id="Object-defineProperties-obj-props"><a href="#Object-defineProperties-obj-props" class="headerlink" title="Object.defineProperties(obj, props)"></a>Object.defineProperties(obj, props)</h3><p>定义：直接在一个对象上定义新的属性或修改现有属性，并返回该对象。<br>参数：obj为要在其上定义属性的对象，props为要定义或修改的一个或多个属性的描述符。<br>返回：obj。</p><h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><p>定义：返回一个由一个给定对象的自身可枚举属性组成的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个表示给定对象的所有可枚举属性的字符串数组。</p><h3 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个包含对象自身的所有可枚举属性值的数组。</p><h3 id="Object-values-obj-1"><a href="#Object-values-obj-1" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：给定对象自身可枚举属性的键值（键值对也为数组）对数组。</p><h3 id="Object-preventExtensions-obj"><a href="#Object-preventExtensions-obj" class="headerlink" title="Object.preventExtensions(obj)"></a>Object.preventExtensions(obj)</h3><p>定义：让一个对象变的不可扩展，也就是永远不能再添加新的属性。<br>参数：obj为将要变得不可扩展的对象。<br>返回：已经不可扩展的对象。<br>PS：该对象的属性可能仍然可删除，且对象的原型仍然可以添加属性。</p><h3 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h3><p>定义：判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否可扩展的一个Boolean 。</p><h3 id="Object-seal-obj"><a href="#Object-seal-obj" class="headerlink" title="Object.seal(obj)"></a>Object.seal(obj)</h3><p>定义：封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。<br>参数：obj为将要被密封的对象。<br>返回：被密封的对象。<br>PS：属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性（get）。</p><h3 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h3><p>定义：判断一个对象是否被密封。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被密封的一个Boolean。</p><h3 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h3><p>定义：可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。<br>参数：obj为要被冻结的对象。<br>返回：要被冻结的对象。</p><h3 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h3><p>定义：判断一个对象是否被冻结。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被冻结的Boolean。</p><h3 id="Object-getOwnPropertyDescriptor-obj-prop"><a href="#Object-getOwnPropertyDescriptor-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptor(obj, prop)"></a>Object.getOwnPropertyDescriptor(obj, prop)</h3><p>定义：返回指定对象上一个自有属性对应的属性描述符。<br>参数：obj为需要查找的目标对象，prop为目标对象内属性名称（String类型）。<br>返回：如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</p><h3 id="Object-getOwnPropertyDescriptors-obj"><a href="#Object-getOwnPropertyDescriptors-obj" class="headerlink" title="Object.getOwnPropertyDescriptors(obj)"></a>Object.getOwnPropertyDescriptors(obj)</h3><p>定义：用来获取一个对象的所有自身属性的描述符。<br>参数：obj为需要查找的目标对象。<br>返回：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p><h3 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>返回：在给定对象上找到的属性对应的字符串数组。</p><h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为要返回 Symbol 属性的对象。<br>返回：在给定对象自身上找到的所有 Symbol 属性的数组。</p><h3 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h3><p>定义：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或null。<br>参数：obj为要设置其原型的对象，prototype为该对象的新原型(一个对象 或 null)。<br>返回：返回obj对象。</p><h3 id="Object-getPrototypeOf-object"><a href="#Object-getPrototypeOf-object" class="headerlink" title="Object.getPrototypeOf(object)"></a>Object.getPrototypeOf(object)</h3><p>定义：返回指定对象的原型（内部[[Prototype]]属性的值）。<br>参数：要返回其原型的对象。<br>返回：给定对象的原型。如果没有继承属性，则返回null。</p><h3 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2);"></a>Object.is(value1, value2);</h3><p>定义：判断两个值是否是相同的值。<br>参数：value1为需要比较的第一个值，value2为需要比较的第二个值。<br>返回：表示两个参数是否相同的Boolean 。</p><h2 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>下面obj为Object的实例。</p><h3 id="obj-hasOwnProperty-prop"><a href="#obj-hasOwnProperty-prop" class="headerlink" title="obj.hasOwnProperty(prop)"></a>obj.hasOwnProperty(prop)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：prop为要检测的属性String或者Symbol。<br>返回：用来判断某个对象是否含有指定的属性的Boolean。</p><h3 id="prototypeObj-isPrototypeOf-obj"><a href="#prototypeObj-isPrototypeOf-obj" class="headerlink" title="prototypeObj.isPrototypeOf(obj)"></a>prototypeObj.isPrototypeOf(obj)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：obj为在该对象的原型链上搜寻。<br>返回：表示调用对象是否在另一个对象的原型链上的Boolean。</p><h3 id="obj-propertyIsEnumerable-prop"><a href="#obj-propertyIsEnumerable-prop" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个布尔值，表示指定的属性是否可枚举。<br>参数：prop为需要测试的属性名。<br>返回：用来表示指定的属性名是否可枚举的Boolean。</p><h3 id="obj-toLocaleString"><a href="#obj-toLocaleString" class="headerlink" title="obj.toLocaleString()"></a>obj.toLocaleString()</h3><p>定义：方法返回一个该对象的字符串表示。<br>返回：表示对象的字符串。</p><h3 id="obj-propertyIsEnumerable-prop-1"><a href="#obj-propertyIsEnumerable-prop-1" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个表示该对象的字符串。<br>返回：表示该对象的字符串。<br>PS：ES6之前经常这样用Object.prototype.toString.call(obj) === ‘[object Object]’ 来区别Object和Array。</p><h3 id="ob-valueOf"><a href="#ob-valueOf" class="headerlink" title="ob.valueOf()"></a>ob.valueOf()</h3><p>定义：返回指定对象的原始值。<br>返回：返回值为该对象的原始值。</p><h3 id="object-instanceof-constructor"><a href="#object-instanceof-constructor" class="headerlink" title="object instanceof constructor"></a>object instanceof constructor</h3><p>定义：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>参数：object为要检测的对象，constructor为某个构造函数。<br>返回：boolean值。[2018-03-21]</p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="external">MDN__proto__</a><br><a href="https://www.zhihu.com/question/34183746/answer/58068402" target="_blank" rel="external">__proto__和prototype的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Object</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么一切皆为对象&quot;&gt;&lt;a href=&quot;#为什么一切皆为对象&quot; class=&quot;headerlink&quot; title=&quot;为什么一切皆为对象&quot;&gt;&lt;/a&gt;为什么一切皆为对象&lt;/h1&gt;&lt;p&gt;‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript标准库总结</title>
    <link href="https://fanerge.github.io/2018/javascript%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/2018/javascript标准库总结.html</id>
    <published>2018-03-19T13:56:38.000Z</published>
    <updated>2018-04-04T12:47:12.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="值属性"><a href="#值属性" class="headerlink" title="值属性"></a>值属性</h1><p>这部分属性只是简单的值，它们没有自己的属性和方法。</p><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><pre><code>全局属性 Infinity 是一个数值，表示无穷大。</code></pre><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><pre><code>全局属性 NaN 的值表示不是一个数字（Not-A-Number）。</code></pre><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><pre><code>全局属性undefined表示原始值undefined。它是一个JavaScript的 原始数据类型 。</code></pre><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><pre><code>值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。</code></pre><h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。    </p><h3 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h3><pre><code>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。</code></pre><p>PS：eval会造成安全和性能方面的问题，具体参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval#Don.27t_use_eval.21" target="_blank" rel="external">避免在不必要的情况下使用 eval</a>。</p><h3 id="isFinite-arg"><a href="#isFinite-arg" class="headerlink" title="isFinite(arg)"></a>isFinite(arg)</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为有限值。</code></pre><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为NaN。</code></pre><p>PS：使用Number.isNaN()来代替更有语义性。</p><h3 id="parseFloat-str"><a href="#parseFloat-str" class="headerlink" title="parseFloat(str)"></a>parseFloat(str)</h3><pre><code>parseFloat() 函数解析一个字符串参数并返回一个浮点数。</code></pre><p>PS：如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略.<br>    如果第一个字符不能解析，直接返回NaN。</p><h3 id="parseInt-str-radix"><a href="#parseInt-str-radix" class="headerlink" title="parseInt(str, radix);"></a>parseInt(str, radix);</h3><pre><code>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</code></pre><p>PS：radix一个介于2和36之间的整数，表示上述字符串的基数（默认为10）。</p><h3 id="encodeURI-URI"><a href="#encodeURI-URI" class="headerlink" title="encodeURI(URI)"></a>encodeURI(URI)</h3><p>函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。<br>PS：encodeURI 字母、数字、;、,、/、?、:、@、&amp;、=、+、$、-、_、.、!、~、*、’、(、)、#、之外的所有字符。</p><h3 id="decodeURI-encodeURI"><a href="#decodeURI-encodeURI" class="headerlink" title="decodeURI(encodeURI)"></a>decodeURI(encodeURI)</h3><pre><code>decodeURI() 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。</code></pre><h3 id="encodeURIComponent-str"><a href="#encodeURIComponent-str" class="headerlink" title="encodeURIComponent(str)"></a>encodeURIComponent(str)</h3><pre><code>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。</code></pre><p>PS：encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。<br>    为了避免服务器收到不可预知的请求，对任何用户输入的作为URI部分的内容你都需要用encodeURIComponent进行转义。</p><h3 id="decodeURIComponent-encodedURI"><a href="#decodeURIComponent-encodedURI" class="headerlink" title="decodeURIComponent(encodedURI)"></a>decodeURIComponent(encodedURI)</h3><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><h3 id="encodeURI和encodeURIComponent的区别与使用场景"><a href="#encodeURI和encodeURIComponent的区别与使用场景" class="headerlink" title="encodeURI和encodeURIComponent的区别与使用场景"></a>encodeURI和encodeURIComponent的区别与使用场景</h3><pre><code>区别在于编码的字符范围不同。</code></pre><p>encodeURI使用于编码整个URI而encodeURIComponent主要query部分（当你需要编码URL中的参数）。<br><a href="https://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="external">简单明了区分escape、encodeURI和encodeURIComponent</a></p><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。</p><h2 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>定义：指明函数的形参个数（确定多少个必须要传入的参数）区别于arguments.length实参个数（确定函数被调用时的实际传参个数）。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>定义：返回创建实例对象的 Object 构造函数的引用。</p><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="func-apply-thisArg-argsArray"><a href="#func-apply-thisArg-argsArray" class="headerlink" title="func.apply(thisArg, [argsArray])"></a>func.apply(thisArg, [argsArray])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为func函数执行时this的指向，argsArray为类数组参数数组。<br>返回：调用有指定this值和参数的函数的结果。</p><h3 id="fun-call-thisArg-arg1-arg2-…"><a href="#fun-call-thisArg-arg1-arg2-…" class="headerlink" title="fun.call(thisArg, arg1, arg2, …)"></a>fun.call(thisArg, arg1, arg2, …)</h3><p>定义：调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。<br>参数：thisArg为func函数执行时this的指向，arg1, arg2, …为指定的参数列表。<br>返回：返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。<br>运用：1.使用call方法调用父构造函数（在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承）<br>  2.使用call方法调用匿名函数3.使用call方法调用函数并且指定上下文的’this’<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#示例" target="_blank" rel="external">运用举例</a></p><h3 id="fun-bind-thisArg-arg1-arg2-…"><a href="#fun-bind-thisArg-arg1-arg2-…" class="headerlink" title="fun.bind(thisArg[, arg1[, arg2[, …]]])"></a>fun.bind(thisArg[, arg1[, arg2[, …]]])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为当绑定函数被调用时，该参数会作为原函数运行时的 this 指向，arg1、arg2…为当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。<br>返回：由指定的this值和初始化参数改造的原函数拷贝（返回一个函数）。<br>运用：1.创建绑定函数（显式绑定this）2.偏函数（使一个函数拥有预设的初始参数）。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#示例" target="_blank" rel="external">运用举例</a></p><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>定义：返回一个表示当前函数源代码的字符串。<br>参数：null。<br>返回：表示函数源代码的一个字符串。</p><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。<br>Number()，如果参数无法被转换为数字，则返回 NaN。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>两个可表示(representable)数之间的最小间隔，在进行计算时误差在这个范围内被认为是合理的。</p><h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>JavaScript 中最大的安全整数 (2^53 - 1)。</p><h3 id="Number-MIN-SAFE-INTEGER"><a href="#Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MIN_SAFE_INTEGER"></a>Number.MIN_SAFE_INTEGER</h3><p>JavaScript 中最小的安全整数 (-(2^53 - 1)).</p><h3 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h3><p>能表示的最大正数。最小的负数是 -MAX_VALUE。</p><h3 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h3><p>能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。</p><h3 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h3><p>Not A Number.</p><h3 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h3><p>特殊的负无穷大值，在溢出时返回该值。</p><h3 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h3><p>特殊的正无穷大值，在溢出时返回改值。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>下列方法均不会发生将String转化为Number的过程。</p><h3 id="Number-isNaN-value"><a href="#Number-isNaN-value" class="headerlink" title="Number.isNaN(value)"></a>Number.isNaN(value)</h3><p>定义：确定传递的值是否为 NaN和其类型是 Number。它是用于代替原始的全局isNaN()。<br>参数：要被检测是否是 NaN 的值。<br>返回：一个布尔值，表示给定的值是否是 NaN。<br>PS：该方法不同于全局的isNaN()，不会将字符串转换为数字。</p><h3 id="Number-isFinite-value"><a href="#Number-isFinite-value" class="headerlink" title="Number.isFinite(value)"></a>Number.isFinite(value)</h3><p>定义：用来检测传入的参数是否是一个有穷数（finite number）。<br>参数：value要被检测有穷性的值。<br>返回：一个布尔值表示给定的值是否是一个有穷数。<br>PS：和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值。</p><h3 id="Number-isInteger-value"><a href="#Number-isInteger-value" class="headerlink" title="Number.isInteger(value)"></a>Number.isInteger(value)</h3><p>定义：用来判断给定的参数是否为整数。<br>参数：value要判断此参数是否为整数。<br>返回：判断给定值是否是整数的 Boolean 值。</p><h3 id="Number-isSafeInteger-testValue"><a href="#Number-isSafeInteger-testValue" class="headerlink" title="Number.isSafeInteger(testValue)"></a>Number.isSafeInteger(testValue)</h3><p>定义：用来判断传入的参数值是否是一个“安全整数”（safe integer）。<br>参数：testValue需要检测的参数。<br>返回：一个布尔值 表示给定的值是否是一个安全整数（safe integer）。</p><h3 id="Number-parseFloat-string"><a href="#Number-parseFloat-string" class="headerlink" title="Number.parseFloat(string)"></a>Number.parseFloat(string)</h3><p>定义：可以把一个字符串解析成浮点数。<br>参数：string被解析的字符串。<br>返回：对应的浮点数。<br>PS：与全局函数 parseFloat()一样。</p><h3 id="Number-parseInt-string-radix"><a href="#Number-parseInt-string-radix" class="headerlink" title="Number.parseInt(string[, radix])"></a>Number.parseInt(string[, radix])</h3><p>定义：可以根据给定的进制数的一个字符串数解析成整数。<br>参数：string要解析的值，radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>下列方法均返回为字符串。</p><h3 id="numObj-toExponential-fractionDigits"><a href="#numObj-toExponential-fractionDigits" class="headerlink" title="numObj.toExponential([fractionDigits])"></a>numObj.toExponential([fractionDigits])</h3><p>定义：以指数表示法返回该数值字符串表示形式。<br>参数：fractionDigits一个整数，用来指定小数点后有几位数字。<br>返回：一个用幂的形式 (科学记数法) 来表示Number 对象的字符串。</p><h3 id="numObj-toFixed-digits"><a href="#numObj-toFixed-digits" class="headerlink" title="numObj.toFixed(digits)"></a>numObj.toFixed(digits)</h3><p>定义：使用定点表示法来格式化一个数。<br>参数：digits小数点后数字的个数。<br>返回：所给数值的定点数表示法的字符串形式。</p><h3 id="numObj-toPrecision-precision"><a href="#numObj-toPrecision-precision" class="headerlink" title="numObj.toPrecision(precision)"></a>numObj.toPrecision(precision)</h3><p>定义：以指定的精度返回该数值对象的字符串表示。<br>参数：precision一个用来指定有效数个数的整数。<br>返回：以定点表示法或指数表示法表示的一个数值对象的字符串表示。</p><h3 id="numObj-toLocaleString-locales-options"><a href="#numObj-toLocaleString-locales-options" class="headerlink" title="numObj.toLocaleString([locales [, options]])"></a>numObj.toLocaleString([locales [, options]])</h3><p>定义：返回这个数字在特定语言环境下的表示字符串。<br>参数：locales为指定本地要使用的编号系统，options为有下列属性（localeMatcher、style、currency等等但存在一定的兼容性）<br>返回：返回一个语言环境下的表示字符串。<br>PS：通常用于格式化为某种货币形式。</p><h3 id="numObj-toString-radix"><a href="#numObj-toString-radix" class="headerlink" title="numObj.toString([radix])"></a>numObj.toString([radix])</h3><p>定义：返回指定 Number 对象的字符串表示形式。<br>参数：radix指定要用于数字到字符串的转换的基数(从2到36)。<br>返回：转换后的字符串。</p><h3 id="numObj-valueOf"><a href="#numObj-valueOf" class="headerlink" title="numObj.valueOf()"></a>numObj.valueOf()</h3><p>定义：返回一个被 Number 对象包装的原始值。<br>返回：表示指定 Number 对象的原始值的数字。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode-num1-…-numN"><a href="#String-fromCharCode-num1-…-numN" class="headerlink" title="String.fromCharCode(num1, …, numN)"></a>String.fromCharCode(num1, …, numN)</h3><p>定义：返回使用指定的Unicode值序列创建的字符串。</p><h3 id="String-fromCodePoint-num1-…-numN"><a href="#String-fromCodePoint-num1-…-numN" class="headerlink" title="String.fromCodePoint(num1[, …[, numN]])"></a>String.fromCodePoint(num1[, …[, numN]])</h3><p>定义：返回使用指定的代码点序列创建的字符串，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p><h3 id="String-raw-callSite-…substitutions-String-rawtemplateString"><a href="#String-raw-callSite-…substitutions-String-rawtemplateString" class="headerlink" title="String.raw(callSite, …substitutions) || String.rawtemplateString"></a>String.raw(callSite, …substitutions) || String.raw<code>templateString</code></h3><p>是用来获取一个模板字符串的原始字面量值的。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h3><p>返回：字符串的长度。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>返回：第N个字符串，但不能更改。</p><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="str-charAt-index"><a href="#str-charAt-index" class="headerlink" title="str.charAt(index)"></a>str.charAt(index)</h3><p>定义：从一个字符串中返回指定index的字符，缺省参数为0。</p><h3 id="str-charCodeAt-index"><a href="#str-charCodeAt-index" class="headerlink" title="str.charCodeAt(index)"></a>str.charCodeAt(index)</h3><p>定义：返回给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。</p><h3 id="str-codePointAt-index"><a href="#str-codePointAt-index" class="headerlink" title="str.codePointAt(index)"></a>str.codePointAt(index)</h3><p>定义：返回 一个 Unicode 编码点值的非负整数。</p><h3 id="str-concat-string2-string3-…-stringN"><a href="#str-concat-string2-string3-…-stringN" class="headerlink" title="str.concat(string2, string3[, …, stringN])"></a>str.concat(string2, string3[, …, stringN])</h3><p>定义：将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p><h3 id="str-includes-searchString-index"><a href="#str-includes-searchString-index" class="headerlink" title="str.includes(searchString[, index])"></a>str.includes(searchString[, index])</h3><p>定义：判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。</p><h3 id="str-startsWith-searchString-index"><a href="#str-startsWith-searchString-index" class="headerlink" title="str.startsWith(searchString [, index])"></a>str.startsWith(searchString [, index])</h3><p>定义：用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。</p><h3 id="str-endsWith-searchString-index"><a href="#str-endsWith-searchString-index" class="headerlink" title="str.endsWith(searchString [, index]);"></a>str.endsWith(searchString [, index]);</h3><p>定义：判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p><h3 id="str-indexOf-searchValue-index"><a href="#str-indexOf-searchValue-index" class="headerlink" title="str.indexOf(searchValue[, index])"></a>str.indexOf(searchValue[, index])</h3><p>定义：第一次出现的指定值的索引，开始在Index进行搜索，否则返回-1。</p><h3 id="str-lastIndexOf-searchValue-index"><a href="#str-lastIndexOf-searchValue-index" class="headerlink" title="str.lastIndexOf(searchValue[, index])"></a>str.lastIndexOf(searchValue[, index])</h3><p>定义：返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</p><h3 id="str-localeCompare-compareString-locales-options"><a href="#str-localeCompare-compareString-locales-options" class="headerlink" title="str.localeCompare(compareString[, locales[, options]])"></a>str.localeCompare(compareString[, locales[, options]])</h3><p>定义：localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。</p><h3 id="str-match-regexp"><a href="#str-match-regexp" class="headerlink" title="str.match(regexp);"></a>str.match(regexp);</h3><p>定义：当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。</p><h3 id="str-normalize-form"><a href="#str-normalize-form" class="headerlink" title="str.normalize([form]);"></a>str.normalize([form]);</h3><p>定义：会按照指定的一种 Unicode 正规形式将当前字符串正规化。</p><h3 id="str-padStart-targetLength-padString"><a href="#str-padStart-targetLength-padString" class="headerlink" title="str.padStart(targetLength [, padString])"></a>str.padStart(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之前（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p><h3 id="str-padEnd-targetLength-padString"><a href="#str-padEnd-targetLength-padString" class="headerlink" title="str.padEnd(targetLength [, padString])"></a>str.padEnd(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之后（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p><h3 id="str-repeat-count"><a href="#str-repeat-count" class="headerlink" title="str.repeat(count);"></a>str.repeat(count);</h3><p>定义：返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。<br>PS：参数从零开始。</p><h3 id="str-replace-regexp-substr-newSubStr-function"><a href="#str-replace-regexp-substr-newSubStr-function" class="headerlink" title="str.replace(regexp|substr, newSubStr|function)"></a>str.replace(regexp|substr, newSubStr|function)</h3><p>定义：返回一个由替换值替换一些或所有匹配的模式后的新字符串。<br>如果第一个参数为regexp第二个参数为function时，该函数参数说明<br>参数1：匹配模式的字符串。<br>参数2–：子表达是匹配的子字符串（就是捕获分组）。<br>倒数参数2：声明匹配在string中出现的位置。<br>倒数参数1：进行匹配的sting本身。</p><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>定义：行正则表达式和 String对象之间的一个搜索匹配。<br>返回：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p><h3 id="str-slice-beginSlice-endSlice"><a href="#str-slice-beginSlice-endSlice" class="headerlink" title="str.slice(beginSlice[, endSlice])"></a>str.slice(beginSlice[, endSlice])</h3><p>定义：提取一个字符串的一部分，并返回一新的字符串。<br>参数：beginSlice从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度。<br>endSlice在该索引（以 0 为基数）处结束提取字符串，同样可为负数。</p><h3 id="str-split-separator-limit"><a href="#str-split-separator-limit" class="headerlink" title="str.split([separator[, limit]])"></a>str.split([separator[, limit]])</h3><p>定义：使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 </p><h3 id="str-substr-start-length"><a href="#str-substr-start-length" class="headerlink" title="str.substr(start[, length])"></a>str.substr(start[, length])</h3><p>定义：返回一个字符串中从指定位置开始到指定字符数的字符。<br>PS：start &gt;=str.length 或 length &lt;= 0 返回空字符串;start &lt; 0 则转换为start + str.length。</p><h3 id="str-substring-indexStart-indexEnd"><a href="#str-substring-indexStart-indexEnd" class="headerlink" title="str.substring(indexStart[, indexEnd])"></a>str.substring(indexStart[, indexEnd])</h3><p>定义：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。<br>PS：一些特殊情况。<br>如果 indexStart 等于 indexEnd，substring 返回一个空字符串。<br>如果省略 indexEnd，substring 提取字符一直到字符串末尾。<br>如果任一参数小于 0 或为 NaN，则被当作 0。<br>如果任一参数大于 stringName.length，则被当作 stringName.length。<br>如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。</p><h3 id="str-toLowerCase"><a href="#str-toLowerCase" class="headerlink" title="str.toLowerCase()"></a>str.toLowerCase()</h3><p>定义：将调用该方法的字符串值转为小写形式，并返回新字符串。</p><h3 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h3><p>定义：将调用该方法的字符串值转换为大写形式，并返回新字符串。</p><h3 id="str-toLocaleLowerCase"><a href="#str-toLocaleLowerCase" class="headerlink" title="str.toLocaleLowerCase()"></a>str.toLocaleLowerCase()</h3><p>定义：根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。<br>PS：在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同（除土耳其等）。</p><h3 id="str-toLocaleUpperCase"><a href="#str-toLocaleUpperCase" class="headerlink" title="str.toLocaleUpperCase()"></a>str.toLocaleUpperCase()</h3><p>定义：使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。</p><h3 id="str-toString"><a href="#str-toString" class="headerlink" title="str.toString()"></a>str.toString()</h3><p>定义：返回指定对象的字符串形式。</p><h3 id="str-trim"><a href="#str-trim" class="headerlink" title="str.trim()"></a>str.trim()</h3><p>定义：会从一个字符串的两端删除空白字符，返回一个新的字符串。<br>PS：str.trimLeft() 和 str.trimRight() 不是标准方法。</p><h3 id="string-Symbol-iterator"><a href="#string-Symbol-iterator" class="headerlink" title="string[Symbol.iterator]"></a>string[Symbol.iterator]</h3><p>返回一个新的Iterator对象，它遍历字符串的代码点，返回每一个代码点的字符串值。<br>PS：下列内置类型拥有默认迭代器行为Array、String、Set、Map等，而Object没有。</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><p>在 ES2015 中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。</p><h3 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike[, mapFn[, thisArg]])"></a>Array.from(arrayLike[, mapFn[, thisArg]])</h3><p>定义：从一个类似数组或可迭代对象中创建一个新的数组实例。<br>参数：<br>  arrayLike想要转换成数组的伪数组对象或可迭代对象。<br>  mapFn (可选参数)如果指定了该参数，新数组中的每个元素会执行该回调函数。<br>  thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。<br>返回：一个新的数组。<br>PS：Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg)，ES6之前的做法：Array.prototype.slice.call(arrayLike)。</p><h3 id="Array-isArray-obj"><a href="#Array-isArray-obj" class="headerlink" title="Array.isArray(obj)"></a>Array.isArray(obj)</h3><p>定义：确定传递的值是否是一个 Array。<br>返回：boolean。<br>PS：ES6之前的做法Object.prototype.toString.call(arg) === ‘[object Array]’。</p><h3 id="Array-of-element0-element1-…-elementN"><a href="#Array-of-element0-element1-…-elementN" class="headerlink" title="Array.of(element0[, element1[, …[, elementN]]])"></a>Array.of(element0[, element1[, …[, elementN]]])</h3><p>定义：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。<br>参数：任意个参数，将按顺序成为返回数组中的元素。<br>返回：参数列表组成的数组。<br>PS：Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。</p><h2 id="实例方法及属性"><a href="#实例方法及属性" class="headerlink" title="实例方法及属性"></a>实例方法及属性</h2><h3 id="ary-length"><a href="#ary-length" class="headerlink" title="ary.length"></a>ary.length</h3><p>返回：读写数组的长度。</p><h3 id="修改器方法（改变原数组）"><a href="#修改器方法（改变原数组）" class="headerlink" title="修改器方法（改变原数组）"></a>修改器方法（改变原数组）</h3><h4 id="arr-copyWithin-target-start-end"><a href="#arr-copyWithin-target-start-end" class="headerlink" title="arr.copyWithin(target[, start[, end]])"></a>arr.copyWithin(target[, start[, end]])</h4><p>定义：浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。<br>参数：<br>target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。<br>start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。<br>end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。<br>返回值：操作原数组。</p><h4 id="arr-fill-value-start-end"><a href="#arr-fill-value-start-end" class="headerlink" title="arr.fill(value[, start[, end]])"></a>arr.fill(value[, start[, end]])</h4><p>定义：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。<br>参数：<br>  value 用来填充数组元素的值。<br>  start 开始索引，默认为0。<br>  end 结束索引，默认为arr.length（不包括）。<br>返回：修改后的数组。</p><h4 id="arr-push-element1-…-elementN"><a href="#arr-push-element1-…-elementN" class="headerlink" title="arr.push(element1, …, elementN)"></a>arr.push(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br>参数：<br>  elementN 被添加到数组末尾的元素。<br>返回：操作后的数组的长度。</p><h4 id="arr-pop"><a href="#arr-pop" class="headerlink" title="arr.pop()"></a>arr.pop()</h4><p>定义：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素(当数组为空时返回undefined)。</p><h4 id="arr-reverse"><a href="#arr-reverse" class="headerlink" title="arr.reverse()"></a>arr.reverse()</h4><p>定义：将数组中元素的位置颠倒。<br>返回：颠倒数组中元素的位置，并返回该数组的引用。</p><h4 id="arr-sort-compareFunction"><a href="#arr-sort-compareFunction" class="headerlink" title="arr.sort(compareFunction)"></a>arr.sort(compareFunction)</h4><p>定义：可以根据指定方法对数组进行排序。<br>compareFunction 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>返回：返回排序后的数组。原数组已经被排序后的数组代替。</p><h4 id="arr-shift"><a href="#arr-shift" class="headerlink" title="arr.shift()"></a>arr.shift()</h4><p>定义：从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素; 如果数组为空则返回undefined。 </p><h4 id="arr-unshift-element1-…-elementN"><a href="#arr-unshift-element1-…-elementN" class="headerlink" title="arr.unshift(element1, …, elementN)"></a>arr.unshift(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br>参数：element1, …, elementN 要添加到数组开头的元素。<br>返回：当一个对象调用该方法时，返回其 length 属性值。</p><h4 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start, [deleteCount], [item1], [item2], …)"></a>array.splice(start, [deleteCount], [item1], [item2], …)</h4><p>定义：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br>参数：<br>  start 开始修改的位置。<br>  deleteCount 移除数组元素的个数。<br>  item1、item2…为添加的元素。<br>返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p><h3 id="访问方法（不直接操作原理的数组）"><a href="#访问方法（不直接操作原理的数组）" class="headerlink" title="访问方法（不直接操作原理的数组）"></a>访问方法（不直接操作原理的数组）</h3><h4 id="old-array-concat-value1-value2-…-valueN"><a href="#old-array-concat-value1-value2-…-valueN" class="headerlink" title="old_array.concat(value1[, value2[, …[, valueN]]])"></a>old_array.concat(value1[, value2[, …[, valueN]]])</h4><p>定义：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br>参数：valueN 将数组和/或值连接成新数组。<br>返回：新数组。</p><h4 id="arr-includes-searchElement-fromIndex"><a href="#arr-includes-searchElement-fromIndex" class="headerlink" title="arr.includes(searchElement, [fromIndex])"></a>arr.includes(searchElement, [fromIndex])</h4><p>定义：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：boolean。</p><h4 id="arr-join-separator"><a href="#arr-join-separator" class="headerlink" title="arr.join([separator])"></a>arr.join([separator])</h4><p>定义：将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：string。</p><h4 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin], [end])"></a>arr.slice([begin], [end])</h4><p>定义：返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。<br>返回：一个含有提取元素的新数组。</p><h4 id="arr-indexOf-searchElement-fromIndex-0"><a href="#arr-indexOf-searchElement-fromIndex-0" class="headerlink" title="arr.indexOf(searchElement[, fromIndex = 0])"></a>arr.indexOf(searchElement[, fromIndex = 0])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。</p><h4 id="arr-lastIndexOf-searchElement-fromIndex-arr-length-1"><a href="#arr-lastIndexOf-searchElement-fromIndex-arr-length-1" class="headerlink" title="arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])"></a>arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：数组中最后一个元素的索引，如未找到返回-1。</p><h4 id="arr-toString"><a href="#arr-toString" class="headerlink" title="arr.toString()"></a>arr.toString()</h4><p>定义：返回一个字符串，表示指定的数组及其元素。<br>返回：逗号分隔的字符串。</p><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="array-forEach-callback-currentValue-index-array-do-something-this"><a href="#array-forEach-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.forEach(callback(currentValue, index, array){ //do something}, this)"></a>array.forEach(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：对数组的每个元素执行一次提供的函数。<br>返回：undefined。<br>PS：没有办法中止或者跳出 forEach 循环，需要跳出请使用循环代替。<br>已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不会跳过那些值为 undefined、null 的项）。</p><h4 id="array-map-callback-currentValue-index-array-do-something-this"><a href="#array-map-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.map(callback(currentValue, index, array){ //do something}, this)"></a>array.map(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>返回：一个新数组，每个元素都是回调函数的结果。</p><h4 id="arr-keys"><a href="#arr-keys" class="headerlink" title="arr.keys()"></a>arr.keys()</h4><p>定义：返回一个新的Array迭代器，它包含数组中每个索引的键。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-values"><a href="#arr-values" class="headerlink" title="arr.values()"></a>arr.values()</h4><p>定义：返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-entries"><a href="#arr-entries" class="headerlink" title="arr.entries()"></a>arr.entries()</h4><p>定义：返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。<br>返回：一个新的 Array 迭代器对象。</p><h4 id="arr-every-callback-thisArg"><a href="#arr-every-callback-thisArg" class="headerlink" title="arr.every(callback[, thisArg])"></a>arr.every(callback[, thisArg])</h4><p>定义：测试数组的所有元素是否都通过了指定函数的测试。<br>返回：boolean。</p><h4 id="arr-some-callback-thisArg"><a href="#arr-some-callback-thisArg" class="headerlink" title="arr.some(callback[, thisArg])"></a>arr.some(callback[, thisArg])</h4><p>定义：测试数组中的某些元素是否通过由提供的函数实现的测试。<br>返回：boolean。</p><h4 id="arr-filter-callback-thisArg"><a href="#arr-filter-callback-thisArg" class="headerlink" title="arr.filter(callback[, thisArg])"></a>arr.filter(callback[, thisArg])</h4><p>定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br>返回：新数组。</p><h4 id="arr-findIndex-callback-thisArg"><a href="#arr-findIndex-callback-thisArg" class="headerlink" title="arr.findIndex(callback[, thisArg])"></a>arr.findIndex(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值的索引，否则返回 -1。</p><h4 id="arr-find-callback-thisArg"><a href="#arr-find-callback-thisArg" class="headerlink" title="arr.find(callback[, thisArg])"></a>arr.find(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。</p><h4 id="arr-reduce-callback-initialValue"><a href="#arr-reduce-callback-initialValue" class="headerlink" title="arr.reduce(callback[, initialValue])"></a>arr.reduce(callback[, initialValue])</h4><p>定义：对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<br>参数：<br>  callback 执行数组中每个值的函数，包含四个参数：<br>    accumulato 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br>    currentValue 数组中正在处理的元素。<br>    currentIndex可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。<br>    array可选 调用reduce的数组。<br>  initialValue 可选用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br>返回：函数累计处理的结果。</p><h4 id="arr-reduceRight-callback-initialValue"><a href="#arr-reduceRight-callback-initialValue" class="headerlink" title="arr.reduceRight(callback[, initialValue])"></a>arr.reduceRight(callback[, initialValue])</h4><p>定义：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。</p><h4 id="arrSymbol-iterator"><a href="#arrSymbol-iterator" class="headerlink" title="arrSymbol.iterator"></a>arr<a href="">Symbol.iterator</a></h4><p>定义：默认为数组不说了迭代器，@@iterator 属性和 values() 属性的初始值均为同一个函数对象。<br>返回：数组的 iterator 方法，默认情况下与 values() 返回值相同。</p><h4 id="arr-flatten-depth"><a href="#arr-flatten-depth" class="headerlink" title="arr.flatten(depth)"></a>arr.flatten(depth)</h4><p>定义：会递归到指定深度将所有子数组连接，并返回一个新数组。<br>参数：depth 可选指定嵌套数组中的结构深度，默认值为1。<br>返回：一个将子数组连接的新数组。</p><h4 id="arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg"><a href="#arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg" class="headerlink" title="arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])"></a>arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])</h4><p>定义：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flatten 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。<br>返回：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</p><h1 id="Proxy-amp-amp-Reflect"><a href="#Proxy-amp-amp-Reflect" class="headerlink" title="Proxy &amp;&amp; Reflect"></a>Proxy &amp;&amp; Reflect</h1><p>Proxy是一个构造函数（对对象的访问进行拦截），Reflect（操作对象提供的API）。<br>Reflect它与Proxy对象的方法是一一对应的，这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Proxy方法：target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">var person = &#123;</div><div class="line">  name: &quot;张三&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var proxy = new Proxy(person, &#123;</div><div class="line">  get: function(target, property) &#123;</div><div class="line">    if (property in target) &#123;</div><div class="line">      return target[property];</div><div class="line">    &#125; else &#123;</div><div class="line">      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">proxy.name // &quot;张三&quot;</div><div class="line">proxy.age // 抛出一个错误</div></pre></td></tr></table></figure></p><p><a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" target="_blank" rel="external">Proxy使用详解</a></p><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。<br>// 下列方法说明：target为目标对象，name为某个属性，receiver为如果name属性设置了赋值函数，则为函数的this指向<br>Reflect.apply(target, thisArg, args)<br>  Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。<br>Reflect.construct(target, args)<br>  Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。<br>Reflect.get(target, name, receiver)<br>  Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>Reflect.set(target, name, value, receiver)<br>  Reflect.set方法设置target对象的name属性等于value。<br>Reflect.defineProperty(target, name, desc)<br>  Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。<br>Reflect.deleteProperty(target, name)<br>  Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。<br>Reflect.has(target, name)<br>  Reflect.has方法对应name in obj里面的in运算符。<br>Reflect.ownKeys(target)<br>  Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。<br>Reflect.isExtensible(target)<br>  Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。<br>Reflect.preventExtensions(target)<br>  Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。<br>Reflect.getOwnPropertyDescriptor(target, name)<br>  Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。<br>Reflect.getPrototypeOf(target)<br>  Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。<br>Reflect.setPrototypeOf(target, prototype)<br>  Reflect.setPrototypeOf方法用于设置对象的<strong>proto</strong>属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。</p><h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>Event接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="bubbles（只读）"><a href="#bubbles（只读）" class="headerlink" title="bubbles（只读）"></a>bubbles（只读）</h3><p>定义：用来表示该事件是否在DOM中冒泡的boolean值。</p><h3 id="cancelBubble（废弃）"><a href="#cancelBubble（废弃）" class="headerlink" title="cancelBubble（废弃）"></a>cancelBubble（废弃）</h3><p>定义：获取或设置当前事件是否要取消冒泡（使用e.stopPropagation()代替）。</p><h3 id="cancelable（只读）"><a href="#cancelable（只读）" class="headerlink" title="cancelable（只读）"></a>cancelable（只读）</h3><p>定义：表示这个事件是否可以取消默认行为（阻止默认行为e.preventDefault()）。</p><h3 id="composed（只读）"><a href="#composed（只读）" class="headerlink" title="composed（只读）"></a>composed（只读）</h3><p>定义：表示该事件是否可以Shadow DOM 传递到一般的 DOM。</p><h3 id="currentTarget（只读）"><a href="#currentTarget（只读）" class="headerlink" title="currentTarget（只读）"></a>currentTarget（只读）</h3><p>定义：当前注册事件的对象的引用，这个值会在传递途中发生变化。</p><h3 id="deepPath"><a href="#deepPath" class="headerlink" title="deepPath"></a>deepPath</h3><p>定义：返回事件冒泡过程所有经过的节点所构成的Array数组。</p><h3 id="defaultPrevented（只读）"><a href="#defaultPrevented（只读）" class="headerlink" title="defaultPrevented（只读）"></a>defaultPrevented（只读）</h3><p>定义：返回是否已经调用了e.preventDefault()来阻止默认行为。</p><h3 id="eventPhase（只读）"><a href="#eventPhase（只读）" class="headerlink" title="eventPhase（只读）"></a>eventPhase（只读）</h3><p>定义：返回事件流正在哪个阶段。</p><h3 id="returnValue（废弃）"><a href="#returnValue（废弃）" class="headerlink" title="returnValue（废弃）"></a>returnValue（废弃）</h3><p>定义：获取或设置事件的默认操作是否已被阻止。</p><h3 id="target（只读）"><a href="#target（只读）" class="headerlink" title="target（只读）"></a>target（只读）</h3><p>定义：返回一个触发事件的对象的引用（ie的srcElement）。</p><h3 id="timeStamp（只读）"><a href="#timeStamp（只读）" class="headerlink" title="timeStamp（只读）"></a>timeStamp（只读）</h3><p>定义：事件创建时的时间戳，毫秒级别。</p><h3 id="type（只读）"><a href="#type（只读）" class="headerlink" title="type（只读）"></a>type（只读）</h3><p>定义：返回一个字符串（不区分大小写）, 表示该事件对象的事件类型。</p><h3 id="isTrusted（只读）"><a href="#isTrusted（只读）" class="headerlink" title="isTrusted（只读）"></a>isTrusted（只读）</h3><p>定义：指明事件是否是由浏览器（当用户点击实例后）或者由脚本（使用事件的创建方法，例如event.initEvent）启动。</p><h3 id="target与currentTarget的区别"><a href="#target与currentTarget的区别" class="headerlink" title="target与currentTarget的区别"></a>target与currentTarget的区别</h3><p>event.target返回触发事件的元素<br>event.currentTarget返回绑定事件的元素<br><a href="https://www.cnblogs.com/yewenxiang/p/6171411.html" target="_blank" rel="external">event对象中 target和currentTarget 属性的区别</a></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="document-createEvent-“UIEvents”"><a href="#document-createEvent-“UIEvents”" class="headerlink" title="document.createEvent(“UIEvents”)"></a>document.createEvent(“UIEvents”)</h3><p>创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化。</p><h3 id="event-initEvent-type-bubbles-cancelable"><a href="#event-initEvent-type-bubbles-cancelable" class="headerlink" title="event.initEvent(type, bubbles, cancelable)"></a>event.initEvent(type, bubbles, cancelable)</h3><p>定义：Event.initEvent() 方法可以用来初始化由Document.createEvent() 创建的 event 实例，且在触发之前event.dispatchEvent()。</p><h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h3><p>定义：如果此事件没有需要显式处理，那么它默认的动作也不要做（因为默认是要做的）。</p><h3 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation()"></a>event.stopPropagation()</h3><p>定义：阻止捕获和冒泡阶段中当前事件的进一步传播（只阻止当前侦听器）。</p><h3 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h3><p>定义：阻止调用相同事件的其他侦听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;值属性&quot;&gt;&lt;a href=&quot;#值属性&quot; class=&quot;headerlink&quot; title=&quot;值属性&quot;&gt;&lt;/a&gt;值属性&lt;/h1&gt;&lt;p&gt;这部分属性只是简单的值，它们没有自己的属性和方法。&lt;/p&gt;
&lt;h3 id=&quot;Infinity&quot;&gt;&lt;a href=&quot;#Infinity
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从对象的遍历到浅拷贝的思考</title>
    <link href="https://fanerge.github.io/2017/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E5%88%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%80%9D%E8%80%83.html"/>
    <id>https://fanerge.github.io/2017/从对象的遍历到浅拷贝的思考.html</id>
    <published>2018-03-14T12:17:36.000Z</published>
    <updated>2018-03-16T14:00:15.496Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有<span style="color: red;">String</span>类型，ES6之后对象的属性有<span style="color: red;">String和Symbol类型</span>。<br>由于文章上下文关系，本文将按照’属性描述符’-&gt;’对象的属性遍历方法介绍’-&gt;’现代ECMAScript对象的浅拷贝’进行介绍，现代ECMAScript对象的深拷贝比较复杂，有时间在分析。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。</p><h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p><h2 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</p><h2 id="属性描述符的读写操作"><a href="#属性描述符的读写操作" class="headerlink" title="属性描述符的读写操作"></a>属性描述符的读写操作</h2><p>我们可以通过Object.getOwnPropertyDescriptor(o,name)、Object.getOwnPropertyDescriptors(obj)来查看属性描述符，<br>通过Object.defineProperty(o,name,desc)、Object.defineProperties(o,descriptors)、Object.create(proto,descriptors)等方法来更改属性描述符。</p><h1 id="对象的属性遍历方法介绍"><a href="#对象的属性遍历方法介绍" class="headerlink" title="对象的属性遍历方法介绍"></a>对象的属性遍历方法介绍</h1><p>上面，我们了解了属性描述符，其中枚举这个属性描述符，在不同方法对对象属性的遍历过程产生的作用差异很大，下面我开始介绍如何遍历对象的属性。<br><strong>本小结的测试代码，我就不贴出来了，都很简单，我这里直接给出结论，感兴趣的朋友可以自己尝试。</strong></p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>定义：for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item in object) &#123;...&#125;</div><div class="line">// itme--在每次迭代时，将不同的属性名分配给变量。</div><div class="line">// object--被迭代枚举其属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.可以遍历对象自身和原型链上可枚举的属性<br>2.任意顺序，说明遍历的属性先后顺序不定（不同运行环境顺序不同）。不建议对数组使用for…in来遍历主要原因就是这个，另一方面为性能考虑for…in还会遍历到原型链上的可枚举属性。</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>定义：Object.keys() 方法会返回一个由该对象的自身的可枚举属性组成的数组。</p><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.keys(obj)</div><div class="line">// obj--要返回其枚举自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性是可枚举的<br>3.任意顺序，枚举属性的顺序和for…in/Object.getOwnPropertyNames(obj)一致<br>4.返回一个所有元素为字符串（不包括Symbol）的数组</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>定义：Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyNames(obj)</div><div class="line">// obj--一个对象，其自身的可枚举和不可枚举属性的名称被返回。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性了枚举和不可枚举都可以遍历<br>3.任意顺序，枚举属性的顺序和for…in/Object.keys(obj)一致</p><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>定义：Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertySymbols(obj)</div><div class="line">// obj--要返回 Symbol 属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性为Symbol类型</p><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><p>定义：Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Reflect.ownKeys(target)</div><div class="line">// target--获取自身属性键的目标对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>这里看，似乎能遍历出自身的所有属性，还差原型连上的属性。</p><h2 id="总结下上面的方法"><a href="#总结下上面的方法" class="headerlink" title="总结下上面的方法"></a>总结下上面的方法</h2><p>为了好归纳，我这里将对象的属性分为以下类别：1.自身可枚举的属性，2.自身不可枚举的属性，3.Symbol类型的属性，4.原型链上的可枚举属性，5.原型链上的不可枚举属性，6.原型链上的Symbol属性<strong>2018-03-16更新</strong></p><table><thead><tr><th>方法</th><th style="text-align:center">可遍历的属性类别</th></tr></thead><tbody><tr><td>for…in</td><td style="text-align:center">1，4</td></tr><tr><td>Object.keys()</td><td style="text-align:center">1</td></tr><tr><td>Object.getOwnPropertyNames()</td><td style="text-align:center">1，2</td></tr><tr><td>Object.getOwnPropertySymbols()</td><td style="text-align:center">3</td></tr><tr><td>Reflect.ownKeys()</td><td style="text-align:center">1，2，3</td></tr></tbody></table><p>从上表分析，还没有一个方法能完美解决，我们只能组合使用了。<br>PS：除了for…in其余方法均返回数组。</p><h1 id="现代ECMAScript对象的浅拷贝"><a href="#现代ECMAScript对象的浅拷贝" class="headerlink" title="现代ECMAScript对象的浅拷贝"></a>现代ECMAScript对象的浅拷贝</h1><p>本小节会我们会实现各种浅拷贝，并分析各自的劣势，最终我们将实现一种比较完美的方法（暂不考虑兼容性）。</p><h2 id="现看一个以前实现的方法"><a href="#现看一个以前实现的方法" class="headerlink" title="现看一个以前实现的方法"></a>现看一个以前实现的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function shallowCopy (obj) &#123;</div><div class="line">  if (typeof obj !== &apos;object&apos;) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  var newObj = obj instanceof Array ? [] : &#123;&#125;</div><div class="line">  for (var key in obj) &#123;</div><div class="line">    if (obj.hasOwnProperty(key)) &#123;</div><div class="line">      newObj[key] = obj[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return newObj</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这中方法对于ES6之前的确可行，毕竟我也用过这样的方法，有了Symbol之后这个就不再正确了。</p><h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><blockquote><p>   该方式在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。<br>不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的 对象 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们</p></blockquote><h2 id="Object-assign-和-展开运算符（…）"><a href="#Object-assign-和-展开运算符（…）" class="headerlink" title="Object.assign 和 展开运算符（…）"></a>Object.assign 和 展开运算符（…）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj2 = Object.assign(&#123;&#125;, obj)</div><div class="line">// obj2</div><div class="line">&#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个函数的定义：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>特点：自身的可枚举的包括Symbol类型的，不包括不可枚举的属性和原型链上的属性，不完美。</p><h2 id="Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors"><a href="#Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors" class="headerlink" title="Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()"></a>Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()</h2><p>首先需要介绍一下相关的方法，ES7的Object.getOwnPropertyDescriptors()。</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>定义：Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// 需要获取自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>4.包括了集体属性的描述符（value）<br>到这里似乎我们已经找到了，比较完美的解决方案了，我们来组合一下这3个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// obj为需要浅拷贝的对象</div><div class="line">let obj1 = Object.create(</div><div class="line">  Object.getPrototypeOf(obj), </div><div class="line">  Object.getOwnPropertyDescriptors(obj) </div><div class="line">)</div><div class="line">// obj1就是我们浅拷贝的得到的对象。</div></pre></td></tr></table></figure></p><p>PS：obj1对象通过Object.create()方法指定了自身的原型链（从原型链继承了相关属性），然后在通过Object.getOwnPropertyDescriptors()方法把自身的（包括可枚举的、不可枚举的、Symbol类型的）全部添加obj1上，这样是实现了我们的真正意义上的浅拷贝。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>数组的浅拷贝ary.slice()、 ary.concat()、[…ary]、JSON.parse(JSON.stringify(ary))<br><a href="https://fanerge.github.io/">期望加入一个技术氛围nice的团队-成都</a></p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="external">Object.getOwnPropertySymbols</a><br><a href="https://github.com/Alvin-Liu/Blog/issues/8" target="_blank" rel="external">ES6时代，你真的会克隆对象吗？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有&lt;span style=&quot;color: red;&quot;&gt;String&lt;/span&gt;类型，ES6之后对象的属性有&lt;span
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>梳理下浏览器对象模型知识（BOM）</title>
    <link href="https://fanerge.github.io/2018/%E6%A2%B3%E7%90%86%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%EF%BC%88BOM%EF%BC%89.html"/>
    <id>https://fanerge.github.io/2018/梳理下浏览器对象模型知识（BOM）.html</id>
    <published>2018-03-12T12:41:17.000Z</published>
    <updated>2018-03-16T14:03:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。</p><h1 id="BOM介绍"><a href="#BOM介绍" class="headerlink" title="BOM介绍"></a>BOM介绍</h1><p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。<br>浏览器对象模型的构成<br><img src="http://p5hb0ypha.bkt.clouddn.com/BOM.svg" alt="浏览器对象模型的构成"></p><h1 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h1><p>Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。<br>在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。</p><h2 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" alt="Window对象的属性"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" target="_blank" rel="external">看不清，点这里</a></p><h2 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" alt="Window对象的方法"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h1><p>Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。<br>Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。<br><img src="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" alt="Location对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h1><p>History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。<br><img src="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" alt="History对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h1><p>Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。<br><img src="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" alt="Navigator对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h1><p>Screen 对象包含有关用户屏幕的信息。<br><img src="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" alt="Screen对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h1><p>Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。<br><img src="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" alt="document对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。&lt;/p&gt;
&lt;h1 id=&quot;BOM介绍&quot;&gt;&lt;a href=&quot;#BOM介绍&quot; class=&quot;head
      
    
    </summary>
    
      <category term="BOM" scheme="https://fanerge.github.io/categories/BOM/"/>
    
    
      <category term="BOM" scheme="https://fanerge.github.io/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj2</title>
    <link href="https://fanerge.github.io/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj2.html"/>
    <id>https://fanerge.github.io/2018/前端常识-gj2.html</id>
    <published>2018-03-11T12:19:13.000Z</published>
    <updated>2018-03-11T13:08:28.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h1><ol><li>在浏览器地址栏输入URL</li><li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control<br>  HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期<br>  HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间    </li><li>浏览器解析URL获取协议，主机，端口，path    </li><li>浏览器组装一个HTTP（GET）请求报文    </li><li>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存<br>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li><li>打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z</li><li>TCP链接建立后发送HTTP请求    </li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序    </li><li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码    </li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作    </li><li>服务器将响应报文通过TCP连接发送回浏览器    </li><li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同    </li><li>如果资源可缓存，进行缓存    </li><li>对响应进行解码（例如gzip压缩）    </li><li>根据资源类型决定如何处理（假设资源为HTML文档）    </li><li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释    </li><li>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树    </li><li>解析过程中遇到图片、样式表、js文件，启动下载    </li><li>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</li><li>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式</li><li>js解析如下：<br>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading<br>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素<br>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</li><li>显示页面（HTML解析过程中会逐步显示页面）<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="CSS选择器有哪些"><a href="#CSS选择器有哪些" class="headerlink" title="CSS选择器有哪些"></a>CSS选择器有哪些</h2></li></ol><ul><li>通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+<br>#X id选择器：选择id值为X的元素，兼容性：IE6+<br>.X 类选择器： 选择class包含X的元素，兼容性：IE6+<br>X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+<br>X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+<br>:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+<br>X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+<br>X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+<br>X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+<br>[attr]：选择所有设置了attr属性的元素，兼容性IE7+<br>[attr=value]：选择属性值刚好为value的元素<br>[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素<br>[attr|=value]：选择属性值刚好为value或者value-开头的元素<br>[attr^=value]：选择属性值以value开头的元素<br>[attr$=value]：选择属性值以value结尾的元素<br>[attribute*=value]：选择属性值中包含value的元素<br>X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+<br>:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+<br>:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+<br>::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+<br>::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+<br>:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+<br>:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+<br>X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+<br>X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+<br>X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+<br>X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+<br>X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+<br>X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+<br>X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+<h2 id="css-sprite是什么-有什么优缺点"><a href="#css-sprite是什么-有什么优缺点" class="headerlink" title="css sprite是什么,有什么优缺点"></a>css sprite是什么,有什么优缺点</h2>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。<br>优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br>缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要从新布局整个图片，样式<h2 id="display-none-与visibility-hidden-的区别"><a href="#display-none-与visibility-hidden-的区别" class="headerlink" title="display: none;与visibility: hidden;的区别"></a>display: none;与visibility: hidden;的区别</h2>相同点：它们都能让元素不可见<br>区别：<br>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见<br>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式<br>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。<br>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容<h2 id="specified-value-computed-value-used-value计算方法"><a href="#specified-value-computed-value-used-value计算方法" class="headerlink" title="specified value,computed value,used value计算方法"></a>specified value,computed value,used value计算方法</h2>specified value: 计算方法如下：<br>  如果样式表设置了一个值，使用这个值<br>  如果没有设置值，这个属性是继承属性，从父元素继承<br>  如果没设置，并且不是继承属性，使用css规范指定的初始值及浏览器初始值<br>computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承<br>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局，<br>  background-position<br>  bottom, left, right, top<br>  height, width<br>  margin-bottom, margin-left, margin-right, margin-top<br>  min-height, min-width<br>  padding-bottom, padding-left, padding-right, padding-top<br>  text-indent<h2 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h2>  link是HTML方式， @import是CSS方式<br>  link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC无样式内容闪烁(Flash Of Unstyled Content)<br>  link可以通过rel=”alternate stylesheet”指定候选样式<br>  浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br>  @import必须在样式规则之前，可以在css文件中引用其他文件<br>  总体来说：link优于@import<h2 id="display-block-和display-inline-的区别"><a href="#display-block-和display-inline-的区别" class="headerlink" title="display: block;和display: inline;的区别"></a>display: block;和display: inline;的区别</h2>block元素特点：<br>  1.处于常规流中时，如果width没有设置，会自动填充满父容器<br>  2.可以应用margin/padding<br>  3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素<br>  4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）<br>  5.忽略vertical-align<br>inline元素特点<br>  1.水平方向上根据direction依次布局<br>  2.不会在元素前后进行换行<br>  3.受white-space控制<br>  4.margin/padding在竖直方向上无效，水平方向上有效<br>  5.width/height属性对非替换行内元素无效，宽度由元素内容决定<br>  6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定<br>  6.浮动或绝对定位时会转换为block<br>  7.vertical-align属性生效<h2 id="PNG-GIF-JPG-webp-svg的区别及如何选"><a href="#PNG-GIF-JPG-webp-svg的区别及如何选" class="headerlink" title="PNG,GIF,JPG,webp,svg的区别及如何选"></a>PNG,GIF,JPG,webp,svg的区别及如何选</h2>GIF:<br>  8位像素，256色<br>  无损压缩<br>  支持简单动画<br>  支持boolean透明<br>  适合简单动画<br>JPEG：<br>  颜色限于256<br>  有损压缩<br>  可控制压缩质量<br>  不支持透明<br>  适合照片<br>PNG：<br>  有PNG8和truecolor PNG<br>  PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画<br>  适合图标、背景、按钮<br>未来趋势：<br>  webp（google推出的图片格式，目前存在浏览器兼容）<br>  svg（矢量图如：iconfont）<h2 id="CSS有哪些继承属性"><a href="#CSS有哪些继承属性" class="headerlink" title="CSS有哪些继承属性"></a>CSS有哪些继承属性</h2>关于文字排版的属性如：<br>  font<br>  word-break<br>  letter-spacing<br>  text-align<br>  text-rendering<br>  word-spacing<br>  white-space<br>  text-indent<br>  text-transform<br>  text-shadow<br>line-height<br>color<br>visibility<br>cursor<h2 id="容器包含若干浮动元素时如何清理-包含-浮动"><a href="#容器包含若干浮动元素时如何清理-包含-浮动" class="headerlink" title="容器包含若干浮动元素时如何清理(包含)浮动"></a>容器包含若干浮动元素时如何清理(包含)浮动</h2>容器元素闭合标签前添加额外元素并设置clear: both<br>父元素触发块级格式化上下文(见块级可视化上下文部分)<br>设置容器元素伪元素进行清理推荐的清理浮动方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 在标准浏览器下使用</div><div class="line">* 1 content内容为空格用于修复opera下文档中出现</div><div class="line">*   contenteditable属性时在清理浮动元素上下的空白</div><div class="line">* 2 使用display使用table而不是block：可以防止容器和</div><div class="line">*   子元素margin-top折叠,这样能使清理效果与BFC，IE6/7</div><div class="line">*   zoom: 1;一致</div><div class="line">* 3 overflow: hidden;</div><div class="line">**/</div><div class="line"></div><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">    content: &quot; &quot;; /* 1 */</div><div class="line">    display: table; /* 2 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">.clearfix:after &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* IE 6/7下使用</div><div class="line">* 通过触发hasLayout实现包含浮动</div><div class="line">**/</div><div class="line">.clearfix &#123;</div><div class="line">    *zoom: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="什么是FOUC-如何避免"><a href="#什么是FOUC-如何避免" class="headerlink" title="什么是FOUC?如何避免"></a>什么是FOUC?如何避免</h2><p>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head使用link元素。</p><h2 id="什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用"><a href="#什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用" class="headerlink" title="什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用"></a>什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于布局中的普通流。<br>创建规则：<br>    根元素<br>    浮动元素（float不是none）<br>    绝对定位元素（position取值为absolute或fixed）<br>    display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素<br>    overflow不是visible的元素<br>作用：<br>    可以包含浮动元素（父布局overflow: hidden）<br>    不被浮动元素覆盖（两列自适应布局：子1浮动，子2不浮动且有overflow: hidden）<br>    阻止父子元素的margin折叠（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中）<br><img src="https://zhuanlan.zhihu.com/p/25321647" alt="https://zhuanlan.zhihu.com/p/25321647"></p><h2 id="display-float-position的关系"><a href="#display-float-position的关系" class="headerlink" title="display,float,position的关系"></a>display,float,position的关系</h2><p>如果display为none，那么position和float都不起作用，这种情况下元素不产生框<br>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。<br>否则，如果float不是none，框是浮动的，display根据下表进行调整<br>否则，如果元素是根元素，display根据下表进行调整<br>其他情况下display的值为指定值<br>总结起来：绝对定位、浮动、根元素都需要调整display</p><h2 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h2><p>毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下：<br>1.两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠<br>2.浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠<br>3.创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠<br>4.元素自身的margin-bottom和margin-top相邻时也会折叠</p><h2 id="如何确定一个元素的包含块-containing-block"><a href="#如何确定一个元素的包含块-containing-block" class="headerlink" title="如何确定一个元素的包含块(containing block)"></a>如何确定一个元素的包含块(containing block)</h2><p>1.根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。<br>2.position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成。<br>3.如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area<br>4.如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下：<br>    如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element.<br>    其他情况下包含块由祖先节点的padding edge组成<br>如果找不到定位的祖先元素，包含块为初始包含块</p><h2 id="stacking-context-布局规则"><a href="#stacking-context-布局规则" class="headerlink" title="stacking context,布局规则"></a>stacking context,布局规则</h2><p>z轴上的默认层叠顺序如下（从下到上）：<br>    根元素的边界和背景<br>    常规流中的元素按照html中顺序<br>    浮动块<br>    positioned元素按照html中出现顺序<br>如何创建stacking context：<br>    根元素<br>    z-index不为auto的定位元素<br>    a flex item with a z-index value other than ‘auto’<br>    opacity小于1的元素<br>    在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context</p><h2 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h2><p>如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现<br>如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。<br>如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto</p><h2 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h2><p>需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height<br><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="external">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术</a><br><a href="http://vanseodesign.com/css/vertical-centering/" target="_blank" rel="external">6 Methods For Vertical Centering With CSS</a></p><h1 id="JavaScript概念部分"><a href="#JavaScript概念部分" class="headerlink" title="JavaScript概念部分"></a>JavaScript概念部分</h1><h2 id="DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系"><a href="#DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系" class="headerlink" title="DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系"></a>DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</h2><p>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性<br>e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问<br>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）<br>e.propName返回值可能是字符串、布尔值、对象、undefined等<br>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性<br>一些布尔属性’<input hidden>‘的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property<br>像’<a href="../index.html">link</a>‘中href属性，转换成property的时候需要通过转换得到完整URL<br>一些attribute和property不是一一对应如：form控件中’input value=”hello”‘对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</p><h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h2><p>offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同<br>clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸</p><h2 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h2><p>1.readyState:表示请求状态的整数，取值：<br>    UNSENT（0）：对象已创建<br>    OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求<br>    HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到<br>    LOADING(3)：响应体正在接收<br>    DONE(4)：数据传输完成或者传输产生错误<br>2.onreadystatechange：readyState改变时调用的函数<br>3.status：服务器返回的HTTP状态码（如，200， 404）<br>4.statusText:服务器返回的HTTP状态信息（如，OK，No Content）<br>5.responseText:作为字符串形式的来自服务器的完整响应<br>6.responseXML: Document对象，表示服务器的响应解析成的XML文档<br>7.abort():取消异步HTTP请求<br>8.getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行<br>9.getResponseHeader(headerName):返回headName对应的报头值<br>10.open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证<br>11.setRequestHeader(name, value):设置HTTP报头<br>12.send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</p><h2 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h2><p>mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持<br>mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能<br>标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素</p><h2 id="sessionStorage-localStorage-cookie区别"><a href="#sessionStorage-localStorage-cookie区别" class="headerlink" title="sessionStorage,localStorage,cookie区别"></a>sessionStorage,localStorage,cookie区别</h2><p>都会在浏览器端保存，有大小限制，同源限制<br>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器<br>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie<br>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除<br>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享<br>localStorage的修改会促发其他文档窗口的update事件<br>cookie有secure属性要求HTTPS传输<br>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</p><h2 id="javascript跨域通信"><a href="#javascript跨域通信" class="headerlink" title="javascript跨域通信"></a>javascript跨域通信</h2><p>同源：两个文档同源需满足<br>    协议相同<br>    域名相同<br>    端口相同<br>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法<br>如果是log之类的简单单项通信，新建img,script,link,iframe元素，通过src，href属性设置为目标url。实现跨域请求<br>如果请求json数据，使用script进行jsonp请求<br>现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用<br>内部服务器代理请求跨域url，然后返回数据<br>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源</p><h2 id="javascript有哪几种数据类型"><a href="#javascript有哪几种数据类型" class="headerlink" title="javascript有哪几种数据类型"></a>javascript有哪几种数据类型</h2><p>六种基本数据类型<br>    undefined<br>    null<br>    string<br>    boolean<br>    number<br>    symbol(ES6)<br>一种引用类型<br>    Object</p><h2 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h2><p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：<br>    函数本身作用域。<br>    闭包定义时的作用域。<br>    全局作用域。<br>闭包常见用途：<br>    创建特权方法用于访问控制<br>    事件处理程序及回调</p><h2 id="javascript有哪几种方法定义函数"><a href="#javascript有哪几种方法定义函数" class="headerlink" title="javascript有哪几种方法定义函数"></a>javascript有哪几种方法定义函数</h2><p>函数声明表达式<br>function操作符<br>Function 构造函数<br>ES6:arrow function</p><h2 id="应用程序存储和离线web应用"><a href="#应用程序存储和离线web应用" class="headerlink" title="应用程序存储和离线web应用"></a>应用程序存储和离线web应用</h2><p>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:’<html manifest="myapp.appcache">‘，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"></div><div class="line">CACHE:</div><div class="line">myapp.html</div><div class="line">myapp.css</div><div class="line">myapp.js</div><div class="line"></div><div class="line">FALLBACK:</div><div class="line">videos/ offline_help.html</div><div class="line"></div><div class="line">NETWORK:</div><div class="line">cgi/</div></pre></td></tr></table></figure></html></p><h2 id="客户端存储localStorage和sessionStorage"><a href="#客户端存储localStorage和sessionStorage" class="headerlink" title="客户端存储localStorage和sessionStorage"></a>客户端存储localStorage和sessionStorage</h2><p>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前<br>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。<br>Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key</p><h2 id="cookie及其操作"><a href="#cookie及其操作" class="headerlink" title="cookie及其操作"></a>cookie及其操作</h2><p>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。<br>通过读写cookie检测是否支持<br>cookie属性有name，value，max-age，path, domain，secure；<br>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期<br>cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问<br>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下<br>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</p><h2 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h2><p>对象字面量： var obj = {};<br>构造函数： var obj = new Object();<br>Object.create(): var obj = Object.create(Object.prototype); // Object.create(proto[, propertiesObject])</p><h2 id="运算符判断相等的流程是怎样的"><a href="#运算符判断相等的流程是怎样的" class="headerlink" title="===运算符判断相等的流程是怎样的"></a>===运算符判断相等的流程是怎样的</h2><p>如果两个值不是相同类型，它们不相等<br>如果两个值都是null或者都是undefined，它们相等<br>如果两个值都是布尔类型true或者都是false，它们相等<br>如果其中有一个是NaN，它们不相等<br>如果都是数值型并且数值相等，他们相等， -0等于0<br>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同和=都认为他们不相等<br>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</p><h2 id="运算符判断相等的流程是怎样的-1"><a href="#运算符判断相等的流程是怎样的-1" class="headerlink" title="==运算符判断相等的流程是怎样的"></a>==运算符判断相等的流程是怎样的</h2><p>如果两个值类型相同，按照===比较方法进行比较<br>如果类型不同，使用如下规则进行比较<br>如果其中一个值是null，另一个是undefined，它们相等<br>如果一个值是数字另一个是字符串，将字符串转换为数字进行比较<br>如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较<br>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较<br>其他所有情况都认为不相等</p><h2 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h2><p>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果<br>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果<br>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</p><h2 id="对象到数字的转换步骤"><a href="#对象到数字的转换步骤" class="headerlink" title="对象到数字的转换步骤"></a>对象到数字的转换步骤</h2><ol><li>如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果</li><li>否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果</li><li>否则，throws a TypeError<h2 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;,&gt;,&lt;=,&gt;=的比较规则"></a>&lt;,&gt;,&lt;=,&gt;=的比较规则</h2>所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:<br>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错<br>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）<br>否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较<h2 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h2>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象<br>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参<br>arguments.length为实参的个数（Function.length表示形参长度）<br>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化<br>arguments.caller为调用当前函数的函数（已被遗弃）<br>转换为数组：var args = Array.prototype.slice.call(arguments, 0);    <h2 id="列举数组相关的常用方法"><a href="#列举数组相关的常用方法" class="headerlink" title="列举数组相关的常用方法"></a>列举数组相关的常用方法</h2>参考答案: push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter<h2 id="列举字符串相关的常用方法"><a href="#列举字符串相关的常用方法" class="headerlink" title="列举字符串相关的常用方法"></a>列举字符串相关的常用方法</h2>参考答案: indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase<h2 id="请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”"><a href="#请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”" class="headerlink" title="请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”"></a>请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];</div><div class="line">var date = new Date();</div><div class="line"></div><div class="line">console.log(&apos;今天是星期&apos; + days[date.getDay()]);</div></pre></td></tr></table></figure></li></ol><h2 id="js里的作用域是什么样子的？"><a href="#js里的作用域是什么样子的？" class="headerlink" title="js里的作用域是什么样子的？"></a>js里的作用域是什么样子的？</h2><p>参考答案：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined.</p><pre><code>var globalVar = &apos;global var&apos;;function test() {alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义var globalVar = &apos;overrided var&apos;; //　globalVar在本函数内被重定义alert(globalVar);　// overrided var}alert(globalVar); // global var，使用全局变量</code></pre><h2 id="js里边的this指的是什么"><a href="#js里边的this指的是什么" class="headerlink" title="js里边的this指的是什么?"></a>js里边的this指的是什么?</h2><p>参考答案: this指的是对象本身，而不是构造函数．    </p><h2 id="apply-call和bind有什么区别"><a href="#apply-call和bind有什么区别" class="headerlink" title="apply, call和bind有什么区别?"></a>apply, call和bind有什么区别?</h2><p>参考答案：三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，    </p><h2 id="caller-callee和arguments分别是什么"><a href="#caller-callee和arguments分别是什么" class="headerlink" title="caller, callee和arguments分别是什么?"></a>caller, callee和arguments分别是什么?</h2><p>参考答案: caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot;&gt;&lt;a href=&quot;#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot; class=&quot;headerlink&quot; title=&quot;从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)&quot;&gt;&lt;/a&gt;从
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Babel工作原理及Babel插件开发探索</title>
    <link href="https://fanerge.github.io/2018/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8ABabel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2.html"/>
    <id>https://fanerge.github.io/2018/Babel工作原理及Babel插件开发探索.html</id>
    <published>2018-03-04T12:46:18.000Z</published>
    <updated>2018-03-04T13:25:41.481Z</updated>
    
    <content type="html"><![CDATA[<p>在掘金上看见了<a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒</a>，正巧自己对Babel工作原理和Babel插件开发也不够了解，赶紧来补一波吧。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>首先我们这里需要了解一些基本的概念，<a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">这篇文章介绍的很详细</a>，我这边只提一下。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。<br>意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。<br>和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。<br>一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote><p>   静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。<br>静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p></blockquote><h1 id="Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）"><a href="#Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）" class="headerlink" title="Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）"></a>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接收代码并输出AST。这个步骤又分为两个阶段：词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段把字符串形式的代码转换成令牌（tokens）流。<br>你可以把令牌看作是一个扁平化的语法片段数组。<br>如：n*n代码经过词法分析转换成令牌<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// n*n</div><div class="line">[</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</div><div class="line">  ...</div><div class="line">]</div></pre></td></tr></table></figure></p><p>每一个type有一组属性来描述该令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &#123;</div><div class="line">    label: &apos;name&apos;,</div><div class="line">    keyword: undefined,</div><div class="line">    beforeExpr: false,</div><div class="line">    startsExpr: true,</div><div class="line">    rightAssociative: false,</div><div class="line">    isLoop: false,</div><div class="line">    isAssign: false,</div><div class="line">    prefix: false,</div><div class="line">    postfix: false,</div><div class="line">    binop: null,</div><div class="line">    updateContext: null</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析阶段会把一个令牌(tokens)流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。<br>这个过程我们可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">astexplorer</a>来查看我们代码生成的AST。<br>这个时候我们的AST就产生了，如下图。<br><img src="http://p52glq5m1.bkt.clouddn.com/ASTdemo1.png" alt="源代码到AST"><br>PS：上图左边为我们的源代码，右边为对应生成的抽象语法树AST。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。<br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。<br>Babel工作原理见下图表示。<br><img src="http://p52glq5m1.bkt.clouddn.com/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="Babel工作原理"><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">图片来源，探索 babel 和 babel 插件是怎么工作的</a></p><h1 id="开发一个Babel插件"><a href="#开发一个Babel插件" class="headerlink" title="开发一个Babel插件"></a>开发一个Babel插件</h1><h2 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a>Visitors（访问者）</h2><p>当我们谈及“进入”一个节点，实际上是说我们在访问它们， 之所以使用这样的术语是因为有一个访问者模式（visitor）的概念。<br>访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const MyVisitor = &#123;</div><div class="line">  Identifier: &#123;</div><div class="line">// 当进入Identifier节点的时候执行</div><div class="line">enter() &#123; </div><div class="line">  console.log(&quot;Entered&quot;);</div><div class="line">&#125;,</div><div class="line">// 当退出Identifier节点的时候执行</div><div class="line">exit() &#123;</div><div class="line">      console.log(&quot;Exited!&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>PS： 许多时候我们只需要关心进入节点，就可以使用简写 Identifier() { … } 或者 Identifier: { enter() { … } } 。<br>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier里面的enter方法和exit方法。</p><h2 id="Paths（路径）"><a href="#Paths（路径）" class="headerlink" title="Paths（路径）"></a>Paths（路径）</h2><blockquote><p>   我们通过 visitor可以在遍历到对应节点执行对应的函数，当需要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置 （即和其他节点间的关系）, visitor在遍历到对应节点执行对应函数时候会给我们传入 path参数，辅助我们完成上面这些操作。注意 Path 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了 Identifier节点，它传入的 path参数看起来是这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;parent&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;VariableDeclarator&quot;,</div><div class="line">    &quot;id&quot;: &#123;</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    ....</div><div class="line">  &#125;,</div><div class="line">  &quot;node&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;Identifier&quot;,</div><div class="line">    &quot;name&quot;: &quot;...&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里就可以通过：path.node.name 获得当前节点的name；path.parent.id 获得父节点的id<br>另外path对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。</p><h2 id="开始动手写插件了"><a href="#开始动手写插件了" class="headerlink" title="开始动手写插件了"></a>开始动手写插件了</h2><p>输入的源代码为：<br><code>yuzhenfan === wangkemei</code><br>生成的AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &quot;BinaryExpression&quot;,</div><div class="line">  operator: &quot;===&quot;,</div><div class="line">  left: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;,</div><div class="line">  right: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>省略部分属性，可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">http://astexplorer.net</a>查看全部属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const babel = require(&apos;babel-core&apos;)</div><div class="line"></div><div class="line">// 我们的babel插件</div><div class="line">let MyVisitor = function(&#123; types: t &#125;) &#123;</div><div class="line">  return &#123;</div><div class="line">    visitor: &#123;</div><div class="line"></div><div class="line">      BinaryExpression(path) &#123;</div><div class="line">  </div><div class="line">        if (path.node.operator !== &quot;===&quot;) &#123;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 改变当前节点的left、right（插件的核心代码）</div><div class="line">path.node.left = t.identifier(&quot;fanerge1&quot;);</div><div class="line">path.node.right = t.identifier(&quot;fanerge2&quot;);</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const code = `yuzhenfan === wangkemei;`;</div><div class="line"></div><div class="line">let demo = babel.transform(code, &#123;</div><div class="line">  // 使用我们的插件</div><div class="line">  plugins: [MyVisitor]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(demo); // fanerge1===fanerge2</div></pre></td></tr></table></figure></p><p>输出的代码为（经过我们的插件处理）：<br><code>fanerge1===fanerge2</code><br>下图为node打印出Balbel输出的代码：<br><img src="http://p52glq5m1.bkt.clouddn.com/result.png" alt="babel转换的代码"><br><a href="https://github.com/fanerge/babel_plugin" target="_blank" rel="external">项目地址，非常简单的Babel插件，后续再继续学习</a></p><blockquote><p>   参考文档<br><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-introduction" target="_blank" rel="external">Babel 插件手册</a><br><a href="https://github.com/estree/estree" target="_blank" rel="external">ESTree</a><br><a href="http://astexplorer.net/" target="_blank" rel="external">AST Explorer</a><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">探索 babel 和 babel 插件是怎么工作的</a><br><a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">掘金-babel插件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在掘金上看见了&lt;a href=&quot;https://juejin.im/post/5a9315e46fb9a0633a711f25&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒&lt;/a&gt;，正
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="Babel" scheme="https://fanerge.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>浏览器工作原理-webkit内核研究</title>
    <link href="https://fanerge.github.io/2018/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html"/>
    <id>https://fanerge.github.io/2018/浏览器工作原理-webkit内核研究.html</id>
    <published>2018-03-03T02:10:00.000Z</published>
    <updated>2018-03-17T12:32:49.119Z</updated>
    
    <content type="html"><![CDATA[<p>从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。<br>主要查阅了<a href="https://book.douban.com/subject/25910556/" target="_blank" rel="external">WebKit技术内幕</a>、<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>、<a href="https://www.w3.org/" target="_blank" rel="external">W3C</a>等网站资料，下文中有若干图片摘自于《WebKit技术内幕》，在此表示感谢。<br>本文略长，如有不适，实属意外。如有不正确的地方，还望指正，毕竟传播真理才不会误导其他同学，共同进步才是目的。</p><h1 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h1><p>浏览器内核由渲染引擎和JS引擎组成，不同的浏览器、即使同一浏览器不同型号可能渲染引擎和JS引擎都不一样。</p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>1)Trident渲染引擎 –&gt; 老版本IE系列浏览器<br>2)Edge渲染引擎 -&gt; Win10中IE浏览器<br>3)Gecko渲染引擎 –&gt; Mozilla Firefox<br>4)Presto渲染引擎 –&gt; Opera<br>5)KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome<br>6)Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器<br>7)Blink渲染引擎 -&gt; 新版本的Chromium浏览器Google项目</p><h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h2><p>1)JScript引擎 –&gt; IE系列浏览器<br>2)spiderMonkey引擎 –&gt; Mozilla Firefox<br>3)V8引擎 –&gt; Google Chrome<br>4)linear b/futhark引擎 –&gt; Opera</p><h2 id="浏览器渲染引擎的进度史"><a href="#浏览器渲染引擎的进度史" class="headerlink" title="浏览器渲染引擎的进度史"></a>浏览器渲染引擎的进度史</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" alt="浏览器渲染引擎的进度史"><br>为大家提供两个开发常用查询网站：<br><a href="http://html5test.com/" target="_blank" rel="external">该浏览器对html5的支持程度</a><br><a href="https://caniuse.com" target="_blank" rel="external">不同与Can I use</a></p><h1 id="浏览器的渲染引擎及依赖模块分析"><a href="#浏览器的渲染引擎及依赖模块分析" class="headerlink" title="浏览器的渲染引擎及依赖模块分析"></a>浏览器的渲染引擎及依赖模块分析</h1><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%9F%E8%83%BD.png" alt="渲染引擎的功能"><br>上图中虚线部分表示渲染引擎所提供的功能。<br>这里渲染引擎包含了JavaScript引擎，许多时候两者都不太区分。<br>下面的内容大部分都是基于这张图来分析的，我们将逐步解释从用户输入URL到页面展示给用户这个过程中都发生了什么？<br>我们先了解网页的基础知识。</p><h1 id="网页基础知识"><a href="#网页基础知识" class="headerlink" title="网页基础知识"></a>网页基础知识</h1><p>html – 结构<br>css – 样式<br>JavaScript – 行为<br>还需要一些静态资源：png、gif、webp、MP4、font、svg等等。<br>由上面几部分就构成我们的网页。</p><h2 id="输入URL到页面展示简图"><a href="#输入URL到页面展示简图" class="headerlink" title="输入URL到页面展示简图"></a>输入URL到页面展示简图</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/url%E5%88%B0dom%E6%A0%91.png" alt="URL到页面展示"><br>读者不要太关心上图所标的顺序，在某些时候可能会有出入。</p><h2 id="浏览器内核各部分解释"><a href="#浏览器内核各部分解释" class="headerlink" title="浏览器内核各部分解释"></a>浏览器内核各部分解释</h2><blockquote><p>   HTML解释器：解释HTML文本的解释器，主要作用是将HTML文本解释成DOM树，DOM是一种文档表示方法。<br>CSS解释器：级联样式表的解释器，它的作用是为DOM中的各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。<br>布局：在DOM创建之后，webkit需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部比偶表示模型。<br>JavaScript引擎：使用JavaScript代码可以修改网页的内容，也能修改CSS的信息，JavaScript引擎能过解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染结果。<br>绘图：使用图形库将布局计算后的各个网页的节点绘制成图像结果。</p></blockquote><p>PS：这些模块依赖许多其他基础模块，其中包括网络、存储、2D/3D图形、音频视频和图片解码器等。这里就不对基础模块做相应说明了。</p><p>下面，我就逐个过程进行分析，我这里省略一些非本文目的的过程，如DNS环节。</p><h1 id="HTML解释器"><a href="#HTML解释器" class="headerlink" title="HTML解释器"></a>HTML解释器</h1><p>先来看看HTML解释器工作原理<br><img src="http://p4yvw0vpm.bkt.clouddn.com/html%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="HTML解释器工作原理"><br>字节流（Bytes）–&gt; 字符流（Characters）–&gt; 词语（Tokens）–&gt; 节点 –&gt; DOM树</p><blockquote><p>   首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），时候经过分析器构建成节点，最后这些节点被组建成一棵DOM树。<br>词法分析：HTMLTokenizer 类（作用是词法分析，类似于状态机），输入的是字符串，输出的是一个个的词语。<br>XSSAuditor验证词语：XSSAuditor （验证词语流Token Stream）XSS指的是Cross Site Security，主要是针对安全方面的考虑。<br>词语到节点：webkit用来构建DOM节点，这一步骤由HTMLDocumentParser 类调用 HTMLTreeBuilder 类的 constructTree的函数来实现。<br>节点到DOM树：树中的元素节点创建属性节点等工作由HTMLConstructionSite类来完成，该类中包含一个 HTMLElementStack 作为保存元素节点的栈。<br>JavaScript的执行：webkit将DOM树创建过程中需要执行得我Javascript代码交由HTMLScriptRunner类来负责。<br>DOM的事件机制：webkit中用EventTarget类来表示DOM规范中Events部分定义的事件目标，Node 节点继承自 EventTarget类，所以Node拥有EventTarget类的相关的方法。</p></blockquote><p>这里需要提一下W3C新规范，影子（Shadow）DOM<br>Shadow DOM API的 ShadowRoot接口是一个DOM子树的根节点, 它与文档的主DOM树分开渲染。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ShadowRoot" target="_blank" rel="external">MDN-影子节点</a></p><h2 id="影子（Shadow）DOM"><a href="#影子（Shadow）DOM" class="headerlink" title="影子（Shadow）DOM"></a>影子（Shadow）DOM</h2><p>定义：Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。<br>ShadowRoot 类继承自 DocumentFragment 类。<br>PS：可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.</p><h1 id="CSS解释器和样式布局"><a href="#CSS解释器和样式布局" class="headerlink" title="CSS解释器和样式布局"></a>CSS解释器和样式布局</h1><p>先看看CSS怎么和DOM结合展示页面的呢？<br><img src="http://p4yvw0vpm.bkt.clouddn.com/css%E5%92%8Cdom%E6%A0%91%E5%88%B0%E7%BB%98%E5%88%B6%E7%BD%91%E9%A1%B5.png" alt="CSS+DOM形成简单页面"><br>css解释器和规则匹配处于DOM树建立之后，RenderObject树建立之前，css解释器解释后的结果会保存起来，然后RenderObject树基于该结果来进行规范匹配和布局计算。</p><h2 id="CSSOM（CSS-Object-Model）"><a href="#CSSOM（CSS-Object-Model）" class="headerlink" title="CSSOM（CSS Object Model）"></a>CSSOM（CSS Object Model）</h2><p>CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动。<br>document.styleSheets 可以查看当前页面的StyleSheetList对象，每个link、style都会产生 CSSStyleSheet 作为 StyleSheetList对象的value。</p><h2 id="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"><a href="#CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）" class="headerlink" title="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"></a>CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）</h2><p>DocumentStyleSheetCollection类（属于Document类），该类包含了所有CSS样式表，还包括了webkit的内部表示类CSSStyleSheet，它包含了CSS的href、类型、内容等信息。<br>CSS解释过程：css字符串经过css解释器处理后变成渲染引擎的内部规则的过程，使用CSSParser类来负责该过程。<br>在解释网页中自定义的CSS样式之前，实际上webkit渲染引擎会为每个网页设置一个默认样式，这也是我们为什么要重置浏览器样式的根本原因。<br>规则匹配：StyleResolver类为DOM的元素节点匹配样式，StyleResolver类根据元素的信息，例如标签名、类别等，从样式规则中查找最匹配的规则，然后将样式信息保存到新建的RenderStyle对象中。最后，这些RenderStyle对象被RenderObject类所管理和使用。<br>    其中，规则的匹配则是由ElementRuleCollector类来计算并获得，它根据元素的属性等信息，并从DocumentRuleSets类中获取规则集合，依次按照ID、CLASS、标签等选择器信息逐次匹配获得元素的样式。<br>    然后webkit对这些规则进行排序，对于该元素需要的样式属性，webkit选择从高优先级规则中选取，并将样式属性值返回。<br>这里，我引入一个不太相关的知识点，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">不太了解的同学，请异步MDN-BFC</a></p><h1 id="webkit布局"><a href="#webkit布局" class="headerlink" title="webkit布局"></a>webkit布局</h1><p>当webkit创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息的过程称为布局计算/排版。<br>    布局计算分类：第一类是对整个RenderObject树进行的计算；第二类是对RenderObject树中某个子树的计算，常见于文本元素或者overflow：auto块的计算。<br>    布局计算：布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。</p><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>我们常说的reflow和repaint。涉及到元素的几何属性改变会造成reflow会降低性能（transform、opacity等属性不会造成reflow）。<br>扩展为什么说transform实现动画较直接设置几何属性性能较好？<br>1.webkit渲染过程：style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite，transform是位于’Composite（渲染层合并）‘，而width、left、margin等则是位于‘Layout（布局）’层，这必定导致reflow。<br>2.现代浏览器针对transform等开启GPU加速。<br>    style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite（transform发生在这个时候）<br>由这个过程我们可以看出，这也是为什么发生reflow必定会发生repaint的根本原因。<br><a href="https://www.w3cplus.com/animation/animation-performance.html" target="_blank" rel="external">CSS Animation性能优化</a><br><a href="https://segmentfault.com/a/1190000008650975" target="_blank" rel="external">从重绘重排角度讲解transform的动画性能</a></p><h1 id="渲染过程的一些理论"><a href="#渲染过程的一些理论" class="headerlink" title="渲染过程的一些理论"></a>渲染过程的一些理论</h1><p>RenderObject树同其他树（如RenderLayer树等），构成了webkit渲染的主要基础设施。</p><h2 id="RenderObject树（DOM树-gt-RenderObject树）"><a href="#RenderObject树（DOM树-gt-RenderObject树）" class="headerlink" title="RenderObject树（DOM树 -&gt; RenderObject树）"></a>RenderObject树（DOM树 -&gt; RenderObject树）</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/DOM%E5%88%B0RenderObject.png" alt="DOM到RenderObject"><br>一个RenderObject对象保存了为绘制DOM节点所需要的各种信息，例如样式布局信息，经过webkit的处理之后，RenderObject对象知道如何绘制自己。<br>下列情况会使DOM树节点创建一个RenderObject对象（DOM和RenderObject并非一一对应）。<br>1.DOM树的document节点。<br>2.DOM树种的可视节点，例如html、body、div等。而webkit不会为非可视化节点创建RenderObject节点，例如meta、script。<br>3.某些情况下webkit需要建立匿名的RenderObject节点，该节点不对应于DOM树种的任何节点，而是webkit处理上的需要，典型的例子例如匿名的RenderBlock节点。<br>在html组建页面结构时，webkit为了提升网页性能，会引入分层结构。</p><h2 id="网页层次结构（css也会对网页的分层策略产生重要影响）"><a href="#网页层次结构（css也会对网页的分层策略产生重要影响）" class="headerlink" title="网页层次结构（css也会对网页的分层策略产生重要影响）"></a>网页层次结构（css也会对网页的分层策略产生重要影响）</h2><p>对于一个html文件webkit会为某些元素和它的子节点建立新层，这样webkit可以单独对某层操作提升性能，下列情况会产生新层。<br>1.video标签 – webkit在新层中有效的处理视频解码器和浏览器之间的交互和渲染问题。<br>2.div、p等普通标签 – 涉及到3D变换时。<br>3.canvas标签 – 复杂的2D和3D绘图操作。</p><h2 id="RenderLayer树"><a href="#RenderLayer树" class="headerlink" title="RenderLayer树"></a>RenderLayer树</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/RenderObject%E5%88%B0RenderLayer.png" alt="RenderObject到RenderLayer"><br>webkit会为网页的层次创建相应的RenderLayer对象。当某些类型RenderObject的节点或者某些css样式的RenderObject节点出现的时候，webkit就会为这些节点创建RenderLayer对象。<br>RenderLayer树是基于RenderObject树建立起来的一棵新树。RenderLayer节点和RenderObject节点不是一一对应关系，而是一对多的关系。<br>哪些情况下的RenderObject节点需要建立新的RenderLayer节点呢？<br>1.DOM树的Document节点对应的RenderView节点。<br>2.DOM树中的Document的子节点，也就是HTML节点对应RenderBlock节点。<br>3.显式的制定css位置的RenderObject节点。<br>4.有透明效果的RenderObject节点。<br>5.节点有溢出（overflow）、alpha或者反射效果的RenderObject节点。<br>6.使用Canvas 2D和3D（WebGL）技术的RenderObject节点。<br>7.Video节点对应的RenderObject节点。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><p>绘图上下文（绘图上下文可以分成两种类型）：<br>    第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）。<br>    第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）。<br>网页的三种渲染方式：<br>1.软件渲染（CPU内存）<br>2.使用软件绘图的合成化渲染（GPU内存）css3D、WebGL<br>3.硬件加速的合成化渲染（GPU内存）</p><h2 id="webkit软件渲染技术"><a href="#webkit软件渲染技术" class="headerlink" title="webkit软件渲染技术"></a>webkit软件渲染技术</h2><p>在不需要硬件加速内容的时候（包括但不限于css3 3D变形、css3 3D变换、WebGL和视频），webkit就可以使用软件渲染技术来完成页面绘制。<br>对于每个RenderObject对象，需要三个阶段绘制自己：<br>第一阶段是绘制该层中所有块的背景和边框。<br>第二阶段是绘制浮动内容。<br>第三阶段是前景（Foreground），也就是内容部分、轮廓、字体颜色、大小等（内嵌元素的背景、边框等发生在这一阶段）。</p><h2 id="硬件加速机制"><a href="#硬件加速机制" class="headerlink" title="硬件加速机制"></a>硬件加速机制</h2><p>硬件加速技术是指使用GPU的硬件能力来帮助渲染网页（GPU的作用主要是用来绘制3D图形并且性能特别好）。</p><h3 id="Chrome的硬件加速机制"><a href="#Chrome的硬件加速机制" class="headerlink" title="Chrome的硬件加速机制"></a>Chrome的硬件加速机制</h3><p>canvas开发，可以将画布分解为更小的画布，这样在更新时只需要更新小画布从而减少开销。<br>css3 3D变形技术，它能过让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果（只触发Composite而不用触发style -&gt; Layout(reflow发生在这) -&gt; Paint）。</p><h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><p>WebGL是Khronous组织提出的一套基于3D图形定义的javascript接口。<br>它基于canvas元素，跟canvas2D不同的是，Web开发者可以使用3D图形接口来绘制各种3D图形。</p><h3 id="css-3D变形"><a href="#css-3D变形" class="headerlink" title="css 3D变形"></a>css 3D变形</h3><p>这里包括3D变形和动画。<br>webkit会建立一个新层来处理，从而提升性能。</p><h1 id="JavaScript引擎-1"><a href="#JavaScript引擎-1" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h1><p>推动JavaScript运行速度提高的利器JIT（Just-In-Time）。<br>JIT：就是代码在目标平台上运行的时候，实时的把代码编译为目标机器上的机器码。<br>编译原理：<br>C++：源代码 –&gt; 抽象语法树 –&gt; 本地代码<br>Java：源代码 –&gt; 抽象语法树  –&gt; 字节码（跨平台） –&gt; JIT –&gt; 本地代码</p><h2 id="V8的一些特性（这里太多了，读者可以自己深究）"><a href="#V8的一些特性（这里太多了，读者可以自己深究）" class="headerlink" title="V8的一些特性（这里太多了，读者可以自己深究）"></a>V8的一些特性（这里太多了，读者可以自己深究）</h2><p>常用的javascript引擎有v8和JavaScriptCore<br>工作原理<br>在js中，基本数据类型Boolean、Number、String、Null、Undefined、Symbol，其他数据都是对象。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>在V8中，数据的表示分成两个部分<br>    第一部分是数据的实际内容，它们是变长的，而且内容的类型也不一样，如String、对象等。<br>    第二部分是数据的句柄，句柄的大小是固定的，句柄中包含指向数据的指针。</p><h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>Handle：句柄类，主要用来管理基础数据和对象，以便被垃圾回收器操作。<br>主要有两个类型，一个Local类（继承自Handle类），表示本地栈上的数据，所以比较轻量。<br>另一个是Persistent类（继承自Handle类）表示函数间的数据和对象访问。<br>对于整形数据，由Handle本身来存储，同时也为了快速访问。<br>其他的数据都是从堆中申请内存来存储它们，由于其他数据类型，受限于Handle的大小和变长等原因，都存储在堆中。<br>V8的延迟（deferred）特性：它使的许多javascript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销。<br><img src="http://p4yvw0vpm.bkt.clouddn.com/javascript%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81.png" alt="v8将源代码-本地代码"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="常见的语言类型"><a href="#常见的语言类型" class="headerlink" title="常见的语言类型"></a>常见的语言类型</h3><p>机器语言（它是计算机唯一能直接执行的语言，电子计算机的机器指令是一列二进制数字。）<br>汇编语言 汇编指令是机器指令便于记忆的书写格式，但他需要进过编译器转换为机器语言，这样机器才能执行。</p><h3 id="使用setTimeout或setInterval较requestAnimationFrame的缺点？"><a href="#使用setTimeout或setInterval较requestAnimationFrame的缺点？" class="headerlink" title="使用setTimeout或setInterval较requestAnimationFrame的缺点？"></a>使用setTimeout或setInterval较requestAnimationFrame的缺点？</h3><p>时间间隔应该设置为多少才合适呢。<br>跟屏幕的分辨率有关吗（不同浏览器存在一个极小值）。<br>设置的时间会按照会准确执行吗。<br>动画会被平滑地显示效果吗。<br>回调函数时复杂的好还是简单的好呢。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame</a></p><h1 id="其他浏览器相关知识"><a href="#其他浏览器相关知识" class="headerlink" title="其他浏览器相关知识"></a>其他浏览器相关知识</h1><h2 id="插件和Javascript扩展"><a href="#插件和Javascript扩展" class="headerlink" title="插件和Javascript扩展"></a>插件和Javascript扩展</h2><p>在早期的浏览器能力十分有限，Web前端开发者们希望能够通过一些机制来扩展浏览器的能力（插件机制如flash插件）。</p><h3 id="NPAPI全称叫-Netscape-plugin-API"><a href="#NPAPI全称叫-Netscape-plugin-API" class="headerlink" title="NPAPI全称叫 Netscape plugin API"></a>NPAPI全称叫 Netscape plugin API</h3><p>NPAPI是当今最流行的插件架构，几乎所有浏览器都支持，不过存在很大的安全隐患，插件可以窃取系统底层权限，发起恶意攻击。</p><h3 id="PPAPI也就是Pepper-Plugin-API"><a href="#PPAPI也就是Pepper-Plugin-API" class="headerlink" title="PPAPI也就是Pepper Plugin API"></a>PPAPI也就是Pepper Plugin API</h3><p>2010年，Google开发了新的PPAPI，将外挂插件全部放到沙盒里运行，2012年Windows、Mac版本的Chrome浏览器先后升级了PPAPI Flash Player，并希望今年底之前彻底淘汰NPAPI。</p><h2 id="JavaScript引擎的扩展机制"><a href="#JavaScript引擎的扩展机制" class="headerlink" title="JavaScript引擎的扩展机制"></a>JavaScript引擎的扩展机制</h2><p>通过如下url参看当前chrome浏览器安装的extensions<br>chrome://extensions/ </p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><p>WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="external">MDN-WebRTC</a><br>最重要的方法：navigator.mediaDevices.getUserMedia(constraints)<br>还有Video、Audio等。</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><p>第一部分是网页的安全，包括但是不限于网页数据安全传输、跨域访问、用户数据安全等。<br>第二部分是浏览器的安全，具体是指虽然网页或者Javascript代码有一些安全问题或者存在安全漏洞，浏览器也能够在运行它们的时候保证吱声的安全，不受到攻击从而泄漏数据或者使系统遭受破坏。</p><h3 id="网页安全模型"><a href="#网页安全模型" class="headerlink" title="网页安全模型"></a>网页安全模型</h3><p>安全模型基础：<br>域（Same Origin Policy）XMLHttpRequest、cookie的读写、DOM对象操作等。<br>XSS（Cross Site Scripting）执行跨域的js脚本代码。开发者可以将用户输入的数据进行字符转换来避免。webkit通过XSSAuditor对象帮我们过滤（默认开启）。<br>CSP （Content-Security-Policy）HTTP首部字段，内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。<br>CORS（Cross Origin Resource Sharing）跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。<br>    具体服务端代码设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 请求头</div><div class="line">header(&apos;Access-Control-Allow-Origin: http://arunranga.com&apos;); // </div><div class="line">header(&apos;Access-Control-Allow-Methods: POST, GET, OPTIONS&apos;);</div><div class="line">header(&apos;Access-Control-Allow-Headers: X-PINGARUNER&apos;);</div><div class="line">// 响应头</div><div class="line">Access-Control-Allow-Origin、</div><div class="line">Access-Control-Allow-Credentials、</div><div class="line">Access-Control-Allow-Headers、</div><div class="line">Access-Control-Expose-Headers、</div><div class="line">Access-Control-Allow-Methods、</div><div class="line">Access-Control-Max-Age</div></pre></td></tr></table></figure></p><p>Cross Document Messaging 通过 window.postMessage 和 message 事件来通信。<br>HTTPS（安全传输协议）<br>SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。    SPDY核心思想为多路复用。<br>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。</p><h4 id="CSP和CORS的区别："><a href="#CSP和CORS的区别：" class="headerlink" title="CSP和CORS的区别："></a>CSP和CORS的区别：</h4><p>CSP定义了网页自身能够访问的某些域和资源。<br>CORS定义一个网页如何才能访问被同源策略禁止的跨域资源，并规定了两者交互的协议和方式。</p><h3 id="沙箱模型"><a href="#沙箱模型" class="headerlink" title="沙箱模型"></a>沙箱模型</h3><p>浏览器的沙箱模型是利用系统提供的安全技术，让网页在执行过程中不会修改操作系统或者是访问系统中的隐私数据，而需要访问系统资源或者说是系统调用的时候，通过一个代理机制来完成。</p><h1 id="chrome浏览其使用技巧（以实用性排列）"><a href="#chrome浏览其使用技巧（以实用性排列）" class="headerlink" title="chrome浏览其使用技巧（以实用性排列）"></a>chrome浏览其使用技巧（以实用性排列）</h1><p>一下url直接输入在浏览器中，enter即可</p><table><thead><tr><th>URL</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>chrome://inspect</td><td style="text-align:center">移动端网页调试</td></tr><tr><td>chrome://net-internals</td><td style="text-align:center">net-internals是一套工具集合，用于帮助诊断网络请求与访问方面的问题，它通过监听和搜集 DNS，Sockets，SPDY，Caches等事件与数据来向开发者反馈各种网络请求的过程、状态以及可能产生影响的因素。如，查看DNS主机解析缓存chrome://net-internals/#dns</td></tr><tr><td>chrome://view-http-cache/</td><td style="text-align:center">查看内部存储内容及其详情</td></tr><tr><td>chrome://downloads/</td><td style="text-align:center">下载内容管理，其快捷键是Ctrl+J</td></tr><tr><td>chrome://extensions/</td><td style="text-align:center">扩展管理</td></tr><tr><td>chrome://bookmarks/</td><td style="text-align:center">书签管理  </td></tr><tr><td>chrome://history</td><td style="text-align:center">访问历史管理  </td></tr><tr><td>chrome://restart</td><td style="text-align:center">重启chrome浏览器 </td></tr><tr><td>chrome://apps</td><td style="text-align:center">chrome网上应用店  </td></tr><tr><td>chrome://flags/</td><td style="text-align:center">新特性管理 </td></tr><tr><td>chrome://dns</td><td style="text-align:center">查看DNS预取命名（从超链接等处来预测）  </td></tr><tr><td>chrome://quota-internals</td><td style="text-align:center">查看浏览器所使用磁盘空间配额 </td></tr><tr><td>chrome://settings</td><td style="text-align:center">浏览器的设置</td></tr><tr><td>chrome://sync-internals</td><td style="text-align:center">查看chrome 的同步状态 </td></tr><tr><td>chrome://about/</td><td style="text-align:center">查看所有chrome命令 </td></tr></tbody></table><p><a href="https://fanerge.github.io">期望加入一个技术氛围nice的团队-成都</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。&lt;br&gt;主要查阅了&lt;a href=&quot;https://book.douban.com/subject/25
      
    
    </summary>
    
      <category term="webkit" scheme="https://fanerge.github.io/categories/webkit/"/>
    
    
      <category term="浏览器" scheme="https://fanerge.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj</title>
    <link href="https://fanerge.github.io/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj.html"/>
    <id>https://fanerge.github.io/2018/前端常识-gj.html</id>
    <published>2018-02-09T12:36:22.000Z</published>
    <updated>2018-05-06T02:55:50.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-virtualDOM（batching）"><a href="#React-virtualDOM（batching）" class="headerlink" title="React virtualDOM（batching）"></a>React virtualDOM（batching）</h2><p>在React中，render执行的结果返回的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。<br>通过 React 的 diff，再由虚拟 DOM 来确保只对界面上真正变化的部分进行实际的DOM操作，这样就极大提升了性能。<br>batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。</p><blockquote><p>DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起30次（潜在的）布局重算，30次（潜在的）重绘。<br>当你在这个单独的 virtualDOM 树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。<br>一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。</p></blockquote><p><a href="https://www.jianshu.com/p/f75c1f0af3f0" target="_blank" rel="external">React中一个没人能解释清楚的问题——为什么要使用Virtual DOM</a></p><h2 id="React-diff"><a href="#React-diff" class="headerlink" title="React diff"></a>React diff</h2><p>React diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础。<br>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。<br>React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。<br>diff 策略（—为具体比对）<br>1.Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 — tree diff<br>2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 — component diff<br>3.对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 — element diff</p><h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%85.jpg" alt="tree-diff"></p><h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。<br>1.如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。<br>2.如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。<br>3.对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%851.jpg" alt="component diff"></p><h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。<br>1.INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。<br>2.MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。<br>3.REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。<br>React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，这也是为什么React建议我们在列表项目中添加key属性的原因！</p><p><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%852.jpg" alt="element diff"><br><a href="https://zhuanlan.zhihu.com/purerender/20346379" target="_blank" rel="external">知乎专栏-react diff，写的很不错</a></p><h2 id="webkit-渲染机制"><a href="#webkit-渲染机制" class="headerlink" title="webkit 渲染机制"></a>webkit 渲染机制</h2><p>先看下简单版的（我们从浏览器地址栏输入网址开始到web页面被完整的呈现在眼前做了哪些事，暂不考虑DNS缓存、本地资源缓存）<br>网址被DNS解析为IP地址 -&gt; 通过IP地址建立TCP连接 -&gt; 发送HTTP请求 -&gt; 服务器处理请求并返回响应 -&gt;  浏览器解析渲染页面 -&gt; 断开TCP连接</p><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>一般渲染引擎主要包括HTML解释器、CSS解释器、Javascript引擎、布局、绘图等模块。<br>HTML解释器 ：HTML解释器的工作就是将网络或者本地磁盘获取到的HTML网页和资源从字节流解释成DOM树的结构（首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（TOKENS），经过语法分析器构建成节点，最后这些节点被组建成一颗DOM树）<br>CSS解释器 ：CSS字符串被CSS解释器处理后变成渲染引擎的内部规则表示。（样式规则建立完成之后，webkit会保存规则结果，当DOM的节点建立之后，webkit会为可视化节点选择合适的样式信息，即作样式规则匹配）<br>Javascript引擎 ：将Javascript代码处理并执行，一个Javascript引擎可以包括以下几个部分<br>　　编译器 -&gt; 主要工作是将源代码编译成抽象语法树，在某些引擎中还包括将抽象语法树转换为字节码（JavascriptCore 引擎）。<br>　　解释器  -&gt; 在某些引擎中，解释器主要是接收字节码，解释执行字节码，同时也依赖垃圾回收机制等。<br>　　JIT工具 -&gt; 将字节码或者抽象语法树转换为本地代码 （V8 引擎）。<br>　　垃圾回收器和分析工具。<br>布局 ：计算RenderObject对象的位置、大小等信息。<br>绘图 ：将构建好的渲染内部表示模型使用图形库绘制出来。<br><img src="http://p26lefllv.bkt.clouddn.com/webkitflow.png" alt="webkit渲染过程"><br><a href="http://www.sohu.com/a/115715208_472885" target="_blank" rel="external">WEBKIT渲染不可不知的这四棵树</a><br><a href="https://www.cnblogs.com/tianheila/p/6413586.html" target="_blank" rel="external">webkit 渲染机制</a></p><h2 id="http1-1-amp-2较1有哪些新东西？"><a href="#http1-1-amp-2较1有哪些新东西？" class="headerlink" title="http1.1&amp;2较1有哪些新东西？"></a>http1.1&amp;2较1有哪些新东西？</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p><h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p><h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</p><h2 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h2><p>1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可<br>2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页<br>3.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br>4.重要内容不要用js输出：爬虫不会执行js获取内容（目前chrome浏览器可以了）<br>5.少用iframe：搜索引擎不会抓取iframe中的内容<br>6.非装饰性图片必须加alt<br>7.提高网站速度：网站速度是搜索引擎排序的一个重要指标</p><h2 id="点击穿透"><a href="#点击穿透" class="headerlink" title="点击穿透"></a>点击穿透</h2><p>如何产生：<br>    现在有两层DOM结构（但不嵌套），底层和弹出层（底层在弹出层下面且弹出层的投影在底层内部），弹出层有一个 touchend 事件，底层有一个 click 事件。<br>当点击弹出层就会触发 touchend 事件（弹出层立即消失，这时事件的 target 为弹出层），300ms后触发 click 事件（由于弹出层消失了，这时事件的 target 就为底层了）。<br>看出来了吗？这样就发生了‘点击穿透’。<br>产生的原因：<br>    click事件延迟且弹出层消失了。<br>解决方案：<br>    1.只用touch事件<br>    2.只用click事件（不推荐只用click事件，这样所有点击都有延迟了，实在要使用可以使用事件库 fastclick）<br>    3.可以延迟（&gt;300ms,好像不太科学）弹出层消失<br><a href="http://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="服务器’推‘技术"><a href="#服务器’推‘技术" class="headerlink" title="服务器’推‘技术"></a>服务器’推‘技术</h2><p>webSocket、Comet、轮询<br>Comet主要是利用客户端向服务器发出请求时，服务器发回响应内容，并利用javascript建立一个长时间链接的“长连接”，这个连接在没有接收到服务器或者没有到达连接时间限制时会一直等待服务器的消息，如果服务器有消息传来，立即显示最新信息。长连接每隔一段时间会重新向服务器发出连接请求。服务器在有新消息产生的时候立即检查消息的接收方是否存在长连接，如果存在马上发送，如果没有则不发送。</p><h2 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h2><p>1.cookie（一般不能存关键字段，最好存sessionID配合session使用）<br>2.session<br>3.url重写<br>4.隐藏input<br>5.ip地址</p><h2 id="img的title和alt有什么区别"><a href="#img的title和alt有什么区别" class="headerlink" title="img的title和alt有什么区别"></a>img的title和alt有什么区别</h2><p>title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。<br>alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p><h2 id="doctype是什么-举例常见doctype及特点"><a href="#doctype是什么-举例常见doctype及特点" class="headerlink" title="doctype是什么,举例常见doctype及特点"></a>doctype是什么,举例常见doctype及特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写</div><div class="line">&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</div><div class="line">现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</div><div class="line">在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</div><div class="line">HTML5不基于SGML，所以不用指定DTD</div></pre></td></tr></table></figure><h3 id="常见dotype"><a href="#常见dotype" class="headerlink" title="常见dotype"></a>常见dotype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</div><div class="line">HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">HTML4.01 Frameset:允许表现性元素，废弃元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</div><div class="line">XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</div><div class="line">XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</div><div class="line">HTML 5: &lt;!doctype html&gt;</div></pre></td></tr></table></figure><h2 id="HTML全局属性-global-attribute-有哪些"><a href="#HTML全局属性-global-attribute-有哪些" class="headerlink" title="HTML全局属性(global attribute)有哪些"></a>HTML全局属性(global attribute)有哪些</h2><p>accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素<br>class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class、classList属性获取元素<br>contenteditable: 指定元素内容是否可编辑<br>contextmenu: 自定义鼠标右键弹出菜单内容<br>data-*: 为元素增加自定义属性<br>dir: 设置元素文本方向<br>draggable: 设置元素是否可拖拽<br>dropzone: 设置元素拖放类型： copy, move, link<br>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果<br>id: 元素id，文档内唯一<br>lang: 元素内容的的语言<br>spellcheck: 是否启动拼写和语法检查<br>style: 行内css样式<br>tabindex: 设置元素可以获得焦点，通过tab可以导航<br>title: 元素相关的建议信息<br>translate: 元素和子孙节点内容是否需要本地化</p><h2 id="什么是web语义化-有什么好处"><a href="#什么是web语义化-有什么好处" class="headerlink" title="什么是web语义化,有什么好处"></a>什么是web语义化,有什么好处</h2><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。<br>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构<br>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息<br>为什么需要语义化：<br>1.去掉样式后页面呈现清晰的结构<br>2.搜索引擎更好地理解页面，有利于收录<br>3.便团队项目的可持续运作及维护<br>5.盲人使用读屏器更好地阅读</p><h2 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。<br>GET是最常用的方法，通常用于请求服务器发送某个资源。<br>HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分<br>PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它<br>POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。<br>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。<br>OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。<br>DELETE请求服务器删除请求URL指定的资源。</p><h2 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h2><p>首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF<br>首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束<br>请求头和消息实体之间有一个CRLF分隔<br>根据实际请求需要可能包含一个消息实体<br>一个请求报文例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</div><div class="line">Host: www.w3.org</div><div class="line">Connection: keep-alive</div><div class="line">Cache-Control: max-age=0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</div><div class="line">Referer: https://www.google.com.hk/</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</div><div class="line">Cookie: authorstyle=yes</div><div class="line">If-None-Match: &quot;2cc8-3e3073913b100&quot;</div><div class="line">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</div><div class="line"></div><div class="line">name=fanerge&amp;age=26</div></pre></td></tr></table></figure></p><h2 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h2><p>首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF<br>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部<br>响应头部和响应实体之间用一个CRLF空行分隔<br>最后是一个可能的消息实体<br>响应报文例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 08 Jul 2014 05:28:43 GMT</div><div class="line">Server: Apache/2</div><div class="line">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</div><div class="line">ETag: &quot;40d7-3e3073913b100&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: 16599</div><div class="line">Cache-Control: max-age=21600</div><div class="line">Expires: Tue, 08 Jul 2014 11:28:43 GMT</div><div class="line">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</div><div class="line">Content-Type: text/html; charset=iso-8859-1</div><div class="line"></div><div class="line">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</div></pre></td></tr></table></figure></p><h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><h3 id="content方面"><a href="#content方面" class="headerlink" title="content方面"></a>content方面</h3><p>减少HTTP请求：合并文件、CSS精灵、inline Image<br>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br>避免重定向：多余的中间访问<br>使Ajax可缓存<br>非必须组件延迟加载<br>未来所需组件预加载<br>减少DOM元素数量<br>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br>减少iframe数量<br>不要404</p><h3 id="Server方面"><a href="#Server方面" class="headerlink" title="Server方面"></a>Server方面</h3><p>使用CDN<br>添加Expires或者Cache-Control响应头<br>对组件使用Gzip压缩<br>配置ETag<br>Flush Buffer Early<br>Ajax使用GET进行请求<br>避免空src的img标签</p><h3 id="Cookie方面"><a href="#Cookie方面" class="headerlink" title="Cookie方面"></a>Cookie方面</h3><p>减小cookie大小<br>引入资源的域名不要包含cookie</p><h3 id="css方面"><a href="#css方面" class="headerlink" title="css方面"></a>css方面</h3><p>将样式表放到页面顶部<br>不使用CSS表达式<br>使用不使用@import<br>不使用IE的Filter</p><h3 id="Javascript方面"><a href="#Javascript方面" class="headerlink" title="Javascript方面"></a>Javascript方面</h3><p>将脚本放到页面底部<br>将javascript和css从外部引入<br>压缩javascript和css<br>删除不需要的脚本<br>减少DOM访问<br>合理设计事件监听器</p><h3 id="图片方面"><a href="#图片方面" class="headerlink" title="图片方面"></a>图片方面</h3><p>优化图片：根据实际颜色需要选择色深、压缩<br>优化css精灵<br>不要在HTML中拉伸图片<br>保证favicon.ico小并且可缓存</p><h3 id="移动方面"><a href="#移动方面" class="headerlink" title="移动方面"></a>移动方面</h3><p>保证组件小于25k<br>Pack Components into a Multipart Document<br><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">yahoo Best Practices for Speeding Up Your Web Site</a></p><h2 id="什么是渐进增强"><a href="#什么是渐进增强" class="headerlink" title="什么是渐进增强"></a>什么是渐进增强</h2><p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。<br>核心原则如下:<br>所有浏览器都必须能访问基本内容<br>所有浏览器都必须能使用基本功能<br>所有内容都包含在语义化标签中<br>通过外部CSS提供增强的布局<br>通过非侵入式、外部javascript提供增强功能<br>end-user web browser preferences are respected</p><h2 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h2><p>1XX：信息状态码<br>100 Continue：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求之后向客户端发送一个最终响应。<br>101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。<br>2XX：成功状态码<br>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回<br>201 Created：<br>202 Accepted：<br>203 Non-Authoritative Information：<br>204 No Content：<br>205 Reset Content：<br>206 Partial Content：<br>3XX：重定向<br>300 Multiple Choices：<br>301 Moved Permanently：<br>302 Found：<br>303 See Other：<br>304 Not Modified：<br>305 Use Proxy：<br>306 （unused）：<br>307 Temporary Redirect：<br>4XX：客户端错误<br>400 Bad Request:<br>401 Unauthorized:<br>402 Payment Required:<br>403 Forbidden:<br>404 Not Found:<br>405 Method Not Allowed:<br>406 Not Acceptable:<br>407 Proxy Authentication Required:<br>408 Request Timeout:<br>409 Conflict:<br>410 Gone:<br>411 Length Required:<br>412 Precondition Failed:<br>413 Request Entity Too Large:<br>414 Request-URI Too Long:<br>415 Unsupported Media Type:<br>416 Requested Range Not Satisfiable:<br>417 Expectation Failed:<br>5XX: 服务器错误<br>500 Internal Server Error:<br>501 Not Implemented:<br>502 Bad Gateway:<br>503 Service Unavailable:<br>504 Gateway Timeout:<br>505 HTTP Version Not Supported:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-virtualDOM（batching）&quot;&gt;&lt;a href=&quot;#React-virtualDOM（batching）&quot; class=&quot;headerlink&quot; title=&quot;React virtualDOM（batching）&quot;&gt;&lt;/a&gt;React vi
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>IndexDB探索之路</title>
    <link href="https://fanerge.github.io/2018/html5-IndexDB.html"/>
    <id>https://fanerge.github.io/2018/html5-IndexDB.html</id>
    <published>2018-02-06T12:20:04.000Z</published>
    <updated>2018-03-17T12:34:15.757Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/indexedDB/static/">demo地址</a></p><h1 id="什么是-IndexDB？"><a href="#什么是-IndexDB？" class="headerlink" title="什么是 IndexDB？"></a>什么是 IndexDB？</h1><p>IndexedDB 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供索引功能以实现高性能查找. 像其他基于 SQL 的 关系型数据库管理系统 (RDBMS) 一样, IndexedDB 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的.</p><h2 id="IndexDB-的特点"><a href="#IndexDB-的特点" class="headerlink" title="IndexDB 的特点"></a>IndexDB 的特点</h2><p>IndexDB 和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。<br>IndexDB API包含异步(asynchronous) API 和同步(synchronous)API两种。  异步API适合大多数情况, 同步API必须同 WebWorkers一同使用.</p><h2 id="为什么我们要使用-IndexDB？"><a href="#为什么我们要使用-IndexDB？" class="headerlink" title="为什么我们要使用 IndexDB？"></a>为什么我们要使用 IndexDB？</h2><p>WebStorage在浏览器中有大小限制，存放较大的数据就不能满足了。<br>IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql.<br>IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）.</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IndexedDB-数据库使用key-value键值对储存数据"><a href="#IndexedDB-数据库使用key-value键值对储存数据" class="headerlink" title="IndexedDB 数据库使用key-value键值对储存数据"></a>IndexedDB 数据库使用key-value键值对储存数据</h2><p>key可以是二进制对象。<br>values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。<br>你可以对对象的某个属性创建索引（index）以实现快速查询和列举排序。</p><h2 id="IndexedDB-是事务模式的数据库"><a href="#IndexedDB-是事务模式的数据库" class="headerlink" title="IndexedDB 是事务模式的数据库"></a>IndexedDB 是事务模式的数据库</h2><p>任何操作都发生在事务(transaction)中。<br>IndexedDB API提供了索引(indexes), 表(tables), 指针(cursors)等等,<br>但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。<br>当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。<br>如果没有事务操作的支持，这两个实例就会互相影响对方的修改。</p><h2 id="IndexedDB-API-基本上是异步的"><a href="#IndexedDB-API-基本上是异步的" class="headerlink" title="IndexedDB API 基本上是异步的"></a>IndexedDB API 基本上是异步的</h2><p>IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。<br>执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。<br>当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。<br>类似于XMLHttpRequest。</p><h2 id="IndexedDB数据库“请求”无处不在"><a href="#IndexedDB数据库“请求”无处不在" class="headerlink" title="IndexedDB数据库“请求”无处不在"></a>IndexedDB数据库“请求”无处不在</h2><p>数据库“请求”负责接受成功或失败的DOM事件。<br>每一个“请求”都包含onsuccess和onerror事件属性，同时你还对“事件”调用addEventListener()和removeEventListener()。<br>“请求”还包括readyState，result和errorCode属性，用来表示“请求”的状态。<br>result属性尤其神奇，他可以根据“请求”生成的方式变成不同的东西，例如：IDBCursor实例、刚插入数据库的数值对应的键值（key）等。</p><h2 id="IndexedDB在结果准备好之后通过DOM事件通知用户"><a href="#IndexedDB在结果准备好之后通过DOM事件通知用户" class="headerlink" title="IndexedDB在结果准备好之后通过DOM事件通知用户"></a>IndexedDB在结果准备好之后通过DOM事件通知用户</h2><p>DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。<br>DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。<br>成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。<br>这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。</p><h2 id="IndexedDB是面向对象的"><a href="#IndexedDB是面向对象的" class="headerlink" title="IndexedDB是面向对象的"></a>IndexedDB是面向对象的</h2><p>indexedDB不是用二维表来表示集合的关系型数据库。这一点非常重要，将影响你设计和建立你的应用程序。​​​​<br>传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象存储(object Store)，只要这种数据一个JavaScript对象即可。<br>每个对象存储都有一个索引(index)集合以方便查询和迭代遍历。</p><h2 id="indexedDB不使用结构化查询语言（SQL）"><a href="#indexedDB不使用结构化查询语言（SQL）" class="headerlink" title="indexedDB不使用结构化查询语言（SQL）"></a>indexedDB不使用结构化查询语言（SQL）</h2><p>它通过索引(index)所产生的指针(cursor)来完成查询操作，从而使你可以迭代遍历到结果集合。</p><h2 id="IndexedDB遵循同源（same-origin）策略"><a href="#IndexedDB遵循同源（same-origin）策略" class="headerlink" title="IndexedDB遵循同源（same-origin）策略"></a>IndexedDB遵循同源（same-origin）策略</h2><p>“源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。<br>在同一个“源”内的所有数据库都有唯一、可区别的名称。</p><h1 id="使用-IndexedDB"><a href="#使用-IndexedDB" class="headerlink" title="使用 IndexedDB"></a>使用 IndexedDB</h1><h2 id="检测浏览器支持情况"><a href="#检测浏览器支持情况" class="headerlink" title="检测浏览器支持情况"></a>检测浏览器支持情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (window.indexedDB) &#123;</div><div class="line">// todo</div><div class="line">&#125; else &#123;</div><div class="line">alert(&apos;您的浏览器不支持indexdb&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我将会以demo来做常用的数据库操作说明，使用火狐浏览器做测试。</p><h2 id="新建数据库-关闭数据库"><a href="#新建数据库-关闭数据库" class="headerlink" title="新建数据库/关闭数据库"></a>新建数据库/关闭数据库</h2><p>indexedDB 有一个open(indexDbName[, version])，这个方法会打开某个数据库，若不存在则新建。<br>第一个参数为数据库名称 ‘demo’，第二个参数为 版本号。<br>db为打开数据库成功回掉 event.target.result 戴白哦数据库实例，有 close() 为关闭该数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function createDatabase(indexDbName) &#123;</div><div class="line"></div><div class="line">// 不存在则新建，存在则打开</div><div class="line">let openRequest = indexedDB.open(indexDbName);</div><div class="line"></div><div class="line">openRequest.onerror = function(event) &#123;</div><div class="line">        console.log(&quot;Database error: &quot; + event.target.errorCode);</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">console.log(&quot;Database created&quot;);</div><div class="line">let db = event.target.result;</div><div class="line">// db.close();</div><div class="line">console.log(&quot;this is :&quot;+db);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//更改数据库，或者存储对象时候在这里处理</div><div class="line">openRequest.onupgradeneeded = function (e) &#123;</div><div class="line">console.log(e);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBIns.png" alt="新建数据库"></p><h2 id="确定数据结构并添加数据"><a href="#确定数据结构并添加数据" class="headerlink" title="确定数据结构并添加数据"></a>确定数据结构并添加数据</h2><p>onupgradeneeded 唯一可以修改数据库结构的地方。<br>在 indexedDB 中一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。<br>创建 objectStore 的方法为数据库实例的 createObjectStore(name[, options]);<br>删除 objectStore 的方法为数据库实例的 deleteObjectStore(name);<br>其中options 有两个可选key，分别是 keyPath（选择objectStore中某个指定字段作为键值）、autoIncrement（若为true，objectStore有一个key generator）<br>我们创建好的 objectStore 也有一些方法：<br>createIndex(indexName, keyPath[, objectParameters]) 该方法作用为创建一个索引来通过 indexName 搜索 objectStore 里的数据。<br>objectStore.add(value[, key]) 该方法作用为将数据添加到 objectStore 中。<br>介绍了相关的方法，我们就通过循环来向 objectStore 添加数据。<br>下面是具体实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function insertData(indexDbName)&#123;</div><div class="line">// 带写入的数据</div><div class="line">const customerData = [</div><div class="line">  &#123; ssn: &quot;444-44-4444&quot;, name: &quot;Bill&quot;, age: 35, email: &quot;bill@company.com&quot; &#125;,</div><div class="line">  &#123; ssn: &quot;555-55-5555&quot;, name: &quot;Donna&quot;, age: 32, email: &quot;donna@home.org&quot; &#125;</div><div class="line">];</div><div class="line"></div><div class="line">// 如果在没有新建数据库时写入数据，这里只能带高版本的数据库版本才能出发 onupgradeneeded 事件</div><div class="line">let openRequest = indexedDB.open(indexDbName, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">console.log(&quot;Database created&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onupgradeneeded = function(event) &#123;</div><div class="line"></div><div class="line">console.log(&quot;开始写入数据&quot;);</div><div class="line">let db = event.target.result;</div><div class="line">// keyPath、autoIncrement</div><div class="line">let objectStore = db.createObjectStore(&quot;customers&quot;, &#123; keyPath: &quot;ssn&quot; &#125;);</div><div class="line">objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125;);</div><div class="line">objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, &#123; unique: true &#125;);</div><div class="line"></div><div class="line">for (let item of customerData) &#123;</div><div class="line">objectStore.add(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 删除 objectStore</div><div class="line">// db.deleteObjectStore(&quot;customers&quot;);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexed%20DBIns1.png" alt="新建数据库"><br>PS： 这里有个坑，需要说明一下。<br>onupgradeneeded事件在下列情况下被触发：<br>1.数据库第一次被打开时即新建<br>2.打开数据库时指定的版本号高于当前被持久化的数据库版本号</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>添加数据在 onsuccess 钩子中进行。<br>IndexedDB 添加数据通过事务来添加数据。<br>下面重点介绍下 transaction(storeNames[, mode]);<br>第一个参数是事务希望跨越的对象存储空间的列表。<br>第二个参数事务中可以执行的访问类型。<br>返回一个事务对象。<br>事务可以接收三种不同类型的 DOM 事件： error，abort，以及 complete。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function addData(storeName) &#123;</div><div class="line">const datas = [</div><div class="line">  &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;,</div><div class="line">  &#123; ssn: &quot;777-77-7777&quot;, name: &quot;sdsd&quot;, age: 22, email: &quot;sdsd@home.org&quot; &#125;</div><div class="line">];</div><div class="line"></div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction=db.transaction(storeName,&apos;readwrite&apos;);</div><div class="line">        let store=transaction.objectStore(storeName); </div><div class="line"></div><div class="line">for(let i=0;i&lt;datas.length;i++)&#123;</div><div class="line">            store.add(datas[i]);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBAdd.png" alt="添加数据"></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>同样删除数据也使用 transaction。<br>唯一区别是使用了 objectStore的 delete(key)，该方法为删除指定key的数据项。<br>objectStore 还有一个方法 clear()清空该 store 中的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function del66(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.delete(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">console.log(&apos;删除成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;删除失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>同样查找数据也使用 transaction。<br>唯一区别是使用了 objectStore的 get(key)，该方法为删除指定key的数据项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function getDataByKey(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.get(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">let item =event.target.result; </div><div class="line">console.log(item); // 获得的该数据项</div><div class="line">console.log(&apos;查找成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;查找失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>可以调用object store的put方法更新数据，会自动替换键值相同的记录，达到更新目的，没有相同的则添加，以使用keyPath做键为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function updateDataByKey(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.get(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">let item =event.target.result; </div><div class="line"> // &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;</div><div class="line">item.ssn = &quot;666-66-6666&quot;</div><div class="line">item.name = &quot;yuzhenfan&quot;</div><div class="line">item.age = 18</div><div class="line">item.email = &quot;yzf@alipay.com&quot;</div><div class="line">            store.put(item); </div><div class="line">console.log(&apos;更新成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;更新失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBupdate.png" alt="更新数据"></p><blockquote><p>   参考文档<br><a href="https://www.cnblogs.com/lovelgx/articles/6026957.html" target="_blank" rel="external">数据库写入时机</a><br><a href="http://www.php.cn/html5-tutorial-359628.html" target="_blank" rel="external">html5使用indexdb的代码实例分享</a><br><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="external">wiki-数据库事务</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IndexedDB" target="_blank" rel="external">MDN-IndexedDB</a><br><a href="http://w3c.github.io/IndexedDB/" target="_blank" rel="external">w3c-IndexDB-API</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB" target="_blank" rel="external">IndexDB-Guides</a><br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（一：基本使用）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/indexedDB/static/&quot;&gt;demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是-IndexDB？&quot;&gt;&lt;a href=&quot;#什么是-IndexDB？&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>html5-svg开发手册</title>
    <link href="https://fanerge.github.io/2018/html5-svg%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/2018/html5-svg开发手册.html</id>
    <published>2018-01-30T12:28:14.000Z</published>
    <updated>2018-05-07T11:56:01.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h2><ol><li>img的src</li><li>background-image: url()</li><li>object: data</li><li>embed: src</li><li>foreignObject<br>foreignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。<h2 id="样式的写法（优先级逐渐降低）"><a href="#样式的写法（优先级逐渐降低）" class="headerlink" title="样式的写法（优先级逐渐降低）"></a>样式的写法（优先级逐渐降低）</h2>1.内联style<br><code>&lt;g style=&quot;fill: red;&quot;&gt;&lt;/g&gt;</code><br>2.class<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;g class=&quot;font&quot;&gt;&lt;/g&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[</div><div class="line">.font &#123;</div><div class="line">fill: red;</div><div class="line">&#125;</div><div class="line">]]&gt;&lt;/style&gt;</div></pre></td></tr></table></figure></li></ol><p>3.外链样式表<br><code>&lt;?xml-stylesheet href=&quot;style.css&quot; type=&quot;text\css&quot; ?&gt;</code><br>4.样式属性<br><code>&lt;g fill=&quot;red&quot;&gt;&lt;/g&gt;</code></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;![CDATA[解析器忽略的内容]]&gt;</div><div class="line">作用：xml解析器忽略解析，将表示为纯文本。</div></pre></td></tr></table></figure><p>默认用户坐标（视口svg的width和height）<br>指定用户坐标（viewBox属性）<br>保持宽高比（SVG的宽高和viewBox的宽高比是不一样），使用preserveAspectRatio属性<br>preserveAspectRatio=”xMidYMid meet”<br>第1个值表示，viewBox如何与SVG viewport对齐；第2个值表示，如何维持高宽比（如果有）。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><p>class、style</p><h2 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h2><p>color、display、opacity、overflow<br>fill、fill-opacity、fill-rule<br>stroke、stroke-dasharray、stroke-dashoffset、stroke-linecap、stroke-linejoin、stroke-miterlimit、stroke-opacity、stroke-width</p><h2 id="动画事件属性"><a href="#动画事件属性" class="headerlink" title="动画事件属性"></a>动画事件属性</h2><p>onbegin, onend, onload, onrepeat</p><h2 id="动画属性目标属性"><a href="#动画属性目标属性" class="headerlink" title="动画属性目标属性"></a>动画属性目标属性</h2><p>attributeType, attributeName</p><h2 id="动画定时属性"><a href="#动画定时属性" class="headerlink" title="动画定时属性"></a>动画定时属性</h2><p>begin, dur, end, min, max, restart, repeatCount, repeatDur, fill</p><h2 id="动画值属性"><a href="#动画值属性" class="headerlink" title="动画值属性"></a>动画值属性</h2><p>calcMode, values, keyTimes, keySplines, from, to, by, autoReverse, accelerate, decelerate</p><h2 id="动画累加属性"><a href="#动画累加属性" class="headerlink" title="动画累加属性"></a>动画累加属性</h2><p>additive, accumulate</p><h2 id="条件处理属性"><a href="#条件处理属性" class="headerlink" title="条件处理属性"></a>条件处理属性</h2><p>requiredExtensions, requiredFeatures, systemLanguage.</p><h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><p>id, xml:base, xml:lang, xml:space</p><h2 id="文档事件属性"><a href="#文档事件属性" class="headerlink" title="文档事件属性"></a>文档事件属性</h2><p>onabort, onerror, onresize, onscroll, onunload, onzoom</p><h2 id="过滤器原始属性"><a href="#过滤器原始属性" class="headerlink" title="过滤器原始属性"></a>过滤器原始属性</h2><p>height, result, width, x, y</p><h2 id="图形事件属性"><a href="#图形事件属性" class="headerlink" title="图形事件属性"></a>图形事件属性</h2><p>onactivate, onclick, onfocusin, onfocusout, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup</p><h1 id="svg-元素"><a href="#svg-元素" class="headerlink" title="svg 元素"></a>svg 元素</h1><h2 id="基本形状元素"><a href="#基本形状元素" class="headerlink" title="基本形状元素"></a>基本形状元素</h2><h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><p>line元素是一个SVG基本形状，用来创建一条连接两个点的线。<br>属性：x1、y1、x2、y2<br><code>&lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;5&quot; y2=&quot;5&quot;&gt;&lt;/line&gt;</code></p><h3 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h3><p>用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形。<br>属性：x、y、width、height、rx、ry<br><code>&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; rx=&quot;3&quot; ry=&quot;3&quot;&gt;&lt;/rect&gt;</code></p><h3 id="circle"><a href="#circle" class="headerlink" title="circle"></a>circle</h3><p>用来创建圆,基于一个圆心和一个半径。<br>属性：cx、cy、r<br><code>&lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;5&quot;&gt;&lt;/circle&gt;</code></p><h3 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse"></a>ellipse</h3><p>用来创建一个椭圆，基于一个中心坐标以及它们的x半径和y半径。<br>利用transform属性椭圆的倾斜。<br>属性：cx、cy、rx、ry<br><code>&lt;ellipse cx=&quot;60&quot; cy=&quot;60&quot; rx=&quot;50&quot; ry=&quot;25&quot;/&gt;</code></p><h3 id="polygon"><a href="#polygon" class="headerlink" title="polygon"></a>polygon</h3><p>polygon元素定义了一个由一组点左边的构成的闭合多边形形状。<br>属性：points<br><code>&lt;polygon points=&quot;100,40 100,80 60,100 20,80 20,40&quot;/&gt;</code></p><h3 id="polyline"><a href="#polyline" class="headerlink" title="polyline"></a>polyline</h3><p>用来创建一系列直线连接多个点。典型的一个polyline是用来创建一个开放的形状，最后一点不与第一点相连。<br>属性：points<br><code>&lt;polyline fill=&quot;none&quot; stroke=&quot;black&quot; points=&quot;20,100 40,60 70,80 100,20&quot;/&gt;</code></p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path元素是用来定义形状的通用元素。所有的基本形状都可以用path元素来创建。<br>属性：d（data）、pathLength<br>PS：d属性有下列值（大写字母为绝对坐标，小写字母为相对坐标）<br>M（m）-x，y-移动到给定坐标。<br>L（l）-x，y-绘制一条到给定坐标的线，可以提供多组坐标来绘制折线。<br>H（h）-x-绘制一条到给定x坐标的水平线。<br>V（v）-y-绘制一条到指定y坐标的竖线。<br>A（a）-rx ry x-axis-rotation large-arc-flag sweep-flag x y。<br>Q（q）-x1，y1，x，y-绘制一条从当前点到（x，y），控制点为（x1，y1）的二次贝塞尔曲线。<br>T（t）-x，y-绘制一条从当前点到（x，y）的二次贝塞尔曲线，控制点是前一个Q命令的控制点的中心对称点。如果没有前一条曲线，当前点会被用作控制点。<br>C（c）-x1，y1，x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，x1和x2分别为开始和终点控制点。<br>S（s）-x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，使用x2作为终点控制点，开始控制点为前一个C命令的终点控制点的中心对称点。<br><code>&lt;path d=&quot;M 100 100 L 300 100 L 200 300 z&quot; /&gt;</code><br>PS：x-axis-rotation为x轴旋转角度，large-arc-flag为角度大小，sweep-flag（弧线方向）<br>large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。<br>sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。</p><h2 id="功能元素"><a href="#功能元素" class="headerlink" title="功能元素"></a>功能元素</h2><h3 id="title（提升可访问性）"><a href="#title（提升可访问性）" class="headerlink" title="title（提升可访问性）"></a>title（提升可访问性）</h3><p>SVG绘图中的每个窗口元素或图形元素都可以提供一个title描述性字符串，该描述只能是纯文本。<br>title元素必须是它的父元素的第一个子元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;g&gt;</div><div class="line">   &lt;title&gt;SVG Title Demo example&lt;/title&gt;</div><div class="line">   &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;200&quot; height=&quot;50&quot; style=&quot;fill:none; stroke:blue; stroke-width:1px&quot;/&gt;</div><div class="line">&lt;desc&gt;提升可访问性&lt;/desc&gt;</div><div class="line">&lt;/g&gt;</div></pre></td></tr></table></figure></p><h3 id="desc（提升可访问性）"><a href="#desc（提升可访问性）" class="headerlink" title="desc（提升可访问性）"></a>desc（提升可访问性）</h3><p>SVG绘画中的每个容器元素或图形元素都可以提供一个desc描述性字符串，这些描述只是纯文本的。</p><h3 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h3><p>SVG 允许我们定义以后需要重复使用的图形元素， 建议把所有需要再次使用的引用元素定义在defs元素里面。<br>需要使用\<use\>元素来呈现defs定义的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">&lt;linearGradient id=&quot;Gradient01&quot;&gt;</div><div class="line">&lt;stop offset=&quot;20%&quot; stop-color=&quot;#39F&quot; /&gt;</div><div class="line">&lt;stop offset=&quot;90%&quot; stop-color=&quot;#F3F&quot; /&gt;</div><div class="line">&lt;/linearGradient&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;60&quot; height=&quot;10&quot; fill=&quot;url(#Gradient01)&quot;  /&gt;</div><div class="line">PS：radialGradient、linearGradient、pattern等元素必须要放在defs元素中</div></pre></td></tr></table></figure></use\></p><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>use元素在SVG文档内取得目标节点，并在别的地方复制它们。<br>属性：x、y、width、height、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;g id=&quot;Port&quot;&gt;</div><div class="line">      &lt;circle style=&quot;fill: inherit;&quot; r=&quot;10&quot;/&gt;</div><div class="line">    &lt;/g&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;use x=&quot;50&quot; y=&quot;10&quot; href=&quot;#Port&quot; /&gt;</div><div class="line">&lt;use x=&quot;50&quot; y=&quot;30&quot; href=&quot;#Port&quot; class=&quot;classA&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>使用 SVG 的锚元素\<a\>定义一个超链接。<br>属性：href、target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;www.alipay.com&quot; target=&quot;_blank&quot;&gt;</div><div class="line">    &lt;rect height=&quot;30&quot; width=&quot;120&quot; y=&quot;0&quot; x=&quot;0&quot; rx=&quot;15&quot;/&gt;</div><div class="line">    &lt;text fill=&quot;white&quot; text-anchor=&quot;middle&quot; y=&quot;21&quot; x=&quot;60&quot;&gt;SVG on MDN&lt;/text&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure></a\></p><h3 id="clipPath"><a href="#clipPath" class="headerlink" title="clipPath"></a>clipPath</h3><p>clipPath用于指定可绘制区域（超出了剪切路径所指定的区域，将不会被绘制。）。<br>属性：clipPathUnits=”userSpaceOnUse’或’objectBoundingBox”。第二个值childern一个对象的边框，会使用掩码的一小部分单位（默认：”userSpaceOnUse”）”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;clipPath id=&quot;myClip&quot;&gt;</div><div class="line">      &lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;20&quot;/&gt;</div><div class="line">    &lt;/clipPath&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; clip-path=&quot;url(#myClip)&quot;/&gt;</div></pre></td></tr></table></figure></p><p>PS：其他元素通过clip-path=”引用剪贴路径和引用剪贴路径交叉”</p><h3 id="color-profile"><a href="#color-profile" class="headerlink" title="color-profile"></a>color-profile</h3><p>该元素允许描述用于图像的颜色配置文件。<br>属性：local、name、rendering-intent、href</p><h3 id="foreignObject"><a href="#foreignObject" class="headerlink" title="foreignObject"></a>foreignObject</h3><p>foreignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。这个被包含的外来图形内容服从SVG变形和合成。<br>foreignObject元素通常与 switch 元素和requiredExtensions属性联用，来做兼容。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>SVG文档中的SVG元素包含图像信息。它表现为图像文件或者其他SVG文件。<br>属性：x、y、width、height、href、preserveAspectRatio（控制图像比例）</p><h3 id="linearGradient"><a href="#linearGradient" class="headerlink" title="linearGradient"></a>linearGradient</h3><p>linearGradient元素用来定义线性渐变，用于图形元素的填充或描边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;linearGradient id=&quot;MyGradient&quot;&gt;</div><div class="line">        &lt;stop offset=&quot;5%&quot;  stop-color=&quot;green&quot;/&gt;</div><div class="line">        &lt;stop offset=&quot;95%&quot; stop-color=&quot;gold&quot;/&gt;</div><div class="line">    &lt;/linearGradient&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;rect fill=&quot;url(#MyGradient)&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;</div></pre></td></tr></table></figure></p><p>属性：gradientUnits、gradientTransform、x1、y1、x2、y2、spreadMethod、href</p><h3 id="radialGradient"><a href="#radialGradient" class="headerlink" title="radialGradient"></a>radialGradient</h3><p>radialGradient用来定义径向，用于图形元素的填充或描边。<br>属性：gradientUnits、gradientTransform、cx、cy、r、fx、fy、spreadMethod、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;radialGradient id=&quot;exampleGradient&quot;&gt;</div><div class="line">      &lt;stop offset=&quot;10%&quot; stop-color=&quot;gold&quot;/&gt;</div><div class="line">      &lt;stop offset=&quot;95%&quot; stop-color=&quot;green&quot;/&gt;</div><div class="line">    &lt;/radialGradient&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;circle fill=&quot;url(#exampleGradient)&quot; cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>一个渐变上的颜色坡度，是用stop元素定义的。<br>stop元素可以是linearGradient、radialGradient的子元素。</p><h3 id="marker"><a href="#marker" class="headerlink" title="marker"></a>marker</h3><p>marker元素定义了在特定的path、line、polyline、polygon上绘制的箭头或者多边标记图形。<br>属性：marker-end、marker-mid、marker-start、markerUnits、refx、refy、markerWidth、markerHeight、orient<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;marker id=&quot;Triangle&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;1&quot; refY=&quot;5&quot; markerWidth=&quot;6&quot; markerHeight=&quot;6&quot; orient=&quot;auto&quot;&gt;</div><div class="line">      &lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; /&gt;</div><div class="line">    &lt;/marker&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;polyline points=&quot;10,90 50,80 90,20&quot; fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#Triangle)&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><p>在SVG中，你可以指一个透明的遮罩层和当前对象合成，形成背景。属性mask用来引用一个遮罩元素。<br>属性：maskUnits、maskContentUnits、x、y、width、height</p><h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>metadata是数据的结构化数据。</p><h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>使用预定义的图形对一个对象进行填充或描边，就要用到pattern元素，在下轴或y轴上重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;pattern id=&quot;Triangle&quot; width=&quot;10&quot; height=&quot;10&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;</div><div class="line">&lt;polygon points=&quot;5,0 10,10 0,10&quot;/&gt;</div><div class="line">&lt;/pattern&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;circle cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;url(#Triangle)&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>text元素定义了一个由文字组成的图形。注意：我们可以将渐变、图案、剪切路径、遮罩或者滤镜应用到text上。<br>属性：x、y、dx、dy、text-anchor、rotate、textLength、lengthAdjust<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;text x=&quot;0&quot; y=&quot;20&quot; transform=&quot;rotate(30 20,40)&quot;&gt;</div><div class="line">    SVG Text Rotation example</div><div class="line">&lt;/text&gt;</div></pre></td></tr></table></figure></p><h3 id="textPath"><a href="#textPath" class="headerlink" title="textPath"></a>textPath</h3><p>textPath使用path来展示文字。<br>属性：startOffset、method、spacing、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path id=&quot;MyPath&quot; fill=&quot;none&quot; stroke=&quot;red&quot; d=&quot;M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50&quot; /&gt;</div><div class="line">&lt;text&gt;</div><div class="line">&lt;textPath href=&quot;#MyPath&quot;&gt;</div><div class="line">  The quick brown fox jumps over the lazy dog.</div><div class="line">&lt;/textPath&gt;</div><div class="line">&lt;/text&gt;</div></pre></td></tr></table></figure></p><h3 id="tspan"><a href="#tspan" class="headerlink" title="tspan"></a>tspan</h3><p>在text元素中，利用内含的tspan元素，可以调整文本和字体的属性以及当前文本的位置、绝对或相对坐标值。<br>属性：x、y、dx、dy、rotate、textLength、lengthAdjust<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;text x=&quot;15&quot; y=&quot;30&quot;&gt;</div><div class="line">    You are </div><div class="line">    &lt;tspan&gt;not&lt;/tspan&gt; </div><div class="line">    a banana</div><div class="line">&lt;/text&gt;</div></pre></td></tr></table></figure></p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view元素是查看图片的一个限定方法，就像一个缩放级别或者一个详细视图。<br>属性：viewBox、preserveAspectRatio、zoomAndPan、viewTarget</p><h2 id="不显示元素"><a href="#不显示元素" class="headerlink" title="不显示元素"></a>不显示元素</h2><h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><p>元素g是用来组合对象的容器，对与transform、属性会作用与子元素。<br>通过\<use\>    元素来实现组合对象的复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;g stroke=&quot;green&quot; fill=&quot;white&quot; stroke-width=&quot;5&quot;&gt;</div><div class="line">    &lt;circle cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;</div><div class="line">    &lt;circle cx=&quot;40&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;</div><div class="line">&lt;/g&gt;</div></pre></td></tr></table></figure></use\></p><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>一个SVG脚本元素等同于HTML中的script元素。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set元素可以用来设定一个属性值，并为该值赋予一个持续时间。</p><h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>style元素元素样式表直接在SVG内容中间嵌入。</p><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>如果svg不是根元素，svg 元素可以用于在当前文档内嵌套一个独立的svg片段 。<br>这个独立片段拥有独立的视口和坐标系统。<br>属性：version、baseProfile、x、y、width、height、preserveAspectRatio、contentScriptType、contentStyleType、viewBox</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch元素对它的直接子元素上的属性requiredFeatures、属性requiredExtensions 和 属性systemLanguage按照顺序进行评估，然后处理和呈现第一个评估为true的子元素。<br>属性：allowReorder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;switch&gt;</div><div class="line">&lt;text systemLanguage=&quot;ar&quot;&gt;مرحبا&lt;/text&gt;</div><div class="line">&lt;text systemLanguage=&quot;ja&quot;&gt;こんにちは&lt;/text&gt;</div><div class="line">&lt;text&gt;☺&lt;/text&gt;</div><div class="line">   &lt;/switch&gt;</div></pre></td></tr></table></figure></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。<br>symbol元素对图形的作用是在同一文档中多次使用，添加结构和语义。<br>属性：preserveAspectRatio、viewBox<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt;</div><div class="line">&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot;/&gt;</div><div class="line">&lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot;/&gt;</div><div class="line">&lt;/symbol&gt;</div><div class="line">&lt;!-- actual drawing by &quot;use&quot; element --&gt;</div><div class="line">&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot;/&gt;</div><div class="line">&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot;/&gt;</div></pre></td></tr></table></figure></p><h2 id="动画元素"><a href="#动画元素" class="headerlink" title="动画元素"></a>动画元素</h2><h3 id="animate"><a href="#animate" class="headerlink" title="animate"></a>animate</h3><p>动画元素放在形状元素的内部，用来定义一个元素的某个属性根据时间点如何改变。<br>属性：attributeName、attributeType（CSS/XML）、from、to、dur、repeatCount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;</div><div class="line">    &lt;animate attributeType=&quot;XML&quot; attributeName=&quot;x&quot; from=&quot;-100&quot; to=&quot;120&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;/&gt;</div><div class="line">&lt;/rect&gt;</div></pre></td></tr></table></figure></p><h3 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h3><p>animateMotion元素导致引用的元素沿着运动路径移动。<br>属性：calcMode、path、keyPoints、rotate、origin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110&quot; stroke=&quot;lightgrey&quot; stroke-width=&quot;2&quot;  fill=&quot;none&quot; id=&quot;theMotionPath&quot;/&gt;</div><div class="line">&lt;circle cx=&quot;&quot; cy=&quot;&quot; r=&quot;5&quot; fill=&quot;red&quot;&gt;</div><div class="line">    &lt;animateMotion dur=&quot;6s&quot; repeatCount=&quot;indefinite&quot;&gt;</div><div class="line">&lt;mpath xlink:href=&quot;#theMotionPath&quot;/&gt;</div><div class="line">    &lt;/animateMotion&gt;</div><div class="line">&lt;/circle&gt;</div></pre></td></tr></table></figure></p><h3 id="mpath"><a href="#mpath" class="headerlink" title="mpath"></a>mpath</h3><p>animateMotion元素的 mpath 子元素使 animateMotion 元素能够引用一个外部的 path 元素作为运动路径的定义。<br>属性：href</p><h3 id="animateTransform"><a href="#animateTransform" class="headerlink" title="animateTransform"></a>animateTransform</h3><p>animateTransform元素变动了目标元素上的一个变形属性，从而允许动画控制转换、缩放、旋转或斜切。<br>属性：by、from、to、type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;polygon points=&quot;60,30 90,90 30,90&quot;&gt;</div><div class="line">    &lt;animateTransform attributeName=&quot;transform&quot;</div><div class="line">attributeType=&quot;XML&quot;</div><div class="line">type=&quot;rotate&quot;</div><div class="line">from=&quot;0 60 70&quot;</div><div class="line">to=&quot;360 60 70&quot;</div><div class="line">dur=&quot;10s&quot;</div><div class="line">repeatCount=&quot;indefinite&quot;/&gt;</div><div class="line">&lt;/polygon&gt;</div></pre></td></tr></table></figure></p><h2 id="滤镜元素"><a href="#滤镜元素" class="headerlink" title="滤镜元素"></a>滤镜元素</h2><h3 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h3><p>x、y、width、height属性置顶应用滤镜的画布的尺寸。<br>filterUnits指定用来定义滤镜范围的单位。<br>primitiveUnits为滤镜基元中的各种长度值指定坐标系统。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter元素作用是作为原子滤镜操作的容器。它不能直接呈现。可以利用目标SVG元素上的filter属性引用一个滤镜。<br>属性：x、y、width、height、filterRes、filterUnits、primitiveUnits、href<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;blurMe&quot;&gt;</div><div class="line">&lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot;/&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;circle cx=&quot;60&quot;  cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; /&gt;</div><div class="line">&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="feBlend"><a href="#feBlend" class="headerlink" title="feBlend"></a>feBlend</h3><p>feBlend滤镜把两个对象组合在一起，使它们受特定的混合模式控制。这类似于图像编辑软件中混合两个图层。该模式由属性mode定义。<br>属性：in、in2、mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;</div><div class="line">    &lt;filter id=&quot;spotlight&quot;&gt;</div><div class="line">&lt;feFlood result=&quot;floodFill&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; flood-color=&quot;green&quot; flood-opacity=&quot;1&quot;/&gt;</div><div class="line">&lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;floodFill&quot; mode=&quot;multiply&quot;/&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line">&lt;/defs&gt;</div><div class="line">&lt;image xlink:href=&quot;/files/6457/mdn_logo_only_color.png&quot; x=&quot;10%&quot; y=&quot;10%&quot; width=&quot;80%&quot; height=&quot;80%&quot; style=&quot;filter:url(#spotlight);&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="feColorMatrix（颜色转换滤镜）"><a href="#feColorMatrix（颜色转换滤镜）" class="headerlink" title="feColorMatrix（颜色转换滤镜）"></a>feColorMatrix（颜色转换滤镜）</h3><p>该滤镜基于转换矩阵对颜色进行变换。每一像素的颜色值(一个表示为[R,G,B,A] 的矢量)都经过矩阵乘法计算出的新颜色。<br>属性：in、type、values</p><h3 id="feComponentTransfer"><a href="#feComponentTransfer" class="headerlink" title="feComponentTransfer"></a>feComponentTransfer</h3><p>SVG滤镜基元对每个像素执行颜色分量的数据重映射.它允许进行像亮度调整,对比度调整,色彩平衡或阈值的操作。<br>属性：in</p><h3 id="feFuncR"><a href="#feFuncR" class="headerlink" title="feFuncR"></a>feFuncR</h3><p>该滤镜为它的父<fecomponenttransfer>元素的输入图形的红色成分定义了变换函数。<br>属性：type、tableValues、slope、intercept、amplitude、exponent、offset</fecomponenttransfer></p><h3 id="feFuncG"><a href="#feFuncG" class="headerlink" title="feFuncG"></a>feFuncG</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的绿色成分定义了变换函数。</p><h3 id="feFuncB"><a href="#feFuncB" class="headerlink" title="feFuncB"></a>feFuncB</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的蓝色成分定义了变换函数。</p><h3 id="feFuncA"><a href="#feFuncA" class="headerlink" title="feFuncA"></a>feFuncA</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的alpha成分定义了变换函数。</p><h3 id="feComposite（合成滤镜）"><a href="#feComposite（合成滤镜）" class="headerlink" title="feComposite（合成滤镜）"></a>feComposite（合成滤镜）</h3><p>该滤镜执行两个输入图像的智能像素组合，在图像空间中使用以下Porter-Duff合成操作之一：over、in、atop、xor<br>属性：in、in2、operator、k1、k2、k3、k4</p><h3 id="feConvolveMatrix"><a href="#feConvolveMatrix" class="headerlink" title="feConvolveMatrix"></a>feConvolveMatrix</h3><p>feConvolveMatrix元素应用了一个矩阵卷积滤镜效果。一个卷积在输入图像中把像素与邻近像素组合起来制作出结果图像。<br>属性：in、order、kernelMatrix、divisor、bias、targetX、targetY、edgeMode、kernelUnitLength、preserveAlpha</p><h3 id="feDiffuseLighting（散开照明滤镜）"><a href="#feDiffuseLighting（散开照明滤镜）" class="headerlink" title="feDiffuseLighting（散开照明滤镜）"></a>feDiffuseLighting（散开照明滤镜）</h3><p>滤镜光照一个图像，使用alpha通道作为隆起映射。<br>属性：in、surfaceScale、diffuseConstant、kernelUnitLength</p><h3 id="feDisplacementMap"><a href="#feDisplacementMap" class="headerlink" title="feDisplacementMap"></a>feDisplacementMap</h3><p>映射置换滤镜，该滤镜用来自图像中从in2到空间的像素值置换图像从in到空间的像素值。<br>属性：in、in2、scale、xChannelSelector、yChannelSelector</p><h3 id="feDistantLight（平行光滤镜）"><a href="#feDistantLight（平行光滤镜）" class="headerlink" title="feDistantLight（平行光滤镜）"></a>feDistantLight（平行光滤镜）</h3><p>该滤镜定义了一个距离光源，可以用在灯光滤镜feDiffuseLighting元素或feSpecularLighting元素的内部。<br>属性：azimuth、elevation</p><h3 id="feFlood"><a href="#feFlood" class="headerlink" title="feFlood"></a>feFlood</h3><p>该滤镜用flood-color元素定义的颜色和flood-opacity元素定义的不透明度填充了滤镜子区域。<br>属性：flood-color、flood-opacity</p><h3 id="feGaussianBlur（高斯模糊滤镜）"><a href="#feGaussianBlur（高斯模糊滤镜）" class="headerlink" title="feGaussianBlur（高斯模糊滤镜）"></a>feGaussianBlur（高斯模糊滤镜）</h3><p>该滤镜对输入图像进行高斯模糊，属性stdDeviation中指定的数量定义了钟形。<br>属性：in、stdDeviation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;blurMe&quot;&gt;</div><div class="line">    &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot; /&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="feImage（图片滤镜）"><a href="#feImage（图片滤镜）" class="headerlink" title="feImage（图片滤镜）"></a>feImage（图片滤镜）</h3><p>feImage滤镜从外部来源取得图像数据，并提供像素数据作为输出（意味着如果外部来源是一个SVG图像，这个图像将被栅格化。）<br>属性：preserveAspectRatio、href</p><h3 id="feMerge（合并滤镜）"><a href="#feMerge（合并滤镜）" class="headerlink" title="feMerge（合并滤镜）"></a>feMerge（合并滤镜）</h3><p>feMerge滤镜允许同时应用滤镜效果而不是按顺序应用滤镜效果。利用result存储别的滤镜的输出可以实现这一点，然后在一个feMergeNode子元素中访问它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;feOffset&quot; x=&quot;-40&quot; y=&quot;-20&quot; width=&quot;100&quot; height=&quot;200&quot;&gt;</div><div class="line">    &lt;feMerge&gt;</div><div class="line">&lt;feMergeNode in=&quot;blur2&quot; /&gt;</div><div class="line">&lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt;</div><div class="line">    &lt;/feMerge&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;rect x=&quot;40&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #000000; fill: green; filter: url(#feOffset);&quot; /&gt;</div></pre></td></tr></table></figure></p><h3 id="feMergeNode"><a href="#feMergeNode" class="headerlink" title="feMergeNode"></a>feMergeNode</h3><p>feMergeNode元素拿另一个滤镜的结果，让它的父feMerge元素处理。<br>属性：in</p><h3 id="feMorphology（扩张滤镜）"><a href="#feMorphology（扩张滤镜）" class="headerlink" title="feMorphology（扩张滤镜）"></a>feMorphology（扩张滤镜）</h3><p>该滤镜用来侵蚀或扩张输入的图像。它在增肥或瘦身效果方面特别有用。<br>属性：in、operator、radius</p><h3 id="feOffset（位移滤镜）"><a href="#feOffset（位移滤镜）" class="headerlink" title="feOffset（位移滤镜）"></a>feOffset（位移滤镜）</h3><p>该输入图像作为一个整体，在属性dx和属性dy的值指定了它的偏移量。<br>属性：in、dx、dy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;filter id=&quot;offset&quot; width=&quot;180&quot; height=&quot;180&quot;&gt;</div><div class="line">    &lt;feOffset in=&quot;SourceGraphic&quot; dx=&quot;60&quot; dy=&quot;60&quot; /&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; stroke=&quot;black&quot; fill=&quot;green&quot; filter=&quot;url(#offset)&quot;/&gt;</div></pre></td></tr></table></figure></p><h3 id="fePointLight（点光源滤镜）"><a href="#fePointLight（点光源滤镜）" class="headerlink" title="fePointLight（点光源滤镜）"></a>fePointLight（点光源滤镜）</h3><p>SVG创建一个点光源效果。<br>属性：x、y、z</p><h3 id="feSpecularLighting（镜子照明滤镜）"><a href="#feSpecularLighting（镜子照明滤镜）" class="headerlink" title="feSpecularLighting（镜子照明滤镜）"></a>feSpecularLighting（镜子照明滤镜）</h3><p>该滤镜照亮一个源图形，使用alpha通道作为隆起映射。<br>属性：in、surfaceScale、specularConstant、specularExponent、kernelUnitLength</p><h3 id="feSpotLight（斑点照明滤镜）"><a href="#feSpotLight（斑点照明滤镜）" class="headerlink" title="feSpotLight（斑点照明滤镜）"></a>feSpotLight（斑点照明滤镜）</h3><p>feSpotLight元素是一种光源元素，用于SVG文件。<br>属性：x、y、z、pointsAtX、pointsAtY、pointsAtZ、specularExponent、limitingConeAngle</p><h3 id="feTile（平铺滤镜）"><a href="#feTile（平铺滤镜）" class="headerlink" title="feTile（平铺滤镜）"></a>feTile（平铺滤镜）</h3><p>输入图像是平铺的，结果用来填充目标。它的效果近似于一个pattern图案对象。<br>属性：in</p><h3 id="feTurbulence"><a href="#feTurbulence" class="headerlink" title="feTurbulence"></a>feTurbulence</h3><p>该滤镜利用Perlin噪声函数创建了一个图像。它实现了人造纹理比如说云纹、大理石纹的合成。<br>属性：baseFrequency、numOctaves、seed、stitchTiles、type</p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="external">MDN-SVG系列资料</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute#Transfer_function_attributes" target="_blank" rel="external">svg-属性参考</a><br><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/an-in-depth-svg-tutorial.md" target="_blank" rel="external">掘金翻译-深入浅出 SVG</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;svg的使用&quot;&gt;&lt;a href=&quot;#svg的使用&quot; class=&quot;headerlink&quot; title=&quot;svg的使用&quot;&gt;&lt;/a&gt;s
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="svg" scheme="https://fanerge.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>Web Worker</title>
    <link href="https://fanerge.github.io/2018/html5-webWorker.html"/>
    <id>https://fanerge.github.io/2018/html5-webWorker.html</id>
    <published>2018-01-26T13:06:15.000Z</published>
    <updated>2018-01-27T08:13:35.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/H5WebWorker/static/">先放上demo，打开控制台试试</a></p><h1 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker"></a>什么是Web Worker</h1><p>Web Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。<br>局限性：在worker内不能直接操作DOM节点，或者使用window对象的默认方法和属性。</p><h1 id="Worker特性检测"><a href="#Worker特性检测" class="headerlink" title="Worker特性检测"></a>Worker特性检测</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(window.Worker)&#123;</div><div class="line">// todo</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持web Worker</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>PS：假设页面为index.html，页面js为main.js，这里的path是相对于index.html到该worker.js。</p><h1 id="专用Worker"><a href="#专用Worker" class="headerlink" title="专用Worker"></a>专用Worker</h1><h2 id="生成一个专用worker"><a href="#生成一个专用worker" class="headerlink" title="生成一个专用worker"></a>生成一个专用worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myWorker = new Worker(&apos;worker.js&apos;);</div></pre></td></tr></table></figure><p>PS：假设页面为index.html，页面主线程js为main.js，这里的path是相对于index.html到该worker.js。</p><h2 id="主线程js和Worker的通信（数据交互）"><a href="#主线程js和Worker的通信（数据交互）" class="headerlink" title="主线程js和Worker的通信（数据交互）"></a>主线程js和Worker的通信（数据交互）</h2><h3 id="主线程js（main-js-用来生成-myWorker）"><a href="#主线程js（main-js-用来生成-myWorker）" class="headerlink" title="主线程js（main.js 用来生成 myWorker）"></a>主线程js（main.js 用来生成 myWorker）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let myWorker</div><div class="line">if(window.Worker)&#123;</div><div class="line">// todo</div><div class="line">myWorker = new Worker(&apos;./js/worker.js&apos;)</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持web Worker</div><div class="line">alert(&apos;不支持web Worker&apos;)</div><div class="line">&#125;</div><div class="line">let app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    num: 1000000,</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">computed () &#123;</div><div class="line">console.log(`Message posted to worker=$&#123;this.num&#125;`);</div><div class="line">// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</div><div class="line">myWorker.postMessage(this.num)</div><div class="line">&#125;  </div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>PS：如果想发送多个消息，可以这样myWorker.postMessage([msg1, msg2…])，对应接收的e.data对象也就是一个数组了，若是对象的话需要序列化，接收的时候需要反序列化。</p><h3 id="myWorker脚本代码"><a href="#myWorker脚本代码" class="headerlink" title="myWorker脚本代码"></a>myWorker脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 有数据发过来，就触发</div><div class="line">onmessage = function(e) &#123;</div><div class="line">let num1 = e.data;</div><div class="line">let num2 = 0;</div><div class="line"></div><div class="line">console.time(&apos;计算耗时&apos;)</div><div class="line">for(let i = 0; i &lt; num1; i++)&#123;</div><div class="line">num2 += i;</div><div class="line">&#125;</div><div class="line">console.timeEnd(&apos;计算耗时&apos;)</div><div class="line"></div><div class="line">console.log(`Worker 计算结果=$&#123;num2&#125;`)</div><div class="line"></div><div class="line">// 当我们计算出结果，应该回传</div><div class="line">postMessage(num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我向一个Worker发送一个较大num，然后求出该1到num的整数和。<br>在页面中input的值分别为：1000000、10000000、100000000各执行了一次计算，最后一次花费了11s左右（算的上耗时计算了吧）。<br>下面是我的测试截图<br><img src="http://p26lefllv.bkt.clouddn.com/WebWorker.png" alt=""><br>就这么简单，我们就实现了主线程js和WebWorker的双向通信。</p><h2 id="终止worker"><a href="#终止worker" class="headerlink" title="终止worker"></a>终止worker</h2><h3 id="在主线程中终止"><a href="#在主线程中终止" class="headerlink" title="在主线程中终止"></a>在主线程中终止</h3><p>如果你需要从主线程中立刻终止一个运行中的worker，可以调用worker的terminate 方法：<br><code>myWorker.terminate();</code><br>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p><h3 id="在Worker中终止（自杀）"><a href="#在Worker中终止（自杀）" class="headerlink" title="在Worker中终止（自杀）"></a>在Worker中终止（自杀）</h3><p><code>close()</code></p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>当然我们刚刚仅仅考虑了正常情况，还有需要错误等待我们处理呢？<br>当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。<br>它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。<br>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。<br>错误事件有以下三个用户关心的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message</div><div class="line">可读性良好的错误消息。</div><div class="line">filename</div><div class="line">发生错误的脚本文件名。</div><div class="line">lineno</div><div class="line">发生错误时所在脚本文件的行号。</div></pre></td></tr></table></figure></p><h2 id="生成subworker"><a href="#生成subworker" class="headerlink" title="生成subworker"></a>生成subworker</h2><p>如果需要的话 worker 能够生成更多的 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>而且，subworker 解析 URI 时会相对于父 worker 的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。</p><h2 id="在Worker中引入脚本与库"><a href="#在Worker中引入脚本与库" class="headerlink" title="在Worker中引入脚本与库"></a>在Worker中引入脚本与库</h2><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">importScripts();                       </div><div class="line">importScripts(&apos;cube.js&apos;);                </div><div class="line">importScripts(&apos;cube1.js&apos;, &apos;cube2&apos;);</div></pre></td></tr></table></figure></p><h1 id="共享Worker（SharedWorker）"><a href="#共享Worker（SharedWorker）" class="headerlink" title="共享Worker（SharedWorker）"></a>共享Worker（SharedWorker）</h1><p>一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。<br>由于SharedWorker 与 专有Worker 非常相似，这里我只是提一下它们的区别。<br>读者若需要做测试的话，可以考虑在2个html页面中的javascript代码使用的是同一个worker。</p><h2 id="生成一个共享worker"><a href="#生成一个共享worker" class="headerlink" title="生成一个共享worker"></a>生成一个共享worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myWorker = new SharedWorker(&apos;worker.js&apos;);</div><div class="line">// 父级线程中的调用</div><div class="line">myWorker.port.start();</div><div class="line">// worker线程中的调用, 假设port变量代表一个端口  </div><div class="line">port.start();</div></pre></td></tr></table></figure><p>一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。<br>在使用start()方法打开端口连接时，如果父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。</p><h2 id="共享worker中消息的接收和发送"><a href="#共享worker中消息的接收和发送" class="headerlink" title="共享worker中消息的接收和发送"></a>共享worker中消息的接收和发送</h2><h3 id="主线程发送消息给Worker"><a href="#主线程发送消息给Worker" class="headerlink" title="主线程发送消息给Worker"></a>主线程发送消息给Worker</h3><p>改写我们的computed方法（vue组件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed () &#123;</div><div class="line">console.log(`Message posted to worker=$&#123;this.num&#125;`);</div><div class="line">// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</div><div class="line">myWorker.port.postMessage(this.num)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Worker接收到消息并处理及回传"><a href="#Worker接收到消息并处理及回传" class="headerlink" title="Worker接收到消息并处理及回传"></a>Worker接收到消息并处理及回传</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">onconnect = function(e) &#123;</div><div class="line">var port = e.ports[0];</div><div class="line"></div><div class="line">port.onmessage = function(e) &#123;</div><div class="line">// 同样e.data为主线程发送的数据</div><div class="line">console.log(e.data)</div><div class="line">//复杂的计算</div><div class="line">let result = e.data*1000*23*3</div><div class="line">// Worker需要回传至主线程</div><div class="line">port.postMessage(result);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="主线程接收并处理消息"><a href="#主线程接收并处理消息" class="headerlink" title="主线程接收并处理消息"></a>主线程接收并处理消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myWorker.port.onmessage = function(e) &#123;</div><div class="line">result2.textContent = e.data;</div><div class="line">console.log(&apos;Message received from worker&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：总结差异，主线程和Worker都要执行start()，通信时需要带上port。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>Worker接口会生成真正的操作系统级别的线程，如果你不太小心，那么并发(concurrency)会对你的代码产生有趣的影响。然而，对于 web worker 来说，与其他线程的通信点会被很小心的控制，这意味着你很难引起并发问题。</p><h1 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP全称Content Security Policy为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。<br>可以限制如下资源的加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">script-src：外部脚本</div><div class="line">style-src：样式表</div><div class="line">img-src：图像</div><div class="line">media-src：媒体文件（音频和视频）</div><div class="line">font-src：字体文件</div><div class="line">object-src：插件（比如 Flash）</div><div class="line">child-src：框架</div><div class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</div><div class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</div><div class="line">worker-src：worker脚本</div><div class="line">manifest-src：manifest 文件</div></pre></td></tr></table></figure></p><p>除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。<br>但它必须与report-uri选项配合使用。<br><code>Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser;</code></p><h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</code></p><h3 id="服务器上设置"><a href="#服务器上设置" class="headerlink" title="服务器上设置"></a>服务器上设置</h3><p>以下语句设置在请求头部（Header）<br><code>Content-Security-Policy &quot;default-src &#39;self&#39;;&quot;</code><br>如果要为Worker指定CSP策略，可以为Worker脚本的请求的响应的头部设置CSP策略。<br>这时这个Worker会继承它所属的文档或者创建它的Worker的CSP策略。 </p><h2 id="worker中数据的接收与发送"><a href="#worker中数据的接收与发送" class="headerlink" title="worker中数据的接收与发送"></a>worker中数据的接收与发送</h2><p>在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。<br>传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。</p><blockquote><p>   参考手册<br>    <a href="http://balance9.iteye.com/blog/1992118" target="_blank" rel="external">测试html5专用线程与共享线程的区别</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">MDN-WebWorker</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="external">WebWorkerAPI</a><br>    <a href="https://cn.vuejs.org/v2/api/#v-model" target="_blank" rel="external">vue</a><br>    <a href="http://www.runoob.com/html/html5-webworkers.html" target="_blank" rel="external">HTML5 Web Workers</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid" target="_blank" rel="external">CSP</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/H5WebWorker/static/&quot;&gt;先放上demo，打开控制台试试&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是Web-Worker&quot;&gt;&lt;a href=&quot;#什么是Web-Worker&quot; class=&quot;he
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Geolocation（地理定位）</title>
    <link href="https://fanerge.github.io/2018/html5-Geolocation.html"/>
    <id>https://fanerge.github.io/2018/html5-Geolocation.html</id>
    <published>2018-01-24T12:11:31.000Z</published>
    <updated>2018-01-24T13:48:48.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地理位置提供定制的信息。<br>其实Geolocation 就是用来获取到当前设备的经纬度（位置）<br>带有此接口的对象可以用由 Navigator实现的属性NavigatorGeolocation.geolocation 来获得。<br>PS：鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="检测是否支持地理定位"><a href="#检测是否支持地理定位" class="headerlink" title="检测是否支持地理定位"></a>检测是否支持地理定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (navigator.geolocation) &#123;</div><div class="line">// 做相应的操作 </div><div class="line">&#125; else &#123;</div><div class="line">console.error(&apos;不支持地理&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="获取当前定位"><a href="#获取当前定位" class="headerlink" title="获取当前定位"></a>获取当前定位</h2><p>Geolocation.getCurrentPosition(success, error, options)<br>    确定设备的位置并返回一个携带位置信息的 Position 对象。<br>参数：</p><h3 id="success"><a href="#success" class="headerlink" title="success"></a>success</h3><p>成功得到位置信息时的回调函数，使用Position 对象作为唯一的参数。 </p><h4 id="Position-coords-只读（latitude、longitude、accuracy）"><a href="#Position-coords-只读（latitude、longitude、accuracy）" class="headerlink" title="Position.coords 只读（latitude、longitude、accuracy）"></a>Position.coords 只读（latitude、longitude、accuracy）</h4><p>返回一个定义了当前位置的Coordinates 对象.<br>    coords.latitude    十进制数的纬度<br>    coords.longitude    十进制数的经度<br>    coords.accuracy    位置精度<br>    coords.altitude    海拔，海平面以上以米计<br>    coords.altitudeAccuracy    位置的海拔精度<br>    coords.heading    方向，从正北开始以度计<br>    coords.speed    速度，以米/每秒计</p><h4 id="Position-timestamp-只读"><a href="#Position-timestamp-只读" class="headerlink" title="Position.timestamp 只读"></a>Position.timestamp 只读</h4><p>返回一个时间戳DOMTimeStamp， 这个时间戳表示获取到的位置的时间。</p><h3 id="error-可选"><a href="#error-可选" class="headerlink" title="error 可选"></a>error 可选</h3><p>获取位置信息失败时的回调函数，使用 PositionError 对象作为唯一的参数，这是一个可选项。 </p><h4 id="PositionError-code-只读"><a href="#PositionError-code-只读" class="headerlink" title="PositionError.code 只读"></a>PositionError.code 只读</h4><p>返回无符号的、简短的错误码。<br>    PERMISSION_DENIED–权限问题<br>    POSITION_UNAVAILABLE–内部错误<br>    TIMEOUT–超时</p><h4 id="PositionError-message-只读"><a href="#PositionError-message-只读" class="headerlink" title="PositionError.message 只读"></a>PositionError.message 只读</h4><p>返回一个开发者可以理解的 DOMString 来描述错误的详细信息。</p><h3 id="options-可选"><a href="#options-可选" class="headerlink" title="options 可选"></a>options 可选</h3><h5 id="一个可选的PositionOptions-对象。"><a href="#一个可选的PositionOptions-对象。" class="headerlink" title="一个可选的PositionOptions 对象。"></a>一个可选的PositionOptions 对象。</h5><pre><code>enableHighAccuracy: false;--是否高精度，默认false timeout: 5000;--超时事件ms maximumAge: 0; 地理位置缓存时长ms</code></pre><h2 id="监视定位"><a href="#监视定位" class="headerlink" title="监视定位"></a>监视定位</h2><p>Geolocation.watchPosition(success[, error[, options]])<br>    用于注册监听器，在设备的地理位置发生改变的时候自动被调用。也可以选择特定的错误处理函数。<br>    该方法会返回一个 ID，如要取消监听可以通过  Geolocation.clearWatch() 传入该 ID 实现取消的目的。<br>参数：</p><h3 id="success-1"><a href="#success-1" class="headerlink" title="success"></a>success</h3><p>成功时候的回调函数， 同时传入一个 Position 对象当作参数。</p><h3 id="error-可选-1"><a href="#error-可选-1" class="headerlink" title="error 可选"></a>error 可选</h3><p>失败时候的回调函数，可选， 会传入一个 PositionError 对象当作参数。</p><h3 id="options-可选-1"><a href="#options-可选-1" class="headerlink" title="options 可选"></a>options 可选</h3><p>一个可选的 PositionOptions 对象。<br>PS：Position、PositionError、PositionOptions对象和上面一样。</p><h2 id="清理监视定位"><a href="#清理监视定位" class="headerlink" title="清理监视定位"></a>清理监视定位</h2><p>Geolocation.clearWatch(id)<br>    这个方法主要用于使用 Geolocation.watchPosition() 注册的 位置/错误 监听器。<br>参数：</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>希望移除的监听器所对应的 Geolocation.watchPosition() 返回的 ID 数字。<br>    Geolocation.watchPosition()注册一个位置改变监听器，每当设备位置改变时，返回一个 long 类型的该监听器的ID值。<br>Geolocation.clearWatch()<br>    取消由 watchPosition()注册的位置监听器。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation" target="_blank" rel="external">Geolocation</a><br>    <a href="http://www.runoob.com/html/html5-geolocation.html" target="_blank" rel="external">HTML5 Geolocation（地理定位）</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionError" target="_blank" rel="external">PositionError</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionOptions" target="_blank" rel="external">PositionOptions</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/watchPosition" target="_blank" rel="external">watchPosition</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>拖放（Drag 和 Drop）</title>
    <link href="https://fanerge.github.io/2018/html5-DragAndDrop.html"/>
    <id>https://fanerge.github.io/2018/html5-DragAndDrop.html</id>
    <published>2018-01-23T12:20:03.000Z</published>
    <updated>2018-01-23T14:33:20.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h1><p>拖放（Drag 和 drop）是 HTML5 标准的组成部分。<br>DataTransfer 对象：拖拽对象用来传递的媒介，使用一般为Event.dataTransfer。<br>draggable 属性：为需要拖拽的元素设置该属性。<br>Event.effectAllowed 属性：就是拖拽的效果。<br>Event.preventDefault() 方法：阻止默认的些事件方法等执行。<br>在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。</p><h2 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h2><h3 id="拖动目标上触发事件"><a href="#拖动目标上触发事件" class="headerlink" title="拖动目标上触发事件"></a>拖动目标上触发事件</h3><p>ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件。<br>ondrag 事件：当元素或者选择的文本被拖动时触发 drag 事件，大约每几百毫秒的触发一次。<br>ondragend 事件：当拖拽完成后触发的事件（比如松开鼠标按键或敲“Esc”键）。</p><h3 id="释放目标时触发的事件"><a href="#释放目标时触发的事件" class="headerlink" title="释放目标时触发的事件"></a>释放目标时触发的事件</h3><p>ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件。<br>ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件。<br>ondragleave 事件：当被鼠标拖动的对象离开其容器范围内时触发此事件。<br>ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件。<br>ondragexit 事件：当一个元素不再拖动立即选择目标元素触发。</p><h1 id="DataTransfer-对象详解"><a href="#DataTransfer-对象详解" class="headerlink" title="DataTransfer 对象详解"></a>DataTransfer 对象详解</h1><p>在进行拖放操作时，DataTransfer 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>dropEffect    String<br>    设置实际的放置效果，它应该始终设置成 effectAllowed  的可能值之一 。<br>effectAllowed    String<br>    用来指定拖动时被允许的效果。<br>files     FileList<br>    包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。<br>types    DOMStringList<br>    保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>addElement(element)<br>    设置拖动源。通常你不需要改变这项，如果修改这项将会影响拖动的哪个节点和dragend事件的触发。默认目标是被拖动的节点。<br>setData(type,data)<br>    为一个给定的类型设置数据。<br>getData()<br>    根据指定的类型检索数据，如果指定类型的数据不存在或者该 DataTransfer 对象中没有数据，方法将返回一个空字符串。<br>clearData(type)<br>    删除与给定类型关联的数据。类型参数是可选的。<br>setDragImage(imgElement,offsetX,offsetY)<br>    自定义一个期望的拖动时的图片。大多数情况下，这项不用设置，因为被拖动的节点被创建成默认图片。</p><h1 id="实现拖拽"><a href="#实现拖拽" class="headerlink" title="实现拖拽"></a>实现拖拽</h1><h2 id="确定什么是可拖动的"><a href="#确定什么是可拖动的" class="headerlink" title="确定什么是可拖动的"></a>确定什么是可拖动的</h2><p>让一个元素被拖动需要添加 draggable 属性，再加上全局事件处理函数ondragstart。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">console.log(&quot;dragStart&quot;);</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="定义拖动数据"><a href="#定义拖动数据" class="headerlink" title="定义拖动数据"></a>定义拖动数据</h2><p>应用程序可以在拖动操作中包含任意数量的数据项。每个数据项都是一个  string 类型，典型的MIME类型，如：text/html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">// 添加拖拽数据</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">ev.dataTransfer.setData(&quot;text/html&quot;, &quot;&lt;p&gt;Example paragraph&lt;/p&gt;&quot;);</div><div class="line">ev.dataTransfer.setData(&quot;text/uri-list&quot;, &quot;http://developer.mozilla.org&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="定义拖动图像"><a href="#定义拖动图像" class="headerlink" title="定义拖动图像"></a>定义拖动图像</h2><p>拖动过程中，浏览器会在鼠标旁显示一张默认图片。当然，应用程序也可以通过setDragImage() 方法自定义一张图片.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123; </div><div class="line">var img = new Image(); </div><div class="line">img.src = &apos;example.gif&apos;; </div><div class="line">ev.dataTransfer.setDragImage(img, 10, 10);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：img 的 src 属性路径是以使用该 js 页面为基准。</p><h2 id="定义拖动效果"><a href="#定义拖动效果" class="headerlink" title="定义拖动效果"></a>定义拖动效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">  // Set the drag effect to copy</div><div class="line">  ev.dataTransfer.dropEffect = &quot;copy&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="定义一个放置区"><a href="#定义一个放置区" class="headerlink" title="定义一个放置区"></a>定义一个放置区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function dragover_handler(ev) &#123;</div><div class="line">// 这里必须阻止默认行为，否则没有效果</div><div class="line">ev.preventDefault();</div><div class="line">ev.dataTransfer.dropEffect = &quot;move&quot;</div><div class="line">&#125;</div><div class="line">function drop_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">// Get the id of the target and add the moved element to the target&apos;s DOM</div><div class="line">var data = ev.dataTransfer.getData(&quot;text&quot;);</div><div class="line">ev.target.appendChild(document.getElementById(data));</div><div class="line">&#125;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><h2 id="处理放置效果"><a href="#处理放置效果" class="headerlink" title="处理放置效果"></a>处理放置效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">ev.dropEffect = &quot;move&quot;;</div><div class="line">&#125;</div><div class="line">function dragover_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">// Set the dropEffect to move</div><div class="line">ev.dataTransfer.dropEffect = &quot;move&quot;</div><div class="line">&#125;</div><div class="line">function drop_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">var data = ev.dataTransfer.getData(&quot;text&quot;);</div><div class="line">ev.target.appendChild(document.getElementById(data));</div><div class="line">&#125;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</div><div class="line">&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><h2 id="拖动结束"><a href="#拖动结束" class="headerlink" title="拖动结束"></a>拖动结束</h2><p>在拖动目标元素上监听 dragend 事件，此时你可以做一起其他事情。</p><blockquote><p>   参考文档：<br>    <a href="http://www.zhangxinxu.com/wordpress/2011/02/html5-drag-drop-%E6%8B%96%E6%8B%BD%E4%B8%8E%E6%8B%96%E6%94%BE%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">HTML5 drag &amp; drop 拖拽与拖放简介</a><br>    <a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="external">HTML5 拖放（Drag 和 Drop）详解与实例</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="external">DataTransfer</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="external">Drag and Drop API</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理论介绍&quot;&gt;&lt;a href=&quot;#理论介绍&quot; class=&quot;headerlink&quot; title=&quot;理论介绍&quot;&gt;&lt;/a&gt;理论介绍&lt;/h1&gt;&lt;p&gt;拖放（Drag 和 drop）是 HTML5 标准的组成部分。&lt;br&gt;DataTransfer 对象：拖拽对象用来传递的媒介
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>面试杂项</title>
    <link href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html"/>
    <id>https://fanerge.github.io/2018/面试杂项.html</id>
    <published>2018-01-22T14:17:21.000Z</published>
    <updated>2018-05-09T13:51:47.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防止网页被嵌入框架的代码"><a href="#防止网页被嵌入框架的代码" class="headerlink" title="防止网页被嵌入框架的代码"></a>防止网页被嵌入框架的代码</h1><h2 id="任何页面都不可嵌套"><a href="#任何页面都不可嵌套" class="headerlink" title="任何页面都不可嵌套"></a>任何页面都不可嵌套</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 判断当前的window对象是否对顶层top对象还可以使用window.top !== window.self</div><div class="line">if (window !== top) </div><div class="line">// 如果不是，将top对象的网址自动导向被嵌入网页的网址</div><div class="line">top.location.href = window.location.href;</div></pre></td></tr></table></figure><h2 id="本地域名可嵌套，其他域名不可"><a href="#本地域名可嵌套，其他域名不可" class="headerlink" title="本地域名可嵌套，其他域名不可"></a>本地域名可嵌套，其他域名不可</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">　　top.location.hostname;</div><div class="line">　　if (top.location.hostname !== window.location.hostname) &#123;</div><div class="line">　　　　top.location.href = window.location.href;</div><div class="line">　　&#125;</div><div class="line">&#125;catch(e)&#123;</div><div class="line">　　top.location.href = window.location.href;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面两种对于动态生产iframe标签和禁用js不会用效果。<br>别人可能这样禁用你的js<br><code>&lt;noscript&gt;&lt;iframe src=fillseo.html&gt;&lt;/iframe&gt;&lt;/noscript&gt;</code></p><h2 id="js如何判断是否在iframe中"><a href="#js如何判断是否在iframe中" class="headerlink" title="js如何判断是否在iframe中"></a>js如何判断是否在iframe中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//方式一 </div><div class="line">if (self.frameElement &amp;&amp; self.frameElement.tagName == &quot;IFRAME&quot;) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125; </div><div class="line">//方式二 </div><div class="line">if (window.frames.length != parent.frames.length) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125; </div><div class="line">//方式三 </div><div class="line">if (self != top) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="比较可靠的方式"><a href="#比较可靠的方式" class="headerlink" title="比较可靠的方式"></a>比较可靠的方式</h2><p>为了彻底防止别人用IFRAME框架嵌套调用自己的网页，如下方法是最可靠的.<br>这里赋值为空页面,也可赋值为你的页面的URL地址.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(top != self)&#123; </div><div class="line">location.href = &quot;about:blank&quot;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="在meta中设置"><a href="#在meta中设置" class="headerlink" title="在meta中设置"></a>在meta中设置</h2><p><code>&lt;meta http-equiv=&quot;X-FRAME-OPTIONS&quot; content=&quot;DENY&quot;&gt;</code></p><h2 id="在http的header做手脚"><a href="#在http的header做手脚" class="headerlink" title="在http的header做手脚"></a>在http的header做手脚</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">header(‘X-Frame-Options:Deny&apos;);</div><div class="line">header(&quot;X-XSS-Protection: 0&quot;);</div></pre></td></tr></table></figure><h2 id="在Apache、IIS、Nginc主机中设置"><a href="#在Apache、IIS、Nginc主机中设置" class="headerlink" title="在Apache、IIS、Nginc主机中设置"></a>在Apache、IIS、Nginc主机中设置</h2><p><code>X-Frame-Options &quot;SAMEORIGIN&quot;;</code></p><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="BFC的定义"><a href="#BFC的定义" class="headerlink" title="BFC的定义"></a>BFC的定义</h2><p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域（可以理解为独立的布局作用域），也是浮动元素与其他元素的交互限定区域。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p><h2 id="BFC的触发"><a href="#BFC的触发" class="headerlink" title="BFC的触发"></a>BFC的触发</h2><p>body 根元素或包含根元素的元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p><h2 id="BFC的运用"><a href="#BFC的运用" class="headerlink" title="BFC的运用"></a>BFC的运用</h2><p>同一个 BFC 下外边距会发生折叠<br>BFC 可以包含浮动的元素（清除浮动）（父容器设置为overflow: hidden;即可清除浮动）<br>BFC 可以阻止元素被浮动元素覆盖（为原本被覆盖的元素设置overflow: hidden;是该元素触发BFC解决问题）<br><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="external">10 分钟理解 BFC 原理</a></p><h1 id="Banner如何平滑的从最后一张过渡到第一张"><a href="#Banner如何平滑的从最后一张过渡到第一张" class="headerlink" title="Banner如何平滑的从最后一张过渡到第一张"></a>Banner如何平滑的从最后一张过渡到第一张</h1><p>1.如有1,2,3,4张banner需要轮播，对应图片顺序为：4,1,2,3,4,1<br>2.动画结束后改变left定位到前面的1，这个过程页面看不出变化。<br><a href="https://segmentfault.com/q/1010000002585081/a-1020000002585201" target="_blank" rel="external">图片轮播，第一张图片和最后一张图片怎么过渡？</a></p><h1 id="Event-Loop（浏览器环境）"><a href="#Event-Loop（浏览器环境）" class="headerlink" title="Event Loop（浏览器环境）"></a>Event Loop（浏览器环境）</h1><p>定义：为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。即事件循环，是JavaScript引擎处理异步任务的方式。为了让单线程的JavaScript通畅的跑起来，所有的异步操作都要被合适的处理，这个处理逻辑就叫做Event Loop。<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="external">HTML标准-Event loops</a></p><h2 id="堆、栈、队列"><a href="#堆、栈、队列" class="headerlink" title="堆、栈、队列"></a>堆、栈、队列</h2><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>堆（heap）是指程序运行时申请的动态内存，在JS运行时用来存放对象。</p><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>栈（stack）遵循的原则是“先进后出”，JS种的基本数据类型与指向对象的地址存放在栈内存中，此外还有一块栈内存用来执行JS主线程–执行栈（execution context stack），这里只考虑执行栈。</p><h3 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h3><p>队列（queue）遵循的原则是“先进先出”，JS中除了主线程之外还存在两个“任务队列”（微任务队列microTask和宏任务队列macroTask）。</p><h2 id="js中的两个队列"><a href="#js中的两个队列" class="headerlink" title="js中的两个队列"></a>js中的两个队列</h2><p>在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。<br>MicroTask: process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver<br>MacroTask: script(同步代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering<br>javascript执行：总的执行顺序为同步代码script—&gt;microTask—&gt;其他macroTask，在执行microTask、macroTask是产生新的异步操作，如此一来就形成了循环。<br>具体来说，浏览器会不断从task队列中按顺序取task执行，每执行完一个task都会检查microtask队列是否为空（执行完一个task的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去task队列中取下一个task执行，以此类推。</p><h2 id="Philip-Roberts的演讲《Help-I’m-stuck-in-an-event-loop》的event-loop-图"><a href="#Philip-Roberts的演讲《Help-I’m-stuck-in-an-event-loop》的event-loop-图" class="headerlink" title="Philip Roberts的演讲《Help, I’m stuck in an event-loop》的event-loop 图"></a>Philip Roberts的演讲《Help, I’m stuck in an event-loop》的event-loop 图</h2><p><img src="http://p677fntmi.bkt.clouddn.com/162385d14ae83726" alt="Philip Roberts的演讲《Help, I&#39;m stuck in an event-loop》"></p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><blockquote><p>   当主线程运行的时候,JS会产生堆和栈(执行栈)<br>主线程中调用的webaip所产生的异步操作(dom事件、ajax回调、定时器等)只要产生结果，就把这个回调塞进“任务队列”中等待执行。<br>当主线程中的同步任务执行完毕，系统就会依次读取“任务队列”中的任务，将任务放进执行栈中执行。<br>执行任务时可能还会产生新的异步操作，会产生新的循环，整个过程是循环不断的。</p></blockquote><p><a href="https://juejin.im/post/5aab2d896fb9a028b86dc2fd" target="_blank" rel="external">JavaScript 运行机制–Event Loop详解</a><br><a href="https://segmentfault.com/a/1190000013861128" target="_blank" rel="external">一篇文章教会你Event loop——浏览器和Node</a></p><h1 id="Event-Loop（Node环境）"><a href="#Event-Loop（Node环境）" class="headerlink" title="Event Loop（Node环境）"></a>Event Loop（Node环境）</h1><p>Node使用了libuv库来实现Event loop。</p><h2 id="Event-Loop顺序"><a href="#Event-Loop顺序" class="headerlink" title="Event Loop顺序"></a>Event Loop顺序</h2><p>nodejs的event loop分为6个阶段，它们会按照顺序反复运行，分别如下：</p><ol><li>timers：执行setTimeout() 和 setInterval()中到期的callback。</li><li>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</li><li>idle, prepare：队列的移动，仅内部使用</li><li>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</li><li>check：执行setImmediate的callback</li><li>close callbacks：执行close事件的callback，例如socket.on(“close”,func)<br><img src="http://p677fntmi.bkt.clouddn.com/690666428-5ab0a22b5cbca_articlex.png" alt="Node-Event Loop"><br>不同于浏览器的是，在每个阶段完成后，而不是MacroTask任务完成后，microTask队列就会被执行。这就导致了同样的代码在不同的上下文环境下会出现不同的结果。<br>另外需要注意的是，如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。<br><a href="https://segmentfault.com/a/1190000013861128" target="_blank" rel="external">一篇文章教会你Event loop——浏览器和Node</a></li></ol><h1 id="RegExp相关知识点"><a href="#RegExp相关知识点" class="headerlink" title="RegExp相关知识点"></a>RegExp相关知识点</h1><p>RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配[2018-03-27]。</p><h2 id="正则flags的说明"><a href="#正则flags的说明" class="headerlink" title="正则flags的说明"></a>正则flags的说明</h2><p>g–全局匹配;找到所有匹配，而不是在第一个匹配后停止<br>i–忽略大小写<br>m–多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处<br>u–Unicode; 将模式视为Unicode序列点的序列<br>y–粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)</p><h2 id="正则表达式中特殊字符的含义"><a href="#正则表达式中特殊字符的含义" class="headerlink" title="正则表达式中特殊字符的含义"></a>正则表达式中特殊字符的含义</h2><h3 id="字符类别（Character-Classes）"><a href="#字符类别（Character-Classes）" class="headerlink" title="字符类别（Character Classes）"></a>字符类别（Character Classes）</h3><h4 id=""><a href="#" class="headerlink" title="."></a>.</h4><p>点号，小数点，匹配任意单个字符（但不包括行结束符\n \r等）。<br>例如，/.y/ 匹配 “yes make my day” 中的 “my” 和 “ay”，但是不匹配 “yes”。</p><h4 id="d"><a href="#d" class="headerlink" title="\d"></a>\d</h4><p>匹配任意阿拉伯数字。等价于[0-9]。<br>例如，/\d/ 或 /[0-9]/ 匹配 “B2 is the suite number.” 中的 ‘2’。 </p><h4 id="D"><a href="#D" class="headerlink" title="\D"></a>\D</h4><p>匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。<br>例如，/\D/ 或 /[^0-9]/ 匹配 “B2 is the suite number.” 中的 ‘B’。<br>PS：由于没有全局匹配，只能匹配到一个’B’就结束匹配。</p><h4 id="w"><a href="#w" class="headerlink" title="\w"></a>\w</h4><p>匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。<br>例如，/\w/ 匹配 “apple” 中的 ‘a’，”$5.28” 中的 ‘5’ 和 “3D” 中的 ‘3’。</p><h4 id="W"><a href="#W" class="headerlink" title="\W"></a>\W</h4><p>匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9<em>]。<br>例如，/\W/ 或 /[^A-Za-z0-9</em>]/ 匹配 “50%” 中的 ‘%’。</p><h4 id="s"><a href="#s" class="headerlink" title="\s"></a>\s</h4><p>匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。<br>例如 /\s\w*/ 匹配 “foo bar” 中的 ‘ bar’。</p><h4 id="S"><a href="#S" class="headerlink" title="\S"></a>\S</h4><p>匹配一个非空白符。<br>例如，/\S\w*/ 匹配 “foo bar” 中的 ‘foo’。<br>PS：经常使用[\s\S]来匹配所有字符。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>\t    匹配一个水平制表符（tab）<br>\r    匹配一个回车符（carriage return）<br>\n    匹配一个换行符（linefeed）<br>\v    匹配一个垂直制表符（vertical tab）<br>\f    匹配一个换页符（form-feed）<br>[\b]    匹配一个退格符（backspace）（不要与 \b 混淆）<br>\0    匹配一个 NUL 字符。不要在此后面跟小数点。<br>\xhh    匹配编码为 hh （两个十六进制数字）的字符。<br>\uhhhh    匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。<br>\      发生转义<br>例如，<em> 是一个特殊字符，表示匹配某个字符 0 或多次，如 /a</em>/ 意味着 0 或多个 “a”。 为了匹配字面意义上的 <em> ，在它前面加上一个反斜杠，例如，/a\</em>/匹配 ‘a*’。</p><h2 id="字符集合（Character-Sets）"><a href="#字符集合（Character-Sets）" class="headerlink" title="字符集合（Character Sets）"></a>字符集合（Character Sets）</h2><h3 id="xyz"><a href="#xyz" class="headerlink" title="[xyz]"></a>[xyz]</h3><p>匹配集合中的任意一个字符。你可以使用连字符’-‘指定一个范围。<br>例如，[abcd] 等价于 [a-d]，匹配”brisket”中的’b’和”chop”中的’c’。</p><h3 id="xyz-1"><a href="#xyz-1" class="headerlink" title="[^xyz]"></a>[^xyz]</h3><p>一个反义或补充字符集，也叫反义字符组。<br>例如，[^abc] 等价于 [^a-c]。 第一个匹配的是 “bacon” 中的’o’ 和 “chop” 中的 ‘h’。</p><h2 id="边界（Boundaries）"><a href="#边界（Boundaries）" class="headerlink" title="边界（Boundaries）"></a>边界（Boundaries）</h2><h3 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h3><p>匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。<br>例如，/^A/ 不匹配 “an A” 中的 “A”，但匹配 “An A” 中的 “A”。</p><h3 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h3><p>匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。<br>例如，/t$/ 不匹配 “eater” 中的 “t”，但匹配 “eat” 中的 “t”。</p><h3 id="b"><a href="#b" class="headerlink" title="\b"></a>\b</h3><p>如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪婪模式。所谓的惰性模式就是一旦匹配到合适的就结束，不在继续匹配下去了。</p><h2 id="分组（Grouping）与反向引用（back-references）"><a href="#分组（Grouping）与反向引用（back-references）" class="headerlink" title="分组（Grouping）与反向引用（back references）"></a>分组（Grouping）与反向引用（back references）</h2><h3 id="先行断言（lookahead）"><a href="#先行断言（lookahead）" class="headerlink" title="先行断言（lookahead）"></a>先行断言（lookahead）</h3><h4 id="先行肯定断言"><a href="#先行肯定断言" class="headerlink" title="先行肯定断言"></a>先行肯定断言</h4><p>x(?=y)<br>只有当 x 后面紧跟着 y 时，才匹配 x。<br>/Jack(?=Sprat|Frost)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 或 ‘Frost’ 时，才会匹配它。然而，’Sprat’ 或 ‘Frost’ 都不是匹配结果的一部分。</p><h4 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h4><p>x(?!y)<br>只有当 x 后面不是紧跟着 y 时，才匹配 x。<br>只有当 x 后面不是紧跟着 y 时，才匹配 x。例如，/\d+(?!.)/ 只有当一个数字后面没有紧跟着一个小数点时，才会匹配该数字。/\d+(?!.)/.exec(“3.141”) 匹配 141 而不是 3.141。</p><h3 id="后行断言（lookbehind）"><a href="#后行断言（lookbehind）" class="headerlink" title="后行断言（lookbehind）"></a>后行断言（lookbehind）</h3><p>这是ES2018新加的标准</p><h4 id="后行肯定断言"><a href="#后行肯定断言" class="headerlink" title="后行肯定断言"></a>后行肯定断言</h4><p>(?&lt;=y)x<br>只有当 x 前面紧跟 y 时，才匹配 x。<br>例如：/(?&lt;=\$)\d+/.exec(‘$1000’) // 1000</p><h4 id="后行否定断言"><a href="#后行否定断言" class="headerlink" title="后行否定断言"></a>后行否定断言</h4><p>(?&lt;!y)x<br>只有当 x 前面紧不是跟 y 时，才匹配 x。<br>例如：/(?&lt;!\$)\d+/.exec(‘$99¥1000’) // 99</p><h1 id="获取元素的尺寸"><a href="#获取元素的尺寸" class="headerlink" title="获取元素的尺寸"></a>获取元素的尺寸</h1><h2 id="window-getComputedStyle-element-pseudoElt"><a href="#window-getComputedStyle-element-pseudoElt" class="headerlink" title="window.getComputedStyle(element, [pseudoElt])"></a>window.getComputedStyle(element, [pseudoElt])</h2><p>定义：Window.getComputedStyle() 方法给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算。<br>参数：<br>element<br>    用于获取计算样式的Element<br>pseudoElt 可选<br>    指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。<br>返回：返回的样式是一个实时的 CSSStyleDeclaration 对象，当元素的样式更改时，它会自动更新本身。<br>兼容性处理：window.getComputedStyle ? window.getComputedStyle(ele, null) : ele.currentStyle<br>可以通过height属性和getPropertyValue(“height”)获取height值。</p><h2 id="elem-getBoundingClientRect"><a href="#elem-getBoundingClientRect" class="headerlink" title="elem.getBoundingClientRect()"></a>elem.getBoundingClientRect()</h2><p>定义：Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。<br>返回：top、right、bottom、left（相对于视口）width、right。</p><h2 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h2><p>content+padding：clientWidth\clientHeight<br>content+padding+border: offsetWidth\offsetHeight</p><h1 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h1><p>定义：埋点分析，是网站分析的一种常用的数据采集方法。数据埋点分为初级、中级、高级三种方式。数据埋点是一种良好的私有化部署数据采集方式。<br>实现步骤：埋点阶段 -&gt; 数据收集阶段 -&gt; 后端处理阶段</p><h2 id="买点分类"><a href="#买点分类" class="headerlink" title="买点分类"></a>买点分类</h2><h3 id="适合前端埋点"><a href="#适合前端埋点" class="headerlink" title="适合前端埋点"></a>适合前端埋点</h3><ol><li>运营初级阶段，产品功能相对简单（无明确业务数据、交易数据，仅通过UV、PV、点击量等基本指标分析即可满足需求）</li><li>需求分析与后端没有交互的前端行为（运营人员工作需要判断前端界面设计是否合理）<h3 id="适合后端埋点"><a href="#适合后端埋点" class="headerlink" title="适合后端埋点"></a>适合后端埋点</h3></li><li>追求精细化运营，需要进行多维度数据分析</li><li>包含用户资产、用户账户、风控辅助数据等重点业务数据</li><li>对数据安全性要求比较高</li><li>前端和后端都可以采集到的数据，应优先考虑后端埋点<h2 id="前端埋点（实现步骤）"><a href="#前端埋点（实现步骤）" class="headerlink" title="前端埋点（实现步骤）"></a>前端埋点（实现步骤）</h2><h3 id="埋点-1"><a href="#埋点-1" class="headerlink" title="埋点"></a>埋点</h3>以Google Analytics分析为例<br>在页面上插入一段js代码，被称为埋点代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">    var _maq = _maq || []; // 全局的数组，放采集到的数据 </div><div class="line">    _maq.push([&apos;_setAccount&apos;, &apos;uuid&apos;]); // 默认放了_setAccount用于设置网站标识ID，这个标识ID是在注册GA时分配的。 </div><div class="line">    (function () &#123;  </div><div class="line">        var ma = document.createElement(&apos;script&apos;);  </div><div class="line">        ma.type = &apos;text/javascript&apos;;  </div><div class="line">        ma.async = true;  </div><div class="line">        ma.src = &quot;http://localhost:8091/data/js/ma.js&quot;;  </div><div class="line">        var s = document.getElementsByTagName(&apos;script&apos;)[0];  </div><div class="line">        s.parentNode.insertBefore(ma, s);  </div><div class="line">    &#125;)();  </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></li></ol><p>PS：匿名函数，这段代码的主要目的就是引入一个外部的js文件（ga.js），方式是通过document.createElement方法创建一个script并根据协议（http或https）将src指向对应的ga.js，最后将这个element插入页面的dom树上。<br>注意ga.async = true的意思是异步调用外部js文件，即不阻塞浏览器的解析，待外部js下载完成后异步执行。这个属性是HTML5新引入的。</p><h3 id="数据采集（之前动态插入的ma-js）"><a href="#数据采集（之前动态插入的ma-js）" class="headerlink" title="数据采集（之前动态插入的ma.js）"></a>数据采集（之前动态插入的ma.js）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">    var params = &#123;&#125;;</div><div class="line">    //Document对象数据</div><div class="line">    if(document) &#123;</div><div class="line">        params.domain = document.domain || &apos;&apos;; </div><div class="line">        params.url = document.URL || &apos;&apos;; </div><div class="line">        params.title = document.title || &apos;&apos;; </div><div class="line">        params.referrer = document.referrer || &apos;&apos;; </div><div class="line">    &#125;   </div><div class="line">    //Window对象数据</div><div class="line">    if(window &amp;&amp; window.screen) &#123;</div><div class="line">        params.sh = window.screen.height || 0;</div><div class="line">        params.sw = window.screen.width || 0;</div><div class="line">        params.cd = window.screen.colorDepth || 0;</div><div class="line">    &#125;   </div><div class="line">    //navigator对象数据</div><div class="line">    if(navigator) &#123;</div><div class="line">        params.lang = navigator.language || &apos;&apos;; </div><div class="line">    &#125;   </div><div class="line">    //解析_maq配置</div><div class="line">    if(_maq) &#123;</div><div class="line">        for(var i in _maq) &#123;</div><div class="line">            switch(_maq[i][0]) &#123;</div><div class="line">                case &apos;_setAccount&apos;:</div><div class="line">                    params.account = _maq[i][1];</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    break;</div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">    //拼接参数串</div><div class="line">    var args = &apos;&apos;; </div><div class="line">    for(var i in params) &#123;</div><div class="line">        if(args != &apos;&apos;) &#123;</div><div class="line">            args += &apos;&amp;&apos;;</div><div class="line">        &#125;   </div><div class="line">        args += i + &apos;=&apos; + encodeURIComponent(params[i]);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //通过Image对象请求后端脚本</div><div class="line">    var img = new Image(1, 1); </div><div class="line">    img.src = &apos;http://analytics.codinglabs.org/1.gif?&apos; + args;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>PS：为什么使用图片请求后端controller而不是ajax直接访问？原因在于ajax不能跨域请求，ma.js和后端分析的代码可能不在相同的域内，ajax做不到，而将image对象的src属性指向后端脚本并携带参数，就轻松实现了跨域请求。</p><h3 id="后端处理"><a href="#后端处理" class="headerlink" title="后端处理"></a>后端处理</h3><p>后端脚本一般做下面几件事：<br>（1）解析http请求参数的到信息。<br>（2）从服务器（WebServer）中获取一些客户端无法获取的信息，如访客ip等。<br>（3）将信息按格式写入log。<br>（4）生成一副1×1的空gif图片作为响应内容并将响应头的Content-type设为image/gif。<br>（5）在响应头中通过Set-cookie设置一些需要的cookie信息（作为跟踪唯一访客）。<br><a href="http://www.woshipm.com/data-analysis/665420.html" target="_blank" rel="external">前端埋点和后端埋点，哪个更科学？</a><br><a href="https://blog.csdn.net/hxyascx/article/details/53373916" target="_blank" rel="external">用户行为日志-js埋点（一）实现整体流程</a><br><a href="https://mixpanel.com/help/reference/javascript" target="_blank" rel="external">开源埋点库MixPanel</a></p><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>文件(File) 接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。</p><h2 id="files属性"><a href="#files属性" class="headerlink" title="files属性"></a>files属性</h2><p>用于获取当前文件数组相关的信息，每个元素有下列属性（均为只读属性）。<br>File.lastModified<br>File.name<br>File.size 单位为B。<br>File.webkitRelativePath<br>File.type 返回文件的 多用途互联网邮件扩展类型 </p><h2 id="FileReader-构造函数"><a href="#FileReader-构造函数" class="headerlink" title="FileReader() 构造函数"></a>FileReader() 构造函数</h2><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>FileReader.abort()<br>该方法可以取消 FileReader 的读取操作，触发之后 readyState 为已完成（DONE）。<br>FileReader.readAsArrayBuffer()<br>开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.<br>FileReader.readAsBinaryString()<br>开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。<br>FileReader.readAsBinaryString()<br>开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。<br>FileReader.readAsText()<br>开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。</p><h1 id="前端错误收集"><a href="#前端错误收集" class="headerlink" title="前端错误收集"></a>前端错误收集</h1><h2 id="window-onerror（大部分的错误）"><a href="#window-onerror（大部分的错误）" class="headerlink" title="window.onerror（大部分的错误）"></a>window.onerror（大部分的错误）</h2><p>window.onerror = function(message, source, lineno, colno, error) { … }<br>PS：</p><ol><li>由于网络请求异常事件不会冒泡，需要在捕获阶段进行处理</li><li>不能捕获promise的错误信息</li><li>跨域资源需要专门处理，需要在script标签加上crossorigin属性，服务器设置Access-Control-Allow-Origin</li><li>window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</li></ol><h2 id="promise的错误处理"><a href="#promise的错误处理" class="headerlink" title="promise的错误处理"></a>promise的错误处理</h2><p>promise除了使用catch方法来捕获错误，还可以使用window的unhandledrejection事件捕获异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&quot;unhandledrejection&quot;, function (event) &#123;</div><div class="line">  console.warn(&quot;WARNING: Unhandled promise rejection. Shame on you! Reason: &quot;</div><div class="line">               + event.reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><p>try catch只能捕获同步代码的异常，对回调，setTimeout，promise等无能为力</p><h2 id="上报错误"><a href="#上报错误" class="headerlink" title="上报错误"></a>上报错误</h2><ol><li>后端提供接口，前端ajax上传</li><li>创建一个新的图片，url参数带上错误信息（跨域）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function report(error) &#123;</div><div class="line">  var reportUrl = &apos;http://xxxx/report&apos;;</div><div class="line">  new Image().src = reportUrl + &apos;error=&apos; + error;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://www.aliued.com/?p=4162" target="_blank" rel="external">阿里UED前端监控</a></p><h1 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h1><p>引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npx create-react-app my-cool-new-app</div></pre></td></tr></table></figure></p><p>这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。</p><h1 id="判断浏览器对某个css3是否支持"><a href="#判断浏览器对某个css3是否支持" class="headerlink" title="判断浏览器对某个css3是否支持"></a>判断浏览器对某个css3是否支持</h1><h2 id="‘样式属性名’-in-document-documentElement-style"><a href="#‘样式属性名’-in-document-documentElement-style" class="headerlink" title="‘样式属性名’ in document.documentElement.style"></a>‘样式属性名’ in document.documentElement.style</h2><p>‘transform’ in document.documentElement.style // true<br>PS：兼容性较好，ie6+</p><h2 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h2><p>此方法为css属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@supports (display: flex) &#123;</div><div class="line">div &#123; display: flex; &#125;</div><div class="line">&#125;</div><div class="line">@supports not (display: flex) &#123;</div><div class="line">div &#123; float: left; &#125; /* 替换样式 */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通常关系链接符有 not、or、and等</p><h2 id="CSS-supports"><a href="#CSS-supports" class="headerlink" title="CSS.supports"></a>CSS.supports</h2><p>CSS.supports(propertyName, value) || CSS.supports(supportCondition)<br>CSS.supports() 静态方法返回一个Boolean值，用来校验浏览器是否支持一个给定的CSS特性。<br>该方法有两种参数形式：</p><ol><li>propertyName：属性名，value：属性值。</li><li>supportCondition：需要一个匹配@supports条件的参数。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = CSS.supports(&apos;(--foo: red)&apos;); // true第一种形式</div><div class="line">result = CSS.supports(&quot;( transform-origin: 5% 5% )&quot;); // true第二种形式</div></pre></td></tr></table></figure></li></ol><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者模式（Decorator Pattern）：在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象。<br>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。<br>装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//需要装饰的类（函数）</div><div class="line">function Macbook() &#123;</div><div class="line"> this.cost = function () &#123;</div><div class="line">  return 1000;</div><div class="line"> &#125;;</div><div class="line">&#125; </div><div class="line">//计算商品的包装费</div><div class="line">function PackagingFee(macbook) &#123;</div><div class="line"> this.cost = function () &#123;</div><div class="line">  return macbook.cost() + 75;</div><div class="line"> &#125;;</div><div class="line">&#125;</div><div class="line">//计算商品的运费</div><div class="line">function Freight(macbook) &#123;</div><div class="line"> this.cost = function () &#123;</div><div class="line">  return macbook.cost() + 300;</div><div class="line"> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let money1 = new Macbook()  // 只包含mac 1000</div><div class="line">let money2 = new PackagingFee(new Macbook()) // 只包含mac + 包装费 1075 </div><div class="line">let money4 = new Freight(new Macbook()) // 只包含mac + 运费 1300</div><div class="line">let money3 = new Freight(new PackagingFee(new Macbook())) // 包含mac + 包装费 + 运费 1375</div></pre></td></tr></table></figure></p><h1 id="touchstart-和-click-的坑"><a href="#touchstart-和-click-的坑" class="headerlink" title="touchstart 和 click 的坑"></a>touchstart 和 click 的坑</h1><h2 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tap = &apos;ontouchstart&apos; in window ? &apos;touchstart&apos; : &apos;click&apos;;</div><div class="line">wrap.addEvenListener(tap, function()&#123;</div><div class="line">    signUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>通过上面代码简单为用户设置事件类型，但我们忽略了‘联想触控笔记本’，<span color="color: red">由于该笔记本支持‘touchstart’事件，但当用户使用鼠标时却不能触发‘touchstart’事件</span>，造成不能触发对应的事件处理函数。</p><ol><li>有些 PC 设备屏幕为触摸屏，同时支持touchstart和click事件；</li><li>用户触发touchstart事件，默认必然会导致触发click事件，但是触发click事件，不一定会导致touchstart事件被触发；</li><li>此类设备外接鼠标时，通过上面的绑定方式，会绑定touchstart事件，但是鼠标操作只能触发click，导致touchstart不触发；</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="均使用click事件（移动端存在300ms延迟）"><a href="#均使用click事件（移动端存在300ms延迟）" class="headerlink" title="均使用click事件（移动端存在300ms延迟）"></a>均使用click事件（移动端存在300ms延迟）</h3><h3 id="通过UA判断设备是否为移动端，再确认事件类型"><a href="#通过UA判断设备是否为移动端，再确认事件类型" class="headerlink" title="通过UA判断设备是否为移动端，再确认事件类型"></a>通过UA判断设备是否为移动端，再确认事件类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function isMobile() &#123;</div><div class="line">    return navigator.userAgent.match(/(blackberry|configuration\/cldc|hp |hp-|htc |htc_|htc-|iemobile|kindle|midp|mmp|motorola|mobile|nokia|opera mini|opera |Googlebot-Mobile|YahooSeeker\/M1A1-R2D2|android|iphone|ipod|mobi|palm|palmos|pocket|portalmmm|ppc;|smartphone|sonyericsson|sqh|spv|symbian|treo|up.browser|up.link|vodafone|windows ce|xda |xda_)/i) ? true : false;</div><div class="line">&#125;</div><div class="line"> var tap = isMobile() ? &apos;touchstart&apos; : &apos;click&apos;;</div></pre></td></tr></table></figure><h3 id="全部使用click，通过FastClick解决300毫秒的延迟问题"><a href="#全部使用click，通过FastClick解决300毫秒的延迟问题" class="headerlink" title="全部使用click，通过FastClick解决300毫秒的延迟问题"></a>全部使用click，通过FastClick解决300毫秒的延迟问题</h3><h3 id="不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。"><a href="#不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。" class="headerlink" title="不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。"></a>不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。</h3><p>具体实现：</p><ol><li>在touchstart事件响应中调用preventDefault()方法，阻止后续click事件的触发（也会阻止多个事件绑定叠加和多人合作项目，导致以来 click 事件出现bug）</li><li>在touchstart事件中设置一些标记，或者取消click事件的绑定，使得click事件触发时不会触发我们绑定的逻辑，在一段时间（例如300-500ms）后再恢复</li><li>直接对事件处理函数进行节流（throttle），保证在一段时间内（300ms - 500ms），事件处理函数只触发一次</li></ol><h1 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h1><p>defer：载入 JavaScript 文件时不阻塞 HTML 的解析（并行），执行阶段被放到 HTML 标签解析完成之后（DOMContentLoaded之前）。<br>async：与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后，但一定在load触发之前执行。</p><h1 id="从输入url到页面渲染优化"><a href="#从输入url到页面渲染优化" class="headerlink" title="从输入url到页面渲染优化"></a>从输入url到页面渲染优化</h1><h2 id="大值步骤"><a href="#大值步骤" class="headerlink" title="大值步骤"></a>大值步骤</h2><p>DNS域名解析-&gt;建立TCP连接-&gt;下载资源-&gt;解析页面</p><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>将人们习惯使用的域名，映射为对应的ip，机器之间只能识别ip地址。<br>域名解析的步骤：以www.baidu.com为例<br>1、浏览器缓存：浏览器会按照一定的频率缓存DNS记录。<br>2、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找（hosts文件）。<br>3、路由缓存：路由器也有DNS缓存(可能存在)。<br>4、ISP的DNS服务器：ISP是互联网服务提供商(Internet Service Provider)的简称，ISP有专门的DNS服务器应对DNS查询请求。<br>5、根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.域名服务器的IP地址，然后再问.com顶级域名服务器，依次类推）。<br>PS：以www.baidu.com为例说明根域名、顶级域名、一级域名等<br>根域名：为’.’,全球共13个ip地址（并不是13台机器）。<br>顶级域名(一级域名)：为www.baidu.com的顶级域名为baidu.com，主机名为www。<br>二级域名：a.www.baidu.com的二级域名为www.baidu.com，主机名为a。<br>优化方案：域名预解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 告知浏览器, 当前页面要做DNS预解析</div><div class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</div><div class="line">// 强制对DNS预解析（本网页需要跳转的页面，注意避免多页面重复DNS解析）</div><div class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</div></pre></td></tr></table></figure></p><h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><p>经过域名解析，浏览器拿到了服务器的IP。<br>TCP建立连接的三次握手：<br>客户端创建socket，向服务器目标端口发送连接建立请求，数据段包含位码SYN（建立联机标志位） = 1，随机数seq（顺序号码）= x，和其他TCP标志和选项。<br>服务器有一个专门处理连接请求的welcome socket，接收到连接建立请求，置位码SYN和ACK（确认标志位）为1，ack（确认号码）= x + 1，随机数seq = y，并返回。<br>客户端检查ack是否等于x + 1，等于时，将ACK置为1，SYN置为0，将ack置为y + 1发送至服务器端。<br>welcome socket检查ack等于y + 1和ACK等于1后，创建新的socket，此socket由源IP/源端口、目标IP/目标端口标识，之后客户端发送的数据都被引导向此新的socket，至此，TCP连接建立。<br>优化方案：<br>减少数据往返延迟（地理位置远近关系）可以使用CDN（客户端访问域名到距离最近的服务器）。<br>使用HTTP2（多路复用 (Multiplexing)）、header压缩（减少传输数据大小）、服务端推送（server push）（有时只需要服务器发送数据到客户端，不需要客户端-&gt;服务端—&gt;客户端这样一个来回）<br>减少cookie：每次请求都携带了本域的cookie<br>PS：虽然HTTP 1.1有长链接，但资源下载事串行的，所以推荐使用HTTP2的多了复用。</p><h2 id="下载资源（接收响应）"><a href="#下载资源（接收响应）" class="headerlink" title="下载资源（接收响应）"></a>下载资源（接收响应）</h2><p>避免不必要的重定向（非缓存重定向），重定向会导致浏览器再进行一次（DNS域名解析-&gt;建立TCP连接-&gt;下载资源-&gt;解析页面）。<br>避免超出并行连接阀值（浏览器会在同域名并行连接限制，一般为6个）</p><h2 id="解析页面（webkit工作原理）"><a href="#解析页面（webkit工作原理）" class="headerlink" title="解析页面（webkit工作原理）"></a>解析页面（webkit工作原理）</h2><p>处理HTML标记，构建DOM树。<br>处理CSS标记，构建CSSOM树。<br>将DOM树和CSSOM树融合成渲染树（会忽略不需要渲染的dom）。<br>根据渲染树来布局，计算每个节点的几何信息。<br>在屏幕上绘制各个节点。<br>中间遇到各种资源时，会进行资源的下载。<br>优化：<br>css放head中，js放body尾部，均以外链形式<br>压缩js、css等文件<br>使用CDN技术<br>使用图片精灵、webp、图片base64等<br>首屏优化（按需加载、首屏资源优先加载）<br>避免重排（开启复合层，如使用3d变换、opacity等<a href="http://div.io/topic/1348" target="_blank" rel="external">3d硬件加速的坑</a>），减少重绘<br>缓存技术：强缓存（Expires、Cache-Control：max-age=seconds）协商缓存（Last-Modified/If-Modified-Since、ETag/If-None-Match）</p><h1 id="CSS2Dtransform和Matrix的关系"><a href="#CSS2Dtransform和Matrix的关系" class="headerlink" title="CSS2Dtransform和Matrix的关系"></a>CSS2Dtransform和Matrix的关系</h1><p>这里transform包括：translate、scale、rotate、skew<br>没有任何变换时：matrix(1, 0, 0, 1, 0, 0)、matrix(a, b, c, d, e, f)<br>translate(30, 30) 等价于 matrix(1, 0, 0, 1, 30, 30)<br>ps：e、f分别表示x轴和y轴偏移距离<br>scale(2, 3) 等价于 matrix(2, 0, 3, 1, 0, 0)<br>ps：a、c分别表示x轴和y轴缩放比例<br>rotate(θ) 等价于 matrix(cosθ,sinθ,-sinθ,cosθ,0,0)<br>ps：a、b、c、d共同决定旋转角度θ<br>skew(θx, θy) 等价于 matrix(1,tan(θy),tan(θx),1,0,0)<br>ps：θx表示x轴倾斜的角度，θy表示y轴</p><h1 id="硬编码和非硬编码（软编码）的区别"><a href="#硬编码和非硬编码（软编码）的区别" class="headerlink" title="硬编码和非硬编码（软编码）的区别"></a>硬编码和非硬编码（软编码）的区别</h1><p>软编码可以在运行时确定，修改；而硬编码是不能够改变的。<br>硬编码是指将可变变量用一个固定值来代替的方法，使用这样方法，编译后，如果想更改词变量就变的非常困难。因此， 在大部分的程序语言中，可以将一个固定值定义为一个标记， 然后用这个特殊的标记来取代变量名称。 当标记名称发生改变时， 变量名不变。这样在程序进行编译时，所有的变量都不再是固定值 这样就更容易实现改变变量的目的。</p><h1 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h1><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><blockquote><p> 参考文档：<br><a href="https://http2.github.io" target="_blank" rel="external">HTTP/2</a><br><a href="https://www.cnblogs.com/geaozhang/p/7010353.html" target="_blank" rel="external">DNS域名解析的过程</a><br><a href="https://juejin.im/post/5ad578ba6fb9a028cc61b89f" target="_blank" rel="external">从输入url开始能做哪些优化</a><br><a href="http://blog.chinaunix.net/uid-28216282-id-3757849.html" target="_blank" rel="external">DNS解析过程详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;a href=&quot;#防止网页被嵌入框架的代码&quot; class=&quot;headerlink&quot; title=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;/a&gt;防止网页被嵌入框架的代码&lt;/h1&gt;&lt;h2 id=&quot;任何页面都不可嵌套&quot;&gt;&lt;a href=&quot;#任何页面
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
