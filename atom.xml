<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2018-03-16T14:00:15.496Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从对象的遍历到浅拷贝的思考</title>
    <link href="https://fanerge.github.io/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E5%88%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%80%9D%E8%80%83.html"/>
    <id>https://fanerge.github.io/从对象的遍历到浅拷贝的思考.html</id>
    <published>2018-03-14T12:17:36.000Z</published>
    <updated>2018-03-16T14:00:15.496Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有<span style="color: red;">String</span>类型，ES6之后对象的属性有<span style="color: red;">String和Symbol类型</span>。<br>由于文章上下文关系，本文将按照’属性描述符’-&gt;’对象的属性遍历方法介绍’-&gt;’现代ECMAScript对象的浅拷贝’进行介绍，现代ECMAScript对象的深拷贝比较复杂，有时间在分析。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。</p><h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p><h2 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</p><h2 id="属性描述符的读写操作"><a href="#属性描述符的读写操作" class="headerlink" title="属性描述符的读写操作"></a>属性描述符的读写操作</h2><p>我们可以通过Object.getOwnPropertyDescriptor(o,name)、Object.getOwnPropertyDescriptors(obj)来查看属性描述符，<br>通过Object.defineProperty(o,name,desc)、Object.defineProperties(o,descriptors)、Object.create(proto,descriptors)等方法来更改属性描述符。</p><h1 id="对象的属性遍历方法介绍"><a href="#对象的属性遍历方法介绍" class="headerlink" title="对象的属性遍历方法介绍"></a>对象的属性遍历方法介绍</h1><p>上面，我们了解了属性描述符，其中枚举这个属性描述符，在不同方法对对象属性的遍历过程产生的作用差异很大，下面我开始介绍如何遍历对象的属性。<br><strong>本小结的测试代码，我就不贴出来了，都很简单，我这里直接给出结论，感兴趣的朋友可以自己尝试。</strong></p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>定义：for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item in object) &#123;...&#125;</div><div class="line">// itme--在每次迭代时，将不同的属性名分配给变量。</div><div class="line">// object--被迭代枚举其属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.可以遍历对象自身和原型链上可枚举的属性<br>2.任意顺序，说明遍历的属性先后顺序不定（不同运行环境顺序不同）。不建议对数组使用for…in来遍历主要原因就是这个，另一方面为性能考虑for…in还会遍历到原型链上的可枚举属性。</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>定义：Object.keys() 方法会返回一个由该对象的自身的可枚举属性组成的数组。</p><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.keys(obj)</div><div class="line">// obj--要返回其枚举自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性是可枚举的<br>3.任意顺序，枚举属性的顺序和for…in/Object.getOwnPropertyNames(obj)一致<br>4.返回一个所有元素为字符串（不包括Symbol）的数组</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>定义：Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyNames(obj)</div><div class="line">// obj--一个对象，其自身的可枚举和不可枚举属性的名称被返回。</div></pre></td></tr></table></figure></p><p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性了枚举和不可枚举都可以遍历<br>3.任意顺序，枚举属性的顺序和for…in/Object.keys(obj)一致</p><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>定义：Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertySymbols(obj)</div><div class="line">// obj--要返回 Symbol 属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性为Symbol类型</p><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><p>定义：Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Reflect.ownKeys(target)</div><div class="line">// target--获取自身属性键的目标对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>这里看，似乎能遍历出自身的所有属性，还差原型连上的属性。</p><h2 id="总结下上面的方法"><a href="#总结下上面的方法" class="headerlink" title="总结下上面的方法"></a>总结下上面的方法</h2><p>为了好归纳，我这里将对象的属性分为以下类别：1.自身可枚举的属性，2.自身不可枚举的属性，3.Symbol类型的属性，4.原型链上的可枚举属性，5.原型链上的不可枚举属性，6.原型链上的Symbol属性<strong>2018-03-16更新</strong></p><table><thead><tr><th>方法</th><th style="text-align:center">可遍历的属性类别</th></tr></thead><tbody><tr><td>for…in</td><td style="text-align:center">1，4</td></tr><tr><td>Object.keys()</td><td style="text-align:center">1</td></tr><tr><td>Object.getOwnPropertyNames()</td><td style="text-align:center">1，2</td></tr><tr><td>Object.getOwnPropertySymbols()</td><td style="text-align:center">3</td></tr><tr><td>Reflect.ownKeys()</td><td style="text-align:center">1，2，3</td></tr></tbody></table><p>从上表分析，还没有一个方法能完美解决，我们只能组合使用了。<br>PS：除了for…in其余方法均返回数组。</p><h1 id="现代ECMAScript对象的浅拷贝"><a href="#现代ECMAScript对象的浅拷贝" class="headerlink" title="现代ECMAScript对象的浅拷贝"></a>现代ECMAScript对象的浅拷贝</h1><p>本小节会我们会实现各种浅拷贝，并分析各自的劣势，最终我们将实现一种比较完美的方法（暂不考虑兼容性）。</p><h2 id="现看一个以前实现的方法"><a href="#现看一个以前实现的方法" class="headerlink" title="现看一个以前实现的方法"></a>现看一个以前实现的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function shallowCopy (obj) &#123;</div><div class="line">  if (typeof obj !== &apos;object&apos;) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  var newObj = obj instanceof Array ? [] : &#123;&#125;</div><div class="line">  for (var key in obj) &#123;</div><div class="line">    if (obj.hasOwnProperty(key)) &#123;</div><div class="line">      newObj[key] = obj[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return newObj</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这中方法对于ES6之前的确可行，毕竟我也用过这样的方法，有了Symbol之后这个就不再正确了。</p><h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><blockquote><p>   该方式在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。<br>不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的 对象 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们</p></blockquote><h2 id="Object-assign-和-展开运算符（…）"><a href="#Object-assign-和-展开运算符（…）" class="headerlink" title="Object.assign 和 展开运算符（…）"></a>Object.assign 和 展开运算符（…）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj2 = Object.assign(&#123;&#125;, obj)</div><div class="line">// obj2</div><div class="line">&#123;</div><div class="line">name: &apos;yzf&apos;,</div><div class="line">age: 100,</div><div class="line">sex: &apos;male&apos;,</div><div class="line">[Symbol()]: &apos;symbol1&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个函数的定义：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>特点：自身的可枚举的包括Symbol类型的，不包括不可枚举的属性和原型链上的属性，不完美。</p><h2 id="Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors"><a href="#Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors" class="headerlink" title="Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()"></a>Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()</h2><p>首先需要介绍一下相关的方法，ES7的Object.getOwnPropertyDescriptors()。</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>定义：Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// 需要获取自身属性的对象。</div></pre></td></tr></table></figure></p><p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>4.包括了集体属性的描述符（value）<br>到这里似乎我们已经找到了，比较完美的解决方案了，我们来组合一下这3个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// obj为需要浅拷贝的对象</div><div class="line">let obj1 = Object.create(</div><div class="line">  Object.getPrototypeOf(obj), </div><div class="line">  Object.getOwnPropertyDescriptors(obj) </div><div class="line">)</div><div class="line">// obj1就是我们浅拷贝的得到的对象。</div></pre></td></tr></table></figure></p><p>PS：obj1对象通过Object.create()方法指定了自身的原型链（从原型链继承了相关属性），然后在通过Object.getOwnPropertyDescriptors()方法把自身的（包括可枚举的、不可枚举的、Symbol类型的）全部添加obj1上，这样是实现了我们的真正意义上的浅拷贝。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>数组的浅拷贝ary.slice()、 ary.concat()、[…ary]、JSON.parse(JSON.stringify(ary))<br><a href="https://fanerge.github.io/">期望加入一个技术氛围nice的团队-成都</a></p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="external">Object.getOwnPropertySymbols</a><br><a href="https://github.com/Alvin-Liu/Blog/issues/8" target="_blank" rel="external">ES6时代，你真的会克隆对象吗？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有&lt;span style=&quot;color: red;&quot;&gt;String&lt;/span&gt;类型，ES6之后对象的属性有&lt;span
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>梳理下浏览器对象模型知识（BOM）</title>
    <link href="https://fanerge.github.io/%E6%A2%B3%E7%90%86%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%EF%BC%88BOM%EF%BC%89.html"/>
    <id>https://fanerge.github.io/梳理下浏览器对象模型知识（BOM）.html</id>
    <published>2018-03-12T12:41:17.000Z</published>
    <updated>2018-03-16T14:03:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。</p><h1 id="BOM介绍"><a href="#BOM介绍" class="headerlink" title="BOM介绍"></a>BOM介绍</h1><p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。<br>浏览器对象模型的构成<br><img src="http://p5hb0ypha.bkt.clouddn.com/BOM.svg" alt="浏览器对象模型的构成"></p><h1 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h1><p>Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。<br>在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。</p><h2 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" alt="Window对象的属性"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" target="_blank" rel="external">看不清，点这里</a></p><h2 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" alt="Window对象的方法"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h1><p>Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。<br>Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。<br><img src="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" alt="Location对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h1><p>History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。<br><img src="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" alt="History对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h1><p>Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。<br><img src="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" alt="Navigator对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h1><p>Screen 对象包含有关用户屏幕的信息。<br><img src="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" alt="Screen对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p><h1 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h1><p>Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。<br><img src="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" alt="document对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="external">看不清，点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。&lt;/p&gt;
&lt;h1 id=&quot;BOM介绍&quot;&gt;&lt;a href=&quot;#BOM介绍&quot; class=&quot;head
      
    
    </summary>
    
      <category term="BOM" scheme="https://fanerge.github.io/categories/BOM/"/>
    
    
      <category term="BOM" scheme="https://fanerge.github.io/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj2</title>
    <link href="https://fanerge.github.io/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj2.html"/>
    <id>https://fanerge.github.io/前端常识-gj2.html</id>
    <published>2018-03-11T12:19:13.000Z</published>
    <updated>2018-03-11T13:08:28.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h1><ol><li>在浏览器地址栏输入URL</li><li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control<br>  HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期<br>  HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间    </li><li>浏览器解析URL获取协议，主机，端口，path    </li><li>浏览器组装一个HTTP（GET）请求报文    </li><li>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存<br>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li><li>打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z</li><li>TCP链接建立后发送HTTP请求    </li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序    </li><li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码    </li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作    </li><li>服务器将响应报文通过TCP连接发送回浏览器    </li><li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同    </li><li>如果资源可缓存，进行缓存    </li><li>对响应进行解码（例如gzip压缩）    </li><li>根据资源类型决定如何处理（假设资源为HTML文档）    </li><li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释    </li><li>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树    </li><li>解析过程中遇到图片、样式表、js文件，启动下载    </li><li>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</li><li>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式</li><li>js解析如下：<br>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading<br>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素<br>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</li><li>显示页面（HTML解析过程中会逐步显示页面）<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="CSS选择器有哪些"><a href="#CSS选择器有哪些" class="headerlink" title="CSS选择器有哪些"></a>CSS选择器有哪些</h2></li></ol><ul><li>通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+<br>#X id选择器：选择id值为X的元素，兼容性：IE6+<br>.X 类选择器： 选择class包含X的元素，兼容性：IE6+<br>X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+<br>X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+<br>:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+<br>X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+<br>X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+<br>X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+<br>[attr]：选择所有设置了attr属性的元素，兼容性IE7+<br>[attr=value]：选择属性值刚好为value的元素<br>[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素<br>[attr|=value]：选择属性值刚好为value或者value-开头的元素<br>[attr^=value]：选择属性值以value开头的元素<br>[attr$=value]：选择属性值以value结尾的元素<br>[attribute*=value]：选择属性值中包含value的元素<br>X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+<br>:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+<br>:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+<br>::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+<br>::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+<br>:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+<br>:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+<br>X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+<br>X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+<br>X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+<br>X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+<br>X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+<br>X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+<br>X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+<h2 id="css-sprite是什么-有什么优缺点"><a href="#css-sprite是什么-有什么优缺点" class="headerlink" title="css sprite是什么,有什么优缺点"></a>css sprite是什么,有什么优缺点</h2>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。<br>优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br>缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要从新布局整个图片，样式<h2 id="display-none-与visibility-hidden-的区别"><a href="#display-none-与visibility-hidden-的区别" class="headerlink" title="display: none;与visibility: hidden;的区别"></a>display: none;与visibility: hidden;的区别</h2>相同点：它们都能让元素不可见<br>区别：<br>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见<br>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式<br>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。<br>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容<h2 id="specified-value-computed-value-used-value计算方法"><a href="#specified-value-computed-value-used-value计算方法" class="headerlink" title="specified value,computed value,used value计算方法"></a>specified value,computed value,used value计算方法</h2>specified value: 计算方法如下：<br>  如果样式表设置了一个值，使用这个值<br>  如果没有设置值，这个属性是继承属性，从父元素继承<br>  如果没设置，并且不是继承属性，使用css规范指定的初始值及浏览器初始值<br>computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承<br>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局，<br>  background-position<br>  bottom, left, right, top<br>  height, width<br>  margin-bottom, margin-left, margin-right, margin-top<br>  min-height, min-width<br>  padding-bottom, padding-left, padding-right, padding-top<br>  text-indent<h2 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h2>  link是HTML方式， @import是CSS方式<br>  link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC无样式内容闪烁(Flash Of Unstyled Content)<br>  link可以通过rel=”alternate stylesheet”指定候选样式<br>  浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br>  @import必须在样式规则之前，可以在css文件中引用其他文件<br>  总体来说：link优于@import<h2 id="display-block-和display-inline-的区别"><a href="#display-block-和display-inline-的区别" class="headerlink" title="display: block;和display: inline;的区别"></a>display: block;和display: inline;的区别</h2>block元素特点：<br>  1.处于常规流中时，如果width没有设置，会自动填充满父容器<br>  2.可以应用margin/padding<br>  3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素<br>  4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）<br>  5.忽略vertical-align<br>inline元素特点<br>  1.水平方向上根据direction依次布局<br>  2.不会在元素前后进行换行<br>  3.受white-space控制<br>  4.margin/padding在竖直方向上无效，水平方向上有效<br>  5.width/height属性对非替换行内元素无效，宽度由元素内容决定<br>  6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定<br>  6.浮动或绝对定位时会转换为block<br>  7.vertical-align属性生效<h2 id="PNG-GIF-JPG-webp-svg的区别及如何选"><a href="#PNG-GIF-JPG-webp-svg的区别及如何选" class="headerlink" title="PNG,GIF,JPG,webp,svg的区别及如何选"></a>PNG,GIF,JPG,webp,svg的区别及如何选</h2>GIF:<br>  8位像素，256色<br>  无损压缩<br>  支持简单动画<br>  支持boolean透明<br>  适合简单动画<br>JPEG：<br>  颜色限于256<br>  有损压缩<br>  可控制压缩质量<br>  不支持透明<br>  适合照片<br>PNG：<br>  有PNG8和truecolor PNG<br>  PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画<br>  适合图标、背景、按钮<br>未来趋势：<br>  webp（google推出的图片格式，目前存在浏览器兼容）<br>  svg（矢量图如：iconfont）<h2 id="CSS有哪些继承属性"><a href="#CSS有哪些继承属性" class="headerlink" title="CSS有哪些继承属性"></a>CSS有哪些继承属性</h2>关于文字排版的属性如：<br>  font<br>  word-break<br>  letter-spacing<br>  text-align<br>  text-rendering<br>  word-spacing<br>  white-space<br>  text-indent<br>  text-transform<br>  text-shadow<br>line-height<br>color<br>visibility<br>cursor<h2 id="容器包含若干浮动元素时如何清理-包含-浮动"><a href="#容器包含若干浮动元素时如何清理-包含-浮动" class="headerlink" title="容器包含若干浮动元素时如何清理(包含)浮动"></a>容器包含若干浮动元素时如何清理(包含)浮动</h2>容器元素闭合标签前添加额外元素并设置clear: both<br>父元素触发块级格式化上下文(见块级可视化上下文部分)<br>设置容器元素伪元素进行清理推荐的清理浮动方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 在标准浏览器下使用</div><div class="line">* 1 content内容为空格用于修复opera下文档中出现</div><div class="line">*   contenteditable属性时在清理浮动元素上下的空白</div><div class="line">* 2 使用display使用table而不是block：可以防止容器和</div><div class="line">*   子元素margin-top折叠,这样能使清理效果与BFC，IE6/7</div><div class="line">*   zoom: 1;一致</div><div class="line">* 3 overflow: hidden;</div><div class="line">**/</div><div class="line"></div><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">    content: &quot; &quot;; /* 1 */</div><div class="line">    display: table; /* 2 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">.clearfix:after &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* IE 6/7下使用</div><div class="line">* 通过触发hasLayout实现包含浮动</div><div class="line">**/</div><div class="line">.clearfix &#123;</div><div class="line">    *zoom: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="什么是FOUC-如何避免"><a href="#什么是FOUC-如何避免" class="headerlink" title="什么是FOUC?如何避免"></a>什么是FOUC?如何避免</h2><p>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head使用link元素。</p><h2 id="什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用"><a href="#什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用" class="headerlink" title="什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用"></a>什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于布局中的普通流。<br>创建规则：<br>    根元素<br>    浮动元素（float不是none）<br>    绝对定位元素（position取值为absolute或fixed）<br>    display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素<br>    overflow不是visible的元素<br>作用：<br>    可以包含浮动元素（父布局overflow: hidden）<br>    不被浮动元素覆盖（两列自适应布局：子1浮动，子2不浮动且有overflow: hidden）<br>    阻止父子元素的margin折叠（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中）<br><img src="https://zhuanlan.zhihu.com/p/25321647" alt="https://zhuanlan.zhihu.com/p/25321647"></p><h2 id="display-float-position的关系"><a href="#display-float-position的关系" class="headerlink" title="display,float,position的关系"></a>display,float,position的关系</h2><p>如果display为none，那么position和float都不起作用，这种情况下元素不产生框<br>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。<br>否则，如果float不是none，框是浮动的，display根据下表进行调整<br>否则，如果元素是根元素，display根据下表进行调整<br>其他情况下display的值为指定值<br>总结起来：绝对定位、浮动、根元素都需要调整display</p><h2 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h2><p>毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下：<br>1.两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠<br>2.浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠<br>3.创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠<br>4.元素自身的margin-bottom和margin-top相邻时也会折叠</p><h2 id="如何确定一个元素的包含块-containing-block"><a href="#如何确定一个元素的包含块-containing-block" class="headerlink" title="如何确定一个元素的包含块(containing block)"></a>如何确定一个元素的包含块(containing block)</h2><p>1.根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。<br>2.position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成。<br>3.如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area<br>4.如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下：<br>    如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element.<br>    其他情况下包含块由祖先节点的padding edge组成<br>如果找不到定位的祖先元素，包含块为初始包含块</p><h2 id="stacking-context-布局规则"><a href="#stacking-context-布局规则" class="headerlink" title="stacking context,布局规则"></a>stacking context,布局规则</h2><p>z轴上的默认层叠顺序如下（从下到上）：<br>    根元素的边界和背景<br>    常规流中的元素按照html中顺序<br>    浮动块<br>    positioned元素按照html中出现顺序<br>如何创建stacking context：<br>    根元素<br>    z-index不为auto的定位元素<br>    a flex item with a z-index value other than ‘auto’<br>    opacity小于1的元素<br>    在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context</p><h2 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h2><p>如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现<br>如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。<br>如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto</p><h2 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h2><p>需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height<br><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="external">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术</a><br><a href="http://vanseodesign.com/css/vertical-centering/" target="_blank" rel="external">6 Methods For Vertical Centering With CSS</a></p><h1 id="JavaScript概念部分"><a href="#JavaScript概念部分" class="headerlink" title="JavaScript概念部分"></a>JavaScript概念部分</h1><h2 id="DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系"><a href="#DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系" class="headerlink" title="DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系"></a>DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</h2><p>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性<br>e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问<br>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）<br>e.propName返回值可能是字符串、布尔值、对象、undefined等<br>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性<br>一些布尔属性’<input hidden>‘的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property<br>像’<a href="../index.html">link</a>‘中href属性，转换成property的时候需要通过转换得到完整URL<br>一些attribute和property不是一一对应如：form控件中’input value=”hello”‘对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</p><h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h2><p>offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同<br>clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸</p><h2 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h2><p>1.readyState:表示请求状态的整数，取值：<br>    UNSENT（0）：对象已创建<br>    OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求<br>    HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到<br>    LOADING(3)：响应体正在接收<br>    DONE(4)：数据传输完成或者传输产生错误<br>2.onreadystatechange：readyState改变时调用的函数<br>3.status：服务器返回的HTTP状态码（如，200， 404）<br>4.statusText:服务器返回的HTTP状态信息（如，OK，No Content）<br>5.responseText:作为字符串形式的来自服务器的完整响应<br>6.responseXML: Document对象，表示服务器的响应解析成的XML文档<br>7.abort():取消异步HTTP请求<br>8.getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行<br>9.getResponseHeader(headerName):返回headName对应的报头值<br>10.open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证<br>11.setRequestHeader(name, value):设置HTTP报头<br>12.send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</p><h2 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h2><p>mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持<br>mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能<br>标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素</p><h2 id="sessionStorage-localStorage-cookie区别"><a href="#sessionStorage-localStorage-cookie区别" class="headerlink" title="sessionStorage,localStorage,cookie区别"></a>sessionStorage,localStorage,cookie区别</h2><p>都会在浏览器端保存，有大小限制，同源限制<br>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器<br>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie<br>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除<br>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享<br>localStorage的修改会促发其他文档窗口的update事件<br>cookie有secure属性要求HTTPS传输<br>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</p><h2 id="javascript跨域通信"><a href="#javascript跨域通信" class="headerlink" title="javascript跨域通信"></a>javascript跨域通信</h2><p>同源：两个文档同源需满足<br>    协议相同<br>    域名相同<br>    端口相同<br>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法<br>如果是log之类的简单单项通信，新建img,script,link,iframe元素，通过src，href属性设置为目标url。实现跨域请求<br>如果请求json数据，使用script进行jsonp请求<br>现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用<br>内部服务器代理请求跨域url，然后返回数据<br>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源</p><h2 id="javascript有哪几种数据类型"><a href="#javascript有哪几种数据类型" class="headerlink" title="javascript有哪几种数据类型"></a>javascript有哪几种数据类型</h2><p>六种基本数据类型<br>    undefined<br>    null<br>    string<br>    boolean<br>    number<br>    symbol(ES6)<br>一种引用类型<br>    Object</p><h2 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h2><p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：<br>    函数本身作用域。<br>    闭包定义时的作用域。<br>    全局作用域。<br>闭包常见用途：<br>    创建特权方法用于访问控制<br>    事件处理程序及回调</p><h2 id="javascript有哪几种方法定义函数"><a href="#javascript有哪几种方法定义函数" class="headerlink" title="javascript有哪几种方法定义函数"></a>javascript有哪几种方法定义函数</h2><p>函数声明表达式<br>function操作符<br>Function 构造函数<br>ES6:arrow function</p><h2 id="应用程序存储和离线web应用"><a href="#应用程序存储和离线web应用" class="headerlink" title="应用程序存储和离线web应用"></a>应用程序存储和离线web应用</h2><p>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:’<html manifest="myapp.appcache">‘，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"></div><div class="line">CACHE:</div><div class="line">myapp.html</div><div class="line">myapp.css</div><div class="line">myapp.js</div><div class="line"></div><div class="line">FALLBACK:</div><div class="line">videos/ offline_help.html</div><div class="line"></div><div class="line">NETWORK:</div><div class="line">cgi/</div></pre></td></tr></table></figure></html></p><h2 id="客户端存储localStorage和sessionStorage"><a href="#客户端存储localStorage和sessionStorage" class="headerlink" title="客户端存储localStorage和sessionStorage"></a>客户端存储localStorage和sessionStorage</h2><p>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前<br>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。<br>Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key</p><h2 id="cookie及其操作"><a href="#cookie及其操作" class="headerlink" title="cookie及其操作"></a>cookie及其操作</h2><p>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。<br>通过读写cookie检测是否支持<br>cookie属性有name，value，max-age，path, domain，secure；<br>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期<br>cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问<br>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下<br>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</p><h2 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h2><p>对象字面量： var obj = {};<br>构造函数： var obj = new Object();<br>Object.create(): var obj = Object.create(Object.prototype); // Object.create(proto[, propertiesObject])</p><h2 id="运算符判断相等的流程是怎样的"><a href="#运算符判断相等的流程是怎样的" class="headerlink" title="===运算符判断相等的流程是怎样的"></a>===运算符判断相等的流程是怎样的</h2><p>如果两个值不是相同类型，它们不相等<br>如果两个值都是null或者都是undefined，它们相等<br>如果两个值都是布尔类型true或者都是false，它们相等<br>如果其中有一个是NaN，它们不相等<br>如果都是数值型并且数值相等，他们相等， -0等于0<br>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同和=都认为他们不相等<br>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</p><h2 id="运算符判断相等的流程是怎样的-1"><a href="#运算符判断相等的流程是怎样的-1" class="headerlink" title="==运算符判断相等的流程是怎样的"></a>==运算符判断相等的流程是怎样的</h2><p>如果两个值类型相同，按照===比较方法进行比较<br>如果类型不同，使用如下规则进行比较<br>如果其中一个值是null，另一个是undefined，它们相等<br>如果一个值是数字另一个是字符串，将字符串转换为数字进行比较<br>如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较<br>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较<br>其他所有情况都认为不相等</p><h2 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h2><p>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果<br>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果<br>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</p><h2 id="对象到数字的转换步骤"><a href="#对象到数字的转换步骤" class="headerlink" title="对象到数字的转换步骤"></a>对象到数字的转换步骤</h2><ol><li>如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果</li><li>否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果</li><li>否则，throws a TypeError<h2 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;,&gt;,&lt;=,&gt;=的比较规则"></a>&lt;,&gt;,&lt;=,&gt;=的比较规则</h2>所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:<br>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错<br>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）<br>否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较<h2 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h2>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象<br>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参<br>arguments.length为实参的个数（Function.length表示形参长度）<br>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化<br>arguments.caller为调用当前函数的函数（已被遗弃）<br>转换为数组：var args = Array.prototype.slice.call(arguments, 0);    <h2 id="列举数组相关的常用方法"><a href="#列举数组相关的常用方法" class="headerlink" title="列举数组相关的常用方法"></a>列举数组相关的常用方法</h2>参考答案: push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter<h2 id="列举字符串相关的常用方法"><a href="#列举字符串相关的常用方法" class="headerlink" title="列举字符串相关的常用方法"></a>列举字符串相关的常用方法</h2>参考答案: indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase<h2 id="请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”"><a href="#请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”" class="headerlink" title="请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”"></a>请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];</div><div class="line">var date = new Date();</div><div class="line"></div><div class="line">console.log(&apos;今天是星期&apos; + days[date.getDay()]);</div></pre></td></tr></table></figure></li></ol><h2 id="js里的作用域是什么样子的？"><a href="#js里的作用域是什么样子的？" class="headerlink" title="js里的作用域是什么样子的？"></a>js里的作用域是什么样子的？</h2><p>参考答案：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined.</p><pre><code>var globalVar = &apos;global var&apos;;function test() {alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义var globalVar = &apos;overrided var&apos;; //　globalVar在本函数内被重定义alert(globalVar);　// overrided var}alert(globalVar); // global var，使用全局变量</code></pre><h2 id="js里边的this指的是什么"><a href="#js里边的this指的是什么" class="headerlink" title="js里边的this指的是什么?"></a>js里边的this指的是什么?</h2><p>参考答案: this指的是对象本身，而不是构造函数．    </p><h2 id="apply-call和bind有什么区别"><a href="#apply-call和bind有什么区别" class="headerlink" title="apply, call和bind有什么区别?"></a>apply, call和bind有什么区别?</h2><p>参考答案：三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，    </p><h2 id="caller-callee和arguments分别是什么"><a href="#caller-callee和arguments分别是什么" class="headerlink" title="caller, callee和arguments分别是什么?"></a>caller, callee和arguments分别是什么?</h2><p>参考答案: caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot;&gt;&lt;a href=&quot;#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例&quot; class=&quot;headerlink&quot; title=&quot;从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)&quot;&gt;&lt;/a&gt;从
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Babel工作原理及Babel插件开发探索</title>
    <link href="https://fanerge.github.io/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8ABabel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2.html"/>
    <id>https://fanerge.github.io/Babel工作原理及Babel插件开发探索.html</id>
    <published>2018-03-04T12:46:18.000Z</published>
    <updated>2018-03-04T13:25:41.481Z</updated>
    
    <content type="html"><![CDATA[<p>在掘金上看见了<a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒</a>，正巧自己对Babel工作原理和Babel插件开发也不够了解，赶紧来补一波吧。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>首先我们这里需要了解一些基本的概念，<a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">这篇文章介绍的很详细</a>，我这边只提一下。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。<br>意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。<br>和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。<br>一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote><p>   静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。<br>静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p></blockquote><h1 id="Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）"><a href="#Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）" class="headerlink" title="Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）"></a>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接收代码并输出AST。这个步骤又分为两个阶段：词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段把字符串形式的代码转换成令牌（tokens）流。<br>你可以把令牌看作是一个扁平化的语法片段数组。<br>如：n*n代码经过词法分析转换成令牌<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// n*n</div><div class="line">[</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</div><div class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</div><div class="line">  ...</div><div class="line">]</div></pre></td></tr></table></figure></p><p>每一个type有一组属性来描述该令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &#123;</div><div class="line">    label: &apos;name&apos;,</div><div class="line">    keyword: undefined,</div><div class="line">    beforeExpr: false,</div><div class="line">    startsExpr: true,</div><div class="line">    rightAssociative: false,</div><div class="line">    isLoop: false,</div><div class="line">    isAssign: false,</div><div class="line">    prefix: false,</div><div class="line">    postfix: false,</div><div class="line">    binop: null,</div><div class="line">    updateContext: null</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析阶段会把一个令牌(tokens)流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。<br>这个过程我们可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">astexplorer</a>来查看我们代码生成的AST。<br>这个时候我们的AST就产生了，如下图。<br><img src="http://p52glq5m1.bkt.clouddn.com/ASTdemo1.png" alt="源代码到AST"><br>PS：上图左边为我们的源代码，右边为对应生成的抽象语法树AST。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。<br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。<br>Babel工作原理见下图表示。<br><img src="http://p52glq5m1.bkt.clouddn.com/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="Babel工作原理"><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">图片来源，探索 babel 和 babel 插件是怎么工作的</a></p><h1 id="开发一个Babel插件"><a href="#开发一个Babel插件" class="headerlink" title="开发一个Babel插件"></a>开发一个Babel插件</h1><h2 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a>Visitors（访问者）</h2><p>当我们谈及“进入”一个节点，实际上是说我们在访问它们， 之所以使用这样的术语是因为有一个访问者模式（visitor）的概念。<br>访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const MyVisitor = &#123;</div><div class="line">  Identifier: &#123;</div><div class="line">// 当进入Identifier节点的时候执行</div><div class="line">enter() &#123; </div><div class="line">  console.log(&quot;Entered&quot;);</div><div class="line">&#125;,</div><div class="line">// 当退出Identifier节点的时候执行</div><div class="line">exit() &#123;</div><div class="line">      console.log(&quot;Exited!&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>PS： 许多时候我们只需要关心进入节点，就可以使用简写 Identifier() { … } 或者 Identifier: { enter() { … } } 。<br>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier里面的enter方法和exit方法。</p><h2 id="Paths（路径）"><a href="#Paths（路径）" class="headerlink" title="Paths（路径）"></a>Paths（路径）</h2><blockquote><p>   我们通过 visitor可以在遍历到对应节点执行对应的函数，当需要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置 （即和其他节点间的关系）, visitor在遍历到对应节点执行对应函数时候会给我们传入 path参数，辅助我们完成上面这些操作。注意 Path 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了 Identifier节点，它传入的 path参数看起来是这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;parent&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;VariableDeclarator&quot;,</div><div class="line">    &quot;id&quot;: &#123;</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    ....</div><div class="line">  &#125;,</div><div class="line">  &quot;node&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;Identifier&quot;,</div><div class="line">    &quot;name&quot;: &quot;...&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里就可以通过：path.node.name 获得当前节点的name；path.parent.id 获得父节点的id<br>另外path对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。</p><h2 id="开始动手写插件了"><a href="#开始动手写插件了" class="headerlink" title="开始动手写插件了"></a>开始动手写插件了</h2><p>输入的源代码为：<br><code>yuzhenfan === wangkemei</code><br>生成的AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &quot;BinaryExpression&quot;,</div><div class="line">  operator: &quot;===&quot;,</div><div class="line">  left: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;,</div><div class="line">  right: &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;yuzhenfan&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>省略部分属性，可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="external">http://astexplorer.net</a>查看全部属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const babel = require(&apos;babel-core&apos;)</div><div class="line"></div><div class="line">// 我们的babel插件</div><div class="line">let MyVisitor = function(&#123; types: t &#125;) &#123;</div><div class="line">  return &#123;</div><div class="line">    visitor: &#123;</div><div class="line"></div><div class="line">      BinaryExpression(path) &#123;</div><div class="line">  </div><div class="line">        if (path.node.operator !== &quot;===&quot;) &#123;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 改变当前节点的left、right（插件的核心代码）</div><div class="line">path.node.left = t.identifier(&quot;fanerge1&quot;);</div><div class="line">path.node.right = t.identifier(&quot;fanerge2&quot;);</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const code = `yuzhenfan === wangkemei;`;</div><div class="line"></div><div class="line">let demo = babel.transform(code, &#123;</div><div class="line">  // 使用我们的插件</div><div class="line">  plugins: [MyVisitor]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(demo); // fanerge1===fanerge2</div></pre></td></tr></table></figure></p><p>输出的代码为（经过我们的插件处理）：<br><code>fanerge1===fanerge2</code><br>下图为node打印出Balbel输出的代码：<br><img src="http://p52glq5m1.bkt.clouddn.com/result.png" alt="babel转换的代码"><br><a href="https://github.com/fanerge/babel_plugin" target="_blank" rel="external">项目地址，非常简单的Babel插件，后续再继续学习</a></p><blockquote><p>   参考文档<br><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-introduction" target="_blank" rel="external">Babel 插件手册</a><br><a href="https://github.com/estree/estree" target="_blank" rel="external">ESTree</a><br><a href="http://astexplorer.net/" target="_blank" rel="external">AST Explorer</a><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="external">探索 babel 和 babel 插件是怎么工作的</a><br><a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="external">掘金-babel插件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在掘金上看见了&lt;a href=&quot;https://juejin.im/post/5a9315e46fb9a0633a711f25&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒&lt;/a&gt;，正
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="Babel" scheme="https://fanerge.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>浏览器工作原理-webkit内核研究</title>
    <link href="https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html"/>
    <id>https://fanerge.github.io/浏览器工作原理-webkit内核研究.html</id>
    <published>2018-03-03T02:10:00.000Z</published>
    <updated>2018-03-03T04:32:43.412Z</updated>
    
    <content type="html"><![CDATA[<p>从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。<br>主要查阅了<a href="https://book.douban.com/subject/25910556/" target="_blank" rel="external">WebKit技术内幕</a>、<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>、<a href="https://www.w3.org/" target="_blank" rel="external">W3C</a>等网站资料，下文中有若干图片摘自于《WebKit技术内幕》，在此表示感谢。<br>本文略长，如有不适，实属意外。如有不正确的地方，还望指正，毕竟传播真理才不会误导其他同学，共同进步才是目的。</p><h1 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h1><p>浏览器内核由渲染引擎和JS引擎组成，不同的浏览器、即使同一浏览器不同型号可能渲染引擎和JS引擎都不一样。</p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>1)Trident渲染引擎 –&gt; 老版本IE系列浏览器<br>2)Edge渲染引擎 -&gt; Win10中IE浏览器<br>3)Gecko渲染引擎 –&gt; Mozilla Firefox<br>4)Presto渲染引擎 –&gt; Opera<br>5)KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome<br>6)Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器<br>7)Blink渲染引擎 -&gt; 新版本的Chromium浏览器Google项目</p><h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h2><p>1)JScript引擎 –&gt; IE系列浏览器<br>2)spiderMonkey引擎 –&gt; Mozilla Firefox<br>3)V8引擎 –&gt; Google Chrome<br>4)linear b/futhark引擎 –&gt; Opera</p><h2 id="浏览器渲染引擎的进度史"><a href="#浏览器渲染引擎的进度史" class="headerlink" title="浏览器渲染引擎的进度史"></a>浏览器渲染引擎的进度史</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" alt="浏览器渲染引擎的进度史"><br>为大家提供两个开发常用查询网站：<br><a href="http://html5test.com/" target="_blank" rel="external">该浏览器对html5的支持程度</a><br><a href="https://caniuse.com" target="_blank" rel="external">不同与Can I use</a></p><h1 id="浏览器的渲染引擎及依赖模块分析"><a href="#浏览器的渲染引擎及依赖模块分析" class="headerlink" title="浏览器的渲染引擎及依赖模块分析"></a>浏览器的渲染引擎及依赖模块分析</h1><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%9F%E8%83%BD.png" alt="渲染引擎的功能"><br>上图中虚线部分表示渲染引擎所提供的功能。<br>这里渲染引擎包含了JavaScript引擎，许多时候两者都不太区分。<br>下面的内容大部分都是基于这张图来分析的，我们将逐步解释从用户输入URL到页面展示给用户这个过程中都发生了什么？<br>我们先了解网页的基础知识。</p><h1 id="网页基础知识"><a href="#网页基础知识" class="headerlink" title="网页基础知识"></a>网页基础知识</h1><p>html – 结构<br>css – 样式<br>JavaScript – 行为<br>还需要一些静态资源：png、gif、webp、MP4、font、svg等等。<br>由上面几部分就构成我们的网页。</p><h2 id="输入URL到页面展示简图"><a href="#输入URL到页面展示简图" class="headerlink" title="输入URL到页面展示简图"></a>输入URL到页面展示简图</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/url%E5%88%B0dom%E6%A0%91.png" alt="URL到页面展示"><br>读者不要太关心上图所标的顺序，在某些时候可能会有出入。</p><h2 id="浏览器内核各部分解释"><a href="#浏览器内核各部分解释" class="headerlink" title="浏览器内核各部分解释"></a>浏览器内核各部分解释</h2><blockquote><p>   HTML解释器：解释HTML文本的解释器，主要作用是将HTML文本解释成DOM树，DOM是一种文档表示方法。<br>CSS解释器：级联样式表的解释器，它的作用是为DOM中的各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。<br>布局：在DOM创建之后，webkit需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部比偶表示模型。<br>JavaScript引擎：使用JavaScript代码可以修改网页的内容，也能修改CSS的信息，JavaScript引擎能过解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染结果。<br>绘图：使用图形库将布局计算后的各个网页的节点绘制成图像结果。</p></blockquote><p>PS：这些模块依赖许多其他基础模块，其中包括网络、存储、2D/3D图形、音频视频和图片解码器等。这里就不对基础模块做相应说明了。</p><p>下面，我就逐个过程进行分析，我这里省略一些非本文目的的过程，如DNS环节。</p><h1 id="HTML解释器"><a href="#HTML解释器" class="headerlink" title="HTML解释器"></a>HTML解释器</h1><p>先来看看HTML解释器工作原理<br><img src="http://p4yvw0vpm.bkt.clouddn.com/html%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="HTML解释器工作原理"><br>字节流（Bytes）–&gt; 字符流（Characters）–&gt; 词语（Tokens）–&gt; 节点 –&gt; DOM树</p><blockquote><p>   首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），时候经过分析器构建成节点，最后这些节点被组建成一棵DOM树。<br>词法分析：HTMLTokenizer 类（作用是词法分析，类似于状态机），输入的是字符串，输出的是一个个的词语。<br>XSSAuditor验证词语：XSSAuditor （验证词语流Token Stream）XSS指的是Cross Site Security，主要是针对安全方面的考虑。<br>词语到节点：webkit用来构建DOM节点，这一步骤由HTMLDocumentParser 类调用 HTMLTreeBuilder 类的 constructTree的函数来实现。<br>节点到DOM树：树中的元素节点创建属性节点等工作由HTMLConstructionSite类来完成，该类中包含一个 HTMLElementStack 作为保存元素节点的栈。<br>JavaScript的执行：webkit将DOM树创建过程中需要执行得我Javascript代码交由HTMLScriptRunner类来负责。<br>DOM的事件机制：webkit中用EventTarget类来表示DOM规范中Events部分定义的事件目标，Node 节点继承自 EventTarget类，所以Node拥有EventTarget类的相关的方法。</p></blockquote><p>这里需要提一下W3C新规范，影子（Shadow）DOM<br>Shadow DOM API的 ShadowRoot接口是一个DOM子树的根节点, 它与文档的主DOM树分开渲染。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ShadowRoot" target="_blank" rel="external">MDN-影子节点</a></p><h2 id="影子（Shadow）DOM"><a href="#影子（Shadow）DOM" class="headerlink" title="影子（Shadow）DOM"></a>影子（Shadow）DOM</h2><p>定义：Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。<br>ShadowRoot 类继承自 DocumentFragment 类。<br>PS：可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.</p><h1 id="CSS解释器和样式布局"><a href="#CSS解释器和样式布局" class="headerlink" title="CSS解释器和样式布局"></a>CSS解释器和样式布局</h1><p>先看看CSS怎么和DOM结合展示页面的呢？<br><img src="http://p4yvw0vpm.bkt.clouddn.com/css%E5%92%8Cdom%E6%A0%91%E5%88%B0%E7%BB%98%E5%88%B6%E7%BD%91%E9%A1%B5.png" alt="CSS+DOM形成简单页面"><br>css解释器和规则匹配处于DOM树建立之后，RenderObject树建立之前，css解释器解释后的结果会保存起来，然后RenderObject树基于该结果来进行规范匹配和布局计算。</p><h2 id="CSSOM（CSS-Object-Model）"><a href="#CSSOM（CSS-Object-Model）" class="headerlink" title="CSSOM（CSS Object Model）"></a>CSSOM（CSS Object Model）</h2><p>CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动。<br>document.styleSheets 可以查看当前页面的StyleSheetList对象，每个link、style都会产生 CSSStyleSheet 作为 StyleSheetList对象的value。</p><h2 id="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"><a href="#CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）" class="headerlink" title="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"></a>CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）</h2><p>DocumentStyleSheetCollection类（属于Document类），该类包含了所有CSS样式表，还包括了webkit的内部表示类CSSStyleSheet，它包含了CSS的href、类型、内容等信息。<br>CSS解释过程：css字符串经过css解释器处理后变成渲染引擎的内部规则的过程，使用CSSParser类来负责该过程。<br>在解释网页中自定义的CSS样式之前，实际上webkit渲染引擎会为每个网页设置一个默认样式，这也是我们为什么要重置浏览器样式的根本原因。<br>规则匹配：StyleResolver类为DOM的元素节点匹配样式，StyleResolver类根据元素的信息，例如标签名、类别等，从样式规则中查找最匹配的规则，然后将样式信息保存到新建的RenderStyle对象中。最后，这些RenderStyle对象被RenderObject类所管理和使用。<br>    其中，规则的匹配则是由ElementRuleCollector类来计算并获得，它根据元素的属性等信息，并从DocumentRuleSets类中获取规则集合，依次按照ID、CLASS、标签等选择器信息逐次匹配获得元素的样式。<br>    然后webkit对这些规则进行排序，对于该元素需要的样式属性，webkit选择从高优先级规则中选取，并将样式属性值返回。<br>这里，我引入一个不太相关的知识点，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">不太了解的同学，请异步MDN-BFC</a></p><h1 id="webkit布局"><a href="#webkit布局" class="headerlink" title="webkit布局"></a>webkit布局</h1><p>当webkit创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息的过程称为布局计算/排版。<br>    布局计算分类：第一类是对整个RenderObject树进行的计算；第二类是对RenderObject树中某个子树的计算，常见于文本元素或者overflow：auto块的计算。<br>    布局计算：布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。</p><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>我们常说的reflow和repaint。涉及到元素的几何属性改变会造成reflow会降低性能（transform、opacity等属性不会造成reflow）。<br>扩展为什么说transform实现动画较直接设置几何属性性能较好？<br>1.webkit渲染过程：style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite，transform是位于’Composite（渲染层合并）‘，而width、left、margin等则是位于‘Layout（布局）’层，这必定导致reflow。<br>2.现代浏览器针对transform等开启GPU加速。<br>    style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite（transform发生在这个时候）<br>由这个过程我们可以看出，这也是为什么发生reflow必定会发生repaint的根本原因。<br><a href="https://www.w3cplus.com/animation/animation-performance.html" target="_blank" rel="external">CSS Animation性能优化</a><br><a href="https://segmentfault.com/a/1190000008650975" target="_blank" rel="external">从重绘重排角度讲解transform的动画性能</a></p><h1 id="渲染过程的一些理论"><a href="#渲染过程的一些理论" class="headerlink" title="渲染过程的一些理论"></a>渲染过程的一些理论</h1><p>RenderObject树同其他树（如RenderLayer树等），构成了webkit渲染的主要基础设施。</p><h2 id="RenderObject树（DOM树-gt-RenderObject树）"><a href="#RenderObject树（DOM树-gt-RenderObject树）" class="headerlink" title="RenderObject树（DOM树 -&gt; RenderObject树）"></a>RenderObject树（DOM树 -&gt; RenderObject树）</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/DOM%E5%88%B0RenderObject.png" alt="DOM到RenderObject"><br>一个RenderObject对象保存了为绘制DOM节点所需要的各种信息，例如样式布局信息，经过webkit的处理之后，RenderObject对象知道如何绘制自己。<br>下列情况会使DOM树节点创建一个RenderObject对象（DOM和RenderObject并非一一对应）。<br>1.DOM树的document节点。<br>2.DOM树种的可视节点，例如html、body、div等。而webkit不会为非可视化节点创建RenderObject节点，例如meta、script。<br>3.某些情况下webkit需要建立匿名的RenderObject节点，该节点不对应于DOM树种的任何节点，而是webkit处理上的需要，典型的例子例如匿名的RenderBlock节点。<br>在html组建页面结构时，webkit为了提升网页性能，会引入分层结构。</p><h2 id="网页层次结构（css也会对网页的分层策略产生重要影响）"><a href="#网页层次结构（css也会对网页的分层策略产生重要影响）" class="headerlink" title="网页层次结构（css也会对网页的分层策略产生重要影响）"></a>网页层次结构（css也会对网页的分层策略产生重要影响）</h2><p>对于一个html文件webkit会为某些元素和它的子节点建立新层，这样webkit可以单独对某层操作提升性能，下列情况会产生新层。<br>1.video标签 – webkit在新层中有效的处理视频解码器和浏览器之间的交互和渲染问题。<br>2.div、p等普通标签 – 涉及到3D变换时。<br>3.canvas标签 – 复杂的2D和3D绘图操作。</p><h2 id="RenderLayer树"><a href="#RenderLayer树" class="headerlink" title="RenderLayer树"></a>RenderLayer树</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/RenderObject%E5%88%B0RenderLayer.png" alt="RenderObject到RenderLayer"><br>webkit会为网页的层次创建相应的RenderLayer对象。当某些类型RenderObject的节点或者某些css样式的RenderObject节点出现的时候，webkit就会为这些节点创建RenderLayer对象。<br>RenderLayer树是基于RenderObject树建立起来的一棵新树。RenderLayer节点和RenderObject节点不是一一对应关系，而是一对多的关系。<br>哪些情况下的RenderObject节点需要建立新的RenderLayer节点呢？<br>1.DOM树的Document节点对应的RenderView节点。<br>2.DOM树中的Document的子节点，也就是HTML节点对应RenderBlock节点。<br>3.显式的制定css位置的RenderObject节点。<br>4.有透明效果的RenderObject节点。<br>5.节点有溢出（overflow）、alpha或者反射效果的RenderObject节点。<br>6.使用Canvas 2D和3D（WebGL）技术的RenderObject节点。<br>7.Video节点对应的RenderObject节点。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><p>绘图上下文（绘图上下文可以分成两种类型）：<br>    第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）。<br>    第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）。<br>网页的三种渲染方式：<br>1.软件渲染（CPU内存）<br>2.使用软件绘图的合成化渲染（GPU内存）css3D、WebGL<br>3.硬件加速的合成化渲染（GPU内存）</p><h2 id="webkit软件渲染技术"><a href="#webkit软件渲染技术" class="headerlink" title="webkit软件渲染技术"></a>webkit软件渲染技术</h2><p>在不需要硬件加速内容的时候（包括但不限于css3 3D变形、css3 3D变换、WebGL和视频），webkit就可以使用软件渲染技术来完成页面绘制。<br>对于每个RenderObject对象，需要三个阶段绘制自己：<br>第一阶段是绘制该层中所有块的背景和边框。<br>第二阶段是绘制浮动内容。<br>第三阶段是前景（Foreground），也就是内容部分、轮廓、字体颜色、大小等（内嵌元素的背景、边框等发生在这一阶段）。</p><h2 id="硬件加速机制"><a href="#硬件加速机制" class="headerlink" title="硬件加速机制"></a>硬件加速机制</h2><p>硬件加速技术是指使用GPU的硬件能力来帮助渲染网页（GPU的作用主要是用来绘制3D图形并且性能特别好）。</p><h3 id="Chrome的硬件加速机制"><a href="#Chrome的硬件加速机制" class="headerlink" title="Chrome的硬件加速机制"></a>Chrome的硬件加速机制</h3><p>canvas开发，可以将画布分解为更小的画布，这样在更新时只需要更新小画布从而减少开销。<br>css3 3D变形技术，它能过让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果（只触发Composite而不用触发style -&gt; Layout(reflow发生在这) -&gt; Paint）。</p><h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><p>WebGL是Khronous组织提出的一套基于3D图形定义的javascript接口。<br>它基于canvas元素，跟canvas2D不同的是，Web开发者可以使用3D图形接口来绘制各种3D图形。</p><h3 id="css-3D变形"><a href="#css-3D变形" class="headerlink" title="css 3D变形"></a>css 3D变形</h3><p>这里包括3D变形和动画。<br>webkit会建立一个新层来处理，从而提升性能。</p><h1 id="JavaScript引擎-1"><a href="#JavaScript引擎-1" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h1><p>推动JavaScript运行速度提高的利器JIT（Just-In-Time）。<br>JIT：就是代码在目标平台上运行的时候，实时的把代码编译为目标机器上的机器码。<br>编译原理：<br>C++：源代码 –&gt; 抽象语法树 –&gt; 本地代码<br>Java：源代码 –&gt; 抽象语法树  –&gt; 字节码（跨平台） –&gt; JIT –&gt; 本地代码</p><h2 id="V8的一些特性（这里太多了，读者可以自己深究）"><a href="#V8的一些特性（这里太多了，读者可以自己深究）" class="headerlink" title="V8的一些特性（这里太多了，读者可以自己深究）"></a>V8的一些特性（这里太多了，读者可以自己深究）</h2><p>常用的javascript引擎有v8和JavaScriptCore<br>工作原理<br>在js中，基本数据类型Boolean、Number、String、Null、Undefined、Symbol，其他数据都是对象。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>在V8中，数据的表示分成两个部分<br>    第一部分是数据的实际内容，它们是变长的，而且内容的类型也不一样，如String、对象等。<br>    第二部分是数据的句柄，句柄的大小是固定的，句柄中包含指向数据的指针。</p><h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>Handle：句柄类，主要用来管理基础数据和对象，以便被垃圾回收器操作。<br>主要有两个类型，一个Local类（继承自Handle类），表示本地栈上的数据，所以比较轻量。<br>另一个是Persistent类（继承自Handle类）表示函数间的数据和对象访问。<br>对于整形数据，由Handle本身来存储，同时也为了快速访问。<br>其他的数据都是从堆中申请内存来存储它们，由于其他数据类型，受限于Handle的大小和变长等原因，都存储在堆中。<br>V8的延迟（deferred）特性：它使的许多javascript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销。<br><img src="http://p4yvw0vpm.bkt.clouddn.com/javascript%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81.png" alt="v8将源代码-本地代码"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="常见的语言类型"><a href="#常见的语言类型" class="headerlink" title="常见的语言类型"></a>常见的语言类型</h3><p>机器语言（它是计算机唯一能直接执行的语言，电子计算机的机器指令是一列二进制数字。）<br>汇编语言 汇编指令是机器指令便于记忆的书写格式，但他需要进过编译器转换为机器语言，这样机器才能执行。</p><h3 id="使用setTimeout或setInterval较requestAnimationFrame的缺点？"><a href="#使用setTimeout或setInterval较requestAnimationFrame的缺点？" class="headerlink" title="使用setTimeout或setInterval较requestAnimationFrame的缺点？"></a>使用setTimeout或setInterval较requestAnimationFrame的缺点？</h3><p>时间间隔应该设置为多少才合适呢。<br>跟屏幕的分辨率有关吗（不同浏览器存在一个极小值）。<br>设置的时间会按照会准确执行吗。<br>动画会被平滑地显示效果吗。<br>回调函数时复杂的好还是简单的好呢。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="external">window.requestAnimationFrame</a></p><h1 id="其他浏览器相关知识"><a href="#其他浏览器相关知识" class="headerlink" title="其他浏览器相关知识"></a>其他浏览器相关知识</h1><h2 id="插件和Javascript扩展"><a href="#插件和Javascript扩展" class="headerlink" title="插件和Javascript扩展"></a>插件和Javascript扩展</h2><p>在早期的浏览器能力十分有限，Web前端开发者们希望能够通过一些机制来扩展浏览器的能力（插件机制如flash插件）。</p><h3 id="NPAPI全称叫-Netscape-plugin-API"><a href="#NPAPI全称叫-Netscape-plugin-API" class="headerlink" title="NPAPI全称叫 Netscape plugin API"></a>NPAPI全称叫 Netscape plugin API</h3><p>NPAPI是当今最流行的插件架构，几乎所有浏览器都支持，不过存在很大的安全隐患，插件可以窃取系统底层权限，发起恶意攻击。</p><h3 id="PPAPI也就是Pepper-Plugin-API"><a href="#PPAPI也就是Pepper-Plugin-API" class="headerlink" title="PPAPI也就是Pepper Plugin API"></a>PPAPI也就是Pepper Plugin API</h3><p>2010年，Google开发了新的PPAPI，将外挂插件全部放到沙盒里运行，2012年Windows、Mac版本的Chrome浏览器先后升级了PPAPI Flash Player，并希望今年底之前彻底淘汰NPAPI。</p><h2 id="JavaScript引擎的扩展机制"><a href="#JavaScript引擎的扩展机制" class="headerlink" title="JavaScript引擎的扩展机制"></a>JavaScript引擎的扩展机制</h2><p>通过如下url参看当前chrome浏览器安装的extensions<br>chrome://extensions/ </p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><p>WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="external">MDN-WebRTC</a><br>最重要的方法：navigator.mediaDevices.getUserMedia(constraints)<br>还有Video、Audio等。</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><p>第一部分是网页的安全，包括但是不限于网页数据安全传输、跨域访问、用户数据安全等。<br>第二部分是浏览器的安全，具体是指虽然网页或者Javascript代码有一些安全问题或者存在安全漏洞，浏览器也能够在运行它们的时候保证吱声的安全，不受到攻击从而泄漏数据或者使系统遭受破坏。</p><h3 id="网页安全模型"><a href="#网页安全模型" class="headerlink" title="网页安全模型"></a>网页安全模型</h3><p>安全模型基础：<br>域（Same Origin Policy）XMLHttpRequest、cookie的读写、DOM对象操作等。<br>XSS（Cross Site Scripting）执行跨域的js脚本代码。开发者可以将用户输入的数据进行字符转换来避免。webkit通过XSSAuditor对象帮我们过滤（默认开启）。<br>CSP （Content-Security-Policy）HTTP首部字段，内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。<br>CORS（Cross Origin Resource Sharing）跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。<br>    具体服务端代码设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 请求头</div><div class="line">header(&apos;Access-Control-Allow-Origin: http://arunranga.com&apos;); // </div><div class="line">header(&apos;Access-Control-Allow-Methods: POST, GET, OPTIONS&apos;);</div><div class="line">header(&apos;Access-Control-Allow-Headers: X-PINGARUNER&apos;);</div><div class="line">// 响应头</div><div class="line">Access-Control-Allow-Origin、</div><div class="line">Access-Control-Allow-Credentials、</div><div class="line">Access-Control-Allow-Headers、</div><div class="line">Access-Control-Expose-Headers、</div><div class="line">Access-Control-Allow-Methods、</div><div class="line">Access-Control-Max-Age</div></pre></td></tr></table></figure></p><p>Cross Document Messaging 通过 window.postMessage 和 message 事件来通信。<br>HTTPS（安全传输协议）<br>SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。    SPDY核心思想为多路复用。<br>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。</p><h4 id="CSP和CORS的区别："><a href="#CSP和CORS的区别：" class="headerlink" title="CSP和CORS的区别："></a>CSP和CORS的区别：</h4><p>CSP定义了网页自身能够访问的某些域和资源。<br>CORS定义一个网页如何才能访问被同源策略禁止的跨域资源，并规定了两者交互的协议和方式。</p><h3 id="沙箱模型"><a href="#沙箱模型" class="headerlink" title="沙箱模型"></a>沙箱模型</h3><p>浏览器的沙箱模型是利用系统提供的安全技术，让网页在执行过程中不会修改操作系统或者是访问系统中的隐私数据，而需要访问系统资源或者说是系统调用的时候，通过一个代理机制来完成。</p><h1 id="chrome浏览其使用技巧（以实用性排列）"><a href="#chrome浏览其使用技巧（以实用性排列）" class="headerlink" title="chrome浏览其使用技巧（以实用性排列）"></a>chrome浏览其使用技巧（以实用性排列）</h1><p>一下url直接输入在浏览器中，enter即可</p><table><thead><tr><th>URL</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>chrome://inspect</td><td style="text-align:center">移动端网页调试</td></tr><tr><td>chrome://net-internals</td><td style="text-align:center">net-internals是一套工具集合，用于帮助诊断网络请求与访问方面的问题，它通过监听和搜集 DNS，Sockets，SPDY，Caches等事件与数据来向开发者反馈各种网络请求的过程、状态以及可能产生影响的因素。如，查看DNS主机解析缓存chrome://net-internals/#dns</td></tr><tr><td>chrome://view-http-cache/</td><td style="text-align:center">查看内部存储内容及其详情</td></tr><tr><td>chrome://downloads/</td><td style="text-align:center">下载内容管理，其快捷键是Ctrl+J</td></tr><tr><td>chrome://extensions/</td><td style="text-align:center">扩展管理</td></tr><tr><td>chrome://bookmarks/</td><td style="text-align:center">书签管理  </td></tr><tr><td>chrome://history</td><td style="text-align:center">访问历史管理  </td></tr><tr><td>chrome://restart</td><td style="text-align:center">重启chrome浏览器 </td></tr><tr><td>chrome://apps</td><td style="text-align:center">chrome网上应用店  </td></tr><tr><td>chrome://flags/</td><td style="text-align:center">新特性管理 </td></tr><tr><td>chrome://dns</td><td style="text-align:center">查看DNS预取命名（从超链接等处来预测）  </td></tr><tr><td>chrome://quota-internals</td><td style="text-align:center">查看浏览器所使用磁盘空间配额 </td></tr><tr><td>chrome://settings</td><td style="text-align:center">浏览器的设置</td></tr><tr><td>chrome://sync-internals</td><td style="text-align:center">查看chrome 的同步状态 </td></tr><tr><td>chrome://about/</td><td style="text-align:center">查看所有chrome命令 </td></tr></tbody></table><p><a href="https://fanerge.github.io">期望加入一个技术氛围nice的团队-成都</a></p>]]></content>
    
    <summary type="html">
    
      webkit浏览器
    
    </summary>
    
      <category term="webkit" scheme="https://fanerge.github.io/categories/webkit/"/>
    
    
      <category term="浏览器" scheme="https://fanerge.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端常识-gj</title>
    <link href="https://fanerge.github.io/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj.html"/>
    <id>https://fanerge.github.io/前端常识-gj.html</id>
    <published>2018-02-09T12:36:22.000Z</published>
    <updated>2018-02-09T13:25:15.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-virtualDOM（batching）"><a href="#React-virtualDOM（batching）" class="headerlink" title="React virtualDOM（batching）"></a>React virtualDOM（batching）</h2><p>在React中，render执行的结果返回的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。<br>通过 React 的 diff，再由虚拟 DOM 来确保只对界面上真正变化的部分进行实际的DOM操作，这样就极大提升了性能。<br>batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。</p><blockquote><p>DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起30次（潜在的）布局重算，30次（潜在的）重绘。<br>当你在这个单独的 virtualDOM 树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。<br>一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。</p></blockquote><p><a href="https://www.jianshu.com/p/f75c1f0af3f0" target="_blank" rel="external">React中一个没人能解释清楚的问题——为什么要使用Virtual DOM</a></p><h2 id="React-diff"><a href="#React-diff" class="headerlink" title="React diff"></a>React diff</h2><p>React diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础。<br>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。<br>React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。<br>diff 策略（—为具体比对）<br>1.Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 — tree diff<br>2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 — component diff<br>3.对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 — element diff</p><h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%85.jpg" alt="tree-diff"></p><h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。<br>1.如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。<br>2.如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。<br>3.对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%851.jpg" alt="component diff"></p><h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。<br>1.INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。<br>2.MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。<br>3.REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。<br>React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，这也是为什么React建议我们在列表项目中添加key属性的原因！</p><p><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%852.jpg" alt="element diff"><br><a href="https://zhuanlan.zhihu.com/purerender/20346379" target="_blank" rel="external">知乎专栏-react diff，写的很不错</a></p><h2 id="webkit-渲染机制"><a href="#webkit-渲染机制" class="headerlink" title="webkit 渲染机制"></a>webkit 渲染机制</h2><p>先看下简单版的（我们从浏览器地址栏输入网址开始到web页面被完整的呈现在眼前做了哪些事，暂不考虑DNS缓存、本地资源缓存）<br>网址被DNS解析为IP地址 -&gt; 通过IP地址建立TCP连接 -&gt; 发送HTTP请求 -&gt; 服务器处理请求并返回响应 -&gt;  浏览器解析渲染页面 -&gt; 断开TCP连接</p><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>一般渲染引擎主要包括HTML解释器、CSS解释器、Javascript引擎、布局、绘图等模块。<br>HTML解释器 ：HTML解释器的工作就是将网络或者本地磁盘获取到的HTML网页和资源从字节流解释成DOM树的结构（首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（TOKENS），经过语法分析器构建成节点，最后这些节点被组建成一颗DOM树）<br>CSS解释器 ：CSS字符串被CSS解释器处理后变成渲染引擎的内部规则表示。（样式规则建立完成之后，webkit会保存规则结果，当DOM的节点建立之后，webkit会为可视化节点选择合适的样式信息，即作样式规则匹配）<br>Javascript引擎 ：将Javascript代码处理并执行，一个Javascript引擎可以包括以下几个部分<br>　　编译器 -&gt; 主要工作是将源代码编译成抽象语法树，在某些引擎中还包括将抽象语法树转换为字节码（JavascriptCore 引擎）。<br>　　解释器  -&gt; 在某些引擎中，解释器主要是接收字节码，解释执行字节码，同时也依赖垃圾回收机制等。<br>　　JIT工具 -&gt; 将字节码或者抽象语法树转换为本地代码 （V8 引擎）。<br>　　垃圾回收器和分析工具。<br>布局 ：计算RenderObject对象的位置、大小等信息。<br>绘图 ：将构建好的渲染内部表示模型使用图形库绘制出来。<br><img src="http://p26lefllv.bkt.clouddn.com/webkitflow.png" alt="webkit渲染过程"><br><a href="http://www.sohu.com/a/115715208_472885" target="_blank" rel="external">WEBKIT渲染不可不知的这四棵树</a><br><a href="https://www.cnblogs.com/tianheila/p/6413586.html" target="_blank" rel="external">webkit 渲染机制</a></p><h2 id="http1-1-amp-2较1有哪些新东西？"><a href="#http1-1-amp-2较1有哪些新东西？" class="headerlink" title="http1.1&amp;2较1有哪些新东西？"></a>http1.1&amp;2较1有哪些新东西？</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p><h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p><h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</p><h2 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h2><p>1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可<br>2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页<br>3.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br>4.重要内容不要用js输出：爬虫不会执行js获取内容（目前chrome浏览器可以了）<br>5.少用iframe：搜索引擎不会抓取iframe中的内容<br>6.非装饰性图片必须加alt<br>7.提高网站速度：网站速度是搜索引擎排序的一个重要指标</p><h2 id="点击穿透"><a href="#点击穿透" class="headerlink" title="点击穿透"></a>点击穿透</h2><p>如何产生：<br>    现在有两层DOM结构（但不嵌套），底层和弹出层（底层在弹出层下面且弹出层的投影在底层内部），弹出层有一个 touchend 事件，底层有一个 click 事件。<br>当点击弹出层就会触发 touchend 事件（弹出层立即消失，这时事件的 target 为弹出层），300ms后触发 click 事件（由于弹出层消失了，这时事件的 target 就为底层了）。<br>看出来了吗？这样就发生了‘点击穿透’。<br>产生的原因：<br>    click事件延迟且弹出层消失了。<br>解决方案：<br>    1.只用touch事件<br>    2.只用click事件（不推荐只用click事件，这样所有点击都有延迟了，实在要使用可以使用事件库 fastclick）<br>    3.可以延迟（&gt;300ms,好像不太科学）弹出层消失<br><a href="http://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="服务器’推‘技术"><a href="#服务器’推‘技术" class="headerlink" title="服务器’推‘技术"></a>服务器’推‘技术</h2><p>webSocket、Comet、轮询<br>Comet主要是利用客户端向服务器发出请求时，服务器发回响应内容，并利用javascript建立一个长时间链接的“长连接”，这个连接在没有接收到服务器或者没有到达连接时间限制时会一直等待服务器的消息，如果服务器有消息传来，立即显示最新信息。长连接每隔一段时间会重新向服务器发出连接请求。服务器在有新消息产生的时候立即检查消息的接收方是否存在长连接，如果存在马上发送，如果没有则不发送。</p><h2 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h2><p>1.cookie（一般不能存关键字段，最好存sessionID配合session使用）<br>2.session<br>3.url重写<br>4.隐藏input<br>5.ip地址</p><h2 id="img的title和alt有什么区别"><a href="#img的title和alt有什么区别" class="headerlink" title="img的title和alt有什么区别"></a>img的title和alt有什么区别</h2><p>title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。<br>alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p><h2 id="doctype是什么-举例常见doctype及特点"><a href="#doctype是什么-举例常见doctype及特点" class="headerlink" title="doctype是什么,举例常见doctype及特点"></a>doctype是什么,举例常见doctype及特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写</div><div class="line">&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</div><div class="line">现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</div><div class="line">在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</div><div class="line">HTML5不基于SGML，所以不用指定DTD</div></pre></td></tr></table></figure><h3 id="常见dotype"><a href="#常见dotype" class="headerlink" title="常见dotype"></a>常见dotype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</div><div class="line">HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">HTML4.01 Frameset:允许表现性元素，废弃元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</div><div class="line">XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</div><div class="line">XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</div><div class="line">HTML 5: &lt;!doctype html&gt;</div></pre></td></tr></table></figure><h2 id="HTML全局属性-global-attribute-有哪些"><a href="#HTML全局属性-global-attribute-有哪些" class="headerlink" title="HTML全局属性(global attribute)有哪些"></a>HTML全局属性(global attribute)有哪些</h2><p>accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素<br>class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class、classList属性获取元素<br>contenteditable: 指定元素内容是否可编辑<br>contextmenu: 自定义鼠标右键弹出菜单内容<br>data-*: 为元素增加自定义属性<br>dir: 设置元素文本方向<br>draggable: 设置元素是否可拖拽<br>dropzone: 设置元素拖放类型： copy, move, link<br>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果<br>id: 元素id，文档内唯一<br>lang: 元素内容的的语言<br>spellcheck: 是否启动拼写和语法检查<br>style: 行内css样式<br>tabindex: 设置元素可以获得焦点，通过tab可以导航<br>title: 元素相关的建议信息<br>translate: 元素和子孙节点内容是否需要本地化</p><h2 id="什么是web语义化-有什么好处"><a href="#什么是web语义化-有什么好处" class="headerlink" title="什么是web语义化,有什么好处"></a>什么是web语义化,有什么好处</h2><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。<br>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构<br>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息<br>为什么需要语义化：<br>1.去掉样式后页面呈现清晰的结构<br>2.搜索引擎更好地理解页面，有利于收录<br>3.便团队项目的可持续运作及维护<br>5.盲人使用读屏器更好地阅读</p><h2 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。<br>GET是最常用的方法，通常用于请求服务器发送某个资源。<br>HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分<br>PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它<br>POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。<br>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。<br>OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。<br>DELETE请求服务器删除请求URL指定的资源。</p><h2 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h2><p>首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF<br>首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束<br>请求头和消息实体之间有一个CRLF分隔<br>根据实际请求需要可能包含一个消息实体<br>一个请求报文例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</div><div class="line">Host: www.w3.org</div><div class="line">Connection: keep-alive</div><div class="line">Cache-Control: max-age=0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</div><div class="line">Referer: https://www.google.com.hk/</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</div><div class="line">Cookie: authorstyle=yes</div><div class="line">If-None-Match: &quot;2cc8-3e3073913b100&quot;</div><div class="line">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</div><div class="line"></div><div class="line">name=fanerge&amp;age=26</div></pre></td></tr></table></figure></p><h2 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h2><p>首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF<br>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部<br>响应头部和响应实体之间用一个CRLF空行分隔<br>最后是一个可能的消息实体<br>响应报文例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 08 Jul 2014 05:28:43 GMT</div><div class="line">Server: Apache/2</div><div class="line">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</div><div class="line">ETag: &quot;40d7-3e3073913b100&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: 16599</div><div class="line">Cache-Control: max-age=21600</div><div class="line">Expires: Tue, 08 Jul 2014 11:28:43 GMT</div><div class="line">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</div><div class="line">Content-Type: text/html; charset=iso-8859-1</div><div class="line"></div><div class="line">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</div></pre></td></tr></table></figure></p><h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><h3 id="content方面"><a href="#content方面" class="headerlink" title="content方面"></a>content方面</h3><p>减少HTTP请求：合并文件、CSS精灵、inline Image<br>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br>避免重定向：多余的中间访问<br>使Ajax可缓存<br>非必须组件延迟加载<br>未来所需组件预加载<br>减少DOM元素数量<br>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br>减少iframe数量<br>不要404</p><h3 id="Server方面"><a href="#Server方面" class="headerlink" title="Server方面"></a>Server方面</h3><p>使用CDN<br>添加Expires或者Cache-Control响应头<br>对组件使用Gzip压缩<br>配置ETag<br>Flush Buffer Early<br>Ajax使用GET进行请求<br>避免空src的img标签</p><h3 id="Cookie方面"><a href="#Cookie方面" class="headerlink" title="Cookie方面"></a>Cookie方面</h3><p>减小cookie大小<br>引入资源的域名不要包含cookie</p><h3 id="css方面"><a href="#css方面" class="headerlink" title="css方面"></a>css方面</h3><p>将样式表放到页面顶部<br>不使用CSS表达式<br>使用不使用@import<br>不使用IE的Filter</p><h3 id="Javascript方面"><a href="#Javascript方面" class="headerlink" title="Javascript方面"></a>Javascript方面</h3><p>将脚本放到页面底部<br>将javascript和css从外部引入<br>压缩javascript和css<br>删除不需要的脚本<br>减少DOM访问<br>合理设计事件监听器</p><h3 id="图片方面"><a href="#图片方面" class="headerlink" title="图片方面"></a>图片方面</h3><p>优化图片：根据实际颜色需要选择色深、压缩<br>优化css精灵<br>不要在HTML中拉伸图片<br>保证favicon.ico小并且可缓存</p><h3 id="移动方面"><a href="#移动方面" class="headerlink" title="移动方面"></a>移动方面</h3><p>保证组件小于25k<br>Pack Components into a Multipart Document<br><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">yahoo Best Practices for Speeding Up Your Web Site</a></p><h2 id="什么是渐进增强"><a href="#什么是渐进增强" class="headerlink" title="什么是渐进增强"></a>什么是渐进增强</h2><p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。<br>核心原则如下:<br>所有浏览器都必须能访问基本内容<br>所有浏览器都必须能使用基本功能<br>所有内容都包含在语义化标签中<br>通过外部CSS提供增强的布局<br>通过非侵入式、外部javascript提供增强功能<br>end-user web browser preferences are respected</p><h2 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h2><p>1XX：信息状态码<br>100 Continue：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求之后向客户端发送一个最终响应。<br>101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。<br>2XX：成功状态码<br>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回<br>201 Created：<br>202 Accepted：<br>203 Non-Authoritative Information：<br>204 No Content：<br>205 Reset Content：<br>206 Partial Content：<br>3XX：重定向<br>300 Multiple Choices：<br>301 Moved Permanently：<br>302 Found：<br>303 See Other：<br>304 Not Modified：<br>305 Use Proxy：<br>306 （unused）：<br>307 Temporary Redirect：<br>4XX：客户端错误<br>400 Bad Request:<br>401 Unauthorized:<br>402 Payment Required:<br>403 Forbidden:<br>404 Not Found:<br>405 Method Not Allowed:<br>406 Not Acceptable:<br>407 Proxy Authentication Required:<br>408 Request Timeout:<br>409 Conflict:<br>410 Gone:<br>411 Length Required:<br>412 Precondition Failed:<br>413 Request Entity Too Large:<br>414 Request-URI Too Long:<br>415 Unsupported Media Type:<br>416 Requested Range Not Satisfiable:<br>417 Expectation Failed:<br>5XX: 服务器错误<br>500 Internal Server Error:<br>501 Not Implemented:<br>502 Bad Gateway:<br>503 Service Unavailable:<br>504 Gateway Timeout:<br>505 HTTP Version Not Supported:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-virtualDOM（batching）&quot;&gt;&lt;a href=&quot;#React-virtualDOM（batching）&quot; class=&quot;headerlink&quot; title=&quot;React virtualDOM（batching）&quot;&gt;&lt;/a&gt;React vi
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>IndexDB探索之路</title>
    <link href="https://fanerge.github.io/html5-IndexDB.html"/>
    <id>https://fanerge.github.io/html5-IndexDB.html</id>
    <published>2018-02-06T12:20:04.000Z</published>
    <updated>2018-02-08T13:28:18.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/indexedDB/static/">demo地址</a></p><h1 id="什么是-IndexDB？"><a href="#什么是-IndexDB？" class="headerlink" title="什么是 IndexDB？"></a>什么是 IndexDB？</h1><p>IndexedDB 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供索引功能以实现高性能查找. 像其他基于 SQL 的 关系型数据库管理系统 (RDBMS) 一样, IndexedDB 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的.</p><h2 id="IndexDB-的特点"><a href="#IndexDB-的特点" class="headerlink" title="IndexDB 的特点"></a>IndexDB 的特点</h2><p>IndexDB 和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。<br>IndexDB API包含异步(asynchronous) API 和同步(synchronous)API两种。  异步API适合大多数情况, 同步API必须同 WebWorkers一同使用.</p><h2 id="为什么我们要使用-IndexDB？"><a href="#为什么我们要使用-IndexDB？" class="headerlink" title="为什么我们要使用 IndexDB？"></a>为什么我们要使用 IndexDB？</h2><p>WebStorage在浏览器中有大小限制，存放较大的数据就不能满足了。<br>IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql.<br>IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）.</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IndexedDB-数据库使用key-value键值对储存数据"><a href="#IndexedDB-数据库使用key-value键值对储存数据" class="headerlink" title="IndexedDB 数据库使用key-value键值对储存数据"></a>IndexedDB 数据库使用key-value键值对储存数据</h2><p>key可以是二进制对象。<br>values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。<br>你可以对对象的某个属性创建索引（index）以实现快速查询和列举排序。</p><h2 id="IndexedDB-是事务模式的数据库"><a href="#IndexedDB-是事务模式的数据库" class="headerlink" title="IndexedDB 是事务模式的数据库"></a>IndexedDB 是事务模式的数据库</h2><p>任何操作都发生在事务(transaction)中。<br>IndexedDB API提供了索引(indexes), 表(tables), 指针(cursors)等等,<br>但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。<br>当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。<br>如果没有事务操作的支持，这两个实例就会互相影响对方的修改。</p><h2 id="IndexedDB-API-基本上是异步的"><a href="#IndexedDB-API-基本上是异步的" class="headerlink" title="IndexedDB API 基本上是异步的"></a>IndexedDB API 基本上是异步的</h2><p>IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。<br>执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。<br>当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。<br>类似于XMLHttpRequest。</p><h2 id="IndexedDB数据库“请求”无处不在"><a href="#IndexedDB数据库“请求”无处不在" class="headerlink" title="IndexedDB数据库“请求”无处不在"></a>IndexedDB数据库“请求”无处不在</h2><p>数据库“请求”负责接受成功或失败的DOM事件。<br>每一个“请求”都包含onsuccess和onerror事件属性，同时你还对“事件”调用addEventListener()和removeEventListener()。<br>“请求”还包括readyState，result和errorCode属性，用来表示“请求”的状态。<br>result属性尤其神奇，他可以根据“请求”生成的方式变成不同的东西，例如：IDBCursor实例、刚插入数据库的数值对应的键值（key）等。</p><h2 id="IndexedDB在结果准备好之后通过DOM事件通知用户"><a href="#IndexedDB在结果准备好之后通过DOM事件通知用户" class="headerlink" title="IndexedDB在结果准备好之后通过DOM事件通知用户"></a>IndexedDB在结果准备好之后通过DOM事件通知用户</h2><p>DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。<br>DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。<br>成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。<br>这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。</p><h2 id="IndexedDB是面向对象的"><a href="#IndexedDB是面向对象的" class="headerlink" title="IndexedDB是面向对象的"></a>IndexedDB是面向对象的</h2><p>indexedDB不是用二维表来表示集合的关系型数据库。这一点非常重要，将影响你设计和建立你的应用程序。​​​​<br>传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象存储(object Store)，只要这种数据一个JavaScript对象即可。<br>每个对象存储都有一个索引(index)集合以方便查询和迭代遍历。</p><h2 id="indexedDB不使用结构化查询语言（SQL）"><a href="#indexedDB不使用结构化查询语言（SQL）" class="headerlink" title="indexedDB不使用结构化查询语言（SQL）"></a>indexedDB不使用结构化查询语言（SQL）</h2><p>它通过索引(index)所产生的指针(cursor)来完成查询操作，从而使你可以迭代遍历到结果集合。</p><h2 id="IndexedDB遵循同源（same-origin）策略"><a href="#IndexedDB遵循同源（same-origin）策略" class="headerlink" title="IndexedDB遵循同源（same-origin）策略"></a>IndexedDB遵循同源（same-origin）策略</h2><p>“源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。<br>在同一个“源”内的所有数据库都有唯一、可区别的名称。</p><h1 id="使用-IndexedDB"><a href="#使用-IndexedDB" class="headerlink" title="使用 IndexedDB"></a>使用 IndexedDB</h1><h2 id="检测浏览器支持情况"><a href="#检测浏览器支持情况" class="headerlink" title="检测浏览器支持情况"></a>检测浏览器支持情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (window.indexedDB) &#123;</div><div class="line">// todo</div><div class="line">&#125; else &#123;</div><div class="line">alert(&apos;您的浏览器不支持indexdb&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我将会以demo来做常用的数据库操作说明，使用火狐浏览器做测试。</p><h2 id="新建数据库-关闭数据库"><a href="#新建数据库-关闭数据库" class="headerlink" title="新建数据库/关闭数据库"></a>新建数据库/关闭数据库</h2><p>indexedDB 有一个open(indexDbName[, version])，这个方法会打开某个数据库，若不存在则新建。<br>第一个参数为数据库名称 ‘demo’，第二个参数为 版本号。<br>db为打开数据库成功回掉 event.target.result 戴白哦数据库实例，有 close() 为关闭该数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function createDatabase(indexDbName) &#123;</div><div class="line"></div><div class="line">// 不存在则新建，存在则打开</div><div class="line">let openRequest = indexedDB.open(indexDbName);</div><div class="line"></div><div class="line">openRequest.onerror = function(event) &#123;</div><div class="line">        console.log(&quot;Database error: &quot; + event.target.errorCode);</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">console.log(&quot;Database created&quot;);</div><div class="line">let db = event.target.result;</div><div class="line">// db.close();</div><div class="line">console.log(&quot;this is :&quot;+db);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//更改数据库，或者存储对象时候在这里处理</div><div class="line">openRequest.onupgradeneeded = function (e) &#123;</div><div class="line">console.log(e);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBIns.png" alt="新建数据库"></p><h2 id="确定数据结构并添加数据"><a href="#确定数据结构并添加数据" class="headerlink" title="确定数据结构并添加数据"></a>确定数据结构并添加数据</h2><p>onupgradeneeded 唯一可以修改数据库结构的地方。<br>在 indexedDB 中一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。<br>创建 objectStore 的方法为数据库实例的 createObjectStore(name[, options]);<br>删除 objectStore 的方法为数据库实例的 deleteObjectStore(name);<br>其中options 有两个可选key，分别是 keyPath（选择objectStore中某个指定字段作为键值）、autoIncrement（若为true，objectStore有一个key generator）<br>我们创建好的 objectStore 也有一些方法：<br>createIndex(indexName, keyPath[, objectParameters]) 该方法作用为创建一个索引来通过 indexName 搜索 objectStore 里的数据。<br>objectStore.add(value[, key]) 该方法作用为将数据添加到 objectStore 中。<br>介绍了相关的方法，我们就通过循环来向 objectStore 添加数据。<br>下面是具体实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function insertData(indexDbName)&#123;</div><div class="line">// 带写入的数据</div><div class="line">const customerData = [</div><div class="line">  &#123; ssn: &quot;444-44-4444&quot;, name: &quot;Bill&quot;, age: 35, email: &quot;bill@company.com&quot; &#125;,</div><div class="line">  &#123; ssn: &quot;555-55-5555&quot;, name: &quot;Donna&quot;, age: 32, email: &quot;donna@home.org&quot; &#125;</div><div class="line">];</div><div class="line"></div><div class="line">// 如果在没有新建数据库时写入数据，这里只能带高版本的数据库版本才能出发 onupgradeneeded 事件</div><div class="line">let openRequest = indexedDB.open(indexDbName, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">console.log(&quot;Database created&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onupgradeneeded = function(event) &#123;</div><div class="line"></div><div class="line">console.log(&quot;开始写入数据&quot;);</div><div class="line">let db = event.target.result;</div><div class="line">// keyPath、autoIncrement</div><div class="line">let objectStore = db.createObjectStore(&quot;customers&quot;, &#123; keyPath: &quot;ssn&quot; &#125;);</div><div class="line">objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125;);</div><div class="line">objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, &#123; unique: true &#125;);</div><div class="line"></div><div class="line">for (let item of customerData) &#123;</div><div class="line">objectStore.add(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 删除 objectStore</div><div class="line">// db.deleteObjectStore(&quot;customers&quot;);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexed%20DBIns1.png" alt="新建数据库"><br>PS： 这里有个坑，需要说明一下。<br>onupgradeneeded事件在下列情况下被触发：<br>1.数据库第一次被打开时即新建<br>2.打开数据库时指定的版本号高于当前被持久化的数据库版本号</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>添加数据在 onsuccess 钩子中进行。<br>IndexedDB 添加数据通过事务来添加数据。<br>下面重点介绍下 transaction(storeNames[, mode]);<br>第一个参数是事务希望跨越的对象存储空间的列表。<br>第二个参数事务中可以执行的访问类型。<br>返回一个事务对象。<br>事务可以接收三种不同类型的 DOM 事件： error，abort，以及 complete。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function addData(storeName) &#123;</div><div class="line">const datas = [</div><div class="line">  &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;,</div><div class="line">  &#123; ssn: &quot;777-77-7777&quot;, name: &quot;sdsd&quot;, age: 22, email: &quot;sdsd@home.org&quot; &#125;</div><div class="line">];</div><div class="line"></div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction=db.transaction(storeName,&apos;readwrite&apos;);</div><div class="line">        let store=transaction.objectStore(storeName); </div><div class="line"></div><div class="line">for(let i=0;i&lt;datas.length;i++)&#123;</div><div class="line">            store.add(datas[i]);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBAdd.png" alt="添加数据"></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>同样删除数据也使用 transaction。<br>唯一区别是使用了 objectStore的 delete(key)，该方法为删除指定key的数据项。<br>objectStore 还有一个方法 clear()清空该 store 中的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function del66(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.delete(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">console.log(&apos;删除成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;删除失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>同样查找数据也使用 transaction。<br>唯一区别是使用了 objectStore的 get(key)，该方法为删除指定key的数据项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function getDataByKey(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.get(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">let item =event.target.result; </div><div class="line">console.log(item); // 获得的该数据项</div><div class="line">console.log(&apos;查找成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;查找失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>可以调用object store的put方法更新数据，会自动替换键值相同的记录，达到更新目的，没有相同的则添加，以使用keyPath做键为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function updateDataByKey(key)&#123;</div><div class="line">let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</div><div class="line"></div><div class="line">openRequest.onerror = function(e) &#123;</div><div class="line">console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">let db = event.target.result;</div><div class="line">let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</div><div class="line">let store=transaction.objectStore(&apos;customers&apos;); </div><div class="line">let request = store.get(key);</div><div class="line"></div><div class="line">request.onsuccess = function(event) &#123;</div><div class="line">let item =event.target.result; </div><div class="line"> // &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;</div><div class="line">item.ssn = &quot;666-66-6666&quot;</div><div class="line">item.name = &quot;yuzhenfan&quot;</div><div class="line">item.age = 18</div><div class="line">item.email = &quot;yzf@alipay.com&quot;</div><div class="line">            store.put(item); </div><div class="line">console.log(&apos;更新成功&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">console.log(&apos;更新失败&apos;);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBupdate.png" alt="更新数据"></p><blockquote><p>   参考文档<br><a href="https://www.cnblogs.com/lovelgx/articles/6026957.html" target="_blank" rel="external">数据库写入时机</a><br><a href="http://www.php.cn/html5-tutorial-359628.html" target="_blank" rel="external">html5使用indexdb的代码实例分享</a><br><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="external">wiki-数据库事务</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IndexedDB" target="_blank" rel="external">MDN-IndexedDB</a><br><a href="http://w3c.github.io/IndexedDB/" target="_blank" rel="external">w3c-IndexDB-API</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB" target="_blank" rel="external">IndexDB-Guides</a><br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（一：基本使用）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      IndexDB
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>html5-svg开发手册</title>
    <link href="https://fanerge.github.io/html5-svg%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/html5-svg开发手册.html</id>
    <published>2018-01-30T12:28:14.000Z</published>
    <updated>2018-01-30T13:04:14.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="svg-介绍"><a href="#svg-介绍" class="headerlink" title="svg 介绍"></a>svg 介绍</h1><p>SVG 意为可缩放矢量图形（Scalable Vector Graphics）。<br>SVG 使用 XML 格式定义图像。</p><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;</div><div class="line">  stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure><h2 id="svg的特点"><a href="#svg的特点" class="headerlink" title="svg的特点"></a>svg的特点</h2><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)<br>SVG 用来定义用于网络的基于矢量的图形<br>SVG 使用 XML 格式定义图形<br>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失<br>SVG 是万维网联盟的标准<br>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</p><h2 id="一个单独的-svg文件"><a href="#一个单独的-svg文件" class="headerlink" title="一个单独的 .svg文件"></a>一个单独的 .svg文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;</div><div class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</div><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;</div><div class="line">  stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure><h2 id="SVG-在-HTML-页面"><a href="#SVG-在-HTML-页面" class="headerlink" title="SVG 在 HTML 页面"></a>SVG 在 HTML 页面</h2><h3 id="使用-embed-标签"><a href="#使用-embed-标签" class="headerlink" title="使用 embed 标签"></a>使用 embed 标签</h3><p><code>&lt;embed src=&quot;circle1.svg&quot; type=&quot;image/svg+xml&quot; /&gt;</code></p><h3 id="使用-object-标签"><a href="#使用-object-标签" class="headerlink" title="使用 object 标签"></a>使用 object 标签</h3><p><code>&lt;object data=&quot;circle1.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;</code></p><h3 id="使用-iframe-标签"><a href="#使用-iframe-标签" class="headerlink" title="使用 iframe 标签"></a>使用 iframe 标签</h3><p><code>&lt;iframe src=&quot;circle1.svg&quot;&gt;&lt;/iframe&gt;</code></p><h3 id="直接在HTML嵌入SVG代码"><a href="#直接在HTML嵌入SVG代码" class="headerlink" title="直接在HTML嵌入SVG代码"></a>直接在HTML嵌入SVG代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">   &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure><h3 id="链接到SVG文件"><a href="#链接到SVG文件" class="headerlink" title="链接到SVG文件"></a>链接到SVG文件</h3><p><code>&lt;a href=&quot;circle1.svg&quot;&gt;View SVG file&lt;/a&gt;</code></p><h1 id="svg-形状元素"><a href="#svg-形状元素" class="headerlink" title="svg 形状元素"></a>svg 形状元素</h1><p>下面所有样式均可以写成属性，建议属性和样式区分。<br>通用样式：fill、fill-opacity、stroke、stroke-width、stroke-opacity、opacity</p><h2 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h2><p>用来创建矩形及其变种<br>属性：x（矩形到浏览器窗口左侧的距离）、y、width、height、rx、ry（圆角半径）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;rect x=&quot;50&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot;</div><div class="line">  style=&quot;fill:red;stroke:black;stroke-width:5;opacity:0.5&quot;/&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="circle"><a href="#circle" class="headerlink" title="circle"></a>circle</h2><p>用来创建一个圆<br>属性：cx、cy（园中心坐标）、r<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;</div><div class="line">  stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="elipse"><a href="#elipse" class="headerlink" title="elipse"></a>elipse</h2><p>用来创建一个椭圆<br>属性：cx（椭圆坐标）、cy、rx、ry（椭圆半径）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;ellipse cx=&quot;240&quot; cy=&quot;50&quot; rx=&quot;220&quot; ry=&quot;30&quot; style=&quot;fill:yellow&quot;/&gt;</div><div class="line">  &lt;ellipse cx=&quot;220&quot; cy=&quot;50&quot; rx=&quot;190&quot; ry=&quot;20&quot; style=&quot;fill:white&quot;/&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="line"><a href="#line" class="headerlink" title="line"></a>line</h2><p>用来创建一个直线<br>属性：x1、y1、x2、y2（分别对应起点和终点的坐标）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot;</div><div class="line">  style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot;/&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="polygon"><a href="#polygon" class="headerlink" title="polygon"></a>polygon</h2><p>用来创建含有不少于三个边的图形<br>属性：points 属性定义多边形每个角所在点的 x 和 y 坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot;</div><div class="line">  style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><p>样式：fill-rule: nonzero | evenodd | inherit<br>nonzero：<br>    按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。<br>evenodd：<br>    按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。</p><h2 id="polyline"><a href="#polyline" class="headerlink" title="polyline"></a>polyline</h2><p>用来创建任何只有直线的形状<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>用来定义一个路径<br>属性：d（路径数据）<br>下列的命令可用于路径数据：<br>M = moveto<br>L = lineto<br>H = horizontal lineto<br>V = vertical lineto<br>C = curveto<br>S = smooth curveto<br>Q = quadratic Bézier curve<br>T = smooth quadratic Bézier curveto<br>A = elliptical Arc<br>Z = closepath<br>PS：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><p>用来定义文本<br>属性：x、y、transform（rotate、skew、scale、translate）</p><h3 id="配合-defs-path-使用"><a href="#配合-defs-path-使用" class="headerlink" title="配合 defs-path 使用"></a>配合 defs-path 使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;</div><div class="line">xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;</div><div class="line">   &lt;defs&gt;</div><div class="line">    &lt;path id=&quot;path1&quot; d=&quot;M75,20 a1,1 0 0,0 100,0&quot; /&gt;</div><div class="line">  &lt;/defs&gt;</div><div class="line">  &lt;text x=&quot;10&quot; y=&quot;100&quot; style=&quot;fill:red;&quot;&gt;</div><div class="line">    &lt;textPath xlink:href=&quot;#path1&quot;&gt;I love SVG I love SVG&lt;/textPath&gt;</div><div class="line">  &lt;/text&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure><h3 id="tspan"><a href="#tspan" class="headerlink" title="tspan"></a>tspan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">  &lt;text x=&quot;10&quot; y=&quot;20&quot; style=&quot;fill:red;&quot;&gt;Several lines:</div><div class="line">    &lt;tspan x=&quot;10&quot; y=&quot;45&quot;&gt;First line&lt;/tspan&gt;</div><div class="line">    &lt;tspan x=&quot;10&quot; y=&quot;70&quot;&gt;Second line&lt;/tspan&gt;</div><div class="line">  &lt;/text&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure><h3 id="配合-a"><a href="#配合-a" class="headerlink" title="配合 a"></a>配合 a</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;</div><div class="line">xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;</div><div class="line">  &lt;a xlink:href=&quot;http://www.w3schools.com/svg/&quot; target=&quot;_blank&quot;&gt;</div><div class="line">    &lt;text x=&quot;0&quot; y=&quot;15&quot; fill=&quot;red&quot;&gt;I love SVG&lt;/text&gt;</div><div class="line">  &lt;/a&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><h2 id="Stroke-属性"><a href="#Stroke-属性" class="headerlink" title="Stroke 属性"></a>Stroke 属性</h2><p>用于线条(path)、文字(text)、元素(rect)<br>颜色（6中颜色均支持）– stroke=”red”<br>宽度 – stroke-width=””<br>路劲的终结 – stroke-dasharray=”20 10 5 3” // 20和5表示实线的长度，10和3表示空白的长度</p><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>用来增加对SVG图形的特殊效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;</div><div class="line">    &lt;filter id=&quot;feBlend1&quot;&gt;</div><div class="line">        &lt;feFlood result=&quot;floodFill&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; flood-color=&quot;green&quot; flood-opacity=&quot;0.9&quot;/&gt;</div><div class="line">        &lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;floodFill&quot; mode=&quot;normal&quot;/&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line">    &lt;circle cx=&quot;150&quot; cy=&quot;50&quot; r=&quot;40&quot; fill=&quot;red&quot; filter=&quot;url(#feBlend1)&quot;/&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h3 id="feBlend"><a href="#feBlend" class="headerlink" title="feBlend"></a>feBlend</h3><p>使用不同的混合模式把两个对象合成在一起<br>专有属性：<br>1.in=顶层生效<br>    SourceGraphic<br>        该关键词表示图形元素自身将作为<filter>原语的原始输入.<br>    SourceAlpha<br>        该关键词表示图形元素自身将作为<filter>原语的原始输入. SourceAlpha与SourceGraphic具有相同的规则除了SourceAlpha只使用元素的透明度.<br>    BackgroundImage<br>        该关键词表示filter元素当前底下的区域的图形快照将被调用.<br>    BackgroundAlpha<br>        跟BackgroundImage相同除了只使用透明度.<br>    FillPaint<br>    StrokePaint<br>2.in2=底层生效<br>    同上<br>3.mode=normal | multiply | screen | darken | lighten // 混合模式</filter></filter></p><h3 id="feColorMatrix"><a href="#feColorMatrix" class="headerlink" title="feColorMatrix"></a>feColorMatrix</h3><p>该滤镜基于转换矩阵对颜色进行变换<br>专有属性：<br>1.in<br>    同上<br>2.type<br>3.values<br>PS：2和3会根据不同滤镜效果参数不一样</p><h3 id="feComponentTransfer"><a href="#feComponentTransfer" class="headerlink" title="feComponentTransfer"></a>feComponentTransfer</h3><p>对每个像素执行颜色分量的数据重映射.它允许进行像亮度调整,对比度调整,色彩平衡或阈值的操作<br>专有属性：</p><h3 id="feComposite"><a href="#feComposite" class="headerlink" title="feComposite"></a>feComposite</h3><p>该滤镜执行两个输入图像的智能像素组合，在图像空间中使用以下Porter-Duff合成操作之一：over、in、atop、xor。</p><h3 id="feConvolveMatrix"><a href="#feConvolveMatrix" class="headerlink" title="feConvolveMatrix"></a>feConvolveMatrix</h3><p>应用了一个矩阵卷积滤镜效果。一个卷积在输入图像中把像素与邻近像素组合起来制作出结果图像。通过卷积可以实现各种成像操作，包括模糊、边缘检测、锐化、压花和斜角。</p><h3 id="feDiffuseLighting"><a href="#feDiffuseLighting" class="headerlink" title="feDiffuseLighting"></a>feDiffuseLighting</h3><p>滤镜光照一个图像，使用alpha通道作为隆起映射。结果图像，是一个RGBA不透明图像，取决于光的颜色、光的位置以及输入隆起映射的表面几何形状。</p><h3 id="feDisplacementMap"><a href="#feDisplacementMap" class="headerlink" title="feDisplacementMap"></a>feDisplacementMap</h3><p>映射置换滤镜，该滤镜用来自图像中从in2到空间的像素值置换图像从in到空间的像素值</p><h3 id="feFlood"><a href="#feFlood" class="headerlink" title="feFlood"></a>feFlood</h3><p>该滤镜用flood-color元素定义的颜色和flood-opacity元素定义的不透明度填充了滤镜子区域</p><h3 id="feGaussianBlur"><a href="#feGaussianBlur" class="headerlink" title="feGaussianBlur"></a>feGaussianBlur</h3><p>该滤镜对输入图像进行高斯模糊，属性stdDeviation中指定的数量定义了钟形</p><h3 id="feImage"><a href="#feImage" class="headerlink" title="feImage"></a>feImage</h3><p>滤镜从外部来源取得图像数据，并提供像素数据作为输出（意味着如果外部来源是一个SVG图像，这个图像将被栅格化。）</p><h3 id="feMerge"><a href="#feMerge" class="headerlink" title="feMerge"></a>feMerge</h3><p>滤镜允许同时应用滤镜效果而不是按顺序应用滤镜效果。利用result存储别的滤镜的输出可以实现这一点，然后在一个 <femergenode>子元素中访问它。</femergenode></p><h3 id="feMorphology"><a href="#feMorphology" class="headerlink" title="feMorphology"></a>feMorphology</h3><p>该滤镜用来侵蚀或扩张输入的图像。它在增肥或瘦身效果方面特别有用。</p><h3 id="feOffset"><a href="#feOffset" class="headerlink" title="feOffset"></a>feOffset</h3><p>该输入图像作为一个整体，在属性dx和属性dy的值指定了它的偏移量。</p><h3 id="feSpecularLighting"><a href="#feSpecularLighting" class="headerlink" title="feSpecularLighting"></a>feSpecularLighting</h3><p>该滤镜照亮一个源图形，使用alpha通道作为隆起映射。该结果图像是一个基于光色的RGBA图象。</p><h3 id="feTile"><a href="#feTile" class="headerlink" title="feTile"></a>feTile</h3><p>输入图像是平铺的，结果用来填充目标。它的效果近似于一个<pattern>图案对象。</pattern></p><h3 id="feTurbulence"><a href="#feTurbulence" class="headerlink" title="feTurbulence"></a>feTurbulence</h3><p>该滤镜利用Perlin噪声函数创建了一个图像。它实现了人造纹理比如说云纹、大理石纹的合成。</p><h3 id="feDistantLight"><a href="#feDistantLight" class="headerlink" title="feDistantLight"></a>feDistantLight</h3><p>该滤镜定义了一个距离光源，可以用在灯光滤镜<fediffuselighting>元素或<fespecularlighting>元素的内部。</fespecularlighting></fediffuselighting></p><h3 id="fePointLight"><a href="#fePointLight" class="headerlink" title="fePointLight"></a>fePointLight</h3><p>该元素实现了 SVGFEPointLightElement 接口。</p><h3 id="feSpotLight"><a href="#feSpotLight" class="headerlink" title="feSpotLight"></a>feSpotLight</h3><p>feSpotLight 元素是一种光源元素，用于SVG文件。<br>PS：您可以在每个 SVG 元素上使用多个滤镜</p><h2 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a>模糊效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;defs&gt;元素定义短并含有特殊元素（如滤镜）定义。</div><div class="line">&lt;filter&gt;标签使用必需的id属性来定义向图形应用哪个滤镜。</div></pre></td></tr></table></figure><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">// 定义id为f1的滤镜</div><div class="line">// in=&quot;SourceGraphic&quot;这个部分定义了由整个图像创建效果</div><div class="line">// stdDeviation属性定义模糊量</div><div class="line">&lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot;&gt;</div><div class="line">  &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;15&quot; /&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">// 使用id为f1的滤镜</div><div class="line">&lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">&lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200%&quot; height=&quot;200%&quot;&gt;</div><div class="line">&lt;feOffset result=&quot;offOut&quot; in=&quot;SourceGraphic&quot; dx=&quot;30&quot; dy=&quot;20&quot; /&gt;</div><div class="line">&lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;offOut&quot; mode=&quot;normal&quot; /&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot;</div><div class="line">fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">    &lt;linearGradient id=&quot;grad1&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;0%&quot;&gt;</div><div class="line">      &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,0);stop-opacity:1&quot; /&gt;</div><div class="line">      &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(255,0,0);stop-opacity:1&quot; /&gt;</div><div class="line">    &lt;/linearGradient&gt;</div><div class="line">&lt;ellipse cx=&quot;200&quot; cy=&quot;70&quot; rx=&quot;85&quot; ry=&quot;55&quot; fill=&quot;url(#grad1)&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><h3 id="径向"><a href="#径向" class="headerlink" title="径向"></a>径向</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</div><div class="line">    &lt;radialGradient id=&quot;grad1&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; r=&quot;50%&quot; fx=&quot;50%&quot; fy=&quot;50%&quot;&gt;</div><div class="line">      &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,255);</div><div class="line">      stop-opacity:0&quot; /&gt;</div><div class="line">      &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(0,0,255);stop-opacity:1&quot; /&gt;</div><div class="line">    &lt;/radialGradient&gt;</div><div class="line">&lt;ellipse cx=&quot;200&quot; cy=&quot;70&quot; rx=&quot;85&quot; ry=&quot;55&quot; fill=&quot;url(#grad1)&quot; /&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p><p><a href="http://www.runoob.com/svg/svg-reference.html" target="_blank" rel="external">svg参考手册</a></p>]]></content>
    
    <summary type="html">
    
      svg开发手册
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="svg" scheme="https://fanerge.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>Web Worker</title>
    <link href="https://fanerge.github.io/html5-webWorker.html"/>
    <id>https://fanerge.github.io/html5-webWorker.html</id>
    <published>2018-01-26T13:06:15.000Z</published>
    <updated>2018-01-27T08:13:35.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fanerge.github.io/H5WebWorker/static/">先放上demo，打开控制台试试</a></p><h1 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker"></a>什么是Web Worker</h1><p>Web Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。<br>局限性：在worker内不能直接操作DOM节点，或者使用window对象的默认方法和属性。</p><h1 id="Worker特性检测"><a href="#Worker特性检测" class="headerlink" title="Worker特性检测"></a>Worker特性检测</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(window.Worker)&#123;</div><div class="line">// todo</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持web Worker</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>PS：假设页面为index.html，页面js为main.js，这里的path是相对于index.html到该worker.js。</p><h1 id="专用Worker"><a href="#专用Worker" class="headerlink" title="专用Worker"></a>专用Worker</h1><h2 id="生成一个专用worker"><a href="#生成一个专用worker" class="headerlink" title="生成一个专用worker"></a>生成一个专用worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myWorker = new Worker(&apos;worker.js&apos;);</div></pre></td></tr></table></figure><p>PS：假设页面为index.html，页面主线程js为main.js，这里的path是相对于index.html到该worker.js。</p><h2 id="主线程js和Worker的通信（数据交互）"><a href="#主线程js和Worker的通信（数据交互）" class="headerlink" title="主线程js和Worker的通信（数据交互）"></a>主线程js和Worker的通信（数据交互）</h2><h3 id="主线程js（main-js-用来生成-myWorker）"><a href="#主线程js（main-js-用来生成-myWorker）" class="headerlink" title="主线程js（main.js 用来生成 myWorker）"></a>主线程js（main.js 用来生成 myWorker）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let myWorker</div><div class="line">if(window.Worker)&#123;</div><div class="line">// todo</div><div class="line">myWorker = new Worker(&apos;./js/worker.js&apos;)</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持web Worker</div><div class="line">alert(&apos;不支持web Worker&apos;)</div><div class="line">&#125;</div><div class="line">let app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    num: 1000000,</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">computed () &#123;</div><div class="line">console.log(`Message posted to worker=$&#123;this.num&#125;`);</div><div class="line">// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</div><div class="line">myWorker.postMessage(this.num)</div><div class="line">&#125;  </div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>PS：如果想发送多个消息，可以这样myWorker.postMessage([msg1, msg2…])，对应接收的e.data对象也就是一个数组了，若是对象的话需要序列化，接收的时候需要反序列化。</p><h3 id="myWorker脚本代码"><a href="#myWorker脚本代码" class="headerlink" title="myWorker脚本代码"></a>myWorker脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 有数据发过来，就触发</div><div class="line">onmessage = function(e) &#123;</div><div class="line">let num1 = e.data;</div><div class="line">let num2 = 0;</div><div class="line"></div><div class="line">console.time(&apos;计算耗时&apos;)</div><div class="line">for(let i = 0; i &lt; num1; i++)&#123;</div><div class="line">num2 += i;</div><div class="line">&#125;</div><div class="line">console.timeEnd(&apos;计算耗时&apos;)</div><div class="line"></div><div class="line">console.log(`Worker 计算结果=$&#123;num2&#125;`)</div><div class="line"></div><div class="line">// 当我们计算出结果，应该回传</div><div class="line">postMessage(num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我向一个Worker发送一个较大num，然后求出该1到num的整数和。<br>在页面中input的值分别为：1000000、10000000、100000000各执行了一次计算，最后一次花费了11s左右（算的上耗时计算了吧）。<br>下面是我的测试截图<br><img src="http://p26lefllv.bkt.clouddn.com/WebWorker.png" alt=""><br>就这么简单，我们就实现了主线程js和WebWorker的双向通信。</p><h2 id="终止worker"><a href="#终止worker" class="headerlink" title="终止worker"></a>终止worker</h2><h3 id="在主线程中终止"><a href="#在主线程中终止" class="headerlink" title="在主线程中终止"></a>在主线程中终止</h3><p>如果你需要从主线程中立刻终止一个运行中的worker，可以调用worker的terminate 方法：<br><code>myWorker.terminate();</code><br>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p><h3 id="在Worker中终止（自杀）"><a href="#在Worker中终止（自杀）" class="headerlink" title="在Worker中终止（自杀）"></a>在Worker中终止（自杀）</h3><p><code>close()</code></p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>当然我们刚刚仅仅考虑了正常情况，还有需要错误等待我们处理呢？<br>当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。<br>它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。<br>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。<br>错误事件有以下三个用户关心的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message</div><div class="line">可读性良好的错误消息。</div><div class="line">filename</div><div class="line">发生错误的脚本文件名。</div><div class="line">lineno</div><div class="line">发生错误时所在脚本文件的行号。</div></pre></td></tr></table></figure></p><h2 id="生成subworker"><a href="#生成subworker" class="headerlink" title="生成subworker"></a>生成subworker</h2><p>如果需要的话 worker 能够生成更多的 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>而且，subworker 解析 URI 时会相对于父 worker 的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。</p><h2 id="在Worker中引入脚本与库"><a href="#在Worker中引入脚本与库" class="headerlink" title="在Worker中引入脚本与库"></a>在Worker中引入脚本与库</h2><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">importScripts();                       </div><div class="line">importScripts(&apos;cube.js&apos;);                </div><div class="line">importScripts(&apos;cube1.js&apos;, &apos;cube2&apos;);</div></pre></td></tr></table></figure></p><h1 id="共享Worker（SharedWorker）"><a href="#共享Worker（SharedWorker）" class="headerlink" title="共享Worker（SharedWorker）"></a>共享Worker（SharedWorker）</h1><p>一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。<br>由于SharedWorker 与 专有Worker 非常相似，这里我只是提一下它们的区别。<br>读者若需要做测试的话，可以考虑在2个html页面中的javascript代码使用的是同一个worker。</p><h2 id="生成一个共享worker"><a href="#生成一个共享worker" class="headerlink" title="生成一个共享worker"></a>生成一个共享worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myWorker = new SharedWorker(&apos;worker.js&apos;);</div><div class="line">// 父级线程中的调用</div><div class="line">myWorker.port.start();</div><div class="line">// worker线程中的调用, 假设port变量代表一个端口  </div><div class="line">port.start();</div></pre></td></tr></table></figure><p>一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。<br>在使用start()方法打开端口连接时，如果父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。</p><h2 id="共享worker中消息的接收和发送"><a href="#共享worker中消息的接收和发送" class="headerlink" title="共享worker中消息的接收和发送"></a>共享worker中消息的接收和发送</h2><h3 id="主线程发送消息给Worker"><a href="#主线程发送消息给Worker" class="headerlink" title="主线程发送消息给Worker"></a>主线程发送消息给Worker</h3><p>改写我们的computed方法（vue组件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed () &#123;</div><div class="line">console.log(`Message posted to worker=$&#123;this.num&#125;`);</div><div class="line">// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</div><div class="line">myWorker.port.postMessage(this.num)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Worker接收到消息并处理及回传"><a href="#Worker接收到消息并处理及回传" class="headerlink" title="Worker接收到消息并处理及回传"></a>Worker接收到消息并处理及回传</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">onconnect = function(e) &#123;</div><div class="line">var port = e.ports[0];</div><div class="line"></div><div class="line">port.onmessage = function(e) &#123;</div><div class="line">// 同样e.data为主线程发送的数据</div><div class="line">console.log(e.data)</div><div class="line">//复杂的计算</div><div class="line">let result = e.data*1000*23*3</div><div class="line">// Worker需要回传至主线程</div><div class="line">port.postMessage(result);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="主线程接收并处理消息"><a href="#主线程接收并处理消息" class="headerlink" title="主线程接收并处理消息"></a>主线程接收并处理消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myWorker.port.onmessage = function(e) &#123;</div><div class="line">result2.textContent = e.data;</div><div class="line">console.log(&apos;Message received from worker&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：总结差异，主线程和Worker都要执行start()，通信时需要带上port。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>Worker接口会生成真正的操作系统级别的线程，如果你不太小心，那么并发(concurrency)会对你的代码产生有趣的影响。然而，对于 web worker 来说，与其他线程的通信点会被很小心的控制，这意味着你很难引起并发问题。</p><h1 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP全称Content Security Policy为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。<br>可以限制如下资源的加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">script-src：外部脚本</div><div class="line">style-src：样式表</div><div class="line">img-src：图像</div><div class="line">media-src：媒体文件（音频和视频）</div><div class="line">font-src：字体文件</div><div class="line">object-src：插件（比如 Flash）</div><div class="line">child-src：框架</div><div class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</div><div class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</div><div class="line">worker-src：worker脚本</div><div class="line">manifest-src：manifest 文件</div></pre></td></tr></table></figure></p><p>除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。<br>但它必须与report-uri选项配合使用。<br><code>Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser;</code></p><h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</code></p><h3 id="服务器上设置"><a href="#服务器上设置" class="headerlink" title="服务器上设置"></a>服务器上设置</h3><p>以下语句设置在请求头部（Header）<br><code>Content-Security-Policy &quot;default-src &#39;self&#39;;&quot;</code><br>如果要为Worker指定CSP策略，可以为Worker脚本的请求的响应的头部设置CSP策略。<br>这时这个Worker会继承它所属的文档或者创建它的Worker的CSP策略。 </p><h2 id="worker中数据的接收与发送"><a href="#worker中数据的接收与发送" class="headerlink" title="worker中数据的接收与发送"></a>worker中数据的接收与发送</h2><p>在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。<br>传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。</p><blockquote><p>   参考手册<br>    <a href="http://balance9.iteye.com/blog/1992118" target="_blank" rel="external">测试html5专用线程与共享线程的区别</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">MDN-WebWorker</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="external">WebWorkerAPI</a><br>    <a href="https://cn.vuejs.org/v2/api/#v-model" target="_blank" rel="external">vue</a><br>    <a href="http://www.runoob.com/html/html5-webworkers.html" target="_blank" rel="external">HTML5 Web Workers</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid" target="_blank" rel="external">CSP</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fanerge.github.io/H5WebWorker/static/&quot;&gt;先放上demo，打开控制台试试&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是Web-Worker&quot;&gt;&lt;a href=&quot;#什么是Web-Worker&quot; class=&quot;he
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Geolocation（地理定位）</title>
    <link href="https://fanerge.github.io/html5-Geolocation.html"/>
    <id>https://fanerge.github.io/html5-Geolocation.html</id>
    <published>2018-01-24T12:11:31.000Z</published>
    <updated>2018-01-24T13:48:48.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地理位置提供定制的信息。<br>其实Geolocation 就是用来获取到当前设备的经纬度（位置）<br>带有此接口的对象可以用由 Navigator实现的属性NavigatorGeolocation.geolocation 来获得。<br>PS：鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="检测是否支持地理定位"><a href="#检测是否支持地理定位" class="headerlink" title="检测是否支持地理定位"></a>检测是否支持地理定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (navigator.geolocation) &#123;</div><div class="line">// 做相应的操作 </div><div class="line">&#125; else &#123;</div><div class="line">console.error(&apos;不支持地理&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="获取当前定位"><a href="#获取当前定位" class="headerlink" title="获取当前定位"></a>获取当前定位</h2><p>Geolocation.getCurrentPosition(success, error, options)<br>    确定设备的位置并返回一个携带位置信息的 Position 对象。<br>参数：</p><h3 id="success"><a href="#success" class="headerlink" title="success"></a>success</h3><p>成功得到位置信息时的回调函数，使用Position 对象作为唯一的参数。 </p><h4 id="Position-coords-只读（latitude、longitude、accuracy）"><a href="#Position-coords-只读（latitude、longitude、accuracy）" class="headerlink" title="Position.coords 只读（latitude、longitude、accuracy）"></a>Position.coords 只读（latitude、longitude、accuracy）</h4><p>返回一个定义了当前位置的Coordinates 对象.<br>    coords.latitude    十进制数的纬度<br>    coords.longitude    十进制数的经度<br>    coords.accuracy    位置精度<br>    coords.altitude    海拔，海平面以上以米计<br>    coords.altitudeAccuracy    位置的海拔精度<br>    coords.heading    方向，从正北开始以度计<br>    coords.speed    速度，以米/每秒计</p><h4 id="Position-timestamp-只读"><a href="#Position-timestamp-只读" class="headerlink" title="Position.timestamp 只读"></a>Position.timestamp 只读</h4><p>返回一个时间戳DOMTimeStamp， 这个时间戳表示获取到的位置的时间。</p><h3 id="error-可选"><a href="#error-可选" class="headerlink" title="error 可选"></a>error 可选</h3><p>获取位置信息失败时的回调函数，使用 PositionError 对象作为唯一的参数，这是一个可选项。 </p><h4 id="PositionError-code-只读"><a href="#PositionError-code-只读" class="headerlink" title="PositionError.code 只读"></a>PositionError.code 只读</h4><p>返回无符号的、简短的错误码。<br>    PERMISSION_DENIED–权限问题<br>    POSITION_UNAVAILABLE–内部错误<br>    TIMEOUT–超时</p><h4 id="PositionError-message-只读"><a href="#PositionError-message-只读" class="headerlink" title="PositionError.message 只读"></a>PositionError.message 只读</h4><p>返回一个开发者可以理解的 DOMString 来描述错误的详细信息。</p><h3 id="options-可选"><a href="#options-可选" class="headerlink" title="options 可选"></a>options 可选</h3><h5 id="一个可选的PositionOptions-对象。"><a href="#一个可选的PositionOptions-对象。" class="headerlink" title="一个可选的PositionOptions 对象。"></a>一个可选的PositionOptions 对象。</h5><pre><code>enableHighAccuracy: false;--是否高精度，默认false timeout: 5000;--超时事件ms maximumAge: 0; 地理位置缓存时长ms</code></pre><h2 id="监视定位"><a href="#监视定位" class="headerlink" title="监视定位"></a>监视定位</h2><p>Geolocation.watchPosition(success[, error[, options]])<br>    用于注册监听器，在设备的地理位置发生改变的时候自动被调用。也可以选择特定的错误处理函数。<br>    该方法会返回一个 ID，如要取消监听可以通过  Geolocation.clearWatch() 传入该 ID 实现取消的目的。<br>参数：</p><h3 id="success-1"><a href="#success-1" class="headerlink" title="success"></a>success</h3><p>成功时候的回调函数， 同时传入一个 Position 对象当作参数。</p><h3 id="error-可选-1"><a href="#error-可选-1" class="headerlink" title="error 可选"></a>error 可选</h3><p>失败时候的回调函数，可选， 会传入一个 PositionError 对象当作参数。</p><h3 id="options-可选-1"><a href="#options-可选-1" class="headerlink" title="options 可选"></a>options 可选</h3><p>一个可选的 PositionOptions 对象。<br>PS：Position、PositionError、PositionOptions对象和上面一样。</p><h2 id="清理监视定位"><a href="#清理监视定位" class="headerlink" title="清理监视定位"></a>清理监视定位</h2><p>Geolocation.clearWatch(id)<br>    这个方法主要用于使用 Geolocation.watchPosition() 注册的 位置/错误 监听器。<br>参数：</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>希望移除的监听器所对应的 Geolocation.watchPosition() 返回的 ID 数字。<br>    Geolocation.watchPosition()注册一个位置改变监听器，每当设备位置改变时，返回一个 long 类型的该监听器的ID值。<br>Geolocation.clearWatch()<br>    取消由 watchPosition()注册的位置监听器。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation" target="_blank" rel="external">Geolocation</a><br>    <a href="http://www.runoob.com/html/html5-geolocation.html" target="_blank" rel="external">HTML5 Geolocation（地理定位）</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionError" target="_blank" rel="external">PositionError</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionOptions" target="_blank" rel="external">PositionOptions</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/watchPosition" target="_blank" rel="external">watchPosition</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>拖放（Drag 和 Drop）</title>
    <link href="https://fanerge.github.io/html5-DragAndDrop.html"/>
    <id>https://fanerge.github.io/html5-DragAndDrop.html</id>
    <published>2018-01-23T12:20:03.000Z</published>
    <updated>2018-01-23T14:33:20.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h1><p>拖放（Drag 和 drop）是 HTML5 标准的组成部分。<br>DataTransfer 对象：拖拽对象用来传递的媒介，使用一般为Event.dataTransfer。<br>draggable 属性：为需要拖拽的元素设置该属性。<br>Event.effectAllowed 属性：就是拖拽的效果。<br>Event.preventDefault() 方法：阻止默认的些事件方法等执行。<br>在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。</p><h2 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h2><h3 id="拖动目标上触发事件"><a href="#拖动目标上触发事件" class="headerlink" title="拖动目标上触发事件"></a>拖动目标上触发事件</h3><p>ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件。<br>ondrag 事件：当元素或者选择的文本被拖动时触发 drag 事件，大约每几百毫秒的触发一次。<br>ondragend 事件：当拖拽完成后触发的事件（比如松开鼠标按键或敲“Esc”键）。</p><h3 id="释放目标时触发的事件"><a href="#释放目标时触发的事件" class="headerlink" title="释放目标时触发的事件"></a>释放目标时触发的事件</h3><p>ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件。<br>ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件。<br>ondragleave 事件：当被鼠标拖动的对象离开其容器范围内时触发此事件。<br>ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件。<br>ondragexit 事件：当一个元素不再拖动立即选择目标元素触发。</p><h1 id="DataTransfer-对象详解"><a href="#DataTransfer-对象详解" class="headerlink" title="DataTransfer 对象详解"></a>DataTransfer 对象详解</h1><p>在进行拖放操作时，DataTransfer 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>dropEffect    String<br>    设置实际的放置效果，它应该始终设置成 effectAllowed  的可能值之一 。<br>effectAllowed    String<br>    用来指定拖动时被允许的效果。<br>files     FileList<br>    包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。<br>types    DOMStringList<br>    保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>addElement(element)<br>    设置拖动源。通常你不需要改变这项，如果修改这项将会影响拖动的哪个节点和dragend事件的触发。默认目标是被拖动的节点。<br>setData(type,data)<br>    为一个给定的类型设置数据。<br>getData()<br>    根据指定的类型检索数据，如果指定类型的数据不存在或者该 DataTransfer 对象中没有数据，方法将返回一个空字符串。<br>clearData(type)<br>    删除与给定类型关联的数据。类型参数是可选的。<br>setDragImage(imgElement,offsetX,offsetY)<br>    自定义一个期望的拖动时的图片。大多数情况下，这项不用设置，因为被拖动的节点被创建成默认图片。</p><h1 id="实现拖拽"><a href="#实现拖拽" class="headerlink" title="实现拖拽"></a>实现拖拽</h1><h2 id="确定什么是可拖动的"><a href="#确定什么是可拖动的" class="headerlink" title="确定什么是可拖动的"></a>确定什么是可拖动的</h2><p>让一个元素被拖动需要添加 draggable 属性，再加上全局事件处理函数ondragstart。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">console.log(&quot;dragStart&quot;);</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="定义拖动数据"><a href="#定义拖动数据" class="headerlink" title="定义拖动数据"></a>定义拖动数据</h2><p>应用程序可以在拖动操作中包含任意数量的数据项。每个数据项都是一个  string 类型，典型的MIME类型，如：text/html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">// 添加拖拽数据</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">ev.dataTransfer.setData(&quot;text/html&quot;, &quot;&lt;p&gt;Example paragraph&lt;/p&gt;&quot;);</div><div class="line">ev.dataTransfer.setData(&quot;text/uri-list&quot;, &quot;http://developer.mozilla.org&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="定义拖动图像"><a href="#定义拖动图像" class="headerlink" title="定义拖动图像"></a>定义拖动图像</h2><p>拖动过程中，浏览器会在鼠标旁显示一张默认图片。当然，应用程序也可以通过setDragImage() 方法自定义一张图片.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123; </div><div class="line">var img = new Image(); </div><div class="line">img.src = &apos;example.gif&apos;; </div><div class="line">ev.dataTransfer.setDragImage(img, 10, 10);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：img 的 src 属性路径是以使用该 js 页面为基准。</p><h2 id="定义拖动效果"><a href="#定义拖动效果" class="headerlink" title="定义拖动效果"></a>定义拖动效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">  // Set the drag effect to copy</div><div class="line">  ev.dataTransfer.dropEffect = &quot;copy&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="定义一个放置区"><a href="#定义一个放置区" class="headerlink" title="定义一个放置区"></a>定义一个放置区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function dragover_handler(ev) &#123;</div><div class="line">// 这里必须阻止默认行为，否则没有效果</div><div class="line">ev.preventDefault();</div><div class="line">ev.dataTransfer.dropEffect = &quot;move&quot;</div><div class="line">&#125;</div><div class="line">function drop_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">// Get the id of the target and add the moved element to the target&apos;s DOM</div><div class="line">var data = ev.dataTransfer.getData(&quot;text&quot;);</div><div class="line">ev.target.appendChild(document.getElementById(data));</div><div class="line">&#125;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><h2 id="处理放置效果"><a href="#处理放置效果" class="headerlink" title="处理放置效果"></a>处理放置效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function dragstart_handler(ev) &#123;</div><div class="line">ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</div><div class="line">ev.dropEffect = &quot;move&quot;;</div><div class="line">&#125;</div><div class="line">function dragover_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">// Set the dropEffect to move</div><div class="line">ev.dataTransfer.dropEffect = &quot;move&quot;</div><div class="line">&#125;</div><div class="line">function drop_handler(ev) &#123;</div><div class="line">ev.preventDefault();</div><div class="line">var data = ev.dataTransfer.getData(&quot;text&quot;);</div><div class="line">ev.target.appendChild(document.getElementById(data));</div><div class="line">&#125;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</div><div class="line">&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><h2 id="拖动结束"><a href="#拖动结束" class="headerlink" title="拖动结束"></a>拖动结束</h2><p>在拖动目标元素上监听 dragend 事件，此时你可以做一起其他事情。</p><blockquote><p>   参考文档：<br>    <a href="http://www.zhangxinxu.com/wordpress/2011/02/html5-drag-drop-%E6%8B%96%E6%8B%BD%E4%B8%8E%E6%8B%96%E6%94%BE%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">HTML5 drag &amp; drop 拖拽与拖放简介</a><br>    <a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="external">HTML5 拖放（Drag 和 Drop）详解与实例</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="external">DataTransfer</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="external">Drag and Drop API</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理论介绍&quot;&gt;&lt;a href=&quot;#理论介绍&quot; class=&quot;headerlink&quot; title=&quot;理论介绍&quot;&gt;&lt;/a&gt;理论介绍&lt;/h1&gt;&lt;p&gt;拖放（Drag 和 drop）是 HTML5 标准的组成部分。&lt;br&gt;DataTransfer 对象：拖拽对象用来传递的媒介
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>面试杂项</title>
    <link href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html"/>
    <id>https://fanerge.github.io/面试杂项.html</id>
    <published>2018-01-22T14:17:21.000Z</published>
    <updated>2018-01-22T14:51:21.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防止网页被嵌入框架的代码"><a href="#防止网页被嵌入框架的代码" class="headerlink" title="防止网页被嵌入框架的代码"></a>防止网页被嵌入框架的代码</h1><h2 id="任何页面都不可嵌套"><a href="#任何页面都不可嵌套" class="headerlink" title="任何页面都不可嵌套"></a>任何页面都不可嵌套</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 判断当前的window对象是否对顶层top对象还可以使用window.top !== window.self</div><div class="line">if (window !== top) </div><div class="line">// 如果不是，将top对象的网址自动导向被嵌入网页的网址</div><div class="line">top.location.href = window.location.href;</div></pre></td></tr></table></figure><h2 id="本地域名可嵌套，其他域名不可"><a href="#本地域名可嵌套，其他域名不可" class="headerlink" title="本地域名可嵌套，其他域名不可"></a>本地域名可嵌套，其他域名不可</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">　　top.location.hostname;</div><div class="line">　　if (top.location.hostname !== window.location.hostname) &#123;</div><div class="line">　　　　top.location.href = window.location.href;</div><div class="line">　　&#125;</div><div class="line">&#125;catch(e)&#123;</div><div class="line">　　top.location.href = window.location.href;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面两种对于动态生产iframe标签和禁用js不会用效果。<br>别人可能这样禁用你的js<br><code>&lt;noscript&gt;&lt;iframe src=fillseo.html&gt;&lt;/iframe&gt;&lt;/noscript&gt;</code></p><h2 id="js如何判断是否在iframe中"><a href="#js如何判断是否在iframe中" class="headerlink" title="js如何判断是否在iframe中"></a>js如何判断是否在iframe中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//方式一 </div><div class="line">if (self.frameElement &amp;&amp; self.frameElement.tagName == &quot;IFRAME&quot;) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125; </div><div class="line">//方式二 </div><div class="line">if (window.frames.length != parent.frames.length) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125; </div><div class="line">//方式三 </div><div class="line">if (self != top) &#123; </div><div class="line">alert(&apos;在iframe中&apos;); </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="比较可靠的方式"><a href="#比较可靠的方式" class="headerlink" title="比较可靠的方式"></a>比较可靠的方式</h2><p>为了彻底防止别人用IFRAME框架嵌套调用自己的网页，如下方法是最可靠的.<br>这里赋值为空页面,也可赋值为你的页面的URL地址.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(top != self)&#123; </div><div class="line">location.href = &quot;about:blank&quot;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="在meta中设置"><a href="#在meta中设置" class="headerlink" title="在meta中设置"></a>在meta中设置</h2><p><code>&lt;meta http-equiv=&quot;X-FRAME-OPTIONS&quot; content=&quot;DENY&quot;&gt;</code></p><h2 id="在http的header做手脚"><a href="#在http的header做手脚" class="headerlink" title="在http的header做手脚"></a>在http的header做手脚</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">header(‘X-Frame-Options:Deny&apos;);</div><div class="line">header(&quot;X-XSS-Protection: 0&quot;);</div></pre></td></tr></table></figure><h2 id="在Apache、IIS、Nginc主机中设置"><a href="#在Apache、IIS、Nginc主机中设置" class="headerlink" title="在Apache、IIS、Nginc主机中设置"></a>在Apache、IIS、Nginc主机中设置</h2><p><code>X-Frame-Options &quot;SAMEORIGIN&quot;;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;a href=&quot;#防止网页被嵌入框架的代码&quot; class=&quot;headerlink&quot; title=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;/a&gt;防止网页被嵌入框架的代码&lt;/h1&gt;&lt;h2 id=&quot;任何页面都不可嵌套&quot;&gt;&lt;a href=&quot;#任何页面
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MathML</title>
    <link href="https://fanerge.github.io/html5-MathML.html"/>
    <id>https://fanerge.github.io/html5-MathML.html</id>
    <published>2018-01-22T12:44:44.000Z</published>
    <updated>2018-01-23T12:24:53.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。<br>MathML 是一个用于标记数学表达式的 XML 词汇表，它包含两个子语言：Presentation MathML 和 Content MathML。<br>Presentation MathML 主要负责描述数学表达式的布局（因此可与 TeX 或更早的 SGML 标记语言相比较，SGML 用于描述诸如 ISO 12083 之类格式的数学表达式的布局）。<br>Content MathML 主要负责标记表达式的某些含义或数学结构。MathML 的这一方面受到 OpenMath 语言的很大影响，在 MathML3 中，与 OpenMath 更为贴近。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;</div><div class="line">&lt;mrow&gt;</div><div class="line">&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</div><div class="line">&lt;mo&gt;+&lt;/mo&gt;</div><div class="line">&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</div><div class="line">&lt;mo&gt;=&lt;/mo&gt;</div><div class="line">&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</div><div class="line">&lt;/mrow&gt;</div><div class="line">&lt;/math&gt;</div></pre></td></tr></table></figure><p><img src="http://www.runoob.com/wp-content/uploads/2015/12/mathml1.jpg" alt="demo"></p><h1 id="MathML-元素"><a href="#MathML-元素" class="headerlink" title="MathML 元素"></a>MathML 元素</h1><p>这是一份关于 MathML 呈现型元素的、按字母表排序的清单。<br>MathML元素的细节和在桌面浏览器与移动设备浏览器上的兼容性情况。</p><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p><code>&lt;math&gt;  （顶层元素）</code></p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;maction&gt;   （绑定动作到子表达式）</div><div class="line">&lt;maligngroup&gt; （对齐分组）</div><div class="line">&lt;malignmark&gt;  （对齐点）</div></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;menclose&gt; （包含的内容）</div><div class="line">&lt;merror&gt; （包含的语法错误消息）</div></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mfenced&gt; （圆括号）</div><div class="line">&lt;mfrac&gt; （因子）</div></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><code>&lt;mglyph&gt; （显示非标准符号）</code></p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p><code>&lt;mi&gt; （标识符）</code></p><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mlabeledtr&gt;（表格或矩阵中的行标签）</div><div class="line">&lt;mlongdiv&gt;（长除法记号）</div></pre></td></tr></table></figure><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><code>&lt;mmultiscripts&gt; （惯例和张量指标）</code></p><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><p><code>&lt;mn&gt; （数量）</code></p><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mo&gt; （运算符）</div><div class="line">&lt;mover&gt; （上标）</div></pre></td></tr></table></figure><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mpadded&gt;（内容周围的填充空间）</div><div class="line">&lt;mphantom&gt; （预留空间的不可见内容）</div></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;mroot&gt; （带指定根数的根号）</div><div class="line">&lt;mrow&gt; （分组后的子表达式）</div></pre></td></tr></table></figure><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;ms&gt; （字符串字面量）</div><div class="line">&lt;mscarries&gt; （诸如进位的附注）</div><div class="line">&lt;mscarry&gt; （单位进位， </div><div class="line">&lt;mscarries&gt;的子元素）</div><div class="line">&lt;msgroup&gt; （在 &lt;mstack&gt; 和 </div><div class="line">&lt;mlongdiv&gt;元素中分组后的若干行）</div><div class="line">&lt;msline&gt; （在 &lt;mstack&gt; 内部的水平行）</div><div class="line">&lt;mspace&gt; （空格）</div><div class="line">&lt;msqrt&gt; （不带根数的平方根）</div><div class="line">&lt;msrow&gt; （在&lt;mstack&gt;元素中的行）</div><div class="line">&lt;mstack&gt; （堆叠式对齐）</div><div class="line">&lt;mstyle&gt; （样式变更）</div><div class="line">&lt;msub&gt; （下角标）</div><div class="line">&lt;msup&gt; （上角标）</div><div class="line">&lt;msubsup&gt; （上下角标对）</div></pre></td></tr></table></figure><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;mtable&gt; （表格或矩阵）</div><div class="line">&lt;mtd&gt; （表格或矩阵中的单元格）</div><div class="line">&lt;mtext&gt; （文本）</div><div class="line">&lt;mtr&gt; （表格或矩阵中的行）</div></pre></td></tr></table></figure><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;munder&gt; （下标）</div><div class="line">&lt;munderover&gt; （上标-下标对）</div></pre></td></tr></table></figure><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;semantics&gt; （语义附注的容器）</div><div class="line">&lt;annotation&gt; （数据附注）</div><div class="line">&lt;annotation-xml&gt;  （XML 附注）</div></pre></td></tr></table></figure><h1 id="MathML-属性"><a href="#MathML-属性" class="headerlink" title="MathML 属性"></a>MathML 属性</h1><p>关于MathML属性的参考文档。用这些属性可以修改这些元素的显示效果。</p><iframe heigth="50vh" width="100%" src="https://developer.mozilla.org/zh-CN/docs/Web/MathML/Attribute"><br></iframe><p>PS：MathML的 mstyle 和 math 元素接受所有 MathML 的描述元素。<br>    请参阅MathML中值（values）和单位的注释值。</p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/MathML" target="_blank" rel="external">MDN-MathML</a><br>    <a href="http://www.runoob.com/html/html5-mathml.html" target="_blank" rel="external">html5-mathml</a><br>    <a href="https://www.ibm.com/developerworks/cn/xml/x-mathml3/" target="_blank" rel="external">MathML 介绍</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。&lt;br&gt;M
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>代码重构技巧</title>
    <link href="https://fanerge.github.io/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7.html"/>
    <id>https://fanerge.github.io/代码重构技巧.html</id>
    <published>2018-01-16T12:34:50.000Z</published>
    <updated>2018-01-22T12:34:16.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h1><p>任何不会被修改的变量都可以当做参数传入新的函数；一个变量会被修改可以把它当做返回值。</p><h1 id="重构方法-重新组织函数"><a href="#重构方法-重新组织函数" class="headerlink" title="重构方法-重新组织函数"></a>重构方法-重新组织函数</h1><h2 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h2><p>将这段代码放进一个独立地函数中，并让函数名称解释该函数的用途。<br>包装函数的粒度小，复用的几率就大。<br>适用于：为一些代码提供一个清晰的函数名。<br>函数命名：以它“做什么”来命名，而不是以它“怎么做”命名。</p><h2 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h2><p>在函数调用点插入函数本体，然后移除该函数。<br>适用于：原函数内部代码清晰易读，不需要提炼为一个单独的函数。</p><h2 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h2><p>将所有对该变量的引用动作，替换为对它赋值的哪个表达式自身。<br>适用于：只使用了一次，或许可以移除该临时变量。</p><h2 id="Replace-Temp-with-Query（以查询取代临时变量）"><a href="#Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp with Query（以查询取代临时变量）"></a>Replace Temp with Query（以查询取代临时变量）</h2><p>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其它函数使用。<br>适用于：由于临时变量作用域只在函数内部，如果把临时变量替换为一个查询，那么同一个类中的所有函数都可以获取这份信息。</p><h2 id="Introduce-Explaining-Variable（引入解释性变量）"><a href="#Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaining Variable（引入解释性变量）"></a>Introduce Explaining Variable（引入解释性变量）</h2><p>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。<br>适用于：用一个命名清晰的变量来代替难以理解的代码或函数。</p><h2 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h2><p>针对每次赋值，创造一个独立、对应的临时变量（再多一个临时变量）。<br>适用于：你的程序有某个临时变量被赋值超过一次，它即不是循环变量，而不被用于收集计算结果。</p><h2 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h2><p>以一个临时变量取代该参数的位置。<br>适用于：用一个临时变量（有意义的名字）保存参数。</p><h2 id="Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Method Object（以函数对象取代函数）"></a>Replace Method with Method Object（以函数对象取代函数）</h2><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。<br>然后你可以在同一个对象中将这个大型函数分解为多个小型函数。<br>适用于：你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。</p><h2 id="Substitute-Algorithm（替换算法）"><a href="#Substitute-Algorithm（替换算法）" class="headerlink" title="Substitute Algorithm（替换算法）"></a>Substitute Algorithm（替换算法）</h2><p>将函数本体代替为另一个算法。<br>适用于：你想要把某个算法替换为另一个更加清晰的算法。</p><h1 id="重构方法-在对象之间搬移特性"><a href="#重构方法-在对象之间搬移特性" class="headerlink" title="重构方法-在对象之间搬移特性"></a>重构方法-在对象之间搬移特性</h1><h2 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h2><p>在该函数最常引用的类中建立一个有着类似行为的新函数。<br>将旧函数编程一个单纯的委托函数，或是将旧函数完全移除。<br>适用于：一个类有太多行为，或一个类与另一个类有太多合作而形成高度耦合。</p><h2 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h2><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。<br>适用于：对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它。</p><h2 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h2><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。<br>适用于：某个类做了应该由两个类做的事。</p><h2 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h2><p>将这个类的所有特性搬移到另一个类中，然后移除原类。<br>适用于：某个类没有做太多事情。</p><h2 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h2><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。<br>适用于：客户通过一个委托类来调用另一个对象。</p><h2 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h2><p>让客户直接调用受托类。<br>适用于：某个类做了过多的简单委托动作。</p><h2 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h2><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。<br>适用于：你需要为提供服务的类添加一个函数，但你无法修改这个类。<br>外加函数终归是权益之计，尽量将其搬移到服务类中去（Introduce Local Extension）。</p><h2 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h2><p>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。<br>适用于：你需要为服务类提供一些额外函数，但你无法修改这个类。</p><h1 id="重构方法-重新组织数据"><a href="#重构方法-重新组织数据" class="headerlink" title="重构方法-重新组织数据"></a>重构方法-重新组织数据</h1><h2 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h2><p>为这个字段建立取值/设置函数，并且只以这些函数来访问字段。<br>适用于：你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。</p><h2 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h2><p>将数据项变成对象。<br>适用于：你有一个数据项，需要与其他数据和行为一起使用才有意义。</p><h2 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h2><p>将这个值对象变成引用对象。<br>适用于：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。</p><h2 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h2><p>将它变成一个值对象。<br>适用于：你有一个引用对象，很小且不可该表，而且不易管理。</p><h2 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h2><p>以对象替换数组。对于数组中的每个元素，以一个字段来表示。<br>适用于：你有一个数组，其中的元素各自代表不同的东西。</p><h2 id="Duplicate-Observed-Data（复制“被监视数据”）"><a href="#Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data（复制“被监视数据”）"></a>Duplicate Observed Data（复制“被监视数据”）</h2><p>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。<br>MVC模型</p><h2 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><p>添加一个反向指针，并使修改函数能够同时更新两条连接。<br>适用于：两个类都需要使用对方特性，但其间只有一条单向连接。</p><h2 id="Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><p>去除不必要的关联。<br>适用于：两个类之间有双向关联，但其中一个类如今不需要另一个类的特性。</p><h2 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h2><p>创造一个常量，根据其意义为它命名，并将上述的字面量替换为这个常量。<br>适用于：你有一个字面数值，带上特别含义。</p><h2 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h2><p>将它声明为private，并提供相应的访问函数get和set。<br>适用于：你的类中存在一个public字段。</p><h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>让这个函数返回集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。<br>适用于：有一个函数返回一个集合。</p><h2 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h2><p>为该记录创建一个“哑”数据对象。<br>适用于：你需要面对传统编程环境中的记录结构。</p><h2 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h2><p>以一个新的类替换该数值类型码。<br>适用于：类之中有一个数值类型码，但它并不影响类的行为。</p><h2 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h2><p>以自带取代这个类型码（多态）。<br>适用于：你有一个不可变的类型码，它会影响类的行为。</p><h2 id="Replace-Type-Code-with-State-Strategy（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy（以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy（以State/Strategy取代类型码）</h2><p>以状态对象取代类型码。<br>适用于：你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。</p><h2 id="Replace-Subclass-with-Fields（以字段取代子类）"><a href="#Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="Replace Subclass with Fields（以字段取代子类）"></a>Replace Subclass with Fields（以字段取代子类）</h2><p>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。<br>适用于：你的各个子类的唯一差别只在“返回常量数据”的函数身上。</p><h1 id="重构方法-简化条件表达式"><a href="#重构方法-简化条件表达式" class="headerlink" title="重构方法-简化条件表达式"></a>重构方法-简化条件表达式</h1><h2 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h2><p>从if、then、else三个段落中分别提炼出独立函数。<br>适用于：你有一个复杂的条件（if-then-else）语句。</p><h2 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h2><p>将这些测试合并为一个条件表达式，并将这个表达式提炼成一个独立的函数。<br>适用于：你有一系列条件测试，都得到相同结果。</p><h2 id="Consilidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consilidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consilidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consilidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将这个端重复代码搬移到条件表达式之外。<br>适用于：在条件表达式的每个分支上有着相同的一段代码。</p><h2 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h2><p>以break语句或return语句取代控制标记。<br>适用于：在一系列布尔表达式中，某个变量带有“控制标记”（control flag）的作用。</p><h2 id="Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）</h2><p>使用卫语句表现所有特殊情况（尽量不要转换成嵌套）。<br>适用于：函数中的条件逻辑使人难以看清正常的执行路径。</p><h2 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br>适用于：你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p><h2 id="Introduce-Null-Object（引入Null对象）"><a href="#Introduce-Null-Object（引入Null对象）" class="headerlink" title="Introduce Null Object（引入Null对象）"></a>Introduce Null Object（引入Null对象）</h2><p>将null值替换为null对象。<br>适用于：你需要再三检查对象是否为null。</p><h2 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h2><p>以断言明确表现这种假设。<br>适用于：某一段代码需要对程序状态做出某种假设。</p><h1 id="重构方法-简化函数调用"><a href="#重构方法-简化函数调用" class="headerlink" title="重构方法-简化函数调用"></a>重构方法-简化函数调用</h1><h2 id="Rename-Method（函数改名）"><a href="#Rename-Method（函数改名）" class="headerlink" title="Rename Method（函数改名）"></a>Rename Method（函数改名）</h2><p>修改函数的名称。<br>适用于：函数的名称未能解释函数的用途。<br>函数命名，参考“做什么”而不是“怎么做”。</p><h2 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h2><p>为此函数添加一个对象参数，让该对象带进函数所需信息。<br>适用于：某个函数需要从调用端得到更对信息。<br>这样做有一个好处，不用关心参数的位置。</p><h2 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h2><p>将该参数去除。<br>适用于：函数本体不再需要某个参数。</p><h2 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h2><p>建立两个不同的函数，其中一个负责查询，另一个负责修改。<br>适用于：某个函数既返回对象状态值，又修改对象状态。</p><h2 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h2><p>建立单一函数，以参数表达那些不同的值。<br>适用于：若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p><h2 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h2><p>针对该参数的每一个可能值，建立一个独立函数。<br>适用于：你有一个函数，其中完全取决于参数值而不采取不同行为。</p><h2 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h2><p>改为传递整个对象（传递整个对象，不要值传递对象的某些属性）。<br>适用于：你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p><h2 id="Replace-Parameter-with-Methods（以函数取代参数）"><a href="#Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="Replace Parameter with Methods（以函数取代参数）"></a>Replace Parameter with Methods（以函数取代参数）</h2><p>让参数接受者去除该项参数，并直接调用前一个函数。<br>适用于：对象调用某一个函数，并将所得结果作为参数，传递给另一个函数。<br>而接受参数的函数本身也能够用前一个函数。</p><h2 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h2><p>以一个对象取代这些参数。<br>适用于：某些参数总是很自然地同时出现。</p><h2 id="Remove-Setting-Method（移除设置函数）"><a href="#Remove-Setting-Method（移除设置函数）" class="headerlink" title="Remove Setting Method（移除设置函数）"></a>Remove Setting Method（移除设置函数）</h2><p>去掉该字段的所有设值函数。<br>适用于：类中的某个字段应该在对象创建时被设值，然后不再改变。</p><h2 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h2><p>将这个函数修改为private。<br>适用于：有一个函数，从来没有被其他任何类用到。</p><h2 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h2><p>将构造函数替换为工厂函数。<br>适用于：你希望在创建对象时不仅仅时做简单的建构动作。</p><h2 id="Enucapsulate-Downcast（封装向下转型）"><a href="#Enucapsulate-Downcast（封装向下转型）" class="headerlink" title="Enucapsulate Downcast（封装向下转型）"></a>Enucapsulate Downcast（封装向下转型）</h2><p>将向下转型动作移到函数中。<br>适用于：某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。</p><h2 id="Replace-Error-Code-with-Exception（异常取代错误代码）"><a href="#Replace-Error-Code-with-Exception（异常取代错误代码）" class="headerlink" title="Replace Error Code with Exception（异常取代错误代码）"></a>Replace Error Code with Exception（异常取代错误代码）</h2><p>改用异常。<br>适用于：某个函数返回一个特定的代码，用以表示某种错误情况。</p><h2 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h2><p>修改调用者，使它在调用函数之前先做检查。<br>适用于：面对一个调用这可以预先检查的条件，你抛出了一个异常。</p><h1 id="重构方法-处理概括关系（继承关系）"><a href="#重构方法-处理概括关系（继承关系）" class="headerlink" title="重构方法-处理概括关系（继承关系）"></a>重构方法-处理概括关系（继承关系）</h1><h2 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h2><p>将该字段移至超类。<br>适用于：两个子类都拥有相同的字段。</p><h2 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h2><p>将函数移至超类。<br>适用于：有些函数，在各个子类中产生完全相同的结果。</p><h2 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h2><p>在超类中新建一个构造函数，并在子类构造函数中调用它。<br>适用于：你在各个子类中拥有一些构造函数，它们的本体机会完全一致。</p><h2 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h2><p>将这个函数移到相关的那些子类去。<br>适用于：超类中的某个函数只与部分（而非全部）子类有关。</p><h2 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h2><p>将这个字段移到需要它的那些子类去。<br>适用于：超类中的某个字段只被部分（而非全部）子类用到。</p><h2 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h2><p>新建一个子类，将上面所说的那一部分特性移到子类中。<br>适用于：类中的某些特性只被某些（而非全部）实例用到。</p><h2 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h2><p>为这两个类建立建立一个超类，将相同特性移至超类。<br>适用于：这两个类有相似特性。</p><h2 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h2><p>将相同的子集提炼到一个独立接口中。<br>适用于：若干客户适用类接口中的同一子集，或者两个类的接口有部分相同。</p><h2 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h2><p>将它们合为一体。<br>适用于：超类和子类之间无太大区别。</p><h2 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h2><p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。<br>适用于：你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节有所不同。</p><h2 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h2><p>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。<br>适用于：某个子类只适用超类接口中的一部分，或是根本不需要继承而来的数据。</p><h2 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h2><p>让委托类继承受托类。<br>适用于：你在两个类之间委托关系，并经常为整个接口编写许多极简单的委托函数。</p><h1 id="重构方法-大型重构"><a href="#重构方法-大型重构" class="headerlink" title="重构方法-大型重构"></a>重构方法-大型重构</h1><h2 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h2><p>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。<br>适用于：某个继承体系同时承担两项责任。</p><h2 id="ConvertProcedural-Design-to-Objects（将过程化设计转化为对象设计）"><a href="#ConvertProcedural-Design-to-Objects（将过程化设计转化为对象设计）" class="headerlink" title="ConvertProcedural Design to Objects（将过程化设计转化为对象设计）"></a>ConvertProcedural Design to Objects（将过程化设计转化为对象设计）</h2><p>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。<br>适用于：你手上有一些传统过程化风格的代码。</p><h2 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h2><p>将领域逻辑分离出来，为它们建立独立地领域类。<br>适用于：某些GUI类之中包含了领域逻辑。</p><h2 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h2><p>建立继承体系，以一个子类表示一种特殊情况。<br>适用于：你有某个类做了太多工作，其中一部分工作是以大量表达式完成的。</p><h1 id="代码的坏味道–及解决方案"><a href="#代码的坏味道–及解决方案" class="headerlink" title="代码的坏味道–及解决方案"></a>代码的坏味道–及解决方案</h1><h2 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h2><p>Extract Method（提炼函数）<br>Pull Up Method（函数上移到超类）<br>Form Template Method（塑造模板函数）<br>Substitute Algorithm（替换算法）<br>Extract Class（提炼类）</p><h2 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h2><p>Extract Method（提炼函数）<br>Replace Temp with Query（以查询取代临时变量）<br>Introduce Parameter Object（引入参数对象）<br>Preserve Whole Object（保持对象完整）<br>Replace Method with Method Object（以函数对象取代函数）<br>Decompose Conditional（分解条件表达式）</p><h2 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h2><p>Extract Class（提炼类）<br>Extract Subclass（提炼子类）<br>Extract Interface（提炼接口）<br>Duplicate Observed Data（复制“被监视数据”）</p><h2 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h2><p>Replace Parameter with Method（用函数替换参数）<br>Preserve Whole Object（保持对象完整）<br>Introduce Parameter Object（引入参数对象）</p><h2 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h2><p>Extract Class（提炼类）</p><h2 id="Shotgun-Surgery（霰xian弹式修改）"><a href="#Shotgun-Surgery（霰xian弹式修改）" class="headerlink" title="Shotgun Surgery（霰xian弹式修改）"></a>Shotgun Surgery（霰xian弹式修改）</h2><p>Move Method（移动函数）<br>Move Field（移动字段）<br>Inline Class（内联类）</p><h2 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h2><p>Move Method（移动函数）<br>Extract Method（提炼方法）</p><h2 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h2><p>Extract Class（提炼类）<br>Introduce Parameter Object（引入参数对象）<br>Preserve Whole Object（保持整个对象）</p><h2 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h2><p>Replace Data Value with Object（用对象替换数据值）<br>Replace Type Code with Class（用类替换类型代码）<br>Extract Class（提炼类）<br>Introduce Parameter Object（引入参数对象）<br>Replace Array with Object（用对象代替数组）</p><h2 id="Switch-Statements（switch-惊悚现身）"><a href="#Switch-Statements（switch-惊悚现身）" class="headerlink" title="Switch Statements（switch 惊悚现身）"></a>Switch Statements（switch 惊悚现身）</h2><p>Extract Method（提炼函数）<br>Move Method（移动函数）<br>Replace Type Code with Subclass（以子类替换类型代码）<br>Replace Type Code with State/Strategy（以State/Strategy取代类型码）<br>Replace Conditional with Polymorphism（以多态取代条件表达式）<br>Replace Parameter with Explicit Methods（以明确函数取代参数）<br>Introduce Null Object（引入null对象）</p><h2 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h2><p>Move Method（移动函数）<br>Move Field（移动字段）</p><h2 id="Lazy-Class（冗赘类）"><a href="#Lazy-Class（冗赘类）" class="headerlink" title="Lazy Class（冗赘类）"></a>Lazy Class（冗赘类）</h2><p>Collapse Hierarchy（折叠继承体系）<br>Inline Class（内联类）</p><h2 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h2><p>Collapse Hierarchy（折叠继承体系）<br>Inline Class（内联类）<br>Remove Parameter（移除参数）<br>Rename Method（移除函数）</p><h2 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h2><p>Extract Class（提炼类）<br>Introduce Null Object（引入Null对象）</p><h2 id="Message-Chains（过渡耦合的消息链）"><a href="#Message-Chains（过渡耦合的消息链）" class="headerlink" title="Message Chains（过渡耦合的消息链）"></a>Message Chains（过渡耦合的消息链）</h2><p>Hide Delegate（隐藏“委托关系”）<br>Extract Method（提炼函数）<br>Move Method（移动函数）</p><h2 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h2><p>Remove Middle Man（中间人）<br>Inline Method（内联方法）<br>Replace Delegation with Inheritance（以继承取代委托）</p><h2 id="Inappropriate-Intimacy（狎昵关系）–两个类过于亲密"><a href="#Inappropriate-Intimacy（狎昵关系）–两个类过于亲密" class="headerlink" title="Inappropriate Intimacy（狎昵关系）–两个类过于亲密"></a>Inappropriate Intimacy（狎昵关系）–两个类过于亲密</h2><p>Move Method（移动函数）<br>Move Field（移动字段）<br>Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）<br>Extract Class（提炼类）<br>Hide Delegate（隐藏“委托关系”）<br>Replace Inheritance with Delegation（以委托取代继承）</p><h2 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h2><p>Rename Method（重命名函数）<br>Move Method（移动函数）<br>Extract Superclass（提炼超类）</p><h2 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h2><p>Move Method（移动函数）<br>Intorduce Foreign Method（引入外加函数）<br>Introduce Local Extension（引入本地扩展）</p><h2 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h2><p>Encapsulate Field（自封装字段）<br>Encapsulate Collection（封装集合）<br>Remove Setting Method（移除设置函数）<br>Move Method（移除函数）<br>Extract Method（提炼函数）<br>Hide Method（隐藏函数）</p><h2 id="Refused-Bequest（被拒绝的馈赠）"><a href="#Refused-Bequest（被拒绝的馈赠）" class="headerlink" title="Refused Bequest（被拒绝的馈赠）"></a>Refused Bequest（被拒绝的馈赠）</h2><p>Push Down Method（函数下移）–移动子类<br>Push Down Field（字段下移）<br>Replace Inheritance with Delegation（以委托取代继承）</p><h2 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h2><p>Rename Metho（重命名方法）<br>Introduce Assertion（引入断言）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文整理于《重构改善既有代码的设计》，这本书是用java写的，整理的目的是为了自己能写出更健壮、更具扩展性的代码，为以后的编码做参考。<br>个人能力有限，如有理解不当还望指出，更深入的了解还请参阅次书籍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构技巧&quot;&gt;&lt;a href=&quot;#重构技巧&quot; class=&quot;headerlink&quot; title=&quot;重构技巧&quot;&gt;&lt;/a&gt;重构技巧&lt;/h1&gt;&lt;p&gt;任何不会被修改的变量都可以当做参数传入新的函数；一个变量会被修改可以把它当做返回值。&lt;/p&gt;
&lt;h1 id=&quot;重构方法-重新
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码重构" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>git使用手册</title>
    <link href="https://fanerge.github.io/git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/git使用手册.html</id>
    <published>2018-01-13T12:50:00.000Z</published>
    <updated>2018-03-16T14:01:05.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git基础知识"><a href="#git基础知识" class="headerlink" title="git基础知识"></a>git基础知识</h1><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的 工作目录，它持有实际文件；<br>第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；<br>最后是 HEAD，它指向你最后一次提交的结果。<br>下图展示其关系<br><img src="http://www.runoob.com/manual/git-guide/img/trees.png" alt="git工作流"></p><h2 id="git配置用户信息"><a href="#git配置用户信息" class="headerlink" title="git配置用户信息"></a>git配置用户信息</h2><p>Git是分布式版本控制系统，SVN都是集中式的版本控制系统（需要中央服务器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;Your Name&quot;</div><div class="line">git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure></p><p>PS：注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir dirname </div><div class="line">cd dirname</div><div class="line">pwd // pwd命令用于显示当前目录(绝对路径)</div><div class="line">git init // 把这个目录变成Git可以管理的仓库</div></pre></td></tr></table></figure></p><p>PS：目录名和文件名不可有中文<br>    .git 文件就是Git来跟踪管理版本库，千万别手动更改。<br>    如果没有.git 文件（系统隐藏关键文件），可以 ls -ah命令来查看</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>第一步，用命令git add告诉Git，把文件<span style="color: red">添加</span>到仓库：<br>实际上就是把文件修改添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git add fileName</div><div class="line">git add *.js // 通配符</div><div class="line">git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</div><div class="line">git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</div><div class="line">git add -A  提交所有变化（是git add .和git add -u的结合，git add -all的简写）</div></pre></td></tr></table></figure></p><p>git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。<br>git add -u ：（git add –update的缩写）他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。<br><strong>2018-03-16更新</strong><br>PS：可以向git库多次添加文件，并一次提交<br>第二步，用命令git commit告诉Git，把文件<span style="color: red">提交</span>到仓库：<br>实际上就是把暂存区的所有内容提交到当前分支（默认是master分支）<br><code>git commit -m &quot;说明文本&quot;</code><br>PS：-m后面输入的是本次提交的说明，方便以后查看<br>更好的理解：需要提交的文件修改通过放到暂存区，然后，一次性提交暂存区的所有修改。<br><code>git commit -am &#39;说明&#39;</code><br>PS：git add 和 git commit的简写<br>清屏<br><code>reset + Enter</code><br>该命令可以让我们时刻掌握仓库当前的状态（当前是否有需要提交的修改）<br><code>git mv &lt;oldName&gt; &lt;nemeName&gt;</code><br>PS：git mv 命令用于移动或重命名一个文件、目录、软连接。<br><code>git status</code><br>PS：列出当前目录所有还没有被git管理的文件和 被git管理且被修改但还未提交（git commit）的文件。<br>查看具体修改了什么内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git diff</div><div class="line">git diff HEAD -- fileName // 比对某个文件</div><div class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</div><div class="line">比对两个分支</div><div class="line">尚未缓存的改动：git diff</div><div class="line">查看已缓存的改动： git diff --cached</div><div class="line">查看已缓存的与未缓存的所有改动：git diff HEAD</div><div class="line">显示摘要而非整个 diff：git diff --stat</div></pre></td></tr></table></figure></p><p>PS：提交仓库前最好看一下，这是不是我们更改的。<br>经过对比后，就可以放心的添加和提交文件了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add fileName</div><div class="line">git commit -m &apos;note&apos;</div></pre></td></tr></table></figure></p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>该命令显示从最近到最远的提交日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git log // 下面命令仅仅显示commit id（版本号），它是16进制数</div><div class="line">git log --oneline // 历史记录的简洁的版本</div><div class="line">git log --oneline --graph // 查看历史中什么时候出现了分支、合并</div><div class="line">git log --reverse --oneline // 逆向显示所有日志</div><div class="line">git log --author=fanerge // 查找指定用户的提交日志</div><div class="line">git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges </div><div class="line">// --since 和 --before，但是你也可以用 --until 和 --after</div></pre></td></tr></table></figure></p><p>回到上一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 当前版本是HEAD，上一个版本就是HEAD^，上上一个版本就是HEAD^^，前100的版本HEAD~100</div><div class="line">git reset --hard HEAD^ // 回到上一个版本</div></pre></td></tr></table></figure></p><p>回到未来的版本<br><code>git reset --hard 版本号 // 版本号可以只写几位，git帮我们完善</code><br>显示文件<br><code>cat fileName</code><br>如果忘记版本号想回到最新的版本怎么办？该命令可以查看到版本号<br><code>git reflog</code><br>PS：可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><pre><code>就是之前mkdir生产的目录，存放git项目的目录。</code></pre><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><pre><code>工作区有一个隐藏目录.git，这个就是Git的版本库。</code></pre><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>PS：其实git add fileName命令就是讲对应的文件添加到暂存区<br>    其实git commit 命令仅仅是将暂存区的东西提交到当前分支</p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>Git跟踪并管理的是修改，而非文件。<br>Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>把 fileName 文件在工作区的修改全部撤销，这里有三种情况：</p><ol><li>一是 fileName 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>二是 fileName 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li><li>三是 fileName 已经提交到本地版本库中，请使用 git reset –hard HEAD^<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。</li></ol><p>处理方式：</p><h3 id="尚未存在暂存区"><a href="#尚未存在暂存区" class="headerlink" title="尚未存在暂存区"></a>尚未存在暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- fileName</div></pre></td></tr></table></figure><p>PS：git checkout -- fileName命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。</p><h3 id="已存在暂存区"><a href="#已存在暂存区" class="headerlink" title="已存在暂存区"></a>已存在暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset HEAD fileName</div><div class="line">git checkout -- fileName // 必须要使用第一点的方式</div></pre></td></tr></table></figure><p>PS：git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。<br><img src="http://marklodato.github.io/visual-git-guide/basic-usage.svg" alt="工作区-暂存区-HEAD"><br>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p><ul><li>git add files 把当前文件放入暂存区域。</li><li>git commit 给暂存区域生成快照并提交。</li><li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li><li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>直接右键或命令删除文件<br><code>rm fileName</code><br>PS：此时，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了<br>这是有两种处理方式：</p><ol><li><p>真的想删除这个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm fileName // git中删除对应文件</div><div class="line">git commit -m &apos;说明&apos; // 同步工作区和版本库</div></pre></td></tr></table></figure></li><li><p>删错了，你想从版本库中恢复（无论工作区是修改还是删除，都可以“一键还原”）<br><code>git checkout -- fieName</code><br>PS：命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。    </p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="设置ssh（以github举例）"><a href="#设置ssh（以github举例）" class="headerlink" title="设置ssh（以github举例）"></a>设置ssh（以github举例）</h2><p>第1步：创建SSH Key。<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa（私钥）和id_rsa.pub（公钥）两个文件<br>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>这里包括title和key字段</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p><code>git remote add origin git@github.com:fanerge/repositoryName.git</code><br>把本地库与远程库进行关联（在本地库目录下进行）<br>远程库的名字就是origin，这是Git默认的叫法<br><code>git push -u origin master</code><br>把本地库的所有内容推送到远程库上<br>其实git push 是把当前分支如 master 推送到远程<br>PS：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>以后推送只需下面命令：<br><code>git push origin master</code>    </p><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:fanerge/仓库名.git</div><div class="line">or</div><div class="line">git clone &lt;repo&gt; &lt;directory&gt; // 克隆到指定的目录</div><div class="line">cd 仓库名</div><div class="line">ls</div></pre></td></tr></table></figure></li></ol><p>PS：git支持多种协议 ssh、https等</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。    </p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout -b branchName</div><div class="line">git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</div><div class="line">git branch branchName // 创建分支</div><div class="line">git checkout branchName // 切换到分支</div><div class="line">git branch</div><div class="line">查看分支</div></pre></td></tr></table></figure></p><p>PS：git branch 命令会列出所有分支，当前分支前面会标一个*号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">dev分支的工作完成，我们就可以切换回master分支</div><div class="line">git merge branchName</div><div class="line">git merge命令用于合并指定分支到当前分支（这里是将dev合并到master）。</div></pre></td></tr></table></figure></p><p>PS：这个操作只能在主分支master上进行。<br>    Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p><code>git branch -d branchName</code></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。<br>    假如 readme.txt 存在冲突。<br>第一步：打开 readme.txt 文件手动处理冲突<br>第二步：添加到暂存区 git add readme.txt<br>第三步：提交到当前分支 git commit -m ‘说明’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log --graph --pretty=oneline --abbrev-commit</div><div class="line">用带参数的git log也可以看到分支的合并情况</div><div class="line">用git log --graph命令可以看到分支合并图。</div></pre></td></tr></table></figure></p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev</div><div class="line">git add readme.txt </div><div class="line">git commit -m &quot;add merge&quot;</div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</div><div class="line">准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward。</div><div class="line">因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</div></pre></td></tr></table></figure></p><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>所有人都在 dev 分支上开发，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br>使用场景，在开发过程中新接收到一个bug需要紧急处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line">Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</div></pre></td></tr></table></figure></p><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git checkout -b issue-101</div></pre></td></tr></table></figure></p><h3 id="创建bug分支"><a href="#创建bug分支" class="headerlink" title="创建bug分支"></a>创建bug分支</h3><p>修复bug之后（提交修复bug相关的代码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git add readme.txt </div><div class="line">git commit -m &quot;fix bug 101&quot;</div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line">git branch -d issue-101</div></pre></td></tr></table></figure></p><p>现在需要切换到原来分支继续开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout dev</div><div class="line">git status</div><div class="line">git stash list</div></pre></td></tr></table></figure></p><p>PS：工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一种 git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除<br>一种 git stash pop，恢复的同时把stash内容也删了<br>PS：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>    当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br><code>git branch -D branchName</code><br>    强行删除一个没有合并的分支<br>PS：开发一个新feature，最好新建一个分支；<br>    如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。    </name></p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。<br><code>git remote</code><br>    查看远程库的信息（origin）<br><code>git remote -v</code><br>    显示更详细的信息，显示了可以抓取（fetch）和推送（push）的origin的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<br><code>git push origin master</code><br>    master 表示你要往远程那个分支推送<br>PS：一般 master、dev 分支需要推送到远程库，其它分支不需要。</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p><code>git branch --set-upstream dev origin/dev</code><br>    把本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接<br><code>git fetch</code><br>PS：相当于是从远程获取最新版本到本地，不会自动merge<br><code>git pull</code><br>PS：相当于是从远程获取最新版本并merge到本地（git fetch + git merge）<br>    把最新的提交从origin/dev抓下来（提交前需要拉取分支的最新代码）<br>手动处理冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;说明&quot;</div><div class="line">git push origin dev</div></pre></td></tr></table></figure></p><pre><code>推送到远程dev分支</code></pre><p>多人协作的工作模式的步骤：    </p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</li></ol><p>PS：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。    </p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。    </p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git checkout master</div><div class="line">切换到需要打标签的分支</div><div class="line">git tag tagName</div><div class="line">打标签</div><div class="line">git tag -a tagName </div><div class="line">-a 选项意为&quot;创建一个带注解的标签&quot;（谁打的，什么时候打的）</div><div class="line">git tag</div><div class="line">查看所有标签</div><div class="line">git tag tagName commitId</div><div class="line">给特定版本号打标签</div><div class="line">git show tagName</div><div class="line">查看标签信息</div><div class="line">git tag -a tagName -m &quot;说明&quot; commitId</div><div class="line">创建带有说明的标签，用-a指定标签名，-m指定说明文字</div><div class="line">git tag -s tagName -m &quot;说明&quot; commitId</div><div class="line">通过-s用私钥签名（PGP签名标签）一个标签</div></pre></td></tr></table></figure><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p><code>git tag -d tagName</code><br>    如果标签打错了，也可以删除<br>PS：因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git push origin tagName</div><div class="line">推送某一个标签到远端</div><div class="line">git push origin --tags</div><div class="line">推送全部尚未推送到远端的本地标签</div><div class="line">git tag -d tagName</div><div class="line">git push origin :refs/tags/tagName</div><div class="line">如果标签已经推送到远程，先本地删除，再远程删除。</div></pre></td></tr></table></figure></p><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;fanerge&quot;</div><div class="line">git config --global user.email fanerge@example.com</div><div class="line">配置用户信息</div><div class="line">git config --global color.ui true</div><div class="line">让Git显示颜色，会让命令输出看起来更醒目。</div><div class="line">git config --global core.editor notepad++</div><div class="line">配置文本编辑器</div><div class="line">git config --global merge.tool vimdiff</div><div class="line">配置差异分析工具</div><div class="line">git config --list</div><div class="line">查看全部配置信息</div><div class="line">git config configName</div><div class="line">查看单个配置信息</div></pre></td></tr></table></figure><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>创建一个特殊的.gitignore文件，把需要忽略的文件名填进去就可。<br>    在这个目录的文件<br>    <a href="https://github.com/github/gitignore" target="_blank" rel="external">所有配置文件可以直接在线浏览</a><br>忽略文件的原则是：<br>    忽略操作系统自动生成的文件，比如缩略图等；<br>    忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>    忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br>有时需要向git添加文件，但又添加不上，需要检查.gitignore哪里写错了<br><code>git check-ignore -v fileName</code><br>暴力向git添加文件<br><code>git add -f fileName // 不建议使用</code></p><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st status</div><div class="line">为status 设置为 st 别名</div><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>每个仓库的Git配置文件都放在.git/config文件中。<br>cat .git/config<br>    查看本仓库的配置</p><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">具体步骤</a><br><a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="external">管理公钥</a><br><a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">管理权限</a></p><h1 id="附上参考手册"><a href="#附上参考手册" class="headerlink" title="附上参考手册"></a>附上参考手册</h1><p><embed id="pdfPlayer" src="http://oxpnrlb4j.bkt.clouddn.com/git-cheatsheet.pdf" type="application/pdf" width="100%" height="500px">    </p><blockquote><p>   参考文档：<br>    <a href="https://git-scm.com/" target="_blank" rel="external">git官网</a><br>    <a href="http://www.runoob.com/manual/git-guide/" target="_blank" rel="external">git - 简明指南</a><br>    <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="external">廖雪峰-git教程</a><br>    <a href="http://www.runoob.com/git/git-basic-operations.html" target="_blank" rel="external">Git 教程</a><br>    <a href="http://blog.csdn.net/hudashi/article/details/7664457" target="_blank" rel="external">Git fetch和git pull的区别</a><br>    <a href="http://blog.csdn.net/ibingow/article/details/7541402" target="_blank" rel="external">git reflog</a><br>    <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解git</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git基础知识&quot;&gt;&lt;a href=&quot;#git基础知识&quot; class=&quot;headerlink&quot; title=&quot;git基础知识&quot;&gt;&lt;/a&gt;git基础知识&lt;/h1&gt;&lt;h2 id=&quot;git工作流&quot;&gt;&lt;a href=&quot;#git工作流&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="代码管理" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://fanerge.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>canvas开发参考手册</title>
    <link href="https://fanerge.github.io/canvas%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html"/>
    <id>https://fanerge.github.io/canvas开发参考手册.html</id>
    <published>2018-01-03T13:20:06.000Z</published>
    <updated>2018-01-10T12:14:40.784Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://fanerge.github.io/canvas_solar_system/" width="700" height="350" frameborder="0"></iframe></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://fanerge.github.io/canvas_solar_system/">学完canvas的相关知识可以做一些小动画了</a><br>最早由Apple引入WebKit，用于Mac OS X 的 Dashboard。<br>canvas 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，交互式游戏，甚至可以进行实时视频处理或渲染。</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>canvas 它是一个元素，当然具有元素通用的属性，如id、class等。</p><h2 id="渲染上下文（The-rendering-context）"><a href="#渲染上下文（The-rendering-context）" class="headerlink" title="渲染上下文（The rendering context）"></a>渲染上下文（The rendering context）</h2><p>canvas 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 获取渲染上下文</div><div class="line">let canvas = document.querySelector(&apos;#canvas&apos;)</div><div class="line">let ctx = canvas.getContext(&apos;2d&apos;)</div></pre></td></tr></table></figure></p><h2 id="检查支持性"><a href="#检查支持性" class="headerlink" title="检查支持性"></a>检查支持性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (canvas.getContext) &#123;</div><div class="line">// 支持</div><div class="line">&#125; else &#123;</div><div class="line">// 不支持</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h1><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p>fillRect(x, y, width, height)<br>    绘制一个填充的矩形<br>strokeRect(x, y, width, height)<br>    绘制一个矩形的边框<br>clearRect(x, y, width, height)<br>    清除指定矩形区域，让清除部分完全透明。<br>    常用于清理画布。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p><ol><li>首先，你需要创建路径起始点。</li><li>然后你使用画图命令去画出路径。</li><li>之后你把路径封闭。</li><li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。<br>beginPath()<br>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br>closePath()<br>闭合路径之后图形绘制命令又重新指向到上下文中。<br>stroke() – 轮廓<br>通过线条来绘制图形轮廓。<br>fill() – 整体<br>通过填充路径的内容区域生成实心的图形。<br>PS：fill会自动闭合儿stroke不会。<br>moveTo(x, y) – 移动笔触<br>将笔触移动到指定的坐标x以及y上。<br>当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径<br>lineTo(x, y) – 直线<br>绘制一条从当前位置到指定x以及y位置的直线。<br>arc(x, y, radius, startAngle, endAngle, anticlockwise) – 圆弧<br>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。<br>arcTo(x1, y1, x2, y2, radius)<br>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。<br>PS：角度是以x轴为基准且为弧度，转化公式：radians=(Math.PI/180)*degrees<br>quadraticCurveTo(cp1x, cp1y, x, y) – 二次贝塞尔曲线<br>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) – 三次贝塞尔曲线<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。<br>PS：贝塞尔曲线都会以开始路径作为起点，实际上二次贝塞尔曲线由3个点控制，N次贝塞尔曲线由n+1个点控制。<br><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="external">wiki-贝塞尔曲线</a><br>绘制矩形的额外方法<br>rect(x, y, width, height)<br>绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。    <h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3>为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径。<br>Path2D()<br>Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。<br>Path2D.addPath(path [, transform])​<br>添加了一条路径到当前路径（可能添加了一个变换矩阵）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 使用 SVG paths</div><div class="line">var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);</div></pre></td></tr></table></figure></li></ol><h1 id="使用样式和颜色"><a href="#使用样式和颜色" class="headerlink" title="使用样式和颜色"></a>使用样式和颜色</h1><h2 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h2><p>fillStyle = color<br>    设置图形的填充颜色。<br>strokeStyle = color<br>    设置图形轮廓的颜色。<br>PS：orange、#ffa500、rgb(255, 165, 0)、rgba(255, 165, 0, 1)、hsl(360, 50%, 50%)、hsla(360, 50%, 50%, 1)</p><h2 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h2><p>globalAlpha = transparencyValue<br>    这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。<br>ctx.strokeStyle = “rgba(255,0,0,0.5)”;<br>ctx.fillStyle = “rgba(255,0,0,0.5)”;    </p><h2 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h2><p>可以通过一系列属性来设置线的样式。<br>lineWidth = value<br>    设置线条宽度。<br>    线宽是指给定路径的中心到两边距离之和的粗细。换句话说就是在路径的两边各绘制线宽的一半。<br>lineCap = type<br>    设置线条末端样式。<br>    butt，round 和 square。<br>    默认是 butt。<br>lineJoin = type<br>    设定线条与线条间接合处的样式。<br>    round, bevel 和 miter。<br>    默认是 miter。<br>miterLimit = value<br>    限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。<br>getLineDash()<br>    返回一个包含当前虚线样式，长度为非负偶数的数组。<br>    [a, b] a表示实线，b表示空白，这样交替出现。<br>setLineDash(segments)<br>    设置当前虚线样式。<br>lineDashOffset = value<br>    设置虚线样式的起始偏移量。</p><h2 id="渐变-Gradients（新建的渐变对象）"><a href="#渐变-Gradients（新建的渐变对象）" class="headerlink" title="渐变 Gradients（新建的渐变对象）"></a>渐变 Gradients（新建的渐变对象）</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>let lineargradient = createLinearGradient(x1, y1, x2, y2)<br>    createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</p><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>let radialgradient = createRadialGradient(x1, y1, r1, x2, y2, r2)<br>    createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。<br>gradient.addColorStop(position, color)<br>    addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。</p><h2 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h2><p>createPattern(image, type)<br>    该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。<br>    你需要确认 image 对象已经装载(onload)完毕，否则图案可能效果不对的。</p><h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h2><p>shadowOffsetX = float<br>    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。<br>shadowOffsetY = float<br>    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。<br>shadowBlur = float<br>    shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。<br>shadowColor = color<br>    shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</p><h2 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h2><p>当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。<br>“nonzero”: 默认值.<br>“evenodd”</p><h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p>canvas 提供了两种方法来渲染文本:<br>fillText(text, x, y [, maxWidth])<br>    在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.<br>strokeText(text, x, y [, maxWidth])<br>    在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</p><h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>font = value<br>    当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。<br>textAlign = value<br>    文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。<br>textBaseline = value<br>    基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。<br>direction = value<br>    文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</p><h2 id="先进的文本测量"><a href="#先进的文本测量" class="headerlink" title="先进的文本测量"></a>先进的文本测量</h2><p>当你需要获得更多的文本细节时，下面的方法可以给你测量文本的方法。<br>measureText()<br>    将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。<br><code>var text = ctx.measureText(&quot;foo&quot;); // TextMetrics objecttext.width; // 16;</code>    </p><h1 id="使用图像-Using-images"><a href="#使用图像-Using-images" class="headerlink" title="使用图像 Using images"></a>使用图像 Using images</h1><p>canvas更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。<br>引入图像到canvas里需要以下两步基本操作：    </p><ol><li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片（参见例子）</li><li>使用drawImage()函数将图片绘制到画布上<h2 id="获得需要绘制的图片"><a href="#获得需要绘制的图片" class="headerlink" title="获得需要绘制的图片"></a>获得需要绘制的图片</h2>HTMLImageElement<br>这些图片是由Image()函数构造出来的，或者任何的<img>元素<br>HTMLVideoElement<br>用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像<br>HTMLCanvasElement<br>可以使用另一个 <canvas> 元素作为你的图片源。<br>ImageBitmap<br>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。<br>PS：这些源统一由 CanvasImageSource类型来引用。    </canvas></video></li><li>使用相同页面内的图片<br>document.images集合<br>document.getElementsByTagName()方法<br>document.getElementById()获得这个图片    </li><li>使用其它域名下的图片<br>在 HTMLImageElement上使用crossOrigin属性，你可以请求加载其它域名上的图片。    </li><li>由零开始创建图像（需要onload保证图片加载完毕）<br><code>var img = new Image();   // 创建一个&lt;img&gt;元素img.src = &#39;myImage.png&#39;; // 设置图片源地址</code>    </li><li>通过 data: url 方式嵌入图像<br><code>img.src = &#39;data:image/gif;base64,...&#39;</code></li><li>使用视频帧<br><code>return document.getElementById(&#39;myvideo&#39;);</code>    <h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2>drawImage(image, x, y)<br>其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。    <h2 id="缩放-Scaling"><a href="#缩放-Scaling" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2>drawImage(image, x, y, width, height)<br>这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小<h2 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片 Slicing"></a>切片 Slicing</h2>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)<br>第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。    <h2 id="控制图像的缩放行为-Controlling-image-scaling-behavior"><a href="#控制图像的缩放行为-Controlling-image-scaling-behavior" class="headerlink" title="控制图像的缩放行为 Controlling image scaling behavior"></a>控制图像的缩放行为 Controlling image scaling behavior</h2>Gecko 1.9.2 引入了 mozImageSmoothingEnabled 属性，值为 false 时，图像不会平滑地缩放。默认是 true 。<br><code>cx.mozImageSmoothingEnabled = false;</code><h1 id="变形-Transformations"><a href="#变形-Transformations" class="headerlink" title="变形 Transformations"></a>变形 Transformations</h1><h2 id="状态的保存和恢复-Saving-and-restoring-state"><a href="#状态的保存和恢复-Saving-and-restoring-state" class="headerlink" title="状态的保存和恢复 Saving and restoring state"></a>状态的保存和恢复 Saving and restoring state</h2>save()restore()<br>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。<br>PS：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。    <h2 id="绘画状态包括："><a href="#绘画状态包括：" class="headerlink" title="绘画状态包括："></a>绘画状态包括：</h2>当前应用的变形（即移动，旋转和缩放，见下）<br>strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值<br>当前的裁切路径（clipping path）<h2 id="移动-Translating"><a href="#移动-Translating" class="headerlink" title="移动 Translating"></a>移动 Translating</h2>我们先介绍 translate 方法，它用来移动 canvas 和它的原点到一个不同的位置。<br>translate(x, y)<br>translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。<br>PS：在做变形之前先保存状态是一个良好的习惯。<br>在绘制螺旋（spirograph）图案，如果不使用 translate 方法，那么只能看见其中的四分之一。<h2 id="旋转-Rotating"><a href="#旋转-Rotating" class="headerlink" title="旋转 Rotating"></a>旋转 Rotating</h2>它用于以原点为中心旋转 canvas。<br>rotate(angle)<br>这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。<br>旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。<h2 id="缩放-Scaling-1"><a href="#缩放-Scaling-1" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2>我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。<br>scale(x, y)<br>scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。<br>PS：默认情况下，canvas 的 1 单位就是 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。<h2 id="变形-Transforms"><a href="#变形-Transforms" class="headerlink" title="变形 Transforms"></a>变形 Transforms</h2>允许对变形矩阵直接修改。<br>transform(m11, m12, m21, m22, dx, dy)<br>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：<br><code>m11 m21 dxm12 m22 dy0     0     1</code><br>m11：水平方向的缩放<br>m12：水平方向的偏移<br>m21：竖直方向的偏移<br>m22：竖直方向的缩放<br>dx：水平方向的移动<br>dy：竖直方向的移动<br>setTransform(m11, m12, m21, m22, dx, dy)<br>这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。<br>从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。<br>resetTransform()<br>重置当前变形为单位矩阵，它和调用以下语句是一样的：<br>ctx.setTransform(1, 0, 0, 1, 0, 0);<h1 id="组合-Compositing"><a href="#组合-Compositing" class="headerlink" title="组合 Compositing"></a>组合 Compositing</h1>对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。此外, clip属性允许我们隐藏不想看到的部分图形.    <h2 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h2>globalCompositeOperation = type<br>这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。<br>具体type值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">source-over默认。在目标图像上显示源图像。</div><div class="line">source-atop在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。</div><div class="line">source-in在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。</div><div class="line">source-out在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。</div><div class="line">destination-over在源图像上方显示目标图像。</div><div class="line">destination-atop在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。</div><div class="line">destination-in在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。</div><div class="line">destination-out在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。</div><div class="line">lighter显示源图像 + 目标图像。</div><div class="line">copy显示源图像。忽略目标图像。</div><div class="line">xor使用异或操作对源图像与目标图像进行组合。</div></pre></td></tr></table></figure></li></ol><h2 id="裁切路径-Clipping-paths"><a href="#裁切路径-Clipping-paths" class="headerlink" title="裁切路径 Clipping paths"></a>裁切路径 Clipping paths</h2><p>裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。<br>clip()<br>    来创建一个新的裁切路径。<br>    默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p><h1 id="基本的动画"><a href="#基本的动画" class="headerlink" title="基本的动画"></a>基本的动画</h1><p>如果需要移动Canvas中的shape，我们不得不对所有东西（包括之前的）进行重绘。重绘是相当费时的，而且性能很依赖于电脑的速度。    </p><h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><p>1.清空 canvas<br>    除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。<br>2.保存 canvas 状态<br>    如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。<br>3.绘制动画图形（animated shapes）<br>    这一步才是重绘动画帧。<br>4.恢复 canvas 状态<br>    如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。    </p><h2 id="操控动画-Controlling-an-animation"><a href="#操控动画-Controlling-an-animation" class="headerlink" title="操控动画 Controlling an animation"></a>操控动画 Controlling an animation</h2><p>为了实现动画，我们需要一些可以定时执行重绘的方法。</p><h3 id="有安排的更新画布-Scheduled-updates"><a href="#有安排的更新画布-Scheduled-updates" class="headerlink" title="有安排的更新画布 Scheduled updates"></a>有安排的更新画布 Scheduled updates</h3><p>window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。<br>requestAnimationFrame(callback)<br>    方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。<br>    该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。<br>window.cancelAnimationFrame(ID)<br>    以取消回调函数。    </p><h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><h3 id="添加速率"><a href="#添加速率" class="headerlink" title="添加速率"></a>添加速率</h3><p>window.requestAnimationFrame(callback) 该方式帮助我们控制动画。<br>ctx.clearRect(0,0, canvas.width, canvas.height) 在callback前面调用清除画布。    </p><h3 id="设置边界"><a href="#设置边界" class="headerlink" title="设置边界"></a>设置边界</h3><p>物体碰到边缘，反弹回来，将速度更换方向即可。<br><code>if (ball.y + ball.vy &gt; canvas.height || ball.y + ball.vy &lt; 0 ) {    ball.vy = -ball.vy;}</code><br>PS：这里对垂直方向上分析，水平方向类似。<br>小球的y坐标+小球y的速度大于canvas的高度（下边缘）或者小球的y坐标+小球y的速度小于0（上边缘）反向</p><h3 id="添加加速度"><a href="#添加加速度" class="headerlink" title="添加加速度"></a>添加加速度</h3><p><code>ball.vy *= .99;ball.vy += .25;</code>    </p><h3 id="长尾效果"><a href="#长尾效果" class="headerlink" title="长尾效果"></a>长尾效果</h3><p>用一个半透明的 fillRect 函数取代之，就可轻松制作长尾效果。<br><code>ctx.fillStyle = &#39;rgba(255,255,255,0.3)&#39;;ctx.fillRect(0,0,canvas.width,canvas.height);</code>    </p><h3 id="添加鼠标控制"><a href="#添加鼠标控制" class="headerlink" title="添加鼠标控制"></a>添加鼠标控制</h3><p>为canvas元素添加 mousemove、 mouseout、click等事件，在通过 canvas 的 shape 来进行精确控制</p><h2 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h2><p>可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。    </p><h3 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h3><p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：<br>width<br>    图片宽度，单位是像素<br>height<br>    图片高度，单位是像素<br>data<br>    Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。<br>    每一个像素又数组4为组成，分别对应r、g、b、a</p><h3 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h3><p>去创建一个新的，空白的ImageData对象，你应该会使用createImageData() 方法。有2个版本的createImageData()方法。<br>var myImageData = ctx.createImageData(width, height);<br>    上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。<br>var myImageData = ctx.createImageData(anotherImageData);<br>    你也可以创建一个被anotherImageData对象指定的相同像素的ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。</p><h3 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h3><p>为了获得一个包含画布场景像素数据的ImageData对像，你可以用getImageData()方法：<br>var myImageData = ctx.getImageData(left, top, width, height);<br>    这个方法会返回一个ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为(left, top), (left + width, top), (left, top + height), 以及(left + width, top + height)四个点。这些坐标点被设定为画布坐标空间元素。</p><h3 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h3><p>你可以用putImageData()方法去对场景进行像素数据的写入。<br>ctx.putImageData(myImageData, dx, dy);<br>    dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标。</p><h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p>在drawImage() 方法， 第二个画布和imageSmoothingEnabled 属性的帮助下，我们可以放大显示我们的图片及看到详情内容。<br>因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。<br>禁用反锯齿<br><code>ctx.imageSmoothingEnabled = false;ctx.mozImageSmoothingEnabled = true;ctx.webkitImageSmoothingEnabled = true;ctx.msImageSmoothingEnabled = true;</code>        </p><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>HTMLCanvasElement  提供一个toDataURL()方法，此方法在保存图片的时候非常有用。<br>它返回一个包含被类型参数规定的图像表现格式的数据链接。返回的图片分辨率是96dpi。<br>canvas.toDataURL(‘image/png’)<br>    默认设定。创建一个PNG图片。<br>canvas.toDataURL(‘image/jpeg’, quality)<br>    创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。<br>canvas.toBlob(callback, type, encoderOptions)<br>    这个创建了一个在画布中的代表图片的Blob对像。<br>PS：这里是canvas对象上的方法，而不是画布上下文对象的方法。    </p><h2 id="点击区域和无障碍访问"><a href="#点击区域和无障碍访问" class="headerlink" title="点击区域和无障碍访问"></a>点击区域和无障碍访问</h2><p>canvas 标签只是一个位图，它并不提供任何已经绘制在上面的对象的信息。    </p><h3 id="内容兼容"><a href="#内容兼容" class="headerlink" title="内容兼容"></a>内容兼容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas&gt; ... &lt;/canvas&gt;标签里的内容被可以对一些不支持canvas的浏览器提供兼容。</div></pre></td></tr></table></figure><h3 id="ARIA-规则"><a href="#ARIA-规则" class="headerlink" title="ARIA 规则"></a>ARIA 规则</h3><p>Accessible Rich Internet Applications (ARIA) 定义了让Web内容和Web应用更容易被有身体缺陷的人获取的办法。你可以用ARIA属性来描述canvas元素的行为和存在目的    </p><h3 id="点击区域（hit-region）"><a href="#点击区域（hit-region）" class="headerlink" title="点击区域（hit region）"></a>点击区域（hit region）</h3><p>判断鼠标坐标是否在canvas上一个特定区域里一直是个有待解决的问题。hit region API让你可以在canvas上定义一个区域，这让无障碍工具获取canvas上的交互内容成为可能。它能让你更容易地进行点击点击检测并把事件转发到DOM元素去。这个API有以下三个方法（都是实验性特性，请先在浏览器兼容表上确认再使用）。<br>CanvasRenderingContext2D.addHitRegion()<br>    在canvas上添加一个点击区域。<br>    ctx.addHitRegion({control: element});<br>    addHitRegion()方法也可以带一个control选项来指定把事件转发到哪个元素上（canvas里的元素）。<br>ctx.removeHitRegion()<br>    从canvas上移除指定id的点击区域。<br>ctx.clearHitRegions()<br>    移除canvas上的所有点击区域。<br>PS：实验性方法，浏览器暂不支持    </p><h2 id="焦点圈"><a href="#焦点圈" class="headerlink" title="焦点圈"></a>焦点圈</h2><p>当用键盘控制时，焦点圈是一个能帮我们在页面上快速导航的标记。要在canvas上绘制焦点圈，可以使用drawFocusIfNeeded 属性。<br>ctx.drawFocusIfNeeded()<br>    如果给定的元素获得了焦点，这个方法会沿着在当前的路径画个焦点圈。<br>ctx.scrollPathIntoView()<br>    把当前的路径或者一个给定的路径滚动到显示区域内。<br>    scrollPathIntoView()方法可以让一个元素获得焦点的时候在屏幕上可见(滚动到元素所在的区域)。    </p><h2 id="canvas的优化"><a href="#canvas的优化" class="headerlink" title="canvas的优化"></a>canvas的优化</h2><h3 id="性能贴士"><a href="#性能贴士" class="headerlink" title="性能贴士"></a>性能贴士</h3><p>下面是一些改善性能的建议    </p><ol><li><p>在离屏canvas上预渲染相似的图形或重复的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myEntity.offscreenCanvas = document.createElement(&quot;canvas&quot;);</div><div class="line">myEntity.offscreenCanvas.width = myEntity.width;</div><div class="line">myEntity.offscreenCanvas.height = myEntity.height;</div><div class="line">myEntity.offscreenContext = myEntity.offscreenCanvas.getContext(&quot;2d&quot;);</div><div class="line">myEntity.render(myEntity.offscreenContext);</div></pre></td></tr></table></figure></li><li><p>避免浮点数的坐标点，用整数取而代之    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">当你画一个没有整数坐标点的对象时会发生子像素渲染。</div><div class="line">ctx.drawImage(myImage, 0.3, 0.5);</div><div class="line">浏览器为了达到抗锯齿的效果会做额外的运算。为了避免这种情况，请保证在你调用drawImage()函数时，用Math.floor()函数对所有的坐标点取整。</div></pre></td></tr></table></figure></li><li><p>不要在用drawImage时缩放图像（多个 canvas 元素）<br>在离屏canvas中缓存图片的不同尺寸，而不要用drawImage()去缩放它们。        </p></li><li>使用多层画布去画一个复杂的场景<br>你可能会发现，你有些元素不断地改变或者移动，而其它的元素，例如外观，永远不变。这种情况的一种优化是去用多个画布元素去创建不同层次。    <h3 id="用CSS设置大的背景图"><a href="#用CSS设置大的背景图" class="headerlink" title="用CSS设置大的背景图"></a>用CSS设置大的背景图</h3>如果像大多数游戏那样，你有一张静态的背景图，用一个静态的<div>元素，结合background 特性，以及将它置于画布元素之后。这么做可以避免在每一帧在画布上绘制大图。    </div></li><li>用CSS transforms特性缩放画布<br>CSS transforms 特性由于调用GPU，因此更快捷。最好的情况是，不要将小画布放大，而是去将大画布缩小。    </li><li>使用moz-opaque属性(仅限Gecko)<br>如果你的游戏使用画布而且不需要透明，请在画布上设置moz-opaque属性。这能够用于内部渲染优化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;mycanvas&quot; moz-opaque&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure></li></ol><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）<br>避免不必要的画布状态改变<br>渲染画布中的不同点，而非整个新状态<br>尽可能避免 shadowBlur特性<br>尽可能避免text rendering<br>使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)<br>有动画，请使用window.requestAnimationFrame() 而非window.setInterval()<br>请谨慎使用大型物理库<br>用JSPerf测试性能<br><a href="https://fanerge.github.io/canvas_solar_system/">demo地址</a><br><a href="https://antv.alipay.com/zh-cn/index.html" target="_blank" rel="external">这里向大家推荐一下阿里开源的数据可视化库antV（g2、g6、f2）</a></p><blockquote><p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">MDN-canvas教程</a><br>    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449990549914b596ac1da54a228a6fa9643e88bc0c000" target="_blank" rel="external">廖雪峰老师的Canvas</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="external">MDN-canvas标签</a><br>    <a href="https://segmentfault.com/a/1190000004469449" target="_blank" rel="external">Canvas 的基本原理</a><br>    <a href="http://www.webhek.com/post/html5-canvas-cheat-sheet.html" target="_blank" rel="external">HTML5画布(CANVAS)速查简表</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://fanerge.github.io/canvas_solar_system/&quot; width=&quot;700&quot; height=&quot;350&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>移动端总结</title>
    <link href="https://fanerge.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/移动端总结.html</id>
    <published>2017-12-27T12:09:35.000Z</published>
    <updated>2017-12-27T14:34:24.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;</code><br>    width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。<br>    height：和 width 相对应，指定高度。<br>    initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。<br>    maximum-scale：允许用户缩放到的最大比例。<br>    minimum-scale：允许用户缩放到的最小比例。<br>    user-scalable：用户是否可以手动缩放。</p><h3 id="IOS中safari允许全屏浏览"><a href="#IOS中safari允许全屏浏览" class="headerlink" title="IOS中safari允许全屏浏览"></a>IOS中safari允许全屏浏览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div><div class="line">&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;</div><div class="line">```</div><div class="line">###IOS中Safari顶端状态条样式</div><div class="line">`&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;`</div><div class="line">PS：如果要去除全部的，就把default ：状态栏背景是白色。</div><div class="line">black ：状态栏背景是黑色。</div><div class="line">black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。</div><div class="line">如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。</div><div class="line">###忽略将数字变为电话号码</div><div class="line">`&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;`</div><div class="line">###忽略识别email</div><div class="line">`&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; &gt;`</div><div class="line">###添加到主屏后的标题（IOS）</div><div class="line">`&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;`</div><div class="line">###百度禁止转码</div><div class="line">`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;`</div><div class="line">###优先使用最新版本 IE 和 Chrome</div><div class="line">`&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;`</div><div class="line">###设置缓存</div><div class="line">`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;`</div><div class="line">##小技巧</div><div class="line">###select 下拉选择设置右对齐</div></pre></td></tr></table></figure><p>select option {<br>    direction: rtl;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###消除 IE10 里面的那个叉号</div><div class="line">`input:-ms-clear&#123;display:none;&#125;`</div><div class="line">###关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)</div></pre></td></tr></table></figure></p><p>-webkit-text-size-adjust: 100%;<br>-ms-text-size-adjust: 100%;<br>text-size-adjust: 100%;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">###关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</div><div class="line">可以通过正则去掉</div><div class="line">`this.value = this.value.replace(/\u2006/g, &apos;&apos;);`</div><div class="line">###移动端 HTML5 input date 不支持 placeholder 问题</div><div class="line">`&lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot;  id=&quot;date&quot;&gt;`</div><div class="line">###部分机型存在type为search的input，自带close按钮样式修改方法</div></pre></td></tr></table></figure></p><p>#Search::-webkit-search-cancel-button{<br>    display: none;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###开启电话功能和短信和发邮件</div></pre></td></tr></table></figure></p><p><a href="tel:123456" target="_blank" rel="external">123456</a><br><a href="sms:123456" target="_blank" rel="external">123456</a><br>&lt;a mailto:dooyoe@gmail.com”&gt;dooyoe@gmail.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">###IOS Web app启动动画</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-640x960.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">&lt;link href=&quot;apple-touch-startup-image-2048x1496.png&quot; media=&quot;(device-width: 1536px)  and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</div><div class="line">（landscape：横屏 | portrait：竖屏）</div><div class="line">###添加到主屏后的APP图标</div></pre></td></tr></table></figure></p><!-- 设计原图 --> <p><link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed"><br><!-- 添加高光效果 --> </p><p><link href="short_cut_114x114.png" rel="apple-touch-icon"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###去除webkit的滚动条</div></pre></td></tr></table></figure></p><p>element::-webkit-scrollbar{<br>    display: none;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PS：如果要去除全部的，就把 element去掉。</div><div class="line">添加这个属性滚动如丝般顺滑： -webkit-overflow-scrolling : touch;</div><div class="line">###去除button在ios上的默认样式</div><div class="line">```</div><div class="line">-webkit-appearance: none;</div><div class="line">border-radius: 0;</div></pre></td></tr></table></figure></p><h3 id="长时间按住页面出现闪退"><a href="#长时间按住页面出现闪退" class="headerlink" title="长时间按住页面出现闪退"></a>长时间按住页面出现闪退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element &#123;</div><div class="line">-webkit-touch-callout: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Retina屏的1px边框"><a href="#Retina屏的1px边框" class="headerlink" title="Retina屏的1px边框"></a>Retina屏的1px边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element&#123;</div><div class="line">border-width: thin;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="transition闪屏"><a href="#transition闪屏" class="headerlink" title="transition闪屏"></a>transition闪屏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/设置内嵌的元素在 3D 空间如何呈现：保留3D /</div><div class="line">-webkit-transform-style: preserve-3d;</div><div class="line">/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /</div><div class="line">-webkit-backface-visibility:hidden;</div></pre></td></tr></table></figure><h3 id="旋转屏幕时，字体大小调整的问题"><a href="#旋转屏幕时，字体大小调整的问题" class="headerlink" title="旋转屏幕时，字体大小调整的问题"></a>旋转屏幕时，字体大小调整的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123;</div><div class="line">-webkit-text-size-adjust:100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="placeholder元素样式的修改"><a href="#placeholder元素样式的修改" class="headerlink" title="placeholder元素样式的修改"></a>placeholder元素样式的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">input::-webkit-input-placeholder&#123;color:red;&#125;</div><div class="line">input:focus::-webkit-input-placeholder&#123;color:green;&#125;</div></pre></td></tr></table></figure><h3 id="不想让按钮-touch时有蓝色的边框或半透明灰色遮罩"><a href="#不想让按钮-touch时有蓝色的边框或半透明灰色遮罩" class="headerlink" title="不想让按钮 touch时有蓝色的边框或半透明灰色遮罩"></a>不想让按钮 touch时有蓝色的边框或半透明灰色遮罩</h3><p>对于a,button,input,textarea<br><code>-webkit-tap-highlight-color:rgba(0,0,0,0);</code></p><h3 id="移动端做动画效果采用css3"><a href="#移动端做动画效果采用css3" class="headerlink" title="移动端做动画效果采用css3"></a>移动端做动画效果采用css3</h3><p>transition、transform（scale、translate、rotate、skew）或者 animation<br>动画尽量少用margin、top等集合属性，因为这样会触发浏览器重排（reflow）</p><h3 id="使用图片时去除图片下4px的空白"><a href="#使用图片时去除图片下4px的空白" class="headerlink" title="使用图片时去除图片下4px的空白"></a>使用图片时去除图片下4px的空白</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img&#123;display:block&#125;；</div><div class="line">img&#123;vertical-align:top&#125;</div></pre></td></tr></table></figure><h3 id="如何禁止保存或拷贝图像（IOS）"><a href="#如何禁止保存或拷贝图像（IOS）" class="headerlink" title="如何禁止保存或拷贝图像（IOS）"></a>如何禁止保存或拷贝图像（IOS）</h3><p><code>img { -webkit-touch-callout: none; }</code></p><h3 id="手机拍照和上传图片"><a href="#手机拍照和上传图片" class="headerlink" title="手机拍照和上传图片"></a>手机拍照和上传图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 选择照片 --&gt; </div><div class="line">&lt;input type=file accept=&quot;image/*&quot;&gt; </div><div class="line">&lt;!-- 选择视频 --&gt; </div><div class="line">&lt;input type=file accept=&quot;video/*&quot;&gt;</div></pre></td></tr></table></figure><h3 id="弹性盒子的过渡"><a href="#弹性盒子的过渡" class="headerlink" title="弹性盒子的过渡"></a>弹性盒子的过渡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display:-webkit-box; // 早期的版本</div><div class="line">display:-webkit-box-flex; // 过渡版本</div><div class="line">display:-webkit-flex; // 最新的版本</div></pre></td></tr></table></figure><h3 id="禁止用户选中文字"><a href="#禁止用户选中文字" class="headerlink" title="禁止用户选中文字"></a>禁止用户选中文字</h3><p><code>-webkit-user-select:none;</code></p><h3 id="定义新的盒模型"><a href="#定义新的盒模型" class="headerlink" title="定义新的盒模型"></a>定义新的盒模型</h3><p><code>box-sizing:border-box</code></p><h3 id="css权重（逐次降低）"><a href="#css权重（逐次降低）" class="headerlink" title="css权重（逐次降低）"></a>css权重（逐次降低）</h3><pre><code>style--1000!importantid--100class--10标签--1</code></pre><h3 id="使用rem"><a href="#使用rem" class="headerlink" title="使用rem"></a>使用rem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">font-size: 625%; // 相当于 12px *6.25 = 100px</div><div class="line">&#125;</div><div class="line">以后的元素的width、height、padding等集合属性都可以用rem来表示。</div><div class="line">```</div><div class="line">###移动端字体</div><div class="line">`font-family: Helvetica,sans-serif;`</div><div class="line">###iphone原生键盘统计字数时</div><div class="line">在 iphone原生键盘上用 keyup统计字符数时，系统不会自动监控你选择文字的事件，应该使用input事件。</div><div class="line">###毛玻璃效果</div><div class="line">实现毛玻璃效果，透过背景看其他元素模糊，自身元素不模糊。</div></pre></td></tr></table></figure><p>-webkit-backdrop-filter: saturate(180%) blur(20px);<br>background: rgba(0,0,0,0.5);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###需要展示小于12px的文字</div><div class="line">`transform:scale(%);`</div><div class="line">###禁止IOS弹出各种操作窗口及关闭自动大写与自动修正</div></pre></td></tr></table></figure></p><p>-webkit-touch-callout:none</p><p><input type="text" autocapitalize="off" autocorrect="off"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">###Andriod 上去掉语音输入按钮</div><div class="line">`input::-webkit-input-speech-button &#123;display: none&#125;`</div><div class="line">#js部分</div><div class="line">##移动端事件</div><div class="line">click事件有300ms的延迟</div><div class="line">###触摸事件touch类事件</div><div class="line">touchstart：手指触摸到屏幕会触发</div><div class="line">touchmove：当手指在屏幕上移动时，会触发</div><div class="line">touchend：当手指离开屏幕时，会触发</div><div class="line">touchcancel：可由系统进行的触发，比如手指触摸屏幕的时候，突然alert了一下，或者系统中其他打断了touch的行为，则可以触发该事件</div><div class="line">###敲击事件tap类事件</div><div class="line">tap: 手指碰一下屏幕会触发</div><div class="line">longTap: 手指长按屏幕会触发</div><div class="line">singleTap: 手指碰一下屏幕会触发</div><div class="line">doubleTap: 手指双击屏幕会触发</div><div class="line">###swipe类事件</div><div class="line">swipe：手指在屏幕上滑动时会触发</div><div class="line">swipeLeft：手指在屏幕上向左滑动时会触发</div><div class="line">swipeRight：手指在屏幕上向右滑动时会触发</div><div class="line">swipeUp：手指在屏幕上向上滑动时会触发</div><div class="line">swipeDown：手指在屏幕上向下滑动时会触发</div><div class="line">###旋转屏幕事件</div><div class="line">`onorientationchange`</div><div class="line">###audio、video默认播放事件</div><div class="line">window.onload或计时器等都不能触发播放，必须用 JS写事件让用户手动点击触发才会开始播放</div></pre></td></tr></table></figure></p><p>$(document).one(‘touchstart’,function(){<br>    audio.play();<br>})<br>```</p><h3 id="移动事件三方库"><a href="#移动事件三方库" class="headerlink" title="移动事件三方库"></a>移动事件三方库</h3><p><a href="http://hammerjs.github.io" target="_blank" rel="external">Hammer.JS</a><br><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="external">FastClick</a></p><p>参考文档：<br>    <a href="https://www.cnblogs.com/imwtr/p/5882166.html" target="_blank" rel="external">移动端前端常见的触摸相关事件touch、tap、swipe等整理</a><br>    <a href="http://mp.weixin.qq.com/s/KpRaX4gPnqvadIZijSmYSQ" target="_blank" rel="external">web前端 —— 移动端知识的一些总结</a><br>    <a href="http://web.jobbole.com/85132/" target="_blank" rel="external">移动端事件介绍</a><br>    <a href="http://www.imooc.com/article/1115" target="_blank" rel="external">移动端web开发技巧</a><br>    <a href="https://masonry.desandro.com/" target="_blank" rel="external">瀑布流框架</a><br>    <a href="http://www.jb51.net/article/84973.htm" target="_blank" rel="external">倾力总结40条常见的移动端Web页面问题解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;css部分&quot;&gt;&lt;a href=&quot;#css部分&quot; class=&quot;headerlink&quot; title=&quot;css部分&quot;&gt;&lt;/a&gt;css部分&lt;/h1&gt;&lt;h2 id=&quot;meta标签&quot;&gt;&lt;a href=&quot;#meta标签&quot; class=&quot;headerlink&quot; title=&quot;m
      
    
    </summary>
    
      <category term="移动端" scheme="https://fanerge.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="https://fanerge.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识学习</title>
    <link href="https://fanerge.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://fanerge.github.io/java基础知识学习.html</id>
    <published>2017-12-26T12:25:18.000Z</published>
    <updated>2017-12-26T13:44:31.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用指令介绍"><a href="#常用指令介绍" class="headerlink" title="常用指令介绍"></a>常用指令介绍</h1><p>javac HelloWorld.java – 该命令用于将 java 源文件编译为 class 字节码文件，如： javac HelloWorld.java。如果成功编译没有错误的话，会出现一个 HelloWorld.class 的文件。<br>java HelloWorld – java 后面跟着的是java文件中的类名,例如 HelloWorld 就是类名，如: java HelloWorld。</p><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>JAVA_HOME：JDK安装在C:\jdk1.6.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串<br>path 变量：path 变量使得我们能够在系统中的任何地方运行java应用程序，比如 javac、java、javah 等等,这就要找到我们安装 JDK 的目录，假设我们的JDK安装在 C:\jdk1.6.0 目录下,那么在 C:\jdk1.6.0\bin 目录下就是我们常用的 java 应用程序,我们就需要把 C:\jdk1.6.0\bin 这个目录加到 path 环境变量里面。<br>classpath 变量：classpath 环境变量，是当我们在开发java程序时需要引用别人写好的类时，要让 java 解释器知道到哪里去找这个类。通常，sun 为我们提供了一些额外的丰富的类包，一个是 dt.jar，一个是 tools.jar，这两个 jar 包都位于 C:\jdk1.6.0\lib 目录下，所以通常我们都会把这两个 jar 包加到我们的 classpath 环境变量中 set classpath=.;C:\jdk1.6.0\lib\tools.jar;C:\jdk1.6.0\lib\dt.jar。    </p><h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><p>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>类：类是一个模板，它描述一类对象的行为和状态。<br>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。<br>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。<br>类名：对于所有的类来说，都使用大驼峰。<br>方法名：所有的方法名都应该使用小驼峰。<br>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。<br>主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。</p><h2 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h2><p>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。<br>跟其他语言类似。</p><h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><p>Java可以使用修饰符来修饰类中方法和属性。<br>访问控制修饰符 : default, public , protected, private<br>非访问控制修饰符 : final, abstract, strictfp</p><h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><p>局部变量<br>类变量（静态变量）<br>成员变量（非静态变量）</p><h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>数组是储存在堆上的对象，可以保存多个同类型变量。<br>这里有别于js的数组，同类型限制。</p><h2 id="Java枚举"><a href="#Java枚举" class="headerlink" title="Java枚举"></a>Java枚举</h2><p>枚举限制变量只能是预先设定好的值。<br>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>这些保留字不能用于常量、变量、和任何标识符的名称。<br>跟其他语言类似。</p><h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><p>单行 //<br>多行 /**/</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。<br>被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Java中，接口可理解为对象间相互通信的协议。<br>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h1 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h1><p>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br>类：类是一个模板，它描述一类对象的行为和状态。</p><h2 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Dog&#123;</div><div class="line">  String breed; // 成员变量</div><div class="line">  int age;</div><div class="line">  String color;</div><div class="line">  </div><div class="line">  // 构造方法</div><div class="line">  public Dog(String name)&#123;</div><div class="line">       // 这个构造器仅有一个参数：name</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // 入口函数</div><div class="line">  public static void main(String []args)&#123;</div><div class="line">// 下面的语句将创建一个Dog对象</div><div class="line">Dog myDog = new Dog( &quot;tommy&quot; );</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  Static demo; // 类变量</div><div class="line">  void barking()&#123;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  void hungry()&#123;</div><div class="line">String dd; // 局部变量</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  void sleeping()&#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。<br>成员变量：成员变量是定义在类中，方法体之外的变量。<br>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的名称必须与类同名，一个类可以有多个构造方法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Dog(String name)&#123;</div><div class="line">     // 这个构造器仅有一个参数：name</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">muDog = new Dog();</div><div class="line">/* 访问类中的变量 */</div><div class="line">muDog.breed;</div><div class="line">/* 访问类中的方法 */</div><div class="line">muDog.hungry();</div></pre></td></tr></table></figure></code></pre><h2 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h2><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。<br>    一个源文件中只能有一个public类<br>    一个源文件可以有多个非public类<br>    源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。<br>    如果一个类定义在某个包中，那么package语句应该在源文件的首行。<br>    如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。<br>    import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p><h2 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h2><p>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><h2 id="Import语句"><a href="#Import语句" class="headerlink" title="Import语句"></a>Import语句</h2><p>Import语句用来提供一个合理的路径，使得编译器可以找到某个类。<br>例如，下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类 import java.io.*;</p><h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。<br>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。<br>Java 的两大数据类型:<br>    内置数据类型<br>    引用数据类型</p><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>    范围：-128（-2^7） 到 127（2^7-1）；<br>    byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>    例子：byte a = 100，byte b = -50。</p><h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>    范围：-32768（-2^15） 到 32767（2^15 - 1）；<br>    Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>    例子：short s = 1000，short r = -20000。</p><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>    范围：-2,147,483,648（-2^31） 到 2,147,483,647（2^31 - 1）；<br>    一般地整型变量默认为 int 类型；<br>    例子：int a = 100000, int b = -200000。</p><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>    范围：-9,223,372,036,854,775,808（-2^63） 到 9,223,372,036,854,775,807（2^63 -1）；<br>    这种类型主要使用在需要比较大整数的系统上；<br>    例子： long a = 100000L，Long b = -200000L。</p><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>    float 在储存大型浮点数组的时候可节省内存空间；<br>    浮点数不能用来表示精确的值，如货币；<br>    例子：float f1 = 234.5f。</p><h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>    浮点数的默认类型为double类型；<br>    double类型同样不能表示精确的值，如货币；<br>    例子：double d1 = 123.4d 或者 123.4。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>boolean数据类型表示一位的信息；<br>    只有两个取值：true 和 false；<br>    默认值是 false；<br>    例子：boolean one = true。</p><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>char类型是一个单一的 16 位 Unicode 字符；<br>    范围：\u0000（即为0） 到 \uffff（即为65,535）；<br>    char 数据类型可以储存任何字符；<br>    例子：char letter = ‘A’;。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><pre><code>对象、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。例子：Site site = new Site(&quot;Runoob&quot;)。</code></pre><h2 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h2><p>常量在程序运行时是不能被修改的。<br>    在 Java 中使用 final 关键字来修饰常量。<br>    final double PI = 3.1415927;</p><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>转换从低级到高级。<br>低  ————————————&gt;  高<br>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double     </p><h2 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。<br>强制类型转换</p><pre><code>1. 条件是转换的数据类型必须是兼容的。2. 格式：(type)value type是要强制类型转换后的数据类型。        </code></pre><p>隐含强制类型转换    </p><pre><code>1. 整数的默认类型是 int。2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。</code></pre><h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的变量在使用前必须声明。<br>    声明格式：type identifier [ = value][, identifier [= value] …] ;<br>Java语言支持的变量类型有：<br>    类变量：独立于方法之外的变量，用 static 修饰。<br>    实例变量：独立于方法之外的变量，不过没有 static 修饰。<br>    局部变量：类的方法中的变量。</p><h2 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h2><pre><code>局部变量声明在方法、构造方法或者语句块中；局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；访问修饰符不能用于局部变量；局部变量只在声明它的方法、构造方法或者语句块中可见；局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</code></pre><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p>实例变量声明在一个类中，但在方法、构造方法和语句块之外；<br>当一个对象被实例化之后，每个实例变量的值就跟着确定；<br>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；<br>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；<br>实例变量可以声明在使用前或者使用后；<br>访问修饰符可以修饰实例变量；<br>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；<br>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；<br>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这个实例变量对子类可见</div><div class="line">public String name;</div><div class="line">// 私有变量，仅在该类可见</div><div class="line">private double salary;</div></pre></td></tr></table></figure></p><h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。<br>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。<br>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。<br>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。<br>静态变量在程序开始时创建，在程序结束时销毁。<br>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。<br>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。<br>静态变量可以通过：ClassName.VariableName的方式访问。<br>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</p><h1 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h1><p>Java语言提供了很多修饰符，主要分为以下两类：<br>    访问修饰符<br>    非访问修饰符</p><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Javav支持 4 种不同的访问权限。<br>    权限有4中：当前类、同一包内、子孙类、其他包<br>    public : 对所有类可见。使用对象：类、接口、变量、方法。<br>    protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>    default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>    private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>访问控制和继承<br>    父类中声明为 public 的方法在子类中也必须为 public。<br>    父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。<br>    父类中声明为 private 的方法，不能够被继承。</p><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>static 修饰符，用来修饰类方法和类变量。<br>final final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>    类中的 final 方法可以被子类继承，但是不能被子类修改。<br>abstract 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>    抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>synchronized 关键字声明的方法同一时间只能被一个线程访问。<br>transient 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>volatile volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><pre><code>算术运算符关系运算符位运算符逻辑运算符赋值运算符其他运算符instanceof 运算符    该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。    ( Object reference variable ) instanceof  (class/interface type)类别    操作符    关联性后缀    () [] . (点操作符)    左到右一元    ++ -- ！~    从右到左乘性     * /％    左到右加性     + -    左到右移位     &gt;&gt; &gt;&gt;&gt;  &lt;&lt;     左到右关系     &gt;&gt; = &lt;&lt; =     左到右相等     ==  !=    左到右按位与    ＆    左到右按位异或    ^    左到右按位或    |    左到右逻辑与    &amp;&amp;    左到右逻辑或    | |    左到右条件    ？：    从右到左赋值    = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =    从右到左逗号    ，    左到右</code></pre><p>注：只有一元、条件（三目）、赋值运算符关联性为从右向左，其余全是从左向右    </p><h1 id="Java-循环结构"><a href="#Java-循环结构" class="headerlink" title="Java 循环结构"></a>Java 循环结构</h1><pre><code>while 循环do…while 循环    对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。    do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。for 循环Java 增强 for 循环（对于数组）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(声明语句 : 表达式)</div><div class="line">&#123;</div><div class="line">   //代码句子</div><div class="line">&#125;</div></pre></td></tr></table></figure>break 关键字    break 主要用在循环语句或者 switch 语句中。    break 在循环语句中作用是跳出本层（并非本次）的循环。    break 在switch语句中作用是跳出该switch语句体。continue 关键字    continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。    在 for 循环中，continue 语句使程序立即跳转到更新语句i++。    在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。return 关键字    返回数据给函数的调用者。    函数一旦执行到了return关键字，那么该函数马上结束。 (能结束一个函数)</code></pre><h1 id="Java-分支结构"><a href="#Java-分支结构" class="headerlink" title="Java 分支结构"></a>Java 分支结构</h1><pre><code>if 语句switch 语句</code></pre><h1 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h1><p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。<br>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。    </p><h2 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。<br>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。<br>    <a href="http://www.runoob.com/java/java-number.html" target="_blank" rel="external">Number &amp; Math 类方法</a></p><h1 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h1><p>Character 类用于对单个字符进行操作。<br>Character 类在对象中包装一个基本类型 char 的值    </p><h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。<br>    <a href="http://www.runoob.com/java/java-character.html" target="_blank" rel="external">Character 类方法</a></p><h1 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h1><p>字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。<br>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。<br>如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</p><h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><pre><code>String greeting = &quot;fanerge&quot;;</code></pre><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><pre><code>int len = greeting.length();</code></pre><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p>string1.concat(string2);<br>    <a href="http://www.runoob.com/java/java-string.html" target="_blank" rel="external">String 类方法</a></p><h1 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h1><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。<br>    <a href="http://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="external">StringBuffer 和 StringBuilder 类方法</a></p><h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>格式：dataType[] arrayRefVar;   // 首选的方法<br>    dataType arrayRefVar[];  // 效果相同，但不是首选方法<br>实例：double[] myList; // 声明一个为double类型的数组    </p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：<br>    dataType[] arrayRefVar = new dataType[arraySize];</p><h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>循环处理 for<br>foreach 循环<br>    <a href="http://www.runoob.com/java/java-array.html" target="_blank" rel="external">Array类方法</a>    </p><h1 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h1><p>Date 类<br>    <a href="http://www.runoob.com/java/java-date-time.html" target="_blank" rel="external">Date类方法</a><br>    Calendar类<br>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。<br>    GregorianCalendar类<br>    Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><h1 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h1><p>java正则在java.util.regex包中<br>Pattern 类：<br>    pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。<br>Matcher 类：<br>    Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。<br>PatternSyntaxException：<br>    PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。    </p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><pre><code>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。    </code></pre><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="external">正则方法</a></p><h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><pre><code>修饰符 返回值类型 方法名(参数类型 参数名){    ...    方法体    ...    return 返回值;}</code></pre><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><pre><code>注：main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。    </code></pre><p>void 关键字<br>方法的重载<br>    创建另一个有相同名字但参数不同的方法 – 方法的重载<br>    就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。<br>变量作用域<br>    变量的范围是程序中该变量可以被引用的部分。<br>    方法的参数范围涵盖整个方法。参数实际上是一个局部变量。<br>    for循环的初始化部分声明的变量，其作用范围在整个循环。<br>    但循环体内声明的变量其适用范围是从它声明到循环体结束。<br>命令行参数的使用<br>构造方法<br>    构造方法和它所在类的名字相同，但构造方法没有返回值。（可不写）<br>可变参数<br>    语法：typeName… parameterName<br>finalize() 方法<br>    Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p><h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。<br>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><pre><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));int read( ) throws IOException</code></pre><h2 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h2><pre><code>String readLine( ) throws IOException</code></pre><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。<br>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>FileInputStream<br>    该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>FileOutputStream<br>    该类用来创建一个文件并向文件中写数据。    </p><h2 id="文件和I-O"><a href="#文件和I-O" class="headerlink" title="文件和I/O"></a>文件和I/O</h2><pre><code>File Class(类)FileReader Class(类)FileWriter Class(类)</code></pre><h2 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h2><p>创建目录：<br>    mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。<br>    mkdirs()方法创建一个文件夹和它的所有父文件夹。<br>读取目录：<br>    一个目录其实就是一个 File 对象，它包含其他文件和文件夹。<br>删除目录或文件<br>    删除文件可以使用 java.io.File.delete() 方法。</p><h1 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h1><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。<br>    通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据<br>next() 与 nextLine() 区别<br>next():<br>    1、一定要读取到有效字符后才可以结束输入。<br>    2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>    3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。<br>nextLine()：<br>    1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>    2、可以获得空白。</p><h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>异常发生的原因有很多，通常包含以下几大类：<br>    用户输入了非法数据。<br>    要打开的文件不存在。<br>    网络通信时连接中断，或者JVM内存溢出。<br>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：<br>    检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。<br>    运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。<br>    错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p><h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><pre><code>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</code></pre><h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h2 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h2><h2 id="throws-throw-关键字"><a href="#throws-throw-关键字" class="headerlink" title="throws/throw 关键字"></a>throws/throw 关键字</h2><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><h2 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class 父类 &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class 子类 extends 父类 &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><p>子类拥有父类非private的属性，方法。<br>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。<br>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。<br>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</p><h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object</p><h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p><h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class C implements A,B &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><pre><code>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。this关键字：指向自己的引用。</code></pre><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><pre><code>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：声明类：    final class 类名 {//类体}声明方法：    修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。</p><h1 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h1><h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h2><pre><code>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</code></pre><h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><p>参数列表必须完全与被重写方法的相同；<br>返回类型必须完全与被重写方法的返回类型相同；<br>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。<br>父类的成员方法只能被它的子类重写。<br>声明为final的方法不能被重写。<br>声明为static的方法不能被重写，但是能够被再次声明。<br>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。<br>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。<br>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。<br>构造方法不能被重写。<br>如果不能继承一个方法，则不能重写这个方法。</p><h3 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h3><pre><code>当需要在子类中调用父类的被重写方法时，要使用super关键字。</code></pre><h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><h1 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h1><p>多态是同一个行为具有多个不同表现形式或形态的能力。    </p><h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><pre><code>继承重写父类引用指向子类对象    Parent p = new Child();</code></pre><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><pre><code>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字super。</code></pre><h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><p>方式一：重写：<br>    这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。<br>方式二：接口</p><ol><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li><p>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。<br>方式三：抽象类和抽象方法<br> 详情请看 Java抽象类 章节。</p><h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p> 在Java语言中使用abstract class来定义抽象类。</p><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p> 尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从 Employee 类继承7个成员方法，且通过该方法可以设置或获取三个成员变量。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p> 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。<br> Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br> 声明抽象方法会造成以下两个结果：</p><pre><code>如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</code></pre><h1 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a>Java 封装</h1><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。<br>要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。<br>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h2 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h2><p>.     修改属性的可见性来限制对属性的访问（一般限制为private）<br>.     对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问getter和setter方法<br>.    采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p><h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>[可见度] interface 接口名称 [extends 其他的类名] {</p><pre><code>// 声明变量// 抽象方法</code></pre><p> }</p><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p> class Cat implements 接口名称[, 其他接口, 其他接口…, …] …</p><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p> 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p> public interface Hockey extends Sports, Event</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p> 最常用的继承接口是没有包含任何方法的接口。<br> 标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br> 标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><h1 id="Java-包-package"><a href="#Java-包-package" class="headerlink" title="Java 包(package)"></a>Java 包(package)</h1><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。<br>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。<br>语法：package pkg1[．pkg2[．pkg3…]];<br> 例如,一个Something.java 文件它的内容<br> package net.java.util<br> public class Something{</p><pre><code>...</code></pre><p> }<br> 那么它的路径应该是 net/java/util/Something.java 这样保存的。</p><h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p> 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。<br> 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。<br> 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p><h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p> 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。<br> 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条<br>语法：import package1[.package2…].(classname|<em>);<br> 用 import 关键字引入，使用通配符 “</em>“  import payroll.*;</p><h2 id="package-的目录结构"><a href="#package-的目录结构" class="headerlink" title="package 的目录结构"></a>package 的目录结构</h2><p> 1.创建 vehicle 目录<br> 2.在目录中新建 Car.java</p><pre><code>// 文件名 :  Car.javapackage vehicle;public class Car {   // 类实现  }</code></pre><h2 id="设置-CLASSPATH-系统变量"><a href="#设置-CLASSPATH-系统变量" class="headerlink" title="设置 CLASSPATH 系统变量"></a>设置 CLASSPATH 系统变量</h2><p> 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。<br>用下面的命令显示当前的CLASSPATH变量：<br> Windows 平台（DOS 命令行下）：C:> set CLASSPATH<br> UNIX 平台（Bourne shell 下）：# echo $CLASSPATH<br>删除当前CLASSPATH变量内容：<br> Windows 平台（DOS 命令行下）：C:> set CLASSPATH=<br> UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH<br>设置CLASSPATH变量:<br> Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes<br> UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用指令介绍&quot;&gt;&lt;a href=&quot;#常用指令介绍&quot; class=&quot;headerlink&quot; title=&quot;常用指令介绍&quot;&gt;&lt;/a&gt;常用指令介绍&lt;/h1&gt;&lt;p&gt;javac HelloWorld.java – 该命令用于将 java 源文件编译为 class 字节码文件
      
    
    </summary>
    
      <category term="java" scheme="https://fanerge.github.io/categories/java/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="java" scheme="https://fanerge.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我使用过的面试题</title>
    <link href="https://fanerge.github.io/%E6%88%91%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>https://fanerge.github.io/我使用过的面试题.html</id>
    <published>2017-12-24T13:31:05.000Z</published>
    <updated>2017-12-25T14:05:36.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术基础"><a href="#技术基础" class="headerlink" title="技术基础"></a>技术基础</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="doctype的作用"><a href="#doctype的作用" class="headerlink" title="doctype的作用"></a>doctype的作用</h3><p>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p><h3 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h3><p>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；<br>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p><h3 id="data-属性的作用和相关的API操作"><a href="#data-属性的作用和相关的API操作" class="headerlink" title="data-属性的作用和相关的API操作"></a>data-属性的作用和相关的API操作</h3><p>HTML 5 增加了一项新功能是 自定义数据属性 ，也就是  data-* 自定义属性。<br>    在HTML5中我们可以使用以 data- 为前缀来设置我们需要的自定义属性，来进行一些数据的存放。<br>    data数据都属于页面私有，不会被搜索引擎等外部系统引用。<br>相关的API<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;user&quot; data-id=&quot;001&quot; data-uname=&quot;fanerge&quot; data-date-of-birth=&quot;1991-10-15&quot;&gt; &lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">let dom = document.querySelector(&apos;#user&apos;)</div><div class="line">// 老的访问方式</div><div class="line">dom.getAttribute(&apos;data-uname&apos;) // fanerge</div><div class="line">dom.setAttribute(&apos;data-uname&apos;, &apos;余真帆&apos;) // 余真帆</div><div class="line"></div><div class="line">// HTML5 提供的访问方法(存在一定的兼容性)</div><div class="line">dom.dataset // 一个DOMStringMap</div><div class="line">dom.dataset.id // 001</div><div class="line">dom.dataset.dateOfBirth // 1991-10-15</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>扩展，data-属性选择器<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// css</div><div class="line">.user[data-name=&apos;fanerge&apos;] &#123;</div><div class="line">       color: brown;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">// js</div><div class="line">document.querySelectorAll(&apos;[data-text-colour=&quot;red&quot;]&apos;)</div></pre></td></tr></table></figure></p><h3 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h3><p>defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。<br>    defer (延迟脚本)<br>        相当于告诉浏览器立即下载，但延迟执行（整个页面都解析完毕）。<br>    async(异步脚本)<br>        指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容（css、图片、font等）。<br>        需要注意，异步脚本不要在加载期间修改DOM。 </p><h3 id="事件DOMContentLoaded和load的区别"><a href="#事件DOMContentLoaded和load的区别" class="headerlink" title="事件DOMContentLoaded和load的区别"></a>事件DOMContentLoaded和load的区别</h3><p>它们触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。<br>    DOM文档加载的步骤为</p><pre><code>1.    解析HTML结构。2.    加载样式表文件和外部脚本。3.    解析并执行脚本代码。4.    DOM树构建完成。//DOMContentLoaded（这里也是jquery的ready方法绑定的时机）5.    加载图片等外部文件。6.    页面加载完毕。//load</code></pre><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ol><li><p>与Cookie的比较<br>来看MDN定义：<br>  sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。<br>  localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。<br>  Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies。<br>共同点：都是保存在浏览器端、且同源的<br>区别点：<br>  1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下<br>  2.存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大<br>  3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭<br>  4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的<br>  5.web Storage提供了良好的api如length、key、setItem、getItem、removeItem、clear等方法<br>个人认为产生这些客户端存储的目的是由于 http协议 是无状态，客户端帮助存储客户的操作，发送给服务端以便服务端做出相应的判断。<br>cookie语法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">document.cookie=&quot;name=value; domain=cookieDomain; path=/; &quot;;</div><div class="line">;path=path (例如 &apos;/&apos;, &apos;/mydir&apos;) 如果没有定义，默认为当前文档位置的路径。</div><div class="line">;domain=domain (例如 &apos;example.com&apos;， &apos;.example.com&apos; (包括所有子域名), &apos;subdomain.example.com&apos;) 如果没有定义，默认为当前文档位置的路径的域名部分。</div><div class="line">;max-age=max-age-in-seconds (例如一年为60*60*24*365)</div><div class="line">;expires=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期这个值的格式参见Date.toUTCString() </div><div class="line">;secure (cookie只通过https协议传输) cookie的值字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).</div></pre></td></tr></table></figure><p>cookie的路径：（路径能解决在同一个域下访问 cookie 的问题）<br>  出于安全方面的考虑，只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置。<br>  让这个设置的cookie 能被其他目录或者父级的目录访问的方法：<br>  document.cookie = “userName = 独行冰海; path=/“;<br>cookie的域：（域能解决同一个主域下的访问问题）<br>  让 “www.baidu.com” 下的cookie被 “mp3.baidu.com” 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 “/“<br>  document.cookie = “username=独行冰海; path=/; domain=baidu.com”</p></li><li><p>扩展-缓存相关的知识<br>http头部缓存相关key<br>  request header缓存相关</p><pre><code>1.cache-control：no-cache、no-store、max-age2.if-none-match：该字段与响应中的eTag一起使用，表示检查实体是否有更新改变3.if-modified-since: 该字段与last-modified配合使用</code></pre><p>  response header缓存相关：</p><pre><code>1.Etag：2.expires：3.last-modified:</code></pre></li><li><p>应用场景<br>首次注册用户的引导等</p></li><li><p>在什么情况是失效<br>  1.浏览器清除缓存<br>  2.5M大小的限制<br>  3.IOS safari 的隐私模式（主要我查MDN上有说明，其他浏览器隐私模式会新建 Storage对象，不会与普通模式公用，且关闭隐私模式时 Storage对象 就消失）</p></li><li><p>浏览器内多个标签页之间的通信<br>1.localstorge + storage 事件<br>  页面1：localStorage.setItem(“name”, ‘测试’);<br>  页面2: window.addEventListener(‘stroge’, (e)=&gt; { console.log(<code>${e.key} = ${e.newValue}</code>) }, false)<br>2.cookie + setInterval（类似于轮询）</p></li></ol><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><pre><code>History.lengthHistory.scrollRestoration (实验性)-- 允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。History.state 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。History.back()History.forward()History.go()History.pushState()History.replaceState()</code></pre><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。<br>作用：解决上面问题，window.postMessage() 方法可以安全地实现跨源通信。<br>语法：otherWindow.postMessage(message, targetOrigin, [transfer]);<br>参数：otherWindow<br>        其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。<br>    message<br>        将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。<br>    targetOrigin（安全性从这里入手）<br>        通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。<br>    transfer 可选<br>        是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。<br>其他window监听message事件<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&quot;message&quot;, receiveMessage, false);</div><div class="line"></div><div class="line">function receiveMessage(event)&#123;</div><div class="line">  // For Chrome, the origin property is in the event.originalEvent</div><div class="line">  // object.</div><div class="line">  var origin = event.origin || event.originalEvent.origin; </div><div class="line">  if (origin !== &quot;http://example.org:8080&quot;)</div><div class="line">return;</div><div class="line"></div><div class="line">  // todo...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：message 的属性有:<br>    data<br>        从其他 window 中传递过来的对象。<br>    origin<br>        调用 postMessage  时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “<a href="https://example.org" target="_blank" rel="external">https://example.org</a> (implying port 443)”、“<a href="http://example.net" target="_blank" rel="external">http://example.net</a> (implying port 80)”、“<a href="http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。" target="_blank" rel="external">http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。</a><br>    source<br>        对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。    </p><p>关注下安全性问题<br>    1.如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。<br>    2.请始终使用origin和source属性验证发件人的身份，还应该始终验证接收到data的消息的语法。<br>    3.当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">详细需了解-MDN</a></p><h4 id="WebSocket对象"><a href="#WebSocket对象" class="headerlink" title="WebSocket对象"></a>WebSocket对象</h4><p>作用：<br>    提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。<br>    WebSocket构造器方法接受一个必须的参数和一个可选的参数：<br>语法：<br>    WebSocket WebSocket(in DOMString url,in optional DOMString[] protocols);<br>具体参数：<br>    url – 表示要连接的URL。这个URL应该为响应WebSocket的地址。<br>    protocols 可选 – 可以是一个单个的协议名字字符串或者包含多个协议名字字符串的数组。这些字符串用来表示子协议，这样做可以让一个服务器实现多种WebSocket子协议（例如你可能希望通过制定不同的协议来处理不同类型的交互）。如果没有制定这个参数，它会默认设为一个空字符串。<br>属性：<br>    binaryType、onclose、onerror、onmessage、onopen（EventListener）<br>方法：<br>    void send(in DOMString data);<br>    void close(in optional unsigned long code, in optional DOMString reason);<br>构造器方法可能抛出以下异常：<br>    SECURITY_ERR – 试图连接的端口被屏蔽。<br>示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Create WebSocket connection.</div><div class="line">const socket = new WebSocket(&apos;ws://localhost:8080&apos;);</div><div class="line"></div><div class="line">// Connection opened</div><div class="line">socket.addEventListener(&apos;open&apos;, function (event) &#123;</div><div class="line">socket.send(&apos;Hello Server!&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Listen for messages</div><div class="line">socket.addEventListener(&apos;message&apos;, function (event) &#123;</div><div class="line">console.log(&apos;Message from server&apos;, event.data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="external">MDN-WebSocket</a></p><p>扩展（Ajax轮询）这是比较原始的方案<br>    定义：轮询（polling）：客户端按规定时间定时向服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.setInterval(function()&#123;$.ajax(getting)&#125;,1000);</div></pre></td></tr></table></figure></p><pre><code>长轮询（递归）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var getting = &#123;</div><div class="line">url:&apos;server.php&apos;,</div><div class="line">dataType:&apos;json&apos;,</div><div class="line">success:function(res) &#123;</div><div class="line">// todo...</div><div class="line">$.ajax(getting); //关键在这里，回调函数内再次请求Ajax</div><div class="line">&#125;        </div><div class="line">error:function(res)&#123;</div><div class="line">$.ajax(getting);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">$.ajax(getting); // 这里第一次调用ajax</div></pre></td></tr></table></figure></code></pre><h4 id="CMD和AMD以及UMD，UMD的实现"><a href="#CMD和AMD以及UMD，UMD的实现" class="headerlink" title="CMD和AMD以及UMD，UMD的实现"></a>CMD和AMD以及UMD，UMD的实现</h4><p>AMD（浏览器环境）– RequireJS<br>CMD（Node） – CommonJS<br>UMD: 通用模块规范（兼容低版本浏览器设置在window上的属性如window.$ – 代表jquery）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 自己封装一个符合UMD的功能函数库取名 fanerge</div><div class="line">(function (window, factory) &#123;</div><div class="line">if (typeof exports === &apos;object&apos;) &#123;</div><div class="line">// UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。</div><div class="line">module.exports = factory();</div><div class="line">&#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class="line">// 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</div><div class="line">define(factory);</div><div class="line">&#125; else &#123;</div><div class="line">// 否则就绑定到全局的一个属性上，这里绑定到window对象的fanerge属性上</div><div class="line">window.fanerge = factory();</div><div class="line">&#125;</div><div class="line">&#125;)(this, function () &#123;</div><div class="line">let fanerge = &#123;&#125;;</div><div class="line">fanerge.alert = function alert() &#123;</div><div class="line">alert(&apos;fanerge&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fanerge.log = function log() &#123;</div><div class="line">console.log(&apos;fanerge&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return fanerge;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 使用时</div><div class="line">fanerge.log()</div></pre></td></tr></table></figure></p><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>分类：专用worker（一个专用worker仅仅能被生成它的脚本所使用）、共享worker<br>作用：Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。<br>限制：在worker内直接操作DOM节点，或者使用window对象的默认方法和属性。<br>主线程与worker数据传递：workers和主线程间的数据传递通过这样的消息机制进行——双方都使用postMessage()方法发送各自的消息，使用onmessage事件处理函数来响应消息（消息被包含在Message事件的data属性中）。这个过程中数据并不是被共享而是被复制。<br>终止worker：<br>    在主线程中终止：workerName.terminate(); worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。<br>    在worker中终止：close();<br>处理错误：onerror 事件处理函数会被调用，对应的参数，message – 可读性良好的错误消息；filename – 发生错误的脚本文件名；lineno – 发生错误时所在脚本文件的行号。<br>生成subworker： 在worker 中能够生成 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>引入脚本与库：Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；<br>共享worker与专有worker的区别：<br>    1.创建worker<br>        var myWorker = new Worker(‘worker.js’); // 专有<br>        var myWorker = new SharedWorker(‘worker.js’); // 共享<br>    2.通信（发送消息和接收消息都需要携带port）<br>        父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。<br>        myWorker.port.start();  // 父级线程中的调用<br>        port.start(); // worker线程中的调用, 假设port变量代表一个端口<br>        共享worker中消息的接收和发送<br>        消息可以像之前那样发送到worker了，但是postMessage() 方法必须被端口对象调用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">详情参考MDN-web Worker</a></p><h4 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h4><p>1、File- 单个文件；提供了诸如file name、file size、mimetype等只读文件属性。<br>2、FileList- 一个类数组File对象集合；<br>构造函数<br>    File()  返回一个新构建的文件对象（File）。<br>属性<br>    File.lastModified – 返回当前 File 对象所引用文件最后修改时间， 自 1970年1月1日0:00 以来的毫秒数。<br>    File.name – 返回当前 File 对象所引用文件的名字。<br>    File.size – 返回文件的大小。<br>    File.type – 返回文件的 多用途互联网邮件扩展类型。<br>获取用户选择文件的方式<br>    来自用户在一个input元素上选择文件后返回的FileList对象。<br>        e.target.files; //FileList<br>    来自拖放操作生成的 DataTransfer对象。<br>        e.dataTransfer.files; //FileList<br>    来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。</p><h4 id="FileReader-API"><a href="#FileReader-API" class="headerlink" title="FileReader API"></a>FileReader API</h4><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>构造函数<br>    FileReader() – 返回一个新构造的FileReader。<br>属性：<br>    error    DOMError    在读取文件时发生的错误. 只读.<br>    readyState    unsigned short    表明FileReader对象的当前状态. 值为State constants中的一个. 只读<br>    result    jsval    读取到的文件内容.这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的. 只读.<br>方法：<br>    void abort();<br>    void readAsArrayBuffer(in Blob blob);<br>    void readAsBinaryString(in Blob blob);<br>    void readAsDataURL(in Blob blob);<br>    void readAsText(in Blob blob, [optional] in DOMString encoding);<br>事件处理程序：<br>    onabort – 当读取操作被中止时调用.<br>    onerror – 当读取操作发生错误时调用.<br>    onload – 当读取操作成功完成时调用.<br>    onloadend – 当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用.<br>    onloadstart – 当读取操作将要开始之前调用.<br>    onprogress – 在读取数据过程中周期性调用.<br>示例（本地文件预览）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let oFReader = new FileReader(), // 新建一个 FileReader实例</div><div class="line">rFilter = /^(?:image\/bmp|image\/)$/i; // 可以读取的文件格式</div><div class="line"></div><div class="line">// 文件异步读取完成时，将设置预览组件的 src 属性</div><div class="line">oFReader.onload = function (oFREvent) &#123;</div><div class="line">document.getElementById(&quot;uploadPreview&quot;).src = oFREvent.target.result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 加载用户选择的图片</div><div class="line">function loadImageFile() &#123;</div><div class="line">// 没有选择文件</div><div class="line">if (document.getElementById(&quot;uploadImage&quot;).files.length === 0) &#123; return; &#125;</div><div class="line">var oFile = document.getElementById(&quot;uploadImage&quot;).files[0];</div><div class="line">// 文件的 MIMETYPE 不满足当前正则</div><div class="line">if (!rFilter.test(oFile.type)) &#123; return; &#125;</div><div class="line">// 读取文件</div><div class="line">oFReader.readAsDataURL(oFile);</div><div class="line">&#125;</div><div class="line">loadImageFile()</div></pre></td></tr></table></figure></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h3 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别"></a>块级元素和行内元素的区别</h3><h3 id="CSS-sprites"><a href="#CSS-sprites" class="headerlink" title="CSS sprites"></a>CSS sprites</h3><h3 id="line-height-和-vertical-align"><a href="#line-height-和-vertical-align" class="headerlink" title="line-height 和 vertical-align"></a>line-height 和 vertical-align</h3><p>line-height的值由font-size和字体类型共同决定。<br>vertical-align的值<br>    vertical-align: top / bottom，表示与 line-box 的顶部或底部对齐<br>    vertical-align: text-top / text-bottom，表示与 content-area 的顶部或底部对齐</p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>需要配合脱离文档流的属性使用，position: relative, absolute, fixed。</p><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>以Bootstrap3为例（12栅格系统）<br>    采用float + width(百分比) + @media(媒体查询实现适配)<br>以Bootstrap4为例<br>    采用容器flex布局（容器6个属性，子项目6个属性）</p><h3 id="Media-Query"><a href="#Media-Query" class="headerlink" title="Media Query"></a>Media Query</h3><p>语法：<br>    1.link元素中的CSS媒体查询<br>        <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</code><br>    2.样式表中的CSS媒体查询<br>        @media (max-width: 600px) { … }<br>逻辑操作符:<br>    all（默认）<br>    not – not 关键字应用于整个媒体查询，在媒体查询为假时返回真 (比如 monochrome 应用于彩色显示设备上或一个600像素的屏幕应用于 min-width: 700px 属性查询上 )。<br>    and – and关键字用于合并多个媒体属性或合并媒体属性与媒体类型。<br>        @media tv and (min-width: 700px) and (orientation: landscape) { … }<br>    only – only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式<br>        <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;</code></p><h3 id="CSS选择器的性能优化"><a href="#CSS选择器的性能优化" class="headerlink" title="CSS选择器的性能优化"></a>CSS选择器的性能优化</h3><p>说明：<br>    1.样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。<br>    2.如果你非常在意页面的性能那千万别使用CSS3选择器。实际上，在所有浏览器中，用 class 和 id 来渲染，比那些使用同胞，后代选择器，子选择器（sibling, descendant and child selectors）对页面性能的改善更值得关注。<br>CSS选择器的效率从高到低排序：<br>    1.id选择器（#myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[rel=”external”]）9.伪类选择器（a:hover,li:nth-child）<br>具体做法：<br>    1.不要在编写id规则时用标签名或类名<br>    2.不要在编写class规则时用标签名<br>    3.把多层标签选择规则用class规则替换，减少css查找<br>    4.避免使用子选择器<br>    5.依靠继承<br>    <a href="http://www.aliued.cn/2013/01/24/%E7%BD%91%E7%AB%99css%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%A7%E8%83%BD%E8%AE%A8%E8%AE%BA.html" target="_blank" rel="external">参考阿里文章</a></p><h3 id="CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考"><a href="#CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考" class="headerlink" title="CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考"></a>CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考</h3><p><a href="https://www.sass.hk/" target="_blank" rel="external">SASS</a></p><h3 id="Webfonts"><a href="#Webfonts" class="headerlink" title="Webfonts"></a>Webfonts</h3><p>作用：WebFont 技术可以让网页使用在线字体，而无需使用图片，从而有机会解决开头设计师提到的问题。它通过 CSS 的@font-face语句引入在线字体，使用 CSS 选择器指定运用字体的文本，与此同时专用于 Web 展示的 woff 格式字体也得到各大浏览器厂商支持，进一步减少了字体的体积。<br>语法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;</div><div class="line">  font-family: &apos;ciclefina&apos;;</div><div class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot&apos;);</div><div class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</div><div class="line"> url(&apos;fonts/cicle_fina-webfont.woff2&apos;) format(&apos;woff2&apos;);</div><div class="line">  font-weight: normal;</div><div class="line">  font-style: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>WebFont的优势：<br>    支持选中、复制<br>    支持 Ctrl+F 查找<br>    对搜索引擎友好<br>    支持工具翻译<br>    支持无障碍访问，支持朗读<br>    字体是矢量图形，支持矢量缩放，自动适配高清屏<br>    文本修改方便<br>    字形可以重复利用，节省网络资源<br>中文 WebFont 的困境：<br>    1、中文字体体积<br>    2、浏览器类型（各种壳的浏览器）<br>    3、操作系统（主要是XP系统）<br>现有的中文 WebFont 解决方案：<br>    1.本地制作<br>        通过字体制作工具来删除没有使用的字符，即制作精简版字体，这也是我之前实践过的方案。</p><pre><code>2. 字体云服务    </code></pre><p><a href="https://www.youziku.com/" target="_blank" rel="external">https://www.youziku.com/</a><br>    3开源工具<br><a href="http://font-spider.org/" target="_blank" rel="external">字蛛（Font-Spider）</a><br><a href="http://www.uisdc.com/the-great-chinese-webfont" target="_blank" rel="external">参考Webfont</a>        </p><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><p>说明：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>    由容器 Container 和 子项目 Item 构成。</p><h4 id="Container-容器相关的属性"><a href="#Container-容器相关的属性" class="headerlink" title="Container 容器相关的属性"></a>Container 容器相关的属性</h4><p>首先 display: flex / inline-flex;<br>flex-direction – 决定主轴的方向（即项目的排列方向）。<br>flex-wrap – 如果一条（主轴）轴线排不下，如何换行。<br>flex-flow – 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br>justify-content – 定义了项目在主轴上的对齐方式。<br>align-items – 定义项目在交叉轴上如何对齐。<br>align-content – 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><h4 id="Item-子项目相关的属性"><a href="#Item-子项目相关的属性" class="headerlink" title="Item 子项目相关的属性"></a>Item 子项目相关的属性</h4><p>order – 定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow – 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink – 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-basis – 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>flex – 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>align-self – 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮老师博客-Flex</a>        </p><h4 id="适配retina屏幕"><a href="#适配retina屏幕" class="headerlink" title="适配retina屏幕"></a>适配retina屏幕</h4><p>什么是retina屏幕适配？<br>    当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。<br>    换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。<br>适配方法：<br>1.直接加载2倍大小的图片。<br>    假如要显示的图片大小为200px<em>300px，你准备的实际图片大小应该为400px</em>600px，并且使用以下代码控制即可：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;pic.png&quot; height=&quot;200px&quot; width=&quot;300px&quot; /&gt;</div></pre></td></tr></table></figure></p><pre><code>缺点：    对于普通屏来说加载多倍图势必会导致页面加载时间加长，用户体验不佳。更好的方案：</code></pre><p><a href="http://imulus.github.io/retinajs/" target="_blank" rel="external">开源retina.js</a><br>原理是通过window.devicePixelRatio &gt; 1判断是不同屏还是retina屏，然后再加载对应的几倍图。<br>2.Image-set控制<br>    假如要显示的图片大小为200px<em>300px，你准备的图片应有两张：一张大小为200px</em>300px，命名为pic.png；另一张大小为400px*600px，命名为pic@2x.png（@2x是Retina图标的标准命名方式），然后使用以下css代码控制：<br>    背景方式使用：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#logo &#123;</div><div class="line">background: url(pic.png) 0 0 no-repeat;</div><div class="line">background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x);</div><div class="line">background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);</div><div class="line">background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);</div><div class="line">background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>在img标签属性中使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;pic.png&quot; srcset=&quot;pic@2x.png 2x&quot; /&gt;</div></pre></td></tr></table></figure></code></pre><p>3.使用@media控制<br>    实际是判断屏幕的像素比来取舍是否显示高分辨率图像，代码如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@media only screen and (-webkit-min-device-pixel-ratio: 1.5),</div><div class="line">  only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */</div><div class="line">  only screen and (-o-min-device-pixel-ratio: 3/2),</div><div class="line">  only screen and (min-device-pixel-ratio: 1.5) &#123;</div><div class="line">#logo &#123;</div><div class="line">background-image: url(pic@2x.png);</div><div class="line">background-size: 100px auto;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="http://www.ui.cn/detail/24556.html" target="_blank" rel="external">参考文章</a>        </p><h4 id="CSS3新增伪类以含义"><a href="#CSS3新增伪类以含义" class="headerlink" title="CSS3新增伪类以含义"></a>CSS3新增伪类以含义</h4><p>p:first-letter    选择每一个P元素的第一个字母<br>p:first-line    选择每一个P元素的第一行<br>p:first-child    指定只有当p元素是其父级的第一个子级的样式<br>p:last-child    选择每个p元素是其父级的最后一个子级。<br>p:first-of-type    选择每个p元素是其父级的第一个p元素<br>p:last-of-type    选择每个p元素是其父级的最后一个p元素<br>p:only-of-type    选择每个p元素是其父级的唯一p元素<br>p:only-child    选择每个p元素是其父级的唯一子元素<br>p:nth-child(2)    选择每个p元素是其父级的第二个子元素<br>p:nth-last-child(2)    选择每个p元素的是其父级的第二个子元素，从最后一个子项计数<br>p:nth-of-type(2)    选择每个p元素是其父级的第二个p元素<br>p:nth-last-of-type(2)    选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</p><p>:root    选择文档的根元素<br>p:empty    选择每个没有任何子级的p元素（包括文本节点）<br>input:enabled    选择每一个已启用的输入元素<br>input:disabled    选择每一个禁用的输入元素<br>input:checked    选择每个选中的输入元素<br>:not(p)    选择每个并非p元素的元素<br>::selection    匹配元素中被用户选中或处于高亮状态的部分</p><p>a[src^=”https”]    选择每一个src属性的值以”https”开头的元素<br>a[src$=”.pdf”]    选择每一个src属性的值以”.pdf”结尾的元素<br>a[src*=”runoob”]    选择每一个src属性的值包含子字符串”runoob”的元素</p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="JavaScript语言"><a href="#JavaScript语言" class="headerlink" title="JavaScript语言"></a>JavaScript语言</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>定义：定义在一个函数内部的函数（将函数内部的变量保留在内存中，这样外部就可以改函数内相关的变量）。<br>    闭包就是能够读取其他函数内部变量的函数。<br>用途：一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>    1.匿名自执行函数 (function(){ // todo… })()<br>    2.缓存（针对于复杂的计算，每次计算前先读缓存如果没有在进行计算并添加到缓存）<br>    3.实现封装（可以将函数内部的变量通过暴露接口在函数外可以访问）<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person = function()&#123;    </div><div class="line">//变量作用域为函数内部，外部无法访问    </div><div class="line">var name = &quot;default&quot;;       </div><div class="line">   </div><div class="line">return &#123;    </div><div class="line">   getName : function()&#123;    </div><div class="line">   return name; // 可以访问 name 属性    </div><div class="line">   &#125;,    </div><div class="line">   setName : function(newName)&#123;    </div><div class="line">   name = newName; // 可以为 name 赋值    </div><div class="line">   &#125;    </div><div class="line">&#125;    </div><div class="line">&#125;();</div></pre></td></tr></table></figure></p><pre><code>4.闭包的另一个重要用途是实现面向对象中的对象    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;    </div><div class="line">var name = &quot;default&quot;;       </div><div class="line">   </div><div class="line">return &#123;    </div><div class="line">   getName : function()&#123;    </div><div class="line">   return name;    </div><div class="line">   &#125;,    </div><div class="line">   setName : function(newName)&#123;    </div><div class="line">   name = newName;    </div><div class="line">   &#125;    </div><div class="line">&#125;    </div><div class="line">&#125;;    </div><div class="line">  </div><div class="line">var john = Person();    </div><div class="line">john.getName();   </div><div class="line">john.setName(&quot;john&quot;);    </div><div class="line">john.getName();</div></pre></td></tr></table></figure></code></pre><p><a href="http://www.jb51.net/article/57259.htm" target="_blank" rel="external">51脚本</a></p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量作用域<br>函数作用域<br>块级作用域<br>    ES6提出，let 和 const 声明。{}范围为该区域<br>    建议在支持的环境尽量使用 let 和 const 代替 var。<br>作用域链<br>    动态作用域 – 函数执行时才确定的。this（4种情况，资料较多这里不再阐述）<br>    静态作用域 – 函数定义时就确定的。<br>    函数的可以允许嵌套的。例如有一个全局函数a， 在 a 在有又定义了函数 b，此时就形成了一条作用域链。<br>        b -&gt; a -&gt; window(浏览器)/global(Node环境)</p><h4 id="原型（-gt-代表指向）"><a href="#原型（-gt-代表指向）" class="headerlink" title="原型（-&gt; 代表指向）"></a>原型（-&gt; 代表指向）</h4><p>Number.prototype(有一些自己的方法如，toFixed) -&gt; Object.prototype (对象所有的方法) -&gt; undefined(原型链的顶层，为null)<br>Number、String、Boolean、Array、Date、RegExp、都是上面的原型链。<br>Math对象有点特殊，无需在使用这个对象之前对它进行定义。类似于在该对象上定义了许多静态属性和静态方法，可以直接使用（Math.PI、Math.abs(-3)）。<br><img src="http://oxpnrlb4j.bkt.clouddn.com/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="搞懂这张就好了"></p><h4 id="面向对象-继承"><a href="#面向对象-继承" class="headerlink" title="面向对象/继承"></a>面向对象/继承</h4><p><a href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象</a><br><a href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-1/">继承</a><br><a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="external">JS实现继承的几种方式</a></p><h4 id="this（也就是说的动态作用域）"><a href="#this（也就是说的动态作用域）" class="headerlink" title="this（也就是说的动态作用域）"></a>this（也就是说的动态作用域）</h4><p>1.普通函数（挂载到全局上面）<br>    在 ‘use strict’ 严格模式中指向 undefined<br>    在非严格模式中指向window/global（适执行环境而定）<br>2.对象的方法<br>    this 指向该对象<br>3.作为构造函数调用<br>    this 指向该构造函数的实例<br>4.call、apply以及bind方法可以改变this指向<br>    this 均指向第一个参数<br>    区别：call、apply返回值是你调用的方法的返回值；而bind返回由指定的this值和初始化参数改造的原函数拷贝。<br>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">这三个方法的区别，请访问MDN</a></p><h4 id="call和apply的作用，以及区别"><a href="#call和apply的作用，以及区别" class="headerlink" title="call和apply的作用，以及区别"></a>call和apply的作用，以及区别</h4><p>参见上面        </p><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>1.过去常用于设计为一个独立的作用域<br>    (function(形参){ // todo })(实参);<br>2.函数声明也是匿名函数<br>    let demo = function(){};        </p><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>1.描述几个正则的语法含义，比如：[]、{}、\w、\d、\s等<br>    [abc]    查找方括号之间的任何字符。<br>    [^abc]    查找任何不在方括号之间的字符。<br>    [0-9]    查找任何从 0 至 9 的数字。<br>    n{X}    匹配包含 X 个 n 的序列的字符串。<br>    n{X,}    前面的模式 n 连续出现至少 X 次时匹配。<br>    n{X,Y}    前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。<br>    PS：所有的大写均表示非。<br>    \w    查找单词字符。<br>    \d    查找数字。<br>    \s    查找空白字符。包括空格符、制表符、回车符、换行符、垂直换行符、换页符<br>    \b    匹配单词边界。<br>2.i/g/m等的含义（ES6中添加u、y）<br>    i – ignore（忽略大小写）<br>    g – global（全局匹配及查找所有匹配而非在找到第一个匹配后停止）<br>    m – multiple（执行多行匹配）<br>    ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。<br>    ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。<br>3.replace方法<br>    第二个参数为string – string.replace(searchvalue,newvalue)<br>    第二个参数是回调函数<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">this.replace(/(^\s+)|(\s+$)/g,function(result,$1,$2,offset,source)&#123;</div><div class="line">//arguments中的每个元素对应一个参数</div><div class="line">console.log(arguments);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>具体参数说明：<br>result: 本次匹配到的结果<br>$1,…$9: 正则表达式中有几个()，就会传递几个参数，$1~$9分别代表本次匹配中每个()提取的结果，最多9个<br>offset:记录本次匹配的开始位置<br>source:接受匹配的原始字符串<br>4.匹配任意字符（使用互补的方式来实现）<br>    [\s\S] 或 [\w\W] 或 [.\r\n]<br>    注：\w 等价于 [A-Za-z0-9_]<br><a href="http://www.jb51.net/article/80544.htm" target="_blank" rel="external">51job</a>            </p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>1.DOM事件流<br>    冒泡：事件冒泡的过程是：a –&gt; div –&gt; body 。<br>        产生的原因：因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。<br>        处理问题：event.stopPropagation()阻止事件的传递行为。<br>        应用：事件委托<br>    捕获：事件从Document节点自上而下向目标节点传播的阶段<br>    完整的DOM事件流模型：<br>        捕获阶段 、目标阶段 、冒泡阶段<br>2.兼容性问题（优先级逐渐升高）<br>    html的onclick属性绑定<br>    dom.onclick = function(){}<br>    dom.attachEvent(“onclick”, callback) // dom.detachEvent(“onclick”, callback)<br>    dom.addEventListener(‘click’, callback, userCapture) // dom.removeEventListener(‘click’, callback, userCapture)<br>3.事件代理<br>    原理为事件冒泡<br>    例如一下DOM结构<br>    ul<br>        li<br>        li<br>    对ul绑定事件，而不是对li绑定事件。在通targe.tagName，以及点的是哪一个li做不用的操作。<br>4.自定义事件<br>    如何实现一个自定义事件的系统<br>    定义：自定义事件就是自己定义事件类型，自己定义事件处理函数，在合适的时候需要哪个事件类型，就去调用哪个处理程。<br>    实现过程：（其实就是发布订阅模式或监听者模式）<br>1.定义自定义事件构造函数<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function EventTarget()&#123;</div><div class="line">//保存事件处理程序数组集合，每个实例不共享</div><div class="line">this.handlers = &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2.在构造函数的原型上添加实例共享的方法<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EventTarget.prototype = &#123;</div><div class="line">constructor: EventTarget, // 矫正原型链指向</div><div class="line">addEvent: function(type, handler) &#123;&#125;, // 添加一个事件处理函数</div><div class="line">addEvents: function(obj)&#123;&#125;, // 批量添加事件</div><div class="line">removeEvent: function(type, handler)&#123;&#125;, // 移除一个事件处理函数</div><div class="line">removeEvents: function(params) &#123;&#125;, // 批量移除事件</div><div class="line">fireEvent: function(type) &#123;&#125;, // 触发一个事件</div><div class="line">fireEvents: function(array) &#123;&#125; // 批量触发事件</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>3.调用<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function b()&#123;</div><div class="line">  console.log(123);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var target = new EventTarget();</div><div class="line">target.addEvent(&quot;eat&quot;, b);</div><div class="line"> </div><div class="line">target.fireEvent(&#123; type: &quot;eat&quot; &#125;); // 12</div></pre></td></tr></table></figure></p><p><a href="http://blog.csdn.net/wkyseo/article/details/53609509" target="_blank" rel="external">详细信息参考博客</a></p><h4 id="BOM-DOM"><a href="#BOM-DOM" class="headerlink" title="BOM/DOM"></a>BOM/DOM</h4><p>BOM – 浏览器对象模型（Browser Object Model，简称BOM）。<br>    提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本，对Cookie的支持等。<br>    Window 对象<br>    Navigator 对象<br>    Screen 对象<br>    History 对象<br>    Location 对象<br>DOM – 文档对象模型（Document Object Model，简称DOM）。<br>    DOM 就是针对 HTML 和 XML 提供的一个API。<br>    兼容性问题<br>    常规的增删改查等操作的原生方法的考核<br>    查：<br>        getElementById()、<br>        getElementsByTagName()、<br>        getElementsByName()、<br>        getElementsByClassName()、<br>        querySelector()、<br>        querySelectorAll()<br>    改：<br>        document.getElementById(id).innerHTML=new value：修改HTML元素<br>        document.getElementById(id).attribute=new value：修改元素属性<br>        document.getElementById(id).style.property=new style：修改元素CSS<br>        setAttribute()：setAttribute()方法将设置元素中某个属性和值<br>        parent.replaceChild(child,oldElem)：替换节点<br>    增：<br>        A.append(B) : 把B追加到A内部（所有的A元素，以下类似）<br>        A.appendTo(B) : 把A追加到B内部<br>        A.prepend(B) : 把B追加到A内部的内容前(即B成为A第一个子元素)<br>        A.prependTo(B) : 把A追加到B的内容前（即A成为B第一个子元素）<br>        A.after(B) : 在A后追加B<br>        A.before(B): 在A前追加B<br>        node.insertBefore(A,B): 在父节点node里面的B节点前面追加A<br>        parent.replaceChild(child,oldElem)：替换节点<br>    删：<br>        dom.remove()：删除该元素<br>        parent.removeChild(child)：删除子元素</p><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>1.JS实现一个动画的方式<br>    setTimeout、<br>    setInterval、<br>    setImmediate（window.clearImmediate）微软取消该方法，不建议使用、<br>    window.requestAnimationFrame(callback)（window.cancelAnimationFrame() ）<br>        参数：一个在每次需要重新绘制动画时调用的包含指定函数的参数。<br>        这个回调函数有一个传参，DOMHighResTimeStamp，指示从触发 requestAnimationFrame 回调到现在的时间。<br>2.CSS3的动画<br>    申明一个动画：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@keyframes animationName &#123;</div><div class="line">from &#123;background: red;&#125;</div><div class="line">to &#123;background: yellow;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>    PS：参数说明，animationname、keyframes-selector（from（0%）、to（100%））、css-styles使用一个动画：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div:hover &#123;</div><div class="line">animation: animationName 5s;</div><div class="line">&#125;</div><div class="line">PS：animation: name duration timing-function delay iteration-count direction fill-mode play-state;</div></pre></td></tr></table></figure></code></pre><p>3.如何优化动画的流畅度<br>    每一帧都需要在16ms内渲染<br>    动画添加到opacity和transform等属性之上。<br>    将内容藏在不起眼的地方，使用pointer-events:通过透明度为0来隐藏元素。<br>    不要同一时间所有元素都做动画，除非使用编排。<br>    轻微地增加延迟，让编排动作变得简单。<br>    使用全局倍数来设计慢动画，然后加速之后所有的元素。<br>    拍下你的UI，并且重放他们，以获取有价值的第三方关点。<br>    网络活动导致滞后，你需要提前或者滞后加载大的http请求。<br>    不要直接绑定滚动。<br>    尽早&amp;经常在手机上测试。<br>    在不同的设备上经常测试，屏幕大小，像素，或者设备都有着极大的暗示。<br>4.animation-fill-mode<br>    animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。<br>    属性值：none | forwards | backwards | both<br><a href="http://www.open-open.com/lib/view/open1480991763196.html" target="_blank" rel="external">流畅web动画的十个法则</a></p><h4 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h4><h4 id="动画事件-自定义事件（start、process、end等）"><a href="#动画事件-自定义事件（start、process、end等）" class="headerlink" title="动画事件/自定义事件（start、process、end等）"></a>动画事件/自定义事件（start、process、end等）</h4><p>animationstart - CSS 动画开始后触发<br>animationiteration - CSS 动画重复播放时触发<br>animationend - CSS 动画完成后触发</p><h4 id="shim和polyfill"><a href="#shim和polyfill" class="headerlink" title="shim和polyfill"></a>shim和polyfill</h4><p>polyfill 是 shim 的一种。<br>shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；<br>polyfill 特指 shim 成的 api 是遵循标准的，其典型做法是在IE浏览器中增加 window.XMLHttpRequest ，内部实现使用 ActiveXObject。</p><h4 id="Ajax-跨域"><a href="#Ajax-跨域" class="headerlink" title="Ajax/跨域"></a>Ajax/跨域</h4><p>1.对Ajax的作用、API方法的理解<br>    Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。<br>    XMLHttpRequest(ActiveXObject 兼容版本ie)或新的Fetch API<br>    重点研究下Fetch API<br>        Fetch API提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。<br>        Fetch 接口<br>GlobalFetch<br>    包含了 fetch() 方法，用于获取资源。<br>Headers（构造器）<br>    相当于 response/request 的头信息，可以修改它，或者针对不同的结果做不同的操作。<br>    Headers.append()<br>        给现有的header添加一个值, 或者添加一个未存在的header并赋值.<br>    Headers.delete()<br>        从Headers对象中删除指定header.<br>    Headers.get()<br>        从Headers对象中返回指定header的第一个值.<br>    Headers.getAll()<br>        以数组的形式从Headers对象中返回指定header的全部值.<br>    Headers.has()<br>        以布尔值的形式从Headers对象中返回是否存在指定的header.<br>    Headers.keys()<br>        以迭代器的形式返回Headers对象中所有存在的header名.<br>    Headers.set()<br>        替换现有的header的值, 或者添加一个未存在的header并赋值.<br>    Headers.values()<br>        以迭代器的形式返回Headers对象中所有存在的header的值.<br>    Headers.entries()<br>        以 迭代器 的形式返回Headers对象中所有的键值对.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myHeaders = new Headers();</div><div class="line">myHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);</div><div class="line">myHeaders.set(&quot;Content-Type&quot;, &quot;text/html&quot;);</div><div class="line">console.log(myHeaders.get(&quot;Content-Length&quot;)); // 11</div><div class="line">myHeaders.delete(&quot;X-Custom-Header&quot;);</div><div class="line">myHeaders.has(&quot;Content-Type&quot;)</div></pre></td></tr></table></figure></p><p>Body<br>    代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。<br>    Body.bodyUsed（属性）<br>        包含一个指示body是否被读取过的 Boolean 值。<br>    Body.arrayBuffer()<br>        使用一个buffer数组来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.blob()<br>        使用一个Blob对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.formData()<br>        使用一个 FormData 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.json()<br>        使用一个 JSON 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.text()<br>        使用一个USVString (文本) 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body" target="_blank" rel="external">MDN-Fetch-body</a><br>Request（构造器）<br>    相当于一个资源请求。<br>    Request.method 只读<br>        请求使用的方法 (GET, POST, 等.)<br>    Request.url 只读<br>        请求使用的 URL。<br>    Request.headers 只读<br>        请求所关联的 Headers 对象。<br>    Request.context 只读<br>        请求的上下文 例如：(例如：audio, image, iframe, 等)<br>    Request.referrer 只读<br>        请求的来源 (例如：client).<br>    Request.mode 只读<br>        请求的模式 (例如： cors, no-cors, same-origin).<br>    Request.credentials 只读<br>        请求的凭证 (例如： omit, same-origin).<br>    Request.redirect 只读<br>        如何处理重定向模式 (例如： follow, error, or manual)<br>    Request.integrity 只读<br>        请求内容的 subresource integrity 值 (例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).<br>    Request.cache 只读<br>        请求的缓存模式 (例如： default, reload, no-cache).<br>    Body.bodyUsed 只读<br>        指示body是否被使用， 类型为Boolean<br>    Request.clone()<br>        创建当前request的副本。</p><pre><code>Request implements Body, so it also has the following methods available to it:    Body.arrayBuffer()    Returns a promise that resolves with an ArrayBuffer representation of the request body.    Body.blob()    Returns a promise that resolves with an Blob representation of the request body.    Body.formData()    Returns a promise that resolves with an FormData representation of the request body.    Body.json()    Returns a promise that resolves with an JSON representation of the request body.    Body.text()    Returns a promise that resolves with an USVString (text) representation of the request body.</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request" target="_blank" rel="external">MDN-Fetch-request</a><br>Response（构造器）<br>    相当于请求的响应。<br>    Response.type 只读<br>        包含Response的类型 (例如, basic, cors).<br>    Response.url 只读<br>        包含Response的URL.<br>    Response.useFinalURL<br>        包含了一个布尔值来标示这是否是该Response的最终URL.<br>    Response.status 只读<br>        包含Response的状态码 (例如, 200 成功).<br>    Response.ok 只读<br>        包含了一个布尔值来标示该Response成功(状态码200-299) 还是失败.<br>    Response.redirected 只读<br>        表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个<br>    Response.statusText 只读<br>        包含了与该Response状态码一致的状态信息 (例如, OK对应200).<br>    Response.headers 只读<br>        包含此Response所关联的Headers 对象.<br>    Response 实现了 Body, 所以以下属性同样可用:<br>    Body.bodyUsed 只读<br>     包含了一个布尔值来标示该Response是否读取过Body.<br>    Response.clone()<br>        创建一个Response对象的克隆<br>    Response.error()<br>        返回一个绑定了网络错误的新的Response对象<br>    Response.redirect()<br>        用另一个URL创建一个新的 response.<br>    Response 实现了 Body, 所以以下方法同样可用:<br>        Body.arrayBuffer()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为ArrayBuffer格式的promise对象<br>        Body.blob()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为Blob格式的promise对象<br>        Body.formData()<br>        读取Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为FormData格式的promise对象<br>        Body.json()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为JSON格式的promise对象<br>        Body.text()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为USVString格式的promise对象<br>        参数：<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myHeaders = new Headers();</div><div class="line">var myInit = &#123; method: &apos;GET&apos;,</div><div class="line">   headers: myHeaders,</div><div class="line">   mode: &apos;cors&apos;,</div><div class="line">   cache: &apos;default&apos; &#125;;</div><div class="line">fetch(&apos;flowers.jpg&apos;,myInit)</div></pre></td></tr></table></figure></p><pre><code>返回值：    Promise 对象    PS：就算是404也会返回promise resolved 还需要使用Response.ok 是不是为 true进一步判断。</code></pre><p>2.同步和异步<br>3.同源策略<br>    作用：同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>    定义：同domain（或ip）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。<br>    同源主要的限制：<br>        （1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>        （2） DOM和js对象无法获得。<br>        （3） AJAX 请求不能发送。<br>4.跟后端的数据交互的方式：JSON/XML，JS如何解析JSON为对象<br>    // json字符串<br>    var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’;<br>    // json对象<br>    var str2 = { “name”: “cxh”, “sex”: “man” };</p><pre><code>// JSON字符串转换为JSON对象方法一// var obj = eval(&apos;(&apos; + str1 + &apos;)&apos;);// JSON字符串转换为JSON对象方法二// var obj = JSON.parse(str1)// JSON对象转换为JSON字符串方法一JSON.stringify(str2)</code></pre><h4 id="对HTTP协议的理解"><a href="#对HTTP协议的理解" class="headerlink" title="对HTTP协议的理解"></a>对HTTP协议的理解</h4><p>1.常见的状态码<br>    200 OK<br>    301 Moved Permanently<br>    302 Found<br>    304 Not Modified<br>    307 Temporary Redirect<br>    400 Bad Request<br>    401 Unauthorized<br>    403 Forbidden<br>    404 Not Found<br>    410 Gone<br>    500 Internal Server Error<br>    501 Not Implemented<br>    <a href="https://fanerge.github.io/2017/11/05/%E5%89%8D%E7%AB%AF%E5%90%8C%E5%AD%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/">前端同学需要了解的通信知识</a><br>2.常见的HTTP请求和响应<br>    <a href="https://www.cnblogs.com/honghong87/articles/6941436.html" target="_blank" rel="external">参考博客</a><br>3.1同源策略限制了一下行为：<br>    1.Cookie、LocalStorage 和 IndexDB 无法读取<br>    2.DOM 和 JS 对象无法获取<br>    3.Ajax请求发送不出去<br>3.2解决跨域的方法<br>    window.name + iframe<br>    location.hash + iframe<br>    jsonp（jsonp的原理和优缺点）<br>        1.原理：动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本,通过这个特性(也可以说漏洞),服务器端不在返回json格式,而是返回一段调用某个函数的js代码（该页面中存在该函数），在src中进行了调用，这样实现了跨域。<br>        前面3中方式均只支持get方式<br>    document.domain + iframe（跨子域）<br>    HTML5中postMessage方案<br>        window.postMessage(msg,targetOrigin)<br>        window.addEventListener(‘message’,function(e) {}<br>    跨域资源共享 CORS<br>    WebSocket协议跨域<br>        后端主要配置，Access-Control-Allow-Origin<br>    node代理跨域<br>    nginx代理跨域<br>    详细请自行参考MDN相关文档<br>    <a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="external">正确面对跨域，别慌</a><br>4.JSONP请求如何取消？<br>    删除script标签（存在兼容性问题）<br>    将callback函数置为空函数<br>5.GET/POST方法的区别和使用场景<br>    get只应该用于获取数据，post用于提交数据（存在副作用）。<br>6.JavaScript模板引擎<br>    Template.js<br>    pug<br>    Mustache<br>    <a href="https://segmentfault.com/a/1190000000502743" target="_blank" rel="external">参考segmentfault</a><br>7.JavaScript设计模式<br>    <a href="https://fanerge.github.io/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">javascript设计模式</a></p><h3 id="Mobile-Web"><a href="#Mobile-Web" class="headerlink" title="Mobile Web"></a>Mobile Web</h3><p>重要概念<br>    设备像素：设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。<br>    CSS像素：这是一个抽象的像素概念，它是为web开发者创造的（是可以改变的，取决于用于是否缩放）。<br>    设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)<br>    最重要的两个视口，布局视口和理想<br>        布局视口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。<br>        理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：理想的布局视口。<br>        下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：<br>            <meta name="viewport" content="width=device-width"><br>屏幕适配 – 主要是屏幕分辨率、尺寸、屏幕方向这些因素。<br>    CSS3的媒体查询（media query）<br>    <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0&quot; /&gt;</code><br>        width=device-width - 布局视口等于理想视口<br>        device-width - 设备的宽度<br>        initial-scale - 初始的缩放比例<br>        minimum-scale - 允许用户缩放到的最小比例<br>        maximum-scale - 允许用户缩放到的最大比例<br>        user-scalable - 用户是否可以手动缩放<br>    <code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot; &gt;</code><br>    //禁止自动识别电话号码和邮箱<br>    <code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; &gt;</code><br>    //苹果手机：会删除默认的工具栏和菜单栏，网站开启对web app程序的支持<br>    <code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</code><br>    //苹果手机：在web app应用下状态条（屏幕顶部条）的颜色,默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。<br>    <code>&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;</code><br>    //苹果手机：如果把一个web app添加到了主屏幕中，那么从主屏幕中打开这个web app则全屏显示<br>    <code>&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/static/images/identity/HTML5_Badge_64.png&quot; /&gt;</code><br>    //苹果手机：将应用添加到手机主屏幕，会有一个icon可以直接进入<br>重置部分css<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line"> font: 16px/1.5 Helvetica, Arial;</div><div class="line">//这里是设置字体，Helvetica字体在移动端各系统都支持（都不支持微软雅黑）</div><div class="line">-webkit-text-size-adjust: none; </div><div class="line">//设置文本不会放大，普通网页在移动端打开文本是会跟随网页结构缩放的</div><div class="line">&#125;</div><div class="line">* &#123;</div><div class="line">-webkit-tap-highlight-color: transparent;</div><div class="line">//在一些手机上，如iphone，点击按钮等元素会出现点击态的背景色，设置为透明就看不出来了</div><div class="line">-webkit-user-select:none;</div><div class="line">//设置元素内的文字及其子元素将不会被选中</div><div class="line">&#125;</div><div class="line">// 去除webkit的滚动条</div><div class="line">::-webkit-scrollbar&#123;</div><div class="line">   display: none;</div><div class="line">&#125;</div><div class="line">div &#123;</div><div class="line">-webkit-overflow-scrolling : touch;</div><div class="line">&#125;</div><div class="line">// 去除button在ios上的默认样式</div><div class="line">button &#123;</div><div class="line">-webkit-appearance: none;</div><div class="line">border-radius: 0;</div><div class="line">&#125;</div><div class="line">// placeholder元素样式的修改</div><div class="line">input::-webkit-input-placeholder&#123;color:red;&#125;</div><div class="line">input:focus::-webkit-input-placeholder&#123;color:green;&#125;</div><div class="line">// 使用css3的transition、transform（translate、scale、rotate、skew）、或者animation来进行动画或过度。</div><div class="line">// 使用图片时，会发现图片下总是有大概4px的空白</div><div class="line">img&#123;display:block&#125;；</div><div class="line">img&#123;vertical-align:top&#125;</div></pre></td></tr></table></figure></p><p>事件<br>    touchstart：当手指放在屏幕上触发;<br>    touchmove：当手指在屏幕上滑动时，连续地触发;<br>    touchend：当手指从屏幕上离开时触发;<br>    touchcancel： 当系统停止跟踪时触发;<br>        event.touches.length // 当前几个手指在触屏上</p><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>1.对AMD、CMD（node.js）、UMD等规范的了解，以及ES6中关于模块的标准定义<br>2.使用过常用的模块化框架：Requirejs、Seajs等<br>3.使用模块化的方式，能够解决什么问题？<br>    命名空间冲突（全局变量覆盖）<br>    文件依赖管理<br>    立即执行函数 + 闭包(实现模块的基本方法)<br>4.动态加载JavaScript有几种方式？<br>    1.使用document.write/writeln(）方式<br>        document.writeln(“<script src="\"http://lib.sinaapp.com/js/jquery/1.6/jquery.min.js\""></script>“);<br>    2.使用jquery getScript(url,callback)方法实现动态加载js文件<br>        $.getScript(‘test.js’,function(){<br>            // TODO…<br>        });<br>    3.动态改变已有script的src属性<br>    4.使用原生js 动态创建script标签，并指定script的src属性<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function loadJs(url,callback)&#123;</div><div class="line">var script=document.createElement(&apos;script&apos;);</div><div class="line"></div><div class="line">script.type=&quot;text/javascript&quot;;</div><div class="line">if(typeof(callback)!=&quot;undefined&quot;)&#123;</div><div class="line">if(script.readyState)&#123;</div><div class="line">script.onreadystatechange=function()&#123;</div><div class="line"></div><div class="line">if(script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</div><div class="line">script.onreadystatechange=null;</div><div class="line">callback();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line">script.onload=function()&#123;</div><div class="line">callback();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">script.src=url;</div><div class="line">document.body.appendChild(script);</div><div class="line">&#125;</div><div class="line">loadJs(&quot;test.js&quot;,function()&#123;</div><div class="line">// todo...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><pre><code>5.用XHR取得要脚本的内容，再创建 Script 对象。6.如何判断动态脚本是否加载完成    为scriptdom节点添加监听事件 onload 和 onreadystatechange    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scriptDom.onload = scriptDom.onreadystatechange = function()&#123;  </div><div class="line">// 这里处理了兼容性，不同浏览器 readyState 的值不一样</div><div class="line">   if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;)&#123;  </div><div class="line">   // todo...</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>5.动态加载CSS方法<br>    1.导入css文件<br>        @import url(style.css);<br>    2.简单的在页面中加载一个外部CSS文件<br>        document.createStyleSheet(cssFile);<br>    3.用createElement方法创建CSS的Link标签<br>7.分析依赖的方式<br>    动态分析，也是运行时分析<br>    本地编译分析出依赖链<br>8.如何做好模块加载的性能优化    </p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><pre><code>参见阮一峰教程</code></pre><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>Angularjs<br>React （重点）<br>Babkbone<br>Vuejs （重点）    </p><h4 id="前端安全（XSS、CSRF等，攻击和防范方案）"><a href="#前端安全（XSS、CSRF等，攻击和防范方案）" class="headerlink" title="前端安全（XSS、CSRF等，攻击和防范方案）"></a>前端安全（XSS、CSRF等，攻击和防范方案）</h4><p>在项目中有遇到过前端方面的安全问题吗？<br>什么是XSS、CSRF？<br>常见的漏洞场景有哪些？<br>如何防范XSS、CSRF<br>网站登陆都加验证码是为了解决哪方面的安全问题？有没有更好的方案？    </p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>1.请减少HTTP请求（代理模式合并http请求）<br>    合并图片（css sprites），合并CSS和JS文件；图片较多的页面也可以使用 lazyLoad 等技术进行优化。<br>2.请正确理解 Repaint重绘 和 Reflow重排<br>3.减少DOM操作（缓存dom节点）<br>    对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。<br>4.尽量使用json数据与后端交互而不是xml<br>5.高效使用HTML标签和CSS样式    （语义化利于seo）<br>6.使用CDN加速（内容分发网络）<br>7.将CSS和JS放到外部文件中引用，CSS放头，JS放尾<br>8.精简CSS和JS文件（压缩）<br>9.压缩图片和使用图片Sprite技术<br>10.注意控制Cookie大小和污染（使用storage代替）<br>    cookie会在每次http请求自动添加，有点浪费<br>11.按需加载资源<br>12.缓存（主要是http头部字段和service workers）    </p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>1.有哪几种浏览器内核<br>    Trident – ie4-ie8<br>    Gecko   – 网景-firefox<br>    Presto  – Opera（Opera现已改用Google Chrome的Blink内核）<br>    Webkit  – Chrome、Safari<br>2.排版引擎<br>    KHTML<br>    WebCore<br>3.浏览器兼容性<br>    css前缀<br>    js自带方法的适配<br>    对各种资源的支持webP图片格式<br>4.浏览器渲染页面的原理（不同浏览器不一样）<br>    DOM Tree：浏览器将HTML解析成树形的数据结构。<br>    CSS Rule Tree：浏览器将CSS解析成树形的数据结构。<br>    Render Tree: DOM和CSSOM合并后生成Render Tree。<br>    layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br>    painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。<br>    reflow（重排）和repaint（重绘）<br>    <a href="https://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="external">参考</a><br>5.浏览器检测和识别<br>    根据浏览器特性来判断<br>    根据UA来检测 – navigator.userAgent 字符串比较</p><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>1.框架的设计方案</p><p>2.解决哪些问题    </p><h4 id="前端架构设计"><a href="#前端架构设计" class="headerlink" title="前端架构设计"></a>前端架构设计</h4><p>前端架构是一系列工具和流程的集合，旨在提升前端代码质量，并实现高效、可持续的工作流。<br>1.前端架构四个核心：<br>    ● 代码——如何实现系统架构中的HTML、CSS和JavaScript<br>    ● 流程——构建高效并且防止出错的工作流所需要的工具和流程<br>    ● 测试——为网站搭建稳固基础<br>    ● 文档——规划好系统设计蓝图<br>2.前端架构师职责：<br>    ● 体系设计——清晰描绘产品和代码的最终形态<br>    ● 工作规划——制定完整开发工作流<br>    ● 监督跟进——保证项目高效率完成    </p><h4 id="跨终端开发"><a href="#跨终端开发" class="headerlink" title="跨终端开发"></a>跨终端开发</h4><p>1.响应性设计（Mobile web），Media Queries<br>    栅格系统（bootstrap）具体实现float + width百分比 + @media query<br>    松软盒子flex 具体实现flex布局 + width百分比 + @media query<br>2.Hybird APP（PhoneGap、AppCan、Titanium等）大致的原理，以及解决的问题<br>    Web App、Hybrid App、 Native App<br>    原理：通过JSBridge,web页面可以调用Native的api,Native也可调用web页面的api或者通知H5页面回调。<br>3.React Native 和 weex<br>4.重构<br>    主要考虑（性能优化和扩展性）<br>    <a href="https://www.cnblogs.com/depsi/p/5063965.html" target="_blank" rel="external">性能优化</a><br>5.前端工程化<br>    借助Node.js的功能（读写文件、搭建服务器、读写数据库等等）帮我们完成如图片、代码压缩、代码检测等事情。<br>    模块化与组件化: npm, es6, react/angularjs<br>    代码版本管理: git<br>    代码风格管理: jscs, editorconfig<br>    代码编译: babel, scss, imgmin, csssprit, inline-svg<br>    代码质量管理 (QA): eslint, mocha<br>    代码构建: webpack<br>    项目脚手架: yeoman<br>    持续集成/持续交付/持续部署: jenkins<br>    本地化与国际化<br>6.系统架构/设计</p><h1 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h1><ol><li>描述一个你遇到过的技术问题，你是如何解决的？        </li><li><p>是否有设计过通用的组件？<br>请设计一个 Dialog（弹出层）等组件<br>你会提供什么接口？<br>调用过程是怎样的？可能会遇到什么细节问题？<br>API<br>  visible – 对话框是否可见<br>  title – 标题<br>  closable – 是否显示右上角的关闭按钮<br>  mask – 是否展示遮罩<br>  maskClosable – 点击蒙层是否允许关闭<br>  maskStyle – 遮罩样式<br>  bodyStyle – Dialog body 样式<br>  footer – 底部内容，当不需要默认底部按钮时，可以设为 footer={null}<br>  cancelText – 取消按钮文字<br>  okText – 确认按钮文字<br>  onCancel – 点击遮罩层或右上角叉或取消按钮的回调<br>  onOk – 点击确定回调<br>  zIndex    设置 Modal 的 z-index（特殊情况使用）</p></li><li><p>请描述一下你做过的哪个前端方面的功能让你特别有成就感    </p></li><li>在制作一个Web应用或Web站点的过程中，你是如何考虑它的UI、安全性、高性能、SEO、可维护性以及技术因素的？        </li><li>说说最近最流行的一些东西吧？常去哪些网站？        </li></ol><h1 id="潜力（加分项）"><a href="#潜力（加分项）" class="headerlink" title="潜力（加分项）"></a>潜力（加分项）</h1><ol><li>熟悉一门非前端语言，并且有项目开发经验，包括且不限于C/C++/Python/PHP/Java/Ruby等</li><li>在Native开发上有相关的经验（iOS、Android）等</li><li>有自己的独立博客并且有自己的思考和总结性质的文章、github有自己维护的仓库并且活跃（即开源项目）</li><li>对技术的追求有热情，特别对新技术的敏感性，能够积极主动学习新技术，并且能够有实践性的应用，比如：HTML5、Nodejs、MVVM、Promise、React、React Native、Angular等等</li><li>有较好的产品意识，并且有积极推动业务进步并拿到结果的案例</li><li>主动性、逻辑性、沟通、协同等方面的软实力良好</li><li>项目管理PM角色的经历（团队合作、沟通、协调能力）    </li></ol><h1 id="你对break和continue的理解"><a href="#你对break和continue的理解" class="headerlink" title="你对break和continue的理解"></a>你对break和continue的理解</h1><p>break 关键字<br>    break 主要用在循环语句或者 switch 语句中。<br>    break 在循环语句中作用是跳出本层（并非本次）的循环。<br>    break 在switch语句中作用是跳出该switch语句体。<br>continue 关键字<br>    continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。<br>    在 for 循环中，continue 语句使程序立即跳转到更新语句i++。<br>    在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技术基础&quot;&gt;&lt;a href=&quot;#技术基础&quot; class=&quot;headerlink&quot; title=&quot;技术基础&quot;&gt;&lt;/a&gt;技术基础&lt;/h1&gt;&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fanerge.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://fanerge.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html"/>
    <id>https://fanerge.github.io/移动端适配.html</id>
    <published>2017-12-22T13:17:45.000Z</published>
    <updated>2017-12-22T14:23:16.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单webApp的处理方案"><a href="#简单webApp的处理方案" class="headerlink" title="简单webApp的处理方案"></a>简单webApp的处理方案</h1><p>这种app是一种典型的弹性布局：关键元素高宽和位置都不变，只有容器元素在做伸缩变换。对于这类app，记住一个开发原则就好：文字流式，控件弹性，图片等比缩放。</p><h1 id="网易的做法（以设计稿为640的计算，还有750等等）"><a href="#网易的做法（以设计稿为640的计算，还有750等等）" class="headerlink" title="网易的做法（以设计稿为640的计算，还有750等等）"></a>网易的做法（以设计稿为640的计算，还有750等等）</h1><p>（1）先拿设计稿竖着的横向分辨率除以100得到body元素的宽度<br>    如果设计稿基于iphone4/5，横向分辨率为640，body的width为640 / 100 = 6.4rem<br>（2）布局时，设计图标注的尺寸除以100得到css中的尺寸<br>    播放器高度为210px，写样式的时候css应该这么写：height: 2.1rem。之所以取一个100作为参照，就是为了这里计算rem的方便！<br>（3）在dom ready以后，通过以下代码设置html的font-size。<br>    document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + ‘px’;<br>    这里的目的是保证，1rem等于100px，方便后面计算<br>（4）font-size可能需要额外的媒介查询，并且font-size不能使用rem<br>    @media screen and (max-width:321px){<br>        .m-navlist{font-size:15px}<br>    }<br>    @media screen and (min-width:321px) and (max-width:400px){<br>        .m-navlist{font-size:16px}<br>    }<br>PS：第一，需要设置视口<br>        <meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"><br>    第二，当deviceWidth大于设计稿的横向分辨率时，html的font-size始终等于横向分辨率/body元素宽<br>        var deviceWidth = document.documentElement.clientWidth;<br>        if(deviceWidth &gt; 640) deviceWidth = 640;<br>        document.documentElement.style.fontSize = deviceWidth / 6.4 + ‘px’;<br>    第三，当物理分辨率大于1280时，应该去访问PC网站了。</p><h1 id="淘宝的做法"><a href="#淘宝的做法" class="headerlink" title="淘宝的做法"></a>淘宝的做法</h1><p>（1）动态设置viewport的scale<br>    var scale = 1 / devicePixelRatio;<br>    document.querySelector(‘meta[name=”viewport”]’).setAttribute(‘content’,’initial-scale=’ + scale + ‘, maximum-scale=’ + scale + ‘, minimum-scale=’ + scale + ‘, user-scalable=no’);<br>（2）动态计算html的font-size<br>    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + ‘px’;<br>（3）布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10<br>（4）font-size可能需要额外的媒介查询，并且font-size不使用rem，这一点跟网易是一样的。<br>PS：第一，当设备竖着时横向物理分辨率大于1080时，应该去访问PC网站了。</p><h1 id="淘宝开源的布局库"><a href="#淘宝开源的布局库" class="headerlink" title="淘宝开源的布局库"></a>淘宝开源的布局库</h1><p><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">lib-flexible</a><br><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="external">详细介绍</a></p><p><a href="http://www.cnblogs.com/lyzg/p/4877277.html" target="_blank" rel="external">整理于互联网</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单webApp的处理方案&quot;&gt;&lt;a href=&quot;#简单webApp的处理方案&quot; class=&quot;headerlink&quot; title=&quot;简单webApp的处理方案&quot;&gt;&lt;/a&gt;简单webApp的处理方案&lt;/h1&gt;&lt;p&gt;这种app是一种典型的弹性布局：关键元素高宽和位置都
      
    
    </summary>
    
      <category term="移动端" scheme="https://fanerge.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端, 布局" scheme="https://fanerge.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
</feed>
