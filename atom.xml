<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-09-14T13:44:47.901Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql函数学习</title>
    <link href="https://fanerge.github.io/2017/09/14/sql%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/14/sql函数学习/</id>
    <published>2017-09-14T12:07:14.000Z</published>
    <updated>2017-09-14T13:44:47.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h3><pre><code>SQL 拥有很多可用于计数和计算的内建函数。
</code></pre><h4 id="SQL-Aggregate-函数"><a href="#SQL-Aggregate-函数" class="headerlink" title="SQL Aggregate 函数"></a>SQL Aggregate 函数</h4><pre><code>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。
AVG() - 返回平均值
COUNT() - 返回行数
FIRST() - 返回第一个记录的值
LAST() - 返回最后一个记录的值
MAX() - 返回最大值
MIN() - 返回最小值
SUM() - 返回总和
</code></pre><h4 id="SQL-Scalar-函数"><a href="#SQL-Scalar-函数" class="headerlink" title="SQL Scalar 函数"></a>SQL Scalar 函数</h4><pre><code>SQL Scalar 函数基于输入值，返回一个单一的值。
UCASE() - 将某个字段转换为大写
LCASE() - 将某个字段转换为小写
MID() - 从某个文本字段提取字符，MySql 中使用
SubString(字段，1，end) - 从某个文本字段提取字符
LEN() - 返回某个文本字段的长度
ROUND() - 对某个数值字段进行指定小数位数的四舍五入
NOW() - 返回当前的系统日期和时间
FORMAT() - 格式化某个字段的显示方式
</code></pre><h4 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h4><pre><code>一下实例中均使用数据库sql，表名为access_log
AVG() 函数返回数值列的平均值。
语法：SELECT AVG(column_name) FROM table_name;
1.返回count的平均值
    SELECT AVG(count) FROM access_log
2.返回大于count平均数的元组
    SELECT site_id, count FROM access_log
    WHERE count &gt; (SELECT AVG(count) FROM access_log);
</code></pre><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h4><pre><code>COUNT() 函数返回匹配指定条件的行数（NULL 不计入）。
语法：SELECT COUNT(column_name) FROM table_name; // COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）
    SELECT COUNT(DISTINCT column_name) FROM table_name; // COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目
1.返回表中记录数
    SELECT COUNT(*) FROM access_log
2.返回site_id = 3的记录拥有count的数量，并改名为nums
    SELECT COUNT(count) AS nums FROM access_log WHERE site_id = 3
3.计算 &quot;access_log&quot; 表中不同 site_id 的记录数
    SELECT COUNT(DISTINCT site_id) AS nums FROM access_log
</code></pre><h4 id="SQL-FIRST-函数"><a href="#SQL-FIRST-函数" class="headerlink" title="SQL FIRST() 函数"></a>SQL FIRST() 函数</h4><pre><code>FIRST() 函数返回指定的列中第一个记录的值。
注释：只有 MS Access 支持 FIRST() 函数。
语法：SELECT FIRST(column_name) FROM table_name;
MySQL 语法：
    SELECT column_name FROM table_name
    ORDER BY column_name ASC
    LIMIT 1;
1.mysql中获取第一条记录
    SELECT count FROM access_log ORDER BY count ASC LIMIT 1;
</code></pre><h4 id="SQL-LAST-函数"><a href="#SQL-LAST-函数" class="headerlink" title="SQL LAST() 函数"></a>SQL LAST() 函数</h4><pre><code>LAST() 函数返回指定的列中最后一个记录的值。
注释：只有 MS Access 支持 LAST() 函数。
语法：SELECT LAST(column_name) FROM table_name;
MySQL 语法：
    SELECT * FROM table_name 
    ORDER BY column_name ASC
    LIMIT 1;
1.mysql中获取最后一条记录
SELECT * FROM access_log ORDER BY count DESC LIMIT 1;
</code></pre><h4 id="SQL-MAX-函数"><a href="#SQL-MAX-函数" class="headerlink" title="SQL MAX() 函数"></a>SQL MAX() 函数</h4><pre><code>MAX() 函数返回指定列的最大值。
语法：SELECT MAX(column_name) FROM table_name;
1.返回count最大的一条记录
    SELECT * FROM access_log WHERE count = (SELECT MAX(count) FROM access_log)
</code></pre><h4 id="SQL-MIN-函数"><a href="#SQL-MIN-函数" class="headerlink" title="SQL MIN() 函数"></a>SQL MIN() 函数</h4><pre><code>MIN() 函数返回指定列的最小值。
语法：SELECT column_name FROM table_name;
1.返回count最小的一条记录中的aid 和 count字段
    SELECT aid, count FROM access_log WHERE count = (SELECT MIN(count) FROM access_log)
</code></pre><h4 id="SQL-SUM-函数"><a href="#SQL-SUM-函数" class="headerlink" title="SQL SUM() 函数"></a>SQL SUM() 函数</h4><pre><code>SUM() 函数返回数值列的总数。
语法：SELECT column_name FROM table_name;
1.返回count 的总和
    SELECT SUM(count) FROM access_log    
</code></pre><h4 id="SQL-GROUP-BY-语句"><a href="#SQL-GROUP-BY-语句" class="headerlink" title="SQL GROUP BY 语句"></a>SQL GROUP BY 语句</h4><pre><code>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。
语法：
    SELECT column_name, aggregate_function(column_name)
    FROM table_name
    WHERE column_name operator value
    GROUP BY column_name;
1.返回通过site_id分组对count求和
    SELECT site_id, SUM(access_log.count) AS nums 
    FROM access_log GROUP BY site_id
2.统计所有网站的访问的记录数（LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。）
SELECT websites.name, COUNT(access_log.aid) AS nums 
FROM access_log LEFT JOIN websites ON access_log.site_id = websites.id 
GROUP BY websites.name
</code></pre><h4 id="SQL-HAVING-子句"><a href="#SQL-HAVING-子句" class="headerlink" title="SQL HAVING 子句"></a>SQL HAVING 子句</h4><pre><code>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。
HAVING 子句可以让我们筛选分组后的各组数据。
1.现在我们想要查找总访问量大于 200 的网站
SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log
INNER JOIN Websites
ON access_log.site_id=Websites.id)
GROUP BY Websites.name
HAVING SUM(access_log.count) &gt; 200;
</code></pre><h4 id="SQL-UCASE-函数"><a href="#SQL-UCASE-函数" class="headerlink" title="SQL UCASE() 函数"></a>SQL UCASE() 函数</h4><pre><code>UCASE() 函数把字段的值转换为大写。
语法：SELECT UCASE(column_name) FROM table_name;
1.将某个列转化为大写
    SELECT UCASE(websites.url) AS url3 FROM websites
</code></pre><h4 id="SQL-LCASE-函数"><a href="#SQL-LCASE-函数" class="headerlink" title="SQL LCASE() 函数"></a>SQL LCASE() 函数</h4><pre><code>LCASE() 函数把字段的值转换为大写。
语法：SELECT LCASE(column_name) FROM table_name;
1.将某个列转化为小写
    SELECT LCASE(country) FROM websites
</code></pre><h4 id="SQL-MID-函数"><a href="#SQL-MID-函数" class="headerlink" title="SQL MID() 函数"></a>SQL MID() 函数</h4><pre><code>MID() 函数用于从文本字段中提取字符。
语法：SELECT MID(column_name, start [,length]) FROM table_name;
1.获取网站地址
    SELECT MID(websites.url, 4) FROM websites
</code></pre><h4 id="SQL-LEN-函数"><a href="#SQL-LEN-函数" class="headerlink" title="SQL LEN() 函数"></a>SQL LEN() 函数</h4><pre><code>LEN() 函数返回文本字段中值的长度。
语法：SELECT LEN(column_name) FROM table_name;
MySQL中函数为 LENGTH()
    SELECT LENGTH(column_name) FROM table_name;
1.获取网址长度
    SELECT LENGTH(websites.url) FROM websites;
</code></pre><h4 id="SQL-ROUND-函数"><a href="#SQL-ROUND-函数" class="headerlink" title="SQL ROUND() 函数"></a>SQL ROUND() 函数</h4><pre><code>ROUND() 函数用于把数值字段舍入为指定的小数位数。
语法：SELECT ROUND(column_name, decimals) FROM table_name;
1.对url四舍五入处理
    SELECT ROUND(url) FROM websites WHERE id=7;
</code></pre><h4 id="SQL-NOW-函数"><a href="#SQL-NOW-函数" class="headerlink" title="SQL NOW() 函数"></a>SQL NOW() 函数</h4><pre><code>NOW() 函数返回当前系统的日期和时间。
语法：SELECT NOW() FROM websites
</code></pre><h4 id="SQL-FORMAT-函数"><a href="#SQL-FORMAT-函数" class="headerlink" title="SQL FORMAT() 函数"></a>SQL FORMAT() 函数</h4><pre><code>FORMAT() 函数用于对字段的显示进行格式化。
语法：SELECT FORMAT(column_name, format) FROM table_name;
1.格式化日期
    SELECT name, url, DATE_FORMAT(Now(), &apos;%Y-%m-%d&apos;) AS date FROM websites
</code></pre><h4 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h4><pre><code>[SQL参考手册](http://www.runoob.com/sql/sql-quickref.html)
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/sql/sql-hosting.html" target="_blank" rel="external">SQL</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL-函数&quot;&gt;&lt;a href=&quot;#SQL-函数&quot; class=&quot;headerlink&quot; title=&quot;SQL 函数&quot;&gt;&lt;/a&gt;SQL 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;SQL 拥有很多可用于计数和计算的内建函数。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;SQ
    
    </summary>
    
      <category term="sql" scheme="https://fanerge.github.io/categories/sql/"/>
    
    
      <category term="数据库" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习（下部分）</title>
    <link href="https://fanerge.github.io/2017/09/14/mysql%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/14/mysql学习/</id>
    <published>2017-09-14T11:54:37.000Z</published>
    <updated>2017-09-14T12:12:39.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h3><pre><code>MySQL 事务主要用于处理操作量大，复杂度高的数据。
在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息。
事务用来管理 insert,update,delete 语句。
事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）。
</code></pre><h4 id="事物控制语句"><a href="#事物控制语句" class="headerlink" title="事物控制语句"></a>事物控制语句</h4><pre><code>BEGIN或START TRANSACTION；显式地开启一个事务；
COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；
ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；
RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
ROLLBACK TO identifier；把事务回滚到标记点；
SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。
</code></pre><h4 id="MYSQL-事务处理主要有两种方法"><a href="#MYSQL-事务处理主要有两种方法" class="headerlink" title="MYSQL 事务处理主要有两种方法"></a>MYSQL 事务处理主要有两种方法</h4><pre><code>1、用 BEGIN, ROLLBACK, COMMIT来实现
    BEGIN 开始一个事务
    ROLLBACK 事务回滚
    COMMIT 事务确认
2、直接用 SET 来改变 MySQL 的自动提交模式:
    SET AUTOCOMMIT=0 禁止自动提交
    SET AUTOCOMMIT=1 开启自动提交
</code></pre><h4 id="事务测试"><a href="#事务测试" class="headerlink" title="事务测试"></a>事务测试</h4><pre><code>CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表
mysql&gt; select * from runoob_transaction_test; 
mysql&gt; begin;  # 开始事务
mysql&gt; insert into runoob_transaction_test value(5); 
mysql&gt; insert into runoob_transaction_test value(6); 
mysql&gt; commit; # 提交事务 
mysql&gt;  select * from runoob_transaction_test;
+------+
| id   |
+------+
| 5    |
| 6    |
+------+ 
mysql&gt; begin;    # 开始事务
mysql&gt;  insert into runoob_transaction_test values(7);
mysql&gt; rollback;   # 回滚
mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入
</code></pre><h3 id="MySQL-ALTER命令"><a href="#MySQL-ALTER命令" class="headerlink" title="MySQL ALTER命令"></a>MySQL ALTER命令</h3><pre><code>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。
</code></pre><h4 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h4><pre><code>// 删除一列（不能是最后一列）
ALTER TABLE table_name DROP column_name;
// 添加一列
ALTER TABLE table_name ADD column_name INT;
// 查看列数据类型
SHOW COLUMNS FROM table_name;
// MySQL提供的关键字 FIRST (设定位第一列)
ALTER TABLE table_name ADD column_name INT FIRST;
// AFTER 字段名（设定位于某个字段之后）
ALTER TABLE table_name ADD column_name INT AFTER c;
</code></pre><h4 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h4><pre><code>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。    
// 更改列的类型
ALTER TABLE table_name MODIFY column_name CHAR(10);
ALTER TABLE table_name CHANGE i j INT;
</code></pre><h4 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h4><pre><code>// 指定字段 column_name 为 NOT NULL 且默认值为100 。
ALTER TABLE table_name MODIFY column_name BIGINT NOT NULL DEFAULT 100;    
</code></pre><h4 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h4><pre><code>// ALTER 来修改字段的默认值
ALTER TABLE table_name ALTER column_name SET DEFAULT 1000;
// ALTER 命令及 DROP子句来删除字段的默认值
ALTER TABLE table_name ALTER column_name DROP DEFAULT;
</code></pre><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><pre><code>ALTER TABLE table_name RENAME TO table_name1;
</code></pre><h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><pre><code>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。
索引分单列索引和组合索引。
单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
组合索引，即一个索引包含多个列。
实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。
</code></pre><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><pre><code>CREATE INDEX indexName ON mytable(username(length)); 
// 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。
</code></pre><h5 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h5><pre><code>ALTER table tableName ADD INDEX indexName(columnName)
</code></pre><h5 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h5><pre><code>CREATE TABLE mytable(  
    ID INT NOT NULL,   
    username VARCHAR(16) NOT NULL,  
    INDEX [indexName] (username(length))  
);  
</code></pre><h5 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h5><pre><code>DROP INDEX [indexName] ON mytable;
</code></pre><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><pre><code>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
</code></pre><h5 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h5><pre><code>CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
</code></pre><h5 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h5><pre><code>ALTER table mytable ADD UNIQUE [indexName] (username(length))
</code></pre><h5 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h5><pre><code>CREATE TABLE mytable(  
    ID INT NOT NULL,   
    username VARCHAR(16) NOT NULL,  
    UNIQUE [indexName] (username(length))  
); 
</code></pre><h4 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h4><pre><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。
// 为在表中添加索引。
ALTER TABLE testalter_tbl ADD INDEX (c);
// 可以在 ALTER 命令中使用 DROP 子句来删除索引。
ALTER TABLE testalter_tbl DROP INDEX c;
</code></pre><h4 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h4><pre><code>// 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。
ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
// 使用 ALTER 命令删除主键，删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。
ALTER TABLE testalter_tbl DROP PRIMARY KEY;
</code></pre><h4 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h4><pre><code>// 使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。
SHOW INDEX FROM table_name; \G
</code></pre><h3 id="MySQL-临时表"><a href="#MySQL-临时表" class="headerlink" title="MySQL 临时表"></a>MySQL 临时表</h3><pre><code>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。
// 创建临时表
CREATE TEMPORARY TABLE SalesSummary (
    product_name VARCHAR(50) NOT NULL, 
    total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00, 
    avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00, 
    total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
// 临时表插入数据
INSERT INTO SalesSummary
(product_name, total_sales, avg_unit_price, total_units_sold)
VALUES
(&apos;cucumber&apos;, 100.25, 90, 2);
</code></pre><h4 id="删除MySQL-临时表"><a href="#删除MySQL-临时表" class="headerlink" title="删除MySQL 临时表"></a>删除MySQL 临时表</h4><pre><code>DROP TABLE SalesSummary;
</code></pre><h3 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h3><pre><code>使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。
复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。
如果你想复制表的内容，你就可以使用 INSERT INTO ... SELECT 语句来实现。
</code></pre><h3 id="MySQL-元数据"><a href="#MySQL-元数据" class="headerlink" title="MySQL 元数据"></a>MySQL 元数据</h3><pre><code>查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数。
数据库和数据表的信息： 包含了数据库及数据表的结构信息。
MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。
</code></pre><h4 id="获取服务器元数据"><a href="#获取服务器元数据" class="headerlink" title="获取服务器元数据"></a>获取服务器元数据</h4><pre><code>SELECT VERSION( )    服务器版本信息
SELECT DATABASE( )    当前数据库名 (或者返回空)
SELECT USER( )    当前用户名
SHOW STATUS    服务器状态
SHOW VARIABLES    服务器配置变量
</code></pre><h3 id="MySQL-序列使用"><a href="#MySQL-序列使用" class="headerlink" title="MySQL 序列使用"></a>MySQL 序列使用</h3><pre><code>MySQL序列是一组整数：1, 2, 3, ...，由于一张数据表只能有一个字段自增主键， 
如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。
</code></pre><h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h4><pre><code>CREATE TABLE insect
    (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (id),
    name VARCHAR(30) NOT NULL, # type of insect
    date DATE NOT NULL, # date collected
    origin VARCHAR(30) NOT NULL # where collected
    );
INSERT INTO insect (id,name,date,origin) VALUES
    (NULL,&apos;housefly&apos;,&apos;2001-09-10&apos;,&apos;kitchen&apos;),
    (NULL,&apos;millipede&apos;,&apos;2001-09-10&apos;,&apos;driveway&apos;),
    (NULL,&apos;grasshopper&apos;,&apos;2001-09-10&apos;,&apos;front yard&apos;);
</code></pre><h4 id="获取AUTO-INCREMENT值"><a href="#获取AUTO-INCREMENT值" class="headerlink" title="获取AUTO_INCREMENT值"></a>获取AUTO_INCREMENT值</h4><pre><code>在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。
</code></pre><h4 id="重置序列"><a href="#重置序列" class="headerlink" title="重置序列"></a>重置序列</h4><pre><code>如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。
ALTER TABLE insect DROP id;
ALTER TABLE insect
ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,
ADD PRIMARY KEY (id);
</code></pre><h4 id="设置序列的开始值"><a href="#设置序列的开始值" class="headerlink" title="设置序列的开始值"></a>设置序列的开始值</h4><pre><code>一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现
CREATE TABLE insect
    (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (id),
    name VARCHAR(30) NOT NULL, 
    date DATE NOT NULL,
    origin VARCHAR(30) NOT NULL
)engine=innodb auto_increment=100 charset=utf8;
</code></pre><h3 id="MySQL-处理重复数据"><a href="#MySQL-处理重复数据" class="headerlink" title="MySQL 处理重复数据"></a>MySQL 处理重复数据</h3><h4 id="防止表中出现重复数据"><a href="#防止表中出现重复数据" class="headerlink" title="防止表中出现重复数据"></a>防止表中出现重复数据</h4><pre><code>你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。
1.如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE person_tbl</div><div class="line">(</div><div class="line">   first_name CHAR(20) NOT NULL,</div><div class="line">   last_name CHAR(20) NOT NULL,</div><div class="line">   sex CHAR(10),</div><div class="line">   PRIMARY KEY (last_name, first_name)</div><div class="line">);</div></pre></td></tr></table></figure>

2.INSERT IGNORE INTO会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT IGNORE INTO person_tbl (last_name, first_name)</div><div class="line">   VALUES( &apos;Jay&apos;, &apos;Thomas&apos;);</div></pre></td></tr></table></figure>

3.另一种设置数据的唯一性方法是添加一个UNIQUE索引。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE person_tbl</div><div class="line">(</div><div class="line">   first_name CHAR(20) NOT NULL,</div><div class="line">   last_name CHAR(20) NOT NULL,</div><div class="line">   sex CHAR(10)</div><div class="line">   UNIQUE (last_name, first_name)</div><div class="line">);</div></pre></td></tr></table></figure>
</code></pre><h4 id="统计重复数据"><a href="#统计重复数据" class="headerlink" title="统计重复数据"></a>统计重复数据</h4><pre><code>以下我们将统计表中 first_name 和 last_name的重复记录数
SELECT COUNT(*) as repetitions, last_name, first_name
FROM person_tbl
GROUP BY last_name, first_name
HAVING repetitions &gt; 1;
确定哪一列包含的值可能会重复。
在列选择列表使用COUNT(*)列出的那些列。
在GROUP BY子句中列出的列。
HAVING子句设置重复数大于1。
</code></pre><h4 id="过滤重复数据"><a href="#过滤重复数据" class="headerlink" title="过滤重复数据"></a>过滤重复数据</h4><pre><code>1.你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。
    SELECT DISTINCT last_name, first_name FROM person_tbl;
2.使用 GROUP BY 来读取数据表中不重复的数据。
    SELECT last_name, first_name
    FROM person_tbl
    GROUP BY (last_name, first_name);
</code></pre><h4 id="删除重复数据"><a href="#删除重复数据" class="headerlink" title="删除重复数据"></a>删除重复数据</h4><pre><code>1.删除person_tbl表中的重复数据
CREATE TABLE tmp SELECT last_name, first_name, sex
FROM person_tbl;
GROUP BY (last_name, first_name, sex);
DROP TABLE person_tbl;
ALTER TABLE tmp RENAME TO person_tbl;
2.可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。
ALTER IGNORE TABLE person_tbl
ADD PRIMARY KEY (last_name, first_name);
</code></pre><h3 id="MySQL-及-SQL-注入"><a href="#MySQL-及-SQL-注入" class="headerlink" title="MySQL 及 SQL 注入"></a>MySQL 及 SQL 注入</h3><pre><code>如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。    
我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。
// 过滤用户的输入
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (preg_match(&quot;/^\w&#123;8,20&#125;$/&quot;, $_GET[&apos;username&apos;], $matches))</div><div class="line">&#123;</div><div class="line">   $result = mysqli_query($conn, &quot;SELECT * FROM users </div><div class="line">						  WHERE username=$matches[0]&quot;);</div><div class="line">&#125;</div><div class="line"> else </div><div class="line">&#123;</div><div class="line">   echo &quot;username 输入异常&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

防止SQL注入，我们需要注意以下几个要点：
    1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双&quot;-&quot;进行转换等。
    2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
    5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。
    6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。
</code></pre><h4 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h4><pre><code>在脚本语言，如Perl和PHP你可以对用户输入的数据进行转义从而来防止SQL注入。
如：mysqli_real_escape_string()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (get_magic_quotes_gpc()) </div><div class="line">&#123;</div><div class="line">  $name = stripslashes($name);</div><div class="line">&#125;</div><div class="line">$name = mysqli_real_escape_string($conn, $name);</div><div class="line"> mysqli_query($conn, &quot;SELECT * FROM users WHERE name=&apos;&#123;$name&#125;&apos;&quot;);</div></pre></td></tr></table></figure>
</code></pre><h4 id="Like语句中的注入"><a href="#Like语句中的注入" class="headerlink" title="Like语句中的注入"></a>Like语句中的注入</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$sub = addcslashes(mysqli_real_escape_string($conn, &quot;%something_&quot;), &quot;%_&quot;);</div><div class="line">// $sub == \%something\_</div><div class="line"> mysqli_query($conn, &quot;SELECT * FROM messages WHERE subject LIKE &apos;&#123;$sub&#125;%&apos;&quot;);</div><div class="line">addcslashes() 函数在指定的字符前添加反斜杠。</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-导出数据"><a href="#MySQL-导出数据" class="headerlink" title="MySQL 导出数据"></a>MySQL 导出数据</h3><pre><code>MySQL中你可以使用SELECT...INTO OUTFILE语句来简单的导出数据到文本文件上。
1.将数据表 runoob_tbl 数据导出到 /tmp/tutorials.txt 文件中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM runoob_tbl </div><div class="line">   INTO OUTFILE &apos;/tmp/tutorials.txt&apos;;</div></pre></td></tr></table></figure>

2.可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM passwd INTO OUTFILE &apos;/tmp/tutorials.txt&apos;</div><div class="line">   FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos;</div><div class="line">   LINES TERMINATED BY &apos;\r\n&apos;;</div></pre></td></tr></table></figure>

3.生成一个文件，各值用逗号隔开。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos;</div><div class="line">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</div><div class="line">LINES TERMINATED BY &apos;\n&apos;</div><div class="line">FROM test_table;</div></pre></td></tr></table></figure>
</code></pre><h4 id="导出表作为原始数据"><a href="#导出表作为原始数据" class="headerlink" title="导出表作为原始数据"></a>导出表作为原始数据</h4><pre><code>mysqldump是mysql用于转存储数据库的实用程序。
使用mysqldump导出数据需要使用 --tab 选项来指定导出文件指定的目录，该目标必须是可写的。    
以下实例将数据表 runoob_tbl 导出到 /tmp 目录中。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysqldump -u root -p --no-create-info \</div><div class="line">           --tab=/tmp database_name table_name</div></pre></td></tr></table></figure>
</code></pre><h4 id="导出SQL格式的数据"><a href="#导出SQL格式的数据" class="headerlink" title="导出SQL格式的数据"></a>导出SQL格式的数据</h4><pre><code>1.导出SQL格式的数据到指定文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -u root -p database_name table_name &gt; dump.txt</div></pre></td></tr></table></figure>

2.导出整个数据库的数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -u root -p database_name &gt; database_dump.txt</div></pre></td></tr></table></figure>

3.备份所有数据库
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -u root -p --all-databases &gt; database_dump.txt</div></pre></td></tr></table></figure>
</code></pre><h4 id="将数据表及数据库拷贝至其他主机"><a href="#将数据表及数据库拷贝至其他主机" class="headerlink" title="将数据表及数据库拷贝至其他主机"></a>将数据表及数据库拷贝至其他主机</h4><pre><code>将数据备份至 dump.txt 文件中
    mysqldump -u root -p database_name table_name &gt; dump.txt
将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建
    mysql -u root -p database_name &lt; dump.txt
使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的
    mysqldump -u root -p database_name \
        | mysql -h other-host.com database_name
</code></pre><h3 id="MySQL-导入数据"><a href="#MySQL-导入数据" class="headerlink" title="MySQL 导入数据"></a>MySQL 导入数据</h3><h4 id="使用-LOAD-DATA-导入数据"><a href="#使用-LOAD-DATA-导入数据" class="headerlink" title="使用 LOAD DATA 导入数据"></a>使用 LOAD DATA 导入数据</h4><pre><code>将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。
    LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl;
    如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。
</code></pre><h4 id="使用-mysqlimport-导入数据"><a href="#使用-mysqlimport-导入数据" class="headerlink" title="使用 mysqlimport 导入数据"></a>使用 mysqlimport 导入数据</h4><pre><code>从文件 dump.txt 中将数据导入到 mytbl 数据表中
    mysqlimport -u root -p --local database_name dump.txt
</code></pre><h4 id="mysqlimport的常用选项介绍"><a href="#mysqlimport的常用选项介绍" class="headerlink" title="mysqlimport的常用选项介绍"></a>mysqlimport的常用选项介绍</h4><p><img src="/images/mysql_import.png" alt="mysql_import"></p>
<blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="external">MYSQL</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MySQL-事务&quot;&gt;&lt;a href=&quot;#MySQL-事务&quot; class=&quot;headerlink&quot; title=&quot;MySQL 事务&quot;&gt;&lt;/a&gt;MySQL 事务&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。
在人员管理系统中，你
    
    </summary>
    
      <category term="sql" scheme="https://fanerge.github.io/categories/sql/"/>
    
    
      <category term="mysql" scheme="https://fanerge.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习（上部分）</title>
    <link href="https://fanerge.github.io/2017/09/12/musql%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/12/musql学习/</id>
    <published>2017-09-12T11:09:59.000Z</published>
    <updated>2017-09-14T12:11:48.717Z</updated>
    
    <content type="html"><![CDATA[<p>基础构架：database –&gt; table –&gt; row 和 col（数据块）</p>
<h3 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h3><ol>
<li>数据库: 数据库是一些关联表的集合。.</li>
<li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>
<li>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>外键：外键用于关联两个表。</li>
<li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ol>
<h3 id="MySQL-创建数据库"><a href="#MySQL-创建数据库" class="headerlink" title="MySQL 创建数据库"></a>MySQL 创建数据库</h3><h4 id="使用-mysqladmin-创建数据库"><a href="#使用-mysqladmin-创建数据库" class="headerlink" title="使用 mysqladmin 创建数据库"></a>使用 mysqladmin 创建数据库</h4><pre><code>以下实例会创建一个 RUNOOB 数据库
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@host]# mysqladmin -u root -p create RUNOOB</div><div class="line">Enter password:******</div></pre></td></tr></table></figure>
</code></pre><h4 id="SQL语句创建数据库-RUNOOB"><a href="#SQL语句创建数据库-RUNOOB" class="headerlink" title="SQL语句创建数据库 RUNOOB"></a>SQL语句创建数据库 RUNOOB</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;CREATE DATABASE RUNOOB&apos;</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-删除数据库"><a href="#MySQL-删除数据库" class="headerlink" title="MySQL 删除数据库"></a>MySQL 删除数据库</h3><h4 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@host]# mysqladmin -u root -p drop RUNOOB</div><div class="line">Enter password:******</div></pre></td></tr></table></figure>
</code></pre><h4 id="SQL语句删除数据库-RUNOOB"><a href="#SQL语句删除数据库-RUNOOB" class="headerlink" title="SQL语句删除数据库 RUNOOB"></a>SQL语句删除数据库 RUNOOB</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;DROP DATABASE RUNOOB&apos;</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-选择数据库"><a href="#MySQL-选择数据库" class="headerlink" title="MySQL 选择数据库"></a>MySQL 选择数据库</h3><h4 id="从命令提示窗口中选择MySQL数据库"><a href="#从命令提示窗口中选择MySQL数据库" class="headerlink" title="从命令提示窗口中选择MySQL数据库"></a>从命令提示窗口中选择MySQL数据库</h4><pre><code>使用 RUNOOB 数据库
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@host]# mysql -u root -p</div><div class="line">Enter password:******</div><div class="line">mysql&gt; use RUNOOB;</div></pre></td></tr></table></figure>
</code></pre><h4 id="使用-NODE-js-选择数据库"><a href="#使用-NODE-js-选择数据库" class="headerlink" title="使用 NODE.js 选择数据库"></a>使用 NODE.js 选择数据库</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var mysql = require(&apos;mysql&apos;);</div><div class="line">var connection = mysql.createConnetion(&#123;</div><div class="line">	host: &apos;localhost&apos;,</div><div class="line">	prot: 3306,</div><div class="line">	user: &apos;root&apos;,</div><div class="line">	password: &apos;****&apos;,</div><div class="line">	database: &apos;RUNOOB&apos;</div><div class="line">&#125;);</div><div class="line">connection.connect(); // 连接数据库</div><div class="line">connection.query(&apos;SQL命令&apos;, function (err, result) &#123; // 数据库相应的 CURD &#125;)	</div><div class="line">connection.end(); // 断开连接</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h3><pre><code>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。
</code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><img src="/images/mysql_int.png" alt="mysql_int"></p>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><pre><code>每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。
</code></pre><p><img src="/images/mysql_time.png" alt="mysql_time"></p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><pre><code>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。
</code></pre><p><img src="/images/mysql_string.png" alt="mysql_string"></p>
<h3 id="MySQL-创建数据表"><a href="#MySQL-创建数据表" class="headerlink" title="MySQL 创建数据表"></a>MySQL 创建数据表</h3><pre><code>创建数据表需要：表名、表字段名、定义每个表字段
</code></pre><h4 id="SQL命令"><a href="#SQL命令" class="headerlink" title="SQL命令"></a>SQL命令</h4><pre><code>语法：
    CREATE TABLE table_name (column_name column_type)
    CREATE TABLE IF NOT EXISTS table_name (column_name column_type) // 判断是否存在
实例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</div><div class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</div><div class="line">   `runoob_title` VARCHAR(100) NOT NULL,</div><div class="line">   `runoob_author` VARCHAR(40) NOT NULL,</div><div class="line">   `submission_date` DATE,</div><div class="line">   PRIMARY KEY ( `runoob_id` )</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div><div class="line">1.如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL</div><div class="line">2.AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</div><div class="line">3.PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</div></pre></td></tr></table></figure>
</code></pre><h4 id="在命令提示窗口中创建数据表"><a href="#在命令提示窗口中创建数据表" class="headerlink" title="在命令提示窗口中创建数据表"></a>在命令提示窗口中创建数据表</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@host# mysql -u root -p</div><div class="line">Enter password:*******</div><div class="line">mysql&gt; use RUNOOB;</div><div class="line">mysql&gt; CREATE TABLE runoob_tbl(</div><div class="line">   -&gt; runoob_id INT NOT NULL AUTO_INCREMENT,</div><div class="line">   -&gt; runoob_title VARCHAR(100) NOT NULL,</div><div class="line">   -&gt; runoob_author VARCHAR(40) NOT NULL,</div><div class="line">   -&gt; submission_date DATE,</div><div class="line">   -&gt; PRIMARY KEY ( runoob_id )</div><div class="line">   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
</code></pre><h4 id="node-js中创建表"><a href="#node-js中创建表" class="headerlink" title="node.js中创建表"></a>node.js中创建表</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connection.query(&quot;CREATE TABLE person(id int,user varchar(255),password varchar(255))&quot;, function(err,result)&#123;</div><div class="line">	if(err)&#123;throw err&#125;</div><div class="line">	console.log(&quot;创建表成功&quot;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-删除数据表"><a href="#MySQL-删除数据表" class="headerlink" title="MySQL 删除数据表"></a>MySQL 删除数据表</h3><pre><code>语法：
    DROP TABLE table_name
</code></pre><h4 id="在命令提示窗口中删除数据表"><a href="#在命令提示窗口中删除数据表" class="headerlink" title="在命令提示窗口中删除数据表"></a>在命令提示窗口中删除数据表</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@host# mysql -u root -p</div><div class="line">Enter password:*******</div><div class="line">mysql&gt; use RUNOOB;</div><div class="line">mysql&gt; DROP TABLE runoob_tbl</div></pre></td></tr></table></figure>
</code></pre><h4 id="node-js中删除表"><a href="#node-js中删除表" class="headerlink" title="node.js中删除表"></a>node.js中删除表</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;DROP TABLE runoob_tbl&apos;, function (err, result) &#123;</div><div class="line">	if (err) throw err;</div><div class="line">	console.log(result);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-插入数据"><a href="#MySQL-插入数据" class="headerlink" title="MySQL 插入数据"></a>MySQL 插入数据</h3><pre><code>语法：    
    INSERT INTO table_name (field1, field2, ...filedN) VALUES (value1, value2, value3);
</code></pre><h4 id="通过命令提示窗口插入数据"><a href="#通过命令提示窗口插入数据" class="headerlink" title="通过命令提示窗口插入数据"></a>通过命令提示窗口插入数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@host# mysql -u root -p password;</div><div class="line">Enter password:*******</div><div class="line">mysql&gt; use RUNOOB;</div><div class="line">mysql&gt; INSERT INTO runoob_tbl </div><div class="line">	-&gt; (runoob_title, runoob_author, submission_date)</div><div class="line">	-&gt; VALUES</div><div class="line">	-&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());</div></pre></td></tr></table></figure>

读取某张表 -- select * from runoob_tbl;
</code></pre><h4 id="node-js插入数据"><a href="#node-js插入数据" class="headerlink" title="node.js插入数据"></a>node.js插入数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;INSERT INTO websites(id, name, url, alexa, country) VALUES (0, &quot;fanerge&quot;, &quot;23213&quot;, &quot;234&quot;, &quot;成都&quot;)&apos;, function (err, result) &#123;</div><div class="line">	console.log(result);</div><div class="line">&#125;);</div><div class="line">// 占位符的形式</div><div class="line">connection.query(&apos;INSERT INTO websites(id, name, url, alexa, country) VALUES (0, ?, ?, ?)&apos;, [&quot;fanerge12&quot;, &quot;23213&quot;, &quot;234&quot;, &quot;成都&quot;], function (err, result) &#123;</div><div class="line">	console.log(&apos;DELETE affectedRows:&apos;, result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-查询数据"><a href="#MySQL-查询数据" class="headerlink" title="MySQL 查询数据"></a>MySQL 查询数据</h3><pre><code>语法：
    SELECT column_name, column_name 
    FROM table_name // 可以查询多张表以,分隔
    [WHERE clause] // 查询条件
    [OFFSET M][LIMIT N] // 偏移量 和 限制条数
</code></pre><h4 id="通过命令提示符获取数据"><a href="#通过命令提示符获取数据" class="headerlink" title="通过命令提示符获取数据"></a>通过命令提示符获取数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from runoob_tbl</div></pre></td></tr></table></figure>
</code></pre><h4 id="node-js查询数据"><a href="#node-js查询数据" class="headerlink" title="node.js查询数据"></a>node.js查询数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;SELECT name, url FROM websites&apos;, function (err, result) &#123;</div><div class="line">	console.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-WHERE-子句"><a href="#MySQL-WHERE-子句" class="headerlink" title="MySQL WHERE 子句"></a>MySQL WHERE 子句</h3><pre><code>可以用在：SELECT 和 DELETE 和 UPDATE 命令中。
默认where语句不区分大小写，使用BINARY开启区分大小写。
语法：
    SELECT field1, field2, ...filedN
    FROM table_name1, table_name2
    [WHERE confition1 [AND [OR]]] condition2
</code></pre><p><img src="/images/mysql_where.png" alt="mysql_where">    </p>
<h4 id="从命令提示符中读取数据"><a href="#从命令提示符中读取数据" class="headerlink" title="从命令提示符中读取数据"></a>从命令提示符中读取数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	SELECT name, url FROM user WHERE name=&quot;fanerge&quot; AND url=&quot;fanerge&quot;</div><div class="line">	```	</div><div class="line">####	node.js读取数据</div></pre></td></tr></table></figure>

connection.query(&apos;SELECT name, url FROM user WHERE name=&quot;fanerge&quot; AND url=&quot;fanerge&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">###		MySQL UPDATE 查询	</div><div class="line">	语法：	</div><div class="line">		UPDATE table_name SET field1=new-value1, field1=new-value2</div><div class="line">		[WHERE clause]</div><div class="line">####	通过命令提示符更新数据</div></pre></td></tr></table></figure>

UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">####	node.js更新数据</div></pre></td></tr></table></figure>

connection.query(&apos;UPDATE user SET url=&quot;zhongguo&quot; WHERE name=&quot;1name&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">###		MySQL DELETE 语句	</div><div class="line">	语法：	</div><div class="line">		DELETE FROM table_name [WHERE clause]</div><div class="line">####	从命令行中删除数据</div></pre></td></tr></table></figure>

use RUNOOB;
mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">####	node.js删除数据</div></pre></td></tr></table></figure>

connection.query(&apos;DELETE FROM user WHERE name=&quot;1name&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">###	MySQL LIKE 子句</div><div class="line">	我们需要获取 runoob_author 字段含有 &quot;COM&quot; 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。	</div><div class="line">	如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。	</div><div class="line">	语法：</div><div class="line">		SELECT field1, field2, ...filedN</div><div class="line">		FROM table_name</div><div class="line">		WHERE field1 LIKE confition1 [AND [OR]] field2 = &apos;somevalue&apos;</div><div class="line">####	在命令提示符中使用 LIKE 子句</div><div class="line">	以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录：</div></pre></td></tr></table></figure>

use RUNOOB
SELECT * from runoob_tl WHERE runoob_author LIKE &apos;%COM&apos;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">####	node.js中使用 LIKE 子句</div></pre></td></tr></table></figure>

connection.query(&apos;SELECT * FROM websites WHERE BINARY name LIKE &quot;f%&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">###	MySQL UNION 操作符</div><div class="line">	MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。</div><div class="line">	多个 SELECT 语句会删除重复的数据。</div><div class="line">	UNION [ALL | DISTINCT]	// DISTINCT: 可选，删除结果集中重复的数据。ALL: 可选，返回所有结果集，包含重复数据。</div><div class="line">	语法：</div><div class="line">		SELECT column1, column2, ... columnN</div><div class="line">		FROM tables</div><div class="line">		[WHERE conditions]</div><div class="line">		UNION [ALL | DISTINCT]</div><div class="line">		SELECT column1, column2, ... columnN</div><div class="line">		FROM tables</div><div class="line">		[WHERE conditions];</div><div class="line">####	node.js 中使用 UNION</div></pre></td></tr></table></figure>

connection.query(&apos;SELECT country FROM websites UNION ALL SELECT country FROM apps ORDER BY country&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">####	带有 WHERE 的 SQL UNION ALL</div></pre></td></tr></table></figure>

connection.query(&apos;SELECT country, name FROM websites WHERE country LIKE &quot;C%&quot; UNION ALL SELECT country, app_name FROM apps WHERE country=&quot;CN&quot; ORDER BY country&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">###	MySQL 排序	</div><div class="line">	语法：</div><div class="line">		SELECT field1, field2, ...filedN table_name1, table_name2</div><div class="line">		ORDER BY field1, [field2] [ASC [DESC]] </div><div class="line">####	在命令提示符中使用 ORDER BY 子句</div></pre></td></tr></table></figure>

use RUNOOB;
mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date ASC;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">####	node.js 中 ORDER BY [ASC DESC]</div></pre></td></tr></table></figure>

connection.query(&apos;SELECT * FROM websites ORDER BY id DESC&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">###	MySQL GROUP BY 语句</div><div class="line">	语法：	</div><div class="line">		SELECT column_name, function(column_name)</div><div class="line">		FROM table_name</div><div class="line">		WHERE column_name operator value</div><div class="line">		GROUP BY column_name;</div><div class="line">####	我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录</div></pre></td></tr></table></figure>

SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">####	使用 WITH ROLLUP</div><div class="line">	WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</div><div class="line">	coalesce函数说明：name !== null ? name : &apos;总数&apos;。</div></pre></td></tr></table></figure>

SELECT coalesce(name, &quot;总数&quot;), SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###	Mysql 连接的使用</div><div class="line">	从多个数据表中读取数据。</div><div class="line">	你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</div><div class="line">	JOIN 按照功能大致分为如下三类：</div><div class="line">	1.	INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。(类似于交集)</div><div class="line">	2.	LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</div><div class="line">	3.	RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。	</div><div class="line">####	在命令提示符中使用 INNER JOIN(相当于交集)</div></pre></td></tr></table></figure>

SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">####	MySQL LEFT JOIN</div><div class="line">	MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</div></pre></td></tr></table></figure>

SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">####	MySQL RIGHT JOIN</div><div class="line">	MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</div></pre></td></tr></table></figure>

SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###	MySQL NULL 值处理</div><div class="line">	IS NULL: 当列的值是 NULL,此运算符返回 true。</div><div class="line">	IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。</div><div class="line">	&lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</div><div class="line">####	在命令提示符中使用 NULL 值</div><div class="line">	SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;</div><div class="line">	SELECT * FROM runoob_test_tbl WHERE runoob_count IS NOT NULL;</div><div class="line"></div><div class="line">###	MySQL 正则表达式</div><div class="line">![mysql_regexp](/images/mysql_regexp1.png)</div></pre></td></tr></table></figure>

SELECT name FROM websites WHERE BINARY name REGEXP &apos;^F&apos;
SELECT name FROM person_tbl WHERE name REGEXP &apos;ok$&apos;;
```
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="external">MYSQL</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础构架：database –&amp;gt; table –&amp;gt; row 和 col（数据块）&lt;/p&gt;
&lt;h3 id=&quot;RDBMS-术语&quot;&gt;&lt;a href=&quot;#RDBMS-术语&quot; class=&quot;headerlink&quot; title=&quot;RDBMS 术语&quot;&gt;&lt;/a&gt;RDBMS 术语
    
    </summary>
    
      <category term="sql" scheme="https://fanerge.github.io/categories/sql/"/>
    
    
      <category term="mysql" scheme="https://fanerge.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>node.js 和 mysql 结合使用</title>
    <link href="https://fanerge.github.io/2017/09/12/node-mysql/"/>
    <id>https://fanerge.github.io/2017/09/12/node-mysql/</id>
    <published>2017-09-12T11:06:38.000Z</published>
    <updated>2017-09-12T15:05:21.437Z</updated>
    
    <content type="html"><![CDATA[<p>可视化工具：navicat for MySQL</p>
<h3 id="node和mysql的配合"><a href="#node和mysql的配合" class="headerlink" title="node和mysql的配合"></a>node和mysql的配合</h3><h4 id="mysql和node-js的连接"><a href="#mysql和node-js的连接" class="headerlink" title="mysql和node.js的连接"></a>mysql和node.js的连接</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var mysql      = require(&apos;mysql&apos;);</div><div class="line">var connection = mysql.createConnection(&#123;</div><div class="line">  host     : &apos;localhost&apos;, // 数据库的ip</div><div class="line">  port	   : 3306, // 数据库起服务的端口</div><div class="line">  user     : &apos;root&apos;, </div><div class="line">  password : &apos;123456&apos;,</div><div class="line">  database : &apos;test&apos; // 数据库名称</div><div class="line">&#125;);</div><div class="line">// 链接数据库 </div><div class="line">connection.connect();</div><div class="line">// 推荐使用下面的链接方式</div><div class="line">connection.connect(function(err) &#123;    </div><div class="line">	if (err) &#123;      </div><div class="line">		console.error(&apos;error connecting: &apos; + err.stack);      </div><div class="line">		return;    </div><div class="line">	&#125;    </div><div class="line">	console.log(&apos;connected as id &apos; + connection.threadId);  // 线程id</div><div class="line">&#125;);</div><div class="line">// 测试数据库是否连接成功 </div><div class="line">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123;</div><div class="line">  if (error) throw error;</div><div class="line">  console.log(&apos;The solution is: &apos;, results[0].solution);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connection.query(&quot;CREATE TABLE person(id int,user varchar(255),password varchar(255))&quot;, function(err,result)&#123;</div><div class="line">	if(err)&#123;throw err&#125;</div><div class="line">	console.log(&quot;创建表成功&quot;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="连接池连接"><a href="#连接池连接" class="headerlink" title="连接池连接"></a>连接池连接</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var pool  = mysql.createPool(&#123;    </div><div class="line">	connectionLimit : 10,    </div><div class="line">	host            : &apos;example.org&apos;,    </div><div class="line">	user            : &apos;bob&apos;,    </div><div class="line">	password        : &apos;secret&apos;,    </div><div class="line">	database        : &apos;my_db&apos;  </div><div class="line">&#125;);	</div><div class="line">// 测试数据库是否连接成功 </div><div class="line">pool.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123;</div><div class="line">  if (error) throw error;</div><div class="line">  console.log(&apos;The solution is: &apos;, results[0].solution);</div><div class="line">&#125;);</div><div class="line">// 使用连接池连接可以更容易地共享某个连接，也可以管理多个连接。</div><div class="line">pool.getConnection(function(err, connection) &#123; // 使用连接        </div><div class="line">	connection.query( &apos;SELECT something FROM sometable&apos;, function(err, rows) &#123; </div><div class="line">		// 使用连接执行查询       </div><div class="line">		connection.release(); //连接不再使用，返回到连接池</div><div class="line">		connection.destroy(); // 如果你想关闭连接并从连接池中删除它，在下次需要时连接池会再创建一个新的连接。			</div><div class="line">	&#125;);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h4 id="连接池的事件"><a href="#连接池的事件" class="headerlink" title="连接池的事件"></a>连接池的事件</h4><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pool.on(&apos;connection&apos;, function (connection) &#123;    </div><div class="line">	connection.query(&apos;SET SESSION auto_increment_increment=1&apos;)  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pool.on(&apos;enqueue&apos;, function () &#123;    </div><div class="line">	console.log(&apos;Waiting for available connection slot&apos;);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="在连接池中关闭所有连接"><a href="#在连接池中关闭所有连接" class="headerlink" title="在连接池中关闭所有连接"></a>在连接池中关闭所有连接</h5><pre><code>如不再需要连接池时，你必须关闭所有连接。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pool.end(function (err) &#123;    </div><div class="line">	// all connections in the pool have ended  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="集群连接池"><a href="#集群连接池" class="headerlink" title="集群连接池"></a>集群连接池</h5><pre><code>集群连接池提供多主机连接.(分组&amp;重试&amp;选择器)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// create  </div><div class="line">var poolCluster = mysql.createPoolCluster();  </div><div class="line">// add configurations (the config is a pool config object)  </div><div class="line">poolCluster.add(config); </div><div class="line">// add configuration with automatic name  </div><div class="line">poolCluster.add(&apos;MASTER&apos;, masterConfig); </div><div class="line">// add a named configuration  </div><div class="line">poolCluster.add(&apos;SLAVE1&apos;, slave1Config);  </div><div class="line">poolCluster.add(&apos;SLAVE2&apos;, slave2Config);  </div><div class="line">// remove configurations  </div><div class="line">poolCluster.remove(&apos;SLAVE2&apos;); </div><div class="line">// By nodeId  poolCluster.remove(&apos;SLAVE*&apos;); </div><div class="line">// By target group : SLAVE1-2  </div><div class="line">// Target Group : ALL(anonymous, MASTER, SLAVE1-2), Selector : round-robin(default)  </div><div class="line">poolCluster.getConnection(function (err, connection) &#123;&#125;);  </div><div class="line">// Target Group : MASTER, Selector : round-robin  </div><div class="line">poolCluster.getConnection(&apos;MASTER&apos;, function (err, connection) &#123;&#125;);  </div><div class="line">// Target Group : SLAVE1-2, Selector : order  </div><div class="line">// If can&apos;t connect to SLAVE1, return SLAVE2. (remove SLAVE1 in the cluster)  </div><div class="line">poolCluster.on(&apos;remove&apos;, function (nodeId) &#123;    console.log(&apos;REMOVED NODE : &apos; + nodeId); </div><div class="line">// nodeId = SLAVE1   &#125;);  </div><div class="line">poolCluster.getConnection(&apos;SLAVE*&apos;, &apos;ORDER&apos;, function (err, connection) &#123;&#125;);  </div><div class="line">// of namespace : of(pattern, selector)  </div><div class="line">poolCluster.of(&apos;*&apos;).getConnection(function (err, connection) &#123;&#125;);  </div><div class="line">var pool = poolCluster.of(&apos;SLAVE*&apos;, &apos;RANDOM&apos;);  </div><div class="line">pool.getConnection(function (err, connection) &#123;&#125;);  </div><div class="line">pool.getConnection(function (err, connection) &#123;&#125;);  </div><div class="line">// close all connections  </div><div class="line">poolCluster.end(function (err) &#123;    // all connections in the pool cluster have ended  &#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="更换用户并且改变连接状态"><a href="#更换用户并且改变连接状态" class="headerlink" title="更换用户并且改变连接状态"></a>更换用户并且改变连接状态</h5><pre><code>该命令允许你在不关闭下列socket的情况下，改变当前用户和连接的其余部分.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.changeUser(&#123;user : &apos;john&apos;&#125;, function(err) &#123;    </div><div class="line">	if (err) throw err;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="数据库操作（CURD）"><a href="#数据库操作（CURD）" class="headerlink" title="数据库操作（CURD）"></a>数据库操作（CURD）</h3><pre><code>代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。
</code></pre><h4 id="查询数据（Retrieve）"><a href="#查询数据（Retrieve）" class="headerlink" title="查询数据（Retrieve）"></a>查询数据（Retrieve）</h4><h5 id="query-sqlString-callback"><a href="#query-sqlString-callback" class="headerlink" title="query(sqlString, callback)"></a>query(sqlString, callback)</h5><pre><code>第一个参数是一条SQL字符串，第二个参数是回调
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;SELECT * FROM `books` WHERE `author` = &quot;David&quot;&apos;, function (error, results, fields) &#123;    </div><div class="line">	if (error) &#123;</div><div class="line">		console.log(error.message);</div><div class="line">	&#125;</div><div class="line">	// 查询之后的操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="query-sqlString-values-callback"><a href="#query-sqlString-values-callback" class="headerlink" title="query(sqlString, values, callback)"></a>query(sqlString, values, callback)</h5><pre><code>带有值的占位符 (查看转义查询值)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;SELECT * FROM `books` WHERE `author` = ?&apos;, [&apos;David&apos;], function (error, results, fields) &#123;    </div><div class="line">	if (error) &#123;</div><div class="line">		console.log(error.message);</div><div class="line">	&#125;</div><div class="line">	// 查询之后的操作</div><div class="line">&#125;);</div><div class="line">connection.end(); // 断开数据库连接</div></pre></td></tr></table></figure>
</code></pre><h5 id="query-options-callback"><a href="#query-options-callback" class="headerlink" title="query(options, callback)"></a>query(options, callback)</h5><pre><code>在查询时带有大量的高级可选项
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">connection.query(&#123;</div><div class="line">	sql: &apos;SELECT * FROM `books` WHERE `author` = ?&apos;,    </div><div class="line">	timeout: 40000,   </div><div class="line">	values: [&apos;David&apos;]  </div><div class="line">&#125;, function (error, results, fields) &#123;    </div><div class="line">	if (error) &#123;</div><div class="line">		console.log(error.message);</div><div class="line">	&#125;</div><div class="line">	// 查询之后的操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="查询值转义"><a href="#查询值转义" class="headerlink" title="查询值转义"></a>查询值转义</h5><pre><code>为了防止SQL注入，每当需要在SQL查询中使用用户数据时，你都应当提前对这些值进行转义。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 第一种，转义可以通过 mysql.escape(), connection.escape() 或 pool.escape() 方法实现。</div><div class="line">var userId = &apos;some user provided value&apos;;  </div><div class="line">var sql    = &apos;SELECT * FROM users WHERE id = &apos; + connection.escape(userId);  </div><div class="line">connection.query(sql, function(err, results) &#123;    </div><div class="line">	// ...  </div><div class="line">&#125;);</div><div class="line">// 第二种，使用 ? 作为查询字符串中的占位符，替代你想要转义的值。</div><div class="line">connection.query(&apos;SELECT * FROM users WHERE id = ?&apos;, [userId], function(err, results) &#123;    </div><div class="line">	// ...  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="查询标识符转义"><a href="#查询标识符转义" class="headerlink" title="查询标识符转义"></a>查询标识符转义</h5><pre><code>如果用户提供了不可信的查询标识符（数据库名、表名、列名），
你应该用 mysql.escapeId(identifier), connection.escapeId(identifier) 或 pool.escapeId(identifier) 方法对它进行转义。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var sorter = &apos;date&apos;;  </div><div class="line">var sql    = &apos;SELECT * FROM posts ORDER BY &apos; + connection.escapeId(sorter);  </div><div class="line">connection.query(sql, function(err, results) &#123;    </div><div class="line">	// ...  </div><div class="line">&#125;);</div><div class="line">var userId = 1;  </div><div class="line">var columns = [&apos;username&apos;, &apos;email&apos;];  </div><div class="line">var query = connection.query(&apos;SELECT ?? FROM ?? WHERE id = ?&apos;, [columns, &apos;users&apos;, userId], function(err, results) &#123;    </div><div class="line">	// SELECT `username`, `email` FROM `users` WHERE id = 1</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="预查询"><a href="#预查询" class="headerlink" title="预查询"></a>预查询</h5><pre><code>你可以使用 mysql.format 来创建一个多插入点的查询语句，对id和值可以使用适当的转义处理 。
这样你就获得了一个有效并且安全的查询语句，然后可以把它发送给 数据库。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sql = &quot;SELECT * FROM ?? WHERE ?? = ?&quot;;  </div><div class="line">var inserts = [&apos;users&apos;, &apos;id&apos;, userId];  </div><div class="line">sql = mysql.format(sql, inserts);</div></pre></td></tr></table></figure>
</code></pre><h4 id="插入数据（Insert）"><a href="#插入数据（Insert）" class="headerlink" title="插入数据（Insert）"></a>插入数据（Insert）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var addSql = &apos;INSERT INTO websites(Id, name, url, alexa, country) VALUES(0, ?, ?, ?, ?)&apos;;</div><div class="line">var addSqlParams = [&apos;余真帆的博客&apos;, &apos;fanerge.githut.io&apos;, &apos;333325&apos;, &apos;CN&apos;];</div><div class="line">connection.query(addSql, addSqlParams, function (err, result) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(&apos;[SELECT ERROR] - &apos;, err.message);</div><div class="line">	&#125;</div><div class="line">	console.log(&apos;-------INSERT--------&apos;);</div><div class="line">	console.log(&apos;INSERT ID:&apos;, result);</div><div class="line">	console.log(&apos;-------END--------&apos;);</div><div class="line">&#125;);</div><div class="line">connection.end();</div></pre></td></tr></table></figure>
</code></pre><h4 id="更新数据（Update）"><a href="#更新数据（Update）" class="headerlink" title="更新数据（Update）"></a>更新数据（Update）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var modSql = &apos;UPDATE websites SET name = ?, url = ?, alexa = ? WHERE Id = ?&apos;;</div><div class="line">var modSqlParams = [&apos;余真帆的网站&apos;, &apos;https://fanerge.github.io&apos;, 23, 6]</div><div class="line">connection.query(modSql, modSqlParams, function (err, result) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(&apos;[UPDATE ERROR] - &apos;, err.message);</div><div class="line">	&#125;</div><div class="line">	console.log(&apos;-------UPDATE--------&apos;);</div><div class="line">	console.log(&apos;UPDATE affectedRows:&apos;, result.affectedRows);</div><div class="line">	console.log(&apos;-------END--------&apos;);</div><div class="line">&#125;);</div><div class="line">connection.end();</div></pre></td></tr></table></figure>
</code></pre><h4 id="删除数据（Delete）"><a href="#删除数据（Delete）" class="headerlink" title="删除数据（Delete）"></a>删除数据（Delete）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var delSql = &apos;DELETE FROM websites WHERE name = &quot;余真帆的博客&quot;&apos;;</div><div class="line">connection.query(delSql, function (err, result) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(&apos;[DELETE ERROR] - &apos;, err.message);</div><div class="line">	&#125;</div><div class="line">	console.log(&apos;-------DELETE--------&apos;);</div><div class="line">	console.log(&apos;DELETE affectedRows:&apos;, result.affectedRows);</div><div class="line">	console.log(&apos;-------END--------&apos;);</div><div class="line">&#125;);</div><div class="line">connection.end();</div></pre></td></tr></table></figure>
</code></pre><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="获取插入行的id"><a href="#获取插入行的id" class="headerlink" title="获取插入行的id"></a>获取插入行的id</h4><pre><code>如果你把一行插入到一个有自增主键的表中，可以这样获得插入的ID
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;INSERT INTO posts SET ?&apos;, &#123;title: &apos;test&apos;&#125;, function(err, result) &#123;    </div><div class="line">	if (err) throw err;    console.log(result.insertId);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h4 id="取得受影响的行数"><a href="#取得受影响的行数" class="headerlink" title="取得受影响的行数"></a>取得受影响的行数</h4><pre><code>你可以从 insert，update 或者 delete 子句中取得受影响的行数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;DELETE FROM posts WHERE title = &quot;wrong&quot;&apos;, function (err, result) &#123;    </div><div class="line">	if (err) throw err;    </div><div class="line">	console.log(&apos;deleted &apos; + result.affectedRows + &apos; rows&apos;);  </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h4 id="取得被改变的行数"><a href="#取得被改变的行数" class="headerlink" title="取得被改变的行数"></a>取得被改变的行数</h4><pre><code>你可以从 update 子句取得被改变的行数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;UPDATE posts SET ...&apos;, function (err, result) &#123;    </div><div class="line">	if (err) throw err;    </div><div class="line">	console.log(&apos;changed &apos; + result.changedRows + &apos; rows&apos;);  </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h4 id="获取连接ID"><a href="#获取连接ID" class="headerlink" title="获取连接ID"></a>获取连接ID</h4><pre><code>你可以取得MySQL的连接ID（“线程ID”），这是一个给定的连接，使用的是线程ID属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connection.connect(function(err) &#123;    </div><div class="line">	if (err) throw err;    </div><div class="line">	console.log(&apos;connected as id &apos; + connection.threadId);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h4 id="并行执行查询"><a href="#并行执行查询" class="headerlink" title="并行执行查询"></a>并行执行查询</h4><pre><code>MySQL协议是顺序的，这意味着你需要多次连接执行并行查询。
你可以使用池来管理连接，一个简单的办法是每传入一个http请求，就创建一个连接。
</code></pre><h4 id="流式查询行"><a href="#流式查询行" class="headerlink" title="流式查询行"></a>流式查询行</h4><pre><code>有的时候可能需要查询大量的数据行，然后在接收到这些数据行的时候一行行的处理它们。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var query = connection.query(&apos;SELECT * FROM posts&apos;);  </div><div class="line">query.on(&apos;error&apos;, function(err) &#123;      </div><div class="line">	// 处理错误，这之后会触发 &apos;end&apos; 事件    </div><div class="line">&#125;)    </div><div class="line">.on(&apos;fields&apos;, function(fields) &#123;      </div><div class="line">	// 字段信息    </div><div class="line">&#125;)</div><div class="line">.on(&apos;result&apos;, function(row) &#123;      </div><div class="line">	// 暂停连接。如果你的处理过程涉及到 I/O 操作，这会很有用。      </div><div class="line">	connection.pause();     </div><div class="line">	processRow(row, function() &#123;        </div><div class="line">		connection.resume();      </div><div class="line">	&#125;);    </div><div class="line">&#125;)</div><div class="line">.on(&apos;end&apos;, function() &#123;      </div><div class="line">	// 所有数据行都已经接收完毕    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h4 id="通过-Streams2-管道输出"><a href="#通过-Streams2-管道输出" class="headerlink" title="通过 Streams2 管道输出"></a>通过 Streams2 管道输出</h4><pre><code>通过管道将查询结果输出到另一个流（最大缓冲 5 个对象）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.query(&apos;SELECT * FROM posts&apos;)    </div><div class="line">.stream(&#123;highWaterMark: 5&#125;)    </div><div class="line">.pipe(...);</div></pre></td></tr></table></figure>
</code></pre><h4 id="多语句查询"><a href="#多语句查询" class="headerlink" title="多语句查询"></a>多语句查询</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 开启多语句查询</div><div class="line">var connection = mysql.createConnection(&#123;multipleStatements: true&#125;);</div><div class="line">connection.query(&apos;SELECT 1; SELECT 2&apos;, function(err, results) &#123;    </div><div class="line">	if (err) throw err;    </div><div class="line">	// `results` is an array with one element for every statement in the query:     </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>先使用var connection = mysql.createConnection方法一个数据库连接的配置项</li>
<li>使用connection.connect方法连接数据库</li>
<li>使用sql语句对数据库进行CURD操作</li>
<li>操作完成后需使用connection.end方法断开数据库连接<br>connection.end(function (err) { … }); // 支持回调<br>connection.destroy(); // 该方法会立即终止底层套接字（underlying socket）。另外，destroy()不会触发更多的事件和回调函数。<blockquote>
<p>参考文档：<br><a href="http://www.runoob.com/nodejs/nodejs-mysql.html" target="_blank" rel="external">Node.js 连接 MySQL</a><br><a href="http://www.techug.com/post/node-mysql-node-js.html" target="_blank" rel="external">如何在node.js里连接和使用mysql</a><br><a href="https://github.com/mysqljs/mysql" target="_blank" rel="external">mysqljs</a><br><a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="external">mysql</a></p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可视化工具：navicat for MySQL&lt;/p&gt;
&lt;h3 id=&quot;node和mysql的配合&quot;&gt;&lt;a href=&quot;#node和mysql的配合&quot; class=&quot;headerlink&quot; title=&quot;node和mysql的配合&quot;&gt;&lt;/a&gt;node和mysql的配合&lt;/h
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="mysql" scheme="https://fanerge.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="node" scheme="https://fanerge.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>grid布局</title>
    <link href="https://fanerge.github.io/2017/09/11/grid%E5%B8%83%E5%B1%80/"/>
    <id>https://fanerge.github.io/2017/09/11/grid布局/</id>
    <published>2017-09-11T12:09:01.000Z</published>
    <updated>2017-09-11T14:44:16.941Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设置在网格容器上的属性"><a href="#设置在网格容器上的属性" class="headerlink" title="设置在网格容器上的属性"></a>设置在网格容器上的属性</h4><pre><code>display: grid | inline-grid | subgrid;
grid-template-columns
grid-template-rows
grid-template-areas
grid-column-gap
grid-row-gap
grid-gap
justify-items
align-items
align-content
grid-auto-columns
grid-auto-rows
grid-auto-flow
grid
</code></pre><h4 id="设置在网格项上的属性"><a href="#设置在网格项上的属性" class="headerlink" title="设置在网格项上的属性"></a>设置在网格项上的属性</h4><pre><code>grid-column-start
grid-column-end
grid-row-start
grid-row-end
grid-column
grid-row
grid-area
justify-self
align-self
</code></pre><h4 id="显式的网格"><a href="#显式的网格" class="headerlink" title="显式的网格"></a>显式的网格</h4><h5 id="html"><a href="#html" class="headerlink" title="html"></a>html</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;section class=&quot;grid&quot;&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</div><div class="line">&lt;/section&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.grid &#123;</div><div class="line">	display: grid; </div><div class="line">	grid-template-columns: 1fr 2fr 3fr; // 指定3个列，分别指定每个列的宽度（1/6, 2/6, 3/6）。</div><div class="line">	grid-template-rows: 100px 100px; // 指定2行，分别指定每个行的宽度</div><div class="line">	grid-gap: 20px 10px; // 指定行间距和列间距（若只有一个参数是行和类间距取相同值）</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="重复轨道"><a href="#重复轨道" class="headerlink" title="重复轨道"></a>重复轨道</h4><h5 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.grid &#123;</div><div class="line">	display: grid;</div><div class="line">	grid-template-columns: repeat(3, 1fr 2fr); // 第一个参数指定的是重复次数，第二个参数是每次重复的轨道列表（共3*2=6列）。</div><div class="line">	grid-template-rows: 100px 100px;</div><div class="line">	grid-gap: 20px 1px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="自动重复轨道"><a href="#自动重复轨道" class="headerlink" title="自动重复轨道"></a>自动重复轨道</h4><h5 id="css-2"><a href="#css-2" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.grid &#123;</div><div class="line">	display: grid;</div><div class="line">	grid-template-columns: repeat(auto-fill, 100px); // auto-fill关键词创建了许多与网格容器相匹配的轨道，而不会导致网格溢出。</div><div class="line">	grid-template-rows: 100px 100px;</div><div class="line">	grid-gap: 20px 10px;</div><div class="line">&#125;</div><div class="line">.grid &#123;</div><div class="line">	display: grid;</div><div class="line">	grid-template-columns: repeat(auto-fit, 100px); // auto-fit关键词与auto-fill有点类似，只是在网格项放置之后，它只会在需要时创建尽可能多的轨道，而重复的空轨道会堆叠在一起（合并）。</div><div class="line">	grid-template-rows: 100px 100px;</div><div class="line">	grid-gap: 20px 10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="隐式网格"><a href="#隐式网格" class="headerlink" title="隐式网格"></a>隐式网格</h4><pre><code>如果网格中有更多的网格项，或者网格项被放置在显式网格之外，网格容器就会通过向网格中添加网格线来自动生成网格轨道。
显式网格和这些额外的隐式轨道和网格线构成了所谓的隐式网格。
</code></pre><h5 id="css-3"><a href="#css-3" class="headerlink" title="css"></a>css</h5><pre><code>对于子项目
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.item:first-child &#123;</div><div class="line">	grid-column-start: -1;</div><div class="line">&#125;</div><div class="line">.item:nth-child(2) &#123;</div><div class="line">	grid-row-start: 4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="隐式轨道尺寸"><a href="#隐式轨道尺寸" class="headerlink" title="隐式轨道尺寸"></a>隐式轨道尺寸</h4><h5 id="css-4"><a href="#css-4" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.grid &#123; </div><div class="line">	display: grid; </div><div class="line">	grid-template-columns: repeat(4, 1fr); </div><div class="line">	grid-template-rows: 100px 100px; </div><div class="line">	grid-gap: 20px; </div><div class="line">	grid-auto-columns: 200px; </div><div class="line">	grid-auto-rows: 60px; </div><div class="line">	grid-auto-columns: minmax(200px, auto); // 隐藏轨道现在最小宽度是200px</div><div class="line">	grid-auto-rows: minmax(auto, 300px); // 隐藏轨道现在最大高度度是300px</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="将网格扩展到开始"><a href="#将网格扩展到开始" class="headerlink" title="将网格扩展到开始"></a>将网格扩展到开始</h4><h5 id="css-5"><a href="#css-5" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.item:first-child &#123;</div><div class="line">  grid-row-end: 1;</div><div class="line">  grid-row-start: span 3; // 开始跨越3个单元格</div><div class="line">&#125;</div><div class="line">.item:nth-child(2) &#123;</div><div class="line">  grid-column-end: 2;</div><div class="line">  grid-column-start: span 2; // 开始跨越2个单元格</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="自动放置"><a href="#自动放置" class="headerlink" title="自动放置"></a>自动放置</h4><h5 id="css-6"><a href="#css-6" class="headerlink" title="css"></a>css</h5><p>我们可以通过使用grid-auto-flow属性来指定如何把网格项目自动放置到网格容器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.grid2 &#123;</div><div class="line">	grid-auto-flow: column;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="未定义显式网格"><a href="#未定义显式网格" class="headerlink" title="未定义显式网格"></a>未定义显式网格</h4><p>使用grid-auto-rows和grid-auto-columns可以自动地调整单元格大小，因此不需要定义显式网格。</p>
<blockquote>
<p>   参考文档</p>
<ol>
<li><a href="http://www.w3cplus.com/css3/difference-explicit-implicit-grids.html" target="_blank" rel="external">显式网格和隐式网格的区别 </a>    </li>
<li><a href="http://www.jianshu.com/p/d183265a8dad" target="_blank" rel="external">Grid布局指南</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;设置在网格容器上的属性&quot;&gt;&lt;a href=&quot;#设置在网格容器上的属性&quot; class=&quot;headerlink&quot; title=&quot;设置在网格容器上的属性&quot;&gt;&lt;/a&gt;设置在网格容器上的属性&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;display: grid | inline-gri
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="布局" scheme="https://fanerge.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>node-学习（七天学会NodeJs）</title>
    <link href="https://fanerge.github.io/2017/09/05/node-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/05/node-学习/</id>
    <published>2017-09-05T14:32:47.000Z</published>
    <updated>2017-09-05T14:43:17.292Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NodeJs基础"><a href="#NodeJs基础" class="headerlink" title="NodeJs基础"></a>NodeJs基础</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><pre><code>在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。
</code></pre><h6 id="require"><a href="#require" class="headerlink" title="require"></a>require</h6><pre><code>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var foo1 = require(&apos;./foo&apos;);</div><div class="line">var foo2 = require(&apos;./foo.js&apos;);</div><div class="line">var foo3 = require(&apos;/home/user/foo&apos;);</div><div class="line">var foo4 = require(&apos;/home/user/foo.js&apos;);</div><div class="line">// foo1至foo4中保存的是同一个模块的导出对象。</div></pre></td></tr></table></figure>

还可以加载使用JSON文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var data = require(&apos;./data.json&apos;);</div></pre></td></tr></table></figure>
</code></pre><h6 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h6><pre><code>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。
以下例子中导出了一个公有方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = function () &#123;</div><div class="line">	console.log(&apos;fanerge&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h6 id="module"><a href="#module" class="headerlink" title="module"></a>module</h6><pre><code>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。
例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = function () &#123;</div><div class="line">	console.log(&apos;fanerge&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h4 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h4><h5 id="模块路径的解析规则（先后顺序）"><a href="#模块路径的解析规则（先后顺序）" class="headerlink" title="模块路径的解析规则（先后顺序）"></a>模块路径的解析规则（先后顺序）</h5><ol>
<li>内置模块<br>如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(‘fs’)。</li>
<li><p>node_modules目录（第三方包）<br>NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/user/node_modules/foo/bar</div><div class="line">/home/node_modules/foo/bar</div><div class="line">/node_modules/foo/bar</div></pre></td></tr></table></figure>
</li>
<li><p>NODE_PATH环境变量<br>与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_PATH=/home/user/lib:/home/lib</div></pre></td></tr></table></figure>
<p>当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/home/user/lib/foo/bar</div><div class="line">/home/lib/foo/bar</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h5><pre><code>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。
示例一个标准包：
-cat:
    doc -- 包说明文档
    -lib -- 包具体代码
        head.js
        body.js
        index.js -- 入口文件
    tests -- 测试用例
    package.json -- 包的说明及依赖关系
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// index.js具体代码</div><div class="line">var head = require(&apos;./head&apos;);</div><div class="line">var body = require(&apos;./body&apos;);</div><div class="line">exports.create = function (name) &#123;</div><div class="line">	return &#123;</div><div class="line">		name: name,</div><div class="line">		head: head.create(),</div><div class="line">		body: body.create()</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line">// package.json具体代码</div><div class="line">&#123;</div><div class="line">	&quot;name&quot;: &quot;cat&quot;,</div><div class="line">	&quot;main&quot;: &quot;./lib/index.js&quot; // 入口模块位置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h5><pre><code>一个标准的工程目录
/home/user/workspace/node-echo/ # 工程目录
    -bin/                       # 存放命令行相关代码
        node-echo
    +doc/                       # 存放文档
    -lib/                       # 存放API相关代码
        echo.js
    -node_modules/              # 存放第三方包
        babel
    +tests/                     # 存放测试用例
    package.json                # 元数据文件
    README.md                    # 说明文件
</code></pre><h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><pre><code>安装第三方包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install argv</div></pre></td></tr></table></figure>

安装第三方包（特定版本）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install argv@0.0.1</div></pre></td></tr></table></figure>

批量安装
还可以在package.json中dependencies字段中写入所有依赖包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">       &quot;argv&quot;: &quot;0.0.2&quot;,</div><div class="line">	...</div><div class="line">   &#125;</div><div class="line">// 在使用指令批量安装</div><div class="line">npm install</div></pre></td></tr></table></figure>

更新包
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm update &lt;package&gt;</div></pre></td></tr></table></figure>

清除NPM本地缓存
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm cache clear（用于对付使用相同版本号发布新版本代码的人）</div></pre></td></tr></table></figure>
</code></pre><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="文件拷贝练手"><a href="#文件拷贝练手" class="headerlink" title="文件拷贝练手"></a>文件拷贝练手</h5><pre><code>// copy.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">function copy(src, dst) &#123;</div><div class="line">	fs.writeFileSync(dst, fs.readFileSync(src));</div><div class="line">&#125;</div><div class="line">function main(argv) &#123;</div><div class="line">	copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line">main(process.argv.slice(0, 2));</div><div class="line">// 进行拷贝</div><div class="line">node copy.js</div></pre></td></tr></table></figure>

以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。
process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径
</code></pre><h5 id="文件操作有关的API"><a href="#文件操作有关的API" class="headerlink" title="文件操作有关的API"></a>文件操作有关的API</h5><h6 id="Buffer（数据块）"><a href="#Buffer（数据块）" class="headerlink" title="Buffer（数据块）"></a>Buffer（数据块）</h6><pre><code>NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 构造一个Buffer实例</div><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">// Buffer实例具有length属性和bin[index]</div><div class="line">bin[0]; // =&gt; 0x68;</div><div class="line">// Buffer实例转化指定编码的字符串</div><div class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</div><div class="line">// 将字符串转化为指定编码的二进制数据</div><div class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div><div class="line">// Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。</div><div class="line">// 至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。</div></pre></td></tr></table></figure>

Buffer拷贝的例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。</div><div class="line">// 这个类似于申请一块新的内存，并把已有内存中的数据复制过去。</div><div class="line">var bin = new Buffer([0x68, 0x65, 0x6c, 0x6c, 0x6f]);</div><div class="line">var dup = new Buffer(bin.length);</div><div class="line">bin.copy(dup);</div><div class="line">dup[0] =0x46;</div><div class="line">console.log(bin, dup);</div></pre></td></tr></table></figure>
</code></pre><h6 id="Stream（数据流）"><a href="#Stream（数据流）" class="headerlink" title="Stream（数据流）"></a>Stream（数据流）</h6><pre><code>Stream的使用场景：
</code></pre><ol>
<li>当内存中无法一次装下需要处理的数据时。</li>
<li>一边读取一边处理更加高效时，我们就需要用到数据流。<br>实例–将a.js拷贝到b.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var rs = fs.createReadStream(process.argv[1].slice(0, -7) + &apos;a.js&apos;);</div><div class="line">var ws = fs.createWriteStream(process.argv[1].slice(0, -7) + &apos;b.js&apos;);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">	// 传入的数据是否写入目标</div><div class="line">	if (ws.write(chunk) === false) &#123;</div><div class="line">			rs.pause();</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">	ws.end();</div><div class="line">&#125;);</div><div class="line">// 判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了</div><div class="line">ws.on(&apos;drain&apos;, function () &#123;</div><div class="line">	rs.resume();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="File-System（文件系统）"><a href="#File-System（文件系统）" class="headerlink" title="File System（文件系统）"></a>File System（文件系统）</h6><pre><code>NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：
</code></pre><ol>
<li>文件属性读写。<br>其中常用的有fs.stat、fs.chmod、fs.chown等等。</li>
<li>文件内容读写。<br>其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。</li>
<li><p>底层文件操作。<br>其中常用的有fs.open、fs.read、fs.write、fs.close等等<br>同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。<br>// 异步处理文件及异常处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">fs.readFile(process.argv[1].slice(0, -7) + &apos;a.js&apos;, function (error, data) &#123;</div><div class="line">	if (error) &#123;</div><div class="line">		console.error(error);</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(data);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>// 同步处理文件及异常处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">try&#123;</div><div class="line">	var data = fs.readFileSync(process.argv[1].slice(0, -7) + &apos;a.js&apos;);</div><div class="line">	console.log(data);</div><div class="line">&#125;catch(err)&#123;</div><div class="line">	console.error(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="Path（路径）"><a href="#Path（路径）" class="headerlink" title="Path（路径）"></a>Path（路径）</h6><pre><code>NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。
path.normalize(str)
    将传入的路径转换为标准路径，除了解析路径中的.与..外，还能去掉多余的斜杠。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var path = require(&apos;path&apos;);</div><div class="line">var cache = &#123;&#125;;</div><div class="line">function store (key, value) &#123;</div><div class="line">	cache[path.normalize(key)] = value;</div><div class="line">	console.dir(cache);</div><div class="line">&#125;</div><div class="line">store(&apos;/home&apos;, 1);</div><div class="line">store(&apos;/home/user&apos;, 44);</div><div class="line">// 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &apos;/&apos;)再替换一下标准路径。</div></pre></td></tr></table></figure>

path.join()
将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</div></pre></td></tr></table></figure>

path.extname()
当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</div></pre></td></tr></table></figure>
</code></pre><h5 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h5><pre><code>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。
</code></pre><h6 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h6><pre><code>计算N的阶乘
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function factorial (n) &#123;</div><div class="line">	if (n === 1) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return n * factorial(n-1);	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</div></pre></td></tr></table></figure>
</code></pre><h6 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h6><pre><code>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。
同步遍历
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function travel (dir, callback) &#123;</div><div class="line">	try &#123;</div><div class="line">		fs.readdirSync(dir).forEach(function (file) &#123;</div><div class="line">			var pathname = path.join(dir, file);</div><div class="line">			if (fs.statSync(pathname).isDirectory()) &#123;</div><div class="line">				travel(pathname, callback);</div><div class="line">			&#125; else &#123;</div><div class="line">				callback(pathname);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;catch(e)&#123;</div><div class="line">		console.error(e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

异步遍历（有点复杂）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback, finish) &#123;</div><div class="line">	fs.readdir(dir, function (err, files) &#123;</div><div class="line">		(function next(i) &#123;</div><div class="line">			if (i &lt; files.length) &#123;</div><div class="line">				var pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">				fs.stat(pathname, function (err, stats) &#123;</div><div class="line">					if (stats.isDirectory()) &#123;</div><div class="line">						travel(pathname, callback, function () &#123;</div><div class="line">							next(i + 1);</div><div class="line">						&#125;);</div><div class="line">					&#125; else &#123;</div><div class="line">						callback(pathname, function () &#123;</div><div class="line">							next(i + 1);</div><div class="line">						&#125;);</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125; else &#123;</div><div class="line">				finish &amp;&amp; finish();</div><div class="line">			&#125;</div><div class="line">		&#125;(0));</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h5><p>我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。</p>
<h6 id="BOM的移除"><a href="#BOM的移除" class="headerlink" title="BOM的移除"></a>BOM的移除</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function readText (pathname) &#123;</div><div class="line">	var bin = fs.readFileAync(pathname);</div><div class="line">	if (bin[0] === 0xFF &amp;&amp; bin[1] === oxBB &amp;&amp; bin[2] === 0xBF) &#123;</div><div class="line">		bin = bin.slice(3);</div><div class="line">	&#125;</div><div class="line">	return bin.toString(&apos;utf-8&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="GBK转UTF8"><a href="#GBK转UTF8" class="headerlink" title="GBK转UTF8"></a>GBK转UTF8</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 第三方包转换编码</div><div class="line">var iconv = require(&apos;iconv-lite&apos;); </div><div class="line">function readGBKText(pathname) &#123;</div><div class="line">	var bin = fs.readFileSync(pathname);</div><div class="line">	return iconv.decode(bin, &apos;gbk&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h6><pre><code>不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function replace(pathname) &#123;</div><div class="line">	var str = fs.readFileSync(pathname, &apos;binary&apos;);</div><div class="line">	str = str.replace(&apos;foo&apos;, &apos;bar&apos;);</div><div class="line">	fs.writeFileSync(pathname, str, &apos;binary&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h4><h5 id="例子开启一个服务"><a href="#例子开启一个服务" class="headerlink" title="例子开启一个服务"></a>例子开启一个服务</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text-plain&apos;&#125;);</div><div class="line">	response.end(&apos;Hello world\n&apos;);</div><div class="line">&#125;).listen(8734);</div><div class="line">// 以上程序创建了一个HTTP服务器并监听8734端口，打开浏览器访问该端口http://127.0.0.1:8124/就能够看到效果。</div></pre></td></tr></table></figure>
</code></pre><h5 id="网络相关的API"><a href="#网络相关的API" class="headerlink" title="网络相关的API"></a>网络相关的API</h5><h6 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h6><pre><code>&apos;http&apos;模块提供两种使用方式：
</code></pre><ol>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。<br>在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。<br>除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	var body = [];</div><div class="line">	console.log(request.method);</div><div class="line">	console.log(request.headers);</div><div class="line">	request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">		body.push(chunk);</div><div class="line">	&#125;);</div><div class="line">	request.on(&apos;end&apos;, function () &#123;</div><div class="line">		body = Buffer.concat(body);</div><div class="line">		console.log(body.toString());</div><div class="line">	&#125;);</div><div class="line">&#125;).listen(8734);</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h6><pre><code>https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。
创建一个HTTPS服务器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">       key: fs.readFileSync(&apos;./ssl/default.key&apos;),</div><div class="line">       cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</div><div class="line">   &#125;;</div><div class="line">var server = https.createServer(options, function (request, response) &#123;</div><div class="line">		// ...</div><div class="line">&#125;);</div><div class="line">// 与创建HTTP服务器相比，多了一个options对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。</div></pre></td></tr></table></figure>

另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server.addContext(&apos;foo.com&apos;, &#123;</div><div class="line">	key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;),</div><div class="line">	cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h6 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h6><pre><code>处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。
</code></pre><ol>
<li><p>url.parse()<br>将一个URL字符串转换为URL对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var url = require(&apos;url&apos;, [boolean], [boolean]);</div><div class="line">console.log(url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;));</div><div class="line">第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。</div><div class="line">第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如//www.example.com/foo/bar。</div></pre></td></tr></table></figure>
</li>
<li><p>url.format()<br>允许将一个URL对象转换为URL字符串</p>
</li>
<li>url.resolve()<br>可以用于拼接URL<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dd = url.resolve(&apos;http://www.baidu.com/yzf/age/sex&apos;, &apos;../va&apos;);</div><div class="line">// http://www.baidu.com/yzf/va</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="Query-String"><a href="#Query-String" class="headerlink" title="Query String"></a>Query String</h6><pre><code>querystring模块用于实现URL参数字符串与参数对象的互相转换.
querystring.parse()
    将字符串参数转化为对象URL参数
querystring.stringify()
    将参数对象转化为URL参数字符串
</code></pre><h6 id="Zlib"><a href="#Zlib" class="headerlink" title="Zlib"></a>Zlib</h6><pre><code>zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。
例子：使用zlib模块压缩HTTP响应体数据。
这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据。
zlib.gzip()
    数据压缩
zlib.gunzip()
    数据解压
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	let i = 1024,</div><div class="line">		data = &apos;&apos;;</div><div class="line">	while (i--) &#123;</div><div class="line">		data += &apos;x&apos;;</div><div class="line">	&#125;</div><div class="line">	if (request.headers[&apos;accept-encoding&apos;].includes(&apos;gzip&apos;)) &#123;</div><div class="line">		zlib.gzip(data, function (err, data) &#123;</div><div class="line">			response.writeHead(200, &#123;</div><div class="line">				&apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">				&apos;Content-Encoding&apos;: &apos;gzip&apos;</div><div class="line">			&#125;);</div><div class="line">			response.end(data);</div><div class="line">		&#125;)</div><div class="line">	&#125; else &#123;</div><div class="line">		response.writeHead(200, &#123;</div><div class="line">			&apos;Content-Type&apos;: &apos;text/plain&apos;</div><div class="line">		&#125;);</div><div class="line">		response.end(data);</div><div class="line">	&#125;</div><div class="line">&#125;).listen(8888);</div></pre></td></tr></table></figure>
</code></pre><h6 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h6><pre><code>net模块可用于创建Socket服务器或Socket客户端。
使用Socket搭建一个HTTP服务器的例子。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net.createServer(function (conn) &#123;</div><div class="line">	conn.on(&apos;data&apos;, function (data) &#123;</div><div class="line">		conn.write([</div><div class="line">			&apos;HTTP/1.1 200 OK&apos;,</div><div class="line">			&apos;Content-Type: text/plain&apos;,</div><div class="line">			&apos;Content-Length: 12&apos;,</div><div class="line">			&apos;&apos;,</div><div class="line">			&apos;Hello World&apos;</div><div class="line">		].join(&apos;\n&apos;));</div><div class="line">	&#125;);</div><div class="line">&#125;).listen(8888);</div></pre></td></tr></table></figure>
</code></pre><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><pre><code>NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。
node.js调用终端简化目录拷贝
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var child_process = require(&apos;child_process&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">function copy(source, target, callback) &#123;</div><div class="line">	child_process.exec(</div><div class="line">		util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</div><div class="line">&#125;</div><div class="line">copy(process.argv[1].slice(0, -7) + &apos;copy1&apos;, process.argv[1].slice(0, -7) + &apos;copy2&apos;, function (err, data) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(err)</div><div class="line">	&#125;</div><div class="line">	console.log(data)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h5><pre><code>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。
另外需要注意的是，process不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。
</code></pre><h5 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h5><pre><code>使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。
</code></pre><h5 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h5><pre><code>cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。
</code></pre><p>应用场景</p>
<ol>
<li>如何获取命令行参数<br>  在NodeJS中可以通过process.argv获取命令行参数。<br>  但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。<br>  一般这样获取：process.argv.slice(2)</li>
<li><p>如何退出程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">	// ...</div><div class="line">&#125; catch (err) &#123;</div><div class="line">	// ...</div><div class="line">	process.exit(1); // 返回特定的状态码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如何控制输入输出<br>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr，<br>第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。</p>
</li>
<li><p>如何降权<br>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http.createServer(callback).listen(80, function () &#123;</div><div class="line">	var env = process.env,</div><div class="line">		uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</div><div class="line">		gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</div><div class="line">	process.setgid(gid);</div><div class="line">	process.setuid(uid);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如何创建子进程<br>创建NodeJS子进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;a.js&apos; ]);</div><div class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</div><div class="line">	console.log(&apos;stdout: &apos; + data);</div><div class="line">&#125;);</div><div class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</div><div class="line">	console.log(&apos;stderr: &apos; + data);</div><div class="line">&#125;);</div><div class="line">child.on(&apos;close&apos;, function (code) &#123;</div><div class="line">	console.log(&apos;child process exited with code &apos; + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>进程间如何通讯    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</div><div class="line"></div><div class="line">child.kill(&apos;SIGTERM&apos;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">	cleanUp();</div><div class="line">	process.exit(0);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>进程间如何通讯<br>如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</div><div class="line">		stdio: [ 0, 1, 2, &apos;ipc&apos; ]</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">child.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">	console.log(msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">	msg.hello = msg.hello.toUpperCase();</div><div class="line">	process.send(msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如何守护子进程<br>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function spawn(mainModule) &#123;</div><div class="line">	var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</div><div class="line">	worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">		if (code !== 0) &#123;</div><div class="line">			spawn(mainModule);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">spawn(&apos;worker.js&apos;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><pre><code>NodeJS最大的卖点——事件机制和异步IO。
</code></pre><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><pre><code>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(function () &#123;</div><div class="line">	console.log(&apos;我是setTimeout&apos;)</div><div class="line">&#125;, 1000);</div><div class="line">console.log(&apos;hello&apos;);</div></pre></td></tr></table></figure>

理解js中如何实现异步
    JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的
    事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。
    我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。
    也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。
</code></pre><h5 id="代码设计模式"><a href="#代码设计模式" class="headerlink" title="代码设计模式"></a>代码设计模式</h5><h6 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h6><pre><code>使用一个函数的输出作为另一个函数的输入是很常见的需求。
同步方式编写代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var output = fn1(fn2(&apos;input&apos;));</div></pre></td></tr></table></figure>

异步方式编写代码：
由于函数执行结果不是通过返回值，而是通过回调函数传递。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fn2(&apos;input&apos;, function (output2) &#123;</div><div class="line">	fn1(output2, function (output1) &#123;</div><div class="line">		// do something</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h6 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h6><pre><code>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。
同步方式编写代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var len = arr.length;</div><div class="line">for (let i = 0; i &lt; len; i++) &#123;</div><div class="line">	arr[i] = sync(arr[i]);</div><div class="line">&#125;</div><div class="line">// 所有的数组项处理完，打算做的事</div></pre></td></tr></table></figure>

异步方式编写代码(异步串行遍历)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">((function next (i, len, callback) &#123;</div><div class="line">	if (i &lt; len) &#123;</div><div class="line">		async(arr[i], function (value) &#123;</div><div class="line">			arr[i] = value;</div><div class="line">			next(i + 1, len, callback);</div><div class="line">		&#125;);</div><div class="line">	&#125; else &#123;</div><div class="line">		callback();</div><div class="line">	&#125;</div><div class="line">&#125;)(0, arr.length, function () &#123;</div><div class="line">	// 所有的数组项处理完，打算做的事</div><div class="line">&#125;));</div></pre></td></tr></table></figure>

异步方式编写代码(异步并行遍历)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">((function (i, len, count, callback) &#123;</div><div class="line">	for (; i &lt; len; i++) &#123;</div><div class="line">		(function (i) &#123;</div><div class="line">			async(arr[i], function (value) &#123;</div><div class="line">				arr[i] = value;</div><div class="line">				if (++count === len) &#123;</div><div class="line">					callback();</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;)(i);</div><div class="line">	&#125;</div><div class="line">&#125;)(0, arr.length, 0, function () &#123;</div><div class="line">	// 所有的数组项处理完，打算做的事</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
</code></pre><h6 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h6><pre><code>JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。
同步异常处理：
因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function sync(fn) &#123;</div><div class="line">	return fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">	sync(null);</div><div class="line">	// Do something.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">	console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

异步异常处理：
但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。
因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。
</code></pre><h5 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h5><pre><code>NodeJS提供了domain模块，可以简化异步代码的异常处理。
一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</div><div class="line">	console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(function (fn) &#123;</div><div class="line">	fn();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

使用domain模块创建一个子域（JS子运行环境）。
在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的error事件统一捕获。
我们使用.create方法创建了一个子域对象，并通过.run方法进入需要在子域中运行的代码的入口点。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">	// Do something.</div><div class="line">	asyncA(request, function (data) &#123;</div><div class="line">		// Do something</div><div class="line">		asyncB(request, function (data) &#123;</div><div class="line">			// Do something</div><div class="line">			asyncC(request, function (data) &#123;</div><div class="line">				// Do something</div><div class="line">				callback(data);</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">	var d = domain.create(); // 创建子域</div><div class="line"></div><div class="line">	d.on(&apos;error&apos;, function () &#123;</div><div class="line">		response.writeHead(500);</div><div class="line">		response.end();</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	d.run(function () &#123; // 子域运行入口</div><div class="line">		async(request, function (data) &#123;</div><div class="line">			response.writeHead(200);</div><div class="line">			response.end(data);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><pre><code>无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。    
</code></pre><p>参考书籍：<br>    <a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJs</a><br>    <a href="http://nodejs.cn/api/" target="_blank" rel="external">node中文</a><br>代码仓库：<a href="https://github.com/fanerge/7day-NodeJs.git" target="_blank" rel="external">node学习源代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NodeJs基础&quot;&gt;&lt;a href=&quot;#NodeJs基础&quot; class=&quot;headerlink&quot; title=&quot;NodeJs基础&quot;&gt;&lt;/a&gt;NodeJs基础&lt;/h4&gt;&lt;h5 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>css加强（多形状图像和心跳灯和竖着排的文字和面包屑导航）</title>
    <link href="https://fanerge.github.io/2017/09/04/css%E5%8A%A0%E5%BC%BA-5/"/>
    <id>https://fanerge.github.io/2017/09/04/css加强-5/</id>
    <published>2017-09-04T13:55:45.000Z</published>
    <updated>2017-09-04T15:21:05.875Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="多形状图像"><a href="#多形状图像" class="headerlink" title="多形状图像"></a>多形状图像</h4><pre><code>可以实现多形状图像
border-radius: top right bottom left;
</code></pre><h4 id="心跳灯"><a href="#心跳灯" class="headerlink" title="心跳灯"></a>心跳灯</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.heartbeat &#123;</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	background: red;</div><div class="line">	animation: heartbeat .83s ease-in-out infinite;</div><div class="line">&#125;</div><div class="line">@keyframes heartbeat &#123;</div><div class="line">	from &#123;</div><div class="line">		opacity:0.1;</div><div class="line">	&#125;</div><div class="line">	50% &#123;</div><div class="line">		opacity:1;</div><div class="line">	&#125;</div><div class="line">	to &#123;</div><div class="line">		opacity:0.1;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="竖着排的文字"><a href="#竖着排的文字" class="headerlink" title="竖着排的文字"></a>竖着排的文字</h4><pre><code>writing-mode: horizontal-tb | vertical-lr | vertical-rl;
    horizontal-tb表示水平方向自上而下的书写方式。
    vertical-rl表示垂直方向自右向左的书写方式
    vertical-lr表示垂直方向自左向右的书写方式
IE
writing-mode: lr-tb | tb-rl;
    lr-tb水平方向自左向右的书写方式
    tb-rl垂直方向自上而下的书写方式。
</code></pre><h4 id="首字母下沉"><a href="#首字母下沉" class="headerlink" title="首字母下沉"></a>首字母下沉</h4><pre><code>::first-letter伪元素选择器用于选取指定选择器的首字母。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p::first-letter &#123;</div><div class="line">	color:#c69c6d;</div><div class="line">	float:left;</div><div class="line">	font-size:5em;</div><div class="line">	margin:0 .2em 0 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css加强（表单和文本样式和动态边框和上传组件美化）</title>
    <link href="https://fanerge.github.io/2017/09/04/css%E5%8A%A0%E5%BC%BA-4/"/>
    <id>https://fanerge.github.io/2017/09/04/css加强-4/</id>
    <published>2017-09-04T11:31:38.000Z</published>
    <updated>2017-09-04T13:55:12.989Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="表单input"><a href="#表单input" class="headerlink" title="表单input"></a>表单input</h4><p>主要添加了过渡下border和验证提示<br><img src="/images/form.png" alt="表单中的input"></p>
<h5 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;input-field&quot;&gt;</div><div class="line">	&lt;input id=&quot;last-name&quot; type=&quot;text&quot; placeholder=&quot;name&quot;&gt;&lt;/input&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;!--带验证的--&gt;</div><div class="line">&lt;div class=&quot;input-field error input-field-icon&quot;&gt;</div><div class="line">	&lt;input id=&quot;last_name&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;&gt;</div><div class="line">	&lt;span class=&quot;gradient&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;i class=&quot;ion-android-close&quot;&gt;</div><div class="line">	&lt;/i&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>

解释：
.input-field成为容器层，input和span并列排列。
让span来充当input的下border，然后在通过为类选择器:focus和兄弟选择器和伪类元素span:after来完成
</code></pre><h5 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> *&#123;</div><div class="line">	box-sizing:border-box;</div><div class="line">&#125;</div><div class="line">.input-field &#123;</div><div class="line">	position: relative;</div><div class="line">	width: 200px;</div><div class="line">	margin: 20px 50px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-field input &#123;</div><div class="line">	background-color: transparent;</div><div class="line">	border: none;</div><div class="line">	border-radius: 0;</div><div class="line">	height: 35px;</div><div class="line">	width: 100%;</div><div class="line">	padding: 0;</div><div class="line">	box-shadow: none;</div><div class="line">	outline: none;</div><div class="line">	transition: all 0.3s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-field input+span &#123;</div><div class="line">	position: absolute;</div><div class="line">	top: 100%;</div><div class="line">	left: 0;</div><div class="line">	display: inline-block;</div><div class="line">	max-width: 100%;</div><div class="line">	z-index: 0;</div><div class="line">	width: 100%;</div><div class="line">	height: 1px;</div><div class="line">	border-bottom: 1px solid #d9d9d9;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-field span:after &#123;</div><div class="line">	content: &quot;&quot;;</div><div class="line">	position: absolute;</div><div class="line">	bottom: 0;</div><div class="line">	left: 0;</div><div class="line">	width: 100%;</div><div class="line">	height: 2px;</div><div class="line">	background: #2196f3;</div><div class="line">	transform: scale(0);</div><div class="line">	transition: all .2s ease-out;</div><div class="line">&#125;</div><div class="line">.input-field input:focus+span:after &#123;</div><div class="line">	transform: scale(1);</div><div class="line">&#125;</div><div class="line">.input-field.input-field-icon i&#123;</div><div class="line">	position:absolute;</div><div class="line">	right:0;</div><div class="line">	top:50%;</div><div class="line">	padding:0 5px;</div><div class="line">	font-size:1.5em;</div><div class="line">	-webkit-transform: translate(0, -50%);</div><div class="line">	transform: translate(0, -50%);</div><div class="line">&#125;</div><div class="line">.input-field.input-field-icon input&#123;</div><div class="line">	padding-right:30px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

这里有个小技巧：要是验证图标垂直居中，达到居中效果。
top: 50%; 相对于父元素的高度
transform: translate(0, -50%); 相对于自身元素的高度。
</code></pre><h4 id="自定义选择文本样式"><a href="#自定义选择文本样式" class="headerlink" title="自定义选择文本样式"></a>自定义选择文本样式</h4><pre><code>使用::selection伪类选择器，我们可以实现与众不同的选择文本样式。
注意：只能设置背景色和文字颜色，同时不支持渐变色。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">::selection &#123;</div><div class="line">	background: #009a61;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div><div class="line"></div><div class="line">::-moz-selection &#123;</div><div class="line">	background: #009a61;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div><div class="line"></div><div class="line">::-webkit-selection &#123;</div><div class="line">	background: #009a61;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="动态的边框"><a href="#动态的边框" class="headerlink" title="动态的边框"></a>动态的边框</h4><h5 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;dynamic-border dynamic-border-2&quot;&gt;</div><div class="line">	&lt;span&gt;</div><div class="line">	&lt;/span&gt;</div><div class="line">	&lt;img src=&quot;images/girl.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>

整体思路：
创建一个容器，容器自身两个伪类元素，span又包含两个伪类元素，可以动态生成容器的4个边框（相对+绝对定位）。
在加上过渡效果就OK了。第二个动态边框只要按不同时间延迟组合就好了。
</code></pre><h5 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"> *&#123;</div><div class="line">	box-sizing:border-box;</div><div class="line">&#125;</div><div class="line">.dynamic-border &#123;</div><div class="line">	position:relative;</div><div class="line">	width:200px;</div><div class="line">	height:200px;</div><div class="line">	background:gray;</div><div class="line">&#125;</div><div class="line">.dynamic-border:before,</div><div class="line">.dynamic-border:after,</div><div class="line">.dynamic-border span:first-child:before,</div><div class="line">.dynamic-border span:first-child:after &#123;</div><div class="line">	content:&quot;&quot;;</div><div class="line">	position:absolute;</div><div class="line">	background:red;</div><div class="line">	-webkit-transition:all .2s ease;</div><div class="line">	transition:all .2s ease;</div><div class="line">&#125;</div><div class="line">/*上边边框*/</div><div class="line">.dynamic-border:before &#123;</div><div class="line">	width:0; </div><div class="line">	top:-2px;</div><div class="line">	right:0;</div><div class="line">	height:2px;</div><div class="line">&#125;</div><div class="line">/*右边边框*/</div><div class="line">.dynamic-border:after &#123;</div><div class="line">	width:2px;</div><div class="line">	height:0;  </div><div class="line">	right:-2px;</div><div class="line">	bottom:0;</div><div class="line">&#125;</div><div class="line">/*下边边框*/</div><div class="line">.dynamic-border span:first-child:before &#123;</div><div class="line">	width:0;  </div><div class="line">	height:2px;</div><div class="line">	bottom:-2px;</div><div class="line">	left:0;</div><div class="line">&#125;</div><div class="line">/*左边边框*/</div><div class="line">.dynamic-border span:first-child:after &#123;</div><div class="line">	width:2px;</div><div class="line">	height:0;  </div><div class="line">	top:0;</div><div class="line">	left:-2px;</div><div class="line">&#125;</div><div class="line">/*鼠标移动上去时*/</div><div class="line">.dynamic-border:hover:before,</div><div class="line">.dynamic-border:hover span:first-child:before &#123;</div><div class="line">	width:calc(100% + 2px);</div><div class="line">&#125;</div><div class="line">.dynamic-border:hover:after,</div><div class="line">.dynamic-border:hover span:first-child:after &#123;</div><div class="line">	height:calc(100% + 2px);</div><div class="line">&#125;</div><div class="line">/*添加过渡延迟时间*/</div><div class="line">.dynamic-border-1:hover:before,</div><div class="line">.dynamic-border-1:hover span:first-child:before &#123;</div><div class="line">	-webkit-transition-delay:.2s;</div><div class="line">	transition-delay:.2s;</div><div class="line">&#125;</div><div class="line">.dynamic-border-2:hover span:first-child:before &#123;</div><div class="line">	-webkit-transition-delay:.2s;</div><div class="line">	transition-delay:.2s;</div><div class="line">&#125;</div><div class="line">.dynamic-border-2:hover:after &#123;</div><div class="line">	-webkit-transition-delay:.4s;</div><div class="line">	transition-delay:.4s;</div><div class="line">&#125;</div><div class="line">.dynamic-border-2:hover:before &#123;</div><div class="line">	-webkit-transition-delay:.6s;</div><div class="line">	transition-delay:.6s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="上传组件美化"><a href="#上传组件美化" class="headerlink" title="上传组件美化"></a>上传组件美化</h4><h5 id="创建模版-2"><a href="#创建模版-2" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;file file-input&quot;&gt;</div><div class="line">	&lt;div class=&quot;file-inner&quot;&gt;</div><div class="line">		选择文件</div><div class="line">		&lt;button class=&quot;btn btn-primary file-inner-btn&quot;&gt;</div><div class="line">			文件上传</div><div class="line">			&lt;i class=&quot;ion-ios-cloud-upload-outline&quot;&gt;</div><div class="line">			&lt;/i&gt;</div><div class="line">		&lt;/button&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;input type=&quot;file&quot; /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="设置CSS样式"><a href="#设置CSS样式" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">.file &#123;</div><div class="line">	position:relative;</div><div class="line">&#125;</div><div class="line">.file input &#123;</div><div class="line">	position:absolute;</div><div class="line">	top:0;</div><div class="line">	left:0;</div><div class="line">	opacity:0;</div><div class="line">	width:100%;</div><div class="line">	height:100%;</div><div class="line">&#125;</div><div class="line">.file-inner &#123;</div><div class="line">	position:relative;</div><div class="line">	width:250px;</div><div class="line">	height:35px;</div><div class="line">	border:1px solid #d9d9d9;</div><div class="line">	border-radius:5px;</div><div class="line">	padding-left:10px;</div><div class="line">	line-height:35px;</div><div class="line">&#125;</div><div class="line">.file-inner .file-inner-btn &#123;</div><div class="line">	position:absolute;</div><div class="line">	right:0;</div><div class="line">	top:0;</div><div class="line">	height:100%;</div><div class="line">	box-shadow:none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

解释；
这里就用了一个技巧，把input设置为opacity: 0;然后在绝对定位并设置宽高100%，这样就会是整个区域都触发file的input默认事件。
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css加强（进度条和遮罩条和切角）</title>
    <link href="https://fanerge.github.io/2017/09/03/css%E5%8A%A0%E5%BC%BA-3/"/>
    <id>https://fanerge.github.io/2017/09/03/css加强-3/</id>
    <published>2017-09-03T09:39:50.000Z</published>
    <updated>2017-09-03T13:47:49.913Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。<br>进度条<br>    <img src="./images/progress.png" alt="进度条"></p>
<h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><h5 id="创建进度条"><a href="#创建进度条" class="headerlink" title="创建进度条"></a>创建进度条</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	&lt;div class=&quot;fan-progress fan-striped fan-active&quot;&gt;</div><div class="line">		&lt;div class=&quot;fan-progress-bar&quot; style=&quot;width: 40%;&quot;&gt;40%&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	```	</div><div class="line">	解释：</div><div class="line">	1.	fan-progress为定义进度条的整体样式（背景）</div><div class="line">	2.	fan-striped为定义斑纹样式（背景）</div><div class="line">	3. 	fan-active为定义动态进度条样式（背景）</div><div class="line">	4.	fan-progress-bar为定义当前行进到样式</div><div class="line">#####	设置样式</div></pre></td></tr></table></figure>

* {
    box-sizing: border-box;
}
fan-progress {
    box-sizing: border-box;
    height: 20px;
    line-height: 20px;
    background: #f7f7f7;
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .08), inset 0 2px 2px rgba(0, 0, 0, .08);
    border-radius: 4px;
}
fan-progress-bar {
    width: 0;
    height: 100%;
    background: #009dd8;
    float: left;
    transition: width .6s ease;
    font-size: 12px;
    color: #fff;
    text-align: center;
    background-image: linear-gradient(to bottom, #oob4f5, #008dc5);
    box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .3), inset 0 0 0 1px rgba(0, 0, 0, .1);
    text-shadow: 0 -1px 0 rgba(0,0,0,.2);
}
/*条纹*/
.fan-progress-striped .fan-progress-bar {
    background-image:linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);
    background-size:30px 30px;
}
/*动态*/
.fan-progress-striped.fan-active .fan-progress-bar {
    animation: fan-progress-active 2s linear infinite;
}
@keyframes fan-progress-active {
    0% {
        background-position: 0 0;
    }
    100% {
        background-position: 30px 0;
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####	遮罩条</div><div class="line">	设计思路：</div><div class="line">1.	用一个DOM容器包图片</div><div class="line">2. 	遮罩条主要以容器的伪类来创建</div><div class="line">3.	通过hover效果和css3的transition和transform完成相应动画</div><div class="line">#####	创建DOM节点</div></pre></td></tr></table></figure>

&lt;div class=&quot;mask&quot; data-title=&quot;遮罩条&quot;&gt;
    &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot;&gt;
&lt;/div&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#####	设置样式</div></pre></td></tr></table></figure>

.mask {
    position: relative;
    width: 150px;
    height: 150px;
    overflow: hidden;
}   
.mask:before {
    content: attr(data-title);
    position: absolute;
    top: 100%;
    left: 0;
    padding: .7em 0;
    width: 100%;
    text-align: center;
    color: #fff;
    background: rgba(0,0,0,.5);
    transform: translate(0, 100%);
    transition: all .3s ease-in-out;
    opacity: 0;
}  
.mask:hover:before {
    top: 80%;
    transform: translate(0, 0);
    opacity: 1;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####	切角</div><div class="line">#####	创建DOM节点</div></pre></td></tr></table></figure>

&lt;div class=&quot;box corner&quot;&gt;单个切角&lt;/div&gt;
&lt;div class=&quot;box corner1&quot;&gt;多个切角&lt;/div&gt;
&lt;div class=&quot;box corner2&quot;&gt;多个园角&lt;/div&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#####	设置样式</div></pre></td></tr></table></figure>

.corner {
    background: linear-gradient(-45deg, transparent 15px, #58a 15px);
}
.corner1 {
    background: linear-gradient(135deg, transparent 15px, #58a 0) top left, 
        linear-gradient(-135deg, transparent 15px, #58a 0) top right, 
        linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,
        linear-gradient(45deg, transparent 15px, #58a 0) bottom left;
    background-size: 50% 50%;
    background-repeat: no-repeat;
}
.corner2 {
    background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, 
        radial-gradient(circle at top right, transparent 15px, #58a 0) top right, 
        radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, 
        radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;
    background-size: 50% 50%;
    background-repeat: no-repeat;
}
```
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>http缓存相关的知识</title>
    <link href="https://fanerge.github.io/2017/09/01/http%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/09/01/http缓存知识总结/</id>
    <published>2017-09-01T10:56:40.000Z</published>
    <updated>2017-09-01T10:56:51.213Z</updated>
    
    <content type="html"><![CDATA[<h4 id="http缓存整理"><a href="#http缓存整理" class="headerlink" title="http缓存整理"></a>http缓存整理</h4><h5 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h5><pre><code>当一个用户发送一个静态资源请求通过下面几步获取资源：
</code></pre><ol>
<li>当第一次发送请求时，http返回200的状态码。</li>
<li>在没有关闭缓存请求的时候，则返回header中返回包含last-Modified以及Etag和Expires的字段，然后将文件保存在Cache目录下。</li>
<li>后续请求该文件时，先本地查找该资源。如果本地缓存存在该资源，但不知道是否过期，则发送一个http请求到服务器，然后服务器来判断。<br>如果该文件没有改动，则返回304，继续使用本地资源。<br>如果该文件发生改动，服务器返回该资源并返回200。<br>如果服务器没有这个资源，则返回404。<h5 id="http头部缓存相关key"><a href="#http头部缓存相关key" class="headerlink" title="http头部缓存相关key"></a>http头部缓存相关key</h5><h6 id="request-header缓存相关"><a href="#request-header缓存相关" class="headerlink" title="request header缓存相关"></a>request header缓存相关</h6>cache-control：<br>  其缓存指令对于前端常用的有如下no-cache、no-store、max-age这几个值；<br>if-none-match：<br>  该字段与响应中的eTag一起使用，表示检查实体是否有更新改变;客户端第一次发送请求时候响应报文会包含字段Etag，表示资源状态，当资源改变后该值也会改变（客户端不必关心该值怎么生成）<br>  然后缓存保存下该字段，第二次已经有该缓存时候在浏览本地缓存时候会将该值赋给if-none-match字段发送给服务器，服务器将发送的值与当前的状态进行对比，<br>  如果值一样的话则答复304去使用缓存数据，如果值改变了则发送最新数据给客户端替代现有缓存数据，并且返回状态200;<br>if-modified-since:<br>  该字段与last-modified配合使用，跟上述原理差不多，都是响应端先返回一个last-modified时间字段，再次请求时候 request头部会将缓存中的last-modified字段拿出来赋给if-modified-since，<br>  发送给服务器，服务器去判断时间是否过期，如未过期则返回304，告诉客户使用缓存数据，如果过期则重新返回一个last-modified并且返回200；<h6 id="response-header缓存相关："><a href="#response-header缓存相关：" class="headerlink" title="response header缓存相关："></a>response header缓存相关：</h6>Etag：<br>  刚才也说过 是跟if-none-match配合去使用，它根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。<br>  使用Etag主要是为了解决根据时间无法解决的问题：比如文件修改频繁（秒之内修改），导致根据时间无法判断是否更新；以及修改时间变了，但是内容没变（我们应该认为该文件是没变的）<br>expires：<br>  表示缓存过期时间例如:expires:Mon Dec 30 2011 11:01:19 GMT，跟cache-control中的max-age作用一样，不过在碰见max-age之后，该值会被覆盖从而被max-age替代;<br>last-modified:<br>  表示文件最后修改时间；</li>
</ol>
<h5 id="实现有关前端对于缓存的操作"><a href="#实现有关前端对于缓存的操作" class="headerlink" title="实现有关前端对于缓存的操作"></a>实现有关前端对于缓存的操作</h5><h6 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h6><pre><code>方法一：
在服务器进行配置其max-age或者expires使其设置一个过期值为当前一年之后。这样每次进行检验时候都会使用缓存中文件。
例如在.htaccess中
&lt;IfModule mod_headers.c&gt;
 &lt;FilesMatch &quot;.(gif|jpg|jpeg|png|ico)$&quot;&gt;
Header set Cache-Control &quot;max-age=604800&quot;
 &lt;/FilesMatch&gt;
方法二：
前端设置if-modified-since去设置一个上次修改时间大于当前日期，
方法三：
服务器端根据etag去判断是否匹配来根据实际业务来使用缓存；
后面两个方法属于弱缓存数据头，需要浪费http连接，所以建议使用第一种方式;
</code></pre><h6 id="禁用缓存"><a href="#禁用缓存" class="headerlink" title="禁用缓存"></a>禁用缓存</h6><pre><code>方法一：
可以在meta标签标明
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 
方法二：
也可以动态去setRequestHeader，强制不用缓存设置组合如下：
cache-control=&apos;no-cache,no-store&apos;
pragma=&apos;no-cache&apos;
if-modified-since=0;
方法三：
请求端设置if-modified-since为已经过期的某个时间，可以是几年前或者几十年前。
方法四：
服务端设置Expires为过期某个时间，例如PHP中header(&quot;Expires: Mon, 26 Jul 1997 05:00:00 GMT&quot;);
实际开发中如果需要一致性检测则尽量去配合Etag以及last-Modified去进行比较然后返回使用缓存还是新数据;这个有点偏服务器端了，不再赘述
方法五：
url后面加随机数或者时间戳url += “&amp;random=” + Math.random()这个方法js以及PHP经常用，原理就是每个请求的url都不一样这样一来缓存中找不到对应数据，就自动去服务器寻找最新资源;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;http缓存整理&quot;&gt;&lt;a href=&quot;#http缓存整理&quot; class=&quot;headerlink&quot; title=&quot;http缓存整理&quot;&gt;&lt;/a&gt;http缓存整理&lt;/h4&gt;&lt;h5 id=&quot;缓存过程&quot;&gt;&lt;a href=&quot;#缓存过程&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="http" scheme="https://fanerge.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://fanerge.github.io/tags/http/"/>
    
      <category term="缓存" scheme="https://fanerge.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>css加强（单选复选Switch、Loading）</title>
    <link href="https://fanerge.github.io/2017/08/30/css%E5%8A%A0%E5%BC%BA-2/"/>
    <id>https://fanerge.github.io/2017/08/30/css加强-2/</id>
    <published>2017-08-30T13:36:57.000Z</published>
    <updated>2017-08-31T14:41:41.075Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="单选复选Switch"><a href="#单选复选Switch" class="headerlink" title="单选复选Switch"></a>单选复选Switch</h4><p>switch组件是常用组件，默认的单选复选框都很丑，是这里使用CSS3美化switch。<br>    <img src="/images/switch.png" alt="效果图"><br>本问重点将一下整体思路（以单选为例）</p>
<h5 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt;</div><div class="line">       &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;</div><div class="line">       &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt;</div><div class="line">       &lt;div class=&quot;fan-check-inner&quot;&gt;</div><div class="line">           &lt;div class=&quot;fan-check-title&quot;&gt;男&lt;/div&gt;</div><div class="line">       &lt;/div&gt;</div><div class="line">   &lt;/label&gt;</div><div class="line">   &lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt;</div><div class="line">       &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;</div><div class="line">       &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt;</div><div class="line">       &lt;div class=&quot;fan-check-inner&quot;&gt;</div><div class="line">           &lt;div class=&quot;fan-check-title&quot;&gt;女&lt;/div&gt;</div><div class="line">       &lt;/div&gt;</div><div class="line">   &lt;/label&gt;</div></pre></td></tr></table></figure>

这里讲解一下DOM结构用义：
</code></pre><ol>
<li>label包含整个组件，并且是label绑定与input的关系。</li>
<li>主要前端效果通过<div class="fan-check-media"></div>节点及其伪类完成</li>
<li><p>通过input:checked 和 兄弟选择器 + 控制类fan-check-media元素的样式</p>
<h5 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line">  box-sizing: border-box;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&#123;</div><div class="line">	display: flex;</div><div class="line">	padding: 5px 0;</div><div class="line">	cursor: pointer;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&gt;input&#123;</div><div class="line">	display: none;</div><div class="line">&#125;</div><div class="line">.fan-check-radio:hover .fan-check-media &#123;</div><div class="line">	border-color: red!important;</div><div class="line">&#125;</div><div class="line">.fan-check-inner,.fan-check-media</div><div class="line">&#123;</div><div class="line">	position: relative;</div><div class="line">&#125;</div><div class="line"> .fan-check-radio .fan-check-media &#123;</div><div class="line">	line-height: 20px;</div><div class="line">	width: 22px;</div><div class="line">	height: 22px;</div><div class="line">	margin-right: 5px;</div><div class="line">	text-align: center;</div><div class="line">	color: #fff;</div><div class="line">	border: 1px solid #d9d9d9;</div><div class="line">	border-radius: 11px;</div><div class="line">&#125;</div><div class="line"> .fan-check-checkbox .fan-check-media &#123;</div><div class="line">	line-height: 20px;</div><div class="line">	width: 22px;</div><div class="line">	height: 22px;</div><div class="line">	margin-right: 5px;</div><div class="line">	text-align: center;</div><div class="line">	color: #fff;</div><div class="line">	border: 1px solid #d9d9d9;</div><div class="line">	border-radius: 2px;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&gt;input:checked + .fan-check-media &#123;</div><div class="line">	border: 1px solid #1aa500;</div><div class="line">&#125;</div><div class="line">.fan-check-radio&gt;input:checked + .fan-check-media:after &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	position: absolute;</div><div class="line">	animation: radiozoom .1s linear forwards;</div><div class="line">	border-radius: 6px;</div><div class="line">	background: #1aa500; </div><div class="line">&#125;</div><div class="line">@keyframes radiozoom &#123;</div><div class="line">	from &#123;</div><div class="line">		top: 8px;</div><div class="line">		left:8px;</div><div class="line">		width: 2px;</div><div class="line">		height: 2px;</div><div class="line">	&#125;</div><div class="line">	to &#123;</div><div class="line">		top: 4px;</div><div class="line">		left:4px;    </div><div class="line">		width: 12px;</div><div class="line">		height: 12px;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：<br>我们需要隐藏radio默认的样式，来做我们自己的UI：.fan-check-radio&gt;input{ display: none; }<br>然后在就只这个<div class="fan-check-media"></div>节点及其伪类上下功夫了。<br>.fan-check-media这个节点需要使用相对定位，其伪类上使用绝对定位。<br>先设定input未选中时的样式，也是通过.fan-check-media及其伪类来控制。<br>在设置input选中时的样式，通过属性选择其[type=’radio’]:checked来控制radio被选中的样式。<br>具体操作请参考，下面的代码库</p>
</li>
</ol>
<h4 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h4><p>先来看下效果<br>    <img src="/images/loading.png" alt="loading"><br>    讲解一下大体思路：</p>
<ol>
<li>构建外层包裹div（相对定位），内部8个span分别占据一周（使它们绕中心一周）通过绝对定位。</li>
<li>创建一个动画，并为每个span添加动画及动画延迟。（需要满足动画周期 === 8* animation-delay ）</li>
</ol>
<h5 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code>我们创意个正方形的div，里面放置8个子元素。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;loader circle-line small&quot;&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">	&lt;span&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code>通过定位和css的转换来移动每一个span的位置。
设置容器的基本样式和span的基本样式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.loader &#123;</div><div class="line">	position: relative;</div><div class="line">	width: 5rem;</div><div class="line">	height: 5rem;</div><div class="line">&#125;</div><div class="line">.loader.circle-line span &#123;</div><div class="line">	position: absolute;</div><div class="line">	display: inline-block;</div><div class="line">	width: 1.5rem;</div><div class="line">	height: .5rem;</div><div class="line">	border-top-left-radius: .25rem;</div><div class="line">	border-bottom-left-radius: .25rem;</div><div class="line">	background: #1aa500;</div><div class="line">	opacity: .05;</div><div class="line">	-webkit-animation: circle-line 1s ease infinite;</div><div class="line">	animation: circle-line 1s ease infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

通过css3-transform得到loading图案
当然这哥定位还是很复杂，我直接参考[web开始实战](https://www.kancloud.cn/dennis/javascriptmethod/261478)的源代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">.loader.circle-line span:nth-child(1) &#123;</div><div class="line">	top: 50%;</div><div class="line">	left: 0;</div><div class="line">	margin-top: -.25rem;</div><div class="line">	animation-delay: .13s;</div><div class="line">&#125;</div><div class="line">.loader.circle-line span:nth-child(2) &#123;</div><div class="line">	top: 1rem;</div><div class="line">	left: .5rem;</div><div class="line">	-webkit-transform: rotate(45deg);</div><div class="line">	transform: rotate(45deg);</div><div class="line">	animation-delay: .26s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(3) &#123;</div><div class="line">	left: 50%;</div><div class="line">	top: .5rem;</div><div class="line">	margin-left: -.75rem;</div><div class="line">	-webkit-transform: rotate(90deg);</div><div class="line">	transform: rotate(90deg);</div><div class="line">	animation-delay: .39s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(4) &#123;</div><div class="line">	right: .5rem;</div><div class="line">	top: 1rem;</div><div class="line">	-webkit-transform: rotate(145deg);</div><div class="line">	transform: rotate(145deg);</div><div class="line">	animation-delay: .52s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(5) &#123;</div><div class="line">	left: 3.5rem;</div><div class="line">	top: 50%;</div><div class="line">	margin-top: -.25rem;</div><div class="line">	-webkit-transform: rotate(180deg);</div><div class="line">	transform: rotate(180deg);</div><div class="line">	animation-delay: .65s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(6) &#123;</div><div class="line">	bottom: 1rem;</div><div class="line">	right: .5rem;</div><div class="line">	-webkit-transform: rotate(-145deg);</div><div class="line">	transform: rotate(-145deg);</div><div class="line">	animation-delay: .78s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(7) &#123;</div><div class="line">	left: 50%;</div><div class="line">	bottom: .5rem;</div><div class="line">	margin-left: -15px;</div><div class="line">	-webkit-transform: rotate(-90deg);</div><div class="line">	transform: rotate(-90deg);</div><div class="line">	animation-delay: 0.91s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.loader.circle-line span:nth-child(8) &#123;</div><div class="line">	bottom: 1rem;</div><div class="line">	left: .5rem;</div><div class="line">	-webkit-transform: rotate(-45deg);</div><div class="line">	transform: rotate(-45deg);</div><div class="line">	animation-delay: 1.04s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

注意：上面动画的周期必须要无限接近于最后一个span元素的动画延迟（动画延迟是平均分配的哦）。

动画，这是使用Opcity动画。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@keyframes circle-line &#123;</div><div class="line">	0% &#123;</div><div class="line">		opacity: .05;</div><div class="line">	&#125;</div><div class="line">	100% &#123;</div><div class="line">		opacity: .7;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css加强（水中倒影、工具提示tooltip）</title>
    <link href="https://fanerge.github.io/2017/08/30/css%E5%8A%A0%E5%BC%BA-1/"/>
    <id>https://fanerge.github.io/2017/08/30/css加强-1/</id>
    <published>2017-08-30T11:39:15.000Z</published>
    <updated>2017-08-30T13:27:38.643Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="水中倒影"><a href="#水中倒影" class="headerlink" title="水中倒影"></a>水中倒影</h4><pre><code>要实现倒影，有两种方式：box-reflect方式和transform方式。
</code></pre><p>box-reflect效果<br>    <img src="/images/box_reflect.png" alt="box-reflect方式"></p>
<h5 id="box-reflect方式（存在兼容性）"><a href="#box-reflect方式（存在兼容性）" class="headerlink" title="box-reflect方式（存在兼容性）"></a>box-reflect方式（存在兼容性）</h5><h6 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h6><pre><code>box-reflect: &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?
参数说明：
</code></pre><ol>
<li>表示倒影的方向，可能值：above、below、left、right（上下左右）；</li>
<li>表示倒影与元素之间的间隔；</li>
<li>表示遮罩图像，可为url地址、渐变<h6 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;./img/demo.png&quot; alt=&quot;&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">       -webkit-box-reflect: below 0 -webkit-linear-gradient(top, rgba(250, 250, 250, 0), rgba(250, 250, 250, .1) 20%, rgba(250, 250, 250, .3));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="transform方式"><a href="#transform方式" class="headerlink" title="transform方式"></a>transform方式</h5><pre><code>这种方式其实就是复制图片，然后翻转，最后同样是使用渐变来充当遮罩层，覆盖在翻转的图片之上。
</code></pre><p>transform效果<br>    <img src="/images/transform_reflect.png" alt="transform方式"></p>
<h6 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;box-reflect&quot;&gt;</div><div class="line">       &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot; /&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h6 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h6><pre><code>使用伪类元素将我们需要将图片克隆一份，然后翻转过来，before存放背景图片，after达到渐变效果，这样after的z-index在before大，就达到了我们想要的效果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">.box-reflect &#123;</div><div class="line">       position: relative;</div><div class="line">       width: 150px;</div><div class="line">       float: left;</div><div class="line">       margin-right: 40px;</div><div class="line">   &#125;</div><div class="line">   .box-reflect img &#123;</div><div class="line">       width: 100%;</div><div class="line">       height: 100%;</div><div class="line">   &#125;</div><div class="line">   .box-reflect:before &#123;</div><div class="line">       background: url(img/demo.png) no-repeat;</div><div class="line">       background-size: 100% 100%;</div><div class="line">       transform: scaleY(-1);</div><div class="line">       /*添加半透明是为了更真实*/</div><div class="line">       opacity: 0.5;</div><div class="line">       filter: alpha(opacity=&apos;50&apos;);</div><div class="line">   &#125;</div><div class="line">   .box-reflect:before, .box-reflect:after &#123;</div><div class="line">       position: absolute;</div><div class="line">       width: 100%;</div><div class="line">       height: 100%;</div><div class="line">       top: 100%;</div><div class="line">       left: 0;</div><div class="line">       content: &quot;&quot;;</div><div class="line">   &#125;</div><div class="line">   .box-reflect:after &#123;</div><div class="line">       background-image: -webkit-linear-gradient(bottom,rgb(0,0,0) 20%,rgba(0,0,0,0) 90%);</div><div class="line">       filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColor=0, EndColorStr=#000000);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="工具提示（tooltip）"><a href="#工具提示（tooltip）" class="headerlink" title="工具提示（tooltip）"></a>工具提示（tooltip）</h4><p>css3设计的tooltip工具<br>    <img src="/images/tooltip.png" alt="tooltip"></p>
<h5 id="创建模版-2"><a href="#创建模版-2" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;toop-group&quot;&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在上方&quot; data-direction=&quot;up&quot;&gt;</div><div class="line">           在上方</div><div class="line">       &lt;/button&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在右方&quot; data-direction=&quot;right&quot;&gt;</div><div class="line">           在右方</div><div class="line">       &lt;/button&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在下方&quot; data-direction=&quot;down&quot;&gt;</div><div class="line">           在下方</div><div class="line">       &lt;/button&gt;</div><div class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在左方&quot; data-direction=&quot;left&quot;&gt;</div><div class="line">           在左方</div><div class="line">       &lt;/button&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="设置样式-2"><a href="#设置样式-2" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code>总体思路：
</code></pre><ol>
<li>利用伪类before生成提示工具的三角形border来形成。</li>
<li>利用伪类after生成提示内容（长方形）以及获取提示文本content(attr(data-tooltip)),来获取自身的自定义属性data-tooltip。</li>
<li>利用hover效果让其展现，在加入一些css3动画将表现的更好。</li>
<li>使用了calc用于动态计算长度值，使我们的组件更通用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">.tooltip</div><div class="line">&#123;</div><div class="line">	position: relative;</div><div class="line">&#125;</div><div class="line">.tooltip:before</div><div class="line">&#123;</div><div class="line">	position: absolute;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	border: 5px solid transparent;</div><div class="line">&#125;</div><div class="line">.tooltip:after</div><div class="line">&#123;</div><div class="line">	font-size: 14px;</div><div class="line">	line-height: normal;</div><div class="line"></div><div class="line">	position: absolute;</div><div class="line"></div><div class="line">	padding: 5px 10px;</div><div class="line">	content: attr(data-tooltip);</div><div class="line">	white-space: nowrap;</div><div class="line"></div><div class="line">	color: #fff;</div><div class="line">	border-radius: 3px;</div><div class="line">	background: #383838;</div><div class="line">&#125;</div><div class="line">.tooltip:before,</div><div class="line">.tooltip:after</div><div class="line">&#123;</div><div class="line">	z-index: 1000000;</div><div class="line"></div><div class="line">	visibility: hidden;</div><div class="line"></div><div class="line">	-webkit-transition: .3s ease;</div><div class="line">	   -moz-transition: .3s ease;</div><div class="line">			transition: .3s ease;</div><div class="line">	-webkit-transition-delay: 0ms;</div><div class="line">	   -moz-transition-delay: 0ms;</div><div class="line">			transition-delay: 0ms;</div><div class="line">	pointer-events: none;</div><div class="line"></div><div class="line">	opacity: 0;</div><div class="line">&#125;</div><div class="line">.tooltip:hover:before,</div><div class="line">.tooltip:hover:after</div><div class="line">&#123;</div><div class="line">	visibility: visible;</div><div class="line"></div><div class="line">	opacity: 1;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;down&apos;]:before</div><div class="line">&#123;</div><div class="line">	top: -webkit-calc(100% - 5px);</div><div class="line">	top:    -moz-calc(100% - 5px);</div><div class="line">	top:         calc(100% - 5px);</div><div class="line"></div><div class="line">	border-bottom-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;down&apos;]:after</div><div class="line">&#123;</div><div class="line">	top: -webkit-calc(100% + 5px);</div><div class="line">	top:    -moz-calc(100% + 5px);</div><div class="line">	top:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;down&apos;]:before,</div><div class="line">[data-direction=&apos;down&apos;]:after,</div><div class="line">[data-direction=&apos;up&apos;]:before,</div><div class="line">[data-direction=&apos;up&apos;]:after</div><div class="line">&#123;</div><div class="line">	left: 50%;</div><div class="line">	-webkit-transform: translate3d(-50%,0,0);</div><div class="line">	   -moz-transform: translate3d(-50%,0,0);</div><div class="line">			transform: translate3d(-50%,0,0);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;up&apos;]:before</div><div class="line">&#123;</div><div class="line">	bottom: -webkit-calc(100% - 5px);</div><div class="line">	bottom:    -moz-calc(100% - 5px);</div><div class="line">	bottom:         calc(100% - 5px);</div><div class="line"></div><div class="line">	border-top-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;up&apos;]:after</div><div class="line">&#123;</div><div class="line">	bottom: -webkit-calc(100% + 5px);</div><div class="line">	bottom:    -moz-calc(100% + 5px);</div><div class="line">	bottom:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;left&apos;]:before,</div><div class="line">[data-direction=&apos;left&apos;]:after,</div><div class="line">[data-direction=&apos;right&apos;]:before,</div><div class="line">[data-direction=&apos;right&apos;]:after</div><div class="line">&#123;</div><div class="line">	top: 50%;</div><div class="line">	-webkit-transform: translate3d(0,-50%,0);</div><div class="line">	   -moz-transform: translate3d(0,-50%,0);</div><div class="line">			transform: translate3d(0,-50%,0);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;left&apos;]:before</div><div class="line">&#123;</div><div class="line">	left: -5px;</div><div class="line">	border-left-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;left&apos;]:after</div><div class="line">&#123;</div><div class="line">	right: -webkit-calc(100% + 5px);</div><div class="line">	right:    -moz-calc(100% + 5px);</div><div class="line">	right:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;right&apos;]:before</div><div class="line">&#123;</div><div class="line">	left: -webkit-calc(100% - 5px);</div><div class="line">	left:    -moz-calc(100% - 5px);</div><div class="line">	left:         calc(100% - 5px);</div><div class="line"></div><div class="line">	border-right-color: #383838;</div><div class="line">&#125;</div><div class="line">[data-direction=&apos;right&apos;]:after</div><div class="line">&#123;</div><div class="line">	left: -webkit-calc(100% + 5px);</div><div class="line">	left:    -moz-calc(100% + 5px);</div><div class="line">	left:         calc(100% + 5px);</div><div class="line">&#125;</div><div class="line">.toop-group &#123;</div><div class="line">	padding-top: 100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>   参考文档：</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261476" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-box-reflect" target="_blank" rel="external">MDN box-reflect</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>css-加强（白光划过效果、3D立方体）</title>
    <link href="https://fanerge.github.io/2017/08/29/css%E5%8A%A0%E5%BC%BA/"/>
    <id>https://fanerge.github.io/2017/08/29/css加强/</id>
    <published>2017-08-29T12:53:23.000Z</published>
    <updated>2017-08-30T12:06:33.632Z</updated>
    
    <content type="html"><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="external">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="白光划过效果"><a href="#白光划过效果" class="headerlink" title="白光划过效果"></a>白光划过效果</h4><h5 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h5><p>我们要放置一张图片，用一个div包裹起来：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;highlight-box&quot;&gt;</div><div class="line">	&lt;img src=&quot;./img/demo.png&quot; width=&quot;296&quot; height=&quot;374&quot; alt=&quot;s&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h5 id="设置CSS样式"><a href="#设置CSS样式" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><p>定义初始样式:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.highlight-box &#123;</div><div class="line">       /**这里用于before、after伪类定位**/</div><div class="line">       position: relative; </div><div class="line">       width: 296px;</div><div class="line">       height: 374px;</div><div class="line">       overflow: hidden;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>接着让我们来制作白光，我们不需多余的元素，只需使用:before选择器.position为伪类定位：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.highlight-box:before &#123;</div><div class="line">       position: absolute;</div><div class="line">       /* 注意这里top和left，让白光移动到图片左上角，后续的划过动画也是依靠这两个属性 */</div><div class="line">       top: -200%;</div><div class="line">       left: -100%;</div><div class="line">       z-index: 2;</div><div class="line">       display: block;</div><div class="line">       content: &apos;&apos;;</div><div class="line">       /* 定义白光的高宽，hight为300%是为了防止在移动过程中白光不够用 */</div><div class="line">       width: 50%;</div><div class="line">       height: 300%;</div><div class="line">       /* 使用线性渐变来实现白光 */</div><div class="line">       background: linear-gradient(to left top, rgba(255, 255, 255, .05) 20%, rgba(255, 255, 255, .6) 65% , rgba(255, 255, 255, .05) 100%);</div><div class="line">       /* background: rgba(255, 255, 255, .5); */</div><div class="line">       transform: rotate(45deg);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>我们使用渐变（linear-gradient）来实现白光效果，同时为了斜向划过，使用transform: rotate(45deg)将其旋转45度。<br>上面的height、width、top和left，你也可以使用具体的像素值，不过建议采用百分比，这样可以重复使用，而不需手动改变太多值。<br>触发白光(hover伪类和css3动画)：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.highlight-box:hover:before &#123;</div><div class="line">       /* 这里省略了私有前缀代码 */</div><div class="line">       animation: crossed .5s linear;</div><div class="line">   &#125;</div><div class="line">   @keyframes crossed &#123;</div><div class="line">       0% &#123;</div><div class="line">           top: -200%;</div><div class="line">           left: -100%;</div><div class="line">       &#125;</div><div class="line">       100% &#123;</div><div class="line">           top: -50px;</div><div class="line">           left: 100%;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>截图效果(鼠标划入时的效果)<br>        <img src="/images/css_white_light.jpg" alt="白光划过"></p>
<h4 id="3D立方体"><a href="#3D立方体" class="headerlink" title="3D立方体"></a>3D立方体</h4><p>随着CSS3的出现，实现3D效果已经不是难事，这一节就来看看3D立方体是如何实现的。</p>
<h5 id="创建模板-1"><a href="#创建模板-1" class="headerlink" title="创建模板"></a>创建模板</h5><p>首先来放置一个父div.cude，然后在其里面放置6个div，分别表示立方体的6个面。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;cude&quot;&gt;</div><div class="line">	&lt;div class=&quot;front surface&quot;&gt;</div><div class="line">		正面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface left&quot;&gt;</div><div class="line">		左面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface right&quot;&gt;</div><div class="line">		右面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface bottom&quot;&gt;</div><div class="line">		底面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface top&quot;&gt;</div><div class="line">		顶面</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;surface back&quot;&gt;</div><div class="line">		背面</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h5 id="设置CSS样式-1"><a href="#设置CSS样式-1" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">.cude &#123;</div><div class="line">	width:300px;</div><div class="line">	height:300px;</div><div class="line">	position:relative;</div><div class="line">	margin:100px auto;</div><div class="line">	transform-style:preserve-3d;</div><div class="line">	-webkit-transform-style:preserve-3d;</div><div class="line">&#125;</div><div class="line">.surface &#123;</div><div class="line">	position:absolute;</div><div class="line">	top:0;</div><div class="line">	left:0;</div><div class="line">	width:300px;</div><div class="line">	height:300px;</div><div class="line">	background:#666;</div><div class="line">	opacity:0.8;</div><div class="line">	font-size:60px;</div><div class="line">	text-align:center;</div><div class="line">	line-height:300px;</div><div class="line">	font-weight:bold;</div><div class="line">	color:#fff;</div><div class="line">	border:1px solid #fff;</div><div class="line">	-webkit-transition:all .3s;</div><div class="line">	transition:all .3s;</div><div class="line">&#125;</div><div class="line">.surface img &#123;</div><div class="line">	width:100%;</div><div class="line">&#125;</div><div class="line">.front &#123;</div><div class="line">	transform:rotateY(0) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.back &#123;</div><div class="line">	transform:translateZ(-150px) rotateY(180deg);</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">	transform:rotateY(-90deg) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">	transform:rotateY(90deg) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.top &#123;</div><div class="line">	transform:rotateX(90deg) translateZ(150px);</div><div class="line">&#125;</div><div class="line">.bottom &#123;</div><div class="line">	transform:rotateX(90deg) translateZ(-150px);</div><div class="line">&#125;</div><div class="line">@-webkit-keyframes rotate &#123;</div><div class="line">	from &#123;</div><div class="line">		transform: rotateX(0deg) rotateY(0deg);</div><div class="line">	&#125;</div><div class="line">	to &#123;</div><div class="line">		transform: rotateX(360deg) rotateY(360deg);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>总结：</p>
<ol>
<li>使用了before和after伪类</li>
<li>linear-gradient-api的使用</li>
<li>animation</li>
<li>transform(分为2D转换和3D转换)</li>
<li>2d转换：translate(x,y)、translateX(x)、translateY(y)、scale(x,y)、scaleX(x)、scaleY(y)、rotate(angle)、skew(x-angle,y-angle)、skewX(angle)</li>
<li>3d转换：translate3d(x,y,z)、translateZ(z)、scale3d(x,y,z)、scaleZ(z)、rotate3d(x,y,z,angle)、rotateX(angle)、rotateY(angle)、rotateZ(angle)</li>
</ol>
<blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="external">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient" target="_blank" rel="external">linear-gradient</a></li>
<li><a href="http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="external">transform</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="external">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接下来的一段时间学习看云上购买的一本&lt;a href=&quot;https://www.kancloud.cn/dennis/javascriptmethod/261472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web开发实战&lt;/a&gt;书籍，来提升自己的软实
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ramda运用--官方文档解读</title>
    <link href="https://fanerge.github.io/2017/08/25/ramda%E8%BF%90%E7%94%A8-5/"/>
    <id>https://fanerge.github.io/2017/08/25/ramda运用-5/</id>
    <published>2017-08-25T12:37:40.000Z</published>
    <updated>2017-08-29T12:50:28.911Z</updated>
    
    <content type="html"><![CDATA[<p>从8月25到8月29共5个晚上和小部分周末时间撸完了Ramda官方文档，继续在事件中继续学习。<br>Rmda中共分为List、Relation、Object、Function、Math、Type、Logic、String共8大类。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><pre><code>定义：检测字符串是否匹配给定的正则表达式。
```   
R.test(/^x/, &apos;xyz&apos;); // true
```   
</code></pre><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><pre><code>定义：正则匹配字符串。注意，如果没有匹配项，则返回空数组。和 String.prototype.match 不同，后者在没有匹配项时会返回 null。
```   
R.match(/([a-z]a)/g, &apos;bananas&apos;); //=&gt; [&apos;ba&apos;, &apos;na&apos;, &apos;na&apos;]
```   
</code></pre><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><pre><code>定义：替换字符串的子串或正则匹配到的值。
```   
R.replace(&apos;foo&apos;, &apos;bar&apos;, &apos;foo foo foo&apos;); // bar foo foo
```   
</code></pre><h5 id="split"><a href="#split" class="headerlink" title="split"></a>split</h5><pre><code>定义：根据指定的分隔符将字符串拆分为字符串类型的数组。
```   
R.split(&apos;.&apos;, &apos;a.b.c.xyz.d&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;xyz&apos;, &apos;d&apos;]
```   
</code></pre><h5 id="toLower"><a href="#toLower" class="headerlink" title="toLower"></a>toLower</h5><pre><code>定义：将字符串转换成小写。
```   
R.toLower(&apos;XYZ&apos;); // xyz
```   
</code></pre><h5 id="toUpper"><a href="#toUpper" class="headerlink" title="toUpper"></a>toUpper</h5><pre><code>定义：将字符串转换为大写。
```   
R.toUpper(&apos;abc&apos;); // ABC
```   
</code></pre><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><pre><code>定义：返回代表输入元素的字符串。求得的输出结果应该等价于输入的值。许多内建的 toString 方法都不满足这一条件。
如果输入值是 [object Object] 对象，且自身含有 toString 方法（不是 Object.prototype.toString 方法），那么直接调用这个方法求返回值。
这意味着，通过用户自定义的构造函数可以提供合适的 toString 方法。
```   
R.toString(42); // 42
```   
</code></pre><h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><pre><code>定义：删除字符串首、尾两端的空白字符。
```   
R.trim(&apos;   xyz  &apos;); //=&gt; &apos;xyz&apos;
```   
</code></pre><h4 id="List-Array"><a href="#List-Array" class="headerlink" title="List(Array)"></a>List(Array)</h4><h5 id="adjust"><a href="#adjust" class="headerlink" title="adjust"></a>adjust</h5><pre><code>定义：将数组中指定索引处的值替换为经函数变换的值。
```   
R.adjust(R.add(10))(1)([1, 2, 3]); // [1, 12, 3]
```   
</code></pre><h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><pre><code>定义：如果列表中的所有元素都满足 predicate，则返回 true；否则，返回 false。
```   
var equals3 = R.equals(3);
R.all(equals3)([3, 3, 3]); // true
R.all(equals3)([1, 3, 3]); // false
```   
</code></pre><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><pre><code>定义：只要列表中有一个元素满足 predicate，就返回 true，否则返回 false。
```   
var lessThan0 = R.flip(R.lt)(0);
var lessThan2 = R.flip(R.lt)(2);
R.any(lessThan0)([1, 2]); // false
R.any(lessThan2)([1, 2]); // true
```   
</code></pre><h5 id="aperture"><a href="#aperture" class="headerlink" title="aperture"></a>aperture</h5><pre><code>定义：返回一个新列表，列表中的元素为由原列表相邻元素组成的 n 元组。如果 n 大于列表的长度，则返回空列表。
```   
R.aperture(2, [1, 2, 3, 4, 5]); // [[1, 2], [2, 3], [3, 4], [4, 5]]
```   
</code></pre><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><pre><code>定义：在列表末尾拼接一个元素。
```   
R.append(5)([1, 2, 3]); // [1, 2, 3, 5]
```   
</code></pre><h5 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h5><pre><code>定义：chain 将函数映射到列表中每个元素，并将结果连接起来。 chain 在一些库中也称为 flatMap（先 map 再 flatten ）。
```   
var duplicate = n =&gt; [n, n];
R.chain(duplicate, [1, 2, 3]); // [1, 1, 2, 2, 3, 3]
```        
</code></pre><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><pre><code>定义：连接列表或字符串。
```   
R.concat(&apos;ABC&apos;, &apos;DEF&apos;); // ABCDEF
R.concat([1, 2, 3])([4, 5, 6]); // [1, 2, 3, 4, 5, 6]
```            
</code></pre><h5 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h5><pre><code>定义：只要列表中有一个元素等于指定值，则返回 true；否则返回 false。通过 R.equals 函数进行相等性判断。
```   
R.contains(2, [1, 2, 3]); // true
```       
</code></pre><h5 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h5><pre><code>定义：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。
```   
R.drop(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;zhen&apos;]
R.drop(2, &apos;fanerge&apos;); // nerge
```       
</code></pre><h5 id="dropLast"><a href="#dropLast" class="headerlink" title="dropLast"></a>dropLast</h5><pre><code>定义：删除 &quot;list&quot; 末尾的 n 个元素。
```   
R.dropLast(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;fan&apos;]
R.dropLast(2, &apos;fanerge&apos;); // faner
```       
</code></pre><h5 id="dropLastWhile"><a href="#dropLastWhile" class="headerlink" title="dropLastWhile"></a>dropLastWhile</h5><pre><code>定义：对 list 从后向前一直删除满足 predicate 的尾部元素，直到遇到第一个 falsy 值，此时停止删除操作。
predicate 需要作为第一个参数传入。
```   
var lteThree = x =&gt; x &lt;= 3;
R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3, 4]
```       
</code></pre><h5 id="dropRepeats"><a href="#dropRepeats" class="headerlink" title="dropRepeats"></a>dropRepeats</h5><pre><code>定义：返回一个没有连续重复元素的 list。通过 R.equals 函数进行相等性判断。
```   
R.dropRepeats([1, 1, 2, 2, 3, 3, 2, 2]); // [1, 2, 3, 2] 
```       
</code></pre><h5 id="dropRepeatsWith"><a href="#dropRepeatsWith" class="headerlink" title="dropRepeatsWith"></a>dropRepeatsWith</h5><pre><code>定义：返回一个没有连续重复元素的 list。首个参数提供的 predicate 用于检测 list 中相邻的两个元素是否相等。
一系列相等元素中的首个元素会被保留。
```   
var list = [1, -1, 1, 3, 4, -4];
R.dropRepeatsWith(R.eqBy(Math.abs), list); // [1, 3, 4]
```       
</code></pre><h5 id="dropWhile"><a href="#dropWhile" class="headerlink" title="dropWhile"></a>dropWhile</h5><pre><code>定义：对 list 从前向后删除满足 predicate 的头部元素，直到遇到第一个 falsy 值。
predicate 需要作为第一个参数传入。
```   
var lteTwo = x =&gt; x &lt;= 2;
R.dropWile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); // [3, 4, 3, 2, 1]
```       
</code></pre><h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h5><pre><code>定义：检查列表或字符串是否以给定的值结尾。
```   
R.endsWith(&apos;c&apos;, &apos;abc&apos;); // true
R.endsWith([&apos;c&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true
```       
</code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><pre><code>定义：使用 predicate 遍历传入的 Filterable，返回满足 predicate 的所有元素的新的 Filterable。新 Filterable 与原先的类型相同。Filterable 类型包括 plain object 或者任何带有 filter 方法的类型，如 Array 。
```   
var isEven = n =&gt; n % 2 === 0;
R.filter(isEven, [1, 2, 3, 4]); // [2, 4]
```       
</code></pre><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><pre><code>定义：查找并返回 list 中首个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。
```   
var xs = [{a: 1}, {a: 2}, {a: 3}];
R.find(R.propEq(&apos;a&apos;, 2))(xs); // {a: 2}
```   
</code></pre><h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h5><pre><code>定义：查找并返回 list 中首个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。
```   
var xs = [{a: 1}, {a: 2}, {a: 3}];
R.findIndex(R.propEq(&apos;a&apos;, 2))(xs); // 1
```   
</code></pre><h5 id="findLast"><a href="#findLast" class="headerlink" title="findLast"></a>findLast</h5><pre><code>定义：查找并返回 list 中最后一个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。
```   
var xs = [{a: 1, b: 0}, {a:1, b: 1}];
R.findLast(R.propEq(&apos;a&apos;, 1))(xs); // {a: 1, b: 1}
```   
</code></pre><h5 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h5><pre><code>定义：查找并返回 list 中最后一个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。
```   
var xs = [{a: 1, b: 0}, {a:1, b: 1}];
R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs); // 1
```   
</code></pre><h5 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h5><pre><code>定义：获取 list 的所有元素（包含所有子数组中的元素），然后由这些元素组成一个新的数组。深度优先。
```   
R.flatten([1, [2, [3]]]); // [1, 2, 3]
```   
</code></pre><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><pre><code>定义：遍历 list，对 list 中的每个元素执行方法 fn。
Ramda 的 forEach 会将原数组返回。
```   
var printPlusFive = x =&gt; console.log(x + 5);
R.forEach(printPlusFive, [1, 2, 3]); // [1, 2, 3]
```   
</code></pre><h5 id="fromPairs"><a href="#fromPairs" class="headerlink" title="fromPairs"></a>fromPairs</h5><pre><code>定义：由一系列 “键值对” 创建一个 object。如果某个键出现多次，选取最右侧的键值对。
```   
var R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]); // {a: 1, b: 2, c: 3}
```   
</code></pre><h5 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h5><pre><code>定义：将列表根据一定规则拆分成多组子列表，并存储在一个对象中。
对列表中的每个元素调用函数，根据函数返回结果进行分组。
函数返回字符串作为相等性判断，返回的字符串作为存储对象的键，具有相同返回字符串的元素聚合为数组，作为该键的值。
```   
var byGrade = R.groupBy(function(student) {
  var score = student.score;
  return score &lt; 65 ? &apos;F&apos; :
         score &lt; 70 ? &apos;D&apos; :
         score &lt; 80 ? &apos;C&apos; :
         score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;
});
var students = [{name: &apos;Abby&apos;, score: 84},
                {name: &apos;Eddy&apos;, score: 58},
                // ...
                {name: &apos;Jack&apos;, score: 69}];
byGrade(students);
// {
//   &apos;A&apos;: [{name: &apos;Dianne&apos;, score: 99}],
//   &apos;B&apos;: [{name: &apos;Abby&apos;, score: 84}]
//   // ...,
//   &apos;F&apos;: [{name: &apos;Eddy&apos;, score: 58}]
// }
```   
</code></pre><h5 id="groupWith"><a href="#groupWith" class="headerlink" title="groupWith"></a>groupWith</h5><pre><code>定义：通过给定的对比函数，将列表按顺序分割成多组子列表。
对比函数只比较相邻元素。
```   
var R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 13, 21]); 
// [[0], [1, 1], [2], [3], [5], [13], [21]]
```   
</code></pre><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><pre><code>定义：求列表或字符串的首个元素。在某些库中，该函数也被称作 first。
```   
R.head([1, 2, 3]); // 1
R.head(&apos;fan&apos;); // f
```   
</code></pre><h5 id="indexBy"><a href="#indexBy" class="headerlink" title="indexBy"></a>indexBy</h5><pre><code>定义：通过生成键的函数，将元素为对象的 list 转换为以生成的键为索引的新对象。注意，如果 list 中多个对象元素生成相同的键，以最后一个对象元素作为该键的值。
```   
var list = [{id: &apos;xyz&apos;, title: &apos;A&apos;}, {id: &apos;abc&apos;, title: &apos;B&apos;}];
R.indexBy(R.prop(&apos;id&apos;), list);
//=&gt; {abc: {id: &apos;abc&apos;, title: &apos;B&apos;}, xyz: {id: &apos;xyz&apos;, title: &apos;A&apos;}}
```   
</code></pre><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><pre><code>定义：返回给定元素在数组中首次出现时的索引值，如果数组中没有该元素，则返回 -1。通过 R.equals 函数进行相等性判断。
```   
R.indexOf(3, [1, 2, 3, 4]); // 2
```       
</code></pre><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><pre><code>定义：返回 list 或 string 删除最后一个元素后的部分。
```   
R.init([1, 2, 3]);  //=&gt; [1, 2]
R.init(&apos;abc&apos;);  //=&gt; &apos;ab&apos;
```       
</code></pre><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><pre><code>定义：将元素插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。
```   
R.insert(2, &apos;x&apos;, [1, 2, 3, 4]); // [1,2,&apos;x&apos;,3,4]
```       
</code></pre><h5 id="insertAll"><a href="#insertAll" class="headerlink" title="insertAll"></a>insertAll</h5><pre><code>定义：将子 list 插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。
```   
R.insertAll(2, [&apos;x&apos;, &apos;y&apos;], [1, 2, 3, 4]); // [1, 2, &apos;x&apos;, &apos;y&apos;, 3, 4]
```       
</code></pre><h5 id="intersperse"><a href="#intersperse" class="headerlink" title="intersperse"></a>intersperse</h5><pre><code>定义：在列表的元素之间插入分割元素。
```   
R.intersperse(&apos;n&apos;, [&apos;ba&apos;, &apos;a&apos;, &apos;a&apos;]); //=&gt; [&apos;ba&apos;, &apos;n&apos;, &apos;a&apos;, &apos;n&apos;, &apos;a&apos;]
```       
</code></pre><h5 id="into"><a href="#into" class="headerlink" title="into"></a>into</h5><pre><code>定义：使用 transducer 对 list 中的元素进行转换，然后使用基于 accumulator 的类型的迭代器函数将转换后的元素依次添加到 accumulator 上。
```   
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));
R.into([], transducer, numbers); //=&gt; [2, 3]
```       
</code></pre><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><pre><code>定义：将列表中所有元素通过 分隔符 串连为一个字符串。
```   
var spacer = R.join(&apos;#&apos;);
spacer([1, 2, 3]); // 1#2#3
```       
</code></pre><h5 id="last"><a href="#last" class="headerlink" title="last"></a>last</h5><pre><code>定义：返回列表或字符串的最后一个元素。
```   
R.last([&apos;fan&apos;, &apos;zhen&apos;, &apos;yu&apos;]); // yu
R.last(&apos;abc&apos;); // c
```       
</code></pre><h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><pre><code>定义：返回数组中某元素最后一次出现的位置，如果数组中不包含该项则返回 -1 。通过 R.equals 函数进行相等性判断。
```   
R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); // 6
```   
</code></pre><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><pre><code>定义：通过 list.length，返回数组的大小（数组中元素的数量）。
```   
R.length([]); // 0
```   
</code></pre><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><pre><code>定义：接收一个函数和一个 functor, 将该函数应用到 functor 的每个值上，返回一个具有相同形态的 functor。
Ramda 为 Array 和 Object 提供了合适的 map 实现，因此 R.map 适用于 [1, 2, 3] 或 {x: 1, y: 2, z: 3}。
若第二个参数自身存在 map 方法，则调用自身的 map 方法。
```   
var double = x =&gt; x * 2;
R.map(double, [1, 2, 3]); // [2, 4, 6]
```   
</code></pre><h5 id="mapAccum"><a href="#mapAccum" class="headerlink" title="mapAccum"></a>mapAccum</h5><pre><code>定义：mapAccum 的行为类似于 map 和 reduce 的组合；
它将迭代函数作用于列表中的每个元素，从左往右传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。 
迭代函数接收两个参数，acc 和 value， 返回一个元组 [acc, value]。
```   
var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];
var appender = (a, b) =&gt; [a + b, a + b];
R.mapAccum(appender, 0, digits); // [&apos;01234&apos;, [&apos;01&apos;, &apos;012&apos;, &apos;0123&apos;, &apos;01234&apos;]]
```   
</code></pre><h5 id="mapAccumRight"><a href="#mapAccumRight" class="headerlink" title="mapAccumRight"></a>mapAccumRight</h5><pre><code>定义：mapAccumRight 的行为类似于 map 和 reduce 的组合；
它将迭代函数作用于列表中的每个元素，从右往左传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。
和 mapAccum 类似，除了列表遍历顺序是从右往左的。
迭代函数接收两个参数，value 和 acc ，返回一个元组 [value, acc]。
```   
var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];
var append = (a, b) =&gt; [a + b, a + b];
R.mapAccumRight(append, 5, digits); // [[&apos;12345&apos;, &apos;2345&apos;, &apos;345&apos;, &apos;45&apos;], &apos;12345&apos;]
```   
</code></pre><h5 id="mapObjIndexed"><a href="#mapObjIndexed" class="headerlink" title="mapObjIndexed"></a>mapObjIndexed</h5><pre><code>定义：Object 版本的 map。mapping function 接受三个参数： (value, key, obj) 。如果仅用到参数 value，则用 map 即可。
```   
var values = {x: 1, y: 2, z: 3};
var prependKeyAndDouble = (val, key, obj) =&gt; key + (val * 2);
R.mapIndexed(prependKeyAndDouble, values); // { x: &apos;x2&apos;, y: &apos;y4&apos;, z: &apos;z6&apos; }
```   
</code></pre><h5 id="mergaAll"><a href="#mergaAll" class="headerlink" title="mergaAll"></a>mergaAll</h5><pre><code>定义：将对象类型列表合并为一个对象。
```   
R.mergeAll([{foo: 1}, {bar: 2}, {baz: 3}]); // {foo: 1, bar: 2, baz: 3}
```   
</code></pre><h5 id="none"><a href="#none" class="headerlink" title="none"></a>none</h5><pre><code>定义：如果列表中的元素都不满足 predicate，返回 true；否则返回 false。
```   
var isEven = n =&gt; n % 2 === 0;
R.none(isEven, [1, 2, 3]); // true
```   
</code></pre><h5 id="nth"><a href="#nth" class="headerlink" title="nth"></a>nth</h5><pre><code>定义：返回列表或字符串的第 n 个元素。如果 n 为负数，则返回索引为 length + n 的元素。
```   
var list = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;quux&apos;];
R.nth(1, list); // &apos;bar&apos;
```   
</code></pre><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><pre><code>定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。
```   
R.pair(&apos;foo&apos;, &apos;bar&apos;); // [&apos;foo&apos;, &apos;bar&apos;]
```   
</code></pre><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><pre><code>定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。
```   
R.partition(R.contains(&apos;s&apos;), [&apos;sss&apos;, &apos;ttt&apos;, &apos;foo&apos;, &apos;bars&apos;]);
// [ [ &apos;sss&apos;, &apos;bars&apos; ],  [ &apos;ttt&apos;, &apos;foo&apos; ] ]
```   
</code></pre><h5 id="pluck"><a href="#pluck" class="headerlink" title="pluck"></a>pluck</h5><pre><code>定义：从列表内的每个对象元素中取出特定名称的属性，组成一个新的列表。
pluck 可以作用于任何 functor ，包括 Array，因为它等价于 R.map(R.prop(k), f)。
```   
R.pluck(&apos;a&apos;)([{a: 1}, {a: 2}]); // [1, 2]
```   
</code></pre><h5 id="prepend"><a href="#prepend" class="headerlink" title="prepend"></a>prepend</h5><pre><code>定义：在列表头部之前拼接一个元素。
```   
R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); // [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]
```   
</code></pre><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><pre><code>定义：返回从 from 到 to 之间的所有数的升序列表。左闭右开（包含 from，不包含 to）。
```   
R.range(1, 5); // [1, 2, 3, 4]
```   
</code></pre><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><pre><code>定义：左折叠操作。
遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。
可以用 R.reduced 提前终止遍历操作。
```   
R.reduce(R.subtract, 0, [1, 2, 3, 4]) // =&gt; ((((0 - 1) - 2) - 3) - 4) = -10
```   
</code></pre><h5 id="reduceBy"><a href="#reduceBy" class="headerlink" title="reduceBy"></a>reduceBy</h5><pre><code>定义：首先对列表中的每个元素调用函数 keyFn ，根据 keyFn 返回的字符串对列表元素进行分组。
然后调用 reducer 函数 valueFn，对组内的元素进行折叠操作。
该函数相当于更通用的 groupBy 函数。
```   
var reduceToNamesBy = R.reduceBy((acc, student) =&gt; acc.concat(student.name), []);
var namesByGrade = reduceToNamesBy(function(student) {
  var score = student.score;
  return score &lt; 65 ? &apos;F&apos; :
         score &lt; 70 ? &apos;D&apos; :
         score &lt; 80 ? &apos;C&apos; :
         score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;
});
var students = [{name: &apos;Lucy&apos;, score: 92},
                {name: &apos;Drew&apos;, score: 85},
                {name: &apos;Bart&apos;, score: 62}];
namesByGrade(students);
// {
//   &apos;A&apos;: [&apos;Lucy&apos;],
//   &apos;B&apos;: [&apos;Drew&apos;]
//   &apos;F&apos;: [&apos;Bart&apos;]
// }
```   
</code></pre><h5 id="reduced"><a href="#reduced" class="headerlink" title="reduced"></a>reduced</h5><pre><code>定义：返回一个封装的值，该值代表 reduce 或 transduce 操作的最终结果。
返回值是一个黑盒：不保证其内部结构的稳定性。
```   
R.reduce(
    (acc, item) =&gt; item &gt; 3 ? R.reduced(acc) : acc.concat(item),
    [],
    [1, 2, 3, 4, 5]
); // [1, 2, 3]
```   
</code></pre><h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h5><pre><code>定义：右折叠操作。
遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。
类似于 reduce，除了遍历列表的顺序是从右向左的。
```   
R.reduceRight(R.subtract, 0, [1, 2, 3, 4]); // (1 - (2 - (3 - (4 - 0)))) = -2
```   
</code></pre><h5 id="reduceWhile"><a href="#reduceWhile" class="headerlink" title="reduceWhile"></a>reduceWhile</h5><pre><code>定义：与 reduce 类似， reduceWhile 会遍历列表，相继调用二元迭代函数，并返回最终累积值。
reduceWhile 在每次调用迭代函数前，先使用 predicate 进行判断，如果 predicate 返回 false ，则提前终止遍历操作，并返回当前累积值。
```   
var isOdd = (acc, x) =&gt; x % 2 === 1;
var xs = [1, 3, 5, 60, 777, 800];
R.reduceWhile(isOdd, R.add, 0, xs); // 9
```   
</code></pre><h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><pre><code>定义：filter 的补操作。返回结果为 R.filter 操作结果的补集。
```   
var isOdd = (acc, x) =&gt; x % 2 === 1;
R.reject(isOdd, [1, 2, 3, 4]); // [2, 4]
```   
</code></pre><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><pre><code>定义：删除列表中从 start 开始的 count 个元素。_ 注意，该操作是非破坏性的：不改变原列表，返回处理后列表的拷贝。
```   
R.remove(2, 3, [1, 2, 3, 4, 5, 6, 7, 8]); // [1, 2, 6, 7, 8]
```   
</code></pre><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><pre><code>定义：生成包含 n 个同一元素的数组。
```   
R.repeat(&apos;h&apos;, 5); // [&apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;]
```   
</code></pre><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><pre><code>定义：对列表或字符串的排列顺序取反。
```   
R.reverse([1, 2, 3]); // [3, 2, 1]
```   
</code></pre><h5 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h5><pre><code>定义：Scan 与 reduce 类似，但会将每次迭代计算的累积值记录下来，组成一个列表返回。
```   
var numbers = [1, 2, 3, 4];
var factorials = R.scan(R.multiply, 1, numbers); // [1, 1, 2, 6, 24]
```   
</code></pre><h5 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h5><pre><code>定义：将一个 Applicative 的 Traversable 转换成一个 Traversable 类型的 Applicative。
```   
R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=&gt; Just([1, 2, 3])
```   
</code></pre><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><pre><code>定义：取出给定的列表或字符串（或带有 slice 方法的对象）中，从 fromIndex（包括）到 toIndex（不包括）的元素。
```   
R.slice(1, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]); // [&apos;b&apos;, &apos;c&apos;]
```   
</code></pre><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><pre><code>定义：使用比较函数对列表进行排序。比较函数每次接受两个参数，如果第一个值较小，则返回负数；如果第一个值较大，则返回正数；如果两值相等，返回零。注意，返回的是列表的 拷贝 ，不会修改原列表。
```   
var diff = function (a, b) { return a - b };
R.sort(diff, [4, 2, 7, 5]); // [2, 4, 5, 7]
```   
</code></pre><h5 id="splitAt"><a href="#splitAt" class="headerlink" title="splitAt"></a>splitAt</h5><pre><code>定义：在指定的索引处拆分列表或者字符串。
```   
R.splitAt(1, [1, 2, 3]); // [[1], [2, 3]]
R.splitAt(5, &apos;hello world&apos;); // [&apos;hello&apos;, &apos;world&apos;]
```   
</code></pre><h5 id="splitEvery"><a href="#splitEvery" class="headerlink" title="splitEvery"></a>splitEvery</h5><pre><code>定义：将列表拆分成指定长度的子列表集。
```   
R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); // [[1, 2, 3], [4, 5, 6], 7]
R.splitEvery(3, &apos;foobarbaz&apos;); //=&gt; [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]
```   
</code></pre><h5 id="splitWhen"><a href="#splitWhen" class="headerlink" title="splitWhen"></a>splitWhen</h5><pre><code>定义：查找列表中首个满足 predicate 的元素，在该处将列表拆分为两部分。首个满足 predicate 的元素包含在后一部分。
```   
R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=&gt; [[1], [2, 3, 1, 2, 3]]
```   
</code></pre><h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h5><pre><code>定义：检查列表是否以给定的值开头。
```   
R.startsWith(&apos;a&apos;, &apos;abc&apos;); // true
R.startsWith([&apos;a&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true
```   
</code></pre><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><pre><code>定义：删除列表中的首个元素（或者调用对象的 tail 方法）。
```   
R.tail([1, 2, 3]); // [2, 3]
```   
</code></pre><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><pre><code>定义：返回列表的前 n 个元素、字符串的前n个字符或者用作 transducer/transform（或者调用对象的 take 方法）。
```   
R.take(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;]
```   
</code></pre><h5 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h5><pre><code>定义：返回列表的后 n 个元素。如果 n &gt; list.length，则返回 list.length 个元素。
```   
R.takeLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;baz&apos;]
```   
</code></pre><h5 id="takeLastWhile"><a href="#takeLastWhile" class="headerlink" title="takeLastWhile"></a>takeLastWhile</h5><pre><code>定义：从后往前取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。
```   
var isNotOne = x =&gt; x !== 1;
R.takeLastWhile(isNotOne, [1, 2, 3, 4]); // [2, 3, 4]
```   
</code></pre><h5 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h5><pre><code>定义：从前往后取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。
```   
var isNotFour = x =&gt; x !== 4;
R.takeLastWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3]
```   
</code></pre><h5 id="times"><a href="#times" class="headerlink" title="times"></a>times</h5><pre><code>定义：执行输入的函数 n 次，返回由函数执行结果组成的数组。
fn 为一元函数，n 次调用接收的参数为：从 0 递增到 n-1 。
```   
R.times(R.identity, 5); // [0, 1, 2, 3, 4]
```   
</code></pre><h5 id="transduce"><a href="#transduce" class="headerlink" title="transduce"></a>transduce</h5><pre><code>定义：用 iterator function 初始化 transducer ，生成一个 transformed iterator function。
然后顺次遍历列表，对每个列表元素先进行转换，然后与累积值进行归约，返回值作为下一轮迭代的累积值。最终返回与初始累积值类型相同的一个累积值。
```   
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));
R.transduce(transducer, R.flip(R.append), [], numbers); //=&gt; [2, 3]
```   
</code></pre><h5 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h5><pre><code>定义：二维数组行列转置。输入 n 个长度为 x 的数组，输出 x 个长度为 n 的数组。
```   
R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
```       
</code></pre><h5 id="traverse"><a href="#traverse" class="headerlink" title="traverse"></a>traverse</h5><pre><code>定义：将返回值为 Applicative 类型的函数映射到一个 Traversable 上。
然后使用 sequence 将结果由 Traversable of Applicative 转换为 Applicative of Traversable。
```   
var safeDiv = n =&gt; d =&gt; d === 0 ? Nothing() : Just(n / d);
R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=&gt; Just([5, 2.5, 2])
```       
</code></pre><h5 id="unfold"><a href="#unfold" class="headerlink" title="unfold"></a>unfold</h5><pre><code>定义：通过一个种子值（ seed ）创建一个列表。unfold 接受一个迭代函数：
该函数或者返回 false 停止迭代，或者返回一个长度为 2 的数组：数组首个元素添加到结果列表，第二个元素作为种子值传给下一轮迭代使用。
```   
var f = n =&gt; n &gt; 50 ? false : [-n, n + 10];
R.unfold(f, 10); //=&gt; [-10, -20, -30, -40, -50]
```       
</code></pre><h5 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h5><pre><code>定义：列表去重操作。返回无重复元素的列表。通过 R.equals 函数进行相等性判断。
```   
R.uniq([1, 1, 2, 1]); // [1, 2]
```   
</code></pre><h5 id="uniqBy"><a href="#uniqBy" class="headerlink" title="uniqBy"></a>uniqBy</h5><pre><code>定义：返回无重复元素的列表。元素通过给定的函数的返回值以及 R.equals 进行相同性判断。如果给定的函数返回值相同，保留第一个元素。
```   
R.uniqBy(Math.abs, [1, -1, 2, 1]); // [1, 2]
```   
</code></pre><h5 id="uniqWith"><a href="#uniqWith" class="headerlink" title="uniqWith"></a>uniqWith</h5><pre><code>定义：返回无重复元素的列表。元素通过 predicate 进行相同性判断。如果通过 predicate 判断两元素相同，保留第一个元素。
```   
var strEq = R.eqBy(String);
R.uniqWith(strEq)([1, &apos;1&apos;, 2, 1]); //=&gt; [1, 2]
```   
</code></pre><h5 id="unnest"><a href="#unnest" class="headerlink" title="unnest"></a>unnest</h5><pre><code>定义：R.chain(R.identity) 的简写, 对 Chain 类型的数据消除一层嵌套。
```   
R.unnest([1, [2], [[3]]]); //=&gt; [1, 2, [3]]
```   
</code></pre><h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><pre><code>定义：替换数组中指定索引处的值。
```   
R.update(1, 11, [0, 1, 2]); // [0, 11, 2]
```   
</code></pre><h5 id="without"><a href="#without" class="headerlink" title="without"></a>without</h5><pre><code>定义：求第二个列表中，未包含在第一个列表中的任一元素的集合。通过 R.equals 函数进行相等性判断。
```   
R.without([1, 2], [1, 2, 1, 3, 4]); // [3, 4]
```   
</code></pre><h5 id="xprod"><a href="#xprod" class="headerlink" title="xprod"></a>xprod</h5><pre><code>定义：将两个列表的元素两两组合，生成一个新的元素对列表。
```   
R.xprod([1, 2], [&apos;a&apos;, &apos;b&apos;]); // [[1, &apos;a&apos;], [1, &apos;b&apos;], [2, &apos;a&apos;], [2, &apos;b&apos;]]
```   
</code></pre><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><pre><code>定义：将两个列表对应位置的元素组合，生成一个新的元素对列表。生成的列表长度取决于较短的输入列表的长度。
注意，zip 等价于 zipWith(function(a, b) { return [a, b] }) 。
```   
R.zip([1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]
```   
</code></pre><h5 id="zipObj"><a href="#zipObj" class="headerlink" title="zipObj"></a>zipObj</h5><pre><code>定义：将两个列表对应位置的元素作为键值对组合，生成一个新的键值对的列表。生成的列表长度取决于较短的输入列表的长度。
注意，zip 等价于 pipe(zipWith(pair), fromPairs) 。
```   
R.zipObj([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]); // {a: 1, b: 2, c: 3}
```   
</code></pre><h5 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h5><pre><code>定义：将两个列表对应位置的元素通过一个函数处理，生成一个新的元素的列表。生成的列表长度取决于较短的输入列表的长度。
```   
var f = (x, y) =&gt; {
  // ...
};
R.zipWith(f, [1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);
//=&gt; [f(1, &apos;a&apos;), f(2, &apos;b&apos;), f(3, &apos;c&apos;)]
```   
</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="assoc"><a href="#assoc" class="headerlink" title="assoc"></a>assoc</h5><pre><code>定义：浅复制对象，然后设置或覆盖对象的指定属性。
```   
R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); {a: 1, b: 2, c: 3}
```       
</code></pre><h5 id="assocPath"><a href="#assocPath" class="headerlink" title="assocPath"></a>assocPath</h5><pre><code>定义：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。
```   
R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); // {a: {b: {c: 42}}}
```       
</code></pre><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><pre><code>定义：深复制。其值可能（嵌套）包含 Array、Object、Number、String、Boolean、Date 类型的数据。Function 通过引用复制。
```   
var objects = [{}, {}, {}];
var objectsClone = R.clone(objects);
objects === objectsClone; // true
```           
</code></pre><h5 id="dissoc"><a href="#dissoc" class="headerlink" title="dissoc"></a>dissoc</h5><pre><code>定义：删除对象中指定 prop 属性。
```   
R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); // {a: 1, c: 3}
```           
</code></pre><h5 id="dissocPath"><a href="#dissocPath" class="headerlink" title="dissocPath"></a>dissocPath</h5><pre><code>定义：浅复制对象，删除返回对象中指定路径上的属性。
```   
R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); // {a: {b: {}}}
```       
</code></pre><h5 id="eqProps"><a href="#eqProps" class="headerlink" title="eqProps"></a>eqProps</h5><pre><code>定义：判断两个对象指定的属性值是否相等。通过 R.equals 函数进行相等性判断。可用作柯里化的 predicate 。
```   
var o1 = {a: 1, b: 2, c: 3, d: 4};
var o2 = {a: 10, b: 20, c: 3, d: 40};
R.eqProps(&apos;a&apos;, o1, o2); // false
```       
</code></pre><h5 id="evolve"><a href="#evolve" class="headerlink" title="evolve"></a>evolve</h5><pre><code>定义：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。所有非原始类型属性都通过引用来复制。
如果某个 transformation 函数对应的键在被变换的 object 中不存在，那么该方法将不会执行。
```   
var tomato  = {firstName: &apos;  Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123};
var transformations = {
    firstName: R.trim,
    lastName: R.trim, // Will not get invoked
    data: {elapsed: R.add(1), remaining: R.add(-1)}
};
R.evolve(transformations, tomato); // {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123}
```       
</code></pre><h5 id="forEachObjIndexed"><a href="#forEachObjIndexed" class="headerlink" title="forEachObjIndexed"></a>forEachObjIndexed</h5><pre><code>定义：遍历 object，对 object 中的每对 key 和 value 执行方法 fn。
fn 接收三个参数: (value, key, obj).
```   
var printKeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value);
R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=&gt; {x: 1, y: 2}
```       
</code></pre><h5 id="has"><a href="#has" class="headerlink" title="has"></a>has</h5><pre><code>定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。
```   
R.has(&apos;name&apos;)({name: &apos;fanerge&apos;}); // true
```       
</code></pre><h5 id="hasIn"><a href="#hasIn" class="headerlink" title="hasIn"></a>hasIn</h5><pre><code>定义：如果对象自身或原型链上含有指定的属性，则返回 true；否则返回 false。
```   
var Rect = function (w, h) {
    this.width = w;
    this.height = h;
};
Rect.prototype.area = function (){
    return this.width * this.heigth;
};
var rect1 = new Rect(100, 200);
R.hasIn(&apos;area&apos;)(rect1); // true
```       
</code></pre><h5 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h5><pre><code>定义：与 R.invertObj 类似，但会将值放入数组中，来处理一个键对应多个值的情况。
```   
var raceResultsByFirstName = {
  first: &apos;alice&apos;,
  second: &apos;jake&apos;,
  third: &apos;alice&apos;,
};
R.invert(raceResultsByFirstName);
//=&gt; { &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] }
```       
</code></pre><h5 id="invertObj"><a href="#invertObj" class="headerlink" title="invertObj"></a>invertObj</h5><pre><code>定义：将对象的键、值交换位置：值作为键，对应的键作为值。交换后的键会被强制转换为字符串。注意，如果原对象同一值对应多个键，采用最后遍历到的键。
```   
var raceResults = {
  first: &apos;alice&apos;,
  second: &apos;jake&apos;
};
R.invertObj(raceResults);
//=&gt; { &apos;alice&apos;: &apos;first&apos;, &apos;jake&apos;:&apos;second&apos; }
```       
</code></pre><h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><pre><code>定义：返回给定对象所有可枚举的、自身属性的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.keys({a: 1, b: 2, c: 3}); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
```       
</code></pre><h5 id="keysIn"><a href="#keysIn" class="headerlink" title="keysIn"></a>keysIn</h5><pre><code>定义：返回给定对象所有属性（包括 prototype 属性）的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function () { this.x = &apos;X&apos; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.keysIn(f); // [&apos;x&apos;, &apos;y&apos;]
```       
</code></pre><h5 id="lens"><a href="#lens" class="headerlink" title="lens"></a>lens</h5><pre><code>定义：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。
setter 不会改变原数据。
```   
var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));
R.view(xLens, {x: 1, y: 2}); // 1
R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2}
R.over(xLens, R.negate, {x: 1, y: 2}); // {x: -1, y: 2}
```       
</code></pre><h5 id="lensIndex"><a href="#lensIndex" class="headerlink" title="lensIndex"></a>lensIndex</h5><pre><code>定义：返回聚焦到指定索引的 lens。
```   
var headLens = R.lensIndex(0);
R.view(headLens, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // a
R.set(headLens, &apos;x&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;x&apos;, &apos;b&apos;, &apos;c&apos;]
R.over(headLens, R.toUpper, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]
```       
</code></pre><h5 id="lensPath"><a href="#lensPath" class="headerlink" title="lensPath"></a>lensPath</h5><pre><code>定义：返回聚焦到指定路径的 lens。
```   
var xHeadYLens = R.lensPath([&apos;x&apos;, 0, &apos;y&apos;]);
R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // 2
R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
```       
</code></pre><h5 id="lensProp"><a href="#lensProp" class="headerlink" title="lensProp"></a>lensProp</h5><pre><code>定义：返回聚焦到指定属性的 lens。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.view(xLens, {x: 1, y: 2});            //=&gt; 1
R.set(xLens, 4, {x: 1, y: 2});          //=&gt; {x: 4, y: 2}
R.over(xLens, R.negate, {x: 1, y: 2});  //=&gt; {x: -1, y: 2}
```       
</code></pre><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。
```   
R.merge({&apos;name&apos;: &apos;fanerge&apos;, &apos;age&apos;: 10}, {age: 30}); // {&apos;name&apos;: &apos;fanerge&apos;, age: 30}
```   
</code></pre><h5 id="mergaDeepLeft"><a href="#mergaDeepLeft" class="headerlink" title="mergaDeepLeft"></a>mergaDeepLeft</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个值都是对象，则继续递归合并这两个值。
否则，采用第一个对象的值。
```   
R.mergeDeepLeft({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }},
            { age: 40, contact: { email: &apos;baa@example.com&apos; }});
// { name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }}
```   
</code></pre><h5 id="mergaDeepRight"><a href="#mergaDeepRight" class="headerlink" title="mergaDeepRight"></a>mergaDeepRight</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个值都是对象，则继续递归合并这两个值。
否则，采用第二个对象的值。
```   
R.mergeDeepRight({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }},
             { age: 40, contact: { email: &apos;baa@example.com&apos; }});
// { name: &apos;fred&apos;, age: 40, contact: { email: &apos;baa@example.com&apos; }}
```   
</code></pre><h5 id="mergaDeepWith"><a href="#mergaDeepWith" class="headerlink" title="mergaDeepWith"></a>mergaDeepWith</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个关联的值都是对象，则继续递归合并这两个值。
否则，使用给定函数对两个值进行处理，并将返回值作为该 key 的新值。
如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。
```   
R.mergeDeepWith(R.concat,
            { a: true, c: { values: [10, 20] }},
            { b: true, c: { values: [15, 35] }});
// { a: true, b: true, c: { values: [10, 20, 15, 35] }}
```   
</code></pre><h5 id="mergeDeepWithKey"><a href="#mergeDeepWithKey" class="headerlink" title="mergeDeepWithKey"></a>mergeDeepWithKey</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个关联的值都是对象，则继续递归合并这两个值。
否则，使用给定函数对该 key 和对应的两个值进行处理，并将返回值作为该 key 的新值。
如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。
```   
let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r
R.mergeDeepWithKey(concatValues,
                   { a: true, c: { thing: &apos;foo&apos;, values: [10, 20] }},
                   { b: true, c: { thing: &apos;bar&apos;, values: [15, 35] }});
// { a: true, b: true, c: { thing: &apos;bar&apos;, values: [10, 20, 15, 35] }}
```       
</code></pre><h5 id="mergeWith"><a href="#mergeWith" class="headerlink" title="mergeWith"></a>mergeWith</h5><pre><code>定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。
如果某个 key 在两个对象中都存在，则使用给定的函数对每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。
```   
R.mergeWith(R.concat, 
                {a: true, values: [10, 20]}, 
                {b: true, values: [15, 35]});
// {a: true, b: true, values: [10, 20, 15, 35]}
```       
</code></pre><h5 id="mergeWithKey"><a href="#mergeWithKey" class="headerlink" title="mergeWithKey"></a>mergeWithKey</h5><pre><code>定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。
如果某个 key 在两个对象中都存在，则使用给定的函数对该 key 和每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。
```   
let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r
R.mergeWithKey(concatValues,
               { a: true, thing: &apos;foo&apos;, values: [10, 20] },
               { b: true, thing: &apos;bar&apos;, values: [15, 35] });
// { a: true, b: true, thing: &apos;bar&apos;, values: [10, 20, 15, 35] }
```       
</code></pre><h5 id="objOf"><a href="#objOf" class="headerlink" title="objOf"></a>objOf</h5><pre><code>定义：创建一个包含单个键值对的对象。
```   
var matchPhrases = R.compose(
    R.objOf(&apos;must&apos;),
    R.map(R.objOf(&apos;match_phrase&apos;))
);
matchPhrases([&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; {must: [{match_phrase: &apos;foo&apos;}, {match_phrase: &apos;bar&apos;}, {match_phrase: &apos;baz&apos;}]}
```   
</code></pre><h5 id="omit"><a href="#omit" class="headerlink" title="omit"></a>omit</h5><pre><code>定义：删除对象中给定的 keys 对应的属性。
```   
R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {b: 2, c: 3}
```       
</code></pre><h5 id="over"><a href="#over" class="headerlink" title="over"></a>over</h5><pre><code>定义：对数据结构中被 lens 聚焦的部分进行函数变换。
```   
var headLens = R.lensIndex(0);
R.over(headLens, R.toUpper, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); // [&apos;FOO&apos;, &apos;bar&apos;, &apos;baz&apos;]
```       
</code></pre><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><pre><code>定义：取出给定路径上的值。
```   
R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2
```       
</code></pre><h5 id="pathOr"><a href="#pathOr" class="headerlink" title="pathOr"></a>pathOr</h5><pre><code>定义：如果非空对象在给定路径上存在值，则将该值返回；否则返回给定的默认值。
```   
R.pathOr(&apos;N/A&apos;, [&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2
```       
</code></pre><h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。
```   
R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4}
```       
</code></pre><h5 id="pickAll"><a href="#pickAll" class="headerlink" title="pickAll"></a>pickAll</h5><pre><code>定义：与 pick 类似，但 pickAll 会将不存在的属性以 key: undefined 键值对的形式返回。
```   
R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;e&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4, e: undefined}
```       
</code></pre><h5 id="pickBy"><a href="#pickBy" class="headerlink" title="pickBy"></a>pickBy</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含 key 满足 predicate 的属性。
```   
var isUpperCase = (val, key) =&gt; key.toUpperCase() === key;
R.pickBy(isUpperCase, {a: 1,b: 2, A: 3, B: 4}); // {A: 3, B: 4}
```       
</code></pre><h5 id="project"><a href="#project" class="headerlink" title="project"></a>project</h5><pre><code>定义：模拟 SQL 中的 select 语句。
```   
var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2};
var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7};
var kids = [abby, fred];
R.project([&apos;name&apos;, &apos;grade&apos;], kids); // [{name: &apos;Abby&apos;, grade: 2}, {name: &apos;Fred&apos;, grade: 7}]
```   
</code></pre><h5 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h5><pre><code>定义：取出对象中指定属性的值。如果不存在，则返回 undefined。
```   
R.prop(&apos;x&apos;, {x: 100}); // 100
```   
</code></pre><h5 id="propOr"><a href="#propOr" class="headerlink" title="propOr"></a>propOr</h5><pre><code>定义：对于给定的非空对象，如果指定属性存在，则返回该属性值；否则返回给定的默认值。
```   
var alice = {
  name: &apos;ALICE&apos;,
  age: 101
};
var favorite = R.prop(&apos;favoriteLibrary&apos;);
var favoriteWithDefault = R.propOr(&apos;Ramda&apos;, &apos;favoriteLibrary&apos;);

favorite(alice);  // undefined
favoriteWithDefault(alice);  // &apos;Ramda&apos;
```   
</code></pre><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><pre><code>定义：返回 prop 的数组：输入为 keys 数组，输出为对应的 values 数组。values 数组的顺序与 keys 的相同。
```   
R.props([&apos;x&apos;, &apos;y&apos;], {x: 1, y: 2}); // [1, 2]
```   
</code></pre><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><pre><code>定义：通过 lens 对数据结构聚焦的部分进行设置。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2}
```   
</code></pre><h5 id="toPairs"><a href="#toPairs" class="headerlink" title="toPairs"></a>toPairs</h5><pre><code>定义：将一个对象的属性转换成键、值二元组类型的数组，只处理对象自身的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.toPairs({a: 1, b: 2, c: 3}); // [[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]
```       
</code></pre><h5 id="toPairsIn"><a href="#toPairsIn" class="headerlink" title="toPairsIn"></a>toPairsIn</h5><pre><code>定义：将一个对象的属性转换成键、值二元组类型的数组，包括原型链上的属性。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function () { this.x = &apos;X&apos;; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.toPairsIn(f); // [[&apos;x&apos;,&apos;X&apos;], [&apos;y&apos;,&apos;Y&apos;]]
```       
</code></pre><h5 id="values"><a href="#values" class="headerlink" title="values"></a>values</h5><pre><code>定义：返回对象所有自身可枚举的属性的值。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.values({a: 1, b: 2, c: 3}); //=&gt; [1, 2, 3]
```       
</code></pre><h5 id="valuesIn"><a href="#valuesIn" class="headerlink" title="valuesIn"></a>valuesIn</h5><pre><code>定义：返回对象所有属性的值，包括原型链上的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function() { this.x = &apos;X&apos;; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.valuesIn(f); //=&gt; [&apos;X&apos;, &apos;Y&apos;]
```       
</code></pre><h5 id="view"><a href="#view" class="headerlink" title="view"></a>view</h5><pre><code>定义：返回数据结构中，lens 聚焦的部分。lens 的焦点决定了数据结构中的哪部分是可见的。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.view(xLens, {x: 1, y: 2});  //=&gt; 1
```       
</code></pre><h5 id="where"><a href="#where" class="headerlink" title="where"></a>where</h5><pre><code>定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。测试规范对象的每个属性值都必须是 predicate 。
每个 predicate 作用于待检测对象对应的属性值，如果所有 predicate 都返回 true，则 where 返回 true，否则返回 false 。
where 非常适合于需要声明式表示约束的函数，比如 filter 和 find 。
```   
var pred = R.where({
  a: R.equals(&apos;foo&apos;),
  b: R.complement(R.equals(&apos;bar&apos;)),
  x: R.gt(R.__, 10),
  y: R.lt(R.__, 20)
});

pred({a: &apos;foo&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; true
pred({a: &apos;xxx&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; false
```       
</code></pre><h5 id="whereEq"><a href="#whereEq" class="headerlink" title="whereEq"></a>whereEq</h5><pre><code>定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。
如果对于每一个测试规范对象的属性值，待检测对象中都有一个对应的相同属性值，则 where 返回 true，否则返回 false 。
whereEq 是 where 的一种特殊形式。
```   
var pred = R.whereEq({a: 1, b: 2});
pred({a: 1});              //=&gt; false
pred({a: 1, b: 2});        //=&gt; true
```       
</code></pre><h4 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h4><h5 id="allPass"><a href="#allPass" class="headerlink" title="allPass"></a>allPass</h5><pre><code>定义：传入包含多个 predicate 的列表，返回一个 predicate：如果给定的参数满足列表中的所有 predicate ，则返回 true。
该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。
```   
var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;);
var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;);
var isQueenOfSpades = R.allPass([isQueen, isSpade]);
isQueenOfSpades({rank: &apos;Q&apos;, suit: &apos;??&apos;}); // true
```   
</code></pre><h5 id="anyPass"><a href="#anyPass" class="headerlink" title="anyPass"></a>anyPass</h5><pre><code>定义：传入包含多个 predicate 的列表，返回一个 predicate：只要给定的参数满足列表中的一个 predicate ，就返回 true。
该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。
```   
var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;);
var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;);
var isQueenOfSpades = R.anyPass([isQueen, isSpade]);
isQueenOfSpades({rank: &apos;K&apos;, suit: &apos;??&apos;}); // true
```   
</code></pre><h5 id="and（针对于值）"><a href="#and（针对于值）" class="headerlink" title="and（针对于值）"></a>and（针对于值）</h5><pre><code>定义：如果两个参数都是 true，则返回 true；否则返回 false。相当于且（&amp;&amp;）
```   
R.and(true, true); // true
```           
</code></pre><h5 id="or（针对于值）"><a href="#or（针对于值）" class="headerlink" title="or（针对于值）"></a>or（针对于值）</h5><pre><code>定义：逻辑或运算，只要有一个参数为 truth-y，就返回 true；否则返回 false。
```   
R.or(true, true); // true
```   
</code></pre><h5 id="not（针对于值）"><a href="#not（针对于值）" class="headerlink" title="not（针对于值）"></a>not（针对于值）</h5><pre><code>定义：逻辑非运算。 当传入参数为 false-y 值时，返回 true；truth-y 值时，返回 false。
```   
R.not(true); // false
```   
</code></pre><h5 id="both（针对于函数）"><a href="#both（针对于函数）" class="headerlink" title="both（针对于函数）"></a>both（针对于函数）</h5><pre><code>定义：该函数调用两个函数，并对两函数返回值进行与操作。若第一个函数结果为 false-y 值 (false, null, 0 等)，则返回该结果，否则返回第二个函数的结果。注意，both 为短路操作，即如果第一个函数返回 false-y 值，则不会调用第二个函数。
```   
var gt10 = R.gt(R.__, 10);
var lt20 = R.lt(R.__, 20);
var f = R.both(gt10, lt20);
f(15); // true
```           
</code></pre><h5 id="either（针对于函数）"><a href="#either（针对于函数）" class="headerlink" title="either（针对于函数）"></a>either（针对于函数）</h5><pre><code>定义：返回由 || 运算符连接的两个函数的包装函数。如果两个函数中任一函数的执行结果为 truth-y，则返回其执行结果。 注意，这个是短路表达式，意味着如果第一个函数返回 truth-y 值的话，第二个函数将不会执行。
```   
var gt10 = x =&gt; x &gt; 10;
var even = x =&gt; x % 2 === 0;
var f = R.either(gt10, even);
f(101); // true
```   
</code></pre><h5 id="complement（针对于函数）"><a href="#complement（针对于函数）" class="headerlink" title="complement（针对于函数）"></a>complement（针对于函数）</h5><pre><code>定义：对函数的返回值取反。接受一个函数 f，返回一个新函数 g：在输入参数相同的情况下，若 f 返回 &apos;true-y&apos; ，则 g 返回 false-y ，反之亦然。
```   
var isNotNil = R.complement(R.isNil);
isNotNil(null); // true
```       
</code></pre><h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><pre><code>定义：返回一个封装了 if / else，if / else if/ else逻辑的函数 fn。 R.cond 接受列表元素为 [predicate，transformer] 的列表。 
fn 的所有参数顺次作用于每个 predicate，直到有一个返回 &quot;truthy&quot; 值，此时相应 transformer 对参数处理，并作为 fn 的结果返回。
如果没有 predicate 匹配，则 fn 返回 undefined。
```   
var fn = R.cond([
    [R.equals(0), R.always(&apos;water freezes at 0&apos;)],
    [R.equals(100), R.always(&apos;water freezes at 100&apos;)],
    [R.T, temp =&gt; `nothing special happens at ${temp}`],
]);
fn(3); // nothing special happens at 3
```       
</code></pre><h5 id="defaultTo"><a href="#defaultTo" class="headerlink" title="defaultTo"></a>defaultTo</h5><pre><code>定义：如果第二个参数不是 null、undefined 或 NaN，则返回第二个参数，否则返回第一个参数（默认值）。
```   
var defaultTo42 = R.defaultTo(42);
defaultTo42(undefined); // 42 
defaultTo42(13); // 13 
```       
</code></pre><h5 id="ifElse"><a href="#ifElse" class="headerlink" title="ifElse"></a>ifElse</h5><pre><code>定义：根据 condition predicate 的返回值调用 onTrue 或 onFalse 函数。
```   
var inCount = R.ifElse(
    R.has(&apos;count&apos;),
    R.over(R.lensProp(&apos;count&apos;), R.inc),
    R.assoc(&apos;count&apos;, 1)
);
incCount({});           //=&gt; { count: 1 }
incCount({ count: 1 }); //=&gt; { count: 2 }
```       
</code></pre><h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h5><pre><code>定义：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。
```   
R.isEmpty([1, 2, 3]); // false
R.isEmpty(&apos;&apos;); // true
```   
</code></pre><h5 id="pathSatisfies"><a href="#pathSatisfies" class="headerlink" title="pathSatisfies"></a>pathSatisfies</h5><pre><code>定义：如果对象的给定路径上的属性满足 predicate，返回 ture；否则返回 false。
```   
R.pathSatisfies(y =&gt; y &gt; 0, [&apos;x&apos;, &apos;y&apos;], {x: {y: 2}}); // true
```   
</code></pre><h5 id="propSatisfies"><a href="#propSatisfies" class="headerlink" title="propSatisfies"></a>propSatisfies</h5><pre><code>定义：如果指定的对象属性满足 predicate，返回 true；否则返回 false。
```   
R.propSatisfies(x =&gt; x &gt; 0, &apos;x&apos;, {x: 1, y: 2}); // true
```   
</code></pre><h5 id="unless"><a href="#unless" class="headerlink" title="unless"></a>unless</h5><pre><code>定义：判断输入值是否满足 predicate，若不符合，则将输入值传给 whenFalseFn 处理，并将处理结果作为返回；若符合，则将输入值原样返回。
```   
let safeInc = R.unless(R.isNil, R.inc);
safeInc(null); //=&gt; null
safeInc(1); //=&gt; 2
```   
</code></pre><h5 id="until"><a href="#until" class="headerlink" title="until"></a>until</h5><pre><code>定义：接受一个 predicate ，transform function 和 初始值，返回一个与初始值相同类型的值。
对输入值进行 transform ，直到 transform 的结果满足 predicate，此时返回这个满足 predicate 的值。
```   
R.until(R.gt(R.__, 100), R.multiply(2))(1); // 128
```   
</code></pre><h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><pre><code>定义：判断输入值是否满足 predicate，若符合，则将输入值传给 whenTrueFn 处理，并将处理结果作为返回；若不符合，则将输入值原样返回。
```   
var truncate = R.when(
  R.propSatisfies(R.gt(R.__, 10), &apos;length&apos;),
  R.pipe(R.take(10), R.append(&apos;…&apos;), R.join(&apos;&apos;))
);
truncate(&apos;12345&apos;);         // &apos;12345&apos;
truncate(&apos;0123456789ABC&apos;); // &apos;0123456789…&apos;
```   
</code></pre><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><h5 id=""><a href="#" class="headerlink" title="__"></a>__</h5><pre><code>定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。
```   
假设 g 代表柯里化的三元函数
g(1, 2, 3)
g(R.__, 2, 3)(1)
g(R.__, R__, 3)(1)(2)
g(R.__, 2, R.__)(1)(3)
g(R.__, 2)(R.__, 3)(1)
// 这些函数都是等价的。
var greet = R.replace(&apos;{name}&apos;, R.__, &apos;Hello, {name}!&apos;);
greet(&apos;Fanerge&apos;); // Hello, Fanerge
```       
</code></pre><h5 id="addIndex"><a href="#addIndex" class="headerlink" title="addIndex"></a>addIndex</h5><pre><code>定义：通过向列表迭代函数的回调函数添加两个新的参数：当前索引、整个列表，创建新的列表迭代函数。
```   
var mapIndexed = R.addIndex(R.map);
mapIndexed((val, idx) =&gt; {idx + &apos;-&apos; + val}, [&apos;f&apos;, &apos;a&apos;, &apos;n&apos;]); // [&apos;0-f&apos;, &apos;1-a&apos;, &apos;2-n&apos;]
```   
</code></pre><h5 id="always"><a href="#always" class="headerlink" title="always"></a>always</h5><pre><code>定义：返回一个返回恒定值的函数。注意，对于非原始值，返回的值是对原始值的引用。
```   
var t = R.always(&apos;Tee&apos;);
t(); // Tee
```   
</code></pre><h5 id="ap"><a href="#ap" class="headerlink" title="ap"></a>ap</h5><pre><code>定义：将函数列表作用于值列表上。
```   
R.ap([R.multiply(2), R.add(3)], [1, 2, 3]); // [2, 4, 6, 4, 5, 6]
```   
</code></pre><h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><pre><code>定义：将函数 fn 作用于参数列表 args。apply 可以将变参函数转换为为定参函数。如果上下文很重要，则 fn 应该绑定其上下文。
```   
var nums = [1, 2, 3, -99, 42, 6, 7];
R.apply(Math.max, nums); // 42
```   
</code></pre><h5 id="applySpec"><a href="#applySpec" class="headerlink" title="applySpec"></a>applySpec</h5><pre><code>定义：接受一个属性值为函数的对象，返回一个能生成相同结构对象的函数。返回的函数使用传入的参数调用对象的每个属性位对应的函数，来生成相应属性的值。
```   
var getMetrics = R.applySpec({    
    sum: R.add,
    nested: { mul: R.multiply }
});
getMetrics(2, 4); // {sum: 6, nested: { mul: 8 }}
```   
</code></pre><h5 id="ascend"><a href="#ascend" class="headerlink" title="ascend"></a>ascend</h5><pre><code>定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个升序比较函数。
```   
var byAge = R.ascend(R.prop(&apos;age&apos;));
var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}];
var peopleByYoungestFirst = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}]
```       
</code></pre><h5 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h5><pre><code>定义：将任意元函数封装为二元函数（只接受2个参数）中。任何额外的参数都不会传递给被封装的函数。
```   
var takesThreeArgs = function (a, b, c){
    return [a, b, c];
};
vat takeTwoArgs = R.binary(takesThreeArgs);
// takeTwoArgs.length; // 2
takeTwoArgs(1, 2, 3); // [1, 2, undefined]
```           
</code></pre><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><pre><code>定义：创建一个绑定了上下文的函数。
注意：与 Function.prototype.bind 不同，R.bind 不会绑定额外参数。
```   
var log = R.bind(console.log, console);
log(1); // 1
```   
</code></pre><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><pre><code>定义：提取第一个参数作为函数，其余参数作为刚提取的函数的参数，调用该函数并将结果返回。
```   
R.call(R.add, 1, 2); // 3
```       
</code></pre><h5 id="comparator"><a href="#comparator" class="headerlink" title="comparator"></a>comparator</h5><pre><code>定义：由首个参数是否小于第二个参数的判断函数，生成一个比较函数。
```   
var byAge = R.comparator((a, b) =&gt; a.age &lt; b.age);
var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}];
var peopleByIncreasingAge = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}]
```       
</code></pre><h5 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h5><pre><code>定义：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
```   
R.compose(R.add(1), R.multiply(2))(3); // 7
```           
</code></pre><h5 id="composeK"><a href="#composeK" class="headerlink" title="composeK"></a>composeK</h5><pre><code>定义：接受一系列函数，返回从右向左的 Kleisli 组合，每个函数必须返回支持 chain 操作的值。
```   
R.composeK(h, g, f) 等同于 R.compose(R.chain(h)，R.chain(g)，R.chain(f))。
```       
</code></pre><h5 id="composeP"><a href="#composeP" class="headerlink" title="composeP"></a>composeP</h5><pre><code>定义： 从右向左执行返回 Promise 的函数的组合。最右边的函数可以是任意元函数（参数个数不限）; 其余函数必须是一元函数。
```   
var db = {
      users: {
            JOE: {
              name: &apos;Joe&apos;,
              followers: [&apos;STEVE&apos;, &apos;SUZY&apos;]
            }
      }
};
var lookupUser = (userId) =&gt; Promise.resolve(db.users[userId]);
var lookupFollowers = (user) =&gt; Promise.resolve(user.followers);
lookupUser(&apos;JOE&apos;).then(lookupFollowers);
var followersForUser = R.composeP(lookupFollowers, lookupUser);
followersForUser(&apos;JOE&apos;).then(followers =&gt; console.log(&apos;Followers:&apos;, followers)) // [&quot;STEVE&quot;,&quot;SUZY&quot;]
```   
</code></pre><h5 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h5><pre><code>定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。
```   
// constructor function
function Animal (kind) {
    this.kind = kind;
}
Animal.prototype.sighting = function () {
    return `it&apos;s a ${this.kind}!`;
};
var AnimalConstructor = R.construct(Animal);
console.log(AnimalConstructor(&apos;PIG&apos;)); // {&quot;kind&quot;:&quot;PIG&quot;}
```   
</code></pre><h5 id="constructN"><a href="#constructN" class="headerlink" title="constructN"></a>constructN</h5><pre><code>定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。为了能够使用变参的构造函数，返回函数的元数需要明确指定。
```   
function Salad() {
  this.ingredients = arguments;
};
Salad.prototype.recipe = function() {
  var instructions = R.map((ingredient) =&gt; (
    &apos;Add a whollop of &apos; + ingredient, this.ingredients)
  )
  return R.join(&apos;\n&apos;, instructions)
}

var ThreeLayerSalad = R.constructN(3, Salad)

// Notice we no longer need the &apos;new&apos; keyword, and the constructor is curried for 3 arguments.
var salad = ThreeLayerSalad(&apos;Mayonnaise&apos;)(&apos;Potato Chips&apos;)(&apos;Ketchup&apos;)
console.log(salad.recipe());
// Add a whollop of Mayonnaise
// Add a whollop of Potato Chips
// Add a whollop of Potato Ketchup
```   
</code></pre><h5 id="converge"><a href="#converge" class="headerlink" title="converge"></a>converge</h5><pre><code>定义：接受一个 converging 函数和一个分支函数列表，返回一个新函数。
当被调用时，新函数接受参数，并将这些参数转发给每个分支函数；然后将每个分支函数的计算结果作为参数传递给 converging 函数，converging 函数的计算结果即新函数的返回值。
```   
var average = R.converge(R.divide, [R.sum, R.length]);
average([1, 2, 3, 4, 5, 6, 7]); // 4
```   
</code></pre><h5 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h5><pre><code>定义：对函数进行柯里化。柯里化函数与其他语言中的柯里化函数相比，有两个非常好的特性：
1.参数不需要一次只传入一个。 
    g(1)(2)(3) === g(1, 2, 3)
2.占位符值 R.__ 可用于标记暂未传入参数的位置。允许部分应用于任何参数组合，而无需关心它们的位置和顺序。
    F(1, 2, 3) === F(R.__, 2, 3)(1) === F(R.__, 3)(1)(2)
```   
var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d;
var curriedAddFourNumbers = R.curry(addFourNumbers);
var f = curriedAddFourNumbers(1); // 返回剩余三个参数的函数
f(2, 3, 4); // 10(当参数全部传入，才返回结果)
```   
</code></pre><h5 id="curryN"><a href="#curryN" class="headerlink" title="curryN"></a>curryN</h5><pre><code>定义：对函数进行柯里化，并限制柯里化函数的元数。
```   
var sumArgs = (...args) =&gt; R.sum(args);
var curriedFourNumbers = R.curryN(5, sumArgs);
var f = curriedAddFourNumbers(1, 2);
var g = f(3, 4, 5); // 15
```       
</code></pre><h5 id="descend"><a href="#descend" class="headerlink" title="descend"></a>descend</h5><pre><code>定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个降序比较函数。
```   
var byAge = R.descend(R.prop(&apos;age&apos;));
var people = [

];
var peopleByOldFirst = R.sort(byAge, people);
```       
</code></pre><h5 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h5><pre><code>定义：根据传入参数的类型返回其对应的空值。
Ramda 定义了各类型的空值如下：Array ([])，Object ({})，String (&apos;&apos;)，和 Arguments。empty 还支持其它定义了 &lt;Type&gt;.empty 和/或 &lt;Type&gt;.prototype.empty 的类型。
```   
R.empty(Just(42)); // Noting()
R.empty([1, 2]); // []
```       
</code></pre><h5 id="F"><a href="#F" class="headerlink" title="F"></a>F</h5><pre><code>定义：恒定返回 false 的函数。忽略所有的输入参数。
```   
R.F(); // false
```       
</code></pre><h5 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h5><pre><code>定义：交换函数前两个参数的位置。
```   
var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);
mergeThree(1, 2, 3); // [1, 2, 3]
R.flip(mergeThree)(1, 2, 3); // [2, 1, 3]
```       
</code></pre><h5 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h5><pre><code>定义：将输入值原样返回。适合用作默认或占位函数。
```   
R.identity(1); // 1
var obj = {};
R.identity(obj) === obj; // true
```       
</code></pre><h5 id="invoker"><a href="#invoker" class="headerlink" title="invoker"></a>invoker</h5><pre><code>定义：将具有指定元数（参数个数）的具名方法，转换为可以被给定参数和目标对象直接调用的函数。
返回的函数是柯里化的，它接收 arity + 1 个参数，其中最后一个参数是目标对象。
```   
var sliceFrom = R.invoker(1, &apos;slice&apos;);
sliceFrom(6, &apos;abcdefghijklm&apos;); //=&gt; &apos;ghijklm&apos;
```       
</code></pre><h5 id="juxt"><a href="#juxt" class="headerlink" title="juxt"></a>juxt</h5><pre><code>定义：juxt 将函数列表作用于值列表。
```   
var getRange = R.juxt([Math.min, Math.max]);
getRange(3, 4, 9, -3); // [-3, 9]
```       
</code></pre><h5 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h5><pre><code>定义：提升一个多元函数，使之能映射到列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。
```   
var madd3 = R.lift((a, b, c) =&gt; a + b + c);
madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]
```       
</code></pre><h5 id="liftN"><a href="#liftN" class="headerlink" title="liftN"></a>liftN</h5><pre><code>定义：将一个函数提升为指定元数的函数，使之能映射到多个列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。
```   
var madd3 = R.liftN(3, (...args) =&gt; R.sum(args));
madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]
```       
</code></pre><h5 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a>memoize</h5><pre><code>定义：memoize 方法可以缓存函数的计算结果。
创建一个新函数，被调用时，缓存特定参数对应的经 fn 计算的结果，并将结果返回。
此后如果用相同的参数调用缓存的 fn 时，直接返回该参数对应的缓存结果，不必再调用 fn。
```   
var count = 0;
const factorial = R.memoize(n =&gt; {
    count += 1;
    return R.product(R.range(1, n + 1));
});
factorial(5); // 120
factorial(5); // 120
count; // 1(只进行了一次运算)
```       
</code></pre><h5 id="memoizeWith"><a href="#memoizeWith" class="headerlink" title="memoizeWith"></a>memoizeWith</h5><pre><code>定义：R.memoize 的可定制版本。memoizeWith 需要一个额外的函数，该函数接受一个参数集，用于创建缓存的键值，在该缓存中会存储被缓存函数的结果。
注意，生成缓存键值时，要避免可能会错误地覆盖之前已缓存键值对的冲突。
```   
var count = 0;
const factorial = R.memoizeWith(R.identity, n =&gt; {
    count += 1;
    return R.product(R.range(1, n + 1));
});
factorial(5); // 120
factorial(5); // 120
count; // 1(只进行了一次运算)
```           
</code></pre><h5 id="nAry"><a href="#nAry" class="headerlink" title="nAry"></a>nAry</h5><pre><code>定义：将一个任意元（包括零元）的函数，封装成一个确定元数（参数个数）的函数。任何多余的参数都不会传入被封装的函数。
```   
var takesTwoArgs = (a, b) =&gt; [a, b];
takesTwoArgs.length; // 2
takesTwoArgs(1, 2); // [1, 2]
var takesOneArg = R.nAry(1, takeTwoArgs);
takesOneArg.length; // 1
takesOneArg(1, 2); // [1, undefined]
```       
</code></pre><h5 id="nthArg"><a href="#nthArg" class="headerlink" title="nthArg"></a>nthArg</h5><pre><code>定义：返回一个函数，该函数返回它的第 n 个参数。
```   
R.nthArg(1)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;); // b
```       
</code></pre><h5 id="o"><a href="#o" class="headerlink" title="o"></a>o</h5><pre><code>定义：o 是一个柯里化组合函数，返回一元函数。
类似于 compose，o 从右到左执行函数组合。但与 compose 不同的是，传递给 o 的最右边的函数为一元函数。
```   
R.o(R.multiply(10), R.add(10))(-4); // 60
```       
</code></pre><h5 id="of"><a href="#of" class="headerlink" title="of"></a>of</h5><pre><code>定义：将给定值作为元素，封装成单元素数组。
```   
R.of(42); // [42]
```       
</code></pre><h5 id="once"><a href="#once" class="headerlink" title="once"></a>once</h5><pre><code>定义：创建一个只能调用一次的函数。
将给定函数 fn 封装到新函数fn&apos;中，fn&apos; 确保 fn 只能调用一次。重复调用fn&apos; ，只会返回第一次执行时的结果。
```   
var addOneOnce = R.once(x =&gt; x + 1);
addOneOnce(10); // 11
addOneOnce(51); // 11
```       
</code></pre><h5 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h5><pre><code>定义：部分应用。
接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将初始参数和 g 的参数顺次传给 f，并返回 f 的执行结果。
```   
var multiply2 = (a, b) =&gt; a * b;
var double = R.partial(multiply2, [2]);
double(3); // 2*3=6
```       
</code></pre><h5 id="partialRight"><a href="#partialRight" class="headerlink" title="partialRight"></a>partialRight</h5><pre><code>定义：部分应用。
接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将 g 的参数和初始参数顺序传给 f，并返回 f 的执行结果。
```   
var multiply2 = (a, b) =&gt; a * b;
var double = R.partial(multiply2, [2]);
double(3); // 3*2=6
```       
</code></pre><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><pre><code>定义：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
```   
var f = R.pipe(Math.pow, R.negate, R.inc);
f(3, 4); // -(3^4) + 1
```       
</code></pre><h5 id="pipeK"><a href="#pipeK" class="headerlink" title="pipeK"></a>pipeK</h5><pre><code>定义：将一系列函数，转换成从左到右的 Kleisli 组合，每个函数必须返回支持chain操作的值。
R.pipeK(f, g, h) 等价于 R.pipe(R.chain(f), R.chain(g), R.chain(h))。
```   
var getStateCode = R.pipeK(
  parseJson,
  get(&apos;user&apos;),
  get(&apos;address&apos;),
  get(&apos;state&apos;),
  R.compose(Maybe.of, R.toUpper)
);
getStateCode(&apos;{&quot;user&quot;:{&quot;address&quot;:{&quot;state&quot;:&quot;ny&quot;}}}&apos;);
// Just(&apos;NY&apos;)
```       
</code></pre><h5 id="pipeP"><a href="#pipeP" class="headerlink" title="pipeP"></a>pipeP</h5><pre><code>定义：从左往右执行返回 Promise 的函数的组合。最左边的函数可以是任意元函数（参数个数不限）；其余函数必须是一元函数。
```   
var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
```       
</code></pre><h5 id="T"><a href="#T" class="headerlink" title="T"></a>T</h5><pre><code>定义：恒定返回 true 的函数。忽略所有的输入参数。
```   
R.T(); // true
```       
</code></pre><h5 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h5><pre><code>定义：对输入的值执行给定的函数，然后返回输入的值。
```   
var sayX = x =&gt; console.log(&apos;x is &apos; + x);
R.tap(sayX, 100); // 100
```       
</code></pre><h5 id="tryCatch"><a href="#tryCatch" class="headerlink" title="tryCatch"></a>tryCatch</h5><pre><code>定义：tryCatch 接受两个函数：tryer 和 catcher，生成的函数执行 tryer，若未抛出异常，则返回执行结果。
若抛出异常，则执行 catcher，返回 catcher 的执行结果。注意，为了有效的组合该函数，tryer 和 catcher 应返回相同类型的值。
```   
R.tryCatch(R.prop(&apos;x&apos;), R.f)({x: true}); // true
```       
</code></pre><h5 id="unapply"><a href="#unapply" class="headerlink" title="unapply"></a>unapply</h5><pre><code>定义：输入一个只接收单个数组作为参数的函数，返回一个新函数：
接收任意个参数；
将参数组成数组传递给 fn ；
返回执行结果。
换言之，R.unapply 将一个使用数组作为参数的函数，变为一个不定参函数。 R.unapply 是 R.apply 的逆函数
```   
R.unapply(JSON.stringify, 1, 2, 3); // &apos;[1, 2, 3]&apos;
```   
</code></pre><h5 id="unary"><a href="#unary" class="headerlink" title="unary"></a>unary</h5><pre><code>定义：将任意元（包括零元）函数封装成一元函数。任何额外的参数都不会传递给被封装的函数。
```   
var takesTwoArgs = function(a, b) {
  return [a, b];
};
takesTwoArgs.length; //=&gt; 2
takesTwoArgs(1, 2); //=&gt; [1, 2]

var takesOneArg = R.unary(takesTwoArgs);
takesOneArg.length; //=&gt; 1
// 只有一个参数能被传递到函数当中
takesOneArg(1, 2); //=&gt; [1, undefined]
```   
</code></pre><h5 id="uncurryN"><a href="#uncurryN" class="headerlink" title="uncurryN"></a>uncurryN</h5><pre><code>定义：将一个柯里化的函数转换为一个 n 元函数。
```   
var addFour = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d;
var uncurriedAddFour = R.uncurryN(4, addFour);
uncurriedAddFour(1, 2, 3, 4); // 10
```   
</code></pre><h5 id="useWith"><a href="#useWith" class="headerlink" title="useWith"></a>useWith</h5><pre><code>定义：接受一个函数 fn 和一个 transformer 函数的列表，返回一个柯里化的新函数。
当被调用时，新函数将每个参数转发给对应位置的 transformer 函数，然后将每个 transformer 函数的计算结果作为参数传递给 fn，fn 的计算结果即新函数的返回值。
如果新函数传传入参数的数量比 transformer 函数的数量多，多出的参数会作为附加参数直接传给 fn 。
如果不需要处理多出的那部分参数，除了忽略之外，也可以用 identity 函数来作为 transformer ，以保证新函数的参数数量是确定的。
```   
R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=&gt; 81
```   
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><pre><code>定义：两数相加。
```   
R.add(2)(3); // 5
```   
</code></pre><h5 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h5><pre><code>定义：两数相除。等价于a / b。
```   
R.divide(71, 100); // 0.71
```   
</code></pre><h5 id="dec（相当于自减）"><a href="#dec（相当于自减）" class="headerlink" title="dec（相当于自减）"></a>dec（相当于自减）</h5><pre><code>定义：减一。与i--的区别为会生产一个新数据（不改变原有值）。
```   
R.dec(42); // 41
```   
</code></pre><h5 id="inc（相当于自加）"><a href="#inc（相当于自加）" class="headerlink" title="inc（相当于自加）"></a>inc（相当于自加）</h5><pre><code>定义：加1。
```   
R.inc(42); // 43
```       
</code></pre><h5 id="mathMod"><a href="#mathMod" class="headerlink" title="mathMod"></a>mathMod</h5><pre><code>定义：mathMod 和算术取模操作类似，而不像 % 操作符 （或 R.modulo）。所以 -17 % 5 等于 -2，而 mathMod(-17, 5) 等于 3 。
mathMod 要求参数为整型，并且当模数等于 0 或者负数时返回 NaN 。
```   
R.mathMod(-17, 5); // 3
R.mathMod(17, 5); // 2
```       
</code></pre><h5 id="mean"><a href="#mean" class="headerlink" title="mean"></a>mean</h5><pre><code>定义：返回给定数字列表的平均值。
```   
R.mean([2, 7, 9]); // 6
```       
</code></pre><h5 id="median"><a href="#median" class="headerlink" title="median"></a>median</h5><pre><code>定义：返回给定数字列表的中位数。
```   
R.median([2, 9, 7]); // 7
```       
</code></pre><h5 id="modulo"><a href="#modulo" class="headerlink" title="modulo"></a>modulo</h5><pre><code>定义：用第一个参数除以第二个参数，并返回余数。注意，该函数是 JavaScript-style 的求模操作。数学求模另见 mathMod。
```   
R.modulo(17, 3); // 2
R.modulo(-17, 3); // -2
```       
</code></pre><h5 id="multiply"><a href="#multiply" class="headerlink" title="multiply"></a>multiply</h5><pre><code>定义：两数相乘，等价于柯里化的 a * b 。
```   
R.multiply(2, 3); // 6
```   
</code></pre><h5 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h5><pre><code>定义：取反操作。
```   
R.negate(42); // -42
```   
</code></pre><h5 id="product"><a href="#product" class="headerlink" title="product"></a>product</h5><pre><code>定义：列表中的所有元素相乘。
```   
R.product([2, 3, 4]); // 24
```   
</code></pre><h5 id="subtract"><a href="#subtract" class="headerlink" title="subtract"></a>subtract</h5><pre><code>定义：首个参数减去第二个参数。
```   
R.subtract(1, 2); // -1
```   
</code></pre><h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><pre><code>定义：对数组中所有元素求和。
```   
R.sum([1, 2, 3]); // 6
```   
</code></pre><h4 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h4><h5 id="clamp"><a href="#clamp" class="headerlink" title="clamp"></a>clamp</h5><pre><code>定义：将数字限制在指定的范围内。
clamp 也可用于其他有序类型，如字符串和日期。
```   
R.clamp(1, 10, -5); // 1
R.clamp(1, 10, 4); // 4
```   
</code></pre><h5 id="countBy"><a href="#countBy" class="headerlink" title="countBy"></a>countBy</h5><pre><code>定义：根据给定函数提供的统计规则对列表中的元素进行分类计数。
返回一个对象，其键值对为：fn 根据列表元素生成键，列表中通过 fn 映射为对应键的元素的个数作为值。
注意，由于 JavaScript 对象的实现方式，所有键都被强制转换为字符串。
```   
var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
R.countBy(Math.floor, numbers); // {&apos;1&apos;: 3, &apos;2&apos;: 2, &apos;3&apos;: 1 }
```   
</code></pre><h5 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h5><pre><code>定义：求差集。求第一个列表中，未包含在第二个列表中的任一元素的集合。对象和数组比较数值相等，而非引用相等。
```   
R.difference([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [1, 2]
```   
</code></pre><h5 id="differenceWith"><a href="#differenceWith" class="headerlink" title="differenceWith"></a>differenceWith</h5><pre><code>定义：求第一个列表中未包含在第二个列表中的所有元素的集合（集合中没有重复元素）。
两列表中的元素通过 predicate 判断相应元素是否同时 “包含在” 两列表中。
```   
var cmp = (x, y) =&gt; x.a === y.a;
var l1 = [{a: 1}, {a: 2}, {a: 3}];
var l2 = [{a: 3}, {a: 4}];
R.differenceWith(cmp, l1, l2); // [{a: 1}, {a: 2}]
```   
</code></pre><h5 id="eqBy"><a href="#eqBy" class="headerlink" title="eqBy"></a>eqBy</h5><pre><code>定义：接受一个函数和两个值，通过传入函数对两个值进行相等性判断。如果两个值的计算结果相等，则返回 true ；否则返回 false 。
```   
R.eqBy(Math.abs, 5, -5); // true
```   
</code></pre><h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><pre><code>定义：如果传入的参数相等，返回 true；否则返回 false。可以处理几乎所有 JavaScript 支持的数据结构。
```   
R.equals(1, 1); // true
R.equals([&apos;1&apos;], [&apos;1&apos;]); // true
```   
</code></pre><h5 id="gt"><a href="#gt" class="headerlink" title="gt"></a>gt</h5><pre><code>定义：如果首个参数大于第二个参数，返回 true；否则返回 false。
```   
R.gt(2, 1); // true
```   
</code></pre><h5 id="gte"><a href="#gte" class="headerlink" title="gte"></a>gte</h5><pre><code>定义：如果首个参数大于等于第二个参数，返回 true；否则返回 false。
```   
R.gte(2, 1); // true
```   
</code></pre><h5 id="identical"><a href="#identical" class="headerlink" title="identical"></a>identical</h5><pre><code>定义：如果两个参数是完全相同，则返回 true，否则返回 false。
如果它们引用相同的内存，也认为是完全相同的。NaN 和 NaN 是完全相同的；0 和 -0 不是完全相同的。
```   
var o = {};
R.identical(o, o); //=&gt; true
R.identical(1, 1); //=&gt; true
```   
</code></pre><h5 id="innerJoin"><a href="#innerJoin" class="headerlink" title="innerJoin"></a>innerJoin</h5><pre><code>定义：接受一个 predicate pred 、列表 xs 和 ys ，返回列表 xs&apos;。
依次取出 xs 中的元素，若通过 pred 判断等于 ys 中的一个或多个元素，则放入 xs&apos; 。
pred 必须为二元函数，两个参数分别来自于对应两个列表中的元素。
```   
R.innerJoin(
  (record, id) =&gt; record.id === id,
  [{id: 824, name: &apos;Richie Furay&apos;},
   {id: 956, name: &apos;Dewey Martin&apos;},
   {id: 313, name: &apos;Bruce Palmer&apos;},
   {id: 456, name: &apos;Stephen Stills&apos;},
   {id: 177, name: &apos;Neil Young&apos;}],
  [177, 456, 999]
);
// [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}]
```   
</code></pre><h5 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h5><pre><code>定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。
```   
R.intersection([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [4, 3]
```   
</code></pre><h5 id="intersectionWith"><a href="#intersectionWith" class="headerlink" title="intersectionWith"></a>intersectionWith</h5><pre><code>定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。由给定的 predicate 进行相同性判断。
```   
var buffaloSpringfield = [
  {id: 824, name: &apos;Richie Furay&apos;},
  {id: 956, name: &apos;Dewey Martin&apos;},
  {id: 313, name: &apos;Bruce Palmer&apos;},
  {id: 456, name: &apos;Stephen Stills&apos;},
  {id: 177, name: &apos;Neil Young&apos;}
];
var csny = [
  {id: 204, name: &apos;David Crosby&apos;},
  {id: 456, name: &apos;Stephen Stills&apos;},
  {id: 539, name: &apos;Graham Nash&apos;},
  {id: 177, name: &apos;Neil Young&apos;}
];

var list = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield, csny);
//=&gt; [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}]
```   
</code></pre><h5 id="lt"><a href="#lt" class="headerlink" title="lt"></a>lt</h5><pre><code>定义：如果首个参数小于第二个参数，返回 true；否则返回 false。
```   
R.lt(2, 1); // false
R.lt(&apos;a&apos;, &apos;b&apos;); // true
```   
</code></pre><h5 id="lte"><a href="#lte" class="headerlink" title="lte"></a>lte</h5><pre><code>定义：如果首个参数小于或等于第二个参数，返回 true；否则返回 false。
```   
R.lt(2, 2); // false
R.lt(&apos;a&apos;, &apos;b&apos;); // true
```   
</code></pre><h5 id="max"><a href="#max" class="headerlink" title="max"></a>max</h5><pre><code>定义：返回两个参数中的较大值。
```   
R.max(789, 123); // 789
```   
</code></pre><h5 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h5><pre><code>定义：接收一个函数和两个值，返回使给定函数执行结果较大的值。
```   
var square = n =&gt; n * n;
R.maxBy(square, -3, 2); // -3
R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); // -5
```   
</code></pre><h5 id="min"><a href="#min" class="headerlink" title="min"></a>min</h5><pre><code>定义：返回两个参数中的较小值。
```   
R.min(789, 123); // 123
R.min(&apos;a&apos;, &apos;c&apos;); // a
```   
</code></pre><h5 id="minBy"><a href="#minBy" class="headerlink" title="minBy"></a>minBy</h5><pre><code>定义：接收一个函数和两个值，返回使给定函数执行结果较小的值。
```   
var square = n =&gt; n * n;
R.minBy(square, -3, 2); // 2
```   
</code></pre><h5 id="pathEq"><a href="#pathEq" class="headerlink" title="pathEq"></a>pathEq</h5><pre><code>定义：判断对象的嵌套路径上是否为给定的值，通过 R.equals 函数进行相等性判断。常用于列表过滤。
```   
var user1 = { address: { zipCode: 90210 } };
var user2 = { address: { zipCode: 55555 } };
var user3 = { name: &apos;Bob&apos; };
var users = [ user1, user2, user3 ];
var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 90210);
var list = R.filter(isFamous, users); // [{&quot;address&quot;:{&quot;zipCode&quot;:90210}}]
```   
</code></pre><h5 id="propEq"><a href="#propEq" class="headerlink" title="propEq"></a>propEq</h5><pre><code>定义：如果指定对象属性与给定的值相等，则返回 true ；否则返回 false 。通过 R.equals 函数进行相等性判断。
```   
var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;};
var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;};
var rusty = {name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;};
var alois = {name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;};
var kids = [abby, fred, rusty, alois];
var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;);
R.filter(hasBrownHair, kids); // [fred, rusty]
```   
</code></pre><h5 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h5><pre><code>定义：根据给定的函数对列表进行排序。
```   
var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop(&apos;name&apos;)));
var alice = {
  name: &apos;ALICE&apos;,
  age: 101
};
var bob = {
  name: &apos;Bob&apos;,
  age: -10
};
var clara = {
  name: &apos;clara&apos;,
  age: 314.159
};
var people = [clara, bob, alice];
sortByNameCaseInsensitive(people); //=&gt; [alice, bob, clara]
```   
</code></pre><h5 id="sortWith"><a href="#sortWith" class="headerlink" title="sortWith"></a>sortWith</h5><pre><code>定义：依据比较函数列表对输入列表进行排序。
```   
var alice = {
  name: &apos;alice&apos;,
  age: 40
};
var bob = {
  name: &apos;bob&apos;,
  age: 30
};
var clara = {
  name: &apos;clara&apos;,
  age: 40
};
var people = [clara, bob, alice];
var ageNameSort = R.sortWith([
  R.descend(R.prop(&apos;age&apos;)),
  R.ascend(R.prop(&apos;name&apos;))
]);
ageNameSort(people); //=&gt; [alice, clara, bob]
```   
</code></pre><h5 id="symmetricDifference"><a href="#symmetricDifference" class="headerlink" title="symmetricDifference"></a>symmetricDifference</h5><pre><code>定义：求对称差集。所有不属于两列表交集元素的集合，其元素在且仅在给定列表中的一个里面出现。
```   
R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=&gt; [1,2,7,6,5]
```   
</code></pre><h5 id="symmetricDifferenceWith"><a href="#symmetricDifferenceWith" class="headerlink" title="symmetricDifferenceWith"></a>symmetricDifferenceWith</h5><pre><code>定义：求对称差集。所有不属于两列表交集元素的集合。交集的元素由条件函数的返回值决定。
```   
var eqA = R.eqBy(R.prop(&apos;a&apos;));
var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
R.symmetricDifferenceWith(eqA, l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
```       
</code></pre><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><pre><code>定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。
```   
R.union([1, 2, 3], [2, 3, 4]); //=&gt; [1, 2, 3, 4]
```       
</code></pre><h5 id="unionWith"><a href="#unionWith" class="headerlink" title="unionWith"></a>unionWith</h5><pre><code>定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。由 predicate 的返回值决定两元素是否重复。
```   
var l1 = [{a: 1}, {a: 2}];
var l2 = [{a: 1}, {a: 4}];
R.unionWith(R.eqBy(R.prop(&apos;a&apos;)), l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 4}]
```       
</code></pre><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><h5 id="is"><a href="#is" class="headerlink" title="is"></a>is</h5><pre><code>定义：检测一个对象（val）是否是给定构造函数的实例。该函数会依次检测其原型链，如果存在的话。
```   
R.is(Object, {}); // true
```   
</code></pre><h5 id="isNil"><a href="#isNil" class="headerlink" title="isNil"></a>isNil</h5><pre><code>定义：检测输入值是否为 null 或 undefined 。
```   
R.isNil(null); // true
```   
</code></pre><h5 id="propIs"><a href="#propIs" class="headerlink" title="propIs"></a>propIs</h5><pre><code>定义：判断指定对象的属性是否为给定的数据类型，是则返回 true ；否则返回 false 。
```   
R.propIs(Number, &apos;x&apos;, {x: 1, y: 2}); // true
```   
</code></pre><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><pre><code>定义：用一个单词来描述输入值的（原生）类型，返回诸如 &apos;Object&apos;、&apos;Number&apos;、&apos;Array&apos;、&apos;Null&apos; 之类的结果。不区分用户自定义的类型，统一返回 &apos;Object&apos;。
```   
R.type([]); // Array
```   
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从8月25到8月29共5个晚上和小部分周末时间撸完了Ramda官方文档，继续在事件中继续学习。&lt;br&gt;Rmda中共分为List、Relation、Object、Function、Math、Type、Logic、String共8大类。&lt;/p&gt;
&lt;h4 id=&quot;String&quot;&gt;
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda运用概述</title>
    <link href="https://fanerge.github.io/2017/08/24/ramda%E8%BF%90%E7%94%A8-4/"/>
    <id>https://fanerge.github.io/2017/08/24/ramda运用-4/</id>
    <published>2017-08-24T12:05:16.000Z</published>
    <updated>2017-08-24T13:00:30.150Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<p>它提供了一系列以函数式、声明式和数据不变性方式工作的函数。<br>在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：</p>
<ol>
<li>数据最后：几乎所有的函数都将数据参数作为最后一个参数。</li>
<li>柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</li>
</ol>
<h4 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h4><p>入门：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：map、filter 和 reduce 等。<br>函数组合：演示了可以使用工具（如 both、either、pipe 和 compose）以多种方式组合函数。<br>部分应用(Partial Application)：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 partial 和 curry 可以实现部分应用。我们还学习了 flip 和占位符（__）。<br>声明式编程：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。<br>无参数风格编程(Pointfree Style)：介绍了 pointfree 风格的思想，也被称为 “tatic” 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。<br>数据不变性和对象：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。<br>数据不变性和数组：继续上一节的主题，展示了数据不变性在数组中的应用。<br>透镜(Lenses)：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 view、set 和 over 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。</p>
<blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;p&gt;它提供了一系列以函数式、声明式和数据不变性方式工作的函数。&lt;br&gt;在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据最后：几乎所有的函数都将数据参数作为最后一个参数。&lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda数组的操作和透镜</title>
    <link href="https://fanerge.github.io/2017/08/23/ramda%E8%BF%90%E7%94%A8-3/"/>
    <id>https://fanerge.github.io/2017/08/23/ramda运用-3/</id>
    <published>2017-08-23T12:09:42.000Z</published>
    <updated>2017-08-24T12:42:02.708Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="数据不变性和数组"><a href="#数据不变性和数组" class="headerlink" title="数据不变性和数组"></a>数据不变性和数组</h4><h5 id="读取数组元素"><a href="#读取数组元素" class="headerlink" title="读取数组元素"></a>读取数组元素</h5><pre><code>nth -- 类型于对象prop
slice -- 类似于对象pick
contains -- 类似于对象的has
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const numbers = [10, 20, 30, 40, 50, 60]</div><div class="line">R.nth(3, numbers) // =&gt; 40  (0-based indexing)</div><div class="line">R.nth(-2, numbers) // =&gt; 50 (negative numbers start from the right)</div><div class="line">R.slice(2, 5, numbers) // =&gt; [30, 40, 50] (see below)</div><div class="line">R.contains(20, numbers) // =&gt; true</div></pre></td></tr></table></figure>

nth(0) === head
nth(length-1) === last
tail -- 访问除首个元素之外的所有元素的函数
init -- 除最后一个元素之外的所有元素的方法
take(N) -- 前 N 个元素
takeLast(N) -- 后 N 个元素
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const numbers = [10, 20, 30, 40, 50, 60]</div><div class="line">R.head(numbers) // =&gt; 10</div><div class="line">R.tail(numbers) // =&gt; [20, 30, 40, 50, 60]</div><div class="line">R.last(numbers) // =&gt; 60</div><div class="line">R.init(numbers) // =&gt; [10, 20, 30, 40, 50]</div><div class="line">R.take(3, numbers) // =&gt; [10, 20, 30]</div><div class="line">R.takeLast(3, numbers) // =&gt; [40, 50, 60]</div></pre></td></tr></table></figure>
</code></pre><h5 id="增、删、改数组元素"><a href="#增、删、改数组元素" class="headerlink" title="增、删、改数组元素"></a>增、删、改数组元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">insert：将元素插入到 list 指定索引处。</div><div class="line">R.insert(2, &apos;x&apos;, [1,2,3,4]); //=&gt; [1,2,&apos;x&apos;,3,4]</div><div class="line">update：替换数组中指定索引处的值。</div><div class="line">R.update(1, 11, [0, 1, 2]);     //=&gt; [0, 11, 2]</div><div class="line">append：在列表末尾拼接一个元素。</div><div class="line">R.append(&apos;tests&apos;, [&apos;write&apos;, &apos;more&apos;]); //=&gt; [&apos;write&apos;, &apos;more&apos;, &apos;tests&apos;]</div><div class="line">prepend：在列表头部之前拼接一个元素。</div><div class="line">R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); //=&gt; [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]</div><div class="line">concat：连接列表或字符串。</div><div class="line">R.concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]</div><div class="line">// 反转数组拼接</div><div class="line">const concatAfter = R.flip(R.concat)</div><div class="line">remove：删除列表中从 start 开始的 count 个元素。</div><div class="line">R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=&gt; [1,2,6,7,8]</div><div class="line">without：求第二个列表中，未包含在第一个列表中的任一元素的集合。</div><div class="line">R.without([1, 2], [1, 2, 1, 3, 4]); //=&gt; [3, 4]</div><div class="line">drop：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。</div><div class="line">R.drop(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;bar&apos;, &apos;baz&apos;]</div><div class="line">dropLast：删除 &quot;list&quot; 末尾的 n 个元素。</div><div class="line">R.dropLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;, &apos;bar&apos;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="变换元素"><a href="#变换元素" class="headerlink" title="变换元素"></a>变换元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adjust：将数组中指定索引处的值替换为经函数变换的值。</div><div class="line">R.adjust(R.add(10), 1, [1, 2, 3]);     //=&gt; [1, 12, 3]</div></pre></td></tr></table></figure>
</code></pre><h4 id="透镜（Lenses）"><a href="#透镜（Lenses）" class="headerlink" title="透镜（Lenses）"></a>透镜（Lenses）</h4><h5 id="什么是透镜？"><a href="#什么是透镜？" class="headerlink" title="什么是透镜？"></a>什么是透镜？</h5><pre><code>透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。
可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。
</code></pre><h5 id="如何创建透镜"><a href="#如何创建透镜" class="headerlink" title="如何创建透镜"></a>如何创建透镜</h5><pre><code>lens：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));</div><div class="line">R.view(xLens, &#123;x: 1, y: 2&#125;);            //=&gt; 1</div><div class="line">R.set(xLens, 4, &#123;x: 1, y: 2&#125;);          //=&gt; &#123;x: 4, y: 2&#125;</div><div class="line">// 还有三个便捷函数</div><div class="line">LensProp：创建关注对象某一属性的透镜。</div><div class="line">lensPath: 创建关注对象某一嵌套属性的透镜。</div><div class="line">lensIndex: 创建关注数组某一索引的透镜。</div></pre></td></tr></table></figure>
</code></pre><h5 id="我能用它做什么呢？"><a href="#我能用它做什么呢？" class="headerlink" title="我能用它做什么呢？"></a>我能用它做什么呢？</h5><pre><code>Ramda 提供了三个配合透镜一起使用的的函数：
    view：读取透镜的值。
    set：更新透镜的值。
    over：将变换函数作用于透镜。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));</div><div class="line">R.view(xLens, &#123;x: 1, y: 2&#125;);            //=&gt; 1</div><div class="line">R.set(xLens, 4, &#123;x: 1, y: 2&#125;);          //=&gt; &#123;x: 4, y: 2&#125;</div><div class="line">R.over(xLens, R.negate, &#123;x: 1, y: 2&#125;);  //=&gt; &#123;x: -1, y: 2&#125;</div><div class="line">// 区别:</div><div class="line">// set 和 over 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</div></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：某些较大数据结构的处理 -- 透镜。
数组：读取(nth、slice、contains、head、last、tail、init、take、takeLast)
增、删、改(insert、update、append、prepend、concat、remove、without、drop、dropLast)
变换(adjust)
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;数据不变性和数组&quot;&gt;&lt;a href=&quot;#数据不变性和数组&quot; class=&quot;headerlink&quot; title=&quot;数据不变性和数组&quot;&gt;&lt;/a&gt;数据不变性和数组&lt;/h4&gt;&lt;h5 id=&quot;读取数组元素&quot;&gt;&lt;a href=&quot;#读取数组
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda无参数风格和对象的相关操作</title>
    <link href="https://fanerge.github.io/2017/08/22/ramda%E8%BF%90%E7%94%A8-2/"/>
    <id>https://fanerge.github.io/2017/08/22/ramda运用-2/</id>
    <published>2017-08-22T11:36:23.000Z</published>
    <updated>2017-08-23T12:15:45.084Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="Pointfree-风格（无参数风格）"><a href="#Pointfree-风格（无参数风格）" class="headerlink" title="Pointfree 风格（无参数风格）"></a>Pointfree 风格（无参数风格）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), R.always(21), R.inc)(age);</div><div class="line">// console.log(forever21(23)); // 21</div><div class="line"></div><div class="line">// pointfree风格的</div><div class="line">var forever21 = R.ifElse(R.gte(R.__, 21), R.always(21), R.inc);</div><div class="line">// console.log(forever21(21));</div><div class="line">// 我们刚刚让 age 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 age 参数。</div></pre></td></tr></table></figure>
</code></pre><h4 id="多元函数（多参数函数）"><a href="#多元函数（多参数函数）" class="headerlink" title="多元函数（多参数函数）"></a>多元函数（多参数函数）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var titlesForYear = R.curry((year, books) =&gt; &#123;</div><div class="line">  R.pipe(</div><div class="line">	R.filter(publishedInYear(year)),</div><div class="line">	R.map(book =&gt; book.title)    </div><div class="line">  )(books);</div><div class="line">&#125;);</div><div class="line">// console.log(titlesForYear(2012)(books));</div><div class="line"></div><div class="line">var titlesForYear = year =&gt; &#123;</div><div class="line">  R.pipe(</div><div class="line">	R.filter(publishedInYear(year)),</div><div class="line">	R.map(book =&gt; book.title)</div><div class="line">  )</div><div class="line">&#125;;</div><div class="line">console.log(titlesForYear(2012));</div></pre></td></tr></table></figure>
</code></pre><h4 id="重构为-pointfree-风格的代码"><a href="#重构为-pointfree-风格的代码" class="headerlink" title="重构为 pointfree 风格的代码"></a>重构为 pointfree 风格的代码</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 改写18岁投票系统</div><div class="line">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</div><div class="line">const isOver18 = person =&gt; person.age &gt;= 18</div><div class="line">const isCitizen = person =&gt; wasBornInCountry(person) || wasNaturalized(person)</div><div class="line">const isEligibleToVote = person =&gt; isOver18(person) &amp;&amp; isCitizen(person)</div><div class="line"></div><div class="line">const isEligibleToVote = person =&gt; both(isOver18, isCitizen)(person)</div><div class="line">const isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line">const isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure>
</code></pre><h4 id="读取对象属性"><a href="#读取对象属性" class="headerlink" title="读取对象属性"></a>读取对象属性</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</div><div class="line">const isOver18 = person =&gt; person.age &gt;= 18</div><div class="line">const isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line">const isEligibleToVote = both(isOver18, isCitizen)</div><div class="line"></div><div class="line">// 改写为</div><div class="line">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY)</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</div><div class="line">const isOver18 = person =&gt; gte(person.age, 18)</div></pre></td></tr></table></figure>
</code></pre><h5 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h5><pre><code>定义：取出对象中指定属性的值。如果不存在，则返回 undefined。
R.prop(&apos;x&apos;, {x: 100}); //=&gt; 100
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var wasBornInCountry = R.compose(R.equals(&apos;CHINA&apos;), R.prop(&apos;birthCountry&apos;))</div><div class="line">var wasNaturalized = R.compose(Boolean, R.prop(&apos;naturalizationDate&apos;))</div><div class="line">var isOver18 = R.compose(R.gte(R.__, 18), R.prop(&apos;age&apos;))</div><div class="line">console.log(R.both(wasBornInCountry, isOver18)(person1)); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。
R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {a: 1, d: 4}
</code></pre><h5 id="has-hasIn"><a href="#has-hasIn" class="headerlink" title="has/hasIn"></a>has/hasIn</h5><pre><code>has定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。
R.has(&apos;name&apos;)({name: &apos;alice&apos;});
hasIn定义：如果对象自身或其原型链上含有指定的属性，则返回 true；否则返回 false。
</code></pre><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><pre><code>定义：取出给定路径上的值。
R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); //=&gt; 2
</code></pre><h5 id="propOr-pathOr"><a href="#propOr-pathOr" class="headerlink" title="propOr / pathOr"></a>propOr / pathOr</h5><pre><code>propOr定义：propOr 和 pathOr 像是 prop/path 与 defaultTo 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值
propOr(&apos;&lt;Unnamed&gt;&apos;, &apos;name&apos;, person);
</code></pre><h5 id="keys-values"><a href="#keys-values" class="headerlink" title="keys / values"></a>keys / values</h5><pre><code>keys 返回一个包含对象中所有属性名称的数组，values 返回这些属性的值组成的数组。
</code></pre><h5 id="对属性增、删、改、查"><a href="#对属性增、删、改、查" class="headerlink" title="对属性增、删、改、查"></a>对属性增、删、改、查</h5><pre><code>···    
assoc/assocPath
assoc：浅复制对象，然后设置或覆盖对象的指定属性。
R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); //=&gt; {a: 1, b: 2, c: 3}
assocPath：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。
R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); //=&gt; {a: {b: {c: 42}}}

dissoc/dissocPath/omit
dissoc：删除对象中指定 prop 属性。
R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); //=&gt; {a: 1, c: 3}
dissocPath：浅复制对象，删除返回对象中指定路径上的属性。
R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); //=&gt; {a: {b: {}}}
omit：删除对象中给定的 keys 对应的属性。
R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">####	属性转换</div><div class="line">	evolve：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。</div></pre></td></tr></table></figure>

var tomato  = {firstName: &apos;  Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123};
var transformations = {
  firstName: R.trim,
  lastName: R.trim, // Will not get invoked.
  data: {elapsed: R.add(1), remaining: R.add(-1)}
};
R.evolve(transformations, tomato); //=&gt; {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####	合并对象</div><div class="line">	merge：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。</div></pre></td></tr></table></figure>

R.merge({ &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10 }, { &apos;age&apos;: 40 });
//=&gt; { &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 40 }
// 定义一个反转合并的函数(用前面的同名属性覆盖后面的同名属性)
 reverseMerge：const reverseMerge = R.flip(merge)
```
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：pointfree(无参数风格编程) 
对象属性：读取(prop、pick、has、path、propOr、pathOr、keys、values、)
增删改查(assoc、assocPath、dissoc、dissocPath、omit)
属性转换(evolve)
合并对象(merge)
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;Pointfree-风格（无参数风格）&quot;&gt;&lt;a href=&quot;#Pointfree-风格（无参数风格）&quot; class=&quot;headerlink&quot; title=&quot;Pointfree 风格（无参数风格）&quot;&gt;&lt;/a&gt;Pointfree 
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda无参数风格编程 (Pointfree Style)和声明式编程</title>
    <link href="https://fanerge.github.io/2017/08/21/ramda%E8%BF%90%E7%94%A8-1/"/>
    <id>https://fanerge.github.io/2017/08/21/ramda运用-1/</id>
    <published>2017-08-21T12:37:43.000Z</published>
    <updated>2017-08-22T11:38:32.585Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="部分应用（Partial-Application）"><a href="#部分应用（Partial-Application）" class="headerlink" title="部分应用（Partial Application）"></a>部分应用（Partial Application）</h4><pre><code>在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？
例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var books = [</div><div class="line">  &#123;year: 1991, title: &apos;11111&apos;&#125;,</div><div class="line">  &#123;year: 1991, title: &apos;22222&apos;&#125;,</div><div class="line">  &#123;year: 1992, title: &apos;33333&apos;&#125;</div><div class="line">];</div><div class="line">const publishedInYear = (book, year) =&gt; book.year === year;</div><div class="line">const titlesForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(book =&gt; publishedInYear(book, year), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;;</div><div class="line">var book1 = titlesForYear(books, 1991); // [&apos;11111&apos;, &apos;22222&apos;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><pre><code>获取或返回其他函数的函数称为 &quot;高阶函数&quot;。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 高阶函数</div><div class="line">var publishedInYear = function (year) &#123;</div><div class="line">  return function (book) &#123;</div><div class="line">	return book.year === year;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">// 箭头函数</div><div class="line">// var publishedInYear = year =&gt; book =&gt; book.year === year;</div><div class="line">var titlesForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(publishedInYear(year), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;; </div><div class="line">console.log(titlesForYear(books, 1992)); // &apos;33333&apos;</div></pre></td></tr></table></figure>
</code></pre><h5 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h5><pre><code>partial/partialRight（部分应用）
定义：这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 例子，只是想检查一本书是否是在指定年份出版的。</div><div class="line">var publishedInYear = (book, year) =&gt; book.year === year;</div><div class="line">var titleForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(R.partialRight(publishedInYear, [year]), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;;</div><div class="line">// console.log(titleForYear(books, 1992)); // [&apos;33333&apos;]</div></pre></td></tr></table></figure>
</code></pre><h5 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h5><pre><code>定义：一个柯里化了的函数是一系列高阶一元函数，将多参数函数转化为单参数函数。
一般来说，我只有需要在多个地方对同一个函数使用 partial 的时候，才会对函数进行柯里化。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var publishedInYear = R.curry((year, book) =&gt; book.year === year);</div><div class="line">var titlesForYear = (books, year) =&gt; &#123;</div><div class="line">  const selected = R.filter(publishedInYear(year), books);</div><div class="line">  return R.map(book =&gt; book.title, selected);</div><div class="line">&#125;;</div><div class="line">console.log(titlesForYear(books, 1992)); // [&apos;33333&apos;]</div><div class="line">var book2 = publishedInYear(1992, &#123;year: 1992, title: &apos;33333&apos;&#125;); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="顺序错误的参数"><a href="#顺序错误的参数" class="headerlink" title="顺序错误的参数"></a>顺序错误的参数</h5><pre><code>filp：交换函数前两个参数的位置。    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);</div><div class="line">console.log(R.flip(mergeThree)(1, 2, 3)); // [2, 1, 3]</div></pre></td></tr></table></figure>

__或placeholder (占位符)
定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。
更通用的选择是使用 &quot;placeholder&quot; 参数（__）
假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const threeArgs = curry((a, b, c) =&gt; &#123; /* ... */ &#125;);</div><div class="line">const middleArgumentLater = threeArgs(&apos;value for a&apos;, R.__, &apos;value for c&apos;);</div><div class="line"></div><div class="line">var publishedInYear = R.curry((year, book) =&gt; book.year === year)</div><div class="line">var titlesForYear = R.curry((year, books) =&gt;</div><div class="line">  R.pipe(</div><div class="line">	R.filter(publishedInYear(year)),</div><div class="line">	R.map(book =&gt; book.title)</div><div class="line">  )(books)</div><div class="line">)</div><div class="line">// console.log(titlesForYear(1991, books)); // [&quot;11111&quot;, &quot;22222&quot;]</div></pre></td></tr></table></figure>
</code></pre><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><h5 id="命令式-vs-声明式"><a href="#命令式-vs-声明式" class="headerlink" title="命令式 vs 声明式"></a>命令式 vs 声明式</h5><pre><code>命令式编程中，程序员需要告诉计算机怎么做来完成任务。
声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var square = x =&gt; R.multiply(x, x);</div><div class="line">var operate = R.pipe(</div><div class="line">  R.multiply,</div><div class="line">  R.add(1),</div><div class="line">  square</div><div class="line">  );</div><div class="line">var operate3 = operate(3, 4); // 169</div><div class="line">// add(1) 与增量运算符（++）非常相似，但 ++ 修改了被操作的值，因此它是 &quot;mutation&quot; 的。</div><div class="line">// 所以使用R.add(1),R.subtract(1)代替++ 和 --</div><div class="line">// Ramda提供了R.inc和R.dec</div><div class="line">R.dec(42); //=&gt; 41</div><div class="line">R.negate(42); //=&gt; -42 取反</div></pre></td></tr></table></figure>
</code></pre><h5 id="比较-Comparison"><a href="#比较-Comparison" class="headerlink" title="比较(Comparison)"></a>比较(Comparison)</h5><pre><code>使用R.gt()、R.gte()、R.lt()、R.lte()、R.equals()代替&gt;、&gt;=、&lt;、&lt;=、===
identical：如果两个参数是完全相同，则返回 true，否则返回 false。如果它们引用相同的内存，也认为是完全相同的。
isEmpty：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。
isNil：检测输入值是否为 null 或 undefined 。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 改写投票的例子</div><div class="line">var wasBornInCountry = person =&gt; R.equals(person.birthCountry, &apos;CHINA&apos;);</div><div class="line">var wasNaturalized = person =&gt; Boolean(person.naturalizationDate);</div><div class="line">var isOver18 = person =&gt; R.gte(person.age, 18);</div><div class="line">var isCitizen = R.either(wasBornInCountry, wasBornInCountry);</div><div class="line">var isEligibleToVote = R.both(isOver18, isCitizen);</div><div class="line">console.log(isEligibleToVote(&#123;</div><div class="line">  birthCountry: &apos;CHINA&apos;, </div><div class="line">  naturalizationDate: false,</div><div class="line">  age: 22</div><div class="line">&#125;)); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="逻辑-Logic"><a href="#逻辑-Logic" class="headerlink" title="逻辑(Logic)"></a>逻辑(Logic)</h5><pre><code>both 和 either 来代替 &amp;&amp; 和 || 运算符。使用 complement 代替 !。
我以下列方式进行分类：and、or 和 not 用于处理数值；both、either 和 complement 用于处理函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var setting = &#123;&#125;;</div><div class="line">var lineWith = setting.lineWith || 80;</div><div class="line">var lineWith = R.defaultTo(80, setting.lineWith);</div><div class="line">console.log(lineWith); //使用后者代替前者</div></pre></td></tr></table></figure>
</code></pre><h5 id="条件-Conditionals"><a href="#条件-Conditionals" class="headerlink" title="条件(Conditionals)"></a>条件(Conditionals)</h5><pre><code>R.ifElse 代替 if-else
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var forever21 = age =&gt; age &gt;= 21 ? 21 : age + 1</div><div class="line">// console.log(forever21(19)); // 20</div><div class="line">var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), () =&gt; 21, R.inc)(age)</div><div class="line">// console.log(forever21(19)); // 20</div></pre></td></tr></table></figure>
</code></pre><h5 id="constants-常量"><a href="#constants-常量" class="headerlink" title="constants (常量)"></a>constants (常量)</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">R.always(42) 代替 42</div><div class="line">R.T() === true 忽略所有参数</div><div class="line">console.log(R.T(false)); // true</div><div class="line">R.F() === false 忽略所有参数</div></pre></td></tr></table></figure>
</code></pre><h5 id="identity-恒等"><a href="#identity-恒等" class="headerlink" title="identity (恒等)"></a>identity (恒等)</h5><pre><code>输出恒等于输入。如，a =&gt; a
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">identity：将输入值原样返回。适合用作默认或占位函数。</div><div class="line">nthArg；返回一个函数，该函数返回它的第 n 个参数。</div><div class="line">const alwaysDrivingAge = age =&gt; ifElse(lt(__, 16), always(16), a =&gt; a)(age)</div></pre></td></tr></table></figure>
</code></pre><h5 id="when-和-unless"><a href="#when-和-unless" class="headerlink" title="when 和 unless"></a>when 和 unless</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var alwaysDrivingAge = age =&gt; R.unless(R.gte(R.__, 16), R.always(16))(age)</div><div class="line">console.log(alwaysDrivingAge(15)); // 16</div></pre></td></tr></table></figure>
</code></pre><h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><pre><code>作用：来代替 switch 语句或链式的 if...then...else 语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const water = temperature =&gt; R.cond([</div><div class="line">  [R.equals(0),   R.always(&apos;water freezes at 0°C&apos;)],</div><div class="line">  [R.equals(100), R.always(&apos;water boils at 100°C&apos;)],</div><div class="line">  [R.T,           temp =&gt; `nothing special happens at $&#123;temp&#125;°C`]</div><div class="line">])(temperature)</div><div class="line">console.log(water(23)); // nothing special happens at 23°C</div></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：高阶函数、部分应用函数、柯里化（Curry）、改变参数顺序的方法（flip、plachhokder__、pipeline）
常用的声明式编程替换命令式编程：add、subtract、multiply、divide等等
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;部分应用（Partial-Application）&quot;&gt;&lt;a href=&quot;#部分应用（Partial-Application）&quot; class=&quot;headerlink&quot; title=&quot;部分应用（Partial Applicatio
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda入门和函数组合</title>
    <link href="https://fanerge.github.io/2017/08/20/ramda%E8%BF%90%E7%94%A8/"/>
    <id>https://fanerge.github.io/2017/08/20/ramda运用/</id>
    <published>2017-08-20T13:37:12.000Z</published>
    <updated>2017-08-21T12:40:06.116Z</updated>
    
    <content type="html"><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="总结Ramda与Lodash和Underscore的优势"><a href="#总结Ramda与Lodash和Underscore的优势" class="headerlink" title="总结Ramda与Lodash和Underscore的优势"></a>总结Ramda与Lodash和Underscore的优势</h4><h5 id="自动柯里化"><a href="#自动柯里化" class="headerlink" title="自动柯里化"></a>自动柯里化</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 一map函数为例，解释Ramda的自动柯里化 </div><div class="line">// map函数解释：param1为对集合每一项进行处理并返回同类型的数据，param2需要处理的集合（Array或Object）</div><div class="line">// 第一种，为使用柯里化</div><div class="line">var map3 = R.map(function (item) &#123;</div><div class="line">  return item * item;</div><div class="line">&#125;, [1, 2, 3, 4]); </div><div class="line">// console.log(map3); // [1, 4, 9, 16]</div><div class="line"></div><div class="line">// 第一种curry化（转化成单参数函数）</div><div class="line">var map1 = R.map(function (item) &#123;</div><div class="line">  return item * item;</div><div class="line">&#125;);</div><div class="line">var map2 = map1([1, 2, 3, 4]);</div><div class="line">// console.log(map2); // [1, 4, 9, 16]</div></pre></td></tr></table></figure>
</code></pre><h5 id="函数参数优先于数据"><a href="#函数参数优先于数据" class="headerlink" title="函数参数优先于数据"></a>函数参数优先于数据</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 函数优先于数据</div><div class="line">var map4 = R.map(R.multiply(2), [1, 2, 3, 4]);</div><div class="line">// console.log(map4); // [2, 4, 6, 8]</div><div class="line">var map5 = R.map(R.multiply(2))([1, 2, 3, 4]);</div><div class="line">// console.log(map5); // [2, 4, 6, 8]</div></pre></td></tr></table></figure>
</code></pre><h4 id="Ramdajs的组合"><a href="#Ramdajs的组合" class="headerlink" title="Ramdajs的组合"></a>Ramdajs的组合</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// ramdajs的compose组合</div><div class="line">var users = [</div><div class="line">  &#123; &apos;user&apos;: &apos;user1&apos;,  &apos;age&apos;: 36 &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;user2&apos;,    &apos;age&apos;: 40 &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;user3&apos;, &apos;age&apos;: 18 &#125;</div><div class="line">];</div><div class="line">// R.pluck(k)[array] === R.map(R.prop(k), array)</div><div class="line">var pluck1 = R.pluck(&apos;user&apos;)(users);</div><div class="line">var pluck2 = R.map(R.prop(&apos;user&apos;))(users);</div><div class="line"></div><div class="line">// compose为函数组合（从右到左）</div><div class="line">var pluck3 = R.compose(R.join(&apos;,&apos;), R.pluck(&apos;user&apos;))(users);</div><div class="line">// console.log(pluck3); // user1,user2,user3</div><div class="line">// pipe为函数组合（从左到右）</div><div class="line">var pipe1 = R.pipe(R.pluck(&apos;user&apos;), R.join(&apos;*&apos;))(users);</div><div class="line">// console.log(pipe1); // user1*user2*user3</div><div class="line"></div><div class="line">// 依次获得用户的出生年</div><div class="line">var compose1 = R.compose(R.join(&apos;,&apos;), R.map(R.subtract(new Date().getFullYear())), R.pluck(&apos;age&apos;))(users);</div><div class="line">console.log(compose1); // 1981,1977,1999</div><div class="line"></div><div class="line">// 获得最年轻的用户信息</div><div class="line">var userMin = R.compose(R.head, R.sortBy(R.prop(&apos;age&apos;)))(users);</div><div class="line">var userMax = R.compose(R.last, R.sortBy(R.prop(&apos;age&apos;)))(users);</div><div class="line">var userMax1 = R.compose(R.head, R.reverse, R.sortBy(R.prop(&apos;age&apos;)))(users);</div><div class="line">console.log(userMin, userMax); // &#123;user: &quot;user3&quot;, age: 18&#125; &#123;user: &quot;user2&quot;, age: 40&#125;</div><div class="line">console.log(userMax1); // &#123;user: &quot;user2&quot;, age: 40&#125;</div></pre></td></tr></table></figure>

**纯函数**纯函数是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 &quot;输出&quot;，不会对数据库进行读写，不会修改输入参数等。
纯函数的基本思想是：相同的输入，永远会得到相同的输出。
**数据不变性**函数式编程的另一个重要概念是 &quot;Immutability&quot;，&quot;Immutability&quot; 是指 &quot;数据不变性&quot;。
当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。
开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">foreach</div><div class="line">for (const value of Array) &#123;</div><div class="line">	console.log(value);</div><div class="line">&#125;</div><div class="line">forEach(value =&gt; console.log(value), Array);</div><div class="line"></div><div class="line">map</div><div class="line">map(x =&gt; x*2, [1, 2, 3]); // [2, 4, 6]</div><div class="line"></div><div class="line">filter/reject(互补)</div><div class="line">const isEven = x =&gt; x % 2 === 0;</div><div class="line">filter(isEven, [1, 2, 3]); // [2]</div><div class="line">reject(isEven, [1, 2, 3]); // [1, 3]</div><div class="line"></div><div class="line">find</div><div class="line">find(isEven, [1, 2, 3, 4]); // 2</div><div class="line"></div><div class="line">reduce</div><div class="line">const add = (accum, value) =&gt; accum + value;	</div><div class="line">reduce(add, 5, [1, 2, 3, 4]); // 15</div></pre></td></tr></table></figure>
</code></pre><h4 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h4><h5 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h5><pre><code>Complement：对函数的返回值取反。接受一个函数 f，返回一个新函数 g。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const isEven = x =&gt; x % 2 === 0;</div><div class="line">var complement1 = R.find(isEven, [1, 1, 2, 4]); // 2</div><div class="line">var complement2 = R.find(R.complement(isEven), [1, 2, 2, 4]); // 1</div></pre></td></tr></table></figure>
</code></pre><h5 id="Both-Either"><a href="#Both-Either" class="headerlink" title="Both/Either"></a>Both/Either</h5><pre><code>both：该函数调用两个函数，并对两函数返回值进行与（&amp;&amp;）操作。
either：该函数调用两个函数，并对两函数返回值进行或（||）操作。    
投票系统（投票资格的条件：在本国出生，或者后来加入该国国籍，且年满18岁。）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 判断是否有投票的权利</div><div class="line">let person1 = &#123;</div><div class="line">  birthCountry: &apos;CHINA&apos;,</div><div class="line">  naturalizationDate: false,</div><div class="line">  age: 20</div><div class="line">&#125;;</div><div class="line">const wasBornInCountry = person =&gt; person.birthCountry === &apos;CHINA&apos;;</div><div class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate);</div><div class="line">const isOver18 = person =&gt; person.age &gt;= 18;</div><div class="line">var isCitizen = R.either(wasBornInCountry, wasNaturalized); // 在本国出生，或者后来加入该国国籍。</div><div class="line">var isEligibleToVote = R.both(isCitizen, isOver18);</div><div class="line">var vote1 = isEligibleToVote(person1); // true</div></pre></td></tr></table></figure>
</code></pre><h5 id="Pipelines-管道"><a href="#Pipelines-管道" class="headerlink" title="Pipelines(管道)"></a>Pipelines(管道)</h5><pre><code>pipe：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var multiply = (num1, num2) =&gt; num1 * num2;</div><div class="line">var addOne = num =&gt; num + 1;</div><div class="line">var square = num =&gt; num * num;</div><div class="line">var operate1 = R.pipe(multiply, addOne, square)(1, 2); // ((1*2)+1)^2 = 9</div></pre></td></tr></table></figure>

compose：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var operate2 =R.compose(square, addOne, multiply)(1, 2); // 9</div></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：函数、纯函数、IMMUTABILITY、foreach（递归替代循环）、map、filter、reject、find、reduce、
函数组合的方法：complement、either、both、pipe、compose、
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="external">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="external">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续函数式编程的学习。&lt;/p&gt;
&lt;h4 id=&quot;总结Ramda与Lodash和Underscore的优势&quot;&gt;&lt;a href=&quot;#总结Ramda与Lodash和Underscore的优势&quot; class=&quot;headerlink&quot; title=&quot;总结Ramda与Lodash和Un
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
  <entry>
    <title>ramda库的使用</title>
    <link href="https://fanerge.github.io/2017/08/16/ramda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://fanerge.github.io/2017/08/16/ramda库的使用/</id>
    <published>2017-08-16T12:24:01.000Z</published>
    <updated>2017-08-16T14:39:03.457Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanerge/Ramda-study/blob/master/ramda/js/pointfree.js" target="_blank" rel="external">学习源代码地址</a></p>
<h4 id="了解Pointfree的概念"><a href="#了解Pointfree的概念" class="headerlink" title="了解Pointfree的概念"></a>了解Pointfree的概念</h4><pre><code>概念：fn = R.pipe(f1, f2, f3);
可以把数据处理的过程，定义成一种与参数无关的合成运算。
**不使用所要处理的值，只合成运算过程。**
</code></pre><h5 id="一些小例子"><a href="#一些小例子" class="headerlink" title="一些小例子"></a>一些小例子</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// pointfree例子</div><div class="line">var addOne = x =&gt; x + 1;</div><div class="line">var square = x =&gt; x * x;</div><div class="line">var addOneThenSquare = R.pipe(square, addOne);</div><div class="line">var pointfree1 = addOneThenSquare(3);</div><div class="line">console.log(pointfree1); // 10</div><div class="line">// addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。</div><div class="line"></div><div class="line">var prop = (p, obj) =&gt; obj[p]; // 封装了读取操作，它需要两个参数p（属性名）和obj（对象）。</div><div class="line">var propRole = R.curry(prop)(&apos;role&apos;); // 将函数柯里化</div><div class="line">var demo1 = propRole(&#123;role: &apos;fan&apos;&#125;);</div><div class="line">console.log(demo1); // fan</div><div class="line"></div><div class="line">var data = [</div><div class="line">  &#123;name: &apos;张三&apos;, role: &apos;worker&apos;&#125;,</div><div class="line">  &#123;name: &apos;李四&apos;, role: &apos;worker&apos;&#125;,</div><div class="line">  &#123;name: &apos;王五&apos;, role: &apos;manager&apos;&#125;,</div><div class="line">];</div><div class="line">var isWorker = r =&gt; r === &apos;worker&apos;;</div><div class="line">var getWorkers = R.filter(R.pipe(R.prop(&apos;role&apos;), isWorker));</div><div class="line">var demo2 = getWorkers(data);</div><div class="line">// console.log(demo2); </div><div class="line">// [</div><div class="line">//   &#123;&quot;name&quot;: &quot;张三&quot;, &quot;role&quot;: &quot;worker&quot;&#125;,</div><div class="line">//   &#123;&quot;name&quot;: &quot;李四&quot;, &quot;role&quot;: &quot;worker&quot;&#125;</div><div class="line">// ]</div></pre></td></tr></table></figure>
</code></pre><h5 id="Pointfree示例一"><a href="#Pointfree示例一" class="headerlink" title="Pointfree示例一"></a>Pointfree示例一</h5><pre><code>**求下面字符串，请问其中最长的单词有多少个字符？**
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var str = &apos;Lorem ipsum dolor sit amet consectetur adipiscing elit&apos;;</div><div class="line">// 以空格分割单词</div><div class="line">var splitBySpace = s =&gt; s.split(&apos; &apos;);</div><div class="line">// 获得每个单词的长度</div><div class="line">var getLength = w =&gt; w.length;</div><div class="line">// 单词数组转化为单词长度的数组</div><div class="line">var getLengArr = arr =&gt; R.map(getLength, arr);</div><div class="line">// 返回较大的数字</div><div class="line">var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;</div><div class="line">// 返回最大的一个数字</div><div class="line">var findBiggestNumber = arr =&gt; R.reduce(getBiggerNumber, 0, arr);</div><div class="line"></div><div class="line">var getLongestWordLength = R.pipe(  </div><div class="line">	splitBySpace,</div><div class="line">	getLengArr,</div><div class="line">	findBiggestNumber</div><div class="line">  );</div><div class="line">var demo3 = getLongestWordLength(str);</div><div class="line">console.log(demo3); // 11</div><div class="line"></div><div class="line">// 使用ramda库</div><div class="line">var getLongestWordLength = R.pipe(</div><div class="line">	R.split(&apos; &apos;),</div><div class="line">	R.map(R.length),</div><div class="line">	R.reduce(R.max, 0)</div><div class="line">  );</div><div class="line">var demo3 = getLongestWordLength(str);</div><div class="line">// console.log(demo3); // 11</div></pre></td></tr></table></figure>
</code></pre><h4 id="Pointfree-示例二"><a href="#Pointfree-示例二" class="headerlink" title="Pointfree 示例二"></a>Pointfree 示例二</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// 下面是一段服务器返回的 JSON 数据。</div><div class="line">var data = &#123;</div><div class="line">	result: &quot;SUCCESS&quot;,</div><div class="line">	interfaceVersion: &quot;1.0.3&quot;,</div><div class="line">	requested: &quot;10/17/2013 15:31:20&quot;,</div><div class="line">	lastUpdated: &quot;10/16/2013 10:52:39&quot;,</div><div class="line">	tasks: [</div><div class="line">		&#123;id: 104, complete: false,            priority: &quot;high&quot;,</div><div class="line">				  dueDate: &quot;2013-11-29&quot;,      username: &quot;Scott&quot;,</div><div class="line">				  title: &quot;Do something&quot;,      created: &quot;9/22/2013&quot;&#125;,</div><div class="line">		&#123;id: 105, complete: false,            priority: &quot;medium&quot;,</div><div class="line">				  dueDate: &quot;2013-11-22&quot;,      username: &quot;Lena&quot;,</div><div class="line">				  title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;&#125;,</div><div class="line">		&#123;id: 107, complete: true,             priority: &quot;high&quot;,</div><div class="line">				  dueDate: &quot;2013-11-22&quot;,      username: &quot;Mike&quot;,</div><div class="line">				  title: &quot;Fix the foo&quot;,       created: &quot;9/22/2013&quot;&#125;,</div><div class="line">		&#123;id: 108, complete: false,            priority: &quot;low&quot;,</div><div class="line">				  dueDate: &quot;2013-11-15&quot;,      username: &quot;Punam&quot;,</div><div class="line">				  title: &quot;Adjust the bar&quot;,    created: &quot;9/25/2013&quot;&#125;,</div><div class="line">		&#123;id: 110, complete: false,            priority: &quot;medium&quot;,</div><div class="line">				  dueDate: &quot;2013-11-15&quot;,      username: &quot;Scott&quot;,</div><div class="line">				  title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;&#125;,</div><div class="line">		&#123;id: 112, complete: true,             priority: &quot;high&quot;,</div><div class="line">				  dueDate: &quot;2013-11-27&quot;,      username: &quot;Lena&quot;,</div><div class="line">				  title: &quot;Alter all quuxes&quot;,  created: &quot;10/5/2013&quot;&#125;</div><div class="line">	]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var fetchData = function (data) &#123;</div><div class="line">  return Promise.resolve(data);</div><div class="line">&#125;;</div><div class="line">// 提取 tasks 属性</div><div class="line">var SelectTasks = R.prop(&apos;tasks&apos;);</div><div class="line"></div><div class="line">// 过滤出指定的用户</div><div class="line">var filterMember = member =&gt; R.filter(</div><div class="line">  R.propEq(&apos;username&apos;, member)</div><div class="line">  );</div><div class="line"></div><div class="line">// 排除已经完成的任务</div><div class="line">var excludeCompletedTasks = R.reject(R.propEq(&apos;complete&apos;, true));</div><div class="line"></div><div class="line">// 选取指定属性</div><div class="line">var selectFields = R.map(</div><div class="line">	R.pick([&apos;id&apos;, &apos;dueDate&apos;, &apos;title&apos;, &apos;priority&apos;])</div><div class="line">  );</div><div class="line"></div><div class="line">// 按照到期日期排序</div><div class="line">var sortByDueDate = R.sortBy(R.prop(&apos;dueDate&apos;));</div><div class="line"></div><div class="line">// 合成函数</div><div class="line">var getIncompleteTaskSummaries = function (membername) &#123;</div><div class="line">  return fetchData(data)</div><div class="line">  .then(R.prop(&apos;tasks&apos;))</div><div class="line">  .then(R.filter(R.propEq(&apos;username&apos;, membername)))</div><div class="line">  .then(R.reject(R.propEq(&apos;complete&apos;, true)))</div><div class="line">  .then(R.map(R.pick([&apos;id&apos;, &apos;dueData&apos;, &apos;title&apos;, &apos;priority&apos;])))</div><div class="line">  .then(R.sortBy(R.prop(&apos;dueData&apos;)));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var scottList = getIncompleteTaskSummaries(&apos;Scott&apos;);</div><div class="line">console.log(scottList);	</div><div class="line">[[object Object] &#123;</div><div class="line">  dueDate: &quot;2013-11-15&quot;,</div><div class="line">  id: 110,</div><div class="line">  priority: &quot;medium&quot;,</div><div class="line">  title: &quot;Rename everything&quot;</div><div class="line">&#125;, [object Object] &#123;</div><div class="line">  dueDate: &quot;2013-11-29&quot;,</div><div class="line">  id: 104,</div><div class="line">  priority: &quot;high&quot;,</div><div class="line">  title: &quot;Do something&quot;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="external">阮老师–Pointfree 编程风格指南</a><br><a href="http://ramda.cn/" target="_blank" rel="external">Ramda 中文</a>    </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanerge/Ramda-study/blob/master/ramda/js/pointfree.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;学习源代码地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=
    
    </summary>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="函数式编程" scheme="https://fanerge.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ramda" scheme="https://fanerge.github.io/tags/ramda/"/>
    
  </entry>
  
</feed>
