<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-10-14T14:17:05.713Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSI七层与TCP/IP五层网络架构</title>
    <link href="https://fanerge.github.io/2017/10/14/OSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    <id>https://fanerge.github.io/2017/10/14/OSI七层与TCP-IP五层网络架构/</id>
    <published>2017-10-14T12:04:20.000Z</published>
    <updated>2017-10-14T14:17:05.713Z</updated>
    
    <content type="html"><![CDATA[<p>还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，<br>从参加工作时一直做的WEB前端开发，对这方面知识也不是太需要。<br>但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol><li>OSI：开放系统互连参考模型 (Open System Interconnect 简称OSI）。</li><li>TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li><li>IP：网络之间互连的协议（IP）是Internet Protocol的外语缩写，中文缩写为“网协”。</li><li>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。</li><li>HTTPS：HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</li></ol><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><pre><code>OSI七层结构--每层的解释</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.jpg" alt="OSI七层结构"><br>    OSI七层结构–每层结构的功能<br><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="OSI七层结构"></p><h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><pre><code>OSI七层模型与TCP/IP五层模型的关系</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.png" alt="TCP/IP五层模型"><br>    OSI七层模型–每层的设备<br><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E8%AE%BE%E5%A4%87.jpg" alt="各层对应的设备"></p><h1 id="对各层的详细说明"><a href="#对各层的详细说明" class="headerlink" title="对各层的详细说明"></a>对各层的详细说明</h1><ol><li>第一层是物理层（PhysicalLayer)，<br>规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。<br>具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；<br>电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等；<br>功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；<br>规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。<br>在这一层，数据的单位称为比特（bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。</li><li>第二层是数据链路层<br>在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，<br>并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。<br>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br>在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</li><li>第三层是网络层<br>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。<br>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。<br>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。<br>如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。<br>IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。<br>地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。<br>网络层协议的代表包括：IP、IPX、RIP、OSPF等。</li><li>第四层是处理信息的传输层<br>第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，<br>TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。<br>这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。<br>第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。<br>所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。<br>传输层协议的代表包括：TCP、UDP、SPX等。</li><li>第五层是会话层<br>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，<br>而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。<br>如服务器验证用户登录便是由会话层完成的。</li><li>第六层是表示层<br>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，<br>转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。<br>数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li><li>第七层应用层<br>应用层为操作系统或网络应用程序提供访问网络服务的接口。<br>应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。</li></ol><blockquote><p>   参考文档<br>    <a href="https://www.2cto.com/net/201310/252965.html" target="_blank" rel="external">OSI七层与TCP/IP五层网络架构详解</a><br>    <a href="http://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="external">OSI七层模型与TCP/IP五层模型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，&lt;br&gt;从参加工作时一直做的WEB前端开发，对这方面知识也不是太需要。&lt;br&gt;但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。&lt;/p&gt;
&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解
      
    
    </summary>
    
      <category term="通信" scheme="https://fanerge.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计指南</title>
    <link href="https://fanerge.github.io/2017/10/13/RESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    <id>https://fanerge.github.io/2017/10/13/RESTful-API-设计指南/</id>
    <published>2017-10-13T13:21:51.000Z</published>
    <updated>2017-10-14T09:55:41.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTful-API-的产生"><a href="#RESTful-API-的产生" class="headerlink" title="RESTful API 的产生"></a>RESTful API 的产生</h2><pre><code>当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信，在这种情况下RESTful API产生了。</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><pre><code>HTTP、HTTPS 应用层协议。 联网的设备 和 服务器之前的通信。</code></pre><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ol><li>API专用域名<br><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></li><li>API放在主域名<br><a href="https://example.org/api/" target="_blank" rel="external">https://example.org/api/</a></li></ol><h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><pre><code>将API的版本放入URL中。https://api.example.com/v1</code></pre><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote><p>   路径又称”终点”（endpoint），表示API的具体网址。<br>    在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>    举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://api.example.com/v1/zoos</div><div class="line">https://api.example.com/v1/animals</div><div class="line">https://api.example.com/v1/employees</div></pre></td></tr></table></figure></p></blockquote><h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><pre><code>对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</code></pre><ol><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。    </li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）:从服务器删除资源。<br>不常用的两个动词</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的那些属性是客户端可以改变的。<br>动物园管理系统举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /zoos: 列出所有动物园。</div><div class="line">POST /zoos: 新建一个动物园（动物园的信息的请求体中）。</div><div class="line">GET /zoos/ID: 获取某个动物园的信息。</div><div class="line">PUT /zoos/ID: 更新某个指定动物园的信息（提供该动物园的全部信息）。</div><div class="line">PATCH /zoos/ID: 更新某个动物园的信息（提供该动物园的部分信息）。</div><div class="line">DELETE /zoos/ID: 删除某个动物园。</div><div class="line">GET /zoos/ID/animals: 列出某个指定动物园的所有动物。</div><div class="line">DELETE /zoos/ID/animals/ID: 删除某个动物园的指定动物。</div></pre></td></tr></table></figure></li></ol><h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><pre><code>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">?limit=10：指定返回记录的数量</div><div class="line">?offset=10：指定返回记录的开始位置。</div><div class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</div><div class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</div><div class="line">?animal_type_id=1：指定筛选条件</div></pre></td></tr></table></figure>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</code></pre><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote><p>   服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</div><div class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</div><div class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</div><div class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</div><div class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</div><div class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</div><div class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</div><div class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</div><div class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</div><div class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</div><div class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</div><div class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</div></pre></td></tr></table></figure></p></blockquote><pre><code>状态码的完全列表参见[w3c](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。</code></pre><h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><pre><code>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">error: &quot;Invalid API key&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote><p>   针对不同操作，服务器向用户返回的结果应该符合以下规范。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /collection：返回资源对象的列表（数组）</div><div class="line">GET /collection/resource：返回单个资源对象</div><div class="line">POST /collection：返回新生成的资源对象</div><div class="line">PUT /collection/resource：返回完整的资源对象</div><div class="line">PATCH /collection/resource：返回完整的资源对象</div><div class="line">DELETE /collection/resource：返回一个空文档</div></pre></td></tr></table></figure></p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>（1）API的身份认证应该使用OAuth 2.0框架。（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RESTful-API-的产生&quot;&gt;&lt;a href=&quot;#RESTful-API-的产生&quot; class=&quot;headerlink&quot; title=&quot;RESTful API 的产生&quot;&gt;&lt;/a&gt;RESTful API 的产生&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;当前的发展趋势，就是
      
    
    </summary>
    
      <category term="服务端" scheme="https://fanerge.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js代码规范</title>
    <link href="https://fanerge.github.io/2017/10/12/js%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://fanerge.github.io/2017/10/12/js代码规范/</id>
    <published>2017-10-12T12:56:39.000Z</published>
    <updated>2017-10-12T13:02:07.327Z</updated>
    
    <content type="html"><![CDATA[<p>Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>基本类型：直接存取基本类型。<br>String 字符串<br>Number 数值<br>Boolean 布尔类型<br>null<br>undefined</li><li>复制类型：通过引用的方式存取复杂类型。<br>Object 对象<br>Array 数组<br>Function 函数<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2></li><li>对不可变的引用使用 const 避免使用 var。<br>  const 声明的变量不可以重新赋值，而 var 可以。</li><li>对可变的引用使用 let 避免使用 var。</li><li>注意 let 和 const 都是块级作用域。<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li><li>使用字面值创建对象。</li><li>如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。</li><li>使用同义词替换需要使用的保留字。</li><li><p>创建有动态属性名的对象时，使用可被计算的属性名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getKey(k) &#123;</div><div class="line">return `a key named $&#123;k&#125;`;</div><div class="line">&#125;</div><div class="line">const obj = &#123;</div><div class="line">id: 5,</div><div class="line">name: &apos;San Francisco&apos;,</div><div class="line">[getKey(&apos;enabled&apos;)]: true,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>使用对象方法的简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const atom = &#123;</div><div class="line">  value: 1,</div><div class="line">  // 方法简写</div><div class="line">  addValue(value) &#123;</div><div class="line">return atom.value + value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>使用对象属性值的简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const lukeSkywalker = &apos;Luke Skywalker111&apos;;</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">lukeSkywalker,</div><div class="line">&#125;;</div><div class="line">console.log(obj.lukeSkywalker); // &apos;Luke Skywalker111&apos;</div></pre></td></tr></table></figure></li><li><p>在对象属性声明前把简写的属性分组（也就是说把简写属性放在一起）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li><li>使用字面值创建数组。</li><li><p>向数组添加元素时使用 Arrary#push 替代直接赋值。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const someStack = [];</div><div class="line"></div><div class="line">// bad</div><div class="line">someStack[someStack.length] = &apos;abracadabra&apos;;</div><div class="line"></div><div class="line">// good</div><div class="line">someStack.push(&apos;abracadabra&apos;);</div><div class="line">```</div><div class="line">3.使用拓展运算符 ... 复制数组。</div></pre></td></tr></table></figure><p>let array = [‘1’,’2’];<br>console.log([…array]);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.使用 Array#from 把一个类数组对象转换成数组。</div></pre></td></tr></table></figure><p>const foo = document.querySelectorAll(‘.foo’);<br>const nodes = Array.from(foo);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">##解构</div><div class="line">1.使用解构存取和使用多属性对象。</div></pre></td></tr></table></figure><p>// good<br>function getFullName(obj) {<br>  const { firstName, lastName } = obj;<br>  return <code>${firstName} ${lastName}</code>;<br>}</p><p>// best<br>  function getFullName({ firstName, lastName }) {<br>  return <code>${firstName} ${lastName}</code>;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.对数组使用解构赋值。</div></pre></td></tr></table></figure><p>const arr = [1, 2, 3, 4];<br>const [first, second] = arr;<br>console.log(first, second); // 1, 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.需要回传多个值时，使用对象解构，而不是数组解构。</div></pre></td></tr></table></figure><p>function processInput(input) {<br>  // then a miracle occurs<br>  return { left, right, top, bottom };<br>}</p><p>// 调用时只选择需要的数据<br>const { left, right } = processInput(input);</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li><li>字符串使用单引号 ‘’。 </li><li>字符串超过 80 个字节应该使用字符串连接号换行。\    </li><li>过度使用字串连接符号可能会对性能造成影响。可换用 +     </li><li>程序化生成字符串时，使用模板字符串代替字符串连接。<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li><li>使用函数声明代替函数表达式。    </li><li><p>立即调用的函数表达式 (IIFE)    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(() =&gt; &#123;</div><div class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></li><li><p>永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。<br>浏览器允许你这么做，但它们的解析表现不一致。<br>可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let test;</div><div class="line">if (currentUser) &#123;</div><div class="line">  test = () =&gt; &#123;</div><div class="line">console.log(&apos;Yup.&apos;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。</p></li><li>不要使用 arguments。可以选择 rest 语法 … 替代。</li><li><p>直接给函数的参数指定默认值，不要使用一个变化的函数参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function handleThings(opts = &#123;&#125;) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>直接给函数参数赋值时需要避免副作用。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2></li><li><p>当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].map((x) =&gt; &#123;</div><div class="line">return x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li><li><p>如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。<br>如果不是，那就不要省略。</p><h2 id="Classes-和-Constructors"><a href="#Classes-和-Constructors" class="headerlink" title="Classes 和 Constructors"></a>Classes 和 Constructors</h2></li><li><p>总是使用 class。避免直接操作 prototype 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// good</div><div class="line">class Queue &#123;</div><div class="line">constructor(contents = []) &#123;</div><div class="line">  this._queue = [...contents];</div><div class="line">&#125;</div><div class="line">pop() &#123;</div><div class="line">  const value = this._queue[0];</div><div class="line">  this._queue.splice(0, 1);</div><div class="line">  return value;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var demo = new Queue([1, 2, 3]);</div><div class="line">console.log(demo.pop()); // 1</div></pre></td></tr></table></figure></li><li><p>使用 extends 继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class PeekableQueue extends Queue &#123;</div><div class="line">constructor (args) &#123;</div><div class="line">super(args);</div><div class="line">&#125;</div><div class="line">peek() &#123;</div><div class="line">return this._queue[0];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>方法可以返回 this 来帮助链式调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">jump() &#123;</div><div class="line">this.jumping = true;</div><div class="line">return this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setHeight(height) &#123;</div><div class="line">this.height = height;</div><div class="line">return this;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const luke = new Jedi();</div><div class="line">luke.jump()</div><div class="line">.setHeight(20);</div></pre></td></tr></table></figure></li><li><p>可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">constructor(options = &#123;&#125;) &#123;</div><div class="line">this.name = options.name || &apos;no name&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName() &#123;</div><div class="line">return this.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">toString() &#123;</div><div class="line">return `Jedi - $&#123;this.getName()&#125;`;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol><li><p>总是使用模组 (import/export) 而不是其他非标准模块系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ok</div><div class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line">// best</div><div class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default es6;</div></pre></td></tr></table></figure></li><li><p>不要使用通配符 import。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">import * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div><div class="line"></div><div class="line">// good</div><div class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</div></pre></td></tr></table></figure></li><li><p>不要从 import 中直接 export。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</div><div class="line">export default es6;</div></pre></td></tr></table></figure></li></ol><h2 id="Iterators-amp-Generators"><a href="#Iterators-amp-Generators" class="headerlink" title="Iterators &amp; Generators"></a>Iterators &amp; Generators</h2><ol><li>不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const numbers = [1, 2, 3, 4, 5];</div><div class="line"></div><div class="line">// good</div><div class="line">let sum = 0;</div><div class="line">numbers.forEach((num) =&gt; sum += num);</div><div class="line"></div><div class="line">// best (use the functional force)</div><div class="line">const sum = numbers.reduce((total, num) =&gt; total + num, 0);</div></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>普通属性使用 . 来访问对象的属性。    </li><li>当通过变量访问属性时使用中括号 []。<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。</li><li><p>单独声明每一个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const items = getItems();</div><div class="line">const goSportsTeam = true;</div><div class="line">const dragonball = &apos;z&apos;;</div></pre></td></tr></table></figure></li><li><p>将所有的 const 和 let 分组。</p></li><li>在你需要的地方给变量赋值，但请把它们放在一个合理的位置。<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2></li><li>var 声明会被提升至该作用域的顶部，但它们赋值不会提升。<br>let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。</li><li>匿名函数表达式的变量名会被提升，但函数内容并不会。</li><li>命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。</li><li>函数声明的名称和函数体都会被提升。<h2 id="比较运算符-amp-等号"><a href="#比较运算符-amp-等号" class="headerlink" title="比较运算符 &amp; 等号"></a>比较运算符 &amp; 等号</h2></li><li>优先使用 === 和 !== 而不是 == 和 !=。</li><li>条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则<br>对象 被计算为 true<br>Undefined 被计算为 false<br>Null 被计算为 false<br>布尔值 被计算为 布尔的值<br>数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true<br>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</li><li>使用简写。<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2></li><li>使用大括号包裹所有的多行代码块。</li><li>如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li><li>使用 /<em>* … </em>/ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。<br>配合 JSDoc 完美</li><li>使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。<br>在注释前插入空行。</li><li>给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。<br>这将有别于常见的注释，因为它们是可操作的。<br>使用FIXME – need to figure this out 或者 TODO – need to implement。</li><li><p>使用 // FIXME: 标注问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Calculator &#123;</div><div class="line">constructor() &#123;</div><div class="line">// FIXME: shouldn&apos;t use a global here</div><div class="line">total = 0;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用 // TODO: 标注问题的解决方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Calculator &#123;</div><div class="line">  constructor() &#123;</div><div class="line">// TODO: total should be configurable by an options param</div><div class="line">this.total = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ol><li>使用 2 个空格作为缩进。</li><li>在花括号前放一个空格。</li><li>在控制语句（if、while 等）的小括号前放一个空格。<br>在函数调用及声明中，不在函数的参数列表前加空格。</li><li>使用空格把运算符隔开。</li><li>在文件末尾插入一个空行。</li><li>在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。</li><li>在块末和新语句前插入空行。<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2></li><li>行首不要加逗号。</li><li>增加结尾的逗号: 需要。<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2></li><li>每个语句都使用分号。</li><li>IIFE 函数前添加分号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// good (防止函数在两个 IIFE 合并时被当成一个参数)</div><div class="line">;(() =&gt; &#123;</div><div class="line">  const name = &apos;Skywalker&apos;;</div><div class="line">  return name;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li>在语句开始时执行类型转换。</li><li>显式转换字符串。<br>const reviewScore = 9;<br>const totalScore = String(reviewScore);</li><li><p>对数字使用 parseInt 转换，并带上类型转换的基数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const val = Number(inputValue);</div><div class="line"></div><div class="line">const val = parseInt(inputValue, 10);</div></pre></td></tr></table></figure></li><li><p>如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</p></li><li>小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数。<br>位操作处理大于 32 位的整数值时还会导致意料之外的行为。</li><li>转换为buer。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const age = 0;</div><div class="line">const hasAge = Boolean(age);</div><div class="line">const hasAge = !!age;</div></pre></td></tr></table></figure></li></ol><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>避免单字母命名。命名应具备描述性。</li><li>使用驼峰式命名对象、函数和实例。</li><li>使用帕斯卡（大驼峰）式命名构造函数或类。</li><li>使用下划线 _ 开头命名私有属性。</li><li><p>别保存 this 的引用。使用箭头函数或 Function#bind。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  return () =&gt; &#123;</div><div class="line">console.log(this);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">return function() &#123;</div><div class="line">console.log(this);</div><div class="line">&#125;.bind(this)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// file contents</div><div class="line">class CheckBox &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">export default CheckBox;</div><div class="line"></div><div class="line">import CheckBox from &apos;./CheckBox&apos;;</div></pre></td></tr></table></figure></li><li><p>当你导出默认的函数时使用驼峰式命名。<br>你的文件名必须和函数名完全保持一致。</p></li><li>当你导出单例、函数库、空对象时使用帕斯卡式命名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const AirbnbStyleGuide = &#123;</div><div class="line">  es6: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default AirbnbStyleGuide;</div></pre></td></tr></table></figure></li></ol><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><ol><li>属性的存取函数不是必须的。    </li><li><p>如果你需要存取函数时使用 getVal() 和 setVal(‘hello’)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dragon.getAge();</div><div class="line">dragon.setAge(25);</div></pre></td></tr></table></figure></li><li><p>如果属性是布尔值，使用 isVal() 或 hasVal()。</p></li><li>创建 get() 和 set() 函数是可以的，但要保持一致。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Jedi &#123;</div><div class="line">  constructor(options = &#123;&#125;) &#123;</div><div class="line">const lightsaber = options.lightsaber || &apos;blue&apos;;</div><div class="line">this.set(&apos;lightsaber&apos;, lightsaber);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set(key, val) &#123;</div><div class="line">this[key] = val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get(key) &#123;</div><div class="line">return this[key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。<br>这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).trigger(&apos;listingUpdated&apos;, &#123; listingId : listing.id &#125;);</div><div class="line"></div><div class="line">$(this).on(&apos;listingUpdated&apos;, function(e, data) &#123;</div><div class="line">  // do something with data.listingId</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li></ol><h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><ol><li>使用 $ 作为存储 jQuery 对象的变量名前缀。<br>const $sidebar = $(‘.sidebar’);</li><li><p>缓存 jQuery 查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setSidebar() &#123;</div><div class="line">  const $sidebar = $(&apos;.sidebar&apos;);</div><div class="line">  $sidebar.hide();</div><div class="line"></div><div class="line">  $sidebar.css(&#123;</div><div class="line">&apos;background-color&apos;: &apos;pink&apos;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>对 DOM 查询使用层叠 $(‘.sidebar ul’) 或 父元素 &gt; 子元素 $(‘.sidebar &gt; ul’)。</p></li><li>对有作用域的 jQuery 对象查询使用 find。<blockquote><p>   参考文档：<br><a href="https://www.kancloud.cn/kancloud/javascript-style-guide/43153" target="_blank" rel="external">Airbnb JavaScript 代码规范（ES6）</a><br><a href="https://github.com/airbnb/javascript#airbnb-javascript-style-guide-" target="_blank" rel="external">Airbnb JavaScript Style Guide</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。&lt;/p&gt;
&lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js-读书比较</title>
    <link href="https://fanerge.github.io/2017/10/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://fanerge.github.io/2017/10/10/深入浅出Node-js-读书笔记（下）/</id>
    <published>2017-10-10T12:17:16.000Z</published>
    <updated>2017-10-12T12:55:31.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><pre><code>常见的需求：</code></pre><ol><li>请求方法的判断（保存在报文）<br>常见的方法有：GET(查看)\POST(更新)\DELETE(删除)\PUT(新建)\CONNECT\HEAD<br>通过req.method 来判断</li><li>URL的路径解析（保存在报文）<br><a href="http://localhost:8080/a.html" target="_blank" rel="external">http://localhost:8080/a.html</a><br>通过req.url 来查找</li><li>URL中查询字符串解析（保存在报文）<br>?foo=bar&amp;baz=val<br>使用Node提供的querystring 模块处理</li><li>Cookie的解析（保存在报文）<br>网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>http 为无状态协议。<br>数据保存在客户端。</li><li>Session（会话）的需求（保存在报文）<br>数据保存在服务器端。<br>1.基于Cookie 来实现用户和数据的映射。<br>  原理：在客户端只保存口令，发送请求是通过该口令再去查找对应的数据<br>2.通过查询字符串来实现浏览器端和服务器端数据的对应。<br>  不推荐使用，风险大。<br>两种存储方式：<br>1.内存<br>2.数据工具<br>  Redis是一个支持网络、基于内存、可选持久性的键值对存储数据库。</li><li>Basic认证（保存在报文）<br>当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</li><li>数据上传<br>思路：先判断数据的格式，再通过对应的解析方法解析。<br>1.表单数据的解析<br>先判断req.headers[‘content-type’] === ‘application/x-www-formurlencoded’<br>  querystring.parse(req.rawBody);<br>2.其他格式<br>  json – application/json<br>  xml – application/xml</li><li><p>任意格式文件的上传处理<br>此时需要<form action="/upload" method="post" enctype="multipart/form-data"></form></p></li><li><p>缓存<br>YSlow中提出的缓存规则：<br>1.添加Expires 和 Cache-Control 到报文头中。<br>2.配置ETags。<br>3.让Ajax 可缓存。<br>数据上传与安全<br>1.内存限制（提交数据占用了所有内存）<br>  限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。<br>  通过流式解析，将数据导向到磁盘中，Node只保留文件路径等小数据。<br>2.CSRF<br>  Cross-Site Request Forgery（跨站点请求伪造）</p><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p>文件路径型<br>  静态文件：URL 的路径与网站目录的路径一致，无须转换。<br>  动态文件：在 MVC 模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，</p><pre><code>它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。</code></pre><p>MVC<br>  MVC 模型的主要思想是将业务逻辑按职责分离。</p><pre><code>控制器（Controller），一组行为的集合。模型（Model），数据相关的操作和封装。视图（View），视图的渲染。1.路由解析，根据URL寻找到对应的控制器和行为。2.行为调用相关的模型，进行数据操作。3.数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</code></pre><p>  路由映射<br>  1.手工映射</p><pre><code>正则匹配参数解析</code></pre><p>  2.自然映射<br>RESTful<br>  REST Representational State Transfer （表现层状态转化）<br>  POST /user/fanerge 修改用户信息<br>  DELETE /user/fanerge 删除用户<br>  PUT /user/fanerge 新建用户<br>  GET /user/fanerge 查询用户信息<br>  请求方法    </p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>作用：middleware 来简化和隔离这些基础设施与业务逻辑之间的细节，使开发者更加关注在业务的开发。<br><a href="/images/middleware.png">中间件工作原理</a><br>中间件设计格式（connect的设计）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var querystring = function (req, res, next) &#123;</div><div class="line">// TODO</div><div class="line">next();</div><div class="line">&#125;</div><div class="line">```</div><div class="line">使用中间件（串联多个中间件）</div></pre></td></tr></table></figure><p>app.use(‘/user/:username’, querystring, cookie, session, function (req, res) {<br>  // 这里处理具体的业务逻辑<br>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div></pre></td><td class="code"><pre><div class="line">异常处理</div><div class="line">同步异常 -- try &#123;&#125; catch (err) &#123;throw err&#125; </div><div class="line">异步异常</div><div class="line">需要把异常传递出来</div><div class="line">domain 模块</div><div class="line">###页面渲染</div><div class="line">内容响应</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Length: 21170</div><div class="line">Content-Type: text/javascript; charset=utf-8</div><div class="line">MIME : Multipurpose Internet Mail Extensions</div><div class="line">附件下载：有些MIME类的资源不需要在客户端中打开它，只需要弹出并下载它即可。</div><div class="line">Content-Disposition: inline(查看)/attachment(附件下载);</div><div class="line">例如：Content-Disposition: attachment; filename=&apos;filename.ext&apos;; // 下载附件并为其命名</div><div class="line">响应JSON</div><div class="line">响应跳转</div><div class="line">视图渲染</div><div class="line">模板</div><div class="line">如EJS、Pug等</div><div class="line">模板引擎</div><div class="line">语法分解。</div><div class="line">处理表达式。</div><div class="line">生成待执行的语句。</div><div class="line">与数据一起执行，生成最终字符串。</div><div class="line">with的应用</div><div class="line">模板安全 XSS 解决方案 转义用户的输入</div><div class="line">模板逻辑</div><div class="line">集成文件系统</div><div class="line">子模板</div><div class="line">布局视图</div><div class="line">模板性能</div><div class="line">Bigpipe</div><div class="line">BigPipe是一个重新设计的基础动态网页服务体系。</div><div class="line">前端加载技术，它的提出主要是为了解决重数据页面的加载问题。</div><div class="line">Bigpipe 的解决思路则是将页面分割成多个部分（pagelet），</div><div class="line">先向用户输出没有数据（框架），将每个部分逐步输出到前端，</div><div class="line">再最终渲染填充框架，完成整个网页的渲染。</div><div class="line">这个过程中需要前端js的参与，它负责将后续输出的数据渲染到页面上。</div><div class="line">1.页面布局框架（无数据的）。</div><div class="line">2.后端持续性的数据输出。</div><div class="line">3.前端渲染。</div><div class="line">bigpipe.ready() -- 以一个key注册一个事件。</div><div class="line">bigpipe.set() -- 触发一个事件，进行页面渲染。</div><div class="line">##玩转进程</div><div class="line">###多进程架构</div><div class="line">child_process 模块</div><div class="line">创建子进程</div><div class="line">1.spawn(): 启动一个子进程来执行命令。</div><div class="line">2.exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，</div><div class="line">它有一个回调函数获知子进程的状况。</div><div class="line">3.execFile(): 启动一个子进程来执行可执行文件。</div><div class="line">4.fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的Javascript文件模块即可。</div><div class="line">spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，</div><div class="line">一旦创建的进程运行超过设定的时间将会被杀死。</div><div class="line">exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。</div><div class="line">进程间通信</div><div class="line">message事件 绑定发送事件</div><div class="line">send()方法 触发发送消息</div><div class="line">句柄传递</div><div class="line">child_process.send(message, [sendHandle]);</div><div class="line">句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。</div><div class="line">比如句柄可以用来标识一个服务器端socket对象、客户端socket对象、UDP套接字、一个管道等。</div><div class="line">###集群稳定之路</div><div class="line">进程事件</div><div class="line">message</div><div class="line">error</div><div class="line">exit</div><div class="line">close</div><div class="line">disconnect</div><div class="line">自动重启</div><div class="line">自杀信号</div><div class="line">负载均衡（轮叫调度）</div><div class="line">由主进程接受链接，将其依次分发给工作进程。</div><div class="line">cluster 模块</div><div class="line">状态共享</div><div class="line">第三方数据存储 通过轮询</div><div class="line">主动通知 当数据更新时，主动通知子进程。</div><div class="line">###Cluster 模块</div><div class="line">解决多核CPU的利用率问题。</div><div class="line">Cluster 工作原理</div><div class="line">该模块是 child_process 和 net 模块的组合应用。</div><div class="line">Cluster 事件</div><div class="line">fork</div><div class="line">online</div><div class="line">listening</div><div class="line">disconnect</div><div class="line">exit</div><div class="line">setup</div><div class="line">##测试</div><div class="line">测试驱动开发</div><div class="line">###单元测试</div><div class="line">测试代码编写的原则</div><div class="line">1.单一职责</div><div class="line">2.接口抽象</div><div class="line">3.层次分离</div><div class="line">单元测试介绍</div><div class="line">1.断言</div><div class="line">assert 模块</div><div class="line">单元测试中用来保证最小单元是否正常的检测方法。</div><div class="line">用于检查程序在运行时是否满足期望。</div><div class="line">ok(): 判断结果是否为真。</div><div class="line">equal(): 判断实际值余期望值是否相等。</div><div class="line">notEqual(): 判断实际值与期望值是否不相等。</div><div class="line">deepEqual(): 判断实际值余期望值是否深度相等（对象和数组的元素是否相等）。</div><div class="line">notDeepEqual(): 判断实际值与期望值是否不深度相等。</div><div class="line">strictEqual(): 判断实际值与期望值是否严格相等（===）。</div><div class="line">notStrictEqual(): 判断实际值与期望值是否不严格相等（!==）。</div><div class="line">throws(): 判断代码块是否抛出异常。</div><div class="line">doesNotThrow(): 判断代码块是否没有抛出异常。</div><div class="line">ifError(): 判断实际值是否为一个假值（null、undefined、0、&apos;&apos;、false），若实际值为真值，将抛出异常。</div><div class="line">2.测试框架</div><div class="line">用于管理测试用例和生成测试报告。</div><div class="line">mocha 模块</div><div class="line">测试风格</div><div class="line">TDD 测试驱动开发</div><div class="line">BDD 行为驱动开发</div><div class="line">测试报告</div><div class="line">mocha --reporters</div><div class="line">测试代码的文件组织</div><div class="line">测试用例</div><div class="line">异步测试</div><div class="line">测试覆盖率</div><div class="line">mock 或者 muk</div><div class="line">私有方法的测试</div><div class="line">var lib = rewire(&apos;../lib/index.js&apos;); // 需要测试方法所在的文件</div><div class="line">var litmit = lib.__get__(&apos;limit&apos;); // 需要测试的方法</div><div class="line">3.工程化与自动化</div><div class="line">工程化 -- Makefile</div><div class="line">持续集成 -- travis-ci</div><div class="line">##性能测试</div><div class="line">负载测试、压力测试和基准测试。</div><div class="line">基准测试：（对基本的方法如Array.protoryp.map 和 for循环的比较）</div><div class="line">benchmark 模块</div><div class="line">压力测试：（网络接口进行压力测试）</div><div class="line">常用的工具：ab、siege、http_load</div><div class="line">基准测试驱动开发</div><div class="line">1.写基准测试</div><div class="line">2.写/改代码</div><div class="line">3.收集数据</div><div class="line">4.找出问题</div><div class="line">5.回到第（2）步</div><div class="line">测试数据余业务数据的转换</div><div class="line">PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。</div><div class="line">UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。</div><div class="line">TPS 是每秒内的事务数，比如执行了dml操作，那么相应的tps会增加；</div><div class="line">QPS 是指每秒内查询次数，比如执行了select操作，相应的qps会增加。</div><div class="line">QPS = PV/H (H为访问量集中的时间单位小时)。</div><div class="line">##产品化</div><div class="line">包括：工程化、架构、容灾备份、部署和运维。</div><div class="line">###项目工程化</div><div class="line">1.目录结构</div><div class="line">Web框架：Express、Koa、Egg</div><div class="line">2.构建工具</div><div class="line">合并静态文件、压缩文件大小、打包应用、编译模块。</div><div class="line">Makefile </div><div class="line">一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，</div><div class="line">makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，</div><div class="line">哪些文件需要重新编译，甚至于进行更复杂的功能操作，</div><div class="line">因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</div><div class="line">Grunt</div><div class="line">3.编码规范</div><div class="line">JSLint JSHint ESLint</div><div class="line">4.代码审查</div><div class="line">###部署流程</div><div class="line">部署环境</div><div class="line">部署操作</div><div class="line">###性能</div><div class="line">动静分离</div><div class="line">静态请求用 Nginx 和 CDN 来保存</div><div class="line">启用缓存</div><div class="line">Redis 和 Memcached</div><div class="line">多进程架构</div><div class="line">读写分离</div><div class="line">###日志</div><div class="line">访问日志</div><div class="line">异常日志</div><div class="line">日志与数据库</div><div class="line">分割日志</div><div class="line">###监控报警</div><div class="line">业务逻辑型监控 和 硬件型监控</div><div class="line">监控</div><div class="line">日志监控</div><div class="line">响应时间</div><div class="line">进程监控</div><div class="line">磁盘监控</div><div class="line">内存监控</div><div class="line">CPU占用监控</div><div class="line">CPU load监控</div><div class="line">I/O负载</div><div class="line">网络监控</div><div class="line">应用状态监控</div><div class="line">DNS 监控 -- 免费DNS监控服务 DNSPod</div><div class="line">报警的实现</div><div class="line">邮件报警 -- nodemailer 模块</div><div class="line">短信或电话报警 </div><div class="line"></div><div class="line">监控系统的稳定性</div><div class="line">###稳定性</div><div class="line">多机器</div><div class="line">多机房</div><div class="line">容灾备份</div><div class="line">###异构共存</div><div class="line">##调试Node</div><div class="line">Debugger</div><div class="line">1.在代码中插入 debugger</div><div class="line">2.运行 node debug demo.js</div><div class="line">Node Inspector</div><div class="line">1.安装 npm install -g node-inspector</div><div class="line">2.错误堆栈</div><div class="line">##Node 编码规范</div><div class="line">###编码规范</div><div class="line">1.空格与格式 -- 采用2个空格缩进，而不是tab缩进。</div><div class="line">2.变量声明 -- 每个变量声明都应该带var。</div><div class="line">3.空格 -- 操作符前后加空格，如+、-、*、%、/、=等</div><div class="line">4.单双引号的问题 -- 只在html标签的属性中使用双引号，其余使用单引号。</div><div class="line">但在JSON中，严格的规范是要求使用字符串使用双引号，内容中出现双引号时需要转义。</div><div class="line">5.大括号的位置 -- 不需要另起一行</div><div class="line">6.逗号 -- 若逗号不在行结尾，前面需要一个空格。</div><div class="line">7.分号 -- 给表达式结尾添加分号。</div><div class="line">###命名规范</div><div class="line">1.变量命名 -- 小驼峰式命名。</div><div class="line">2.方法命名 -- 小驼峰式命名，尽量采用动词或判断词汇。</div></pre></td></tr></table></figure><p>  var getUser = () =&gt; {};<br>  var isAdmin = () =&gt; {};</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3.类命名（构造函数和Class） -- 大驼峰式命名。</div><div class="line">4.常量命名 -- 全大写字母和下划线。</div></pre></td></tr></table></figure><pre><code>var PINK_COLOR = &apos;pink&apos;;</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5.文件命名 -- 全小写字母和下划线。</div></pre></td></tr></table></figure><p>  child_process.js // 普通文件<br>  _linklist.js // 私有文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">6.包名 -- 不要包含 js 或 node 的字样，它们是重复的。</div><div class="line">###比较操作</div><div class="line">1.使用 === 替代 ==</div><div class="line">2.当遇到 0、undefined、null、false、&apos;&apos;假值时，不需要使用 === 或 ==。</div><div class="line">###字面量</div><div class="line">尽量使用 &#123;&#125;、[]，不要使用 new Object() 和 new Array()</div><div class="line">###作用域</div><div class="line">1.慎用with</div></pre></td></tr></table></figure><p>with (obj) {<br>  foo = bar;<br>}<br>// 出现4中结果：obj.foo = obj.bar; obj.foo = bar; foo = obj.bar; foo = bar;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">2.慎用eval()</div><div class="line">###数组与对象</div><div class="line">1.字面量格式 -- 结尾用逗号分隔，若分行，一行只能一个元素。</div><div class="line">2.for in 循环 -- 只能对对象使用，不能对数组使用。</div><div class="line">for in语句以任意顺序遍历一个对象的可枚举属性（包括原型上的属性）。</div><div class="line">3.不要把数组当对象使用</div><div class="line">###异步</div><div class="line">1.异步回调函数的第一个参数应该是错误指示</div><div class="line">2.执行传入的回调函数</div><div class="line">###类与模块</div><div class="line">1.类继承（Node推荐的类继承方式）</div></pre></td></tr></table></figure><p>function Socket (options) {<br>  stream.Stream.call(this);<br>}<br>util.inherits(Socket, stream.Stream);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2.导出 -- 所有供外部调用的方法或变量均需要挂载在exports变量上。</div><div class="line">当需要将文件当做一个类导出时，需要通过如下方式挂载。</div></pre></td></tr></table></figure><p>module.exports = Class;<br>```</p><h3 id="注解规范"><a href="#注解规范" class="headerlink" title="注解规范"></a>注解规范</h3><p>采用 JSDoc</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1.冲突的解决原则 – 入乡随俗<br>2.给编辑器设置检测工具<br>3.版本控制中的hook<br>4.持续集成</p><h2 id="搭建局域NPM仓库"><a href="#搭建局域NPM仓库" class="headerlink" title="搭建局域NPM仓库"></a>搭建局域NPM仓库</h2><blockquote><p>参考文档<br><a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="external">朴灵-深入浅出Node</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构建Web应用&quot;&gt;&lt;a href=&quot;#构建Web应用&quot; class=&quot;headerlink&quot; title=&quot;构建Web应用&quot;&gt;&lt;/a&gt;构建Web应用&lt;/h2&gt;&lt;h3 id=&quot;基础功能&quot;&gt;&lt;a href=&quot;#基础功能&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js-读书比较</title>
    <link href="https://fanerge.github.io/2017/10/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E6%AF%94%E8%BE%83/"/>
    <id>https://fanerge.github.io/2017/10/10/深入浅出Node-js-读书比较/</id>
    <published>2017-10-10T12:17:16.000Z</published>
    <updated>2017-10-12T12:54:16.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><pre><code>常见的需求：</code></pre><ol><li>请求方法的判断（保存在报文）<br>常见的方法有：GET(查看)\POST(更新)\DELETE(删除)\PUT(新建)\CONNECT\HEAD<br>通过req.method 来判断</li><li>URL的路径解析（保存在报文）<br><a href="http://localhost:8080/a.html" target="_blank" rel="external">http://localhost:8080/a.html</a><br>通过req.url 来查找</li><li>URL中查询字符串解析（保存在报文）<br>?foo=bar&amp;baz=val<br>使用Node提供的querystring 模块处理</li><li>Cookie的解析（保存在报文）<br>网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>http 为无状态协议。<br>数据保存在客户端。</li><li>Session（会话）的需求（保存在报文）<br>数据保存在服务器端。<br>1.基于Cookie 来实现用户和数据的映射。<br>  原理：在客户端只保存口令，发送请求是通过该口令再去查找对应的数据<br>2.通过查询字符串来实现浏览器端和服务器端数据的对应。<br>  不推荐使用，风险大。<br>两种存储方式：<br>1.内存<br>2.数据工具<br>  Redis是一个支持网络、基于内存、可选持久性的键值对存储数据库。</li><li>Basic认证（保存在报文）<br>当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</li><li>数据上传<br>思路：先判断数据的格式，再通过对应的解析方法解析。<br>1.表单数据的解析<br>先判断req.headers[‘content-type’] === ‘application/x-www-formurlencoded’<br>  querystring.parse(req.rawBody);<br>2.其他格式<br>  json – application/json<br>  xml – application/xml</li><li><p>任意格式文件的上传处理<br>此时需要<form action="/upload" method="post" enctype="multipart/form-data"></form></p></li><li><p>缓存<br>YSlow中提出的缓存规则：<br>1.添加Expires 和 Cache-Control 到报文头中。<br>2.配置ETags。<br>3.让Ajax 可缓存。<br>数据上传与安全<br>1.内存限制（提交数据占用了所有内存）<br>  限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。<br>  通过流式解析，将数据导向到磁盘中，Node只保留文件路径等小数据。<br>2.CSRF<br>  Cross-Site Request Forgery（跨站点请求伪造）</p><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p>文件路径型<br>  静态文件：URL 的路径与网站目录的路径一致，无须转换。<br>  动态文件：在 MVC 模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，</p><pre><code>它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。</code></pre><p>MVC<br>  MVC 模型的主要思想是将业务逻辑按职责分离。</p><pre><code>控制器（Controller），一组行为的集合。模型（Model），数据相关的操作和封装。视图（View），视图的渲染。1.路由解析，根据URL寻找到对应的控制器和行为。2.行为调用相关的模型，进行数据操作。3.数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</code></pre><p>  路由映射<br>  1.手工映射</p><pre><code>正则匹配参数解析</code></pre><p>  2.自然映射<br>RESTful<br>  REST Representational State Transfer （表现层状态转化）<br>  POST /user/fanerge 修改用户信息<br>  DELETE /user/fanerge 删除用户<br>  PUT /user/fanerge 新建用户<br>  GET /user/fanerge 查询用户信息<br>  请求方法    </p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>作用：middleware 来简化和隔离这些基础设施与业务逻辑之间的细节，使开发者更加关注在业务的开发。<br><a href="/images/middleware.png">中间件工作原理</a><br>中间件设计格式（connect的设计）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var querystring = function (req, res, next) &#123;</div><div class="line">// TODO</div><div class="line">next();</div><div class="line">&#125;</div><div class="line">```</div><div class="line">使用中间件（串联多个中间件）</div></pre></td></tr></table></figure><p>app.use(‘/user/:username’, querystring, cookie, session, function (req, res) {<br>  // 这里处理具体的业务逻辑<br>});<br>```<br>异常处理<br>  同步异常 – try {} catch (err) {throw err}<br>  异步异常</p><pre><code>需要把异常传递出来domain 模块    </code></pre><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>内容响应<br>  Content-Encoding: gzip<br>  Content-Length: 21170<br>  Content-Type: text/javascript; charset=utf-8<br>  MIME : Multipurpose Internet Mail Extensions<br>  附件下载：有些MIME类的资源不需要在客户端中打开它，只需要弹出并下载它即可。</p><pre><code>Content-Disposition: inline(查看)/attachment(附件下载);例如：Content-Disposition: attachment; filename=&apos;filename.ext&apos;; // 下载附件并为其命名</code></pre><p>  响应JSON<br>  响应跳转<br>视图渲染<br>模板<br>  如EJS、Pug等<br>  模板引擎</p><pre><code>语法分解。处理表达式。生成待执行的语句。与数据一起执行，生成最终字符串。</code></pre><p>  with的应用    </p><pre><code>模板安全 XSS 解决方案 转义用户的输入</code></pre><p>  模板逻辑<br>  集成文件系统<br>  子模板<br>  布局视图<br>  模板性能<br>Bigpipe<br>  BigPipe是一个重新设计的基础动态网页服务体系。<br>  前端加载技术，它的提出主要是为了解决重数据页面的加载问题。<br>  Bigpipe 的解决思路则是将页面分割成多个部分（pagelet），<br>  先向用户输出没有数据（框架），将每个部分逐步输出到前端，<br>  再最终渲染填充框架，完成整个网页的渲染。<br>  这个过程中需要前端js的参与，它负责将后续输出的数据渲染到页面上。<br>  1.页面布局框架（无数据的）。<br>  2.后端持续性的数据输出。<br>  3.前端渲染。</p><pre><code>bigpipe.ready() -- 以一个key注册一个事件。bigpipe.set() -- 触发一个事件，进行页面渲染。</code></pre><h2 id="玩转进程"><a href="#玩转进程" class="headerlink" title="玩转进程"></a>玩转进程</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><p>child_process 模块<br>创建子进程<br>  1.spawn(): 启动一个子进程来执行命令。<br>  2.exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，<br>  它有一个回调函数获知子进程的状况。<br>  3.execFile(): 启动一个子进程来执行可执行文件。<br>  4.fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的Javascript文件模块即可。<br>  spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，<br>  一旦创建的进程运行超过设定的时间将会被杀死。<br>  exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。<br>进程间通信<br>  message事件 绑定发送事件<br>  send()方法 触发发送消息<br>句柄传递<br>  child_process.send(message, [sendHandle]);<br>  句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。<br>  比如句柄可以用来标识一个服务器端socket对象、客户端socket对象、UDP套接字、一个管道等。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构建Web应用&quot;&gt;&lt;a href=&quot;#构建Web应用&quot; class=&quot;headerlink&quot; title=&quot;构建Web应用&quot;&gt;&lt;/a&gt;构建Web应用&lt;/h2&gt;&lt;h3 id=&quot;基础功能&quot;&gt;&lt;a href=&quot;#基础功能&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Object的扩展、密密封、冻结</title>
    <link href="https://fanerge.github.io/2017/10/10/Object%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%81%E5%AF%86%E5%AF%86%E5%B0%81%E3%80%81%E5%86%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/10/10/Object的扩展、密密封、冻结/</id>
    <published>2017-10-10T11:56:38.000Z</published>
    <updated>2017-10-10T12:02:21.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h2><pre><code>Object.isExtensible(obj)    判断一个对象是可扩展(是否能有新的属性添加到它)。Object.preventExtensions(obj)    可以对对象的属性进行修改和删除，不能向自身添加属性但可以向其原型添加属性。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Object.create(proto[, propertiesObject]);</div><div class="line">var obj = &#123;</div><div class="line">a: 1,</div><div class="line">b: 2</div><div class="line">&#125;;</div><div class="line">console.log(Object.isExtensible(obj)); // true</div><div class="line">Object.preventExtensions(obj);</div><div class="line">console.log(Object.isExtensible(obj)); // false</div><div class="line">// obj.a = 3; // 可以修改原有属性</div><div class="line">// delete obj.a; // 可以删除原有属性</div><div class="line">// obj.c = 3; // 不能自身添加属性</div><div class="line">console.log(obj);</div></pre></td></tr></table></figure></code></pre><h2 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h2><pre><code>Object.isSealed()    判断一个对象是密封的。Object.seal()    密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。    属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性。    将所有现有的属性标记为不可配置。现在的属性的值仍然可以改变,只要它们是可写的。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  prop: function() &#123;&#125;,</div><div class="line">  foo: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line">var o = Object.seal(obj);</div><div class="line">console.log(o === obj); // true</div><div class="line">Object.isSealed(obj); // === true</div><div class="line"></div><div class="line">obj.foo = &apos;quux&apos;; // 可以改变属性</div><div class="line"></div><div class="line">// 不能改变属性访问器，会抛出错误</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</div><div class="line">  get: function() &#123; return &apos;g&apos;; &#125;</div><div class="line">&#125;); // throws a TypeError</div><div class="line"></div><div class="line">// 不能添加新属性</div><div class="line">obj.quaxxor = &apos;the friendly duck&apos;;</div><div class="line"></div><div class="line">// 不能删除原有属性</div><div class="line">delete obj.foo;</div><div class="line"></div><div class="line">// 可以更改属性，只要它是可写的</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</div><div class="line">  value: &apos;eit&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h2><pre><code>Object.isFrozen()Object.freeze()    防止新的属性被添加到它;防止现有的属性被移除;    和防止现有的属性,或他们的可数性,可配置性,或可写性,被改变了,它还可以防止原型被改变了。    该方法返回对象处于冻结状态。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  prop: function() &#123;&#125;,</div><div class="line">  foo: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 返回已被冻结的对象</div><div class="line">var o = Object.freeze(obj);</div><div class="line"></div><div class="line">// o === obj; // true</div><div class="line">Object.isFrozen(obj); // === true</div><div class="line"></div><div class="line">// 改变原有属性失败</div><div class="line">obj.foo = &apos;quux&apos;; // silently does nothing</div><div class="line">// 添加属性失败</div><div class="line">obj.quaxxor = &apos;the friendly duck&apos;;</div><div class="line">// 删除原有属性失败</div><div class="line">delete obj.foo; // throws a TypeError</div><div class="line">console.log(obj);</div><div class="line"></div><div class="line">// 重新配置原有属性失败</div><div class="line">Object.defineProperty(obj, &apos;ohai&apos;, &#123; value: 17 &#125;);</div><div class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;eit&apos; &#125;);</div><div class="line"></div><div class="line">// 向原型中添加属性失败</div><div class="line">Object.setPrototypeOf(obj, &#123; x: 20 &#125;)</div><div class="line">obj.__proto__ = &#123; x: 20 &#125;</div></pre></td></tr></table></figure></code></pre><h2 id="浅冻结与深冻结"><a href="#浅冻结与深冻结" class="headerlink" title="浅冻结与深冻结"></a>浅冻结与深冻结</h2><pre><code>如该方法 MDN 的描述所述，倘若一个对象的属性是一个对象，那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结，若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">obj = &#123;</div><div class="line">internal :&#123;&#125;</div><div class="line">&#125;;</div><div class="line">Object.freeze(obj);//浅冻结</div><div class="line">obj.internal.a = &quot;aValue&quot;;</div><div class="line">console.log(obj.internal.a);//&quot;aValue&quot;</div><div class="line"></div><div class="line">//想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数.</div><div class="line">function deepFreeze(o)&#123;</div><div class="line">var prop,propKey;</div><div class="line">Object.freeze(o);//首先冻结第一层对象</div><div class="line">for(propKey in o)&#123;</div><div class="line">prop = o[propKey];</div><div class="line">if(!o.hasOwnProperty(propKey) || !(typeof prop === &quot;object&quot;) || Object.isFrozen(prop))&#123;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">deepFreeze(prop);//递归</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">deepFreeze(obj);</div><div class="line">obj.internal.b = &quot;bValue&quot;;//静默失败</div><div class="line">console.log(obj.internal.b);//undefined</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000003894119" target="_blank" rel="external">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br>    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="external">MDN</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扩展特性&quot;&gt;&lt;a href=&quot;#扩展特性&quot; class=&quot;headerlink&quot; title=&quot;扩展特性&quot;&gt;&lt;/a&gt;扩展特性&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Object.isExtensible(obj)
    判断一个对象是可扩展(是否能有新的属性添加到它)。
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js-读书笔记</title>
    <link href="https://fanerge.github.io/2017/10/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://fanerge.github.io/2017/10/09/深入浅出Node-js-读书笔记（上）/</id>
    <published>2017-10-09T12:09:51.000Z</published>
    <updated>2017-10-09T15:15:42.993Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。</p><h2 id="Node-js-基础知识"><a href="#Node-js-基础知识" class="headerlink" title="Node.js 基础知识"></a>Node.js 基础知识</h2><h3 id="chrome-与-Node-工作原理"><a href="#chrome-与-Node-工作原理" class="headerlink" title="chrome 与 Node 工作原理"></a>chrome 与 Node 工作原理</h3><pre><code>chrome：HTML + JavaScript + WebKit + V8 &gt;&gt; 中间层 &gt;&gt; 网卡 + 硬盘 + 显卡 + ...Node：JavaScript + V8 &gt;&gt; 中间层（libuv）&gt;&gt; 网卡 + 硬盘 + 显卡 + ...说明：libuv 是 Node 的新跨平台抽象层，用于抽象 Windows 的 IOCP 及 Unix 的 libev。    作者打算在这个库的包含所有平台的差异性。</code></pre><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.get(&apos;url&apos;, (data) =&gt; &#123;</div><div class="line">console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>异步是并行的基础。单线程，不适合大量计算占用 CPU 导致无法继续调用异步I/O。</code></pre><h2 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h2><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><pre><code>模块引用：    var math = require(&apos;math&apos;);    模块定义：    exports.add = () =&gt; {        var a = 1,            b = 3;        return a + b;    }exports 是 module 的属性。Node 引入模块的步骤：    路径分析    文件定位    编译执行</code></pre><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><pre><code>文件模块 &gt;&gt; 核心模块（JavaScript） &gt;&gt; 内建模块（C/C++）</code></pre><h2 id="异步I-O-1"><a href="#异步I-O-1" class="headerlink" title="异步I/O"></a>异步I/O</h2><h3 id="Node-的异步I-O"><a href="#Node-的异步I-O" class="headerlink" title="Node 的异步I/O"></a>Node 的异步I/O</h3><pre><code>Node 自身的执行模型 -- 事件循环。单线程、事件循环、观察者和I/O线程池</code></pre><h3 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h3><pre><code>定时器：setTimeout()\setInterval()process.nextTick()    在事件循环的下一次循环中调用 callback 回调函数。    效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；    与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。setImmediate()    nextTick()的回调函数执行的优先级要高于setImmediate();        process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,    I/O观察者先于check观察者.</code></pre><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>高阶函数：以函数作为参数或返回值。偏函数用法：通过指定部分参数来产生一个新的定制函数的形式就是偏函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const isType = function (type)&#123;</div><div class="line">return function (obj) &#123;</div><div class="line">return Object.prototype.toString.call(obj) == &apos;[object &apos; + type + &apos;]&apos;;</div><div class="line">&#125;; </div><div class="line">&#125;</div><div class="line">var isString = isType(&apos;String&apos;);</div></pre></td></tr></table></figure></code></pre><h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h3><pre><code>事件发布/订阅模式（事件绑定）promisegeneratorasync-await</code></pre><h3 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h3><pre><code>eventproxy[async](https://github.com/caolan/async)</code></pre><h2 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h2><h2 id="理解Buffer"><a href="#理解Buffer" class="headerlink" title="理解Buffer"></a>理解Buffer</h2><pre><code>Buffer 是一个像Array的对象，但它主要用于操作字节。Buffer 对象    var buf = new Buffer(&apos;string&apos;, &apos;utf-8&apos;);</code></pre><h3 id="Buffer-的转换"><a href="#Buffer-的转换" class="headerlink" title="Buffer 的转换"></a>Buffer 的转换</h3><pre><code>    支持的字符串编码类型：    ASCII\UTF-8\UTF-16LE/UCS-2\Base64\Binary\Hex字符串转 Buffer    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var buf = new Buffer(str, [encoding]);</div><div class="line">buf.write(string, [offset], [length], [encoding]);</div></pre></td></tr></table></figure>Buffer 转字符串buf.toString([encoding], [start], [end]);</code></pre><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>TCP 和 UDP 属于网络传输层协议，HTTP 属于应用层协议。</code></pre><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><pre><code>创建TCP 服务器端 net 模块TCP 服务的事件</code></pre><h3 id="构建UDP-服务（用户数据包协议）"><a href="#构建UDP-服务（用户数据包协议）" class="headerlink" title="构建UDP 服务（用户数据包协议）"></a>构建UDP 服务（用户数据包协议）</h3><pre><code>创建UDP套接字 dgram模块创建UDP 服务器端创建UDP 客户端UDP 套接字事件</code></pre><h3 id="构建HTTP-服务"><a href="#构建HTTP-服务" class="headerlink" title="构建HTTP 服务"></a>构建HTTP 服务</h3><pre><code>HTTP 超文本传输协议。http 模块HTTP 客户端</code></pre><h3 id="构建WebSocket-服务"><a href="#构建WebSocket-服务" class="headerlink" title="构建WebSocket 服务"></a>构建WebSocket 服务</h3><pre><code>以前的方案：Comet（彗星）技术细节为：长轮询（long-polling）或iframe流（streaming）。长轮询原理：客户端向服务器断发送请求，服务端只在超时或有数据响应时断开连接（res.end()），    客户端在接收到数据或者超时后重新发送请求。iframe流原理：iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，    然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。    通过iframe里的内容进行长时间的请求，当需要传输内容时通过调用父页面js方法来实现页面展示，以此达到comet所需要的效果。WebSocket原理：WebSocket是一种在单个TCP连接上进行全双工通讯的协议。    WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，    浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</code></pre><h3 id="网络服务与安全"><a href="#网络服务与安全" class="headerlink" title="网络服务与安全"></a>网络服务与安全</h3><pre><code>Node在网络安全上提供了3个模块</code></pre><ol><li>crypto – 主要用于加密和解密，SHA1、MD5。</li><li>tls – 类似于net模块，它是建立在TLS/SSL加密的TCP连接上。</li><li>https – 类似于http模块，他它是建立于安全的连接之上。<br>TLS/SSL<br>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构。<br>每个服务器断和客户端都有自己的公私钥。<br>公钥要来加密要传输的数据，私钥用来解密接收到的数据。<br>Node在底层采用的是openssl实现TLS/SSL。<br>数字证书：CA（Certificate Authority，数字证书认证中心）<br>HTTPS服务<br>HTTPS服务就是工作在TLS/SSL上的HTTP。<blockquote><p>参考文档<br><a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="external">朴灵-深入浅出Node</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。&lt;/p&gt;
&lt;h2 id=&quot;Node-js-基础知识&quot;&gt;&lt;a href=&quot;#Node-js-基础知识&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="读书笔记" scheme="https://fanerge.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-总结</title>
    <link href="https://fanerge.github.io/2017/09/28/koa%E5%AD%A6%E4%B9%A0-%E6%80%BB%E7%BB%93/"/>
    <id>https://fanerge.github.io/2017/09/28/koa学习-总结/</id>
    <published>2017-09-28T12:22:32.000Z</published>
    <updated>2017-09-29T14:11:44.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个koa示例"><a href="#一个koa示例" class="headerlink" title="一个koa示例"></a>一个koa示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const koa = require(&apos;koa&apos;);</div><div class="line">const app = new koa();</div><div class="line"></div><div class="line">// 使用中间件</div><div class="line">app.use(); // @param function</div><div class="line">// 监听端口，开启服务</div><div class="line">app.listen(1314, () =&gt; &#123;</div><div class="line">console.log(&apos;success&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="Context-对象"><a href="#Context-对象" class="headerlink" title="Context 对象"></a>Context 对象</h2><pre><code>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。koa 通过 ctx.request.accepts 设置期望返回的类型内容，默认为 text/plain。        koa 通过 ctx.response.type 指定返回类型。示例：常用的格式xml、json、html、text等。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.use((ctx) =&gt; &#123;</div><div class="line">if (ctx.request.accepts(&apos;xml&apos;)) &#123;</div><div class="line">ctx.response.type = &apos;xml&apos;;</div><div class="line">ctx.response.body = &apos;&lt;data&gt;我是xml&lt;/data&gt;&apos;;</div><div class="line">&#125; else &#123;</div><div class="line">ctx.response.type = &apos;text&apos;;</div><div class="line">ctx.response.body = &apos;我是text&apos;;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">```</div><div class="line">示例：实际开发（网页模板）</div><div class="line">直接返回template.html</div></pre></td></tr></table></figure>    app.use(ctx =&gt; {      ctx.response.type = &apos;html&apos;;      ctx.response.body = fs.createReadStream(&apos;./views/template.html&apos;);    });    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">##路由</div><div class="line">通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。</div><div class="line">###原生路由</div></pre></td></tr></table></figure>    const main = ctx =&gt; {        ctx.response.type = &apos;html&apos;;      if (ctx.request.path === &apos;/&apos;) {        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;      } else if (ctx.request.path === &apos;/get&apos;) {        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Get Page&lt;/a&gt;&apos;;      } else {        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;other Page&lt;/a&gt;&apos;;      }    };    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">###koa-route 模块</div></pre></td></tr></table></figure>const Koa = require(&apos;koa&apos;);const route = require(&apos;koa-route&apos;);const app = new Koa();const about = ctx =&gt; {    ctx.response.type = &apos;html&apos;;    ctx.response.body = &apos;&lt;p&gt;about page&lt;/p&gt;&apos;};const user = ctx =&gt; {    ctx.response.type = &apos;html&apos;;    ctx.response.body = &apos;&lt;p&gt;user page&lt;/p&gt;&apos;};const main = ctx =&gt; {    ctx.response.type = &apos;html&apos;;    ctx.response.body = &apos;hello world&apos;};app.use(route.get(&apos;/&apos;, main)); // 主页app.use(route.get(&apos;/about&apos;, about)); // about页面app.use(route.get(&apos;/user&apos;, user)); // user页面// app.use(main);app.listen(3000);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##静态资源 和 重定向</div><div class="line">###静态资源</div><div class="line">如果网站提供静态资源（图片、字体、样式表、脚本......）。</div><div class="line">koa-static 模块封装了这部分的请求。</div><div class="line">示例：请求本地12.js</div></pre></td></tr></table></figure>const Koa = require(&apos;koa&apos;);const app = new Koa();const path = require(&apos;path&apos;);const serve = require(&apos;koa-static&apos;);const main = serve(path.join(__dirname));app.use(main);app.listen(3000);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">说明：__dirname 表示 node.js 执行环境路径。</div><div class="line">请求资源： http://127.0.0.1:3000/12.js</div><div class="line">###重定向</div><div class="line">有些场合，服务器需要重定向（redirect）访问请求。</div><div class="line">比如，用户登陆以后，将他重定向到登陆前的页面。</div><div class="line">ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。</div></pre></td></tr></table></figure>const redirect = ctx =&gt; {  ctx.response.redirect(&apos;/&apos;);};const main = ctx =&gt; {  ctx.response.body = &apos;Hello World&apos;;};app.use(route.get(&apos;/&apos;, main));app.use(route.get(&apos;/redirect&apos;, redirect)); // 当请求路径为 /redirect 时，执行 redirect 方法，进行重定向<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。</div><div class="line">##中间件</div><div class="line">###设计中间件</div><div class="line">Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。</div><div class="line">示例：自己设计一个logger中间件。</div></pre></td></tr></table></figure>/*** 定义日志中间件 logger* @param ctx {object} 上下文对象 * @param next {function} 下一个中间件执行权*/const logger = (ctx, next) =&gt; {    console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);    next(); // 只要调用next函数，就可以把执行权转交给下一个中间件。};// 使用中间件app.use(logger);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###中间件特性</div><div class="line">多个中间件会形成一个栈结构（middle stack），以&quot;先进后出&quot;（first-in-last-out）的顺序执行。</div></pre></td></tr></table></figure>const one = (ctx, next) =&gt; {  console.log(&apos;&gt;&gt; one&apos;);  next();  console.log(&apos;&lt;&lt; one&apos;);}const two = (ctx, next) =&gt; {  console.log(&apos;&gt;&gt; two&apos;);  next();   console.log(&apos;&lt;&lt; two&apos;);}const three = (ctx, next) =&gt; {  console.log(&apos;&gt;&gt; three&apos;);  next();  console.log(&apos;&lt;&lt; three&apos;);}app.use(one);app.use(two);app.use(three);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输出：</div><div class="line">&gt;&gt; one   // one中间件进栈</div><div class="line">&gt;&gt; two   // two中间件进栈</div><div class="line">&gt;&gt; three // three中间件进栈</div><div class="line">&lt;&lt; three // three中间件 出栈</div><div class="line">&lt;&lt; two   // two中间件 出栈</div><div class="line">&lt;&lt; one // one中间件 出栈</div><div class="line">###异步中间件</div><div class="line">如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。</div><div class="line">实例：异步 main 中间件</div></pre></td></tr></table></figure>const fs = require(&apos;fs.promised&apos;);const main = async function (ctx, next) {  ctx.response.type = &apos;html&apos;;  ctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;);};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.readFile是一个异步操作，必须写成异步中间件。</div><div class="line">###koa-compose模块可以将多个中间件合成为一个。</div><div class="line">示例：合并 logger 和 main 中间件。</div></pre></td></tr></table></figure>const compose = require(&apos;koa-compose&apos;);const middlewares = compose([logger, main]);app.use(middlewares);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##错误处理</div><div class="line">如果代码运行过程中发生错误，我们需要把错误信息返回给用户。</div><div class="line">###500错误</div><div class="line">HTTP 协定约定这时要返回500状态码。</div><div class="line">Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误。</div></pre></td></tr></table></figure>const main = ctx =&gt; {    ctx.throw(500);};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###404错误</div><div class="line">如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。</div></pre></td></tr></table></figure>const main = ctx =&gt; {  ctx.response.status = 404; // ctx.throw(404);  ctx.response.body = &apos;Page Not Found&apos;;};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###处理错误的中间件</div><div class="line">为了方便处理错误，最好使用try...catch将其捕获。</div><div class="line">但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。</div></pre></td></tr></table></figure>// 最外层中间件const handler = async (ctx, next) =&gt; {  try {    await next();  } catch (err) {    ctx.response.status = err.statusCode || err.status || 500;    ctx.response.body = {      message: err.message    };  }};// 内层中间件const main = ctx =&gt; {  ctx.throw(404);};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###error 事件的监听</div><div class="line">运行过程中一旦出错，Koa 会触发一个error事件。</div><div class="line">监听这个事件，也可以处理错误。</div></pre></td></tr></table></figure>const main = ctx =&gt; {    ctx.throw(500); // 直接触发错误};// 监听错误app.on(&apos;error&apos;, (err, ctx) =&gt; {    console.error(&apos;server error&apos;, err);});<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###释放 error 事件</div><div class="line">需要注意的是，如果错误被try...catch捕获，就不会触发error事件。</div><div class="line">这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。</div></pre></td></tr></table></figure>const handler = async (ctx, next) =&gt; {    try {        await next();    } catch (err) {        ctx.response.status = err.statusCode || err.status || 500;        ctx.response.type = &apos;html&apos;;        ctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;;        ctx.app.emit(&apos;error&apos;, err, ctx);    }};const main = ctx =&gt; {    ctx.throw(500);};app.on(&apos;error&apos;, function(err) {    console.log(&apos;logging error &apos;, err.message);    console.log(err);});<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main函数抛出错误，被handler函数捕获。</div><div class="line">catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。</div><div class="line">##Web App 的功能</div><div class="line">###Cookies</div><div class="line">ctx.cookies 用来读写 Cookie。</div></pre></td></tr></table></figure>const main = function(ctx) {    const n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1;    ctx.cookies.set(&apos;view&apos;, n);    ctx.response.body = n + &apos; views&apos;;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">###表单</div><div class="line">Web 应用离不开处理表单。</div><div class="line">表单就是 POST 方法发送到服务器的键值对。</div><div class="line">koa-body模块可以用来从 POST 请求的数据体里面提取键值对。</div></pre></td></tr></table></figure>const koaBody = require(&apos;koa-body&apos;);const main = async function (ctx) {    const body = ctx.request.body;    if (!body.name) ctx.throw(400, &apos;.name required&apos;);    ctx.body = { name: body.name };};app.use(koaBody());<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###文件上传</div><div class="line">koa-body模块还可以用来处理文件上传。</div></pre></td></tr></table></figure>const os = require(&apos;os&apos;);const path = require(&apos;path&apos;);const koaBody = require(&apos;koa-body&apos;);const main = async function(ctx) {    const tmpdir = os.tmpdir();    const filePaths = [];    const files = ctx.request.body.files || {};    for (let key in files) {        const file = files[key];        const filePath = path.join(tmpdir, file.name);        const reader = fs.createReadStream(file.path);        const writer = fs.createWriteStream(filePath);        reader.pipe(writer);        filePaths.push(filePath);    }    ctx.body = filePaths;};app.use(koaBody({ multipart: true }));```</code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="external">阮一峰老师的koa教程</a><br>    <a href="https://www.npmjs.com/package/koa-router" target="_blank" rel="external">koa-router官方文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一个koa示例&quot;&gt;&lt;a href=&quot;#一个koa示例&quot; class=&quot;headerlink&quot; title=&quot;一个koa示例&quot;&gt;&lt;/a&gt;一个koa示例&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签总结</title>
    <link href="https://fanerge.github.io/2017/09/27/jsDoc%E5%AD%A6%E4%B9%A0-5/"/>
    <id>https://fanerge.github.io/2017/09/27/jsDoc学习-5/</id>
    <published>2017-09-27T14:46:04.000Z</published>
    <updated>2017-10-12T13:02:24.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><pre><code>@class -- 此函数旨在需要使用”new”关键字调用（构造函数）或ES6中class。    @constructor@classdesc -- 使用的后面的蚊子来描述整个类。@abstract -- 这个成员必须在继承的子类中重写。    @virtual@static -- 记录一个静态成员。@access -- 指定该成员的访问级别（私有private、保护protected、公共public）。    @access private 等价于 @private    @access protected 等价于 @protected    @access public 等价于 @public@alias -- 标记成员有一个别名。@extends -- 指名这个子类继承至哪个父类，后面需要加父类名。    @augments@instance -- 记录一个实例成员。@interface -- 这是别人可以实现的一个接口。</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre><code>@borrows -- 这个对象使用另一个对象的某些东西。@lends -- 将一个字面量对象的所有属性标记为某个标识符（类或模块）的成员。@mixes -- 此对象混入了另一个对象中的所有成员。@mixin -- 记录一个mixin（混入）对象。@name  -- 记录一个对象的名称。@namespace -- 记录一个命名空间对象。@property -- 记录一个对象的属性。    @prop@typedef -- 记录一个自定义的类型。@type -- 记录一个对象的类型。@variation -- 区分具有相同名称的不同的对象。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>@callback -- 描述一个回调函数。@function -- 描述一个函数或方法。    @func    @method@returns -- 记录一个函数的返回值。    @return@this -- this关键字的指向。</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>@author -- 指定项目的作者。@constant -- 记录一个对象作为一个常量。    @const@default -- 记录默认值。    @defaultvalue@copyright -- 描述一些版权信息。@since -- 该方法添加于该版本，建议使用。@deprecated -- 该方法已弃用，不建议使用。@description -- 描述一个标识。    @desc@enum -- 描述一个相关属性的集合。@example -- 提供一个如何使用描述项的例子。@external -- 标识一个外部的类，命名空间，或模块。@file -- 描述一个文件。    @fileoverview    @overview@global -- 记录一个全局对象。@ignore -- 忽略文档中的一个标识。@implements -- 这个表示实现一个接口。@inheritdoc -- 指明这个标识应继承其父类的文档。@inner -- 描述一个内部对象。@kind -- 表示的类型。@license -- 表示你的代码采用何种软件许可协议。@member -- 记录一个成员。    @var@memberof -- 标明这个标识属于哪个父级标识。@override -- 指明一个标识符覆盖其父类同名的标识符。@param -- 记录传递给一个函数的参数。    @arg     @argument@readonly -- 标记为只读的。@see -- 更多详细参阅其他一些文档。@summary -- 完整描述的一个简写版本。@throws -- 说明可能会被抛出什么样的错误。@todo -- 记录一个将要完成的任务。@tutorial -- 插入一个连接到包含教程文件。@version -- 记录版本信息。</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>@event -- 描述一个事件。@listens -- 列出一个标识的监听事件。@fires -- 描述事件这个方法可能会触发。    @emits</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>@exports -- 表示一个由javascript模块导出的成员。@module -- 记录一个javascript模块。@requires -- 这个文件需要一个javascript模块。</code></pre><h2 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a>内联标签</h2><pre><code>@link -- 连接到文档中的另一个项目。    @linkcode    @linkplain@tutorial -- 链接到一个教程。</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>安装jsdoc3<br>npm install -g jsdoc</li><li>在cmd 中 (此时会在test.js的同级目录产出out目录，存放生成的API文档)<br>jsdoc test.js<br>  默认配置情况下out目录中产出：<pre><code>fonts、scripts、styles目录顾名思义。index.html -- API文档首页global.html -- 全局的（成员和方法）index.js.html -- 源代码页面</code></pre></li><li><p>相关配置<br>启用jsdoc有两种方式：命令行参数 和 conf.json配置<br>JSDoc命令行参数<br>  JSDoc命令行几个常用参数有以下几个：<br>  -c, –configure 指定configuration file<br>  -d, –destination 指定输出路径，默认./out<br>  -e, –encoding 设定encoding，默认utf8<br>  -p, –private 将private注释输出到文档，默认不输出<br>  -P, –package 指定package.json file<br>  -r, –recurse 查询子目录<br>  -t, –template 指定输出文档template<br>  -u, –tutorials 指定教程路径，默认无<br>  例如：jsdoc -T –match tag –verbose<br>JSDoc配置文件<br>  默认的配置文件：conf.json.EXAMPLE</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;tags&quot;: &#123;</div><div class="line">&quot;allowUnknownTags&quot;: true, // 允许使用自定义tag</div><div class="line">&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;] // 定义tag集</div><div class="line">&#125;,</div><div class="line">&quot;source&quot;: &#123;</div><div class="line">&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;, // 将以.js, .jsdoc结尾的文件作为源文件</div><div class="line">&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot; // 忽略以_开头的文件夹及文件</div><div class="line">&#125;,</div><div class="line">&quot;plugins&quot;: [],</div><div class="line">&quot;templates&quot;: &#123;</div><div class="line">&quot;cleverLinks&quot;: false,</div><div class="line">&quot;monospaceLinks&quot;: false</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  例如：jsdoc -c /path/to/conf.json</p></li></ol><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/inline-tags.html" target="_blank" rel="external">jsdoc</a><br>    <a href="https://github.com/jsdoc3/jsdoc" target="_blank" rel="external">jsdoc3</a><br>    <a href="http://www.moodpo.com/archives/jsdoc3-tutorial.html" target="_blank" rel="external">使用 JSDoc 3 自动生成 JavaScript API 文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类和构造函数&quot;&gt;&lt;a href=&quot;#类和构造函数&quot; class=&quot;headerlink&quot; title=&quot;类和构造函数&quot;&gt;&lt;/a&gt;类和构造函数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;@class -- 此函数旨在需要使用”new”关键字调用（构造函数）或ES6中class。
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签3</title>
    <link href="https://fanerge.github.io/2017/09/26/jsDoc%E5%AD%A6%E4%B9%A0-4/"/>
    <id>https://fanerge.github.io/2017/09/26/jsDoc学习-4/</id>
    <published>2017-09-26T13:28:50.000Z</published>
    <updated>2017-10-12T13:02:20.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h3><pre><code>@override标签指明一个标识符覆盖其父类同名的标识符。下面的例子说明一个方法如何重写父类的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @classdesc Abstract class representing a network connection.</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Connection() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Open the connection.</div><div class="line"> */</div><div class="line">Connection.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * @classdesc Class representing a socket connection.</div><div class="line"> * @class</div><div class="line"> * @augments Connection</div><div class="line"> */</div><div class="line">function Socket() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Open the socket.</div><div class="line"> * @override</div><div class="line"> */</div><div class="line">Socket.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h3><pre><code>@param标签提供了对某个函数的参数的各项说明，包括参数名、参数数据类型、描述等。别名：@arg @argument下面的示例演示如何在 @param标签中包含名称，类型，和说明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param somebody</div><div class="line"> */</div><div class="line">function sayHello(somebody) &#123;</div><div class="line">alert(&apos;Hello &apos; + somebody);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h3><pre><code>@private标签标记标识符为私有，或者不做一般用途使用。私有成员不会在生成文档中输出任何内容，除非JSDoc使用 -p/--private 命令行选项运行。语法：@private在下面的例子中，Documents和Documents.Newspaper会被输出到生成的文档中，但是Documents.Diary不会。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var Documents = &#123;</div><div class="line">/**</div><div class="line"> * An ordinary newspaper.</div><div class="line"> */</div><div class="line">Newspaper: 1,</div><div class="line">/**</div><div class="line"> * My diary.</div><div class="line"> * @private</div><div class="line"> */</div><div class="line">Diary: 2</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><pre><code>@property标签很容易描述类，命名空间或其它对象的静态属性列表。别名：@prop例如，描述命名空间的默认属性及嵌套属性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @namespace</div><div class="line"> * @property &#123;object&#125;  defaults               - The default values for parties.</div><div class="line"> * @property &#123;number&#125;  defaults.players       - The default number of players.</div><div class="line"> * @property &#123;string&#125;  defaults.level         - The default level for the party.</div><div class="line"> * @property &#123;object&#125;  defaults.treasure      - The default treasure.</div><div class="line"> * @property &#123;number&#125;  defaults.treasure.gold - How much gold the party starts with.</div><div class="line"> */</div><div class="line">var config = &#123;</div><div class="line">defaults: &#123;</div><div class="line">players: 1,</div><div class="line">level:   &apos;beginner&apos;,</div><div class="line">treasure: &#123;</div><div class="line">gold: 0</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h3><pre><code>@protected标签标记标识符为受保护的，通常情况下，受保护的成员只能在被继承的子类中或在模块内部可以访问。语法：@protected [{typeExpression}]在下面的例子中，该实例成员Thingy#_bar会被导出到生成的文档中，但使用注释说明它是被保护的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** @constructor */</div><div class="line">function Thingy() &#123;</div><div class="line">/** @protected */</div><div class="line">this._bar = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h3><pre><code>@public标签标记标识符为公开的。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The Thingy class is available to all.</div><div class="line"> * @public</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Thingy() &#123;</div><div class="line">/**</div><div class="line"> * The Thingy~foo member. Note that &apos;foo&apos; is still an inner member</div><div class="line"> * of &apos;Thingy&apos;, in spite of the @public tag.</div><div class="line"> * @public</div><div class="line"> */</div><div class="line">var foo = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h3><pre><code>标记一个标识符为只读。jsdoc不会检查某个代码是否真是只读的，只要标上@readonly，在文档中就体现为只读的。例如，给getter标记为只读<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Options for ordering a delicious slice of pie.</div><div class="line"> * @namespace</div><div class="line"> */</div><div class="line">var pieOptions = &#123;</div><div class="line">/**</div><div class="line"> * A la mode.</div><div class="line"> * @readonly</div><div class="line"> */</div><div class="line">get aLaMode() &#123;</div><div class="line">return this.plain + &apos; with ice cream&apos;;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="requires"><a href="#requires" class="headerlink" title="@requires"></a>@requires</h3><pre><code>@requires标签可以记录一个模块需要的依赖项。一个JSDoc注释块可以有多个@require标签。模块名可以被指定为 &quot;moduleName&quot; 或者 &quot;module:moduleName&quot;;这两种形式将被解析为模块。语法：@requires &lt;someModuleName&gt;例如，使用@requires 标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * This class requires the modules &#123;@link module:xyzcorp/helper&#125; and</div><div class="line"> * &#123;@link module:xyzcorp/helper.ShinyWidget#polish&#125;.</div><div class="line"> * @class</div><div class="line"> * @requires module:xyzcorp/helper</div><div class="line"> * @requires xyzcorp/helper.ShinyWidget#polish</div><div class="line"> */</div><div class="line">function Widgetizer() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="returns"><a href="#returns" class="headerlink" title="@returns"></a>@returns</h3><pre><code>@returns 标签描述一个函数的返回值。语法和@param类似。别名：@return返回值的类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns the sum of a and b</div><div class="line"> * @param &#123;Number&#125; a</div><div class="line"> * @param &#123;Number&#125; b</div><div class="line"> * @returns &#123;Number&#125;</div><div class="line"> */</div><div class="line">function sum(a, b) &#123;</div><div class="line">return a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h3><pre><code>@see标签表示可以参考另一个标识符的说明文档，或者一个外部资源。语法：@see &lt;namepath&gt;      @see &lt;text&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Both of these will link to the bar function.</div><div class="line"> * @see &#123;@link bar&#125;</div><div class="line"> * @see bar</div><div class="line"> */</div><div class="line">function foo() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="since"><a href="#since" class="headerlink" title="@since"></a>@since</h3><pre><code>@since标签标明一个类，方法，或其它标识符是在哪个特定版本开始添加进来的。语法：@since &lt;versionDescription&gt;例如，使用@since标签：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Provides access to user information.</div><div class="line"> * @since 1.0.1</div><div class="line"> */</div><div class="line">function UserRecord() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="static"><a href="#static" class="headerlink" title="@static"></a>@static</h3><pre><code>@static标签标明一个在父类中的标识符不需实例即可使用。例如，在一个虚拟注释中使用@static    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/** @namespace MyNamespace */</div><div class="line">/**</div><div class="line"> * @function myFunction</div><div class="line"> * @memberof MyNamespace</div><div class="line"> * @static</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="summary"><a href="#summary" class="headerlink" title="@summary"></a>@summary</h3><pre><code>@summary标签是完整描述的一个简写版本。它可以被添加到任何的doclet。语法：@summary Summary goes here.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological,</div><div class="line"> * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate,</div><div class="line"> * loquacious, garrulous, chatty, extended, babbling description.</div><div class="line"> * @summary A concise summary.</div><div class="line"> */</div><div class="line">function bloviate() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="this"><a href="#this" class="headerlink" title="@this"></a>@this</h3><pre><code>@this标签指明this关键字的指向。语法：@this &lt;namePath&gt;在下面的例子中，@this标签迫使&quot;this.name&quot;被描述为&quot;Greeter#name&quot;，而不是全局变量&quot;name&quot;。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/** @constructor */</div><div class="line">function Greeter(name) &#123;</div><div class="line">setName.apply(this, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/** @this Greeter */</div><div class="line">function setName(name) &#123;</div><div class="line">/** document me */</div><div class="line">this.name = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="throws"><a href="#throws" class="headerlink" title="@throws"></a>@throws</h3><pre><code>@throws标签可以让你描述函数可能会抛出的错误。在一个JSDoc注释块中您可以包含多个@throws标签。语法：@throws free-form description      @throws {&lt;type&gt;}      @throws {&lt;type&gt;} free-form description例如，在type中使用@throws标签:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @throws &#123;InvalidArgumentException&#125;</div><div class="line"> */</div><div class="line">function foo(x) &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="todo"><a href="#todo" class="headerlink" title="@todo"></a>@todo</h3><pre><code>@todo标签可以让你记录要完成的任务。在一个JSDoc注释块中您可以包含多个@todo标签。语法：@todo text describing thing to do.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @todo Write the documentation.</div><div class="line"> * @todo Implement this function.</div><div class="line"> */</div><div class="line">function foo() &#123;</div><div class="line">// write me</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="tutorial"><a href="#tutorial" class="headerlink" title="@tutorial"></a>@tutorial</h3><pre><code>@tutorial 标签插入一个指向向导教程的链接，作为文档的一部分。语法：@tutorial &lt;tutorialID&gt;在下面的例子中，MyClass的文档将链接到tutorial-1 和 tutorial-2标识符的教程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Description</div><div class="line"> * @class</div><div class="line"> * @tutorial tutorial-1</div><div class="line"> * @tutorial tutorial-2</div><div class="line"> */</div><div class="line">function MyClass() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><pre><code>@type标签允许你提供一个表达式，用于标识一个标识符可能包含的值的类型，或由函数返回值的类型。语法：@type {typeName1 | typeName2}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** @type &#123;(string|Array.&lt;string&gt;)&#125; */</div><div class="line">var foo;</div><div class="line">/** @type &#123;number&#125; */</div><div class="line">var bar = 1;</div></pre></td></tr></table></figure></code></pre><h3 id="typedef"><a href="#typedef" class="headerlink" title="@typedef"></a>@typedef</h3><pre><code>@typedef标签在描述自定义类型时是很有用的，特别是如果你要反复引用它们的时候。语法：@typedef [&lt;type&gt;] &lt;namepath&gt;这个例子定义了一个联合类型的参数，表示可以包含数字或字符串。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A number, or a string containing a number.</div><div class="line"> * @typedef &#123;(number|string)&#125; NumberLike</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="variation"><a href="#variation" class="headerlink" title="@variation"></a>@variation</h3><pre><code>描述: 区分具有相同名称的不同的对象。语法：@variation &lt;variationNumber&gt;</code></pre><h3 id="version"><a href="#version" class="headerlink" title="@version"></a>@version</h3><pre><code>@version标签后面的文本将被用于表示该项的版本。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @version 1.2.3</div><div class="line"> * @tutorial solver</div><div class="line"> */</div><div class="line">function solver(a, b) &#123;</div><div class="line">return b / a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="内联标签（inline-Tags）"><a href="#内联标签（inline-Tags）" class="headerlink" title="内联标签（inline Tags）"></a>内联标签（inline Tags）</h3><pre><code>{@link}内联标签创建一个链接到您指定的namepath或URL。当您使用{@link}标签，还可以提供几种不同的格式的链接文本。如果你不提供任何链接文本，JSDoc使用namepath或URL作为链接文字。别名：@linkcode  @linkplain语法：{@link namepathOrURL}      [link text]{@link namepathOrURL}      {@link namepathOrURL|link text}      {@link namepathOrURL link text (after the first space)}下面的例子显示了提供给{@link} 标签链接文本的所有方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * See &#123;@link MyClass&#125; and [MyClass&apos;s foo property]&#123;@link MyClass#foo&#125;.</div><div class="line"> * Also, check out &#123;@link http://www.google.com|Google&#125; and</div><div class="line"> * &#123;@link https://github.com GitHub&#125;.</div><div class="line"> */</div><div class="line">function myFunction() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="tutorial-1"><a href="#tutorial-1" class="headerlink" title="@tutorial"></a>@tutorial</h3><pre><code>{@tutorial}行内标签创建一个链接到您指定的教程标识符。当您使用{@tutorial}标签，您也可以提供几种不同的格式的链接文本。如果你不提供任何链接文本，JSDoc使用本教程的标题作为链接文字。语法：{@tutorial tutorialID}      [link text]{@tutorial tutorialID}      {@tutorial tutorialID|link text}      {@tutorial tutorialID link text (after the first space)}下面的例子显示了提供给{@tutorial}标签链接文本的所有方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * See &#123;@tutorial gettingstarted&#125; and [Configuring the Dashboard]&#123;@tutorial dashboard&#125;.</div><div class="line"> * For more information, see &#123;@tutorial create|Creating a Widget&#125; and</div><div class="line"> * &#123;@tutorial destroy Destroying a Widget&#125;.</div><div class="line"> */</div><div class="line">function myFunction() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;override&quot;&gt;&lt;a href=&quot;#override&quot; class=&quot;headerlink&quot; title=&quot;@override&quot;&gt;&lt;/a&gt;@override&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@override标签指明一个标识符覆盖其父类同名的标识符。
下面的例子
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签2</title>
    <link href="https://fanerge.github.io/2017/09/26/jsDoc%E5%AD%A6%E4%B9%A0-3/"/>
    <id>https://fanerge.github.io/2017/09/26/jsDoc学习-3/</id>
    <published>2017-09-26T12:26:15.000Z</published>
    <updated>2017-10-12T13:02:17.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="file"><a href="#file" class="headerlink" title="@file"></a>@file</h3><pre><code>@file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。别名：@fileoverview  @overview例如，文件描述<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @file 这是正则js文件</div><div class="line"> * @author fanerge &lt;fanerge@example.com&gt;</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="fires"><a href="#fires" class="headerlink" title="@fires"></a>@fires</h3><pre><code>@fires标签标明当一个方法被调用时将触发一个指定类型的事件，使用@event 标签来描述事件的内容。别名：@emits语法：@fires &lt;className&gt;#[event:]&lt;eventName&gt;例如，方法将触发&quot;drain&quot;事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Drink the milkshake.</div><div class="line"> * @fires Milkshake#drain</div><div class="line"> */</div><div class="line">Milkshake.prototype.drink = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="function"><a href="#function" class="headerlink" title="@function"></a>@function</h3><pre><code>标记一个对象作为一个函数，即使它可能不会出现在解析器中。它设置doclet的@kind为&apos;function&apos;。别名：@func  @method语法：@function [&lt;FunctionName&gt;]例如，使用@function标记为一个函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** @function */</div><div class="line">var paginate = paginateFactory(pages);</div></pre></td></tr></table></figure></code></pre><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><pre><code>@global标签指定一个在文档的标识是为全局性的标识。JSDoc忽略这个标识在源文件中的实际作用范围。这个标记是在本地所定义标识时特别有用。例如，文档中的内部变量作为一个全局变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">/** @global */</div><div class="line">var foo = &apos;hello foo&apos;;</div><div class="line"></div><div class="line">this.foo = foo;</div><div class="line">&#125;).apply(window);</div></pre></td></tr></table></figure></code></pre><h3 id="ignore"><a href="#ignore" class="headerlink" title="@ignore"></a>@ignore</h3><pre><code>@ignore标签表示在你的代码中的注释不应该出现在文档中，注释会被直接忽略。这个标签优先于所有其他标签。在下面的例子中，@ignore标签， Jacket 和 Jacket#color 将不会出现在文档中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @class</div><div class="line"> * @ignore</div><div class="line"> */</div><div class="line">function Jacket() &#123;</div><div class="line">/** The jacket&apos;s color. */</div><div class="line">this.color = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="implements"><a href="#implements" class="headerlink" title="@implements"></a>@implements</h3><pre><code>@implements标签指示一个标识实现一个接口。语法：@implements {typeExpression}在下面的例子中，TransparentColor类实现Color接口，并添加了TransparentColor#rgba方法。</code></pre><h3 id="inheritdoc"><a href="#inheritdoc" class="headerlink" title="@inheritdoc"></a>@inheritdoc</h3><pre><code>@inheritdoc标签指示该标识应继承其父类的文档。在你的JSDoc注释中的任何其它标签都将被忽略。下面的例子显示了一个类的描述如何从它的父类继承文档。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @classdesc Abstract class representing a network connection.</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Connection() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Open the connection.</div><div class="line"> */</div><div class="line">Connection.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * @classdesc Class representing a socket connection.</div><div class="line"> * @class</div><div class="line"> * @augments Connection</div><div class="line"> */</div><div class="line">function Socket() &#123;&#125;</div><div class="line"></div><div class="line">/** @inheritdoc */</div><div class="line">Socket.prototype.open = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="inner"><a href="#inner" class="headerlink" title="@inner"></a>@inner</h3><pre><code>使用@inner标签将标明该标识符作为它父标识符的内部成员。这意味着它可以通过 &quot;Parent~Child&quot; 被引用。在下面的例子中，我们使用@inner迫使一个命名空间的成员被描述作为内部成员（默认情况下，这是一个静态成员）。这意味着，foo现在有了MyNamespace~foo新名字，而不是MyNamespace.foo。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var MyNamespace = &#123;</div><div class="line">/**</div><div class="line"> * foo is now MyNamespace~foo rather than MyNamespace.foo.</div><div class="line"> * @inner</div><div class="line"> */</div><div class="line">foo: 1</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="instance"><a href="#instance" class="headerlink" title="@instance"></a>@instance</h3><pre><code>使用@instance标签标明该标识符作为它父标识符的实例成员。这意味着它可以通过&quot;Parent#Child&quot;被引用。例如，使用@instance确定一个实例成员<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var BaseObject = &#123;</div><div class="line">/**</div><div class="line"> * foo is now BaseObject#foo rather than BaseObject.foo.</div><div class="line"> * @instance</div><div class="line"> */</div><div class="line">foo: null</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** Generates BaseObject instances. */</div><div class="line">function fooFactory(fooValue) &#123;</div><div class="line">var props = &#123; foo: fooValue &#125;;</div><div class="line">return Object.create(BaseObject, props);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h3><pre><code>@interface标签使一个标识符作为其他标识符的一个实现接口。 例如，你的代码可能定义一个父类，它的方法和属性被去掉。您可以将@interface标签添加到父类，以指明子类必须实现父类的方法和属性。语法：@interface [&lt;name&gt;]在下面的例子中，Color函数表示其它类可以实现的接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Interface for classes that represent a color.</div><div class="line"> * @interface</div><div class="line"> */</div><div class="line">function Color() &#123;&#125;</div><div class="line">/**</div><div class="line"> * Get the color as an array of red, green, and blue values, represented as</div><div class="line"> * decimal numbers between 0 and 1.</div><div class="line"> * @returns &#123;Array&amp;lt;number&gt;&#125; An array containing the red, green, and blue values,</div><div class="line"> * in that order.</div><div class="line"> */</div><div class="line">Color.prototype.rgb = function() &#123;</div><div class="line">throw new Error(&apos;not implemented&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="kind"><a href="#kind" class="headerlink" title="@kind"></a>@kind</h3><pre><code>@kind标签是用来指明什么样的标识符被描述（例如，一类或模块）。标识符kind 不同于标识符type（例如，字符串或布尔）。语法：@kind &lt;kindName&gt;    kindName取值：class constant event external file function member mixin module namespace typedef<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A constant.</div><div class="line"> * @kind constant</div><div class="line"> */</div><div class="line">const asdf = 1;</div></pre></td></tr></table></figure></code></pre><h3 id="lends"><a href="#lends" class="headerlink" title="@lends"></a>@lends</h3><pre><code>@lends标签允许你将一个字面量对象的所有成员标记为某个标识符（类或模块）的成员，就像他们是给定名称的标识符成员。你可能想这样做，如果你传递一个对象字面量给一个函数，创建一个成员为对象字面量的命名类。语法：@lends &lt;namepath&gt;实例，@lends标签告诉JSDoc，这一对象字面量的所有成员都会被“借”给&quot;Person&quot;类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** @class */</div><div class="line">var Person = makeClass(</div><div class="line">/** @lends Person */</div><div class="line">&#123;</div><div class="line">initialize: function(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;,</div><div class="line">say: function(message) &#123;</div><div class="line">return this.name + &quot; says: &quot; + message;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">);</div></pre></td></tr></table></figure></code></pre><h3 id="license"><a href="#license" class="headerlink" title="@license"></a>@license</h3><pre><code>@license标签标识你的代码采用何种软件许可协议。语法：@license &lt;identifier&gt;例如，这是在Apache 2.0 许可下分发的模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Utility functions for the foo package.</div><div class="line"> * @module foo/util</div><div class="line"> * @license Apache-2.0</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="listens"><a href="#listens" class="headerlink" title="@listens"></a>@listens</h3><pre><code>@listens 标签指示一个标识监听指定的事件。使用@event 标签来记录事件的内容。语法：@listens &lt;eventName&gt;下面的示例演示了如何记录名为module:hurler~event:snowball的事件，还有一个方法命名为module:playground/monitor.reportThrowage来监听事件。</code></pre><h3 id="member"><a href="#member" class="headerlink" title="@member"></a>@member</h3><pre><code>@member标签记录成员基本种类（kind），比如&quot;class&quot;, &quot;function&quot;, 或者 &quot;constant&quot;。一个成员可以任选地具有一个类型以及名称。别名：@var语法：@member [&lt;type&gt;] [&lt;name&gt;]例如，Data#point上使用@member：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** @class */</div><div class="line">function Data() &#123;</div><div class="line">/** @member &#123;Object&#125; */</div><div class="line">this.point = &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="memberof"><a href="#memberof" class="headerlink" title="@memberof"></a>@memberof</h3><pre><code>@memberof标签标明成员隶属于哪一个父级标识符。语法：@memberof &lt;parentNamepath&gt;      @memberof! &lt;parentNamepath&gt;事实上，它就是一个全局性的函数，但同事它也是Tools命名空间的一个成员，而这才是你想描述的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var Tools = &#123;&#125;;</div><div class="line"></div><div class="line">/** @memberof Tools */</div><div class="line">var hammer = function() &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Tools.hammer = hammer;</div></pre></td></tr></table></figure></code></pre><h3 id="mixes"><a href="#mixes" class="headerlink" title="@mixes"></a>@mixes</h3><pre><code>@mixes标签指示当前对象混入了OtherObjectPath对象的所有成员,被混入的对象就是一个@mixin。    语法：@mixes &lt;OtherObjectPath&gt;</code></pre><h3 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h3><pre><code>您可以使用@mixin标签标识该对象是一个mixin（混入），旨在表明该对象的属性和方法混入到其他对象。然后，可以将@mixes标签 添加到使用了该 mixin（混入）的对象上。语法：@mixin [&lt;MixinName&gt;]</code></pre><h3 id="module"><a href="#module" class="headerlink" title="@module"></a>@module</h3><pre><code>@module可以将当前文件标注为一个模块，默认情况下文件内的所有标识符都隶属于此模块，除非文档另有说明。@module [[{&lt;type&gt;}] &lt;moduleName&gt;]下面的示例演示了在一个模块中用于标识的namepaths。第一个标识符是模块私有的，或“内部”变量 - 它只能在模块内访问。第二个标识符是由模块导出一个静态函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/** @module myModule */</div><div class="line"></div><div class="line">/** will be module:myModule~foo */</div><div class="line">var foo = 1;</div><div class="line"></div><div class="line">/** will be module:myModule.bar */</div><div class="line">var bar = function() &#123;&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="name"><a href="#name" class="headerlink" title="@name"></a>@name</h3><pre><code>@name标签强制JSDoc使用这个给定的名称，而忽略实际代码里的名称。这个标签最好用于&quot;虚拟注释&quot;，而不是在代码中随时可见的标签，如在运行时期间产生的方法。语法：@name &lt;namePath&gt;下面的例子演示了如何使用@name标签描述一个函数，JSDoc通常不会识别。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @name highlightSearchTerm</div><div class="line"> * @function</div><div class="line"> * @global</div><div class="line"> * @param &#123;string&#125; term - The search term to highlight.</div><div class="line"> */</div><div class="line">eval(&quot;window.highlightSearchTerm = function(term) &#123;&#125;;&quot;)</div></pre></td></tr></table></figure></code></pre><h3 id="namespace"><a href="#namespace" class="headerlink" title="@namespace"></a>@namespace</h3><pre><code>@namespace标签指明对象是一个命名空间。你也可以书写一个虚拟JSDoc注释，通过使用代码来定义命名空间。语法：@namespace [{&lt;type&gt;}] &lt;SomeName&gt;]例如，对象上使用 @namespace 标签：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * My namespace.</div><div class="line"> * @namespace</div><div class="line"> */</div><div class="line">var MyNamespace = &#123;</div><div class="line">/** documented as MyNamespace.foo */</div><div class="line">foo: function() &#123;&#125;,</div><div class="line">/** documented as MyNamespace.bar */</div><div class="line">bar: 1</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;file&quot;&gt;&lt;a href=&quot;#file&quot; class=&quot;headerlink&quot; title=&quot;@file&quot;&gt;&lt;/a&gt;@file&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。
别名：@fileovervie
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>postman</title>
    <link href="https://fanerge.github.io/2017/09/26/postman/"/>
    <id>https://fanerge.github.io/2017/09/26/postman/</id>
    <published>2017-09-26T11:32:30.000Z</published>
    <updated>2017-09-26T11:39:13.975Z</updated>
    
    <content type="html"><![CDATA[<pre><code>虽然一直使用postman进行http相关的调试，但一直都停留在简单使用，并没有对其的深入学习。现在比较全面的学习下post相关功能。</code></pre><h3 id="postman仪表盘布局"><a href="#postman仪表盘布局" class="headerlink" title="postman仪表盘布局"></a>postman仪表盘布局</h3><pre><code>分为左右两栏（sidebar + main）    siderbar：Search + History + Collections    main：        第一行：请求方式 + URL + Params + Send(Send and Download) + Save(Save as)        第二行(request)：Authorization + Headers + Body + Pre-request Script(请求发送前运行的脚本) + Tests + Code(转化为相应的语言请求代码)        第三行(response)：Body + Cookies + Headers + Tests + Status(响应状态) + Time(响应等待时间)     </code></pre><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><pre><code>HTTP请求的4部分:URL，method，headers，body。对于body说明：    1.mutipart/form-data：是网页表单用来传输数据的默认格式。（提交表单上传文件）    2.x-www-form-urlencoded：同前面一样，注意,你不能上传文件通过这个编码模式。    3.raw：raw request可以包含任何东西。所有填写的text都会随着请求发送。    4.binary：image, audio or video files.text files 。 也不能保存历史，每次选择文件，提交。身份验证Authentication：    1.Basic Auth：填写用户名和密码，点击Refresh headers    2.Digest Auth：要比Basic Auth复杂的多。使用当前填写的值生成authorization header。        所以在生成header之前要确保设置的正确性。        如果当前的header已经存在，postman会移除之前的header。    3.OAuth 1.0a：postman的OAuth helper让你签署支持OAuth 1.0基于身份验证的请求。        OAuth不用获取access token,你需要去API提供者获取的。        OAuth 1.0可以在header或者查询参数中设置value。    4.OAuth 2.0：postman支持获得OAuth 2.0 token并添加到requests中。    </code></pre><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><pre><code>对于body说明：    1.Pretty：格式化了JSON和XML，方便查看。    2.Raw：是text文本。    3.Preview：返回html页面。cookies：可以显示browser cookies，需要开启Interceptor。</code></pre><h3 id="Writting-Test"><a href="#Writting-Test" class="headerlink" title="Writting Test"></a>Writting Test</h3><pre><code>暂不涉及！！！Postman的Tests标签可以用来写测试</code></pre><h3 id="运行Collections"><a href="#运行Collections" class="headerlink" title="运行Collections"></a>运行Collections</h3><pre><code>Postman测试管理的单位是测试集（Collections），测试集内可以创建文件夹(Folder)和具体的请求(Requests)。postman允许你运行collection，你可以运行任意的次数。 最后会给出一个整体运行的结果。会保存每一次运行的结果，提供给你比较每一次运行结果的不同。</code></pre><h3 id="Postman开发者模式"><a href="#Postman开发者模式" class="headerlink" title="Postman开发者模式"></a>Postman开发者模式</h3><pre><code>使用环境变量可以方便的在开发和测试环境进行切换。1.点击环境管理按钮添加环境。2.通常会有开发和测试两个环境，分别添加相应的环境变量。    环境一：ev_develop        url：127.0.0.1.8081    环境二：ev_test        url：10.1.1.133.80803.使用环境变量    {{url}}/api/v1/currentUser.json    No Environment选择对应的环境即可4.查看和编辑环境变量    下拉select和眼睛图标</code></pre><h3 id="Postman接口测试"><a href="#Postman接口测试" class="headerlink" title="Postman接口测试"></a>Postman接口测试</h3><pre><code>1.对于同一接口的多个测试请求，可统一使用后缀命名    在Collections中    如测试登录的不同情况：    login_normal    login_bad_username    login_bad_password    login_miss_username    login_miss_password2.对于关键字搜索测试，可使用关键字作为后缀，以保持与开发关键字一致    如测试评分资料内容列表展示    评分资料内容列表_pageNum    评分资料内容列表_numPerPage    评分资料内容列表_docName3.对于需要额外说明的测试请求，需要在描述里增加注释    点击edit添加Description</code></pre><h3 id="Postman接口测试进阶"><a href="#Postman接口测试进阶" class="headerlink" title="Postman接口测试进阶"></a>Postman接口测试进阶</h3><pre><code>1.全局变量的创建方式与环境变量相同    2.使用方式也是相同的，不同的是全局变量可以在不同环境下共用    </code></pre><blockquote><p>   参考文档：<br>    <a href="http://blog.csdn.net/flowerspring/article/details/52774399" target="_blank" rel="external">postman 使用详解</a><br>    <a href="https://jingyan.baidu.com/article/0f5fb09907e3046d8334ea2f.html" target="_blank" rel="external">postmen 使用入门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;虽然一直使用postman进行http相关的调试，但一直都停留在简单使用，并没有对其的深入学习。
现在比较全面的学习下post相关功能。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;postman仪表盘布局&quot;&gt;&lt;a href=&quot;#postman仪表盘布局&quot; c
      
    
    </summary>
    
      <category term="调试" scheme="https://fanerge.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="http" scheme="https://fanerge.github.io/tags/http/"/>
    
      <category term="调试" scheme="https://fanerge.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-标签1</title>
    <link href="https://fanerge.github.io/2017/09/25/jsDoc%E5%AD%A6%E4%B9%A0-2/"/>
    <id>https://fanerge.github.io/2017/09/25/jsDoc学习-2/</id>
    <published>2017-09-25T13:03:22.000Z</published>
    <updated>2017-10-12T13:02:14.002Z</updated>
    
    <content type="html"><![CDATA[<p>块标签（Block Tags）</p><h3 id="abstract"><a href="#abstract" class="headerlink" title="@abstract"></a>@abstract</h3><pre><code>该成员（一般指父类的方法）必须在继承的子类中实现（或重写）。别名：@virtual<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 奶制品</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">function DairyProduct () &#123;&#125;</div><div class="line">/**</div><div class="line"> * 检查奶制品的状态</div><div class="line"> * @abstract</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line">DairyProduct.prototype.isSolid = function () &#123;</div><div class="line">  throw new Error(&apos;must be implemented by subclass!&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 牛奶</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">function Milk () &#123;&#125;</div><div class="line">Milk.prototype = new DairyProduct();</div><div class="line">// 这里重写了父类的isSolid方法</div><div class="line">Milk.prototype.isSolid = function () &#123;</div><div class="line">return false;</div><div class="line">&#125;;</div><div class="line">var dd = new Milk();</div><div class="line">console.log(dd.isSolid()); // false</div></pre></td></tr></table></figure></code></pre><h3 id="access"><a href="#access" class="headerlink" title="@access"></a>@access</h3><pre><code>指定该成员的访问级别（私有 private，公共 public，或保护 protected）语法：@access &lt;private|protected|public&gt;    @access private 等价于 @private;    @access protected 等价于 @protected;    @access public 等价于 @public;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">function Thingy () &#123;</div><div class="line">/** @access private */</div><div class="line">var foo = 0;</div><div class="line">/** @access protected */</div><div class="line">this._bar = 1;</div><div class="line">/** @access public */</div><div class="line">this.pez = 2;</div><div class="line">&#125;</div><div class="line">OR</div><div class="line">/**</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">function Thingy () &#123;</div><div class="line">/** @private */</div><div class="line">var foo = 0;</div><div class="line">/** @protected */</div><div class="line">this._bar = 1;</div><div class="line">/** @public */</div><div class="line">this.pez = 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><pre><code>标记成员有一个别名语法：@alias &lt;aliasNamepath&gt;例如，匿名的构造函数使用@alias。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Klass(&apos;trackr.CookieManager&apos;,</div><div class="line">/**</div><div class="line"> * 匿名函数</div><div class="line"> * @alias trackr.CookieManager</div><div class="line"> * @param kv</div><div class="line"> */</div><div class="line">function (kv) &#123;</div><div class="line">/** trackr.CookieManager＃value */</div><div class="line">this.value = kv;</div><div class="line">&#125;</div><div class="line">)</div></pre></td></tr></table></figure>您也可以在一个立即调用的函数表达式（IIFE）中创建的成员中使用@alias标签。@alias标签告诉JSDoc，这些成员都暴露在IIFE作用域之外的。例如，命名空间的静态方法使用@alias。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** @namespace */</div><div class="line">var Apple = &#123;&#125;;</div><div class="line">(function (ns) &#123;</div><div class="line">/**</div><div class="line"> * @namespace</div><div class="line"> * @alias Apple.Core</div><div class="line"> */</div><div class="line">var core = &#123;&#125;;</div><div class="line">/** Documented as Apple.Core.seed */</div><div class="line">core.speed = function () &#123;&#125;;</div><div class="line">ns.Core = core;</div><div class="line">&#125;)(Apple);</div></pre></td></tr></table></figure>对于那些对象字面量中定义的成员，可以使用@alias标签替代的@lends标记。例如，对象常量使用@alias。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Documenting objectA with @alias</div><div class="line">var objectA = (function() &#123;</div><div class="line">/**</div><div class="line"> * Documented as objectA</div><div class="line"> * @alias objectA</div><div class="line"> * @namespace</div><div class="line"> */</div><div class="line"> /** @lends objectA */</div><div class="line">var x = &#123;</div><div class="line">/**</div><div class="line"> * Documented as objectA.myProperty</div><div class="line"> * @member</div><div class="line"> */</div><div class="line">myProperty: &apos;foo&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">return x;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></code></pre><h3 id="auguments"><a href="#auguments" class="headerlink" title="@auguments"></a>@auguments</h3><pre><code>@augments or@extends标签指明标识符继承自哪个父类，后面需要加父类名。你可以使用这个标签来记录基于类和并基于原型的继承。别名：@extends语法：@auguments &lt;namepath&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 动物</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">function Animal () &#123;</div><div class="line">this.alive = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 鸭子</div><div class="line"> * @constructor</div><div class="line"> * @auguments Animal</div><div class="line"> */</div><div class="line">function Duck () &#123;&#125;</div><div class="line">Duck.prototype = new Animal();</div><div class="line">Duck.prototype.speak = function () &#123;</div><div class="line">if (this.alive) &#123;</div><div class="line">alert(&apos;Quack!&apos;);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">var d = new Duck();</div><div class="line">d.speak();</div></pre></td></tr></table></figure></code></pre><h3 id="author"><a href="#author" class="headerlink" title="@author"></a>@author</h3><pre><code>@author标签标识一个项目的作者。语法：@author &lt;name&gt; [&lt;emailAddress&gt;]<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* @author fanerge &lt;fanerge@qq.com&gt;</div><div class="line">*/</div><div class="line">function MyClass () &#123;&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="borrows"><a href="#borrows" class="headerlink" title="@borrows"></a>@borrows</h3><pre><code>@borrows标签允许您将另一个标识符的描述添加到你的当前描述。语法：@borrows &lt;that namepath&gt; as &lt;this namepath&gt;在这个例子中，&quot;trstr&quot;函数存在文档，但&quot;util.trim&quot;只是使用不同的名称引用相同的功能。例如，复制trstr的文档描述给util.trim。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @namespace</div><div class="line"> * @borrows trstr as trim</div><div class="line"> */</div><div class="line">var util = &#123;</div><div class="line">trim: trstr</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Remove whitespace from around a string.</div><div class="line"> * @param &#123;string&#125; str</div><div class="line"> */</div><div class="line">function trstr(str) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="callback"><a href="#callback" class="headerlink" title="@callback"></a>@callback</h3><pre><code>描述一个回调函数。@Callback标签提供回调函数（可传递给其他函数）的描述，包括回调的参数和返回值。你可以包涵任何一个你能提供给@method标签。语法：@callback &lt;namepath&gt;例如,描述一个指定类回调。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Requester() &#123;&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Send a request.</div><div class="line"> * @param &#123;Requester~requestCallback&#125; cb - The callback that handles the response.</div><div class="line"> */</div><div class="line">Requester.prototype.send = function(cb) &#123;</div><div class="line">// code</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * This callback is displayed as part of the Requester class.</div><div class="line"> * @callback Requester~requestCallback</div><div class="line"> * @param &#123;number&#125; responseCode</div><div class="line"> * @param &#123;string&#125; responseMessage</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><h3 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h3><pre><code>@class标签标明函数是一个构造器函数，意味着需要使用 new 关键字来返回一个实例，即使用 new 关键字实例化。别名：@constructor语法：@class [&lt;type&gt; &lt;name&gt;]例如，一个函数构建一个Person实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建一个人</div><div class="line"> * @class</div><div class="line"> */</div><div class="line">function Person () &#123;&#125;</div><div class="line">var p = new Person();</div></pre></td></tr></table></figure></code></pre><h3 id="classdesc"><a href="#classdesc" class="headerlink" title="@classdesc"></a>@classdesc</h3><pre><code>@classdesc标签用于为类提供一个描述，这样和构造函数的描述区分开来。@classdesc标签应该与 @class (或 @constructor)标签结合使用。语法：@classdesc &lt;some description&gt;如下所示，一个类有两个添加描述的地方，一个适用于函数本身，而另一个一般适用于类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * This is a description of the MyClass constructor function.</div><div class="line"> * @class</div><div class="line"> * @classdesc This is a description of the MyClass class.</div><div class="line"> */</div><div class="line">function MyClass() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="constant"><a href="#constant" class="headerlink" title="@constant"></a>@constant</h3><pre><code>@constant 标签指明这个对象是一个常量。语法：@constant [&lt;type&gt; &lt;name&gt;]    例如，一个字符串常量表示红色。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** @constant</div><div class="line">@type &#123;string&#125;</div><div class="line">@default</div><div class="line">*/</div><div class="line">const RED = &apos;FF0000&apos;;</div></pre></td></tr></table></figure></code></pre><h3 id="constructs"><a href="#constructs" class="headerlink" title="@constructs"></a>@constructs</h3><pre><code>当使用对象字面量形式定义类（例如使用@lends标签）时，可使用@constructs标签标明这个函数用来作为类的构造实例。语法：＠constructs [name]例如， @constructs 和 @lends 结合使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var Person = makeClass(</div><div class="line">   /** @lends Person.prototype */</div><div class="line">   &#123;</div><div class="line">       /**</div><div class="line">        * @constructs</div><div class="line">        * @param name</div><div class="line">        */</div><div class="line">       initialize: function (name) &#123;</div><div class="line">           this.name = name;</div><div class="line">       &#125;,</div><div class="line">       /**</div><div class="line">        * @param msg</div><div class="line">        * @returns &#123;*&#125;</div><div class="line">        */</div><div class="line">       say: function (msg) &#123;</div><div class="line">           return `$&#123;this.name&#125;says:$&#123;msg&#125;`;</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></code></pre><h3 id="copyright"><a href="#copyright" class="headerlink" title="@copyright"></a>@copyright</h3><pre><code>@copyright标签是用来描述一个文件的版权信息。一般和@file 标签结合使用。语法：@copyright &lt;some copyright text&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* @file this is javascript</div><div class="line">* @copyright fanerge 2017</div><div class="line">*/</div></pre></td></tr></table></figure></code></pre><h3 id="default"><a href="#default" class="headerlink" title="@default"></a>@default</h3><pre><code>@default标签可以让你记录标识的赋值。可以在标签后面跟上他的值，或者当值是一个唯一被分配的简单值(可以是：一个字符串，数字，布尔值或null)的时候，你可以让JSDoc从源代码中获取值，自动记录 。别名：defaultvalue语法：@default [&lt;some value&gt;]在本实例中,一个常量被记录。该常数的值为0xff0000。通过添加@default标签，这个值将自动添加到文档。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* @constant</div><div class="line">* @default</div><div class="line">*/</div><div class="line">const RED = &apos;0xff0000&apos;;</div></pre></td></tr></table></figure></code></pre><h3 id="deprecated"><a href="#deprecated" class="headerlink" title="@deprecated"></a>@deprecated</h3><pre><code>@deprecated 标签指明一个标识在你代码中已经被弃用。语法：@deprecated [&lt;some text&gt;]例如，描述一个old函数从2.0版本开始已经被弃用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* @deprecated since version 2.0</div><div class="line">*/</div><div class="line">function old () &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="description"><a href="#description" class="headerlink" title="@description"></a>@description</h3><pre><code>@description标签允许您提供一般描述。该说明可能包括HTML标签。如果Markdown 插件启用的话，它也可包括Markdown格式。别名：@desc语法：@description &lt;some description&gt;例如，不用@description标签描述一个标识<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Add two numbers.</div><div class="line"> * @param &#123;number&#125; a</div><div class="line"> * @param &#123;number&#125; b</div><div class="line"> * @returns &#123;number&#125;</div><div class="line"> */</div><div class="line">function add(a, b) &#123;</div><div class="line">return a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>例如，用@description标签描述一个标识<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number&#125; a</div><div class="line"> * @param &#123;number&#125; b</div><div class="line"> * @returns &#123;number&#125;</div><div class="line"> * @description Add two numbers.</div><div class="line"> */</div><div class="line">function add(a, b) &#123;</div><div class="line">return a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="enum"><a href="#enum" class="headerlink" title="@enum"></a>@enum</h3><pre><code>@enum标签描述一个静态属性值的全部相同的集合。枚举类似一个属性的集合，除了枚举自己的描述注释之外，属性都记录在容器内部的注释中。通常这种标签是与@ReadOnly结合使用，作为一个枚举通常表示常量的集合。语法：@enum [&lt;type&gt;]例如，一个数字枚举，表示的3种状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Enum for tri-state values.</div><div class="line"> * @readonly</div><div class="line"> * @enum &#123;number&#125;</div><div class="line"> */</div><div class="line">var triState = &#123;</div><div class="line">/** The true value */</div><div class="line">TRUE: 1,</div><div class="line">FALSE: -1,</div><div class="line">/** @type &#123;boolean&#125; */</div><div class="line">MAYBE: true</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="event"><a href="#event" class="headerlink" title="@event"></a>@event</h3><pre><code>描述一个事件。@event标签允许您描述一个可触发的事件，一个典型的事件是由对象定义的一组属性来表示。标签来定义事件的具体类型，您可以使用@fires标记，以表明这个种方法可以触发该事件。你还可以使用@listens标签，以指示表明用这个表示来侦听该事件。    语法：@event &lt;className&gt;#[event:]&lt;eventName&gt;例如，描述一个作为事件的行数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Throw a snowball.</div><div class="line"> *</div><div class="line"> * @fires Hurl#snowball</div><div class="line"> */</div><div class="line">Hurl.prototype.snowball = function() &#123;</div><div class="line">/**</div><div class="line"> * Snowball event.</div><div class="line"> *</div><div class="line"> * @event Hurl#snowball</div><div class="line"> * @type &#123;object&#125;</div><div class="line"> * @property &#123;boolean&#125; isPacked - Indicates whether the snowball is tightly packed.</div><div class="line"> */</div><div class="line">this.emit(&apos;snowball&apos;, &#123;</div><div class="line">isPacked: this._snowball.isPacked</div><div class="line">&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="example"><a href="#example" class="headerlink" title="@example"></a>@example</h3><pre><code>提供一个如何使用描述项的例子。跟随此标签的文字将显示为高亮代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Solves equations of the form a * x = b</div><div class="line"> * @example</div><div class="line"> * // returns 2</div><div class="line"> * globalNS.method1(5, 10);</div><div class="line"> * @example</div><div class="line"> * // returns 3</div><div class="line"> * globalNS.method(5, 15);</div><div class="line"> * @returns &#123;Number&#125; Returns the value of x for the equation.</div><div class="line"> */</div><div class="line">globalNS.method1 = function (a, b) &#123;</div><div class="line">return b / a;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="exports"><a href="#exports" class="headerlink" title="@exports"></a>@exports</h3><pre><code>@exports标签描述由JavaScript模块的exports或module.exports属性导出的任何内容。语法：@exports &lt;moduleName&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A module that says hello!</div><div class="line"> * @module hello/world</div><div class="line"> */</div><div class="line"></div><div class="line">/** Say hello. */</div><div class="line">exports.sayHello = function() &#123;</div><div class="line">return &apos;Hello world&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><h3 id="external"><a href="#external" class="headerlink" title="@external"></a>@external</h3><pre><code>@external标签用来标识一个在当前包外部定义的类，命名空间，或模块。通过使用这个标签，你可以描述你的包的外部标识的扩展，或者您也可以提供关于 外部标识的相关信息给你的包的使用者。你也可以在任何其他JSDoc标签中引用外部标识的namepath（名称路径）。外部标识引用的路径名 始终需要使用external:前缀：（例如{@link external:Foo}或@augments external:Foo）。 但是，你可以省略@external标记的这个前缀。别名：@host下面的示例演示如何描述内置的String对象作为external，新的实例方法external:String#rot13<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The built in string object.</div><div class="line"> * @external String</div><div class="line"> * @see &#123;@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String&#125;</div><div class="line"> */</div><div class="line"></div><div class="line">/**</div><div class="line"> * Create a ROT13-encoded version of the string. Added by the `foo` package.</div><div class="line"> * @function external:String#rot13</div><div class="line"> * @example</div><div class="line"> * var greeting = new String(&apos;hello world&apos;);</div><div class="line"> * console.log( greeting.rot13() ); // uryyb jbeyq</div><div class="line"> */</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;块标签（Block Tags）&lt;/p&gt;
&lt;h3 id=&quot;abstract&quot;&gt;&lt;a href=&quot;#abstract&quot; class=&quot;headerlink&quot; title=&quot;@abstract&quot;&gt;&lt;/a&gt;@abstract&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;该成员（一般指父类的方法）
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-常用示例</title>
    <link href="https://fanerge.github.io/2017/09/25/jsDoc%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://fanerge.github.io/2017/09/25/jsDoc学习-1/</id>
    <published>2017-09-25T11:51:34.000Z</published>
    <updated>2017-10-12T13:02:10.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jsDoc-示例"><a href="#jsDoc-示例" class="headerlink" title="jsDoc 示例"></a>jsDoc 示例</h2><h3 id="ES-2015-Classes"><a href="#ES-2015-Classes" class="headerlink" title="ES 2015 Classes"></a>ES 2015 Classes</h3><pre><code>Documenting a simple class（文档化一个简单的类）        演示了如何通过一个构造函数，两个实例方法和一个静态方法文档化一个简单的类    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">/**</div><div class="line"> * 构造函数</div><div class="line"> * @param x</div><div class="line"> * @param y</div><div class="line"> */</div><div class="line">constructor (x, y) &#123;</div><div class="line">this.x = x;</div><div class="line">this.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 实例方法</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getX () &#123;</div><div class="line">return this.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 实例方法</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getY () &#123;</div><div class="line">return this.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 静态方法</div><div class="line"> * @param str</div><div class="line"> */</div><div class="line">static fromString (str) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var de = new Point(&apos;1&apos;,&apos;2&apos;);</div><div class="line">console.log(de.getX()); // &apos;1&apos;</div></pre></td></tr></table></figure>Extending classes（扩展类）    当您使用 extends关键字来扩展一个现有的类的时候，你还需要告诉JSDoc哪个类是你要扩展的。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/** Class representing a point. */</div><div class="line">class Point &#123;</div><div class="line">/**</div><div class="line"> * 构造函数</div><div class="line"> * @param x</div><div class="line"> * @param y</div><div class="line"> */</div><div class="line">constructor (x, y) &#123;</div><div class="line">this.x = x;</div><div class="line">this.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 实例方法</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getX () &#123;</div><div class="line">return this.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 实例方法</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getY () &#123;</div><div class="line">return this.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 静态方法</div><div class="line"> * @param str</div><div class="line"> */</div><div class="line">static fromString (str) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">/** Class representing a point</div><div class="line"> * @extends Point</div><div class="line"> */</div><div class="line">class Dot extends  Point &#123;</div><div class="line">/**</div><div class="line"> * 构造函数</div><div class="line"> * @param x</div><div class="line"> * @param y</div><div class="line"> * @param width</div><div class="line"> */</div><div class="line">constructor (x, y, width) &#123;</div><div class="line">super(x,y);</div><div class="line">this.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 实例方法</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getWidth () &#123;</div><div class="line">return this.width;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dd = new Dot(1, 2, 3);</div><div class="line">console.log(dd.getX()); // 1</div></pre></td></tr></table></figure></code></pre><h3 id="ES-2015-Modules"><a href="#ES-2015-Modules" class="headerlink" title="ES 2015 Modules"></a>ES 2015 Modules</h3><pre><code>Module identifiers（模块标识符）    当你描述一个 ES 2015 module（模块）时，您将使用@module 标签来描述模块的标识符。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @module my/shirt</div><div class="line"> */</div><div class="line">import * as myShirt from &apos;my/shirt&apos;;</div></pre></td></tr></table></figure>    当您使用一个 JSDoc namepath（名称路径）从另一个JSDoc注释中引用一个模块，您必须添加前缀module:。    例如，如果你想模块my/pants的文档 连接到模块my/shirt，您可以使用@see 标签来描述my/pants。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Pants module.</div><div class="line"> * @module my/pants</div><div class="line"> * @see module:my/shirt</div><div class="line"> */</div></pre></td></tr></table></figure>    同样，模块中每个成员的namepath （名称路径）将以module: 开始，后面跟模块名字。    例如，如果你的my/pants模块输出一个Jeans类，并且Jeans 有一个名为hem的实例方法，    那么这个实例方法longname（长名称）是module:my/pants.Jeans#hem。Exported values （导出值）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/** The name of the module. */</div><div class="line">export const name = &apos;mixer&apos;;</div><div class="line"></div><div class="line">/** The most recent blended color. */</div><div class="line">export var lastColor = null;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Blend two colors together.</div><div class="line"> * @param &#123;string&#125; color1 - The first color, in hexidecimal format.</div><div class="line"> * @param &#123;string&#125; color2 - The second color, in hexidecimal format.</div><div class="line"> * @return &#123;string&#125; The blended color.</div><div class="line"> */</div><div class="line">export function blend(color1, color2) &#123;&#125;</div><div class="line"></div><div class="line">// convert color to array of RGB values (0-255)</div><div class="line">function rgbify(color) &#123;&#125;</div><div class="line"></div><div class="line">export &#123;</div><div class="line">/**</div><div class="line"> * Get the red, green, and blue values of a color.</div><div class="line"> * @function</div><div class="line"> * @param &#123;string&#125; color - A color, in hexidecimal format.</div><div class="line"> * @returns &#123;Array.&lt;number&gt;&#125; An array of the red, green, and blue values,</div><div class="line"> * each ranging from 0 to 255.</div><div class="line"> */</div><div class="line">rgbify as toRgb</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="CommonJS-Modules"><a href="#CommonJS-Modules" class="headerlink" title="CommonJS Modules"></a>CommonJS Modules</h3><pre><code>Module identifiers（模块标识符）        例如，如果你想模块my/pants的文档 连接到模块my/shirt，您可以使用@see 标签来描述my/pants。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Pants module.</div><div class="line"> * @module my/pants</div><div class="line"> * @see module:my/shirt</div><div class="line"> */</div></pre></td></tr></table></figure>Properties of the &apos;exports&apos; object（&apos;exports&apos;对象的属性）    例如，方法添加到导出对象。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Shirt module.</div><div class="line"> * @module my/shirt</div><div class="line"> */</div><div class="line"></div><div class="line">/** Button the shirt. */</div><div class="line">exports.button = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** Unbutton the shirt. */</div><div class="line">exports.unbutton = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>Values assigned to local variables （值分配给局部变量）    例如，longname（长名称）定义在 @alias 标签中。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Shirt module.</div><div class="line"> * @module my/shirt</div><div class="line"> */</div><div class="line"></div><div class="line">/**</div><div class="line"> * Wash the shirt.</div><div class="line"> * @alias module:my/shirt.wash</div><div class="line"> */</div><div class="line">var wash = exports.wash = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>    例如，JSDoc注释放在exports.wash之前。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Shirt module.</div><div class="line"> * @module my/shirt</div><div class="line"> */</div><div class="line"></div><div class="line">var wash =</div><div class="line">/** Wash the shirt. */</div><div class="line">exports.wash = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>Values assigned to &apos;module.exports&apos; （值分配给&apos;module.exports&apos;）    Object literal assigned to &apos;module.exports&apos;（对象字面量分配给&apos;module.exports&apos;）    例如：对象字面量分配给&apos;module.exports&apos;。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Color mixer.</div><div class="line"> * @module color/mixer</div><div class="line"> */</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">/** Blend two colors together. */</div><div class="line">blend: function(color1, color2) &#123;</div><div class="line">// ...</div><div class="line">&#125;,</div><div class="line"></div><div class="line">/** Darken a color by the given percentage. */</div><div class="line">darken: function(color, percent) &#123;</div><div class="line">// ..</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>    例如，通过属性定义，分配给module.exports。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Color mixer.</div><div class="line"> * @module color/mixer</div><div class="line"> */</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">/** Blend two colors together. */</div><div class="line">blend: function(color1, color2) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** Darken a color by the given percentage. */</div><div class="line">module.exports.darken = function(color, percent) &#123;</div><div class="line">// ..</div><div class="line">&#125;;</div></pre></td></tr></table></figure>    Function assigned to &apos;module.exports&apos;（函数分配给&apos;module.exports&apos;）    例如，函数分配给&apos;module.exports&apos;。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Color mixer.</div><div class="line"> * @module color/mixer</div><div class="line"> */</div><div class="line"></div><div class="line">/** Blend two colors together. */</div><div class="line">module.exports = function(color1, color2) &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>    例如，构造函数分配给&apos;module.exports&apos;。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Color mixer.</div><div class="line"> * @module color/mixer</div><div class="line"> */</div><div class="line"></div><div class="line">/** Create a color mixer. */</div><div class="line">module.exports = function ColorMixer() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>    String, number, or boolean assigned to &apos;module.exports&apos;（字符串，数字，或布尔值分配给&apos;module.exports&apos;）    例如，字符串分配给&apos;module.exports&apos;。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Module representing the word of the day.</div><div class="line"> * @module wotd</div><div class="line"> * @type &#123;string&#125;</div><div class="line"> */</div><div class="line"></div><div class="line">module.exports = &apos;perniciousness&apos;;</div></pre></td></tr></table></figure>    Values assigned to &apos;module.exports&apos; and local variables （值分配给&apos;module.exports&apos;和局部变量）    例如，对象字面量分配给一个局部变量和module.export。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Color mixer.</div><div class="line"> * @exports color/mixer</div><div class="line"> */</div><div class="line">var mixer = module.exports = &#123;</div><div class="line">/** Blend two colors together. */</div><div class="line">blend: function(color1, color2) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>    Properties added to &apos;this&apos;（属性添加到&apos;this&apos;）    例如，属性添加到一个模块的&apos;this&apos;对象。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/** @module bookshelf */</div><div class="line"></div><div class="line">/** @class */</div><div class="line">this.Book = function(title) &#123;</div><div class="line">/** The title of the book. */</div><div class="line">this.title = title;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="AMD-Modules"><a href="#AMD-Modules" class="headerlink" title="AMD Modules"></a>AMD Modules</h3><pre><code>Module identifiers（模块标识符）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Pants module.</div><div class="line"> * @module my/pants</div><div class="line"> * @see module:my/shirt</div><div class="line"> */</div></pre></td></tr></table></figure>Function that returns an object literal（函数返回一个对象字面量）    例如，函数返回一个对象字面量。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">define(&apos;my/shirt&apos;, function() &#123;</div><div class="line">   /**</div><div class="line">* A module representing a shirt.</div><div class="line">* @exports my/shirt</div><div class="line">*/</div><div class="line">var shirt = &#123;</div><div class="line">/** The module&apos;s `color` property. */</div><div class="line">color: &apos;black&apos;,</div><div class="line"></div><div class="line">/** @constructor */</div><div class="line">Turtleneck: function(size) &#123;</div><div class="line">/** The class&apos; `size` property. */</div><div class="line">this.size = size;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">return shirt;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>Function that returns another function（函数返回另一个函数）    例如，函数返回另一个函数。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A module representing a jacket.</div><div class="line"> * @module my/jacket</div><div class="line"> */</div><div class="line">define(&apos;my/jacket&apos;, function() &#123;</div><div class="line">/**</div><div class="line"> * @constructor</div><div class="line"> * @alias module:my/jacket</div><div class="line"> */</div><div class="line">var Jacket = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** Zip up the jacket. */</div><div class="line">Jacket.prototype.zip = function() &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">return Jacket;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>Module declared in a return statement （模块声明在return语句中）    例如，模块声明在return语句中。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Module representing a shirt.</div><div class="line"> * @module my/shirt</div><div class="line"> */</div><div class="line"></div><div class="line">define(&apos;my/shirt&apos;, function() &#123;</div><div class="line">// Do setup work here.</div><div class="line"></div><div class="line">return /** @alias module:my/shirt */ &#123;</div><div class="line">/** Color. */</div><div class="line">color: &apos;black&apos;,</div><div class="line">/** Size. */</div><div class="line">size: &apos;unisize&apos;</div><div class="line">&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>Module object passed to a function（模块对象传递给一个函数）    例如，模块对象传递给一个函数。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">define(&apos;my/jacket&apos;, function(</div><div class="line">/**</div><div class="line"> * Utility functions for jackets.</div><div class="line"> * @exports my/jacket</div><div class="line"> */</div><div class="line">module) &#123;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Zip up a jacket.</div><div class="line"> * @param &#123;Jacket&#125; jacket - The jacket to zip up.</div><div class="line"> */</div><div class="line">module.zip = function(jacket) &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>Multiple modules defined in one file（多模块定义在一个文件中）    例如，多模块定义在一个文件中。    ```    // one module    define(&apos;html/utils&apos;, function() {        /**         * Utility functions to ease working with DOM elements.         * @exports html/utils         */        var utils = {            /** Get the value of a property on an element. */            getStyleProperty: function(element, propertyName) { }        };        /** Determine if an element is in the document head. */        utils.isInHead = function(element) { }        return utils;        }    );    // another module    define(&apos;tag&apos;, function() {        /** @exports tag */        var tag = {            /** @class */            Tag: function(tagName) {                // ...            }        };        return tag;    });    ```        </code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jsDoc-示例&quot;&gt;&lt;a href=&quot;#jsDoc-示例&quot; class=&quot;headerlink&quot; title=&quot;jsDoc 示例&quot;&gt;&lt;/a&gt;jsDoc 示例&lt;/h2&gt;&lt;h3 id=&quot;ES-2015-Classes&quot;&gt;&lt;a href=&quot;#ES-2015-Classe
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>jsDoc学习-入门知识</title>
    <link href="https://fanerge.github.io/2017/09/24/jsDoc%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/24/jsDoc学习/</id>
    <published>2017-09-24T11:47:00.000Z</published>
    <updated>2017-10-12T13:02:28.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jsDoc介绍"><a href="#jsDoc介绍" class="headerlink" title="jsDoc介绍"></a>jsDoc介绍</h2><p>定义：JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。<br>jsDoc注释：是以 /** 来作为jsDoc注释的开始，其它如 /* 和 /*** 的注释都会被jsDoc解析器忽略。<br>    在webstorm中自动生成jsDoc注释<br>    示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Book类，代表一本书</div><div class="line"> * @param title</div><div class="line"> * @param anthor</div><div class="line"> * @param pageNum</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">function Book (title, anthor, pageNum ) &#123;</div><div class="line">// 实例属性</div><div class="line">this.title = title;</div><div class="line">this.anthor = anthor;</div><div class="line">this.pageNum = pageNum || 0;</div><div class="line">&#125;</div><div class="line">Book.prototype = &#123;</div><div class="line">/**</div><div class="line"> * 获取书本的标题</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getTitle : function () &#123;</div><div class="line">return this.title;</div><div class="line">&#125;,</div><div class="line">/**</div><div class="line"> * 获取书本的作者</div><div class="line"> * @returns &#123;*&#125;</div><div class="line"> */</div><div class="line">getAnthor: function  () &#123;</div><div class="line">return this.anthor;</div><div class="line">&#125;,</div><div class="line">/**</div><div class="line"> * 设置书本的页码</div><div class="line"> * @param pageNum</div><div class="line"> */</div><div class="line">setPageNum: function (pageNum) &#123;</div><div class="line">this.pageNum = pageNum;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Namepaths-in-JSDoc-3（JSDoc-3中的名称路径）"><a href="#Namepaths-in-JSDoc-3（JSDoc-3中的名称路径）" class="headerlink" title="Namepaths in JSDoc 3（JSDoc 3中的名称路径）"></a>Namepaths in JSDoc 3（JSDoc 3中的名称路径）</h3><pre><code>如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。jsDoc中名称路径的基本语法示例：</code></pre><ol><li>myFunction</li><li>MyConstructor</li><li>MyConstructor#instanceMember（实例成员）</li><li>MyConstructor.staticMember（静态成员）</li><li><p>MyConstructor~innerMember（内部成员）<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Person类，一个人</div><div class="line"> * @param name</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">const  Person = function (name) &#123;</div><div class="line">this.name = name;</div><div class="line">/**</div><div class="line"> * 这是一个实例成员</div><div class="line"> * @returns &#123;string&#125;</div><div class="line"> */</div><div class="line">this.say = () =&gt; &#123;</div><div class="line">return &apos;I\&apos;am an instance.&apos;;</div><div class="line">&#125;;</div><div class="line">/**</div><div class="line"> * 这是一个内部成员</div><div class="line"> * @returns &#123;string&#125;</div><div class="line"> */</div><div class="line">function say () &#123;</div><div class="line">return &apos;I\&apos; am an inner.&apos;;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">/**</div><div class="line"> * 这是一个静态成员</div><div class="line"> * @returns &#123;string&#125;</div><div class="line"> */</div><div class="line">Person.say = function () &#123;</div><div class="line">return &apos;I\&apos;am an static.&apos;;</div><div class="line">&#125;;</div><div class="line">/**</div><div class="line"> * 实例化一个人</div><div class="line"> * @type &#123;Person&#125;</div><div class="line"> */</div><div class="line">const person1 = new Person(&apos;fanerge&apos;);</div><div class="line">// Person#say 使用实例方法</div><div class="line">person1.say();</div><div class="line">// Person.say 使用静态方法</div><div class="line">Person.say();</div><div class="line">// Person~say 使用内部方法，但这里不能访问到</div></pre></td></tr></table></figure><p>使用名称路径也有一些特殊的情况：@module名称由”module:”前缀，<br>@external 名称由”external:”前缀，@event名称由”event:”前缀。</p><h3 id="JSDoc中的命令行参数"><a href="#JSDoc中的命令行参数" class="headerlink" title="JSDoc中的命令行参数"></a>JSDoc中的命令行参数</h3><p>使用JSDoc最基本的，像这样使用：<br><code>/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...</code><br>其中…是生成文档文件的路径。<br>JSDoc支持大量的命令行选项，其中许多选项有长和短两种形式。<br>选项    描述<br>-a <value>, –access <value>    只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。<br>-c <value>, –configure <value>    JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。<br>-d <value>, –destination <value>    输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。<br>–debug    打印日志信息，可以帮助调试JSDoc本身的问题。<br>-e <value>, –encoding <value>    当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。<br>-h, –help    显示JSDoc的命令行选项的信息，然后退出。<br>–match <value>    只有运行测试，其名称中包含value。<br>–nocolor    当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。<br>-p, –private    将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。<br>-P, –package    包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。<br>–pedantic    将错误视为致命错误，将警告视为错误。默认为false。<br>-q <value>, –query <value>    一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&amp;baz=true。<br>-r, –recurse    扫描源文件和导览时递归到子目录。<br>-R, –readme    用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。<br>-t <value>, –template <value>    用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。<br>-T, –test    运行JSDoc的测试套件，并把结果打印到控制台。<br>-u <value>, –tutorials <value>    导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。<br>-v, –version    显示JSDoc的版本号，然后退出。<br>–verbose    日志的详细信息到控制台JSDoc运行。默认为false。<br>-X, –explain    以JSON格式转储所有的doclet到控制台，然后退出。</value></value></value></value></value></value></value></value></value></value></value></value></value></value></value></p><p>示例：<br>使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中：<br>  /path/to/jsdoc src -r -c /path/to/my/conf.json -d docs<br>运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息：<br>  /path/to/jsdoc -T –match tag –verbose</p><h3 id="用conf-json配置JSDoc"><a href="#用conf-json配置JSDoc" class="headerlink" title="用conf.json配置JSDoc"></a>用conf.json配置JSDoc</h3><p>Configuration File(配置文件)<br>  要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json。<br>  默认的jsDoc配置文件conf.json.EXAMPLE</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;tags&quot;: &#123;</div><div class="line">&quot;allowUnknownTags&quot;: true,</div><div class="line">&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]</div><div class="line">&#125;,</div><div class="line">&quot;source&quot;: &#123;</div><div class="line">&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;,</div><div class="line">&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;</div><div class="line">&#125;,</div><div class="line">&quot;plugins&quot;: [],</div><div class="line">&quot;templates&quot;: &#123;</div><div class="line">&quot;cleverLinks&quot;: false,</div><div class="line">&quot;monospaceLinks&quot;: false</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Specifying input files(指定输入文件)<br>  source选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档。 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;source&quot;: &#123;</div><div class="line">&quot;include&quot;: [ /* array of paths to files to generate documentation for */ ],</div><div class="line">&quot;exclude&quot;: [ /* array of paths to exclude */ ],</div><div class="line">&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;,</div><div class="line">&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Incorporating command-line options into the configuration file(合并命令行选项到配置文件)<br>  它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。<br>  要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;opts&quot;: &#123;</div><div class="line">&quot;template&quot;: &quot;templates/default&quot;,  // same as -t templates/default</div><div class="line">&quot;encoding&quot;: &quot;utf8&quot;,               // same as -e utf8</div><div class="line">&quot;destination&quot;: &quot;./out/&quot;,          // same as -d ./out/</div><div class="line">&quot;recurse&quot;: true,                  // same as -r</div><div class="line">&quot;tutorials&quot;: &quot;path/to/tutorials&quot;, // same as -u path/to/tutorials</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Plugins（插件）<br>  要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。<br>  示例：<br>  例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;plugins&quot;: [</div><div class="line">&quot;plugins/markdown&quot;,</div><div class="line">&quot;plugins/summarize&quot;</div><div class="line">]</div></pre></td></tr></table></figure><p>Tags and tag dictionaries(标签和标签字典)<br>  tags选项控制哪些JSDoc标签允许被使用和解析。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;tags&quot;: &#123;</div><div class="line">&quot;allowUnknownTags&quot;: true,</div><div class="line">&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="配置JSDoc的默认模板"><a href="#配置JSDoc的默认模板" class="headerlink" title="配置JSDoc的默认模板"></a>配置JSDoc的默认模板</h3><pre><code>JSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。Generating pretty-printed source files（生成适合打印的文档）    默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。    要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。    使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。Copying static files to the output directory(复制静态文件到输出目录)    SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。    在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。    例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。Showing the current date in the page footer（在页脚显示当前日期）    默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。    在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。Showing longnames in the navigation column（在导航栏中显示长文件名）    默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。    例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。    此选项在JSDoc3.4.0及更高版本中可用。Overriding the default template&apos;s layout file（重写默认模板的布局文件）    默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。    特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。    要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。    路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。</code></pre><h3 id="块标签和内联标签"><a href="#块标签和内联标签" class="headerlink" title="块标签和内联标签"></a>块标签和内联标签</h3><pre><code>JSDoc支持两种不同类型的标签：</code></pre><ol><li>块标签, 这是在一个JSDoc注释的最高级别。</li><li>内联标签, 块标签文本中的标签或说明。<br>块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。<br>块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。<br>内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（<a>）。<br>内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。<br>如果你的标签文本中包含右花括号（}），则必须用反斜线（ \ ）进行转义。<br>在内联标签后,你并不需要使用一个换行符。<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Shoe类，一双鞋子</div><div class="line"> * @param color</div><div class="line"> * @param size</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line">const Shoe = function (color, size)&#123;</div><div class="line">this.color = color;</div><div class="line">this.size = size;</div><div class="line">&#125;;</div><div class="line">/**</div><div class="line"> * Set shoe&apos;s color. Use &#123;@link Shoe#setSize&#125; to set the shoe size</div><div class="line"> * @param color</div><div class="line"> */</div><div class="line">Shoe.prototype.setColor = function (color) &#123;</div><div class="line">this.color = color;</div><div class="line">&#125;;</div><div class="line">/**</div><div class="line"> * 设置鞋子的尺寸</div><div class="line"> * @param size</div><div class="line"> */</div><div class="line">Shoe.prototype.setSize = function (size) &#123;</div><div class="line">this.size = size;</div><div class="line">&#125;;</div><div class="line">/**</div><div class="line"> * 设置花边的颜色和样式</div><div class="line"> * @param color</div><div class="line"> * @param type</div><div class="line"> */</div><div class="line">Shoe.prototype.setLaceType = function (color, type) &#123;</div><div class="line">// ...</div><div class="line">&#125;;</div><div class="line">var shoe1 = new Shoe(&apos;red&apos;, 12);</div></pre></td></tr></table></figure></a></li></ol><h3 id="关于JSDoc插件"><a href="#关于JSDoc插件" class="headerlink" title="关于JSDoc插件"></a>关于JSDoc插件</h3><pre><code>Creating and Enabling a Plugin（创建并启用插件）    创建并启用新JSDoc插件,需要两个步骤：        创建一个包含你的插件代码的JavaScript模块.        将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。        如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。Authoring JSDoc 3 Plugins（创建JSDoc3插件）    JSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果：</code></pre><ol><li>定义事件处理程序</li><li>定义标签</li><li><p>定义一个抽象语法树节点的访问者<br>Event Handlers（事件处理程序）<br>事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。<br>事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。<br>事件: beforeParse – beforeParse事件在解析开始之前被触发。<br>事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。<br>事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。<br>事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。<br>事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。<br>事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。<br>事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。<br>Tag Definitions （标签定义）<br>添加标签到标签字典是影响文档生成的一个中级方式。<br>在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。<br>当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。<br>The Dictionary（字典）<br>Node Visitors（节点访问者）<br>Reporting Errors(报告错误)</p><h3 id="使用Markdown插件"><a href="#使用Markdown插件" class="headerlink" title="使用Markdown插件"></a>使用Markdown插件</h3><p>Enabling the Markdown plugin(启用markdown插件)<br>要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。<br>Converting Markdown in additional JSDoc tags（在额外的JSDoc标签中转换Markdown）<br>默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。<br>您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。<br>Excluding the default tags from Markdown processing（剔除markdown默认处理的标签）<br>为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。<br>Hard-wrapping text at line breaks （用换行符换行文本）<br>默认情况下，Markdown插件不处理换行符换行的文本。<br>Adding ID attributes to headings（添加ID属性到标题标签）<br>默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。</p><h3 id="Tutorials-教程"><a href="#Tutorials-教程" class="headerlink" title="Tutorials 教程"></a>Tutorials 教程</h3><p>JSDoc允许你的API文档的页面旁边包含教程。<br>您可以使用此功能来为您的API提供详细的使用说明，如“入门”指南或实现一个功能的一步一步的过程。</p><p>Adding tutorials（添加教程）<br>添加教程到您的API文档，可以通过–tutorials 或 -u 选项运行JSDoc，并提供JSDoc要搜索的教程目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jsdoc -u path/to/tutorials path/to/js/files</div></pre></td></tr></table></figure><p>Configuring titles, order, and hierarchy （配置标题，顺序和层次结构）<br>默认情况下，JSDoc使用的文件名作为教程标题，并且所有的教程都在同一层次。<br>您可以使用JSON文件为每个教程提供标题并指示文档中的教程应如何排序和分组。<br>Linking to tutorials from API documentation（从API文档链接到教程）<br>@tutorial 块标签<br>{@tutorial} 内联标签</p><h3 id="包含Package（包）文件"><a href="#包含Package（包）文件" class="headerlink" title="包含Package（包）文件"></a>包含Package（包）文件</h3><p>包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。<br>当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。<br>示例，默认的模板在文档中显示项目的名称和版本号。<br>在源路径中包含一个包文件:<br>  jsdoc path/to/js path/to/package/package.json<br>使用 -P/–package 选项：<br>  jsdoc –package path/to/package/package-docs.json path/to/js    </p><h3 id="包含-README-文件"><a href="#包含-README-文件" class="headerlink" title="包含 README 文件"></a>包含 README 文件</h3><p>有两种方法可以将 README 文件中的信息合并到您的文档：<br>在源路径中包含一个 README 文件:<br>jsdoc path/to/js path/to/readme/README.md<br>使用 -R/–readme 选项：<br>jsdoc –readme path/to/readme/README path/to/js</p><blockquote><p>   参考文档：<br><a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="external">jsDoc文档</a>    </p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jsDoc介绍&quot;&gt;&lt;a href=&quot;#jsDoc介绍&quot; class=&quot;headerlink&quot; title=&quot;jsDoc介绍&quot;&gt;&lt;/a&gt;jsDoc介绍&lt;/h2&gt;&lt;p&gt;定义：JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、
      
    
    </summary>
    
      <category term="代码规范" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="代码规范" scheme="https://fanerge.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>MVC学习</title>
    <link href="https://fanerge.github.io/2017/09/21/MVC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/21/MVC学习/</id>
    <published>2017-09-21T12:22:26.000Z</published>
    <updated>2017-09-22T13:24:59.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><pre><code>MVC的全名是Model View Controller，是模型（model）--视图（view）--控制器（controller）的缩写，是一种软件设计典范。M（数据模型）：比如你设计一个User对象，包含username和password属性，它就是一个简单的M。M是指业务模型，V是指用户界面，C则是控制器。</code></pre><h3 id="在web开发中"><a href="#在web开发中" class="headerlink" title="在web开发中"></a>在web开发中</h3><pre><code>V--即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。    MVC的好处之一在于它能为应用程序处理很多不同的视图。    在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。M--即Model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。    被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，    由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。C--即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，    控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，    然后再确定用哪个视图来显示返回的数据。它们三者的关系</code></pre><p><img src="http://images2015.cnblogs.com/blog/811883/201704/811883-20170423150019101-1710764799.jpg" alt="mvc关系图"><br>    用户首先在界面中进行人机交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型，<br>    模型可以与数据库进行交互，进行增删改查操作，完成之后，根据业务的逻辑选择相应的视图进行显示，此时用户获得此次交互的反馈信息，<br>    用户可以进行下一步交互，如此循环。</p><h3 id="每层主要的功能"><a href="#每层主要的功能" class="headerlink" title="每层主要的功能"></a>每层主要的功能</h3><pre><code>视图（View）：用户界面控制器（Controller）：业务逻辑模型（Model）：数据保存</code></pre><p><img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt="各部分之间的通信方式如下"></p><h3 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h3><pre><code>控制器（Controller）- 负责转发请求，对请求进行处理。视图（View） - 界面设计人员进行图形界面设计。模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</code></pre><p><img src="/images/ModelViewControllerDiagramZh.png" alt="图解MVC"></p><pre><code>将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。“Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比较：观察者模式（软件设计模式））视图（View）能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。控制器（Controller）起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。</code></pre><h3 id="javscript的一个MVC示例"><a href="#javscript的一个MVC示例" class="headerlink" title="javscript的一个MVC示例"></a>javscript的一个MVC示例</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** 模擬 Model, View, Controller */</div><div class="line">var M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;</div><div class="line"></div><div class="line">/** Model 負責存放資料 */</div><div class="line">M.data = &quot;hello world&quot;;</div><div class="line"></div><div class="line">/** View 負責將資料輸出到螢幕上 */</div><div class="line">V.render = (M) =&gt; &#123; alert(M.data); &#125;</div><div class="line"></div><div class="line">/** Controller 作為一個 M 和 V 的橋樑 */</div><div class="line">C.handleOnload = () =&gt; &#123; V.render(M); &#125;</div><div class="line"></div><div class="line">/** 在網頁讀取的時候呼叫 Controller */</div><div class="line">window.onload = C.handleOnload;</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="http://www.cnblogs.com/diyunfei/p/6752618.html" target="_blank" rel="external">MVC简介</a><br>    <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">阮一峰</a><br>    <a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="external">wiki-MVC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;MVC的全名是Model View Controller，是模型（model）--视图（view）--控制器
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="MVC" scheme="https://fanerge.github.io/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Sass学习</title>
    <link href="https://fanerge.github.io/2017/09/20/Sass%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/20/Sass学习/</id>
    <published>2017-09-20T11:41:05.000Z</published>
    <updated>2017-09-22T12:36:17.676Z</updated>
    
    <content type="html"><![CDATA[<p>Sass是在CSS语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。</p><h2 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h2><pre><code>在命令行中运行 Sass    sass input.scss output.css监视单个 Sass 文件，每次修改并保存时自动编译    sass --watch input.scss:output.css监视整个文件夹    sass --watch app/scss:public/stylesheets开启debug信息    sass --watch input.scss:output.css --debug-info选择编译格式并添加调试map    sass --watch input.scss:output.css --style expanded --sourcemap编译添加调试map    sass --watch input.scss:output.css --sourcemap编译格式    sass --watch input.scss:output.css --style compact</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><pre><code>sass让人们受益的一个重要特性就是它为css引入了变量。你可以把反复使用的css属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。sass使用$符号来标识变量，如比如$highlight-color和$sidebar-width。</code></pre><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ol><li>声明单个属性值<br>$higlight-color: #f90;</li><li>声明多个属性值<br>$basic-border: 1px solid black;</li><li>逗号分割多个属性值<br>$plain-font: “Myriad Pro”,Myriad,”Helvetica Neue”,Helvetica,”Liberation Sans”,Arial,sans-serif,sans-serif;</li><li><p>变量的作用域<br>当变量定义在css规则块内，那么该变量只能在此规则块内使用。<br>如果它们出现在任何形式的{…}块中（如@media或者@font-face块）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$nav-color: #F90; // 全局声明</div><div class="line">nav &#123;</div><div class="line">  $width: 100px; // 局部声明</div><div class="line">  width: $width; // 100px</div><div class="line">  color: $nav-color; // #f90</div><div class="line">&#125;</div><div class="line">// 这意味着是你可以在样式表的其他地方定义和使用$width变量，不会对这里造成影响。</div></pre></td></tr></table></figure></li><li><p>在声明变量时，变量值也可以引用其他变量。<br>$highlight-color: #F90;<br>$highlight-border: 1px solid $highlight-color;</p><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 声明变量</div><div class="line">$highlight-color: #F90;</div><div class="line">$highlight-border: 1px solid $highlight-color;</div><div class="line">.selected &#123;</div><div class="line">  border: $highlight-border; // 引用变量</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ol><li>变量名用中划线还是下划线分隔<br>用中划线声明的变量可以使用下划线的方式引用，反之亦然。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$link-color: blue; // 中划线声明</div><div class="line">a &#123;</div><div class="line">  color: $link_color; // 下划线引用</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="将局部变量升级为全局变量"><a href="#将局部变量升级为全局变量" class="headerlink" title="将局部变量升级为全局变量"></a>将局部变量升级为全局变量</h3><pre><code>编译前<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#main &#123;</div><div class="line">  $width: 5em !global;</div><div class="line">  width: $width;</div><div class="line">&#125;</div><div class="line">#sidebar &#123;</div><div class="line">  width: $width;</div><div class="line">&#125;</div></pre></td></tr></table></figure>编译后<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#main &#123; </div><div class="line">width: 5em; </div><div class="line">&#125;</div><div class="line">#sidebar &#123; </div><div class="line">width: 5em; </div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型 (Data Types)"></a>数据类型 (Data Types)</h3><pre><code>Interactive Shell    color: #777 + #777; // color: #eeeeee;如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  $font-size: 12px;</div><div class="line">  $line-height: 30px;</div><div class="line">  font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>数字，1, 2, 13, 10px字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &apos;bar&apos;, baz颜色，blue, #04a3f9, rgba(255,0,0,0.5)布尔型，true, false空值，null数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serifmaps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)</code></pre><h2 id="嵌套CSS-规则"><a href="#嵌套CSS-规则" class="headerlink" title="嵌套CSS 规则"></a>嵌套CSS 规则</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">#content &#123;</div><div class="line">  article &#123;</div><div class="line">h1 &#123; color: #333 &#125;</div><div class="line">p &#123; margin-bottom: 1.4em &#125;</div><div class="line">  &#125;</div><div class="line">  aside &#123; background-color: #EEE &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">#content article h1 &#123; color: #333 &#125;</div><div class="line">#content article p &#123; margin-bottom: 1.4em &#125;</div><div class="line">#content aside &#123; background-color: #EEE &#125;</div></pre></td></tr></table></figure>当你同时要为一个容器元素及其子元素编写特定样式时，这种能力就非常有用了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">#content &#123;</div><div class="line">  background-color: #f5f5f5;</div><div class="line">  aside &#123; background-color: #eee &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">#content &#123; background-color: #f5f5f5 &#125;</div><div class="line">#content aside &#123; background-color: #eee &#125;</div></pre></td></tr></table></figure></code></pre><h3 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;"></a>父选择器的标识符&amp;</h3><pre><code>作用于伪类:hover、:after等等<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">article a &#123;</div><div class="line">  color: blue;</div><div class="line">  &amp;:hover &#123; color: red &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">article a &#123; color: blue &#125;</div><div class="line">article a:hover &#123; color: red &#125;</div></pre></td></tr></table></figure>父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。举例来说，当用户在使用IE浏览器时，你会通过JavaScript在&lt;body&gt;标签上添加一个ie的类名，为这种情况编写特殊的样式如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">#content aside &#123;</div><div class="line">  color: red;</div><div class="line">  body.ie &amp; &#123; color: green &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">#content aside &#123;color: red&#125;;</div><div class="line">body.ie #content aside &#123; color: green &#125;</div></pre></td></tr></table></figure></code></pre><h3 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">nav, aside &#123;</div><div class="line">  a &#123;color: blue&#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">nav a, </div><div class="line">aside a &#123;</div><div class="line">color: blue</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~"></a>子组合选择器和同层组合选择器：&gt;、+和~</h3><pre><code>上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。    可以把它们放在外层选择器后边，或里层选择器前边。&gt;  直接后代选择器+  紧接的相邻兄弟选择器~  同层全体组合选择器</code></pre><h3 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h3><pre><code>除了CSS选择器，属性也可以进行嵌套。嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。</code></pre><ol><li><p>属性的嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">nav &#123;</div><div class="line">  border: &#123;</div><div class="line">  style: solid;</div><div class="line">  width: 1px;</div><div class="line">  color: #ccc;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">nav &#123;</div><div class="line">  border-style: solid;</div><div class="line">  border-width: 1px;</div><div class="line">  border-color: #ccc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>对于属性的缩写形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">nav &#123;</div><div class="line">  border: 1px solid #ccc &#123;</div><div class="line">  left: 0px;</div><div class="line">  right: 0px;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">nav &#123;</div><div class="line">  border: 1px solid #ccc;</div><div class="line">  border-left: 0px;</div><div class="line">  border-right: 0px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件"></a>导入SASS文件</h2><pre><code>css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀。@import &quot;sidebar&quot;;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。</code></pre><h3 id="使用SASS部分文件"><a href="#使用SASS部分文件" class="headerlink" title="使用SASS部分文件"></a>使用SASS部分文件</h3><pre><code>sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">你想导入themes/_night-sky.scss这个局部文件里的变量，</div><div class="line">你只需在样式表中写@import &quot;themes/night-sky&quot;;。</div></pre></td></tr></table></figure></code></pre><h3 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值"></a>默认变量值</h3><pre><code>你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。    使用sass的!default标签可以实现这个目的。对于通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值，非常有用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$fancybox-width: 400px !default;</div><div class="line">.fancybox &#123;</div><div class="line">width: $fancybox-width; // 400px</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h3><pre><code>跟原生的css不同，sass允许@import命令写在css规则内。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// _blue-theme.scss</div><div class="line">aside &#123;</div><div class="line">  background: blue;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line">// 在主scss文件中index.scss</div><div class="line">.blue-theme &#123;@import &quot;blue-theme&quot;&#125;</div><div class="line">// 类似于编译前</div><div class="line">.blue-theme &#123;</div><div class="line">aside &#123;</div><div class="line">background: blue;</div><div class="line">color: #fff;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">.blue-theme aside &#123;</div><div class="line">background: blue;</div><div class="line">color: #fff;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入"></a>原生的CSS导入</h3><pre><code>下列3种情况使用原生CSS@import，浏览器解析css时的额外下载。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">被导入文件的名字以.css结尾；</div><div class="line">被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</div><div class="line">被导入文件的名字是CSS的url()值。</div></pre></td></tr></table></figure></code></pre><h2 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释"></a>静默注释</h2><pre><code>sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  color: #333; // 这种注释内容不会出现在生成的css文件中(静默注释)</div><div class="line">  padding: 0; /* 这种注释内容会出现在生成的css文件中 */</div><div class="line">&#125;</div></pre></td></tr></table></figure>当注释出现在原生css不允许的地方，如在css属性或选择器中，sass将不知如何将其生成到对应css文件中的相应位置，于是这些注释被抹掉。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  color /* 这块注释内容不会出现在生成的css中 */: #333;</div><div class="line">  padding: 1; /* 这块注释内容也不会出现在生成的css中 */ 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><pre><code>混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。你可以通过sass的混合器实现大段样式的重用。混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 声明混合器</div><div class="line">@mixin rounded-corners &#123;</div><div class="line">  -moz-border-radius: 5px;</div><div class="line">  -webkit-border-radius: 5px;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div><div class="line">// 使用混合器</div><div class="line">div p &#123;</div><div class="line">color: red;</div><div class="line">@include rounded-corners;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="何时使用混合器"><a href="#何时使用混合器" class="headerlink" title="何时使用混合器"></a>何时使用混合器</h3><pre><code>一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-cornersfancy-font或者no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。</code></pre><h3 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则"></a>混合器中的CSS规则</h3><pre><code>混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 定义一个嵌套css混合</div><div class="line">@mixin no-bullets &#123;</div><div class="line">  list-style: none;</div><div class="line">  li &#123;</div><div class="line">list-style-image: none;</div><div class="line">list-style-type: none;</div><div class="line">margin-left: 0px;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 使用混合</div><div class="line">ul.plain &#123;</div><div class="line">  color: #444;</div><div class="line">  @include no-bullets;</div><div class="line">&#125;</div></pre></td></tr></table></figure>编译后<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ul.plain &#123;</div><div class="line">  color: #444;</div><div class="line">  list-style: none;</div><div class="line">&#125;</div><div class="line">ul.plain li &#123;</div><div class="line">  list-style-image: none;</div><div class="line">  list-style-type: none;</div><div class="line">  margin-left: 0px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参"></a>给混合器传参</h3><pre><code>可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。// 声明带参数的混合<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@mixin link-colors($normal, $hover, $visited) &#123;</div><div class="line">  color: $normal;</div><div class="line">  &amp;:hover &#123; color: $hover; &#125;</div><div class="line">  &amp;:visited &#123; color: $visited; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>// 使用带参数的混合<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 使用1</div><div class="line">p a &#123;</div><div class="line">@include link-colors(red, blue, white);</div><div class="line">&#125;</div><div class="line">// 使用2（好处是表明每个参数的意思和顺序）</div><div class="line">a &#123;</div><div class="line">@include link-colors(</div><div class="line">  $normal: blue,</div><div class="line">  $visited: green,</div><div class="line">  $hover: red</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>编译后<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p a &#123; color: blue; &#125;</div><div class="line">p a:hover &#123; color: red; &#125;</div><div class="line">p a:visited &#123; color: green; &#125;</div></pre></td></tr></table></figure></code></pre><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 默认都使用$normal的值</div><div class="line">@mixin link-colors(</div><div class="line">$normal,</div><div class="line">$hover: $normal,</div><div class="line">$visited: $normal</div><div class="line">  )</div><div class="line">&#123;</div><div class="line">  color: $normal;</div><div class="line">  &amp;:hover &#123; color: $hover; &#125;</div><div class="line">  &amp;:visited &#123; color: $visited; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>使用混合<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@include link-colors(red)</div><div class="line">编译后</div><div class="line">p a &#123;</div><div class="line">color: red; </div><div class="line">&#125;</div><div class="line">p a:hover &#123;</div><div class="line">color: red; </div><div class="line">&#125;</div><div class="line">p a:visited &#123;</div><div class="line">color: red; </div><div class="line">&#125;</div></pre></td></tr></table></figure>使用混合<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@include link-colors(red, blue, white)</div><div class="line">编译后</div><div class="line">p a &#123;</div><div class="line">color: red; </div><div class="line">&#125;</div><div class="line">p a:hover &#123;</div><div class="line">color: blue; </div><div class="line">&#125;</div><div class="line">p a:visited &#123;</div><div class="line">color: white; </div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="使用选择器继承来精简CSS"><a href="#使用选择器继承来精简CSS" class="headerlink" title="使用选择器继承来精简CSS"></a>使用选择器继承来精简CSS</h2><pre><code>继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。</code></pre><ol><li><p>选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现。<br>编译前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//通过选择器继承继承样式</div><div class="line">.error &#123;</div><div class="line">  border: 1px solid red;</div><div class="line">  background-color: #fdd;</div><div class="line">&#125;</div><div class="line">.seriousError &#123;</div><div class="line">  @extend .error;</div><div class="line">  border-width: 3px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.error, .seriousError &#123;</div><div class="line">  border: 1px solid red;</div><div class="line">  background-color: #fdd; </div><div class="line">&#125;</div><div class="line">.seriousError &#123;</div><div class="line">  border-width: 3px; </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>.seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//.seriousError从.error继承样式</div><div class="line">.error a&#123;  //应用到.seriousError a</div><div class="line">  color: red;</div><div class="line">  font-weight: 100;</div><div class="line">&#125;</div><div class="line">h1.error &#123; //应用到hl.seriousError</div><div class="line">  font-size: 1.2rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="何时使用继承"><a href="#何时使用继承" class="headerlink" title="何时使用继承"></a>何时使用继承</h3><pre><code>混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。当一个元素拥有的类（比如说.seriousError）表明它属于另一个类（比如说.error），这时使用继承再合适不过了。综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error.seriousError都会继承其中的样式。</code></pre><h3 id="继承的高级用法"><a href="#继承的高级用法" class="headerlink" title="继承的高级用法"></a>继承的高级用法</h3><pre><code>接下来的这段代码定义了一个名为disabled的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现编译前<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a &#123;</div><div class="line">background: #fff;</div><div class="line">&#125;</div><div class="line">.disabled &#123;</div><div class="line">  color: gray;</div><div class="line">  @extend a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>编译后<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a, .disabled &#123;</div><div class="line">  background: #fff; </div><div class="line">&#125;</div><div class="line"></div><div class="line">.disabled &#123;</div><div class="line">  color: gray; </div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h3 id="继承的工作细节"><a href="#继承的工作细节" class="headerlink" title="继承的工作细节"></a>继承的工作细节</h3><pre><code>@extend背后最基本的想法是，如果.seriousError @extend .error， 那么样式表中的任何一处.error都用.error.seriousError这一选择器组进行替换。@extend的优点    跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。    继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。</code></pre><h3 id="使用继承的最佳实践"><a href="#使用继承的最佳实践" class="headerlink" title="使用继承的最佳实践"></a>使用继承的最佳实践</h3><pre><code>通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。</code></pre><h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><ol><li>占位符选择器 %foo (Placeholder Selectors: %foo)</li><li>字符串 (Strings)<br>  有引号字符串 与 无引号字符串 (unquoted strings)</li><li>数组 (Lists)<br>  nth 函数可以直接访问数组中的某一项；<br>  join 函数可以将多个数组连接在一起；<br>  append 函数可以在数组中添加新值；<br>  @each 指令能够遍历数组中的每一项。</li><li>Maps<br>  $map: (key1: value1, key2: value2, key3: value3);</li><li>颜色 (Colors)</li><li><p>运算 (Operations)<br>所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。<br>SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。<br>字符串运算 (String Operations)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  cursor: e + -resize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>布尔运算 (Boolean Operations)<br>SassScript 支持布尔型的 and or 以及 not 运算。</p></li><li>圆括号 (Parentheses)<br>  width: 1em + (2em * 3);</li><li>插值语句 #{} (Interpolation: #{})<br>  $attr: border;<br>  #{$attr}-color: blue;</li><li>&amp; in SassScript<br> 父选择器标识符</li><li>变量定义 !default (Variable Defaults: !default)</li><li>@import 并可以嵌套<br> 导入其他scss文件</li><li>@extend</li><li><p>控制指令 (Control Directives)<br>@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。<br> @if 1 + 1 == 2 { border: 1px solid; }<br> @if 5 &lt; 3 { border: 2px dotted; }<br>@for</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@for $i from 1 through 3 &#123;</div><div class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@each</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@each $animal in puma, sea-slug, egret, salamander &#123;</div><div class="line">  .#&#123;$animal&#125;-icon &#123;</div><div class="line">background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@while</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$i: 6;</div><div class="line">@while $i &gt; 0 &#123;</div><div class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</div><div class="line">  $i: $i - 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>变量（声明及使用）：    可以声明全局和局部变量。声明方法：$var-name嵌套CSS规则：    article a {      color: blue;      &amp;:hover { color: red } // 父选择器的标识符&amp;，此时代表 a 元素    }导入SASS文件：    在一个scss文件同导入其他scss文件。导入方法：@import &quot;sidebar&quot;;静默注释：    在scss文件中有注释，编译之后注释被抹掉。注释方法为：// 混合器：    混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。    定义混合器使用@mixin标识符。    使用混合器@include。        使用选择器继承来精简CSS：    继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。    这个通过@extend语法实现。    </code></pre><blockquote><p>   参考文档：<br>    <a href="https://www.sass.hk" target="_blank" rel="external">Sass中文网</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Sass是在CSS语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。&lt;/p&gt;
&lt;h2 id=&quot;常用的指令&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="Sass" scheme="https://fanerge.github.io/tags/Sass/"/>
    
      <category term="web" scheme="https://fanerge.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-搭建项目</title>
    <link href="https://fanerge.github.io/2017/09/19/koa%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://fanerge.github.io/2017/09/19/koa学习-搭建项目/</id>
    <published>2017-09-19T11:41:00.000Z</published>
    <updated>2017-09-19T11:48:39.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="external">cookies</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;   参考文档：&lt;br&gt;    &lt;a href=&quot;https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-debug</title>
    <link href="https://fanerge.github.io/2017/09/19/koa%E5%AD%A6%E4%B9%A0-debug/"/>
    <id>https://fanerge.github.io/2017/09/19/koa学习-debug/</id>
    <published>2017-09-19T11:38:51.000Z</published>
    <updated>2017-09-19T11:47:58.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><pre><code>node环境 8.x +chrome 60+index.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;)</div><div class="line">const app = new Koa()</div><div class="line"></div><div class="line">app.use( async ( ctx ) =&gt; &#123;</div><div class="line">  ctx.body = &apos;hello koa2&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(3000, () =&gt; &#123;</div><div class="line">  console.log(&apos;[demo] start-quick is starting at port 3000&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></code></pre><h3 id="进行调试"><a href="#进行调试" class="headerlink" title="进行调试"></a>进行调试</h3><pre><code>node --inspect index.js在控制台上点击node调试，会弹出新窗口，此时就可以进入调试--如打断点。</code></pre><blockquote><p>   参考文档：<br>        <a href="https://chenshenhai.github.io/koa2-note/note/debug/info.html" target="_blank" rel="external">debug</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;node环境 8.x +
chrome 60+
index.js
&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-测试</title>
    <link href="https://fanerge.github.io/2017/09/18/koa%E5%AD%A6%E4%B9%A0-%E6%B5%8B%E8%AF%95/"/>
    <id>https://fanerge.github.io/2017/09/18/koa学习-测试/</id>
    <published>2017-09-18T14:21:06.000Z</published>
    <updated>2017-09-18T14:56:31.296Z</updated>
    
    <content type="html"><![CDATA[<p>mocha 模块是测试框架<br>chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2<br>supertest 模块是http请求测试库，用来请求API接口</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code>所需测试demo<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">const koa = require(&apos;koa&apos;);</div><div class="line">const app = new koa();</div><div class="line"></div><div class="line">const server = async (ctx, next) =&gt; &#123;</div><div class="line">let result = &#123;</div><div class="line">success: true,</div><div class="line">data: null</div><div class="line">&#125;;</div><div class="line">if (ctx.method === &apos;GET&apos;) &#123;</div><div class="line">if (ctx.url === &apos;/getString.json&apos;) &#123;</div><div class="line">result.data = &apos;this is string data&apos;;</div><div class="line">&#125; else if (ctx.url === &apos;/getNumber.json&apos;)&#123;</div><div class="line">result.data = 123456;    </div><div class="line">&#125; else &#123;</div><div class="line">result.success = false;</div><div class="line">&#125;</div><div class="line">ctx.body = result;</div><div class="line">next &amp;&amp; next();</div><div class="line">&#125; else if (ctx.method === &apos;POST&apos;) &#123;</div><div class="line">if (ctx.url === &apos;/postData.json&apos;) &#123;</div><div class="line">result.data = &apos;ok&apos;;</div><div class="line">&#125; else &#123;</div><div class="line">result.success = false;</div><div class="line">&#125;</div><div class="line">ctx.body = result;</div><div class="line">next &amp;&amp; next();</div><div class="line">&#125; else &#123;</div><div class="line">ctx.body = &apos;hello world&apos;;</div><div class="line">next &amp;&amp; next();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">app.use(server);</div><div class="line"></div><div class="line">module.exports = app;</div><div class="line"></div><div class="line">app.listen(3004, () =&gt; &#123;</div><div class="line">console.log(&apos;[demo] test-unit is starting at port 3004&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const supertest = require(&apos;supertest&apos;)</div><div class="line">const chai = require(&apos;chai&apos;)</div><div class="line">const app = require(&apos;./../index&apos;)</div><div class="line"></div><div class="line">const expect = chai.expect</div><div class="line">const request = supertest( app.listen() )</div><div class="line"></div><div class="line">// 测试套件/组</div><div class="line">describe( &apos;开始测试demo的GET请求&apos;, ( ) =&gt; &#123;</div><div class="line"></div><div class="line">  // 测试用例</div><div class="line">  it(&apos;测试/getString.json请求&apos;, ( done ) =&gt; &#123;</div><div class="line">  request</div><div class="line">.get(&apos;/getString.json&apos;)</div><div class="line">.expect(200)</div><div class="line">.end(( err, res ) =&gt; &#123;</div><div class="line">// 断言判断结果是否为object类型</div><div class="line">expect(res.body).to.be.an(&apos;object&apos;)</div><div class="line">expect(res.body.success).to.be.an(&apos;boolean&apos;)</div><div class="line">expect(res.body.data).to.be.an(&apos;string&apos;)</div><div class="line">done()</div><div class="line">&#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></code></pre><blockquote><p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-jsonp" target="_blank" rel="external">koa-jsonp</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mocha 模块是测试框架&lt;br&gt;chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2&lt;br&gt;supertest 模块是http请求测试库，用来请求API接口&lt;/p&gt;
&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
</feed>
