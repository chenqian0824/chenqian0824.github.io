<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2017-09-21T14:03:32.053Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MVC学习</title>
    <link href="https://fanerge.github.io/2017/09/21/MVC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/21/MVC学习/</id>
    <published>2017-09-21T12:22:26.000Z</published>
    <updated>2017-09-21T14:03:32.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><pre><code>MVC的全名是Model View Controller，是模型（model）--视图（view）--控制器（controller）的缩写，是一种软件设计典范。
M（数据模型）：比如你设计一个User对象，包含username和password属性，它就是一个简单的M。
M是指业务模型，V是指用户界面，C则是控制器。
</code></pre><h2 id="在web开发中"><a href="#在web开发中" class="headerlink" title="在web开发中"></a>在web开发中</h2><pre><code>V即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。
    在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。
M即Model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。
    被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。
C即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，
    控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。
它们三者的关系
</code></pre><p><img src="http://images2015.cnblogs.com/blog/811883/201704/811883-20170423150019101-1710764799.jpg" alt="mvc关系图"><br>    用户首先在界面中进行人机交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型，模型可以与数据库进行交互，进行增删改查操作，完成之后，根据业务的逻辑选择相应的视图进行显示，此时用户获得此次交互的反馈信息，用户可以进行下一步交互，如此循环。</p>
<h3 id="每层主要的功能"><a href="#每层主要的功能" class="headerlink" title="每层主要的功能"></a>每层主要的功能</h3><pre><code>视图（View）：用户界面
控制器（Controller）：业务逻辑
模型（Model）：数据保存
</code></pre><p><img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt="各部分之间的通信方式如下"><br>    各部分之间的通信方式如下。<br>    View 传送指令到 Controller<br>    Controller 完成业务逻辑后，要求 Model 改变状态<br>    Model 将新的数据发送到 View，用户得到反馈</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/diyunfei/p/6752618.html" target="_blank" rel="external">MVC简介</a>    </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;MVC的全名是Model View Controller，是模型（model）--视图（view）--控制器
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="MVC" scheme="https://fanerge.github.io/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Sass学习</title>
    <link href="https://fanerge.github.io/2017/09/20/Sass%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/20/Sass学习/</id>
    <published>2017-09-20T11:41:05.000Z</published>
    <updated>2017-09-20T15:05:57.962Z</updated>
    
    <content type="html"><![CDATA[<p>Sass是在CSS语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。</p>
<h2 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h2><pre><code>在命令行中运行 Sass
    sass input.scss output.css
监视单个 Sass 文件，每次修改并保存时自动编译
    sass --watch input.scss:output.css
监视整个文件夹
    sass --watch app/scss:public/stylesheets
开启debug信息
    sass --watch input.scss:output.css --debug-info
选择编译格式并添加调试map
    sass --watch input.scss:output.css --style expanded --sourcemap
编译添加调试map
    sass --watch input.scss:output.css --sourcemap
编译格式
    sass --watch input.scss:output.css --style compact
</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><pre><code>sass让人们受益的一个重要特性就是它为css引入了变量。你可以把反复使用的css属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。
sass使用$符号来标识变量，如比如$highlight-color和$sidebar-width。
</code></pre><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ol>
<li>声明单个属性值<br>$higlight-color: #f90;</li>
<li>声明多个属性值<br>$basic-border: 1px solid black;</li>
<li>逗号分割多个属性值<br>$plain-font: “Myriad Pro”,Myriad,”Helvetica Neue”,Helvetica,”Liberation Sans”,Arial,sans-serif,sans-serif;</li>
<li><p>变量的作用域<br>当变量定义在css规则块内，那么该变量只能在此规则块内使用。<br>如果它们出现在任何形式的{…}块中（如@media或者@font-face块）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$nav-color: #F90; // 全局声明</div><div class="line">nav &#123;</div><div class="line">  $width: 100px; // 局部声明</div><div class="line">  width: $width; // 100px</div><div class="line">  color: $nav-color; // #f90</div><div class="line">&#125;</div><div class="line">// 这意味着是你可以在样式表的其他地方定义和使用$width变量，不会对这里造成影响。</div></pre></td></tr></table></figure>
</li>
<li><p>在声明变量时，变量值也可以引用其他变量。<br>$highlight-color: #F90;<br>$highlight-border: 1px solid $highlight-color;</p>
<h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 声明变量</div><div class="line">$highlight-color: #F90;</div><div class="line">$highlight-border: 1px solid $highlight-color;</div><div class="line">.selected &#123;</div><div class="line">  border: $highlight-border; // 引用变量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ol>
<li>变量名用中划线还是下划线分隔<br>用中划线声明的变量可以使用下划线的方式引用，反之亦然。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$link-color: blue; // 中划线声明</div><div class="line">a &#123;</div><div class="line">  color: $link_color; // 下划线引用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="将局部变量升级为全局变量"><a href="#将局部变量升级为全局变量" class="headerlink" title="将局部变量升级为全局变量"></a>将局部变量升级为全局变量</h3><pre><code>编译前
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#main &#123;</div><div class="line">  $width: 5em !global;</div><div class="line">  width: $width;</div><div class="line">&#125;</div><div class="line">#sidebar &#123;</div><div class="line">  width: $width;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#main &#123; </div><div class="line">	width: 5em; </div><div class="line">&#125;</div><div class="line">#sidebar &#123; </div><div class="line">	width: 5em; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型 (Data Types)"></a>数据类型 (Data Types)</h3><pre><code>Interactive Shell
    color: #777 + #777; // color: #eeeeee;
如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  $font-size: 12px;</div><div class="line">  $line-height: 30px;</div><div class="line">  font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

数字，1, 2, 13, 10px
字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &apos;bar&apos;, baz
颜色，blue, #04a3f9, rgba(255,0,0,0.5)
布尔型，true, false
空值，null
数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)
</code></pre><h2 id="嵌套CSS-规则"><a href="#嵌套CSS-规则" class="headerlink" title="嵌套CSS 规则"></a>嵌套CSS 规则</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">#content &#123;</div><div class="line">  article &#123;</div><div class="line">	h1 &#123; color: #333 &#125;</div><div class="line">	p &#123; margin-bottom: 1.4em &#125;</div><div class="line">  &#125;</div><div class="line">  aside &#123; background-color: #EEE &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">#content article h1 &#123; color: #333 &#125;</div><div class="line">#content article p &#123; margin-bottom: 1.4em &#125;</div><div class="line">#content aside &#123; background-color: #EEE &#125;</div></pre></td></tr></table></figure>

当你同时要为一个容器元素及其子元素编写特定样式时，这种能力就非常有用了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">#content &#123;</div><div class="line">  background-color: #f5f5f5;</div><div class="line">  aside &#123; background-color: #eee &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">#content &#123; background-color: #f5f5f5 &#125;</div><div class="line">#content aside &#123; background-color: #eee &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;"></a>父选择器的标识符&amp;</h3><pre><code>作用于伪类:hover、:after等等
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">article a &#123;</div><div class="line">  color: blue;</div><div class="line">  &amp;:hover &#123; color: red &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">article a &#123; color: blue &#125;</div><div class="line">article a:hover &#123; color: red &#125;</div></pre></td></tr></table></figure>

父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。
举例来说，当用户在使用IE浏览器时，你会通过JavaScript在&lt;body&gt;标签上添加一个ie的类名，为这种情况编写特殊的样式如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">#content aside &#123;</div><div class="line">  color: red;</div><div class="line">  body.ie &amp; &#123; color: green &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">#content aside &#123;color: red&#125;;</div><div class="line">body.ie #content aside &#123; color: green &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">nav, aside &#123;</div><div class="line">  a &#123;color: blue&#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">nav a, </div><div class="line">aside a &#123;</div><div class="line">	color: blue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~"></a>子组合选择器和同层组合选择器：&gt;、+和~</h3><pre><code>上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。    
可以把它们放在外层选择器后边，或里层选择器前边。
&gt;  直接后代选择器
+  紧接的相邻兄弟选择器
~  同层全体组合选择器
</code></pre><h3 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h3><pre><code>除了CSS选择器，属性也可以进行嵌套。
嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。
</code></pre><ol>
<li><p>属性的嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">nav &#123;</div><div class="line">  border: &#123;</div><div class="line">  style: solid;</div><div class="line">  width: 1px;</div><div class="line">  color: #ccc;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">nav &#123;</div><div class="line">  border-style: solid;</div><div class="line">  border-width: 1px;</div><div class="line">  border-color: #ccc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于属性的缩写形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 编译前</div><div class="line">nav &#123;</div><div class="line">  border: 1px solid #ccc &#123;</div><div class="line">  left: 0px;</div><div class="line">  right: 0px;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">nav &#123;</div><div class="line">  border: 1px solid #ccc;</div><div class="line">  border-left: 0px;</div><div class="line">  border-right: 0px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件"></a>导入SASS文件</h2><pre><code>css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。
使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀。
@import &quot;sidebar&quot;;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。
</code></pre><h3 id="使用SASS部分文件"><a href="#使用SASS部分文件" class="headerlink" title="使用SASS部分文件"></a>使用SASS部分文件</h3><pre><code>sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">你想导入themes/_night-sky.scss这个局部文件里的变量，</div><div class="line">你只需在样式表中写@import &quot;themes/night-sky&quot;;。</div></pre></td></tr></table></figure>
</code></pre><h3 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值"></a>默认变量值</h3><pre><code>你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。
如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。    
使用sass的!default标签可以实现这个目的。
对于通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值，非常有用。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$fancybox-width: 400px !default;</div><div class="line">.fancybox &#123;</div><div class="line">	width: $fancybox-width; // 400px</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h3><pre><code>跟原生的css不同，sass允许@import命令写在css规则内。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// _blue-theme.scss</div><div class="line">aside &#123;</div><div class="line">  background: blue;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line">// 在主scss文件中index.scss</div><div class="line">.blue-theme &#123;@import &quot;blue-theme&quot;&#125;	</div><div class="line">// 类似于编译前</div><div class="line">.blue-theme &#123;</div><div class="line">	aside &#123;</div><div class="line">		background: blue;</div><div class="line">		color: #fff;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 编译后</div><div class="line">.blue-theme aside &#123;</div><div class="line">	background: blue;</div><div class="line">	color: #fff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入"></a>原生的CSS导入</h3><pre><code>下列3种情况使用原生CSS@import，浏览器解析css时的额外下载。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">被导入文件的名字以.css结尾；</div><div class="line">被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</div><div class="line">被导入文件的名字是CSS的url()值。</div></pre></td></tr></table></figure>
</code></pre><h2 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释"></a>静默注释</h2><pre><code>sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，
即静默注释，其内容不会出现在生成的css文件中。
将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  color: #333; // 这种注释内容不会出现在生成的css文件中(静默注释)</div><div class="line">  padding: 0; /* 这种注释内容会出现在生成的css文件中 */</div><div class="line">&#125;</div></pre></td></tr></table></figure>

当注释出现在原生css不允许的地方，如在css属性或选择器中，sass将不知如何将其生成到对应css文件中的相应位置，于是这些注释被抹掉。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  color /* 这块注释内容不会出现在生成的css中 */: #333;</div><div class="line">  padding: 1; /* 这块注释内容也不会出现在生成的css中 */ 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><pre><code>混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。
你可以通过sass的混合器实现大段样式的重用。
混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 声明混合器</div><div class="line">@mixin rounded-corners &#123;</div><div class="line">  -moz-border-radius: 5px;</div><div class="line">  -webkit-border-radius: 5px;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div><div class="line">// 使用混合器</div><div class="line">div p &#123;</div><div class="line">	color: red;</div><div class="line">	@include rounded-corners;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="何时使用混合器"><a href="#何时使用混合器" class="headerlink" title="何时使用混合器"></a>何时使用混合器</h3><pre><code>一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-cornersfancy-font或者no-bullets，那么往往能够构造一个合适的混合器。
如果你找不到，这时候构造一个混合器可能并不合适。
</code></pre><h3 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则"></a>混合器中的CSS规则</h3><pre><code>混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 定义一个嵌套css混合</div><div class="line">@mixin no-bullets &#123;</div><div class="line">  list-style: none;</div><div class="line">  li &#123;</div><div class="line">	list-style-image: none;</div><div class="line">	list-style-type: none;</div><div class="line">	margin-left: 0px;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 使用混合</div><div class="line">ul.plain &#123;</div><div class="line">  color: #444;</div><div class="line">  @include no-bullets;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ul.plain &#123;</div><div class="line">  color: #444;</div><div class="line">  list-style: none;</div><div class="line">&#125;</div><div class="line">ul.plain li &#123;</div><div class="line">  list-style-image: none;</div><div class="line">  list-style-type: none;</div><div class="line">  margin-left: 0px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参"></a>给混合器传参</h3><pre><code>可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。
// 声明带参数的混合
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@mixin link-colors($normal, $hover, $visited) &#123;</div><div class="line">  color: $normal;</div><div class="line">  &amp;:hover &#123; color: $hover; &#125;</div><div class="line">  &amp;:visited &#123; color: $visited; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

// 使用带参数的混合
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 使用1</div><div class="line">p a &#123;</div><div class="line">	@include link-colors(red, blue, white);</div><div class="line">&#125;</div><div class="line">// 使用2（好处是表明每个参数的意思和顺序）</div><div class="line">a &#123;</div><div class="line">	@include link-colors(</div><div class="line">	  $normal: blue,</div><div class="line">	  $visited: green,</div><div class="line">	  $hover: red</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p a &#123; color: blue; &#125;</div><div class="line">p a:hover &#123; color: red; &#125;</div><div class="line">p a:visited &#123; color: green; &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 默认都使用$normal的值</div><div class="line">@mixin link-colors(</div><div class="line">	$normal,</div><div class="line">	$hover: $normal,</div><div class="line">	$visited: $normal</div><div class="line">  )</div><div class="line">&#123;</div><div class="line">  color: $normal;</div><div class="line">  &amp;:hover &#123; color: $hover; &#125;</div><div class="line">  &amp;:visited &#123; color: $visited; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

使用混合
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@include link-colors(red)</div><div class="line">编译后</div><div class="line">p a &#123;</div><div class="line">	color: red; </div><div class="line">&#125;</div><div class="line">p a:hover &#123;</div><div class="line">	color: red; </div><div class="line">&#125;</div><div class="line">p a:visited &#123;</div><div class="line">	color: red; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

使用混合
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@include link-colors(red, blue, white)</div><div class="line">编译后</div><div class="line">p a &#123;</div><div class="line">	color: red; </div><div class="line">&#125;</div><div class="line">p a:hover &#123;</div><div class="line">	color: blue; </div><div class="line">&#125;</div><div class="line">p a:visited &#123;</div><div class="line">	color: white; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="使用选择器继承来精简CSS"><a href="#使用选择器继承来精简CSS" class="headerlink" title="使用选择器继承来精简CSS"></a>使用选择器继承来精简CSS</h2><pre><code>继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。
</code></pre><ol>
<li><p>选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现。<br>编译前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//通过选择器继承继承样式</div><div class="line">.error &#123;</div><div class="line">  border: 1px solid red;</div><div class="line">  background-color: #fdd;</div><div class="line">&#125;</div><div class="line">.seriousError &#123;</div><div class="line">  @extend .error;</div><div class="line">  border-width: 3px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.error, .seriousError &#123;</div><div class="line">  border: 1px solid red;</div><div class="line">  background-color: #fdd; </div><div class="line">&#125;</div><div class="line">.seriousError &#123;</div><div class="line">  border-width: 3px; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>.seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//.seriousError从.error继承样式</div><div class="line">.error a&#123;  //应用到.seriousError a</div><div class="line">  color: red;</div><div class="line">  font-weight: 100;</div><div class="line">&#125;</div><div class="line">h1.error &#123; //应用到hl.seriousError</div><div class="line">  font-size: 1.2rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="何时使用继承"><a href="#何时使用继承" class="headerlink" title="何时使用继承"></a>何时使用继承</h3><pre><code>混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。
当一个元素拥有的类（比如说.seriousError）表明它属于另一个类（比如说.error），这时使用继承再合适不过了。
综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。
更重要的是无论你在样式表的哪里使用.error.seriousError都会继承其中的样式。
</code></pre><h3 id="继承的高级用法"><a href="#继承的高级用法" class="headerlink" title="继承的高级用法"></a>继承的高级用法</h3><pre><code>接下来的这段代码定义了一个名为disabled的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现
编译前
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a &#123;</div><div class="line">	background: #fff;</div><div class="line">&#125;</div><div class="line">.disabled &#123;</div><div class="line">  color: gray;</div><div class="line">  @extend a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">	a, .disabled &#123;</div><div class="line">	  background: #fff; </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	.disabled &#123;</div><div class="line">	  color: gray; </div><div class="line">	&#125;</div><div class="line">	```	</div><div class="line">###	继承的工作细节</div><div class="line">	@extend背后最基本的想法是，如果.seriousError @extend .error， 那么样式表中的任何一处.error都用.error.seriousError这一选择器组进行替换。</div><div class="line">	@extend的优点</div><div class="line">		跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。</div><div class="line">		继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。</div><div class="line">###	使用继承的最佳实践</div><div class="line">	通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。</div><div class="line">	避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。</div><div class="line">##	小知识点</div><div class="line">1.	占位符选择器 %foo (Placeholder Selectors: %foo)</div><div class="line">2.	字符串 (Strings)</div><div class="line">		有引号字符串 与 无引号字符串 (unquoted strings)</div><div class="line">3.	数组 (Lists)</div><div class="line">		nth 函数可以直接访问数组中的某一项；</div><div class="line">		join 函数可以将多个数组连接在一起；</div><div class="line">		append 函数可以在数组中添加新值；</div><div class="line">		@each 指令能够遍历数组中的每一项。</div><div class="line">4.	Maps</div><div class="line">		$map: (key1: value1, key2: value2, key3: value3);</div><div class="line">5.	颜色 (Colors)</div><div class="line">6.	运算 (Operations)</div><div class="line">	所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。</div><div class="line">	SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。</div><div class="line">	字符串运算 (String Operations)</div></pre></td></tr></table></figure>

    p {
      cursor: e + -resize;
    }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">7.	布尔运算 (Boolean Operations)</div><div class="line">	SassScript 支持布尔型的 and or 以及 not 运算。</div><div class="line">8.	圆括号 (Parentheses)</div><div class="line">		width: 1em + (2em * 3);</div><div class="line">9.	插值语句 #&#123;&#125; (Interpolation: #&#123;&#125;)</div><div class="line">		$attr: border;</div><div class="line">		#&#123;$attr&#125;-color: blue;</div><div class="line">10.	&amp; in SassScript</div><div class="line">		父选择器标识符</div><div class="line">11.	变量定义 !default (Variable Defaults: !default)</div><div class="line">12.	@import 并可以嵌套</div><div class="line">		导入其他scss文件</div><div class="line">13.	@extend</div><div class="line">14.	控制指令 (Control Directives)</div><div class="line">	@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。</div><div class="line">		@if 1 + 1 == 2 &#123; border: 1px solid; &#125;</div><div class="line">		@if 5 &lt; 3 &#123; border: 2px dotted; &#125;</div><div class="line">	@for</div></pre></td></tr></table></figure>

    @for $i from 1 through 3 {
      .item-#{$i} { width: 2em * $i; }
    }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@each</div></pre></td></tr></table></figure>

    @each $animal in puma, sea-slug, egret, salamander {
      .#{$animal}-icon {
        background-image: url(&apos;/images/#{$animal}.png&apos;);
      }
    }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@while</div></pre></td></tr></table></figure>

    $i: 6;
    @while $i &gt; 0 {
      .item-#{$i} { width: 2em * $i; }
      $i: $i - 2;
    }
    ```
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>变量（声明及使用）：
    可以声明全局和局部变量。声明方法：$var-name
嵌套CSS规则：
    article a {
      color: blue;
      &amp;:hover { color: red } // 父选择器的标识符&amp;，此时代表 a 元素
    }
导入SASS文件：
    在一个scss文件同导入其他scss文件。导入方法：@import &quot;sidebar&quot;;
静默注释：
    在scss文件中有注释，编译之后注释被抹掉。注释方法为：// 
混合器：
    混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。
    定义混合器使用@mixin标识符。
    使用混合器@include。        
使用选择器继承来精简CSS：
    继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。
    这个通过@extend语法实现。    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://www.sass.hk" target="_blank" rel="external">Sass中文网</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sass是在CSS语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。&lt;/p&gt;
&lt;h2 id=&quot;常用的指令&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
      <category term="Sass" scheme="https://fanerge.github.io/tags/Sass/"/>
    
      <category term="web" scheme="https://fanerge.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-搭建项目</title>
    <link href="https://fanerge.github.io/2017/09/19/koa%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://fanerge.github.io/2017/09/19/koa学习-搭建项目/</id>
    <published>2017-09-19T11:41:00.000Z</published>
    <updated>2017-09-19T11:48:39.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="external">cookies</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   参考文档：&lt;br&gt;    &lt;a href=&quot;https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-debug</title>
    <link href="https://fanerge.github.io/2017/09/19/koa%E5%AD%A6%E4%B9%A0-debug/"/>
    <id>https://fanerge.github.io/2017/09/19/koa学习-debug/</id>
    <published>2017-09-19T11:38:51.000Z</published>
    <updated>2017-09-19T11:47:58.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><pre><code>node环境 8.x +
chrome 60+
index.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;)</div><div class="line">const app = new Koa()</div><div class="line"></div><div class="line">app.use( async ( ctx ) =&gt; &#123;</div><div class="line">  ctx.body = &apos;hello koa2&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(3000, () =&gt; &#123;</div><div class="line">  console.log(&apos;[demo] start-quick is starting at port 3000&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h3 id="进行调试"><a href="#进行调试" class="headerlink" title="进行调试"></a>进行调试</h3><pre><code>node --inspect index.js
在控制台上点击node调试，会弹出新窗口，此时就可以进入调试--如打断点。
</code></pre><blockquote>
<p>   参考文档：<br>        <a href="https://chenshenhai.github.io/koa2-note/note/debug/info.html" target="_blank" rel="external">debug</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;node环境 8.x +
chrome 60+
index.js
&lt;figure class=&quot;highlight plai
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-测试</title>
    <link href="https://fanerge.github.io/2017/09/18/koa%E5%AD%A6%E4%B9%A0-%E6%B5%8B%E8%AF%95/"/>
    <id>https://fanerge.github.io/2017/09/18/koa学习-测试/</id>
    <published>2017-09-18T14:21:06.000Z</published>
    <updated>2017-09-18T14:56:31.296Z</updated>
    
    <content type="html"><![CDATA[<p>mocha 模块是测试框架<br>chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2<br>supertest 模块是http请求测试库，用来请求API接口</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code>所需测试demo
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">const koa = require(&apos;koa&apos;);</div><div class="line">const app = new koa();</div><div class="line"></div><div class="line">const server = async (ctx, next) =&gt; &#123;</div><div class="line">	let result = &#123;</div><div class="line">		success: true,</div><div class="line">		data: null</div><div class="line">	&#125;;</div><div class="line">	if (ctx.method === &apos;GET&apos;) &#123;</div><div class="line">		if (ctx.url === &apos;/getString.json&apos;) &#123;</div><div class="line">			result.data = &apos;this is string data&apos;;</div><div class="line">		&#125; else if (ctx.url === &apos;/getNumber.json&apos;)&#123;</div><div class="line">			result.data = 123456;    </div><div class="line">		&#125; else &#123;</div><div class="line">			result.success = false;</div><div class="line">		&#125;</div><div class="line">		ctx.body = result;</div><div class="line">		next &amp;&amp; next();</div><div class="line">	&#125; else if (ctx.method === &apos;POST&apos;) &#123;</div><div class="line">		if (ctx.url === &apos;/postData.json&apos;) &#123;</div><div class="line">			result.data = &apos;ok&apos;;</div><div class="line">		&#125; else &#123;</div><div class="line">			result.success = false;</div><div class="line">		&#125;</div><div class="line">		ctx.body = result;</div><div class="line">		next &amp;&amp; next();</div><div class="line">	&#125; else &#123;</div><div class="line">		ctx.body = &apos;hello world&apos;;</div><div class="line">		next &amp;&amp; next();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">app.use(server);</div><div class="line"></div><div class="line">module.exports = app;</div><div class="line"></div><div class="line">app.listen(3004, () =&gt; &#123;</div><div class="line">	console.log(&apos;[demo] test-unit is starting at port 3004&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const supertest = require(&apos;supertest&apos;)</div><div class="line">const chai = require(&apos;chai&apos;)</div><div class="line">const app = require(&apos;./../index&apos;)</div><div class="line"></div><div class="line">const expect = chai.expect</div><div class="line">const request = supertest( app.listen() )</div><div class="line"></div><div class="line">// 测试套件/组</div><div class="line">describe( &apos;开始测试demo的GET请求&apos;, ( ) =&gt; &#123;</div><div class="line"></div><div class="line">  // 测试用例</div><div class="line">  it(&apos;测试/getString.json请求&apos;, ( done ) =&gt; &#123;</div><div class="line">	  request</div><div class="line">		.get(&apos;/getString.json&apos;)</div><div class="line">		.expect(200)</div><div class="line">		.end(( err, res ) =&gt; &#123;</div><div class="line">			// 断言判断结果是否为object类型</div><div class="line">			expect(res.body).to.be.an(&apos;object&apos;)</div><div class="line">			expect(res.body.success).to.be.an(&apos;boolean&apos;)</div><div class="line">			expect(res.body.data).to.be.an(&apos;string&apos;)</div><div class="line">			done()</div><div class="line">		&#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-jsonp" target="_blank" rel="external">koa-jsonp</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mocha 模块是测试框架&lt;br&gt;chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2&lt;br&gt;supertest 模块是http请求测试库，用来请求API接口&lt;/p&gt;
&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;hea
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-jsonp实现</title>
    <link href="https://fanerge.github.io/2017/09/18/koa%E5%AD%A6%E4%B9%A0-jsonp%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fanerge.github.io/2017/09/18/koa学习-jsonp实现/</id>
    <published>2017-09-18T13:35:36.000Z</published>
    <updated>2017-09-18T14:22:25.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原生koa2实现jsonp"><a href="#原生koa2实现jsonp" class="headerlink" title="原生koa2实现jsonp"></a>原生koa2实现jsonp</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const koa = require(&apos;koa&apos;);</div><div class="line"></div><div class="line">const app = new koa();</div><div class="line"></div><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	// 判断是否为jsonp的请求</div><div class="line">	if (ctx.method === &apos;GET&apos; &amp;&amp; ctx.url.split(&apos;?&apos;)[0] === &apos;/getData.jsonp&apos;) &#123;</div><div class="line">		// 获取jsonp的callback</div><div class="line">		let callbackName = ctx.query.callback || &apos;callback&apos;;</div><div class="line">		let returnData = &#123;</div><div class="line">			success: true,</div><div class="line">			data: &#123;</div><div class="line">				text: &apos;this is a jsonp api&apos;,</div><div class="line">				time: new Date().getTime()</div><div class="line">			&#125;</div><div class="line">		&#125; </div><div class="line">		// jsonp的script字符串</div><div class="line">		let jsonpStr = `;$&#123;callbackName&#125;($&#123;JSON.stringify(returnData)&#125;)`;      </div><div class="line">		// 用text/javascript，让请求支持跨域获取</div><div class="line">		ctx.type = &apos;text/javascript&apos;;</div><div class="line">		// 输出jsonp字符串</div><div class="line">		ctx.body = jsonpStr</div><div class="line">	&#125; else &#123;</div><div class="line">		ctx.body = &apos;hello jsonp&apos;;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(3004, () =&gt; &#123;</div><div class="line">	console.log(&apos;[demo] jsonp is starting at port 3004&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="koa-jsonp中间件实现"><a href="#koa-jsonp中间件实现" class="headerlink" title="koa-jsonp中间件实现"></a>koa-jsonp中间件实现</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const koa = require(&apos;koa&apos;);</div><div class="line">const jsonp = require(&apos;koa-jsonp&apos;);</div><div class="line"></div><div class="line">const app = new koa();</div><div class="line"></div><div class="line">app.use(jsonp());</div><div class="line"></div><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	let returnData = &#123;</div><div class="line">		success: true,</div><div class="line">		data: &#123;</div><div class="line">			text: &apos;this is a jsonp api&apos;,</div><div class="line">			time: new Date().getTime(),</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	// 直接输出json</div><div class="line">	ctx.body = returnData;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(3004, () =&gt; &#123;</div><div class="line">	console.log(&apos;[demo] jsonp is starting at port 3004&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-jsonp" target="_blank" rel="external">koa-jsonp</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原生koa2实现jsonp&quot;&gt;&lt;a href=&quot;#原生koa2实现jsonp&quot; class=&quot;headerlink&quot; title=&quot;原生koa2实现jsonp&quot;&gt;&lt;/a&gt;原生koa2实现jsonp&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;hig
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-数据库mysql</title>
    <link href="https://fanerge.github.io/2017/09/18/koa%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93mysql/"/>
    <id>https://fanerge.github.io/2017/09/18/koa学习-数据库mysql/</id>
    <published>2017-09-18T11:56:33.000Z</published>
    <updated>2017-09-18T13:39:20.144Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const mysql = require(&apos;mysql&apos;);</div><div class="line">// 数据库的配置信息</div><div class="line">const connection = mysql.createConnection(&#123;</div><div class="line">	host: &apos;localhost&apos;,</div><div class="line">	port: 3306,</div><div class="line">	user: &apos;root&apos;,</div><div class="line">	password: &apos;root&apos;,</div><div class="line">	database: &apos;sql&apos;</div><div class="line">&#125;);</div><div class="line">// 连接数据库</div><div class="line">connection.connect();</div><div class="line">// 进行数据库操作</div><div class="line">connection.query(&apos;SELECT * FROM apps&apos;, (err, result) =&gt; &#123;</div><div class="line">	if (err)  throw err;</div><div class="line">	console.log(result);</div><div class="line">&#125;);</div><div class="line">// 关闭连接</div><div class="line">connection.end();</div></pre></td></tr></table></figure>
</code></pre><h3 id="创建数据连接池"><a href="#创建数据连接池" class="headerlink" title="创建数据连接池"></a>创建数据连接池</h3><pre><code>一般情况下操作数据库是很复杂的读写过程，不只是一个会话，如果直接用会话操作，就需要每次会话都要配置连接参数。
所以这时候就需要连接池管理会话。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const mysql = require(&apos;mysql&apos;);</div><div class="line">const pool = mysql.createPool(&#123;</div><div class="line">	host: &apos;localhost&apos;,</div><div class="line">	port: 3306,</div><div class="line">	user: &apos;root&apos;,</div><div class="line">	password: &apos;root&apos;,</div><div class="line">	database: &apos;sql&apos;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 在数据池中进行会话操作</div><div class="line">pool.getConnection((err, connection) =&gt; &#123;</div><div class="line">	connection.query(&apos;SELECT * FROM apps&apos;, (err, result) =&gt; &#123;</div><div class="line">		console.log(result);</div><div class="line">		// 连接完成，连接将返回连接池</div><div class="line">		connection.release();</div><div class="line">		if (err) throw err;</div><div class="line">	&#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="使用promise和async-await来封装"><a href="#使用promise和async-await来封装" class="headerlink" title="使用promise和async-await来封装"></a>使用promise和async-await来封装</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// promise.js</div><div class="line">const mysql = require(&apos;mysql&apos;);</div><div class="line">const pool = mysql.createPool(&#123;</div><div class="line">	host     :  &apos;127.0.0.1&apos;,</div><div class="line">	user     :  &apos;root&apos;,</div><div class="line">	password :  &apos;root&apos;,</div><div class="line">	database :  &apos;sql&apos;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">let query = function (sql) &#123;</div><div class="line">	return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">		pool.getConnection((err, connection) =&gt; &#123;</div><div class="line">			if (err) &#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; else &#123;</div><div class="line">				connection.query(sql, (err, rows) =&gt; &#123;</div><div class="line">					if (err) &#123;</div><div class="line">						reject(err)</div><div class="line">					&#125; else &#123;</div><div class="line">						resolve(rows);</div><div class="line">					&#125;</div><div class="line">				connection.release();   </div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = query;</div><div class="line"></div><div class="line">// async.js</div><div class="line">const query = require(&apos;./promise&apos;);</div><div class="line"></div><div class="line">async function getData (sql) &#123;</div><div class="line">	let dataList = await query(sql);</div><div class="line">	console.log(dataList);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData(&apos;SELECT * FROM sql&apos;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="建表初始化"><a href="#建表初始化" class="headerlink" title="建表初始化"></a>建表初始化</h3><pre><code>+----------+  遍历sql  +---+ 解析所有sql +---+  执行sql  +------------&gt;
       |   |  目录下的  |   |  文件脚本  |   |   脚本     |   |
+----------+  sql文件   +---+   内容    +---+           +------------&gt;

[详细代码见]()
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="external">cookies</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模块介绍&quot;&gt;&lt;a href=&quot;#模块介绍&quot; class=&quot;headerlink&quot; title=&quot;模块介绍&quot;&gt;&lt;/a&gt;模块介绍&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-文件上传</title>
    <link href="https://fanerge.github.io/2017/09/17/koa%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://fanerge.github.io/2017/09/17/koa学习-文件上传/</id>
    <published>2017-09-17T12:20:14.000Z</published>
    <updated>2017-09-17T14:10:50.207Z</updated>
    
    <content type="html"><![CDATA[<h3 id="busboy模块"><a href="#busboy模块" class="headerlink" title="busboy模块"></a>busboy模块</h3><pre><code>模块是用来解析POST请求，node原生req中的文件流。
busboy 是用来解析出请求中文件流。
</code></pre><h3 id="封装上传文件到写入服务的方法"><a href="#封装上传文件到写入服务的方法" class="headerlink" title="封装上传文件到写入服务的方法"></a>封装上传文件到写入服务的方法</h3><pre><code>创建上传模块upload.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">const inspect = require(&apos;util&apos;).inspect;</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const os = require(&apos;os&apos;);</div><div class="line">const fs = require(&apos;fs&apos;);</div><div class="line">const Busboy = require(&apos;busboy&apos;);</div><div class="line"></div><div class="line">/*</div><div class="line">* 同步创建文件目录</div><div class="line">* @param &#123;string&#125; dirname 目录绝对地址</div><div class="line">* @return &#123;boolean&#125; 创建目录结果</div><div class="line">*/</div><div class="line">function mkdirsSync (dirname) &#123;</div><div class="line">	if (fs.existsSync(dirname)) &#123;</div><div class="line">		return true;</div><div class="line">	&#125; else &#123;</div><div class="line">		if (mkdirsSync(path.dirname(dirname))) &#123;</div><div class="line">			fs.mkdirSync(dirname);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">* 获取上传文件的后缀名</div><div class="line">* @param &#123;string&#125; fileName 获取上传文件的后缀名</div><div class="line">* @return &#123;string&#125; 文件后缀名</div><div class="line">*/</div><div class="line">function getSuffixName (fileName) &#123;</div><div class="line">	/*let nameList = fileName.split(&apos;.&apos;);</div><div class="line">	return nameList[nameList.length-1]*/</div><div class="line">	return path.extname(fileName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">* 上传文件</div><div class="line">* @param &#123;object&#125; ctx koa上下文</div><div class="line">* @param &#123;object&#125; options 文件上传参数 fileType文件类型， path文件存放路径</div><div class="line">* @return &#123;promise&#125;</div><div class="line">*/</div><div class="line">function uploadFile (ctx, options) &#123;</div><div class="line">	let req = ctx.req;</div><div class="line">	let res = ctx.res;</div><div class="line">	let busboy = new Busboy(&#123;headers: req.headers&#125;);</div><div class="line"></div><div class="line">	// 获取类型</div><div class="line">	let fileType = options.fileType || &apos;common&apos;;</div><div class="line">	let filePath = path.join(options.path, fileType);</div><div class="line">	let mkdirResult = mkdirsSync(filePath);</div><div class="line"></div><div class="line">	return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">		console.log(&apos;文件上传中...&apos;);</div><div class="line">		let result = &#123;</div><div class="line">			success: false,</div><div class="line">			formData: &#123;&#125;,</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		// 解析请求文件事件</div><div class="line">		busboy.on(&apos;file&apos;, function(fieldname, file, filename, encoding, mimetype) &#123;</div><div class="line">		  let fileName = Math.random().toString(16).substr(2) + &apos;.&apos; + getSuffixName(filename)</div><div class="line">		  let _uploadFilePath = path.join( filePath, fileName )</div><div class="line">		  let saveTo = path.join(_uploadFilePath)</div><div class="line"></div><div class="line">		  // 文件保存到制定路径</div><div class="line">		  file.pipe(fs.createWriteStream(saveTo))</div><div class="line"></div><div class="line">		  // 文件写入事件结束</div><div class="line">		  file.on(&apos;end&apos;, function() &#123;</div><div class="line">			result.success = true</div><div class="line">			result.message = &apos;文件上传成功&apos;</div><div class="line"></div><div class="line">			console.log(&apos;文件上传成功！&apos;)</div><div class="line">			resolve(result)</div><div class="line">		  &#125;)</div><div class="line">		&#125;)</div><div class="line"></div><div class="line">		// 解析表单中其他字段信息</div><div class="line">		busboy.on(&apos;field&apos;, function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) &#123;</div><div class="line">		  console.log(&apos;表单字段数据 [&apos; + fieldname + &apos;]: value: &apos; + inspect(val));</div><div class="line">		  result.formData[fieldname] = inspect(val);</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		// 解析结束事件</div><div class="line">		busboy.on(&apos;finish&apos;, function( ) &#123;</div><div class="line">		  console.log(&apos;文件上结束&apos;)</div><div class="line">		  resolve(result)</div><div class="line">		&#125;)</div><div class="line"></div><div class="line">		// 解析错误事件</div><div class="line">		busboy.on(&apos;error&apos;, function(err) &#123;</div><div class="line">		  console.log(&apos;文件上出错&apos;)</div><div class="line">		  reject(result)</div><div class="line">		&#125;)</div><div class="line"></div><div class="line">		req.pipe(busboy)</div><div class="line"></div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports =  &#123;</div><div class="line">  uploadFile</div><div class="line">&#125;</div></pre></td></tr></table></figure>

入口文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;)</div><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const app = new Koa()</div><div class="line">// const bodyParser = require(&apos;koa-bodyparser&apos;)</div><div class="line"></div><div class="line">const &#123; uploadFile &#125; = require(&apos;./util/upload&apos;)</div><div class="line"></div><div class="line">// app.use(bodyParser())</div><div class="line"></div><div class="line">app.use( async ( ctx ) =&gt; &#123;</div><div class="line"></div><div class="line">  if ( ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos; ) &#123;</div><div class="line">	// 当GET请求时候返回表单页面</div><div class="line">	let html = `</div><div class="line">	  &lt;h1&gt;koa2 upload demo&lt;/h1&gt;</div><div class="line">	  &lt;form method=&quot;POST&quot; action=&quot;/upload.json&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">		&lt;p&gt;file upload&lt;/p&gt;</div><div class="line">		&lt;span&gt;picName:&lt;/span&gt;&lt;input name=&quot;picName&quot; type=&quot;text&quot; /&gt;&lt;br/&gt;</div><div class="line">		&lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;&lt;br/&gt;&lt;br/&gt;</div><div class="line">		&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</div><div class="line">	  &lt;/form&gt;</div><div class="line">	`</div><div class="line">	ctx.body = html</div><div class="line"></div><div class="line">  &#125; else if ( ctx.url === &apos;/upload.json&apos; &amp;&amp; ctx.method === &apos;POST&apos; ) &#123;</div><div class="line">	// 上传文件请求处理</div><div class="line">	let result = &#123; success: false &#125;</div><div class="line">	let serverFilePath = path.join( __dirname, &apos;upload-files&apos; )</div><div class="line"></div><div class="line">	// 上传文件事件</div><div class="line">	result = await uploadFile( ctx, &#123;</div><div class="line">	  fileType: &apos;album&apos;, // common or album</div><div class="line">	  path: serverFilePath</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	ctx.body = result</div><div class="line">  &#125; else &#123;</div><div class="line">	// 其他请求显示404</div><div class="line">	ctx.body = &apos;&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(3004, () =&gt; &#123;</div><div class="line">  console.log(&apos;[demo] upload-simple is starting at port 3000&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="external">cookies</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;busboy模块&quot;&gt;&lt;a href=&quot;#busboy模块&quot; class=&quot;headerlink&quot; title=&quot;busboy模块&quot;&gt;&lt;/a&gt;busboy模块&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;模块是用来解析POST请求，node原生req中的文件流。
busboy 是
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-模版引擎</title>
    <link href="https://fanerge.github.io/2017/09/17/koa%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"/>
    <id>https://fanerge.github.io/2017/09/17/koa学习-模版引擎/</id>
    <published>2017-09-17T09:29:05.000Z</published>
    <updated>2017-09-17T10:21:31.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="koa2加载模板引擎"><a href="#koa2加载模板引擎" class="headerlink" title="koa2加载模板引擎"></a>koa2加载模板引擎</h3><pre><code>koa-views - 为koa模版渲染中间件
ejs - 模版引擎
关键代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const views = require(&apos;koa-views&apos;)</div><div class="line">const path = require(&apos;path&apos;)</div><div class="line">app.use(views(path.join(__dirname, &apos;./view&apos;), &#123;</div><div class="line">	extension: &apos;ejs&apos;</div><div class="line">&#125;));</div><div class="line"></div><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	if (ctx.url === &apos;/&apos;) &#123;</div><div class="line">	   let title = &apos;hello koa2&apos;;</div><div class="line">		await ctx.render(&apos;index&apos;, &#123;</div><div class="line">			title,</div><div class="line">		&#125;);     </div><div class="line">	&#125; else &#123;</div><div class="line">		let title = &apos;other&apos;;</div><div class="line">		await ctx.render(&apos;index&apos;, &#123;</div><div class="line">			title,</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="ejs模板引擎"><a href="#ejs模板引擎" class="headerlink" title="ejs模板引擎"></a>ejs模板引擎</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">	</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-views" target="_blank" rel="external">koa-views</a><br>    <a href="https://www.npmjs.com/package/ejs" target="_blank" rel="external">ejs</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;koa2加载模板引擎&quot;&gt;&lt;a href=&quot;#koa2加载模板引擎&quot; class=&quot;headerlink&quot; title=&quot;koa2加载模板引擎&quot;&gt;&lt;/a&gt;koa2加载模板引擎&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;koa-views - 为koa模版渲染中间件
ejs - 
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-静态资源加载</title>
    <link href="https://fanerge.github.io/2017/09/17/koa%E5%AD%A6%E4%B9%A0-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    <id>https://fanerge.github.io/2017/09/17/koa学习-静态资源加载/</id>
    <published>2017-09-17T05:17:50.000Z</published>
    <updated>2017-09-17T08:35:27.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原生koa2实现静态资源服务器"><a href="#原生koa2实现静态资源服务器" class="headerlink" title="原生koa2实现静态资源服务器"></a>原生koa2实现静态资源服务器</h3><pre><code>一个http请求访问web服务静态资源，一般响应结果有三种情况
</code></pre><ol>
<li>访问文本，例如html，js，css，png，jpg，gif</li>
<li>访问静态目录</li>
<li>找不到资源，抛出404错误<br>这里由于代码量过多，请查看源代码<br><a href="">这里由于代码量过多，请查看源代码</a><h3 id="koa-static中间件使用"><a href="#koa-static中间件使用" class="headerlink" title="koa-static中间件使用"></a>koa-static中间件使用</h3>koa-static作为koaweb框架的静态服务器中间件<br>使用关键代码:<pre><code>// 导入koa-static模块
const static = require(&apos;koa-static&apos;);
// 设置静态资源的更目录
const staticPath = &apos;./static&apos;;
// 使用静态资源中间件
app.use(static(path.join(__dirname, staticPath)));
</code></pre><blockquote>
<p>   参考文档：<br><a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br><a href="https://www.npmjs.com/package/cookies" target="_blank" rel="external">cookies</a></p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原生koa2实现静态资源服务器&quot;&gt;&lt;a href=&quot;#原生koa2实现静态资源服务器&quot; class=&quot;headerlink&quot; title=&quot;原生koa2实现静态资源服务器&quot;&gt;&lt;/a&gt;原生koa2实现静态资源服务器&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;一个http请求访问
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-请求数据获取</title>
    <link href="https://fanerge.github.io/2017/09/17/koa%E5%AD%A6%E4%B9%A0-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
    <id>https://fanerge.github.io/2017/09/17/koa学习-请求数据获取/</id>
    <published>2017-09-17T03:13:16.000Z</published>
    <updated>2017-09-17T05:16:24.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GET请求数据获取"><a href="#GET请求数据获取" class="headerlink" title="GET请求数据获取"></a>GET请求数据获取</h3><pre><code>获取GET请求数据源头是koa中request对象中的query方法或querystring方法，
query返回是格式化好的参数对象，querystring返回的是请求字符串。    
由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。
</code></pre><ol>
<li>是从上下文中直接获取<br>  请求对象ctx.query，返回如 { a:1, b:2 }<br>  请求字符串 ctx.querystring，返回如 a=1&amp;b=2</li>
<li><p>是从上下文的request对象中获取<br>  请求对象ctx.request.query，返回如 { a:1, b:2 }<br>  请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2<br>关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	let url = ctx.url;</div><div class="line">	let request = ctx.request;</div><div class="line">	// 使用ctx.request对象获取</div><div class="line">	let req_query = request.query;</div><div class="line">	let req_querystring = request.querystring;</div><div class="line">	// 使用ctx对其request属性的引用获取</div><div class="line">	let ctx_query = ctx.query;</div><div class="line">	let ctx_querystring = ctx.querystring;</div><div class="line">	ctx.body = &#123;</div><div class="line">		url,</div><div class="line">		req_query,</div><div class="line">		req_querystring,</div><div class="line">		ctx_query,</div><div class="line">		ctx_querystring</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出：<br>测试url：<a href="http://localhost:3000/?name=fanerge&amp;age=323" target="_blank" rel="external">http://localhost:3000/?name=fanerge&amp;age=323</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	url: &quot;/?name=fanerge&amp;age=323&quot;,</div><div class="line">	req_query: &#123;</div><div class="line">		name: &quot;fanerge&quot;,</div><div class="line">		age: &quot;323&quot;</div><div class="line">	&#125;,</div><div class="line">	req_querystring: &quot;name=fanerge&amp;age=323&quot;,</div><div class="line">	ctx_query: &#123;</div><div class="line">		name: &quot;fanerge&quot;,</div><div class="line">		age: &quot;323&quot;</div><div class="line">	&#125;,</div><div class="line">	ctx_querystring: &quot;name=fanerge&amp;age=323&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="POST请求参数获取"><a href="#POST请求参数获取" class="headerlink" title="POST请求参数获取"></a>POST请求参数获取</h3><pre><code>解析出POST请求上下文中的表单数据
新建一个工具函数库：./util/index.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function parseQueryStr (queryStr) &#123;</div><div class="line">	let queryData = &#123;&#125;;</div><div class="line">	let queryStrList = queryStr.split(&apos;&amp;&apos;);</div><div class="line">	console.log(queryStrList);</div><div class="line">	for (let [index, queryStr] of queryStrList.entries()) &#123;</div><div class="line">		let itemList = queryStr.split(&apos;=&apos;);</div><div class="line">		queryData[itemList[0]] = decodeURIComponent(itemList[1]);</div><div class="line">	&#125;</div><div class="line">	return queryData;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function parsePostData (ctx) &#123;</div><div class="line">	return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">		try &#123;</div><div class="line">			let postData = &quot;&quot;;</div><div class="line">			ctx.req.addListener(&apos;data&apos;, (data) =&gt; &#123;</div><div class="line">				postData += data;</div><div class="line">			&#125;);</div><div class="line">			ctx.req.addListener(&apos;end&apos;, ()=&gt; &#123;</div><div class="line">				let parseData = parseQueryStr(postData);</div><div class="line">				resolve(parseData);</div><div class="line">			&#125;);</div><div class="line">		&#125; catch (e) &#123;</div><div class="line">			conole.error(e);</div><div class="line">			reject(e);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports= &#123;</div><div class="line">	parsePostData,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

post.js关键代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">const &#123;parsePostData&#125; = require(&apos;./util/index&apos;);</div><div class="line"></div><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123;</div><div class="line">		// 当get请求是返回表单页面</div><div class="line">		let html = `</div><div class="line">			&lt;h1&gt;koa2 request post demo&lt;/h1&gt;</div><div class="line">		  &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;</div><div class="line">			&lt;p&gt;userName&lt;/p&gt;</div><div class="line">			&lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</div><div class="line">			&lt;p&gt;nickName&lt;/p&gt;</div><div class="line">			&lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;</div><div class="line">			&lt;p&gt;email&lt;/p&gt;</div><div class="line">			&lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;</div><div class="line">			&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</div><div class="line">		  &lt;/form&gt;</div><div class="line">		`;</div><div class="line">		ctx.body = html;</div><div class="line">	&#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123;</div><div class="line">		let postData = await parsePostData(ctx);</div><div class="line">		ctx.body = postData;</div><div class="line">	&#125; else &#123;</div><div class="line">		ctx.body = &apos;没找到&apos;</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

提交表单的数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	userName: &quot;67&quot;,</div><div class="line">	nickName: &quot;89&quot;,</div><div class="line">	email: &quot;0&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="koa-bodyparser中间件"><a href="#koa-bodyparser中间件" class="headerlink" title="koa-bodyparser中间件"></a>koa-bodyparser中间件</h3><pre><code>对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中
关键代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const bodyParser = require(&apos;koa-bodyparser&apos;); // 引入该模块</div><div class="line">app.use(bodyParser()); // 使用ctx.body解析中间件</div><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123;</div><div class="line">		// 当GET请求时候返回表单页面</div><div class="line">		let html = `</div><div class="line">		  &lt;h1&gt;koa2 request post demo&lt;/h1&gt;</div><div class="line">		  &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;</div><div class="line">			&lt;p&gt;userName&lt;/p&gt;</div><div class="line">			&lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</div><div class="line">			&lt;p&gt;nickName&lt;/p&gt;</div><div class="line">			&lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;</div><div class="line">			&lt;p&gt;email&lt;/p&gt;</div><div class="line">			&lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;</div><div class="line">			&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</div><div class="line">		  &lt;/form&gt;</div><div class="line">		`</div><div class="line">		ctx.body = html</div><div class="line">	&#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123;</div><div class="line">		// 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来</div><div class="line">		let postData = ctx.request.body;</div><div class="line">		ctx.body = postData;</div><div class="line">	&#125; else &#123;</div><div class="line">		ctx.body = &apos;没找到404&apos;;</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="external">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-bodyparser" target="_blank" rel="external">koa-bodyparser</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GET请求数据获取&quot;&gt;&lt;a href=&quot;#GET请求数据获取&quot; class=&quot;headerlink&quot; title=&quot;GET请求数据获取&quot;&gt;&lt;/a&gt;GET请求数据获取&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;获取GET请求数据源头是koa中request对象中的query方法
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa学习-中间件和路由</title>
    <link href="https://fanerge.github.io/2017/09/16/koa%E5%AD%A6%E4%B9%A0-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1/"/>
    <id>https://fanerge.github.io/2017/09/16/koa学习-中间件和路由/</id>
    <published>2017-09-16T13:24:00.000Z</published>
    <updated>2017-09-17T03:18:25.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="koa中间件的制作和使用"><a href="#koa中间件的制作和使用" class="headerlink" title="koa中间件的制作和使用"></a>koa中间件的制作和使用</h2><h3 id="koa模版"><a href="#koa模版" class="headerlink" title="koa模版"></a>koa模版</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var koa = require(&apos;koa&apos;);</div><div class="line">const app = new koa();</div><div class="line">// 中间件</div><div class="line">app.use(async (ctx) =&gt; &#123;</div><div class="line">	ctx.body = &apos;hello koa2&apos;;</div><div class="line">&#125;);</div><div class="line">app.listen(3000);</div></pre></td></tr></table></figure>
</code></pre><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function getSyncTime () &#123;</div><div class="line">	return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">		try &#123;</div><div class="line">			let startTime = new Date().getTime();</div><div class="line">			setTimeout(() =&gt; &#123;</div><div class="line">				let endTime = new Date().getTime();</div><div class="line">				let data = endTime - startTime;</div><div class="line">				resolve(data);</div><div class="line">			&#125;, 500);</div><div class="line">		&#125; catch (e) &#123;</div><div class="line">			reject(e);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async function getSyncData () &#123;</div><div class="line">	let time = await getSyncTime();</div><div class="line">	let data = `endTime - startTime = $&#123;time&#125;`;</div><div class="line">	console.log(data);</div><div class="line">&#125;</div><div class="line">getSyncData();</div></pre></td></tr></table></figure>
</code></pre><h3 id="koa2简析结构"><a href="#koa2简析结构" class="headerlink" title="koa2简析结构"></a>koa2简析结构</h3><pre><code>源码文件：
├── lib
│   ├── application.js
│   ├── context.js
│   ├── request.js
│   └── response.js
└── package.json
文件说明：
application.js 是整个koa2 的入口文件，封装了context，request，response，以及最核心的中间件处理流程。
context.js 处理应用上下文，里面直接封装部分request.js和response.js的方法
request.js 处理http请求
response.js 处理http响应
</code></pre><h3 id="koa中间件开发和使用"><a href="#koa中间件开发和使用" class="headerlink" title="koa中间件开发和使用"></a>koa中间件开发和使用</h3><pre><code>以日志中间件为例
middleware/logger-async.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function log (ctx) &#123;</div><div class="line">	console.log(`请求方法：$&#123;ctx.method&#125;, host：$&#123;ctx.header.host&#125;, url：$&#123;ctx.url&#125;`);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = function () &#123;</div><div class="line">	return async function (ctx, next)&#123;</div><div class="line">		log(ctx);</div><div class="line">		await next();</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

使用该中间件logger
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const loggerAsync  = require(&apos;./middleware/logger-async&apos;);</div><div class="line">// 使用日志中间件</div><div class="line">app.use(loggerAsync());</div></pre></td></tr></table></figure>
</code></pre><h2 id="koa路由中间件"><a href="#koa路由中间件" class="headerlink" title="koa路由中间件"></a>koa路由中间件</h2><h3 id="koa2原生路由实现"><a href="#koa2原生路由实现" class="headerlink" title="koa2原生路由实现"></a>koa2原生路由实现</h3><pre><code>获取url：ctx.request.url
后端路由：根据前端get请求的url地址，后端返回对应的view页面达到。
</code></pre><h3 id="koa-router中间件"><a href="#koa-router中间件" class="headerlink" title="koa-router中间件"></a>koa-router中间件</h3><pre><code>安装koa-router中间件
    npm install --save koa-router
使用koa-router
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 子路由1</div><div class="line">let home = new Router();</div><div class="line">home.get(&apos;/&apos;, async (ctx) =&gt; &#123;</div><div class="line">	let html = `</div><div class="line">		&lt;ul&gt;</div><div class="line">			&lt;li&gt;&lt;a href=&quot;/&quot;&gt;/&lt;/a&gt;&lt;/li&gt;</div><div class="line">			&lt;li&gt;&lt;a href=&quot;/page&quot;&gt;/page&lt;/a&gt;&lt;/li&gt;</div><div class="line">			&lt;li&gt;&lt;a href=&quot;/page/helloword&quot;&gt;/page/helloword&lt;/a&gt;&lt;/li&gt;</div><div class="line">			&lt;li&gt;&lt;a href=&quot;/page/chengdu&quot;&gt;/page/chengdu&lt;/a&gt;&lt;/li&gt;</div><div class="line">			&lt;li&gt;&lt;a href=&quot;/page/ss&quot;&gt;not found&lt;/a&gt;&lt;/li&gt;</div><div class="line">		&lt;/ul&gt;</div><div class="line">	`;</div><div class="line">	ctx.body = html;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 子路由2</div><div class="line">let page = new Router();</div><div class="line">page.get(&apos;/&apos;, async (ctx) =&gt; &#123;</div><div class="line">	ctx.body = &apos;page主页&apos;;</div><div class="line">&#125;)</div><div class="line">.get(&apos;/chengdu&apos;, async (ctx) =&gt; &#123;</div><div class="line">	ctx.body = &apos;欢迎来到成都&apos;;</div><div class="line">&#125;)</div><div class="line">.get(&apos;/helloword&apos;, (ctx) =&gt; &#123;</div><div class="line">	ctx.body = &apos;helloword page&apos;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 子路由3-Not found</div><div class="line">let notFound = new Router();</div><div class="line">notFound.get(&apos;*&apos;, async (ctx) =&gt; &#123;</div><div class="line">	ctx.body = &apos;没有找到！&apos;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 装载所有的子路由</div><div class="line">let router = new Router();</div><div class="line">router.use(&apos;/&apos;, home.routes(), home.allowedMethods());</div><div class="line">router.use(&apos;/page&apos;, page.routes(), page.allowedMethods());</div><div class="line">router.use(&apos;*&apos;, notFound.routes(), notFound.allowedMethods());</div><div class="line"></div><div class="line">// 加载路由中间件</div><div class="line">app.use(router.routes())</div><div class="line">.use(router.allowedMethods());</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/get.html" target="_blank" rel="external">koa2-note</a><br>    <a href="https://www.npmjs.com/package/koa-router" target="_blank" rel="external">koa-router官方文档</a></p>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note" target="_blank" rel="external">koa2</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;koa中间件的制作和使用&quot;&gt;&lt;a href=&quot;#koa中间件的制作和使用&quot; class=&quot;headerlink&quot; title=&quot;koa中间件的制作和使用&quot;&gt;&lt;/a&gt;koa中间件的制作和使用&lt;/h2&gt;&lt;h3 id=&quot;koa模版&quot;&gt;&lt;a href=&quot;#koa模版&quot; c
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://fanerge.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>HTTP模块</title>
    <link href="https://fanerge.github.io/2017/09/16/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-HTTP/"/>
    <id>https://fanerge.github.io/2017/09/16/nodejs自带模块-HTTP/</id>
    <published>2017-09-16T09:06:40.000Z</published>
    <updated>2017-09-16T12:40:31.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要使用-HTTP-服务器与客户端，需要-require-‘http’-。"><a href="#要使用-HTTP-服务器与客户端，需要-require-‘http’-。" class="headerlink" title="要使用 HTTP 服务器与客户端，需要 require(‘http’)。"></a>要使用 HTTP 服务器与客户端，需要 require(‘http’)。</h3><pre><code>Node.js 中的 HTTP 接口被设计成支持协议的许多特性。 比如，大块编码的消息。 这些接口不缓冲完整的请求或响应，用户能够以流的形式处理数据。
</code></pre><h3 id="http-Agent-类"><a href="#http-Agent-类" class="headerlink" title="http.Agent 类"></a>http.Agent 类</h3><pre><code>Agent 负责为 HTTP 客户端管理连接的持续与复用。 它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket 连接直到队列为空，此时 socket 会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 keepAlive 选项。
</code></pre><ol>
<li>new Agent([options])<br>  作用：实例化一个代理 代理的配置选项。<br>  var agent = new Agent([options]);</li>
<li>agent.createConnection(options[, callback])<br>  作用：创建一个用于 HTTP 请求的 socket 或流。</li>
<li>agent.keepSocketAlive(socket)<br>  作用：在 socket 被请求分离的时候调用, 可能被代理持续使用。</li>
<li>agent.reuseSocket(socket, request)<br>  作用：由于 keep-alive 选项被保持持久化, 在 socket 附加到 request 时调用。</li>
<li>agent.destroy()<br>  作用：销毁当前正被代理使用的任何 socket。</li>
<li>agent.freeSockets<br>  作用：返回一个对象，包含当前正在等待被启用了 keepAlive 的代理使用的 socket 数组。 不要修改该属性。</li>
<li>agent.getName(options)<br>  作用：为请求选项的集合获取一个唯一的名称，用来判断一个连接是否可以被复用。</li>
<li>agent.maxFreeSockets<br>  作用：默认为 256。 对于已启用 keepAlive 的代理，该属性可设置要保留的空闲 socket 的最大数量。</li>
<li>agent.maxSockets<br>  作用：默认为不限制。 该属性可设置代理为每个来源打开的并发 socket 的最大数量。</li>
<li>agent.requests<br> 作用：返回一个对象，包含还未被分配到 socket 的请求队列。 不要修改。</li>
<li>agent.sockets<br> 作用：返回一个对象，包含当前正被代理使用的 socket 数组。 不要修改。<h3 id="http-ClientRequest-类"><a href="#http-ClientRequest-类" class="headerlink" title="http.ClientRequest 类"></a>http.ClientRequest 类</h3>该对象在 http.request() 内部被创建并返回。 它表示着一个正在处理的请求，其请求头已进入队列。 请求头仍可使用 setHeader(name, value)、getHeader(name) 和 removeHeader(name) API 进行修改。</li>
<li>abort事件<br>当请求已被客户端终止时触发。 该事件仅在首次调用 abort() 时触发。</li>
<li>aborted事件<br>当请求已被服务器终止且网络 socket 已关闭时触发。</li>
<li>connect事件<br>每当服务器响应 CONNECT 请求时触发。</li>
<li>continue事件<br>当服务器发送了一个 100 Continue 的 HTTP 响应时触发，通常是因为请求包含 Expect: 100-continue。 这是客户端将要发送请求主体的指令。</li>
<li>response事件<br>当请求的响应被接收到时触发。 该事件只触发一次。</li>
<li>socket事件<br>当 socket 被分配到请求后触发。</li>
<li>upgrade事件<br>每当服务器响应 upgrade 请求时触发。 </li>
<li>request.abort()<br>标记请求为终止。 调用该方法将使响应中剩余的数据被丢弃且 socket 被销毁。</li>
<li>request.aborted<br>如果请求已被终止，则该属性的值为请求被终止的时间，从 1 January 1970 00:00:00 UTC 到现在的毫秒数。</li>
<li>request.connection</li>
<li>request.end([data[, encoding]][, callback])<br>结束发送请求。</li>
<li>request.flushHeaders()<br>刷新请求头。</li>
<li>request.setNoDelay([noDelay])<br>一旦 socket 被分配给请求且已连接，socket.setNoDelay() 会被调用。</li>
<li>request.setSocketKeepAlive([enable][, initialDelay])<br>一旦 socket 被分配给请求且已连接，socket.setKeepAlive() 会被调用。</li>
<li>request.setTimeout(timeout[, callback])<br>一旦 socket 被分配给请求且已连接，socket.setTimeout() 会被调用。</li>
<li>request.socket<br>引用底层socket。</li>
<li>request.write(chunk[, encoding][, callback])<br>发送请求主体的一个数据块。<h3 id="http-Server-类"><a href="#http-Server-类" class="headerlink" title="http.Server 类"></a>http.Server 类</h3>该类继承自 net.Server，且具有以下额外的事件</li>
<li>checkContinue 事件<br>每当接收到一个带有 HTTP Expect: 100-continue 请求头的请求时触发。</li>
<li>checkExpectation 事件<br>每当接收到一个带有 HTTP Expect 请求头（值不为 100-continue）的请求时触发。 </li>
<li>clientError 事件<br>如果客户端触发了一个 ‘error’ 事件，则它会被传递到这里。</li>
<li>close事件<br>当服务器关闭时触发。</li>
<li>connect事件<br>每当客户端发送 HTTP CONNECT 请求时触发。</li>
<li>connection事件<br>当一个新的 TCP 流被建立时触发。 </li>
<li>request事件<br>每次接收到一个请求时触发。 </li>
<li>upgrade事件<br>每当客户端发送 HTTP upgrade 请求时触发。</li>
<li>server.close([callback])<br>停止服务端接收新的连接。</li>
<li>server.listen(handle[, callback])<br>handle 对象可以被设为一个服务器或 socket（任何带有一个 _handle 成员的对象）、或一个 {fd: <n>} 对象。</n></li>
<li>server.listen(path[, callback])<br>启动一个 UNIX socket 服务器，并在给定的 path 上监听连接。</li>
<li>server.listen([port][, hostname][, backlog][, callback])<br>开始在指定的 port 和 hostname 上接受连接。</li>
<li>server.listening<br>返回一个布尔值，表示服务器是否正在监听连接。</li>
<li>server.maxHeadersCount<br>限制请求头的最大数量，默认为 2000。 如果设为 0，则没有限制。</li>
<li>server.setTimeout([msecs][, callback])<br>设置 socket 的超时时间。</li>
<li>server.timeout<br>socket 被认定为超时的空闲毫秒数。</li>
<li>server.keepAliveTimeout<br>服务器完成最后的响应之后需要等待的额外的传入数据的活跃毫秒数, socket 才能被销毁。<h3 id="http-ServerResponse-类"><a href="#http-ServerResponse-类" class="headerlink" title="http.ServerResponse 类"></a>http.ServerResponse 类</h3>该对象在 HTTP 服务器内部被创建。 它作为第二个参数被传入 ‘request’ 事件。</li>
<li>close事件<br>当底层连接在 response.end() 被调用或能够刷新之前被终止时触发。</li>
<li>finish事件<br>当响应已被发送时触发。 </li>
<li>response.addTrailers(headers)<br>该方法会添加 HTTP 尾部响应头（一种在消息尾部的响应头）到响应。</li>
<li>response.connection</li>
<li>response.end([data][, encoding][, callback])<br>该方法会通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。 </li>
<li>response.finished<br>返回一个布尔值，表示响应是否已完成。</li>
<li>response.getHeader(name)<br>读取一个已入队列但尚未发送到客户端的响应头。</li>
<li>response.getHeaderNames()<br>返回一个包含当前响应唯一名称的 http 头信息名称数组. 名称均为小写。</li>
<li>response.getHeaders()<br>返回当前响应头文件的浅拷贝。</li>
<li>response.hasHeader(name)<br>如果响应头当前有设置 name 头部，返回 true。</li>
<li>response.headersSent<br>返回一个布尔值（只读）。 </li>
<li>response.removeHeader(name)<br>从隐式发送的队列中移除一个响应头。</li>
<li>response.sendDate<br>当为 true 时，如果响应头里没有日期响应头，则日期响应头会被自动生成并发送。</li>
<li>response.setHeader(name, value)<br>为一个隐式的响应头设置值。</li>
<li>response.setTimeout(msecs[, callback])<br>设置 socket 的超时时间为 msecs。</li>
<li>response.socket<br>引用底层socket。 </li>
<li>response.statusCode<br>当使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态码。</li>
<li>response.statusMessage<br>使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态信息。</li>
<li>response.write(chunk[, encoding][, callback])<br>如果该方法被调用且 response.writeHead() 没有被调用，则它会切换到隐式响应头模式并刷新隐式响应头。</li>
<li>response.writeContinue()<br>发送一个 HTTP/1.1 100 Continue 消息到客户端，表示请求主体可以开始发送。 参阅 Server 的 ‘checkContinue’ 事件。</li>
<li>response.writeHead(statusCode[, statusMessage][, headers])<br>发送一个响应头给请求。 <h3 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h3>IncomingMessage 对象由 http.Server 或 http.ClientRequest 创建，并作为第一个参数分别递给 ‘request’ 和 ‘response’ 事件。 它可以用来访问响应状态、消息头、以及数据。<blockquote>
<p>   参考文档：<br><a href="http://nodejs.cn/api/http.html" target="_blank" rel="external">HTTP参考-api</a></p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要使用-HTTP-服务器与客户端，需要-require-‘http’-。&quot;&gt;&lt;a href=&quot;#要使用-HTTP-服务器与客户端，需要-require-‘http’-。&quot; class=&quot;headerlink&quot; title=&quot;要使用 HTTP 服务器与客户端，需要 
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>url模块-网址</title>
    <link href="https://fanerge.github.io/2017/09/16/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-url/"/>
    <id>https://fanerge.github.io/2017/09/16/nodejs自带模块-url/</id>
    <published>2017-09-16T07:04:28.000Z</published>
    <updated>2017-09-16T09:08:38.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="url-模块提供了一些实用函数，用于-URL-处理与解析。"><a href="#url-模块提供了一些实用函数，用于-URL-处理与解析。" class="headerlink" title="url 模块提供了一些实用函数，用于 URL 处理与解析。"></a>url 模块提供了一些实用函数，用于 URL 处理与解析。</h3><h3 id="URL-字符串与-URL-对象"><a href="#URL-字符串与-URL-对象" class="headerlink" title="URL 字符串与 URL 对象"></a>URL 字符串与 URL 对象</h3><pre><code>一个 URL 字符串是一个结构化的字符串，它包含多个有意义的组成部分。 当被解析时，会返回一个 URL 对象，它包含每个组成部分作为属性。
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
&quot;  https:   //    user   :   pass   @ sub.host.com : 8080   /p/a/t/h  ?  query=string   #hash &quot;
│          │  │          │          │   hostname   │ port │          │                │       │
│          │  │          │          ├──────── ──────┴──────┤          │                │       │
│ protocol │  │ username │ password │        host         │          │                │       │
├──────────┴──┼──────────┴──────────┼─────────────────────┤          │                │       │
│   origin    │                     │       origin        │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴─────────────────────┴──────────┴────────────────┴───────┤
│                                            href                                             │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre><h3 id="Constructor-new-URL-input-base"><a href="#Constructor-new-URL-input-base" class="headerlink" title="Constructor: new URL(input[, base])"></a>Constructor: new URL(input[, base])</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const &#123; URL &#125; = require(&apos;url&apos;);</div><div class="line">const myURL = new URL(&apos;/foo&apos;, &apos;https://example.org/&apos;);</div><div class="line">// https://example.org/foo</div></pre></td></tr></table></figure>
</code></pre><p>一下实例均以：var myURL = new URL(‘<a href="https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash" target="_blank" rel="external">https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash</a>‘);</p>
<h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url.hash"></a>url.hash</h3><pre><code>作用：获取及设置URL的分段(hash)部分。
    myURL.hash; // #hash
</code></pre><h3 id="url-host"><a href="#url-host" class="headerlink" title="url.host"></a>url.host</h3><pre><code>作用：获取及设置URL的主机(host)部分。
    myURL.host; // user:pass@sub.host.com:8080
</code></pre><h3 id="url-hostname"><a href="#url-hostname" class="headerlink" title="url.hostname"></a>url.hostname</h3><pre><code>作用：获取及设置URL的主机名(hostname)部分。 url.host和url.hostname之间的区别是url.hostname不 包含端口。
    myURL.hostname; // user:pass@sub.host.com
</code></pre><h3 id="url-href"><a href="#url-href" class="headerlink" title="url.href"></a>url.href</h3><pre><code>作用：获取及设置序列化的URL。
    myURL.href; // https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash
</code></pre><h3 id="url-origin"><a href="#url-origin" class="headerlink" title="url.origin"></a>url.origin</h3><pre><code>作用：获取只读序列化的URL orgin部分。
    myURL.origin; // https://user:pass@sub.host.com:8080
</code></pre><h3 id="url-password"><a href="#url-password" class="headerlink" title="url.password"></a>url.password</h3><pre><code>作用：获取及设置URL的密码(password)部分。
    myURL.password; // pass
</code></pre><h3 id="url-pathname"><a href="#url-pathname" class="headerlink" title="url.pathname"></a>url.pathname</h3><pre><code>作用：获取及设置URL的路径(path)部分。
    myURL.pathname; // /p/a/t/h
</code></pre><h3 id="url-port"><a href="#url-port" class="headerlink" title="url.port"></a>url.port</h3><pre><code>作用：获取及设置URL的端口(port)部分。
    myURL.port; 8080
</code></pre><h3 id="url-protocol"><a href="#url-protocol" class="headerlink" title="url.protocol"></a>url.protocol</h3><pre><code>作用：获取及设置URL的协议(protocol)部分。
    myURL.protocol; // https
</code></pre><h3 id="url-search"><a href="#url-search" class="headerlink" title="url.search"></a>url.search</h3><pre><code>作用：获取及设置URL的序列化查询(query)部分部分。
    myURL.search; // ?query=string
</code></pre><h3 id="url-searchParams"><a href="#url-searchParams" class="headerlink" title="url.searchParams"></a>url.searchParams</h3><pre><code>作用：获取表示URL查询参数的URLSearchParams对象。该属性是只读的；
    myURL.searchParams; // 
</code></pre><h3 id="url-username"><a href="#url-username" class="headerlink" title="url.username"></a>url.username</h3><pre><code>作用：获取及设置URL的用户名(username)部分。
    myURL.username; // user
</code></pre><h3 id="url-toString"><a href="#url-toString" class="headerlink" title="url.toString()"></a>url.toString()</h3><pre><code>作用：在URL对象上调用toString()方法将返回序列化的URL。返回值与url.href和url.toJSON()的相同。
    如果需要更大灵活性，require(&apos;url&apos;).format()可能更合适。
</code></pre><h3 id="url-toJSON"><a href="#url-toJSON" class="headerlink" title="url.toJSON()"></a>url.toJSON()</h3><pre><code>在URL对象上调用toJSON()方法将返回序列化的URL。
</code></pre><h3 id="Constructor-new-URLSearchParams-obj"><a href="#Constructor-new-URLSearchParams-obj" class="headerlink" title="Constructor: new URLSearchParams(obj)"></a>Constructor: new URLSearchParams(obj)</h3><pre><code>通过使用查询哈希映射实例化一个新的URLSearchParams对象，obj的每一个属性的键和值将被强制转换为字符串。
urlSearchParams.append(name, value)
    在查询字符串中附加一个新的键值对。
urlSearchParams.entries()
    返回: &lt;Iterator&gt; 在查询中的每个键值对上返回一个ES6迭代器。
urlSearchParams.forEach(fn[, thisArg])
    在查询字符串中迭代每个键值对，并调用给定的函数。
urlSearchParams.get(name)
    返回键是name的第一个键值对的值。如果没有对应的键值对，则返回null。
urlSearchParams.getAll(name)
    返回键是name的所有键值对的值，如果没有满足条件的键值对，则返回一个空的数组。
urlSearchParams.has(name)
    如果存在至少一对键是name的键值对则返回 true。
urlSearchParams.keys()
    在每一个键值对上返回一个键的ES6迭代器。
urlSearchParams.set(name, value)
    将URLSearchParams对象中与name相对应的值设置为value。
urlSearchParams.sort()    
    按现有名称就地排列所有的名称-值对。    
urlSearchParams.toString()    
    返回查询参数序列化后的字符串，必要时存在百分号编码字符。
urlSearchParams.values()
    在每一个键值对上返回一个值的ES6迭代器。
urlSearchParams[@@iterator]()    
    返回在查询字符串中每一个键值对的ES6迭代器。
url.domainToASCII(domain)    
    返回Punycode ASCII序列化的domain. 如果domain是无效域名，将返回空字符串。
url.domainToUnicode(domain)    
    返回Unicode序列化的domain. 如果domain是无效域名，将返回空字符串。
url.format(URL[, options])    
    返回一个WHATWG URL对象的可自定义序列化的URL字符串表达。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/url.html" target="_blank" rel="external">url参考-api</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;url-模块提供了一些实用函数，用于-URL-处理与解析。&quot;&gt;&lt;a href=&quot;#url-模块提供了一些实用函数，用于-URL-处理与解析。&quot; class=&quot;headerlink&quot; title=&quot;url 模块提供了一些实用函数，用于 URL 处理与解析。&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>全局变量-global</title>
    <link href="https://fanerge.github.io/2017/09/16/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>https://fanerge.github.io/2017/09/16/nodejs自带模块-全局变量/</id>
    <published>2017-09-16T03:49:36.000Z</published>
    <updated>2017-09-17T04:52:02.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="global-全局变量"><a href="#global-全局变量" class="headerlink" title="global - 全局变量"></a>global - 全局变量</h3><pre><code>global - 全局变量，相当于浏览器环境下的window对象。
</code></pre><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><pre><code>作用：处理二进制数据。
</code></pre><h3 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h3><pre><code>作用：当前模块的文件夹名称。等同于 __filename 的 path.dirname() 的值。
</code></pre><h3 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h3><pre><code>作用：当前模块的文件名称---解析后的绝对路径。
</code></pre><h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><pre><code>作用：用于打印 stdout 和 stderr。
</code></pre><h4 id="关于module-exports-与-exports的区别"><a href="#关于module-exports-与-exports的区别" class="headerlink" title="关于module.exports 与 exports的区别"></a>关于module.exports 与 exports的区别</h4><ol>
<li>module.exports<br>导出：<br>  module.exports= {<pre><code>methodName,
</code></pre>  };<br>引用：<br>  const {methodName} = require(‘path’);    </li>
<li>exports<br>导出：<br>  exports.methodName = function () {…};<br>引用：<br>  const {methodName} = require(‘path’);<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3>作用：导出一个对象。<br>module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容。<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3>作用：导出一个方法，为module.exports的简写形式。<br>每一个node.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是 {}<br>Module.exports本身不具备任何属性和方法。如果，Module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。<h3 id="require-path"><a href="#require-path" class="headerlink" title="require(path)"></a>require(path)</h3>作用：引入模块。<h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3>作用：全局的命名空间对象。<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3>作用：进程对象。<h3 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[, …args])"></a>setImmediate(callback[, …args])</h3>作用：创建 Immediate 对象。<h3 id="clearImmediate-immediateObject"><a href="#clearImmediate-immediateObject" class="headerlink" title="clearImmediate(immediateObject)"></a>clearImmediate(immediateObject)</h3>作用：取消一个由 setImmediate() 创建的 Immediate 对象。<h3 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a>setInterval(callback, delay[, …args])</h3>作用：创建 Timeout 对象。<h3 id="clearInterval-timeoutObject"><a href="#clearInterval-timeoutObject" class="headerlink" title="clearInterval(timeoutObject)"></a>clearInterval(timeoutObject)</h3>作用：取消一个由 setInterval() 创建的 Timeout 对象。<h3 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a>setTimeout(callback, delay[, …args])</h3>作用：创建 Timeout 对象。<h3 id="clearTimeout-timeoutObject"><a href="#clearTimeout-timeoutObject" class="headerlink" title="clearTimeout(timeoutObject)"></a>clearTimeout(timeoutObject)</h3>作用：取消一个由 setTimeout() 创建的 Timeout 对象。<blockquote>
<p>   参考文档：<br><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="external">global参考-api</a></p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;global-全局变量&quot;&gt;&lt;a href=&quot;#global-全局变量&quot; class=&quot;headerlink&quot; title=&quot;global - 全局变量&quot;&gt;&lt;/a&gt;global - 全局变量&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;global - 全局变量，相当于浏览器环境
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>fs模块-文件</title>
    <link href="https://fanerge.github.io/2017/09/16/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-fs/"/>
    <id>https://fanerge.github.io/2017/09/16/nodejs自带模块学习-fs/</id>
    <published>2017-09-16T02:18:38.000Z</published>
    <updated>2017-09-16T07:07:51.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fs模块-文件系统"><a href="#fs模块-文件系统" class="headerlink" title="fs模块-文件系统"></a>fs模块-文件系统</h3><pre><code>以下方法均有同步和异步版本
说明：文件 I/O 是对标准 POSIX 函数的简单封装。 通过 require(&apos;fs&apos;) 使用该模块。 所有的方法都有异步和同步的形式。
异步方法的最后一个参数都是一个回调函数。 传给回调函数的参数取决于具体方法，但回调函数的第一个参数都会保留给异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。
步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。
</code></pre><h3 id="异步的删除文件"><a href="#异步的删除文件" class="headerlink" title="异步的删除文件"></a>异步的删除文件</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.unlink(&apos;tmp/hello&apos;, function (err) &#123;</div><div class="line">	if (err) throw err;</div><div class="line">	console.log(&apos;删除成功&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="同步的删除文件"><a href="#同步的删除文件" class="headerlink" title="同步的删除文件"></a>同步的删除文件</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">	fs.unlinkSync(&apos;tmp/hello&apos;);</div><div class="line">&#125;catch (e) &#123;</div><div class="line">	console.error(e);</div><div class="line">&#125;</div><div class="line">console.log(&apos;删除成功&apos;);</div></pre></td></tr></table></figure>
</code></pre><h3 id="fs-contants"><a href="#fs-contants" class="headerlink" title="fs.contants"></a>fs.contants</h3><pre><code>作用：返回一个包含常用文件系统操作的常量的对象。FRWX（可见、读、写、执行）
</code></pre><h3 id="fs-FSWatcher-类"><a href="#fs-FSWatcher-类" class="headerlink" title="fs.FSWatcher 类"></a>fs.FSWatcher 类</h3><pre><code>作用：从 fs.watch() 返回的对象是该类型。
方法：change、error、close分别代表监视目录或文件的改变和出错和关闭监视。
    fs.watch(&apos;./tmp&apos;, (eventType, filename) =&gt; {
        if (filename) { console.log(filename); }
    });
</code></pre><h3 id="fs-ReadStream-类"><a href="#fs-ReadStream-类" class="headerlink" title="fs.ReadStream 类"></a>fs.ReadStream 类</h3><pre><code>作用：ReadStream 是一个可读流。
属性：
    readStream.bytesRead - 已读取的字节数。
    readStream.path - 流正在读取的文件的路径，指定在 fs.createReadStream() 的第一个参数
方法：open、close分别对应ReadStream文件fs.open()被打开和fs.close()被关闭时触发。
</code></pre><h3 id="fs-Stats-类"><a href="#fs-Stats-类" class="headerlink" title="fs.Stats 类"></a>fs.Stats 类</h3><pre><code>从 fs.stat()、fs.lstat() 和 fs.fstat() 及其同步版本返回的对象都是该类型。
stats.isFile()
stats.isDirectory()
stats.isBlockDevice()
stats.isCharacterDevice()
stats.isSymbolicLink() (仅对 fs.lstat() 有效)
stats.isFIFO()
stats.isSocket()
</code></pre><h3 id="Stat-时间值"><a href="#Stat-时间值" class="headerlink" title="Stat 时间值"></a>Stat 时间值</h3><pre><code>atime &quot;访问时间&quot; - 文件数据最近被访问的时间。
mtime &quot;修改时间&quot; - 文件数据最近被修改的时间。
ctime &quot;变化时间&quot; - 文件状态最近更改的时间。
birthtime &quot;创建时间&quot; - 文件创建的时间。 
</code></pre><h3 id="fs-WriteStream类"><a href="#fs-WriteStream类" class="headerlink" title="fs.WriteStream类"></a>fs.WriteStream类</h3><pre><code>作用：WriteStream 一个可写流。
属性：
    writeStream.bytesWritten - 已写入的字节数。 不包括仍在排队等待写入的数据。
    writeStream.path - 流正在写入的文件的路径，指定在 fs.createWriteStream() 的第一个参数。
方法：
    open() - 当 WriteStream 文件被打开时触发。
    close() - 当 WriteStream 底层的文件描述符已被使用 fs.close() 方法关闭时触发。
</code></pre><h3 id="fs-access-path-mode-callback"><a href="#fs-access-path-mode-callback" class="headerlink" title="fs.access(path[, mode], callback);"></a>fs.access(path[, mode], callback);</h3><pre><code>作用：判断用户是否有权限操作给定的目录或者是文件。
    如果要检查一个文件是否存在且不操作它。
mode参数的可选项：
    fs.constants.F_OK - path 文件对调用进程可见（默认）。
    fs.constants.R_OK - path 文件可被调用进程读取。
    fs.constants.W_OK - path 文件可被调用进程写入。
    fs.constants.X_OK - path 文件可被调用进程执行。
</code></pre><h3 id="fs-accessSync-path-mode"><a href="#fs-accessSync-path-mode" class="headerlink" title="fs.accessSync(path[, mode]);"></a>fs.accessSync(path[, mode]);</h3><pre><code>fs.access() 的同步版本。
</code></pre><h3 id="fs-appendFile-file-data-options-callback"><a href="#fs-appendFile-file-data-options-callback" class="headerlink" title="fs.appendFile(file, data[, options], callback);"></a>fs.appendFile(file, data[, options], callback);</h3><pre><code>作用：异步地追加数据到一个文件，如果文件不存在则创建文件。
fs.appendFile(&apos;filename.txt&apos;, &apos;data to append&apos; , (err) =&gt; {
    if (err) throw err;
    console.log(&apos;添加成功&apos;);
});
</code></pre><h3 id="fs-chmod-path-mode-callback"><a href="#fs-chmod-path-mode-callback" class="headerlink" title="fs.chmod(path, mode, callback);"></a>fs.chmod(path, mode, callback);</h3><pre><code>作用： 更改文件属性（存取模式）(mode)。
</code></pre><h3 id="fs-chown-path-uid-gid-callback"><a href="#fs-chown-path-uid-gid-callback" class="headerlink" title="fs.chown(path, uid, gid, callback);"></a>fs.chown(path, uid, gid, callback);</h3><pre><code>作用：修改文件目录属主。用户ID，群体身份（共享资源系统使用者的身份）
</code></pre><h3 id="fs-close-fd-callback"><a href="#fs-close-fd-callback" class="headerlink" title="fs.close(fd, callback);"></a>fs.close(fd, callback);</h3><pre><code>作用：关闭已打开的文件。
</code></pre><h3 id="fs-createReadStream-path-options"><a href="#fs-createReadStream-path-options" class="headerlink" title="fs.createReadStream(path[, options]);"></a>fs.createReadStream(path[, options]);</h3><pre><code>作用：返回一个新建的ReadStream对象。
</code></pre><h3 id="fs-createWriteStream-path-options"><a href="#fs-createWriteStream-path-options" class="headerlink" title="fs.createWriteStream(path[, options]);"></a>fs.createWriteStream(path[, options]);</h3><pre><code>作用：返回一个新建的WriteStream对象。
</code></pre><h3 id="fs-existsSync-path"><a href="#fs-existsSync-path" class="headerlink" title="fs.existsSync(path);"></a>fs.existsSync(path);</h3><pre><code>作用： 判断文件是否存在的同步版，异步已经废弃了。
</code></pre><h3 id="fs-fchmod-fd-mode-callback"><a href="#fs-fchmod-fd-mode-callback" class="headerlink" title="fs.fchmod(fd, mode, callback);"></a>fs.fchmod(fd, mode, callback);</h3><pre><code>作用：更改文件权限（文件描述符）。
</code></pre><h3 id="fs-fchown-fd-uid-gid-callback"><a href="#fs-fchown-fd-uid-gid-callback" class="headerlink" title="fs.fchown(fd, uid, gid, callback);"></a>fs.fchown(fd, uid, gid, callback);</h3><pre><code>作用：更改文件所有权(文件描述符)。
</code></pre><h3 id="fs-fdatasync-fd-callback"><a href="#fs-fdatasync-fd-callback" class="headerlink" title="fs.fdatasync(fd, callback);"></a>fs.fdatasync(fd, callback);</h3><pre><code>作用：刷新数据到磁盘。
</code></pre><h3 id="fs-fstat-fd-callback"><a href="#fs-fstat-fd-callback" class="headerlink" title="fs.fstat(fd, callback);"></a>fs.fstat(fd, callback);</h3><pre><code>作用：返回文件的详细信息。
</code></pre><h3 id="fs-fsync-fd-callback"><a href="#fs-fsync-fd-callback" class="headerlink" title="fs.fsync(fd, callback);"></a>fs.fsync(fd, callback);</h3><pre><code>作用：同步缓存数据到磁盘。
</code></pre><h3 id="fs-ftruncate-fd-len-callback"><a href="#fs-ftruncate-fd-len-callback" class="headerlink" title="fs.ftruncate(fd, len, callback);"></a>fs.ftruncate(fd, len, callback);</h3><pre><code>作用：截取文件内容。
</code></pre><h3 id="fs-futimes-fd-atime-mtime-callback"><a href="#fs-futimes-fd-atime-mtime-callback" class="headerlink" title="fs.futimes(fd, atime, mtime, callback);"></a>fs.futimes(fd, atime, mtime, callback);</h3><pre><code>作用：更改一个文件所提供的文件描述符引用的文件的时间戳。
</code></pre><h3 id="fs-lchmod-path-mode-callback"><a href="#fs-lchmod-path-mode-callback" class="headerlink" title="fs.lchmod(path, mode, callback);"></a>fs.lchmod(path, mode, callback);</h3><pre><code>作用：更改文件权限(不解析符号链接)。
</code></pre><h3 id="fs-lchown-path-uid-gid-callback"><a href="#fs-lchown-path-uid-gid-callback" class="headerlink" title="fs.lchown(path, uid, gid, callback)"></a>fs.lchown(path, uid, gid, callback)</h3><pre><code>作用：更改文件所有权（不解析符号链接）。
</code></pre><h3 id="fs-link-existingPath-newPath-callback"><a href="#fs-link-existingPath-newPath-callback" class="headerlink" title="fs.link(existingPath, newPath, callback);"></a>fs.link(existingPath, newPath, callback);</h3><pre><code>作用：创建硬链接(只能在本券中)。
</code></pre><h3 id="fs-lstat-path-callback"><a href="#fs-lstat-path-callback" class="headerlink" title="fs.lstat(path, callback);"></a>fs.lstat(path, callback);</h3><pre><code>作用：获取文件信息(不解析符号链接)。
</code></pre><h3 id="fs-mkdir-path-mode-callback"><a href="#fs-mkdir-path-mode-callback" class="headerlink" title="fs.mkdir(path[, mode], callback);"></a>fs.mkdir(path[, mode], callback);</h3><pre><code>作用：创建文件目录，如果目录已存在，将抛出异常。
</code></pre><h3 id="fs-mkdtemp-prefix-options-callback"><a href="#fs-mkdtemp-prefix-options-callback" class="headerlink" title="fs.mkdtemp(prefix[, options], callback);"></a>fs.mkdtemp(prefix[, options], callback);</h3><pre><code>作用：创建临时目录。
</code></pre><h3 id="fs-open-path-flags-mode-callback"><a href="#fs-open-path-flags-mode-callback" class="headerlink" title="fs.open(path, flags[, mode], callback);"></a>fs.open(path, flags[, mode], callback);</h3><pre><code>作用：打开文件。
</code></pre><h3 id="fs-read-fd-buffer-offset-length-position-callback"><a href="#fs-read-fd-buffer-offset-length-position-callback" class="headerlink" title="fs.read(fd, buffer, offset, length, position, callback);"></a>fs.read(fd, buffer, offset, length, position, callback);</h3><pre><code>作用：读取文件内容。
</code></pre><h3 id="fs-readdir-path-options-callback"><a href="#fs-readdir-path-options-callback" class="headerlink" title="fs.readdir(path[, options], callback);"></a>fs.readdir(path[, options], callback);</h3><pre><code>作用：读取文件目录。
</code></pre><h3 id="fs-readFile-path-options-callback"><a href="#fs-readFile-path-options-callback" class="headerlink" title="fs.readFile(path[, options], callback);"></a>fs.readFile(path[, options], callback);</h3><pre><code>作用：读取文件。
</code></pre><h3 id="fs-readlink-path-options-callback"><a href="#fs-readlink-path-options-callback" class="headerlink" title="fs.readlink(path[, options], callback);"></a>fs.readlink(path[, options], callback);</h3><pre><code>作用：读取软连接信息。
</code></pre><h3 id="fs-readSync-fd-buffer-offset-length-position"><a href="#fs-readSync-fd-buffer-offset-length-position" class="headerlink" title="fs.readSync(fd, buffer, offset, length, position);"></a>fs.readSync(fd, buffer, offset, length, position);</h3><pre><code>作用：读取文件内容，返回字节数。
</code></pre><h3 id="fs-realpath-path-options-callback"><a href="#fs-realpath-path-options-callback" class="headerlink" title="fs.realpath(path[, options], callback);"></a>fs.realpath(path[, options], callback);</h3><pre><code>作用：获取真实路径。
</code></pre><h3 id="fs-rename-oldPath-newPath-callback"><a href="#fs-rename-oldPath-newPath-callback" class="headerlink" title="fs.rename(oldPath, newPath, callback);"></a>fs.rename(oldPath, newPath, callback);</h3><pre><code>作用：重命名路径。
</code></pre><h3 id="fs-rmdir-path-callback"><a href="#fs-rmdir-path-callback" class="headerlink" title="fs.rmdir(path, callback);"></a>fs.rmdir(path, callback);</h3><pre><code>作用：删除文件目录。
</code></pre><h3 id="fs-stat-path-callback"><a href="#fs-stat-path-callback" class="headerlink" title="fs.stat(path, callback);"></a>fs.stat(path, callback);</h3><pre><code>作用：获取文件信息。
</code></pre><h3 id="fs-symlink-target-path-type-callback"><a href="#fs-symlink-target-path-type-callback" class="headerlink" title="fs.symlink(target, path[, type], callback);"></a>fs.symlink(target, path[, type], callback);</h3><pre><code>作用：创建符号链接。
</code></pre><h3 id="fs-truncate-path-len-callback"><a href="#fs-truncate-path-len-callback" class="headerlink" title="fs.truncate(path[, len], callback);"></a>fs.truncate(path[, len], callback);</h3><pre><code>作用：文件内容截取操作。
</code></pre><h3 id="fs-unlink-path-callback"><a href="#fs-unlink-path-callback" class="headerlink" title="fs.unlink(path, callback);"></a>fs.unlink(path, callback);</h3><pre><code>作用：删除文件操作。
</code></pre><h3 id="fs-unwatchFile-filename-listener"><a href="#fs-unwatchFile-filename-listener" class="headerlink" title="fs.unwatchFile(filename[, listener]);"></a>fs.unwatchFile(filename[, listener]);</h3><pre><code>作用：解除文件监听。
</code></pre><h3 id="fs-utimes-path-atime-mtime-callback"><a href="#fs-utimes-path-atime-mtime-callback" class="headerlink" title="fs.utimes(path, atime, mtime, callback);"></a>fs.utimes(path, atime, mtime, callback);</h3><pre><code>作用：修改文件时间戳。
</code></pre><h3 id="fs-watch-filename-options-listener"><a href="#fs-watch-filename-options-listener" class="headerlink" title="fs.watch(filename[, options][, listener]);"></a>fs.watch(filename[, options][, listener]);</h3><pre><code>作用：监控文件。
</code></pre><h3 id="fs-watchFile-filename-options-listener"><a href="#fs-watchFile-filename-options-listener" class="headerlink" title="fs.watchFile(filename[, options], listener);"></a>fs.watchFile(filename[, options], listener);</h3><pre><code>作用：监控文件。
</code></pre><h3 id="fs-write-fd-buffer-offset-length-position-callback"><a href="#fs-write-fd-buffer-offset-length-position-callback" class="headerlink" title="fs.write(fd, buffer[, offset[, length[, position]]], callback);"></a>fs.write(fd, buffer[, offset[, length[, position]]], callback);</h3><pre><code>作用：向文件写数据。
</code></pre><h3 id="fs-writeFile-file-data-options-callback"><a href="#fs-writeFile-file-data-options-callback" class="headerlink" title="fs.writeFile(file, data[, options], callback);"></a>fs.writeFile(file, data[, options], callback);</h3><pre><code>作用：向文件写数据。        
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/fs.html" target="_blank" rel="external">fs参考-api</a><br>    <a href="http://blog.csdn.net/zza000000/article/details/54341943" target="_blank" rel="external">fs模块</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;fs模块-文件系统&quot;&gt;&lt;a href=&quot;#fs模块-文件系统&quot; class=&quot;headerlink&quot; title=&quot;fs模块-文件系统&quot;&gt;&lt;/a&gt;fs模块-文件系统&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;以下方法均有同步和异步版本
说明：文件 I/O 是对标准 POSIX
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>util模块-工具</title>
    <link href="https://fanerge.github.io/2017/09/16/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-util/"/>
    <id>https://fanerge.github.io/2017/09/16/nodejs自带模块学习-util/</id>
    <published>2017-09-16T02:18:15.000Z</published>
    <updated>2017-09-16T07:08:11.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="util模块"><a href="#util模块" class="headerlink" title="util模块"></a>util模块</h3><pre><code>说明：util 模块主要用于支持 Node.js 内部 API 的需求。 大部分实用工具也可用于应用程序与模块开发者。
</code></pre><h3 id="util-callbackify-original"><a href="#util-callbackify-original" class="headerlink" title="util.callbackify(original)"></a>util.callbackify(original)</h3><h3 id="util-debuglog-section"><a href="#util-debuglog-section" class="headerlink" title="util.debuglog(section)"></a>util.debuglog(section)</h3><pre><code>作用：util.debuglog() 方法用于创建一个函数，基于 NODE_DEBUG 环境变量的存在与否有条件地写入调试信息到 stderr。
    const debuglog = util.debuglog(&apos;foo&apos;);
    debuglog(&apos;hello from foo [%d]&apos;, 123);
    若程序的环境运行是带上NODE_DEBUG=foo,则FOO 3245: hello from foo [123]
    3234是进程id
</code></pre><h3 id="util-deprecate-function-string"><a href="#util-deprecate-function-string" class="headerlink" title="util.deprecate(function, string)"></a>util.deprecate(function, string)</h3><pre><code>作用：util.deprecate() 方法会包装给定的 function 或类，并标记为废弃的。
    // 在util模块中
    exports.puts = util.deprecate(function() {
      for (let i = 0, len = arguments.length; i &lt; len; ++i) {
        process.stdout.write(arguments[i] + &apos;\n&apos;);
      }
    }, &apos;util.puts: 使用 console.log 代替&apos;);
</code></pre><h3 id="util-format-format-…args"><a href="#util-format-format-…args" class="headerlink" title="util.format(format[, …args])"></a>util.format(format[, …args])</h3><pre><code>作用：返回一个格式化后的字符串，使用第一个参数作为一个类似 printf 的格式。
对应的占位符：
    %s - 字符串
    %d - 数值
    %i - Integer
    %f - Float
    %j - JSON
    %o - Object
    %% - 单个百分号（&apos;%&apos;）。不消耗参数。
    util.format(&apos;%s:%d&apos;, &apos;fan&apos;, 100); // &apos;fan:100&apos;
</code></pre><h3 id="util-inherits-constructor-superConstructor"><a href="#util-inherits-constructor-superConstructor" class="headerlink" title="util.inherits(constructor, superConstructor)"></a>util.inherits(constructor, superConstructor)</h3><pre><code>注意，不建议使用 util.inherits()。 请使用 ES6 的 class 和 extends 关键词获得语言层面的继承支持。
作用：从一个构造函数中继承原型方法到另一个。 constructor 的原型会被设置到一个从 superConstructor 创建的新对象上。
    util.inherits(MyStream, EventEmitter);
</code></pre><h3 id="util-inspect-object-options"><a href="#util-inspect-object-options" class="headerlink" title="util.inspect(object[, options])"></a>util.inspect(object[, options])</h3><pre><code>作用：返回 object 的字符串表示，主要用于调试。 附加的 options 可用于改变格式化字符串的某些方面。
</code></pre><h3 id="自定义-util-inspect-颜色"><a href="#自定义-util-inspect-颜色" class="headerlink" title="自定义 util.inspect 颜色"></a>自定义 util.inspect 颜色</h3><pre><code>作用：可以通过 util.inspect.styles 和 util.inspect.colors 属性全局地自定义 util.inspect 的颜色输出（如果已启用）。
</code></pre><h3 id="util-inspect-custom"><a href="#util-inspect-custom" class="headerlink" title="util.inspect.custom"></a>util.inspect.custom</h3><pre><code>作用：可被用于声明自定义的查看函数。
</code></pre><h3 id="util-inspect-defaultOptions"><a href="#util-inspect-defaultOptions" class="headerlink" title="util.inspect.defaultOptions"></a>util.inspect.defaultOptions</h3><pre><code>作用：defaultOptions 值允许对被 util.inspect 使用的默认选项进行自定义。
</code></pre><h3 id="util-promisify-original"><a href="#util-promisify-original" class="headerlink" title="util.promisify(original)"></a>util.promisify(original)</h3><pre><code>作用：让一个遵循通常的让一个遵循通常的 Node.js 回调风格的函数， 即 (err, value) =&gt; ... 回调函数是最后一个参数, 返回一个返回值是一个 promise 版本的函数。    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/util.html" target="_blank" rel="external">util参考-api</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;util模块&quot;&gt;&lt;a href=&quot;#util模块&quot; class=&quot;headerlink&quot; title=&quot;util模块&quot;&gt;&lt;/a&gt;util模块&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;说明：util 模块主要用于支持 Node.js 内部 API 的需求。 大部分实用工具也可
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>path模块-路径</title>
    <link href="https://fanerge.github.io/2017/09/16/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-path/"/>
    <id>https://fanerge.github.io/2017/09/16/nodejs自带模块学习-path/</id>
    <published>2017-09-16T02:16:31.000Z</published>
    <updated>2017-09-16T02:25:40.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="path模块-路径"><a href="#path模块-路径" class="headerlink" title="path模块-路径"></a>path模块-路径</h3><pre><code>在不同系统中，路径分隔符显示不同。POSIX 上的 / 与 Windows 上的 \
说明：path 模块提供了一些工具函数，用于处理文件与目录的路径。
</code></pre><h3 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h3><pre><code>作用：提供了平台特定的路径片段分隔符。
    windows上是 \
    POSIX上是 /
</code></pre><h3 id="path-win32-和-path-posix"><a href="#path-win32-和-path-posix" class="headerlink" title="path.win32 和 path.posix"></a>path.win32 和 path.posix</h3><pre><code>要想在任何操作系统上处理 Windows 文件路径时获得一致的结果，可以使用 path.win32
    path.win32.basename(&apos;c:\\temp\\myfile.html&apos;); // myfile.html
要想在任何操作系统上处理 POSIX 文件路径时获得一致的结果，可以使用 path.posix
    path.posix.basename(&apos;/temp/myfile.html&apos;); // myfile.html
</code></pre><h3 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h3><pre><code>作用：提供平台特定的路径分隔符。
    windows是;
    POSIX是:
    process.env.PATH; // &apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&apos;
    process.env.PATH.split(path.delimiter); // [&apos;/usr/bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin&apos;, &apos;/sbin&apos;, &apos;/usr/local/bin&apos;]
</code></pre><h3 id="path-basename-path-ext"><a href="#path-basename-path-ext" class="headerlink" title="path.basename(path[, ext]);"></a>path.basename(path[, ext]);</h3><pre><code>作用：返回一个 path 的最后一部分。
    path.basename(&apos;/foo/bar/myfile.html&apos;); // &apos;myfile.html&apos;
    patn.basename(&apos;/foo/bar/myfile.html&apos;, &apos;.html&apos;); // &apos;myfile&apos;
</code></pre><h3 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path);"></a>path.dirname(path);</h3><pre><code>作用：返回一个path的目录名。
    path.dirname(&apos;/foo/bar/myfile&apos;); // foo/bar
</code></pre><h3 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h3><pre><code>作用：返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。
    path.extname(&apos;index.coffee.md&apos;); // &apos;.md&apos;
</code></pre><h3 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject);"></a>path.format(pathObject);</h3><pre><code>作用：会从一个对象返回一个路径字符串。 与 path.parse() 相反。
参数：Object
    {
        dir: &apos;&apos;,
        root: &apos;&apos;,
        base: &apos;&apos;,
        name: &apos;&apos;,
        ext: &apos;&apos;
    }
    在windows中
    path.format({
        root: &apos;ignored&apos;,
        dir: &apos;\home\user&apos;,
        base: &apos;file.txt&apos;
    });
    // &apos;\home\user\file.txt&apos;
</code></pre><h3 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path);"></a>path.parse(path);</h3><pre><code>作用：返回一个对象，对象的属性表示 path 的元素。
    path.parse(&apos;/home/user/file.txt&apos;);
    // {
        root: &apos;/&apos;,
        base: &apos;/home/user&apos;,
        ext: &apos;.txt&apos;.
        name: &apos;file&apos;
    }
</code></pre><h3 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path);"></a>path.isAbsolute(path);</h3><pre><code>作用：会判定 path 是否为一个绝对路径。
    path.isAbsolute(&apos;bar\baz&apos;); // true
</code></pre><h3 id="path-join-…path"><a href="#path-join-…path" class="headerlink" title="path.join([…path]);"></a>path.join([…path]);</h3><pre><code>作用：使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。
    path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;); // 返回: &apos;/foo/bar/baz/asdf&apos;
</code></pre><h3 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path);"></a>path.normalize(path);</h3><pre><code>作用：规范化给定的 path，并解析 &apos;..&apos; 和 &apos;.&apos; 片段。
    path.normalize(&apos;/foo/bar/baz/asdf/quux/..&apos;); // &apos;/foo/bar/baz/asdf&apos;
</code></pre><h3 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to);"></a>path.relative(from, to);</h3><pre><code>作用：返回从 from 到 to 的相对路径（基于当前工作目录）。
    path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;);
    // &apos;../../impl/bbb&apos;
</code></pre><h3 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths]);"></a>path.resolve([…paths]);</h3><pre><code>作用：把一个路径或路径片段的序列解析为一个绝对路径。
    path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;); // &apos;/foo/bar/baz&apos;
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/path.html" target="_blank" rel="external">path参考-api</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;path模块-路径&quot;&gt;&lt;a href=&quot;#path模块-路径&quot; class=&quot;headerlink&quot; title=&quot;path模块-路径&quot;&gt;&lt;/a&gt;path模块-路径&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在不同系统中，路径分隔符显示不同。POSIX 上的 / 与 Wind
    
    </summary>
    
      <category term="NodeJS" scheme="https://fanerge.github.io/categories/NodeJS/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
      <category term="web开发" scheme="https://fanerge.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务端" scheme="https://fanerge.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>sql参考手册</title>
    <link href="https://fanerge.github.io/2017/09/14/sql%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"/>
    <id>https://fanerge.github.io/2017/09/14/sql参考手册/</id>
    <published>2017-09-14T14:21:26.000Z</published>
    <updated>2017-09-15T14:16:00.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND / OR"></a>AND / OR</h4><pre><code>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。
语法：SELECT column_name(s) FROM table_name WHERE condition AND|OR condition;
选择count大于10 且 count小于230
    SELECT * FROM access_log WHERE count &gt; 10 AND count &lt; 230
选择count小于10 或 count大于230    
    SELECT * FROM access_log WHERE count &lt; 10 OR count &gt; 230
</code></pre><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><pre><code>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。
语法：
    // 添加一列
    ALTER TABLE table_name  
    ADD column_name datatype 
    // 删除一列
    ALTER TABLE table_name   
    DROP COLUMN column_name
    // 更改一列字段类型    
    ALTER TABLE table_name   
    MODIFY COLUMN column_name VARCHAR(10)
    // 更改一列
    ALTER TABLE table_name   
    CHANGE COLUMN column_name re_name
</code></pre><h4 id="AS-alias"><a href="#AS-alias" class="headerlink" title="AS (alias)"></a>AS (alias)</h4><pre><code>SELECT column_name AS column_alias 
FROM table_name
OR
SELECT column_name
FROM table_name AS table_alias
对url改名为ii    
    SELECT url AS ii FROM websites
</code></pre><h4 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h4><pre><code>语法：
    SELECT column_name(s)
    FROM table_name
    WHERE column_name
    BETWEEN value1 AND value2
选择alexa1到10的所有记录
    SELECT * FROM websites WHERE alexa BETWEEN 1 AND 10    
</code></pre><h4 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a>CREATE DATABASE</h4><pre><code>语法：CREATE DATABASE database_name
创建IIII数据库    
    CREATE DATABASE IIII    
</code></pre><h4 id="DROP-DATABASE"><a href="#DROP-DATABASE" class="headerlink" title="DROP DATABASE"></a>DROP DATABASE</h4><pre><code>语法：DROP DATABASE database_name
删除IIII数据库
    DROP DATABASE IIII
</code></pre><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h4><pre><code>语法：
    CREATE TABLE table_name (
        column_name data_type,
        column_name data_type,
        ...
    )
创建一个名为 sds 的表，且有字段int    
    CREATE TABLE sds (id int)
</code></pre><h4 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h4><pre><code>语法：DROP TABLE IF EXISTS tabale_name
如果表sds存在就删除
    DROP TABLE IF EXISTS sds
</code></pre><h4 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h4><pre><code>创建索引
语法：
    CREATE INDEX index_name
    ON tabale_name (column_name)
    OR
    CREATE UNIQUE INDEX index_name
    ON tabale_name (column_name)
</code></pre><h4 id="CREATE-VIEW"><a href="#CREATE-VIEW" class="headerlink" title="CREATE VIEW"></a>CREATE VIEW</h4><pre><code>创建视图
视图是基于 SQL 语句的结果集的可视化的表。
语法：
    CREATE VIEW view_name AS
    SELECT column_name(s)
    FROM tabale_name
</code></pre><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><pre><code>DELETE FROM tabale_name
WHERE some_column = some_value
OR
DELETE FROM tabale_name // 删除整个表
DELETE * FROM tabale_name
</code></pre><h4 id="DROP-DATABASE-1"><a href="#DROP-DATABASE-1" class="headerlink" title="DROP DATABASE"></a>DROP DATABASE</h4><pre><code>删除数据库
DROP DATABASE data_name
</code></pre><h4 id="DROP-INDEX"><a href="#DROP-INDEX" class="headerlink" title="DROP INDEX"></a>DROP INDEX</h4><pre><code>删除索引
DROP INDEX index_name
</code></pre><h4 id="DROP-TABLE-1"><a href="#DROP-TABLE-1" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h4><pre><code>删除表
DROP TABLE table_name
</code></pre><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><pre><code>合计函数 (比如 SUM) 常常需要添加 GROUP BY 语句。
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value1
GROUP BY column_name
</code></pre><h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><pre><code>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。    
SELECT column_name, aggregate_function(column_name)
FROM tabale_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value
</code></pre><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><pre><code>IN 操作符允许您在 WHERE 子句中规定多个值。
SELECT column_name(s)
FROM tabale_name
WHERE column_name
IN(value1, value2)
</code></pre><h4 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h4><pre><code>插入数据
INSERT INTO tabale_name
VALUES(value1, value2, ...value3)
OR    
INSERT INTO tabale_name
(column1, column2, ...column3)
VALUES(value1, value2, ...value3)
</code></pre><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><pre><code>在表中存在至少一个匹配时，INNER JOIN 关键字返回行。    
SELECT column_name(s)
FROM tabale_name1
INNER JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name
</code></pre><h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><pre><code>返回左表
SELECT column_name(s)
FROM tabale_name1
LEFT JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name
</code></pre><h4 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h4><pre><code>返回左表
SELECT column_name(s)
FROM tabale_name1
RIGHT JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name        
</code></pre><h4 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h4><pre><code>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。    
SELECT column_name(s)
FROM tabale_name1
FULL JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name
</code></pre><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><pre><code>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。    
SELECT column_name(s)
FROM tabale_name
WHERE column_name LIKE pattern
</code></pre><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><pre><code>ORDER BY 语句用于对结果集进行排序。
SELECT column_name 
FROM table_name
ORDER BY column_name[ASC|DESC]
</code></pre><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><pre><code>查询
SELECT column_name(s)
FROM tabale_name
</code></pre><h4 id="SELECT-1"><a href="#SELECT-1" class="headerlink" title="SELECT *"></a>SELECT *</h4><pre><code>SELECT *
FROM tabale_name
</code></pre><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><pre><code>关键词 DISTINCT 用于返回唯一不同的值。    
SELECT DISTINCT column_name(s)
FROM tabale_name
</code></pre><h4 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h4><pre><code>SELECT *
INTO new_table_name [IN externaldatabase]
FROM old_table_name
OR
SELECT column_name(s)
INTO new_table_name [IN externaldatabase]
FROM old_table_name
</code></pre><h4 id="SELECT-TOP"><a href="#SELECT-TOP" class="headerlink" title="SELECT TOP"></a>SELECT TOP</h4><pre><code>SELECT column_name(s)
FROM table_name
LIMIT number
</code></pre><h4 id="TRUNCATE-TABLE"><a href="#TRUNCATE-TABLE" class="headerlink" title="TRUNCATE TABLE"></a>TRUNCATE TABLE</h4><pre><code>TRUNCATE TABLE table_name    
</code></pre><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><pre><code>SQL UNION 操作符合并两个或多个 SELECT 语句的结果。
SELECT column_name(s) FROM tabale_name1
UNION
SELECT column_name(s) FROM tabale_name2
</code></pre><h4 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h4><pre><code>SELECT column_name(s) FROM tabale_name1
UNION ALL
SELECT column_name(s) FROM tabale_name2
</code></pre><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><pre><code>更新
UPDATE tabale_name
SET column1=value, column2=value
WHERE some_column=some_value
</code></pre><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><pre><code>条件
SELECT column_name(s)
FROM tabale_name
WHERE column_name operator value
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/sql/sql-quickref.html" target="_blank" rel="external">SQL文档</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;AND-OR&quot;&gt;&lt;a href=&quot;#AND-OR&quot; class=&quot;headerlink&quot; title=&quot;AND / OR&quot;&gt;&lt;/a&gt;AND / OR&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;AND &amp;amp; OR 运算符用于基于一个以上的条件对记录进行过滤。
语法：SEL
    
    </summary>
    
      <category term="sql" scheme="https://fanerge.github.io/categories/sql/"/>
    
    
      <category term="数据库" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>sql函数学习</title>
    <link href="https://fanerge.github.io/2017/09/14/sql%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fanerge.github.io/2017/09/14/sql函数学习/</id>
    <published>2017-09-14T12:07:14.000Z</published>
    <updated>2017-09-14T13:44:47.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h3><pre><code>SQL 拥有很多可用于计数和计算的内建函数。
</code></pre><h4 id="SQL-Aggregate-函数"><a href="#SQL-Aggregate-函数" class="headerlink" title="SQL Aggregate 函数"></a>SQL Aggregate 函数</h4><pre><code>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。
AVG() - 返回平均值
COUNT() - 返回行数
FIRST() - 返回第一个记录的值
LAST() - 返回最后一个记录的值
MAX() - 返回最大值
MIN() - 返回最小值
SUM() - 返回总和
</code></pre><h4 id="SQL-Scalar-函数"><a href="#SQL-Scalar-函数" class="headerlink" title="SQL Scalar 函数"></a>SQL Scalar 函数</h4><pre><code>SQL Scalar 函数基于输入值，返回一个单一的值。
UCASE() - 将某个字段转换为大写
LCASE() - 将某个字段转换为小写
MID() - 从某个文本字段提取字符，MySql 中使用
SubString(字段，1，end) - 从某个文本字段提取字符
LEN() - 返回某个文本字段的长度
ROUND() - 对某个数值字段进行指定小数位数的四舍五入
NOW() - 返回当前的系统日期和时间
FORMAT() - 格式化某个字段的显示方式
</code></pre><h4 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h4><pre><code>一下实例中均使用数据库sql，表名为access_log
AVG() 函数返回数值列的平均值。
语法：SELECT AVG(column_name) FROM table_name;
1.返回count的平均值
    SELECT AVG(count) FROM access_log
2.返回大于count平均数的元组
    SELECT site_id, count FROM access_log
    WHERE count &gt; (SELECT AVG(count) FROM access_log);
</code></pre><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h4><pre><code>COUNT() 函数返回匹配指定条件的行数（NULL 不计入）。
语法：SELECT COUNT(column_name) FROM table_name; // COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）
    SELECT COUNT(DISTINCT column_name) FROM table_name; // COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目
1.返回表中记录数
    SELECT COUNT(*) FROM access_log
2.返回site_id = 3的记录拥有count的数量，并改名为nums
    SELECT COUNT(count) AS nums FROM access_log WHERE site_id = 3
3.计算 &quot;access_log&quot; 表中不同 site_id 的记录数
    SELECT COUNT(DISTINCT site_id) AS nums FROM access_log
</code></pre><h4 id="SQL-FIRST-函数"><a href="#SQL-FIRST-函数" class="headerlink" title="SQL FIRST() 函数"></a>SQL FIRST() 函数</h4><pre><code>FIRST() 函数返回指定的列中第一个记录的值。
注释：只有 MS Access 支持 FIRST() 函数。
语法：SELECT FIRST(column_name) FROM table_name;
MySQL 语法：
    SELECT column_name FROM table_name
    ORDER BY column_name ASC
    LIMIT 1;
1.mysql中获取第一条记录
    SELECT count FROM access_log ORDER BY count ASC LIMIT 1;
</code></pre><h4 id="SQL-LAST-函数"><a href="#SQL-LAST-函数" class="headerlink" title="SQL LAST() 函数"></a>SQL LAST() 函数</h4><pre><code>LAST() 函数返回指定的列中最后一个记录的值。
注释：只有 MS Access 支持 LAST() 函数。
语法：SELECT LAST(column_name) FROM table_name;
MySQL 语法：
    SELECT * FROM table_name 
    ORDER BY column_name ASC
    LIMIT 1;
1.mysql中获取最后一条记录
SELECT * FROM access_log ORDER BY count DESC LIMIT 1;
</code></pre><h4 id="SQL-MAX-函数"><a href="#SQL-MAX-函数" class="headerlink" title="SQL MAX() 函数"></a>SQL MAX() 函数</h4><pre><code>MAX() 函数返回指定列的最大值。
语法：SELECT MAX(column_name) FROM table_name;
1.返回count最大的一条记录
    SELECT * FROM access_log WHERE count = (SELECT MAX(count) FROM access_log)
</code></pre><h4 id="SQL-MIN-函数"><a href="#SQL-MIN-函数" class="headerlink" title="SQL MIN() 函数"></a>SQL MIN() 函数</h4><pre><code>MIN() 函数返回指定列的最小值。
语法：SELECT column_name FROM table_name;
1.返回count最小的一条记录中的aid 和 count字段
    SELECT aid, count FROM access_log WHERE count = (SELECT MIN(count) FROM access_log)
</code></pre><h4 id="SQL-SUM-函数"><a href="#SQL-SUM-函数" class="headerlink" title="SQL SUM() 函数"></a>SQL SUM() 函数</h4><pre><code>SUM() 函数返回数值列的总数。
语法：SELECT column_name FROM table_name;
1.返回count 的总和
    SELECT SUM(count) FROM access_log    
</code></pre><h4 id="SQL-GROUP-BY-语句"><a href="#SQL-GROUP-BY-语句" class="headerlink" title="SQL GROUP BY 语句"></a>SQL GROUP BY 语句</h4><pre><code>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。
语法：
    SELECT column_name, aggregate_function(column_name)
    FROM table_name
    WHERE column_name operator value
    GROUP BY column_name;
1.返回通过site_id分组对count求和
    SELECT site_id, SUM(access_log.count) AS nums 
    FROM access_log GROUP BY site_id
2.统计所有网站的访问的记录数（LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。）
SELECT websites.name, COUNT(access_log.aid) AS nums 
FROM access_log LEFT JOIN websites ON access_log.site_id = websites.id 
GROUP BY websites.name
</code></pre><h4 id="SQL-HAVING-子句"><a href="#SQL-HAVING-子句" class="headerlink" title="SQL HAVING 子句"></a>SQL HAVING 子句</h4><pre><code>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。
HAVING 子句可以让我们筛选分组后的各组数据。
1.现在我们想要查找总访问量大于 200 的网站
SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log
INNER JOIN Websites
ON access_log.site_id=Websites.id)
GROUP BY Websites.name
HAVING SUM(access_log.count) &gt; 200;
</code></pre><h4 id="SQL-UCASE-函数"><a href="#SQL-UCASE-函数" class="headerlink" title="SQL UCASE() 函数"></a>SQL UCASE() 函数</h4><pre><code>UCASE() 函数把字段的值转换为大写。
语法：SELECT UCASE(column_name) FROM table_name;
1.将某个列转化为大写
    SELECT UCASE(websites.url) AS url3 FROM websites
</code></pre><h4 id="SQL-LCASE-函数"><a href="#SQL-LCASE-函数" class="headerlink" title="SQL LCASE() 函数"></a>SQL LCASE() 函数</h4><pre><code>LCASE() 函数把字段的值转换为大写。
语法：SELECT LCASE(column_name) FROM table_name;
1.将某个列转化为小写
    SELECT LCASE(country) FROM websites
</code></pre><h4 id="SQL-MID-函数"><a href="#SQL-MID-函数" class="headerlink" title="SQL MID() 函数"></a>SQL MID() 函数</h4><pre><code>MID() 函数用于从文本字段中提取字符。
语法：SELECT MID(column_name, start [,length]) FROM table_name;
1.获取网站地址
    SELECT MID(websites.url, 4) FROM websites
</code></pre><h4 id="SQL-LEN-函数"><a href="#SQL-LEN-函数" class="headerlink" title="SQL LEN() 函数"></a>SQL LEN() 函数</h4><pre><code>LEN() 函数返回文本字段中值的长度。
语法：SELECT LEN(column_name) FROM table_name;
MySQL中函数为 LENGTH()
    SELECT LENGTH(column_name) FROM table_name;
1.获取网址长度
    SELECT LENGTH(websites.url) FROM websites;
</code></pre><h4 id="SQL-ROUND-函数"><a href="#SQL-ROUND-函数" class="headerlink" title="SQL ROUND() 函数"></a>SQL ROUND() 函数</h4><pre><code>ROUND() 函数用于把数值字段舍入为指定的小数位数。
语法：SELECT ROUND(column_name, decimals) FROM table_name;
1.对url四舍五入处理
    SELECT ROUND(url) FROM websites WHERE id=7;
</code></pre><h4 id="SQL-NOW-函数"><a href="#SQL-NOW-函数" class="headerlink" title="SQL NOW() 函数"></a>SQL NOW() 函数</h4><pre><code>NOW() 函数返回当前系统的日期和时间。
语法：SELECT NOW() FROM websites
</code></pre><h4 id="SQL-FORMAT-函数"><a href="#SQL-FORMAT-函数" class="headerlink" title="SQL FORMAT() 函数"></a>SQL FORMAT() 函数</h4><pre><code>FORMAT() 函数用于对字段的显示进行格式化。
语法：SELECT FORMAT(column_name, format) FROM table_name;
1.格式化日期
    SELECT name, url, DATE_FORMAT(Now(), &apos;%Y-%m-%d&apos;) AS date FROM websites
</code></pre><h4 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h4><pre><code>[SQL参考手册](http://www.runoob.com/sql/sql-quickref.html)
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/sql/sql-hosting.html" target="_blank" rel="external">SQL</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL-函数&quot;&gt;&lt;a href=&quot;#SQL-函数&quot; class=&quot;headerlink&quot; title=&quot;SQL 函数&quot;&gt;&lt;/a&gt;SQL 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;SQL 拥有很多可用于计数和计算的内建函数。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;SQ
    
    </summary>
    
      <category term="sql" scheme="https://fanerge.github.io/categories/sql/"/>
    
    
      <category term="数据库" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
