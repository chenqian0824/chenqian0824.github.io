<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余真帆的博客</title>
  
  <subtitle>一个专注于技术的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanerge.github.io/"/>
  <updated>2018-08-24T12:09:27.581Z</updated>
  <id>https://fanerge.github.io/</id>
  
  <author>
    <name>余真帆-fanerge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试收获</title>
    <link href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%94%B6%E8%8E%B7.html"/>
    <id>https://fanerge.github.io/2018/面试收获.html</id>
    <published>2018-08-23T11:54:43.000Z</published>
    <updated>2018-08-24T12:09:27.581Z</updated>
    
    <content type="html"><![CDATA[<p>记录今日头条各论面试中一些比较有意思的话题分享给大家，全程3轮视频面试。</p><h1 id="new操作符的工作原理"><a href="#new操作符的工作原理" class="headerlink" title="new操作符的工作原理"></a>new操作符的工作原理</h1><p>我们都知道 new 运算符是用来实例化一个类，从而在内存中分配一个实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let Person = function(name, age)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">&#125;</div><div class="line">Person.prototype.getAge = function()&#123;</div><div class="line">return this.age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：这里我先说明一下直接执行 Person 会返回 undefined，new Person(…) 会返回一个对象（即我们的this对象）。</p><h2 id="调用构造函数实际上会经历以下4个步骤"><a href="#调用构造函数实际上会经历以下4个步骤" class="headerlink" title="调用构造函数实际上会经历以下4个步骤"></a>调用构造函数实际上会经历以下4个步骤</h2><p>(1) 创建一个新对象<br>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象即类的实例）<br>(3) 执行构造函数中的代码（即为这个新对象添加属性）<br>(4) 返回新对象<br><a href="https://www.jb51.net/article/137370.htm" target="_blank" rel="external">如果不明白，请看前辈整理的文章</a></p><h1 id="JavaScript内部属性-Scope-与作用域链的理解"><a href="#JavaScript内部属性-Scope-与作用域链的理解" class="headerlink" title="JavaScript内部属性[[Scope]]与作用域链的理解"></a>JavaScript内部属性[[Scope]]与作用域链的理解</h1><h2 id="Scope-属性"><a href="#Scope-属性" class="headerlink" title="[[Scope]]属性"></a>[[Scope]]属性</h2><p>每一个 function 声明时都会有一个内部属性 [[Scope]]，例如声明 foo 函数会创建一个 foo.[[Scope]] 属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">function foo()&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">// 当我们的 foo 函数创建时，它的作用域链中插入了一个全局对象GO（Global Object），包含全局所有定义的变量</div><div class="line">// 伪代码</div><div class="line">foo.[[Scope]] = &#123;</div><div class="line">    GO: &#123;</div><div class="line">        this: window ,</div><div class="line">        window: ... ,</div><div class="line">        document: ... ,</div><div class="line">        ......</div><div class="line">        a: undefined, // 预编译阶段还不知道a值是多少</div><div class="line">        foo: function()&#123;...&#125;,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>在函数执行时，会创建一个叫做执行环境/执行上下文（execution context，下文均用EC表示）的内部对象（独一无二）。</p><h3 id="执行环境有以下特点"><a href="#执行环境有以下特点" class="headerlink" title="执行环境有以下特点"></a>执行环境有以下特点</h3><p>函数每次执行时的执行环境独一无二<br>多次调用同一函数就多次创建执行环境<br>并且函数执行完毕后，执行环境就会被销毁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// foo函数执行前，创建了执行期上下文（EC）</div><div class="line">// 首先取得foo内部[[Scope]]属性保存的作用域链（复制）到 EC 的底部</div><div class="line">// 然后foo函数执行前预编译产生了一个活动对象AO（Active Object），这个对象被推入EC作用域链的最前端</div><div class="line">// 伪代码：foo函数预编译产生AO活动对象，挂载到foo中EC作用域链的最前端</div><div class="line">foo.EC = &#123;</div><div class="line">    AO: &#123;</div><div class="line">        this: window,</div><div class="line">        arguments: [100,200],</div><div class="line">        x: 100,</div><div class="line">        y: 200,</div><div class="line">        b: undefined,</div><div class="line">        bar: function()&#123;...&#125;</div><div class="line">    &#125;,</div><div class="line">    GO: &#123;</div><div class="line">        this: window ,</div><div class="line">        window: ... ,</div><div class="line">        document: ... ,</div><div class="line">        a: 1,</div><div class="line">        foo: function()&#123;...&#125;,</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="案列分析"><a href="#案列分析" class="headerlink" title="案列分析"></a>案列分析</h2><p>这里我们来看一个稍微复杂一点的场景<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">function foo(x, y)&#123;</div><div class="line">    var b = 2;</div><div class="line">    function bar()&#123;</div><div class="line">        var c = 3;</div><div class="line">    &#125;</div><div class="line">    bar();</div><div class="line">&#125;</div><div class="line">foo(100, 200);</div></pre></td></tr></table></figure></p><p>foo函数在预编译阶段创建了bar函数，于是bar函数创建了属性[[Scope]]，包含bar被创建的作用域中对象的集合，也就是复制了foo.EC<br>所以我们可以得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 伪代码：bar函数创建产生[[Scope]]对象</div><div class="line">// bar.[[Scope]] === foo.EC</div><div class="line">bar.[[Scope]] = &#123;</div><div class="line">    AO: &#123;</div><div class="line">        this: window,</div><div class="line">        arguments: [100,200],</div><div class="line">        x: 100,</div><div class="line">        y: 200,</div><div class="line">        b: undefined,</div><div class="line">        bar: function()&#123;...&#125;</div><div class="line">    &#125;,</div><div class="line">    GO: &#123;</div><div class="line">        this: window ,</div><div class="line">        window: ... ,</div><div class="line">        document: ... ,</div><div class="line">        a: 1,</div><div class="line">        foo: function()&#123;...&#125;,</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>bar函数执行，过程同foo函数执行相近，整理出 bar.EC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bar.EC = &#123;</div><div class="line">AO: &#123; // bar 产生的 AO</div><div class="line">        this: window,</div><div class="line">        arguments: [],</div><div class="line">        c: undefined,</div><div class="line">    &#125;,</div><div class="line">    AO: &#123; // foo 产生的 EC</div><div class="line">        this: window,</div><div class="line">        arguments: [100,200],</div><div class="line">        x: 100,</div><div class="line">        y: 200,</div><div class="line">        b: 2,</div><div class="line">        bar: function()&#123;...&#125;</div><div class="line">    &#125;,</div><div class="line">    GO: &#123; // foo 的 [[Scope]]</div><div class="line">        this: window ,</div><div class="line">        window: ... ,</div><div class="line">        document: ... ,</div><div class="line">        a: 1,</div><div class="line">        foo: function()&#123;...&#125;,</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果在bar函数中在创建一个der函数，der的EC又会是怎么样呢？读者自行脑补吧（大体思路类似）<br><a href="https://blog.csdn.net/q1056843325/article/details/53086893?locationNum=12&amp;fps=1" target="_blank" rel="external">[[Scope]]与作用域链</a></p><h1 id="jsEvent-Loop机制"><a href="#jsEvent-Loop机制" class="headerlink" title="jsEvent Loop机制"></a>jsEvent Loop机制</h1><p>在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。</p><h2 id="MicroTask"><a href="#MicroTask" class="headerlink" title="MicroTask"></a>MicroTask</h2><p>process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver</p><h2 id="MacroTask"><a href="#MacroTask" class="headerlink" title="MacroTask"></a>MacroTask</h2><p>script(同步代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>script(同步代码) -&gt; MicroTask -&gt; MacroTask<br>在执行上面代码时有产生了一些 MicroTask 和 MacroTask 会挂起，在一下次Event Loop再触发，以此类推。<br><a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#Event-Loop%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%EF%BC%89">可以看看我之前的博客</a></p><h1 id="通用-curry-实现"><a href="#通用-curry-实现" class="headerlink" title="通用 curry 实现"></a>通用 curry 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//柯里函数实质：传递给函数一部分参数来调用它，让它返回一个函数来处理剩余参数</div><div class="line">function curry(fx) &#123;</div><div class="line">    //要进行柯里化的函数的形参数量</div><div class="line">    let arity = fx.length;</div><div class="line"></div><div class="line">    return function f1() &#123;</div><div class="line">        //第一次传入的参数数量</div><div class="line">        let args = Array.from(arguments);</div><div class="line">        //若传入的参数数量大于等于形参数量</div><div class="line">        if (args.length &gt;= arity) &#123;</div><div class="line">            return fx.apply(null,args)</div><div class="line">        &#125;else&#123;</div><div class="line">            let f2 = function() &#123;</div><div class="line">                //如果只传入了一部分参数</div><div class="line">                let args2 = Array.from(arguments)</div><div class="line">                //判断是否所有参数都传完了，如果没有，不断concat新传的参数，然后执行f1函数</div><div class="line">                return f1.apply(null, args.concat(args2))</div><div class="line">            &#125;</div><div class="line">            return f2</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">let add = (num1, num2, num3)=&gt; num1 + num2 + num3;</div><div class="line">console.log(curry(add)(1)(2)(3)) // 6</div></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000012135934" target="_blank" rel="external">curry实现</a></p><h1 id="通用的-compose-的实现"><a href="#通用的-compose-的实现" class="headerlink" title="通用的 compose 的实现"></a>通用的 compose 的实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let compose = function(...args) &#123;</div><div class="line">var len = args.length,</div><div class="line">count = len - 1,</div><div class="line">result;</div><div class="line"></div><div class="line">return function f1(...args1) &#123;</div><div class="line">result = args[count].apply(this, args1);</div><div class="line">if (count &lt;= 0) &#123;</div><div class="line">count = len - 1;</div><div class="line">return result;</div><div class="line">&#125; else &#123;</div><div class="line">count--;</div><div class="line">return f1.call(null, result);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000008394749" target="_blank" rel="external">关于javascript函数式编程中compose的实现</a></p><blockquote><p>   参考文档：<br><a href="https://www.jb51.net/article/137370.htm" target="_blank" rel="external">详解Javascript中new()到底做了些什么？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录今日头条各论面试中一些比较有意思的话题分享给大家，全程3轮视频面试。&lt;/p&gt;
&lt;h1 id=&quot;new操作符的工作原理&quot;&gt;&lt;a href=&quot;#new操作符的工作原理&quot; class=&quot;headerlink&quot; title=&quot;new操作符的工作原理&quot;&gt;&lt;/a&gt;new操作符的工作
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vue-基础知识</title>
    <link href="https://fanerge.github.io/2018/vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>https://fanerge.github.io/2018/vue-基础知识.html</id>
    <published>2018-08-14T13:23:58.000Z</published>
    <updated>2018-08-14T13:34:19.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h1><h2 id="单向与双向"><a href="#单向与双向" class="headerlink" title="单向与双向"></a>单向与双向</h2><p>Model&gt;View（单向）<br>Model&lt;&gt;View（单向）</p><h2 id="双向的原理"><a href="#双向的原理" class="headerlink" title="双向的原理"></a>双向的原理</h2><p>通过数据劫持和发布者-订阅者模式的方式来实现。</p><ol><li>数据劫持主要通过 Object.defineProperty(obj, prop, descriptor) 的set和get方法执行对应的改变视图的方法。</li><li>new Proxy(target, handler) 来实现数据劫持。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue双向绑定原理&quot;&gt;&lt;a href=&quot;#vue双向绑定原理&quot; class=&quot;headerlink&quot; title=&quot;vue双向绑定原理&quot;&gt;&lt;/a&gt;vue双向绑定原理&lt;/h1&gt;&lt;h2 id=&quot;单向与双向&quot;&gt;&lt;a href=&quot;#单向与双向&quot; class=&quot;header
      
    
    </summary>
    
      <category term="vue" scheme="https://fanerge.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://fanerge.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JS常用设计模式总结</title>
    <link href="https://fanerge.github.io/2017/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html"/>
    <id>https://fanerge.github.io/2017/设计模式总结.html</id>
    <published>2018-08-05T02:48:22.000Z</published>
    <updated>2018-08-05T03:42:05.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>设计模式，是一套经过前人总结、业务验证并适合于特定业务开发的代码组织方式，可能会有一些同学会认为设计模式没有用，我这里需要指出设计模式并不是万能的只适合于特定业务场景的开发（对我们的业务开发起到一定的指导作用，所有设计模式的目的都是让开发者编写可维护、易扩展的代码），其实你日常开发中或多或少都使用过设计模式，只是你不知道名字而已（如，绑定事件和触发事件这就是一个简单的发布-订阅模式）。<br>本文所有设计模式都是使用 JavaScript 语言书写，这些案例都是较为基础的，目的是帮助前端同学更好的理解设计模式。<br>为了你更好的理解设计模式，你需要了解设计模式的六大原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则，可以看这篇<a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="external">设计模式六大原则</a>。<br>本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="external">个人技术博客项目</a>给个star哦。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><h1 id="工厂模式（Factory）"><a href="#工厂模式（Factory）" class="headerlink" title="工厂模式（Factory）"></a>工厂模式（Factory）</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）、自行车售卖（山地、公路）、饮料机（咖啡、牛奶、水）、RPG中职业（战士、法师、射手）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：：模态框、登录控件、注销控件<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>定义：策略模式包括两个部分，算法的使用部分（不变的）和算法的实现部分（可变的）。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）、计算年终奖（工资、效绩）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例： 图片预加载、图片懒加载、合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、缓存代理（缓存请求结果、计算结果）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：手机购买页面（颜色、数量、内存、价格）、MVC模式（控制层便是位于表现层与模型层之间的中介者）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="装饰者模式（Decorator）"><a href="#装饰者模式（Decorator）" class="headerlink" title="装饰者模式（Decorator）"></a>装饰者模式（Decorator）</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。<br>举例：雷霆战机（吃道具的例子）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="发布订阅模式（Observer）"><a href="#发布订阅模式（Observer）" class="headerlink" title="发布订阅模式（Observer）"></a>发布订阅模式（Observer）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。<br>举例：模块通信、事件绑定与触发、售楼中心<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>举例：常用于接口适配、兼容多个库（如Prototype库的$函数和YUI的get方法）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>举例：jquery的$.each()、<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>举例：用桥接模式联结多个类、事件监控<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>举例：兼容浏览器事件绑定、兼容浏览器阻止冒泡、默认事件<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br>举例：<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模版方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>举例：泡饮品（茶 和 coffee）、公司面试（百度面试 和 阿里面试）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象（子对象）和组合对象的使用具有一致性。<br>举例：文件扫描（目录为组合对象和文件为子对象）、dom节点操作<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。<br>举例：分页控件、撤销组件<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。<br>举例：挤公交车递钱（只有售票员可以收钱）、交押金预定手机<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成（环境类、状态类）。<br>举例：文件下载（开始、暂停、完成、失败等）、红绿灯<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p><h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了（具体做法缓存对象从而达到重复利用）。<br>举例：内衣厂展示许多商品展示、地图应用（对象池）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;设计模式，是一套经过前人总结、业务验证并适合于特定业务开发的代码组织方式，可能会有一些同学会认为设计模式没有用，我这里需要指
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fanerge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://fanerge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Web实验性知识</title>
    <link href="https://fanerge.github.io/2018/Web%E5%AE%9E%E9%AA%8C%E6%80%A7%E7%9F%A5%E8%AF%86.html"/>
    <id>https://fanerge.github.io/2018/Web实验性知识.html</id>
    <published>2018-08-04T05:10:44.000Z</published>
    <updated>2018-08-04T05:56:12.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪类-placeholder-shown"><a href="#伪类-placeholder-shown" class="headerlink" title="伪类:placeholder-shown"></a>伪类:placeholder-shown</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CSS 伪类在 input 或 textarea 元素显示 placeholder text 时生效。<br>PS：可以配合 :not() 伪类等配合，优化表单。</p><h1 id="伪-focus-within"><a href="#伪-focus-within" class="headerlink" title="伪:focus-within"></a>伪:focus-within</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>CSS 伪类，表示一个元素获得焦点或该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配:focus伪类。<br><a href="https://github.com/chokcoco/iCSS/issues/36" target="_blank" rel="external">神奇的选择器 :focus-within</a></p><h1 id="display-contents"><a href="#display-contents" class="headerlink" title="display:contents"></a>display:contents</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>元素本身不产生任何边界框，而元素的子元素与伪元素仍然生成边界框，元素文字照常显示。为了同时照顾边界框与布局，处理这个元素时，要想象这个元素不在元素树型结构里，而只有内容留下。这包括元素在原文档中的子元素与伪元素，比如::before和::after这两个伪元素，如平常一样，前者仍然在元素子元素之前生成，后者在之后生成。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown" target="_blank" rel="external">MDN-placeholder-shown</a><br><a href="https://zhuanlan.zhihu.com/p/40736286" target="_blank" rel="external">五个最新的CSS特性以及如何使用它们</a></p><h1 id="contain"><a href="#contain" class="headerlink" title="contain"></a>contain</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain" target="_blank" rel="external">MDN-contain</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪类-placeholder-shown&quot;&gt;&lt;a href=&quot;#伪类-placeholder-shown&quot; class=&quot;headerlink&quot; title=&quot;伪类:placeholder-shown&quot;&gt;&lt;/a&gt;伪类:placeholder-shown&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="杂项" scheme="https://fanerge.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="html,css,js" scheme="https://fanerge.github.io/tags/html-css-js/"/>
    
  </entry>
  
  <entry>
    <title>如何形成一个完整的HTML对象</title>
    <link href="https://fanerge.github.io/2018/%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84HTML%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://fanerge.github.io/2018/如何形成一个完整的HTML对象.html</id>
    <published>2018-07-28T11:22:25.000Z</published>
    <updated>2018-08-16T13:17:49.420Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面，本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="external">个人技术博客项目</a>给个star哦。</p><h1 id="为何写这篇文章？"><a href="#为何写这篇文章？" class="headerlink" title="为何写这篇文章？"></a>为何写这篇文章？</h1><p>你可能做Web开发已经有一段时间，你是否有想过下列问题呢？<br>为什么div元素甚至是所有的html元素都可以使用addEventListener来添加事件呢？<br>为什么每个DOM节点都有parentNode、firstChild、nodeType等属性呢？<br>为什么每个DOM元素都有className、classList、innerHTML等属性呢？<br>为什么有些DOM元素有accessKey、contentEditable、isContentEditable等属性呢？<br>为什么每个DOM元素都有onclick、ondblclick、ondrag等属性？<br>本文就是来解答这些简单而又不“简单”的问题。</p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>你可以在浏览器中选择一个节点，然后在控制台中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$0.hasOwnProperty </div><div class="line">// ƒ hasOwnProperty() &#123; [native code] &#125;</div></pre></td></tr></table></figure></p><p>PS：$0表示当前选择的DOM元素。<br>为什么我的一个元素会有对象的方法，追究其原因在设计HTML时，通过从各个接口继承不同的属性和方法。<br>例如span元素继承关系：span -&gt; HTMLSpanElement -&gt; HTMLElement -&gt; Element -&gt; Node -&gt; EventTarget-&gt; Object<br><img src="http://oxpnrlb4j.bkt.clouddn.com/html%E5%B1%9E%E6%80%A7.png" alt="property"><br>[2018-08-16]</p><h1 id="EventTarget"><a href="#EventTarget" class="headerlink" title="EventTarget"></a>EventTarget</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>EventTarget 是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如XMLHttpRequest，AudioNode，AudioContext 等等。<br>许多事件目标（包括元素，文档和 window）还支持通过 onXXX（如onclick） 属性和属性设置事件处理程序。</p><h2 id="该接口的方法"><a href="#该接口的方法" class="headerlink" title="该接口的方法"></a>该接口的方法</h2><h3 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p>在EventTarget上注册特定事件类型的事件处理程序。</p><h3 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h3><p>EventTarget中删除事件侦听器。</p><h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h3><p>将事件分派到此EventTarget。</p><h2 id="我们自己实现EventTarget"><a href="#我们自己实现EventTarget" class="headerlink" title="我们自己实现EventTarget"></a>我们自己实现EventTarget</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">var EventTarget = function() &#123;</div><div class="line">  this.listeners = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">EventTarget.prototype.listeners = null;</div><div class="line">EventTarget.prototype.addEventListener = function(type, callback) &#123;</div><div class="line">  if (!(type in this.listeners)) &#123;</div><div class="line">    this.listeners[type] = [];</div><div class="line">  &#125;</div><div class="line">  this.listeners[type].push(callback);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">EventTarget.prototype.removeEventListener = function(type, callback) &#123;</div><div class="line">  if (!(type in this.listeners)) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  var stack = this.listeners[type];</div><div class="line">  for (var i = 0, l = stack.length; i &lt; l; i++) &#123;</div><div class="line">    if (stack[i] === callback)&#123;</div><div class="line">      stack.splice(i, 1);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">EventTarget.prototype.dispatchEvent = function(event) &#123;</div><div class="line">  if (!(event.type in this.listeners)) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  var stack = this.listeners[event.type].slice();</div><div class="line"></div><div class="line">  for (var i = 0, l = stack.length; i &lt; l; i++) &#123;</div><div class="line">    stack[i].call(this, event);</div><div class="line">  &#125;</div><div class="line">  return !event.defaultPrevented;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。</p><h2 id="有那些接口重Node继承其方法和属性？"><a href="#有那些接口重Node继承其方法和属性？" class="headerlink" title="有那些接口重Node继承其方法和属性？"></a>有那些接口重Node继承其方法和属性？</h2><p>Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference<br>PS：在方法和属性不相关的特定情况下，这些接口可能返回null。它们可能会抛出异常 - 例如，当将子节点添加到不允许子节点存在的节点时。</p><h2 id="接口相关的属性和方法"><a href="#接口相关的属性和方法" class="headerlink" title="接口相关的属性和方法"></a>接口相关的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="Node-baseURI"><a href="#Node-baseURI" class="headerlink" title="Node.baseURI"></a>Node.baseURI</h4><p>返回一个表示base URL的DOMString。不同语言中的base URL的概念都不一样。 在HTML中，base URL表示协议和域名，以及一直到最后一个’/‘之前的文件目录。</p><h4 id="Node-childNodes"><a href="#Node-childNodes" class="headerlink" title="Node.childNodes"></a>Node.childNodes</h4><p>返回一个包含了该节点所有子节点的实时的NodeList。NodeList 是“实时的”意思是，如果该节点的子节点发生了变化，NodeList对象就会自动更新。 </p><h4 id="Node-firstChild"><a href="#Node-firstChild" class="headerlink" title="Node.firstChild"></a>Node.firstChild</h4><p>返回该节点的第一个子节点，如果该节点没有子节点则返回null。</p><h4 id="Node-lastChild"><a href="#Node-lastChild" class="headerlink" title="Node.lastChild"></a>Node.lastChild</h4><p>返回该节点的最后一个子节点，如果该节点没有子节点则返回null。<br>此处省略若干Node接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node#属性" target="_blank" rel="external">更多属性查看这里</a>。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>——————–重点分割线——————-<br>重点：从其父类EventTarget继承了addEventListener、removeEventListener、dispatchEvent等方法。</p><h4 id="Node-appendChild"><a href="#Node-appendChild" class="headerlink" title="Node.appendChild()"></a>Node.appendChild()</h4><p>将一个节点添加到指定父节点的子节点列表末尾。</p><h4 id="Node-contains"><a href="#Node-contains" class="headerlink" title="Node.contains()"></a>Node.contains()</h4><p>返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点。</p><h4 id="Node-cloneNode"><a href="#Node-cloneNode" class="headerlink" title="Node.cloneNode()"></a>Node.cloneNode()</h4><p>返回调用该方法的节点的一个副本。<br>此处省略若干Node接口方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node#方法" target="_blank" rel="external">更多方法查看这里</a>。</p><h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Element是非常通用的基类，所有 Document对象下的对象都继承它。这个接口描述了所有相同种类的元素所普遍具有的方法和属性。 这些继承自Element并且增加了一些额外功能的接口描述了具体的行为。<br>PS：HTMLElement 接口是所有HTML元素的基础接口， 而 SVGElement 接口是所有SVG元素的基本接口。<br>在web以外的语言，像 XUL 可以通过 XULElement 的API，也能实现它。</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>所有属性继承至它的祖先接口 Node, 和它所扩展的接口 EventTarget, 并且从以下部分继承了属性ParentNode, ChildNode, NonDocumentTypeChildNode, 和Animatable.</p><h3 id="Element-assignedSlot"><a href="#Element-assignedSlot" class="headerlink" title="Element.assignedSlot"></a>Element.assignedSlot</h3><p>返回元素对应的 HTMLSlotElement 接口</p><h3 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h3><p>返回一个与该元素相关的所有属性集合NamedNodeMap </p><h3 id="Element-classList"><a href="#Element-classList" class="headerlink" title="Element.classList"></a>Element.classList</h3><p>返回该元素包含的class属性是一个DOMTokenList.</p><h3 id="Element-className"><a href="#Element-className" class="headerlink" title="Element.className"></a>Element.className</h3><p>它是一个 DOMString 表示这个元素的class.<br>此处省略若干Element接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element#Properties" target="_blank" rel="external">更多方法查看这里</a>。</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>——————–重点分割线——————-<br>从它的父类（Node）和它父类的父类（EventTarget）继承方法，并实现parentNode、ChildNode、NonDocumentTypeChildNode、Animatable。<br>此处省略若干Element接口方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element#Properties" target="_blank" rel="external">更多方法查看这里</a>。</p><h3 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h3><p>方法用来获取匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。</p><h3 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h3><p>返回元素上一个指定的属性值。如果指定的属性不存在，则返回  null 或 “” （空字符串）。</p><h3 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h3><p>参数中给出类的列表，返回一个动态的 HTMLCollection ，这里面包含了所有持有这些类的后代元素。<br>此处省略若干Element接口方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element#Methods" target="_blank" rel="external">更多方法查看这里</a>。</p><h1 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>HTMLElement 接口表示所有的 HTML 元素。一些HTML元素直接实现了HTMLElement接口，其它的间接实现HTMLElement接口。</p><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>——————–重点分割线——————-<br>继承自父接口Element和 GlobalEventHandlers的属性。<br>HTMLElement.accessKey    DOMString    获取/设置元素访问的快捷键<br>HTMLElement.accessKeyLabel    DOMString    返回一个包含元素访问的快捷键的字符串（只读）<br>HTMLElement.contentEditable    DOMString    获取/设置元素的可编辑状态<br>HTMLElement.isContentEditable Boolean    表明元素的内容是否可编辑（只读）<br>此处省略若干HTMLElement接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement#属性" target="_blank" rel="external">更多方法查看这里</a>。</p><h2 id="Event-handlers"><a href="#Event-handlers" class="headerlink" title="Event handlers"></a>Event handlers</h2><p>HTMLElement.onTouchStart<br>HTMLElement.onTouchEnd<br>HTMLElement.onTouchMove<br>HTMLElement.onTouchEnter<br>HTMLElement.onTouchLeave<br>HTMLElement.onTouchCancel </p><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><p>HTMLElement.blur()    void    元素失去焦点<br>HTMLElement.click()    void    触发元素的点击事件<br>HTMLElement.focus()    void    元素获得焦点<br>HTMLElement.forceSpellCheck()     void     </p><h1 id="GlobalEventHandlers"><a href="#GlobalEventHandlers" class="headerlink" title="GlobalEventHandlers"></a>GlobalEventHandlers</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>GlobalEventHandlers接口描述了事件处理程序像HTMLElement常见的几个接口,文件,窗口,或WorkerGlobalScope Web Workers。这些接口可以实现更多的事件处理程序。</p><h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><h3 id="GlobalEventHandlers-onabort"><a href="#GlobalEventHandlers-onabort" class="headerlink" title="GlobalEventHandlers.onabort"></a>GlobalEventHandlers.onabort</h3><p>中断事件。</p><h3 id="GlobalEventHandlers-onblur"><a href="#GlobalEventHandlers-onblur" class="headerlink" title="GlobalEventHandlers.onblur"></a>GlobalEventHandlers.onblur</h3><p>失去焦点事件。</p><h3 id="GlobalEventHandlers-onfocus"><a href="#GlobalEventHandlers-onfocus" class="headerlink" title="GlobalEventHandlers.onfocus"></a>GlobalEventHandlers.onfocus</h3><p>获取焦点事件。<br>此处省略若干GlobalEventHandlers接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers#Properties" target="_blank" rel="external">更多方法查看这里</a>。</p><h1 id="元素接口"><a href="#元素接口" class="headerlink" title="元素接口"></a>元素接口</h1><p>该接口用于创建对应的元素。<br>如：<br>HTMLDivElement 接口提供了一些特殊属性（它也继承了通常的 HTMLElement 接口）来操作div元素。<br>HTMLFormElement接口可以创建或者修改<form>对象;它继承了HTMLElement接口的方法和属性。<br>HTMLAnchorElement 接口表示超链接元素，并提供一些特别的属性和方法（除了那些继承自普通 HTMLElement对象接口的之外）以用于操作这些元素的布局和显示。<br>……</form></p><h1 id="回答前面问题"><a href="#回答前面问题" class="headerlink" title="回答前面问题"></a>回答前面问题</h1><p>通过上面的知识，我们了解到：<br>HTMLDivElement（其他元素接口） 继承 HTMLElement 和 GlobalEventHandlers 接口。<br>HTMLElement 继承 Element 接口。<br>Element 继承 Node 接口。<br>Node 继承 EventTarget 接口。<br><img src="http://oxpnrlb4j.bkt.clouddn.com/html%E5%85%83%E7%B4%A0%E7%94%B1%E6%9D%A5%281%29.svg" alt="html由来"><br>为什么div元素甚至是所有的html元素都可以使用addEventListener来添加事件呢？<br>回答：从 EventTarget 接口中继承而来。<br>为什么每个DOM节点都有parentNode、firstChild、nodeType等属性呢？<br>回答：从 Node 接口中继承而来。<br>为什么每个DOM元素都有className、classList、innerHTML等属性呢？<br>回答：从 Element 接口中继承而来。<br>为什么有些DOM元素有accessKey、contentEditable、isContentEditable等属性呢？<br>回答：从 HTMLElement 接口中继承而来。<br>为什么每个DOM元素都有onclick、ondblclick、ondrag等属性？<br>回答：从 GlobalEventHandlers 接口中继承而来。<br>——————–重点分割线——————-</p><h2 id="只有通过上面的继承关系，我们得到的-DOM-元素才是一个完整的-HTML-对象，我们才能为它设置-获取属性、绑定事件、添加样式类等操作。"><a href="#只有通过上面的继承关系，我们得到的-DOM-元素才是一个完整的-HTML-对象，我们才能为它设置-获取属性、绑定事件、添加样式类等操作。" class="headerlink" title="只有通过上面的继承关系，我们得到的 DOM 元素才是一个完整的 HTML 对象，我们才能为它设置/获取属性、绑定事件、添加样式类等操作。"></a>只有通过上面的继承关系，我们得到的 DOM 元素才是一个完整的 HTML 对象，我们才能为它设置/获取属性、绑定事件、添加样式类等操作。</h2><p>参考文档：</p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="external">EventTarget</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node" target="_blank" rel="external">Node</a><br><a href="https://developer.mozilla.org/en-US/docs/Glossary/Element" target="_blank" rel="external">Element</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" target="_blank" rel="external">HTMLElement</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers" target="_blank" rel="external">GlobalEventHandlers</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前面，本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的&lt;a href=&quot;https://github.com/fanerge/fanerge.github.io&quot; target=&quot;_blank&quot; rel=&quot;exte
      
    
    </summary>
    
      <category term="html5" scheme="https://fanerge.github.io/categories/html5/"/>
    
    
      <category term="html5" scheme="https://fanerge.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>自己踩过的坑</title>
    <link href="https://fanerge.github.io/2018/%E8%87%AA%E5%B7%B1%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html"/>
    <id>https://fanerge.github.io/2018/自己踩过的坑.html</id>
    <published>2018-07-24T14:17:21.000Z</published>
    <updated>2018-07-26T13:47:51.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="touchstart-和-click-的坑"><a href="#touchstart-和-click-的坑" class="headerlink" title="touchstart 和 click 的坑"></a>touchstart 和 click 的坑</h1><h2 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tap = &apos;ontouchstart&apos; in window ? &apos;touchstart&apos; : &apos;click&apos;;</div><div class="line">wrap.addEvenListener(tap, function()&#123;</div><div class="line">    signUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>通过上面代码简单为用户设置事件类型，但我们忽略了‘联想触控笔记本’，<span color="color: red">由于该笔记本支持‘touchstart’事件，但当用户使用鼠标时却不能触发‘touchstart’事件</span>，造成不能触发对应的事件处理函数。</p><ol><li>有些 PC 设备屏幕为触摸屏，同时支持touchstart和click事件；</li><li>用户触发touchstart事件，默认必然会导致触发click事件，但是触发click事件，不一定会导致touchstart事件被触发；</li><li>此类设备外接鼠标时，通过上面的绑定方式，会绑定touchstart事件，但是鼠标操作只能触发click，导致touchstart不触发；</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="均使用click事件（移动端存在300ms延迟）"><a href="#均使用click事件（移动端存在300ms延迟）" class="headerlink" title="均使用click事件（移动端存在300ms延迟）"></a>均使用click事件（移动端存在300ms延迟）</h3><h3 id="通过UA判断设备是否为移动端，再确认事件类型"><a href="#通过UA判断设备是否为移动端，再确认事件类型" class="headerlink" title="通过UA判断设备是否为移动端，再确认事件类型"></a>通过UA判断设备是否为移动端，再确认事件类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function isMobile() &#123;</div><div class="line">    return navigator.userAgent.match(/(blackberry|configuration\/cldc|hp |hp-|htc |htc_|htc-|iemobile|kindle|midp|mmp|motorola|mobile|nokia|opera mini|opera |Googlebot-Mobile|YahooSeeker\/M1A1-R2D2|android|iphone|ipod|mobi|palm|palmos|pocket|portalmmm|ppc;|smartphone|sonyericsson|sqh|spv|symbian|treo|up.browser|up.link|vodafone|windows ce|xda |xda_)/i) ? true : false;</div><div class="line">&#125;</div><div class="line"> var tap = isMobile() ? &apos;touchstart&apos; : &apos;click&apos;;</div></pre></td></tr></table></figure><h3 id="全部使用click，通过FastClick解决300毫秒的延迟问题"><a href="#全部使用click，通过FastClick解决300毫秒的延迟问题" class="headerlink" title="全部使用click，通过FastClick解决300毫秒的延迟问题"></a>全部使用click，通过FastClick解决300毫秒的延迟问题</h3><h3 id="不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。"><a href="#不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。" class="headerlink" title="不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。"></a>不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。</h3><p>具体实现：</p><ol><li>在touchstart事件响应中调用preventDefault()方法，阻止后续click事件的触发（也会阻止多个事件绑定叠加和多人合作项目，导致以来 click 事件出现bug）</li><li>在touchstart事件中设置一些标记，或者取消click事件的绑定，使得click事件触发时不会触发我们绑定的逻辑，在一段时间（例如300-500ms）后再恢复</li><li>直接对事件处理函数进行节流（throttle），保证在一段时间内（300ms - 500ms），事件处理函数只触发一次</li></ol><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>object instanceof constructor<br>instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。<br>instanceof 运算符用来测试一个对象的原型链中是否存在一个构造函数的 prototype 属性。</p><h1 id="URL-构造函数-和-URLSearchParams-构造函数"><a href="#URL-构造函数-和-URLSearchParams-构造函数" class="headerlink" title="URL 构造函数 和 URLSearchParams 构造函数"></a>URL 构造函数 和 URLSearchParams 构造函数</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL() 构造函数返回一个新创建的URL对象，表示由参数定义的URL。</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>URL 实例的属性与Location对象的属性基本一致，返回当前 URL 的信息。<br>URL.href、URL.protocol等</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>URL.createObjectURL()<br>URL.createObjectURL方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。<br>URL.revokeObjectURL()<br>URL.revokeObjectURL方法用来释放URL.createObjectURL方法生成的 URL 实例。它的参数就是URL.createObjectURL方法返回的 URL 字符串。</p><h2 id="URLSearchParams"><a href="#URLSearchParams" class="headerlink" title="URLSearchParams"></a>URLSearchParams</h2><p>URLSearchParams对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>URLSearchParams.append()<br> 插入一个指定的键/值对作为新的搜索参数。<br>URLSearchParams.delete()<br> 从搜索参数列表里删除指定的搜索参数及其对应的值。<br>URLSearchParams.entries()<br> 返回一个iterator可以遍历所有键/值对的对象。<br>URLSearchParams.get()<br> 获取指定搜索参数的第一个值。<br>URLSearchParams.getAll()<br> 获取指定搜索参数的所有值，返回是一个数组。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="external">URLSearchParams</a><br><a href="https://wangdoc.com/javascript/bom/location.html#url-%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">URL 对象，URLSearchParams 对象</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;touchstart-和-click-的坑&quot;&gt;&lt;a href=&quot;#touchstart-和-click-的坑&quot; class=&quot;headerlink&quot; title=&quot;touchstart 和 click 的坑&quot;&gt;&lt;/a&gt;touchstart 和 click 的坑&lt;/
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://fanerge.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>React-基础知识整理</title>
    <link href="https://fanerge.github.io/2018/React-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html"/>
    <id>https://fanerge.github.io/2018/React-基础知识整理.html</id>
    <published>2018-07-17T12:17:11.000Z</published>
    <updated>2018-08-19T03:03:30.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="setState-一定是异步的吗？"><a href="#setState-一定是异步的吗？" class="headerlink" title="setState 一定是异步的吗？"></a>setState 一定是异步的吗？</h1><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是“同步”的。<br><a href="https://juejin.im/entry/5b45c6955188251abd7d14be" target="_blank" rel="external">你真的理解setState吗？</a></p><h1 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h1><p>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。<br>对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。<br>对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p><h2 id="Reconciliation-阶段"><a href="#Reconciliation-阶段" class="headerlink" title="Reconciliation 阶段"></a>Reconciliation 阶段</h2><p>componentWillMount<br>componentWillReceiveProps（使用 getDerivedStateFromProps 代替）<br>shouldComponentUpdate<br>componentWillUpdate</p><h2 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h2><p>componentDidMount<br>componentDidUpdate<br>componentWillUnmount<br><a href="https://yuchengkai.cn/docs/zh/frontend/react.html" target="_blank" rel="external">react</a></p><h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">class ExampleComponent extends React.Component &#123;</div><div class="line">  // 用于初始化 state</div><div class="line">  constructor() &#123;&#125;</div><div class="line">  // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用</div><div class="line">  // 因为该函数是静态函数，所以取不到 `this`</div><div class="line">  // 如果需要对比 `prevProps` 需要单独在 `state` 中维护</div><div class="line">  static getDerivedStateFromProps(nextProps, prevState) &#123;&#125;</div><div class="line">  // 判断是否需要更新组件，多用于组件性能优化</div><div class="line">  shouldComponentUpdate(nextProps, nextState) &#123;&#125;</div><div class="line">  // 组件挂载后调用</div><div class="line">  // 可以在该函数中进行请求或者订阅</div><div class="line">  componentDidMount() &#123;&#125;</div><div class="line">  // 用于获得最新的 DOM 数据</div><div class="line">  getSnapshotBeforeUpdate() &#123;&#125;</div><div class="line">  // 组件即将销毁</div><div class="line">  // 可以在此处移除订阅，定时器等等</div><div class="line">  componentWillUnmount() &#123;&#125;</div><div class="line">  // 组件销毁后调用</div><div class="line">  componentDidUnMount() &#123;&#125;</div><div class="line">  // 组件更新后调用</div><div class="line">  componentDidUpdate() &#123;&#125;</div><div class="line">  // 渲染组件函数</div><div class="line">  render() &#123;&#125;</div><div class="line">  // 以下函数不建议使用</div><div class="line">  componentWillMount() &#123;&#125;</div><div class="line">  componentWillUpdate(nextProps, nextState) &#123;&#125;</div><div class="line">  componentWillReceiveProps(nextProps) &#123;&#125;</div><div class="line">&#125;</div><div class="line">```</div><div class="line">##首次渲染触发的生命周期</div><div class="line">constructor()</div><div class="line">UNSAFE_componentWillMount()</div><div class="line">render()</div><div class="line">componentDidMount()</div><div class="line">##非初次渲染触发的生命周期</div><div class="line">UNSAFE_componentWillReceiveProps(nextProps) </div><div class="line">shouldComponentUpdate(nextProps, nextState)</div><div class="line">UNSAFE_componentWillUpdate()</div><div class="line">render()</div><div class="line">componentDidUpdate()</div><div class="line">##其他什么周期函数</div><div class="line">componentWillUnmount()</div><div class="line">static getDerivedStateFromProps(nextProps, prevState) // 代替 componentWillReceiveProps 在初始化和 update 时触发，由于时静态方法无 this</div><div class="line">getSnapshotBeforeUpdate(prevProps, prevState) // 此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）与componentDidUpdate一起，这个新的生命周期将覆盖旧版componentWillUpdate的所有用例。</div><div class="line"></div><div class="line">#React16.0中的portal</div><div class="line">作用：将子节点插入到父节点之外的dom（render到一个组件里面去，实际改变的是网页上另一处的DOM结构。）。</div><div class="line">使用场景：Modal、Dialog、Message等全局提示组件</div><div class="line">比如写一个Dialog通用组件</div></pre></td></tr></table></figure><p>import React from ‘react’;<br>import {createPortal} from ‘react-dom’;</p><p>class Dialog extends React.Component {<br>  constructor() {<br>    super(…arguments);</p><pre><code>const doc = window.document;this.node = doc.createElement(&apos;div&apos;);doc.body.appendChild(this.node);</code></pre><p>  }</p><p>  render() {<br>    return createPortal(<br>      <div class="dialog"><br>        {this.props.children}<br>      </div>, //塞进传送门的JSX<br>      this.node //传送门的另一端DOM node<br>    );<br>  }</p><p>  componentWillUnmount() {<br>    window.document.body.removeChild(this.node);<br>  }<br>}<br>```<br><a href="https://zhuanlan.zhihu.com/p/29880992?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage" target="_blank" rel="external">React-DOM Portal</a></p><h1 id="React16新特性"><a href="#React16新特性" class="headerlink" title="React16新特性"></a>React16新特性</h1><h2 id="Error-Boundary（错误边界）"><a href="#Error-Boundary（错误边界）" class="headerlink" title="Error Boundary（错误边界）"></a>Error Boundary（错误边界）</h2><p>之前，一旦某个组件发生错误，整个组件树将会从根节点被unmount下来。<br>Error Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）<br>PS：最佳实践封装通用错误组件，用起包裹可能出错的组件，来捕获子组件可能发生的错误。</p><h2 id="render方法新增返回类型"><a href="#render方法新增返回类型" class="headerlink" title="render方法新增返回类型"></a>render方法新增返回类型</h2><p>render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。</p><h2 id="支持自定义DOM属性"><a href="#支持自定义DOM属性" class="headerlink" title="支持自定义DOM属性"></a>支持自定义DOM属性</h2><p>现在React可以将属性直接传递给DOM，不过有些写法任然无效。</p><h2 id="setState传入null时不会再触发更新"><a href="#setState传入null时不会再触发更新" class="headerlink" title="setState传入null时不会再触发更新"></a>setState传入null时不会再触发更新</h2><p>比如在一个选择城市的函数中，当点击某个城市时，newValue的值可能发生改变，也可能是点击了原来的城市，值没有变化，返回null则可以直接避免触发更新，不会引起重复渲染，不需要在shouldComponentUpdate函数里面去判断。<br><a href="https://www.jianshu.com/p/af0ae26eac18" target="_blank" rel="external">十分钟快速了解React16新特性</a></p><h1 id="React编码优化"><a href="#React编码优化" class="headerlink" title="React编码优化"></a>React编码优化</h1><ol><li>使用 key 属性为列表项组件做身份标记</li><li>shouldComponentUpdate 决定组件是否render</li><li>PureComponent 来定义组件</li><li>Stateless components 函数式组件</li><li>慎用bind，它会返回一个新的函数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;setState-一定是异步的吗？&quot;&gt;&lt;a href=&quot;#setState-一定是异步的吗？&quot; class=&quot;headerlink&quot; title=&quot;setState 一定是异步的吗？&quot;&gt;&lt;/a&gt;setState 一定是异步的吗？&lt;/h1&gt;&lt;p&gt;setState 只
      
    
    </summary>
    
      <category term="React" scheme="https://fanerge.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://fanerge.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web性能优化</title>
    <link href="https://fanerge.github.io/2018/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
    <id>https://fanerge.github.io/2018/Web性能优化.html</id>
    <published>2018-07-13T14:33:31.000Z</published>
    <updated>2018-08-02T13:04:02.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><h2 id="DNS-prefetch"><a href="#DNS-prefetch" class="headerlink" title="DNS prefetch"></a>DNS prefetch</h2><p>DNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。<br><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</code></p><h2 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h2><p>和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。<br><code>&lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt;</code></p><h2 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h2><p>当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用，prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。<br><code>&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;</code><br>PS：可以解决字体文件必须等DOM和CSSOM创建好后才能下载的性能瓶颈。</p><h2 id="Subresource"><a href="#Subresource" class="headerlink" title="Subresource"></a>Subresource</h2><p>可以用来指定资源是最高优先级的。<br><code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code><br>PS：rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。</p><h2 id="Prerender"><a href="#Prerender" class="headerlink" title="Prerender"></a>Prerender</h2><p>prerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。<br>一些适用场景用户搜索后的结果页面、登录成功后的页面、多页文章（预先加载下一页的资源）<br><code>&lt;link rel=&quot;prerender&quot;  href=&quot;/thenextpage.html&quot; /&gt;</code><br>PS：该属性会下载所有的资源、创建DOM、渲染页面、执行JS<a href="https://www.w3.org/TR/page-visibility/" target="_blank" rel="external">这篇文章可以防止页面还没有展示给用户就出发JS的执行</a>等等。</p><h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源。<br><code>&lt;link rel=&quot;preload&quot; href=&quot;image.png&quot;&gt;</code><br><a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/" target="_blank" rel="external">AlloyTeam-一箩筐的预加载技术</a></p><h1 id="微任务（jobs）和宏任务（task）"><a href="#微任务（jobs）和宏任务（task）" class="headerlink" title="微任务（jobs）和宏任务（task）"></a>微任务（jobs）和宏任务（task）</h1><p>微任务包括：process.nextTick，原生Promise(有些实现的promise将then方法放到了宏任务中)，Object.observe(已废弃)，MutationObserver<br>宏任务包括：script，setTimeout，setInterval，setImmediate，I/O ，UI rendering，MessageChannel </p><h1 id="如何生成新图层（避免重排影响其他图层）"><a href="#如何生成新图层（避免重排影响其他图层）" class="headerlink" title="如何生成新图层（避免重排影响其他图层）"></a>如何生成新图层（避免重排影响其他图层）</h1><p>通过以下几个常用属性可以生成新图层<br>3D 变换：translate3d、translateZ<br>will-change<br>video、iframe 标签<br>通过动画实现的 opacity 动画转换<br>position: fixed</p><h1 id="React-16-加载性能优化"><a href="#React-16-加载性能优化" class="headerlink" title="React 16 加载性能优化"></a>React 16 加载性能优化</h1><p><a href="https://juejin.im/entry/5b506b315188251b24382faa" target="_blank" rel="external">React 16 加载性能优化指南</a></p><h1 id="CSS性能优化技巧"><a href="#CSS性能优化技巧" class="headerlink" title="CSS性能优化技巧"></a>CSS性能优化技巧</h1><h2 id="内联首屏关键CSS（Critical-CSS）"><a href="#内联首屏关键CSS（Critical-CSS）" class="headerlink" title="内联首屏关键CSS（Critical CSS）"></a>内联首屏关键CSS（Critical CSS）</h2><p>即为只将渲染首屏内容所需的关键CSS内联到HTML中。<br><a href="https://github.com/filamentgroup/criticalCSS" target="_blank" rel="external">github-首屏的关键样式提取</a></p><h2 id="异步加载CSS（四种方式）"><a href="#异步加载CSS（四种方式）" class="headerlink" title="异步加载CSS（四种方式）"></a>异步加载CSS（四种方式）</h2><p>第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。<br>第二种方式是将link元素的media属性设置为用户浏览器不匹配的媒体类型甚至不存在的类型都可以，对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。<br>`</p><p><link rel="stylesheet" href="mystyles.css" media="noexist" onload="this.media='all'"><br><code>第三种方式是通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。</code></p><p><link rel="alternate stylesheet" href="mystyles.css" onload="this.rel='stylesheet'"><br><code>第四中方式是rel=”preload”5这一Web标准指出了如何异步加载资源，包括CSS类资源。</code></p><p><link rel="preload" href="mystyles.css" as="style" onload="this.rel='stylesheet'"><br>`<br>PS：第四中为标准方案，as 属性是必须的。</p><h2 id="去除无用CSS"><a href="#去除无用CSS" class="headerlink" title="去除无用CSS"></a>去除无用CSS</h2><p><a href="https://github.com/uncss/uncss" target="_blank" rel="external">github-去除无用CSS</a></p><h2 id="有选择地使用选择器"><a href="#有选择地使用选择器" class="headerlink" title="有选择地使用选择器"></a>有选择地使用选择器</h2><p>CSS选择器的匹配是从右向左进行的。</p><h1 id="如何启用GPU硬件加速"><a href="#如何启用GPU硬件加速" class="headerlink" title="如何启用GPU硬件加速"></a>如何启用GPU硬件加速</h1><h2 id="什么情况形成新的层-layer？（作用为重绘时只影响该层，不影响层外的元素。）"><a href="#什么情况形成新的层-layer？（作用为重绘时只影响该层，不影响层外的元素。）" class="headerlink" title="什么情况形成新的层 layer？（作用为重绘时只影响该层，不影响层外的元素。）"></a>什么情况形成新的层 layer？（作用为重绘时只影响该层，不影响层外的元素。）</h2><ol><li>3D 或者 CSS的transform属性</li><li>video 和 canvas 元素</li><li>CSS的filter属性</li><li>覆盖在其它元素之上的元素，比如通过z-index提升层级</li></ol><h2 id="哪些属性直接在GPU处理？"><a href="#哪些属性直接在GPU处理？" class="headerlink" title="哪些属性直接在GPU处理？"></a>哪些属性直接在GPU处理？</h2><p>transform<br>opacity<br>filter<br>transform: translateZ(0); // 可以强制GPU渲染</p><h2 id="使用硬件加速需要注意的地方？"><a href="#使用硬件加速需要注意的地方？" class="headerlink" title="使用硬件加速需要注意的地方？"></a>使用硬件加速需要注意的地方？</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>GPU处理过多的内容会导致内存问题。这在移动端和移动端浏览器会导致崩溃。因此，通常不会对所有的元素使用硬件加速。</p><h3 id="Font-rendering"><a href="#Font-rendering" class="headerlink" title="Font rendering"></a>Font rendering</h3><p>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p><h3 id="浏览器的优化"><a href="#浏览器的优化" class="headerlink" title="浏览器的优化"></a>浏览器的优化</h3><p>通常配合will-change属性使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.example &#123;</div><div class="line">transform: rotate(1turn);</div><div class="line">will-change: transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：这个功能允许你告诉浏览器这个属性会发生变化，因此浏览器会在开始之前对其进行优化。<br><a href="https://juejin.im/post/5b6143996fb9a04fd343ae28" target="_blank" rel="external">在 CSS 动画中使用硬件加速</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预加载技术&quot;&gt;&lt;a href=&quot;#预加载技术&quot; class=&quot;headerlink&quot; title=&quot;预加载技术&quot;&gt;&lt;/a&gt;预加载技术&lt;/h1&gt;&lt;h2 id=&quot;DNS-prefetch&quot;&gt;&lt;a href=&quot;#DNS-prefetch&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="性能" scheme="https://fanerge.github.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="性能" scheme="https://fanerge.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>聊聊伪元素（::after和::before）、pointer-events属性、touch-action属性</title>
    <link href="https://fanerge.github.io/2018/%E8%81%8A%E8%81%8A%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%88-after%E5%92%8C-before%EF%BC%89%E5%92%8Cpointer-events%E5%B1%9E%E6%80%A7%E5%92%8Ctouch-action%E5%B1%9E%E6%80%A7.html"/>
    <id>https://fanerge.github.io/2018/聊聊伪元素（-after和-before）和pointer-events属性和touch-action属性.html</id>
    <published>2018-07-06T12:00:32.000Z</published>
    <updated>2018-07-14T13:56:40.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪元素（以-after举例）"><a href="#伪元素（以-after举例）" class="headerlink" title="伪元素（以::after举例）"></a>伪元素（以::after举例）</h1><h2 id="属性基础介绍"><a href="#属性基础介绍" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。<br>使用：CSS2.0为<code>element:after{content: &#39;&#39;;...}</code>；CSS3.0为<code>element::after{content: &#39;&#39;;...}</code><br>这些并不是我今天想讨论的，我们应该来看看伪元素的一些其他性质。</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>本文的重点：我们都知道我们不能为伪元素添加事件（目前是这样，不知道以后W3C会不会考虑），但是伪元素是可以触发元素本体上的事件。我认为伪元素的出现使我们在某种程度上可以精简DOM结构（伪元素可以达到补充、完善UI的目的），但是由于会触发元素本体上的事件，可能有些地方使用需要考虑一下了（在DOM简化的微小性能优化和是否适用于该场景中权衡一下）。<br>PS：元素本体：为了文章的好理解，我自己起的名字，意思为某个元素除了虚拟元素（::after等）以外的部分。<br>比如为了为了实现下图UI，用元素的 after伪类 实现登录和注册分割中的‘点.’，但这个 after伪类保留了 span标签 登录事件感觉有点不符合UI语义。<br><img src="http://pau044s3z.bkt.clouddn.com/after%E4%BC%AA%E7%B1%BB%E4%BD%BF%E7%94%A8.png" alt="after伪类的使用"></p><h1 id="CSS之pointer-events属性"><a href="#CSS之pointer-events属性" class="headerlink" title="CSS之pointer-events属性"></a>CSS之pointer-events属性</h1><p>我这里只讨论 pointer-events 的auto、none、inherit、initial、unset（不讨论SVG相关的属性值）。</p><h2 id="属性基础介绍-1"><a href="#属性基础介绍-1" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target，也就是说通过设置该属性可以控制该元素是否为事件的target。<br>对上面提到的属性值做下简单的介绍：<br>auto：  与 pointer-events 属性未指定时的表现效果相同<br>none：  元素永远不会成为鼠标事件的 target（不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍）。<br>inherit：  该关键字使得元素获取其父元素的计算值(computed value )，由于该属性为非继承属性 inherit 在这里指定的行为通常没有多大意义，一般使用使用 initial 或 unset 作为替代。<br>initial：  相关标准都设置了每个元素的的初始值，pointer-events 属性的初始值为 auto 。<br>unset：  关键字 unset 是 关键字 initial 和 inherit的组合（如果有继承父级样式，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值）。</p><h2 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h2><p>还记得我们刚刚讲到 pointer-events 的属性值为 none 时提到“不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍”，这里开始做说明。</p><blockquote><p> 使用pointer-events来阻止元素成为鼠标事件目标不一定意味着元素上的事件侦听器永远不会触发。如果元素后代明确指定了pointer-events属性并允许其成为鼠标事件的目标，那么指向该元素的任何事件在事件传播过程中都将通过父元素，并以适当的方式触发其上的事件侦听器。当然，位于父元素但不在后代元素上的鼠标活动都不会被父元素和后代元素捕获（鼠标活动将会穿过父元素而指向位于其下面的元素）。</p></blockquote><h3 id="该属性提高页面滚动时候的绘制性能是不准确的"><a href="#该属性提高页面滚动时候的绘制性能是不准确的" class="headerlink" title="该属性提高页面滚动时候的绘制性能是不准确的"></a>该属性提高页面滚动时候的绘制性能是不准确的</h3><p>为什么这么说呢？已经有前辈写过相应的文章，以及详细的测试数据<a href="https://www.zhangxinxu.com/wordpress/2014/01/pointer-events-none-avoiding-unnecessary-paints/" target="_blank" rel="external">pointer-events:none提高页面滚动时候的绘制性能？</a></p><h3 id="只能失效鼠标事件，并不能让键盘事件失效"><a href="#只能失效鼠标事件，并不能让键盘事件失效" class="headerlink" title="只能失效鼠标事件，并不能让键盘事件失效"></a>只能失效鼠标事件，并不能让键盘事件失效</h3><p>pointer-events 只能失效鼠标事件，并不能让键盘事件失效，所以用该属性对按钮的禁用需要小心<a href="https://www.zhangxinxu.com/wordpress/2011/12/css3-pointer-events-none-javascript/" target="_blank" rel="external">大家可以看看张鑫旭前辈的文章</a>。</p><h1 id="CSS之touch-action属性"><a href="#CSS之touch-action属性" class="headerlink" title="CSS之touch-action属性"></a>CSS之touch-action属性</h1><h2 id="属性基础介绍-2"><a href="#属性基础介绍-2" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。<br>属性值介绍：<br>auto：  当触控事件发生在元素上时，由浏览器来决定进行哪些操作，比如对viewport进行平滑、缩放等。<br>none：  当触控事件发生在元素上时，不进行任何操作。<br>pan-x：  启用单指水平平移手势。可以与 pan-y 、pan-up、pan-down、pinch-zoom 组合使用。<br>pan-y：  启用单指垂直平移手势。可以与 pan-x 、pan-left 、pan-right、pinch-zoom 组合使用。<br>manipulation：  浏览器只允许进行滚动和持续缩放操作。任何其它被auto值支持的行为不被支持。启用平移和缩小缩放手势，但禁用其他非标准手势，例如双击以进行缩放。 禁用双击可缩放功能可减少浏览器在用户点击屏幕时延迟生成点击事件的需要。<br>pinch-zoom：  启用多手指平移和缩放页面。 这可以与任何平移值组合。</p><h2 id="补充知识-2"><a href="#补充知识-2" class="headerlink" title="补充知识"></a>补充知识</h2><p>移动端300ms延迟，就可以使用 touch-action: manipulation;因为 manipulation 会禁用双击事件（浏览器就不需要等待300ms之后来判断了）。<br>处理移动端点击延迟代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">  touch-action: manipulation;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h3><ol><li><p>在地图或游戏开发中，最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#map &#123;</div><div class="line">  touch-action: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>水平图像轮播开发中，只想通过水平滑动但不想干扰网页的垂直滚动或缩放，可用以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.image-carousel &#123;</div><div class="line">  width: 100%;</div><div class="line">  height: 150px;</div><div class="line">  touch-action: pan-y pinch-zoom;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪元素（以-after举例）&quot;&gt;&lt;a href=&quot;#伪元素（以-after举例）&quot; class=&quot;headerlink&quot; title=&quot;伪元素（以::after举例）&quot;&gt;&lt;/a&gt;伪元素（以::after举例）&lt;/h1&gt;&lt;h2 id=&quot;属性基础介绍&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTTP知识（前端相关）</title>
    <link href="https://fanerge.github.io/2018/http%E5%BD%92%E7%BA%B3.html"/>
    <id>https://fanerge.github.io/2018/http归纳.html</id>
    <published>2018-07-05T12:21:36.000Z</published>
    <updated>2018-07-12T23:57:14.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全（Safe）"><a href="#安全（Safe）" class="headerlink" title="安全（Safe）"></a>安全（Safe）</h1><p>说一个HTTP方法是安全的，是说这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD和OPTIONS。<br>所有安全的方法都是idempotent（幂等），有些不安全的方法如PUT和DELETE则不是。<br>PS：网络爬虫也是依赖于安全的HTTP方法，安全方法: GET, HEAD, OPTIONS；非安全方法: PUT, DELETE, POST。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe" target="_blank" rel="external">MDN-Safe</a></p><h1 id="幂等（Idempotent）"><a href="#幂等（Idempotent）" class="headerlink" title="幂等（Idempotent）"></a>幂等（Idempotent）</h1><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态（不是返回的状态码而是数据）也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p><h1 id="HTTP方法比较"><a href="#HTTP方法比较" class="headerlink" title="HTTP方法比较"></a>HTTP方法比较</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体（也就是说只存在响应头无响应体）。<br>PS：该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST方法用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改。 </p><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>请求方法 PUT  用于新增资源或者使用请求中的有效负载替换目标资源的表现形式。<br>PS：PUT 与 POST 方法的区别在于，PUT方法是幂等的。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>DELETE 请求方法用于删除指定的资源。</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>OPTIONS 方法 用于获取目的资源所支持的通信选项。在 CORS 作为预检请求。</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>TRACE 方法 实行了向目标资源的沿路径的消息环回(loop-back)测试 ，提供了一种实用的debug机制。</p><h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><p>请求方法 PATCH  用于对资源进行部分修改。<br>PS：在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于  PUT 方法，而与 POST 方法类似，PATCH  方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="Cache-Control（请求头和响应头）"><a href="#Cache-Control（请求头和响应头）" class="headerlink" title="Cache-Control（请求头和响应头）"></a>Cache-Control（请求头和响应头）</h3><p>通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。<br>max-age：指定设置缓存最大的有效时间（单位为s）。<br>s-maxage：覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理CDN)，并且私有缓存中它被忽略。<br>public：表明响应可以被接收的客户端、代理服务器等缓存。<br>private：表明响应只能被客户端缓存，不能作为共享缓存（即代理服务器不能缓存它）。<br>no-cache：在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。<br>no-store：缓存不应存储有关客户端请求或服务器响应的任何内容。</p><h3 id="Expires（响应头）"><a href="#Expires（响应头）" class="headerlink" title="Expires（响应头）"></a>Expires（响应头）</h3><p>响应头包含日期/时间， 即在此时候之后，响应过期。<br>PS：如果在Cache-Control响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="Last-modified（响应头）"><a href="#Last-modified（响应头）" class="headerlink" title="Last-modified（响应头）"></a>Last-modified（响应头）</h3><p>它包含源头服务器认定的资源做出修改的日期及时间。<br>工作原理：浏览器首次请求资源是响应头中包含 Last-modified 字段，当再次请求时将上次 Last-modified 的值赋值给 If-Modified-Since 请求头，服务器根据对应资源的修改时间于 If-Modified-Since 的值进行比较，从而断定该资源是否被修改再响应304或200。</p><h3 id="ETag（响应头）"><a href="#ETag（响应头）" class="headerlink" title="ETag（响应头）"></a>ETag（响应头）</h3><p>工作原理：和 Last-modified（If-Modified-Since）工作原理基本一致，只不过服务器判断资源是否被更改的条件不是文件修改时间而是为资源生产的hash值是否发生变化。<br>PS：可以弥补 max-age 和 Last-modified 只能精确到秒的缺陷。<br><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/" target="_blank" rel="external">alloyteam-浅谈Web缓存</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安全（Safe）&quot;&gt;&lt;a href=&quot;#安全（Safe）&quot; class=&quot;headerlink&quot; title=&quot;安全（Safe）&quot;&gt;&lt;/a&gt;安全（Safe）&lt;/h1&gt;&lt;p&gt;说一个HTTP方法是安全的，是说这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器
      
    
    </summary>
    
      <category term="http" scheme="https://fanerge.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://fanerge.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>懂这些，你将能构建更安全的Web应用</title>
    <link href="https://fanerge.github.io/2018/web%E5%AE%89%E5%85%A8.html"/>
    <id>https://fanerge.github.io/2018/web安全.html</id>
    <published>2018-06-27T14:05:43.000Z</published>
    <updated>2018-07-11T14:55:08.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="同源策略（Same-Origin-Policy）"><a href="#同源策略（Same-Origin-Policy）" class="headerlink" title="同源策略（Same Origin Policy）"></a>同源策略（Same Origin Policy）</h2><p>同源策略限制了一个源（origin）中加载的文档或脚本与其他源（origin）中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。<br>源的定义：如果两个页面的协议、域名、端口（如果有指定）和都相同，则两个页面具有相同的源。</p><h2 id="浏览器沙箱Sandbox-和-多线程架构"><a href="#浏览器沙箱Sandbox-和-多线程架构" class="headerlink" title="浏览器沙箱Sandbox 和 多线程架构"></a>浏览器沙箱Sandbox 和 多线程架构</h2><p>浏览器为我们提供了一个独立的沙箱环境，尽量来保障浏览器的安全，也有部分浏览器采用一个 tab 页面一个线程，这样多线程架构增强了浏览器的安全（即使某个线程崩溃了，也不至于浏览器崩溃）。 </p><h2 id="恶意网址拦截（大多基于黑名单）"><a href="#恶意网址拦截（大多基于黑名单）" class="headerlink" title="恶意网址拦截（大多基于黑名单）"></a>恶意网址拦截（大多基于黑名单）</h2><p>常见的黑名单获取：<a href="https://www.phishtank.com/" target="_blank" rel="external">PhishTank恶意网址黑名单</a>、Google 的SafeBrowsing API、EVSSL证书</p><h2 id="更安全的浏览器进化"><a href="#更安全的浏览器进化" class="headerlink" title="更安全的浏览器进化"></a>更安全的浏览器进化</h2><p>IE8 的 XSS Filter功能<br>Firefox 的 CSP（Content Security Policy）</p><h1 id="XSS（跨站脚本攻击Cross-Site-Script）"><a href="#XSS（跨站脚本攻击Cross-Site-Script）" class="headerlink" title="XSS（跨站脚本攻击Cross Site Script）"></a>XSS（跨站脚本攻击Cross Site Script）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意 Web 用户将代码植入到提供给其它用户使用的页面中。<br>XSS分为三种类型：1.反射型XSS 2.存储型XSS 3.DOM Based XSS（通过修改页面的DOM节点形成的XSS）</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>Cookie劫持（一般Cookie作为登录凭证，通过HttpOnly可以防止）、构造GET与POST请求、XSS钓鱼、识别用户浏览器、CSS HIstory Hack（访问过的连接会使用:visited的样式）、获取用户的真实IP地址（前提如用户安装了Java环境JRE等）、XSS Worm</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>CSP(Content Security Policy)、对特殊字符转义，不要相信任何来自用户的输入（包括请求体、queryString甚至是请求Headers）</p><ol><li>响应头 HttpOnly 有效保护 Cookie</li><li>XSS Filter输入检查 排除、转义特殊字符</li><li>输出检查</li><li>安全的编码函数 HtmlEncode （将特殊字符转换为实体字符）</li><li>只需一种编码吗 浏览器解析 htmlparser 优先于 JavaScript Parser</li></ol><h2 id="对于处理富文本开发："><a href="#对于处理富文本开发：" class="headerlink" title="对于处理富文本开发："></a>对于处理富文本开发：</h2><ol><li>我们应该让事件被严格禁止，不包含iframe、script、base、form等危险标签。</li><li>使用白名单，避免使用黑名单。</li><li>OWASP 开源的 XSS Filter 项目（Antisamy–Java 和 .NET）（HTML Purifier–PHP） </li></ol><p><a href="https://www.zhuyingda.com/blog/article.html?id=2" target="_blank" rel="external">XSS漏洞的原理</a></p><h1 id="CSRF（跨站点脚本Cross-site-request-forgery）"><a href="#CSRF（跨站点脚本Cross-site-request-forgery）" class="headerlink" title="CSRF（跨站点脚本Cross-site request forgery）"></a>CSRF（跨站点脚本Cross-site request forgery）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>是指在黑客已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器 CRUD 来执行读写操作。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>验证码，我们应该使用验证码作为防御 CSRF 的辅助手段，而不应该作为最主要的解决方案（毕竟不可能所有操作都加上验证码，多次验证码不利于用户体验）。<br>Referer Check ，常见应用为防止图片盗链，直白的讲就是后端需要检查请求头中的 Referer 字段，是否为我们期望的”源”。<br>Anti CSRF Token，需要保证使用足够安全的随机数生产算法或真随机数生成器，只有用户和服务器共同持有，才能保证安全。<br>PS：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。<br><a href="https://www.zhuyingda.com/blog/article.html?id=5" target="_blank" rel="external">CSRF漏洞的原理</a></p><h1 id="clickjacking（点击劫持）"><a href="#clickjacking（点击劫持）" class="headerlink" title="clickjacking（点击劫持）"></a>clickjacking（点击劫持）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>点击劫持其实是一种视觉上的欺骗手段，攻击者将一个透明的、不可见的iframe覆盖在一个网页上，通过调整iframe页面位置，诱使用户在页面上进行操作，在不知情的情况下用户的点击恰好是点击在iframe页面的一些功能按钮上，其实还也可使用 img 来代替 iframe，这就是后面要说的 XSIO。<br>HTML5的Drag 和 Drop API会发生数据窃取，分别在 Drag 隐藏一个 iframe ，在 Drop 中 隐藏一个 textarea ，在 drop 事件时就可以获取来自 drag 的数据，从而形成数据劫持，event.dataTransfer.getData()</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>frame busting：禁止iframe的嵌套<a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">JS防止潜入</a><br>X-Frame-Options：防止或限制网页内嵌（http头部X-FRAME-OPTIONS）<br>CSP的frame-ancestors：指定了一个可以包含frame，iframe，object，embed，or applet等元素的有效来源。<br>PS：http头部X-FRAME-OPTIONS为非标准的（但所有浏览器都支持），你可以使用CSP的frame-ancestors（标准属性）。<br>同样还有触屏劫持（TapJacking）实现原理基本类似。<br><a href="https://www.zhuyingda.com/blog/article.html?id=6" target="_blank" rel="external">ClickJacking漏洞的原理</a></p><h1 id="window-name-的妙用"><a href="#window-name-的妙用" class="headerlink" title="window.name 的妙用"></a>window.name 的妙用</h1><p>window.name 属性可设置或返回存放窗口的名称的一个字符串。<br>因为 window 对象是浏览器的窗体，并非 document 对象，因此许多时候 window 对象不受同源策略的限制。<br>可以利用该属性实现跨域、跨页面传递数据<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">可以使用postMessage来进行跨源通信</a>。</p><h1 id="XSIO"><a href="#XSIO" class="headerlink" title="XSIO"></a>XSIO</h1><p>原理：没有限制图片的position属性为absolute，导致可以控制一张图片出现在网页的任意位置。<br><a href="https://blog.csdn.net/inject2006/article/details/3057045" target="_blank" rel="external">百度的XSIO</a></p><h1 id="iframe-的-sandbox-属性"><a href="#iframe-的-sandbox-属性" class="headerlink" title="iframe 的 sandbox 属性"></a>iframe 的 sandbox 属性</h1><p>可以防止以下操作：</p><ol><li>访问父页面的DOM（从技术角度来说，这是因为相对于父页面iframe已经成为不同的源了）</li><li>执行脚本</li><li>通过脚本嵌入自己的表单或操作表单</li><li>对cookie、本地存储Storage、本地数据库IndexDB的读写</li></ol><p>PS：sandbox 属性有 allow-same-origin（允许同源访问）、allow-top-navigation（允许访问顶层窗口）、allow-forms（允许提交表单）、allow-script（允许执行脚本）</p><h1 id="a标签-和-area标签的安全问题"><a href="#a标签-和-area标签的安全问题" class="headerlink" title="a标签 和 area标签的安全问题"></a>a标签 和 area标签的安全问题</h1><p>当a链接有target=”_blank”属性时，必须添加rel=”noreferrer noopener”，不然新产生的页面可以通过window.opener来获取到父窗口的window对象。<br><code>&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; &gt;</code></p><h1 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP (内容安全策略)"></a>CSP (内容安全策略)</h1><p>内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。<br>其实CSP的本质是以白名单的机制对网站加载或执行的资源起作用。</p><h2 id="适用方式"><a href="#适用方式" class="headerlink" title="适用方式"></a>适用方式</h2><ol><li>可以通过配置你的网络服务器返回  Content-Security-Policy  HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部，它是旧版本)。</li><li>在html页面中meta元素中使用，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt;</div></pre></td></tr></table></figure></li></ol><h1 id="隐私与-visited选择器"><a href="#隐私与-visited选择器" class="headerlink" title="隐私与:visited选择器"></a>隐私与:visited选择器</h1><h2 id="为什么说-visited选择器暴露了用户隐私？"><a href="#为什么说-visited选择器暴露了用户隐私？" class="headerlink" title="为什么说:visited选择器暴露了用户隐私？"></a>为什么说:visited选择器暴露了用户隐私？</h2><p>曾经，CSS选择器 :visited 被网站用来查看用户的浏览记录。通过使用 getComputedStyle() 或其他方法扫描用户的浏览记录来获取用户访问了哪些网站。这很容易实现，不仅能够判断用户是否曾经访问过这个页面，还能猜测出大量的用户身份信息。<br>不过现代浏览器已经做了相应的修复和只能给已访问链接设置少量的样式（color、background-color、border-color、outline-color、fill 和 stroke 等）</p><h1 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h1><p>CORS属于HTTP访问控制特性，以下内容大多针对于XMLHttpRequest，有些并不适用于 Fetch 。<br>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。<br>比如，站点 <code>http://domain-a.com</code> 的某 HTML 页面通过 <code>img</code> 的 <code>src</code> 请求 <code>http://domain-b.com/image.jpg</code>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。<br>PS：跨域并非不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）<br>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><h1 id="X-Frame-Options-响应头"><a href="#X-Frame-Options-响应头" class="headerlink" title="X-Frame-Options 响应头"></a>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>frame</code>（已废弃）, <code>iframe</code> 或者 <code>object</code> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p><h2 id="使用-X-Frame-Options"><a href="#使用-X-Frame-Options" class="headerlink" title="使用 X-Frame-Options"></a>使用 X-Frame-Options</h2><p>X-Frame-Options 有三个值:<br>DENY–表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。<br>SAMEORIGIN–表示该页面可以在相同域名页面的 frame 中展示。<br>ALLOW-FROM uri–表示该页面可以在指定来源的 frame 中展示。<br>PS：如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><h1 id="前端反爬虫"><a href="#前端反爬虫" class="headerlink" title="前端反爬虫"></a>前端反爬虫</h1><p>该课题是在腾讯的<a href="http://imweb.io/topic/595b7161d6ca6b4f0ac71f05" target="_blank" rel="external">IMWeb前端博客上看到的，整理于此，非常感谢。</a><br><a href="http://litten.me/2017/07/09/prevent-spiders/" target="_blank" rel="external">反击爬虫，前端工程师的脑洞可以有多大？</a></p><h2 id="FONT-FACE拼凑式"><a href="#FONT-FACE拼凑式" class="headerlink" title="FONT-FACE拼凑式"></a>FONT-FACE拼凑式</h2><p><a href="http://maoyan.com/films/#content" target="_blank" rel="external">猫眼电影</a>-页面使用了font-face定义了字符集，并通过unicode去映射展示。</p><h2 id="BACKGROUND拼凑式"><a href="#BACKGROUND拼凑式" class="headerlink" title="BACKGROUND拼凑式"></a>BACKGROUND拼凑式</h2><p>美团-与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p><h2 id="字符穿插式"><a href="#字符穿插式" class="headerlink" title="字符穿插式"></a>字符穿插式</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&amp;mid=2247484365&amp;idx=4&amp;sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&amp;chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&amp;scene=4" target="_blank" rel="external">微信公众号文章</a>-某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。</p><h2 id="伪元素隐藏式"><a href="#伪元素隐藏式" class="headerlink" title="伪元素隐藏式"></a>伪元素隐藏式</h2><p><a href="https://car.autohome.com.cn/config/series/3170.html" target="_blank" rel="external">汽车之家</a>-把关键的厂商信息，做到了伪元素的content里（如汽车厂家）。</p><h2 id="元素定位覆盖式"><a href="#元素定位覆盖式" class="headerlink" title="元素定位覆盖式"></a>元素定位覆盖式</h2><p><a href="https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&amp;searchArrivalAirport=%E5%8C%97%E4%BA%AC&amp;searchDepartureTime=2018-06-27&amp;searchArrivalTime=2018-06-29&amp;nextNDays=0&amp;startSearch=true&amp;fromCode=CAN&amp;toCode=BJS&amp;from=qunarindex&amp;lowestPrice=null" target="_blank" rel="external">去哪网</a>-对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格。</p><h2 id="IFRAME异步加载式"><a href="#IFRAME异步加载式" class="headerlink" title="IFRAME异步加载式"></a>IFRAME异步加载式</h2><p><a href="http://music.163.com/#/song?id=424477863" target="_blank" rel="external">网易云音乐</a>-页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面。</p><h2 id="字符分割式"><a href="#字符分割式" class="headerlink" title="字符分割式"></a>字符分割式</h2><p><a href="http://www.goubanjia.com/" target="_blank" rel="external">全网代理IP</a>-他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p><h2 id="字符集替换式"><a href="#字符集替换式" class="headerlink" title="字符集替换式"></a>字符集替换式</h2><p><a href="https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&amp;arrCity=%E4%B8%8A%E6%B5%B7&amp;goDate=2018-06-27&amp;from=touch_index_search&amp;child=0&amp;baby=0&amp;cabinType=0" target="_blank" rel="external">去哪儿移动侧</a>-html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果<br>PS：常用的后端反爬有 User-Agent + Referer检测、账号及Cookie验证、验证码、IP限制频次。</p><h1 id="子资源完整性（SRI-Subresource-Integrity）"><a href="#子资源完整性（SRI-Subresource-Integrity）" class="headerlink" title="子资源完整性（SRI,Subresource Integrity）"></a>子资源完整性（SRI,Subresource Integrity）</h1><p>子资源完整性(Subresource Integrity)是允许浏览器检查其获得的资源（例如从 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CDN" target="_blank" rel="external">CDN</a> 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。<br>子资源完整性 (SRI) 是一种安全功能，允许浏览器验证所获取的文件 (比如，从一个 CDN 内容分发网络) 是无意外操作而交付的。它的工作原理是允许你提供一个获取文件必须匹配的加密哈希。</p><h2 id="SRI-如何工作"><a href="#SRI-如何工作" class="headerlink" title="SRI 如何工作"></a>SRI 如何工作</h2><p>使用 内容分发网络 (CDN) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件)，因此可能潜在地攻击所有从该 CDN 获取文件的站点。<br>子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。</p><h2 id="如何使用-SRI"><a href="#如何使用-SRI" class="headerlink" title="如何使用 SRI"></a>如何使用 SRI</h2><p>将使用 base64 编码过后的文件哈希值写入你所引用的 script 或 link 标签的 integrigy 属性值中即可启用子资源完整性功能。<br>PS：integrity 值分成两个部分，第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。<br>integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。</p><h3 id="内容安全策略（CSP）和子资源完整性（SRI）共同使用"><a href="#内容安全策略（CSP）和子资源完整性（SRI）共同使用" class="headerlink" title="内容安全策略（CSP）和子资源完整性（SRI）共同使用"></a>内容安全策略（CSP）和子资源完整性（SRI）共同使用</h3><p>你可以根据内容安全策略来配置你的服务器使得指定类型的文件遵守 SRI。这是通过在 CSP 头部添加 require-sri-for 指令实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这条指令规定了所有 JavaScript 都要有 integrity 属性，且通过验证才能被加载。</div><div class="line">Content-Security-Policy: require-sri-for script;</div><div class="line">// 你也可以指定所有样式表也要通过 SRI 验证：</div><div class="line">Content-Security-Policy: require-sri-for style;</div></pre></td></tr></table></figure></p><p>你也可以对两者都加上验证。</p><h2 id="生成-SRI-哈希的工具"><a href="#生成-SRI-哈希的工具" class="headerlink" title="生成 SRI 哈希的工具"></a>生成 SRI 哈希的工具</h2><h3 id="openssl-在命令行"><a href="#openssl-在命令行" class="headerlink" title="openssl 在命令行"></a>openssl 在命令行</h3><p>你可以用 openssl 在命令行中执行如下命令来生成 SRI 哈希值：<br><code>cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A</code><br><a href="https://www.srihash.org/" target="_blank" rel="external">在线生成 SRI 哈希值的工具</a><br>下面以知乎的一个js文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原js文件地址</div><div class="line">https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js</div><div class="line">// 生成的脚本标签</div><div class="line">&lt;script src=&quot;https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js&quot; integrity=&quot;sha384-B4YDh2AljLezOmNwiezobW8FJbJQfyZxm1SksT7THfKULK6SVxN+dRNSvLxEmXtA&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><h3 id="shasum-在命令行"><a href="#shasum-在命令行" class="headerlink" title="shasum 在命令行"></a>shasum 在命令行</h3><p><code>shasum -b -a 384 FILENAME.js | xxd -r -p | base64</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="external">MDN-SRI</a></p><h1 id="用户密码是泄漏的原因？"><a href="#用户密码是泄漏的原因？" class="headerlink" title="用户密码是泄漏的原因？"></a>用户密码是泄漏的原因？</h1><p> HTTPS 协议旨在保护用户数据在网络上不被窃听（机密性） 和不被篡改（完整性）。处理用户数据的网站应该使用 HTTPS 协议保护他们的用户不受黑客的侵害。如果网站使用 HTTP 协议而不是 HTTPS 协议，窃取用户信息（比如他们的登录凭证）将会轻而易举。这曾经被 <a href="http://codebutler.github.io/firesheep/" target="_blank" rel="external">Firesheep</a> 很好地演示过。<br>这里罗列出密码所牵涉到的安全问题：</p><ol><li>在HTTP之上运行登录表单. 即使表单的action对象是HTTPS链接,用户的登录表单信息也会受到威胁,因为攻击者能够通过用户修改用户接收到的页面(例如,攻击者插入键盘记录脚本来盗取用户输入的密码.他们还能改变表单目的页从而将敏感信息传递到受他们控制的服务器).</li><li>在表单的action链接中使用HTTP链接.在这种情况下,用户输入的任何信息都将以明文方式通过网络传递.这样,从密码离开用户的电脑到密码到达服务器过程中,用户的密码将清楚地展现在任何嗅探用户网络的人眼前.</li><li>在网页iframe中递交登录表单(或是嵌入在HTTP frame中的HTTPS frame).即使最上层页面是HTTPS,但在HTTP iframe中包含密码域和在HTTP页面中包含密码域是没有区别的.攻击者同样能够修改这个页面以及偷取用户信息.</li><li>有时网页需要用户名及密码,但实际上却没有存储这些敏感的信息.例如,一个新闻页面可能存储一个用户想要再次阅读的文章,却没有存储任何关于这位用户的其他信息.这个新闻站点的网页开发者可能没有动力去对于提高他的网站的安全性以及保护他们用户的信息.不幸的是,密码重用也是一个大问题.用户可能在不同的站点使用相同的密码(新闻网页,社交网络,电子邮箱及其银行).因此即使通过用户名及密码登陆你的网页对你来说不是很大的问题,对于重复使用相同用户名及密码来登陆他们银行账户的用户来说却是一个极大的威胁.网络攻击者正变得越来越聪明.他们在一个网站同时盗取用户名及密码然后在另一个可能能给他们带来金钱的网站上使用这些密码.</li></ol><h1 id="弱签名算法"><a href="#弱签名算法" class="headerlink" title="弱签名算法"></a>弱签名算法</h1><p>在签署数字证书时，哈希算法的完整性是决定证书安全性的关键因素。哈希算法的弱点可能导致攻击者在某些情况下能够获得伪造的证书。由于技术的升级和已知的新型攻击，此类攻击的可行性已经大为提升。因此，不推荐使用旧算法，对于旧算法的支持最终也会停止。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>对基于MD5的签名的支持已在2012年初停止。</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>基于SHA-1的签名非常普遍；截至2015年5月，大约45%的数字证书皆使用此算法。但是，SHA-1已经过时因而不再推荐使用。<br>SHA-1的证书将从2017开始不再被主流浏览器厂商视为安全的。</p><h2 id="SHA-2（推荐使用）"><a href="#SHA-2（推荐使用）" class="headerlink" title="SHA-2（推荐使用）"></a>SHA-2（推荐使用）</h2><p>SHA-2是一个哈希算法家族，其中包括SHA-256和SHA-512。截至2015年，SHA-2家族被认为足够安全强大。许多证书颁发机构颁发新的证书使用SHA-256。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用预编译语句、使用存储过程、检查数据类型、使用安全函数（编码特殊字符）、最小权限原则（是否可操作数据库）<br>PS：防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。</p><h1 id="MIMT-中间人攻击Man-in-the-middle-attacks"><a href="#MIMT-中间人攻击Man-in-the-middle-attacks" class="headerlink" title="MIMT(中间人攻击Man-in-the-middle-attacks)"></a>MIMT(中间人攻击Man-in-the-middle-attacks)</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>Client &lt;–&gt; Proxy Server(Middle Man这里可能存在攻击) &lt;–&gt; Web Server真实的服务器<br>Client 发出的请求 和 Web Server返回的数据都经过Proxy Server 转发，这个Proxy Server 就起到了一个Middle Man的作用，如果这个“中间人” 够黑，那么整个代理过程的数据都可以由这个“中间人”控制，“中间人”可以进行截取敏感数据、代码注射、Proxp worm操作。</p><h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p>启用虚拟专用网(VPN)、https(传输报文加密)<br><a href="https://www.zhuyingda.com/blog/article.html?id=7" target="_blank" rel="external">web中间人攻击的威胁</a></p><h1 id="DDOS（分布式拒绝服务Distributed-Denial-of-Service）"><a href="#DDOS（分布式拒绝服务Distributed-Denial-of-Service）" class="headerlink" title="DDOS（分布式拒绝服务Distributed Denial of Service）"></a>DDOS（分布式拒绝服务Distributed Denial of Service）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>最基本的DDOS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。</p><h2 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h2><p>限制请求频率、高防服务器、黑名单、DDoS 清洗、CDN（隐藏真实IP及分流）</p><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="SYN-flood（网络层DDOS）"><a href="#SYN-flood（网络层DDOS）" class="headerlink" title="SYN flood（网络层DDOS）"></a>SYN flood（网络层DDOS）</h3><p><a href="https://www.cnblogs.com/popduke/p/5823801.html" target="_blank" rel="external">什么是SYN Flood攻击?</a><br>对抗措施：SYN Cookie 为每一个IP地址分配一个Cookie，并统计每个IP地址的访问频率。如果短时间内收到大量的来自同一个IP地址的数据包，则认为是受到攻击，之后来自这个IP地址的包将被丢失。</p><h3 id="Challenge-Collapasar（应用层DDOS）"><a href="#Challenge-Collapasar（应用层DDOS）" class="headerlink" title="Challenge Collapasar（应用层DDOS）"></a>Challenge Collapasar（应用层DDOS）</h3><p>原理：对一些消耗资源较大的应用页面不断发起正常的请求（查询数据库、读写硬盘文件等），以达到消耗服务端资源的目的。<br>对抗措施：在应用中针对每个”客户端”做一个请求频率的限制，可以通过IP地址与Cookie定位一个客户端。<br>若IP地址改变（代理服务器）或Cookie清空，应该使用应用代码要做好性能优化（常用数据转移到内存中），在网络架构上做好优化（利用负载均衡、CDN、镜像站点等分流，减轻主站的压力）。<br><a href="https://www.zhihu.com/question/22259175" target="_blank" rel="external">知乎-什么是 DDoS 攻击？</a></p><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><ol><li>上传文件是Web脚本语言</li><li>上传文件是木马、病毒文件，诱骗用户或者管理员下载执行</li><li>上传文件是钓鱼图片或包含了脚本的图片，在某些浏览器会被作为脚本执行</li></ol><h2 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h2><p>文件上传的目录设置为不可执行<br>判断文件类型（使用白名单而不是黑名单）<br>使用随机数改写文件名和文件路径<br>单独设置文件服务器的域名</p><h2 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h2><h3 id="绕过文件上传检查功能"><a href="#绕过文件上传检查功能" class="headerlink" title="绕过文件上传检查功能"></a>绕过文件上传检查功能</h3><p>UI原本允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\0].JPG，其中[\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为0x00字符截断的关系，最终会变成xxx.php。<br>对应的解决方案，可以检查附件头信息（同样也可以使用脚本语言来伪造一个合法头信息，这时应该提供不让脚本执行的容器，Web Server将其当做静态文件来解析，从而避免）。</p><h2 id="Apache文件解析问题"><a href="#Apache文件解析问题" class="headerlink" title="Apache文件解析问题"></a>Apache文件解析问题</h2><p>在Apache1.x、Apache2.x中，对文件名的解析就存在以下特性。<br>Apache对于文件的解析是从后往前解析的，知道遇到一个Apache认识的文件类型为止。<br>Apache的mime.types文件配置了Apache能认识那些文件。</p><h1 id="认证与会话管理"><a href="#认证与会话管理" class="headerlink" title="认证与会话管理"></a>认证与会话管理</h1><h2 id="认证和授权？"><a href="#认证和授权？" class="headerlink" title="认证和授权？"></a>认证和授权？</h2><p>认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。</p><h2 id="常见的认证方式"><a href="#常见的认证方式" class="headerlink" title="常见的认证方式"></a>常见的认证方式</h2><p>密码认证<br>多因素认证（手机号+身份证+护照等等）<br>Session 与认证（对SessionID加密后保存在Cookie中，Cookie随HTTP请求发送，且受浏览器同源策略的保护）</p><h2 id="常见攻击"><a href="#常见攻击" class="headerlink" title="常见攻击"></a>常见攻击</h2><p>Session Fixation 攻击：登录前和登录后，重写 Session ID。</p><h2 id="单点登录（SSO）"><a href="#单点登录（SSO）" class="headerlink" title="单点登录（SSO）"></a>单点登录（SSO）</h2><p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。<br>OpenID：OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。</p><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="垂直权限管理"><a href="#垂直权限管理" class="headerlink" title="垂直权限管理"></a>垂直权限管理</h2><p>主要为基于角色的访问控制（Role-Based Access Control）RBAC<br>一个用户有多个角色，一个角色有一个权限集合，最小粒度为每个权限（权限码）。<br>有以下几个分类</p><h3 id="基于URL的访问控制"><a href="#基于URL的访问控制" class="headerlink" title="基于URL的访问控制"></a>基于URL的访问控制</h3><p>如不同角色能访问不同的页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;sec:http&gt;</div><div class="line">&lt;sec:intercept-url pattern=&quot;/admin&quot; access=&quot;ROLE_ADMIN&quot;/&gt;</div><div class="line">&lt;sec:intercept-url pattern=&quot;/user/*&quot; access=&quot;ROLE_USER&quot;/&gt;</div><div class="line">&lt;/sec:http&gt;</div></pre></td></tr></table></figure></p><h3 id="基于method的访问控制"><a href="#基于method的访问控制" class="headerlink" title="基于method的访问控制"></a>基于method的访问控制</h3><p>如限定角色调用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@PreAuthorize(&quot;hasRole(&apos;ROLE_USER&apos;)&quot;)</div><div class="line">public void create(Contact contact)</div></pre></td></tr></table></figure></p><h3 id="基于表达式的访问控制"><a href="#基于表达式的访问控制" class="headerlink" title="基于表达式的访问控制"></a>基于表达式的访问控制</h3><p>如角色和IP地址验证<br><code>hasRole(&#39;admin&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;)</code></p><h2 id="水平权限管理"><a href="#水平权限管理" class="headerlink" title="水平权限管理"></a>水平权限管理</h2><h3 id="什么叫水平权限？"><a href="#什么叫水平权限？" class="headerlink" title="什么叫水平权限？"></a>什么叫水平权限？</h3><p>用户A只能访问用户A的数据，不能通过构造URL等手段访问到用户B的数据。</p><h2 id="OAuth（Open-Authorization）"><a href="#OAuth（Open-Authorization）" class="headerlink" title="OAuth（Open Authorization）"></a>OAuth（Open Authorization）</h2><p>OAUTH协议是一个在不提供用户名和密码的情况下，授权第三方应用访问 Web 资源的安全协议。<br>OAuth1.0中分为3个角色（Consumer：消费方 Client、Service Provider：服务提供方 Server、User：用户 Resource Owner）<br>如我们在人人网，想要导入用户MSN里的好友<br>这里人人网为消费方；MSN为服务提供方、用户为资源拥有者</p><h1 id="cookie防篡改（实现思路）"><a href="#cookie防篡改（实现思路）" class="headerlink" title="cookie防篡改（实现思路）"></a>cookie防篡改（实现思路）</h1><ol><li>服务端提供一个签名生成算法secret</li><li>根据方法生成签名secret(wall)=34Yult8i</li><li>将生成的签名放入对应的Cookie项username=wall|34Yult8i。其中，内容和签名用|隔开。</li><li>服务端根据接收到的内容和签名，校验内容是否被篡改（签名和服务器之前生成的不一致则表示cookie被篡改了）。</li></ol><p><a href="https://juejin.im/post/5b02fe326fb9a07ab1117c82" target="_blank" rel="external">Cookie防篡改机制</a></p><blockquote><p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">浏览器的同源策略</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://publicsuffix.org/" target="_blank" rel="external">PUBLIC SUFFIX LIST</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="external">X-Frame-Options</a><br><a href="https://www.srihash.org/" target="_blank" rel="external">SRI Hash Generator</a><br><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">HTTPS</a><br><a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt，免费好用的 HTTPS 证书</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浏览器安全&quot;&gt;&lt;a href=&quot;#浏览器安全&quot; class=&quot;headerlink&quot; title=&quot;浏览器安全&quot;&gt;&lt;/a&gt;浏览器安全&lt;/h1&gt;&lt;h2 id=&quot;同源策略（Same-Origin-Policy）&quot;&gt;&lt;a href=&quot;#同源策略（Same-Origin-
      
    
    </summary>
    
      <category term="安全" scheme="https://fanerge.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://fanerge.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS技巧</title>
    <link href="https://fanerge.github.io/2018/CSS%E6%8A%80%E5%B7%A7.html"/>
    <id>https://fanerge.github.io/2018/CSS技巧.html</id>
    <published>2018-06-13T14:29:35.000Z</published>
    <updated>2018-06-18T08:40:35.512Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结日常CSS技巧，大多收集于网络、<a href="http://www.ituring.com.cn/book/1695" target="_blank" rel="external">《CSS揭秘》</a></p><h2 id="半透明边框"><a href="#半透明边框" class="headerlink" title="半透明边框"></a>半透明边框</h2><p>思路：默认 background 是从  border-box 裁切，我们可以通过 background-clip 属性来改变 background 裁切区域如 padding-box，在使用 rgba 或者 hsla 来指定边框颜色即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.border &#123;</div><div class="line">border: 10px solid hsla(0,0%,100%,.5);</div><div class="line">background: white;</div><div class="line">background-clip: padding-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/translucent-borders">半透明边框</a><br>PS：根据 stack context 层级关系 background 在 border 下层。</p><h2 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h2><h3 id="box-shadow-方案"><a href="#box-shadow-方案" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><p>思路：首先要知道 box-shadow 的参数：vl hl blurl spreadl color inset，并且支持多重阴影。<br><a href="play.csssecrets.io/multiple-borders">demo</a><br>PS：box-shadow 不影响布局（不占用空间）、不受 box-sizing 的控制、不适用于增加热点区域。</p><h3 id="outline-方案"><a href="#outline-方案" class="headerlink" title="outline 方案"></a>outline 方案</h3><p>只适用于两层边框。<br>PS：当 border 为圆角时，outline 不会贴合元素的圆角，需要使用 box-shadow 来填补。 </p><h2 id="灵活的背景定位"><a href="#灵活的背景定位" class="headerlink" title="灵活的背景定位"></a>灵活的背景定位</h2><h3 id="background-position-的扩展语法方案"><a href="#background-position-的扩展语法方案" class="headerlink" title="background-position 的扩展语法方案"></a>background-position 的扩展语法方案</h3><p><code>background-position: right 20px bottom 10px;</code><br>PS：背景定位于 right 的 20px处，bottom 的 10px处。<br><a href="play.csssecrets.io/extended-bg-position">bg-position</a></p><h3 id="background-origin-方案"><a href="#background-origin-方案" class="headerlink" title="background-origin 方案"></a>background-origin 方案</h3><p>background-origin 属性指定 background-position 属性应该是相对位置。<br><a href="play.csssecrets.io/background-origin">background-origin</a></p><h3 id="calc-方案"><a href="#calc-方案" class="headerlink" title="calc() 方案"></a>calc() 方案</h3><p><code>background-position: calc(100% - 20px) calc(100% - 10px);</code><br>PS：需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)。<br><a href="play.csssecrets.io/background-position-calc">background-position-calc</a></p><h2 id="边框内圆角"><a href="#边框内圆角" class="headerlink" title="边框内圆角"></a>边框内圆角</h2><p>我们知道box-shadow是会紧贴border-radius圆角边的，但是，描边outline并不会与圆角边border-radius贴合，我们可以将两者组合，通过box-shadow去填补描边outline所产生的间隙来达到我们想要的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">border-radius: 8px;</div><div class="line">    outline: 6px solid #b4a078;</div><div class="line">    box-shadow: 0 0 0 5px #b4a078; // 用于填充 outline 不能紧靠 border-radius</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://lhammer.cn/You-need-to-know-css/#/inner-rounding" target="_blank" rel="external">边框内圆角</a></p><h2 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h2><h3 id="横向条纹（默认横向渐变）"><a href="#横向条纹（默认横向渐变）" class="headerlink" title="横向条纹（默认横向渐变）"></a>横向条纹（默认横向渐变）</h3><p>如形成三条间隔条纹背景。<br><code>background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);</code><br>PS：#58a 0 的作用为直接填充 &gt; 33.3% 的部分。<br><a href="play.csssecrets.io/horizontal-stripes">horizontal-stripes</a></p><h3 id="垂直条纹"><a href="#垂直条纹" class="headerlink" title="垂直条纹"></a>垂直条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(to right, /* 或 90deg */#fb3 50%, #58a 0);</div><div class="line">background-size: 30px 100%;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/vertical-stripes">vertical-stripes</a></p><h3 id="斜向条纹"><a href="#斜向条纹" class="headerlink" title="斜向条纹"></a>斜向条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);</div><div class="line">background-size: 42.426406871px 42.426406871px;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/diagonal-stripes">diagonal-stripes</a><br><a href="play.csssecrets.io/diagonal-stripes-60deg">diagonal-stripes-60deg</a></p><h3 id="灵活的同色系条纹"><a href="#灵活的同色系条纹" class="headerlink" title="灵活的同色系条纹"></a>灵活的同色系条纹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: #58a;</div><div class="line">background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/subtle-stripes">subtle-stripes</a></p><h2 id="复杂的背景图案"><a href="#复杂的背景图案" class="headerlink" title="复杂的背景图案"></a>复杂的背景图案</h2><p><a href="play.csssecrets.io/blueprint">网格</a><br><a href="play.csssecrets.io/polka">波点</a><br><a href="play.csssecrets.io/test-conic-gradient">角向渐变</a><br><a href="http://lea.verou.me/css3patterns/" target="_blank" rel="external">css3patterns</a><br><a href="http://bennettfeely.com/gradients/" target="_blank" rel="external">图案库</a></p><h2 id="连续的图像边框"><a href="#连续的图像边框" class="headerlink" title="连续的图像边框"></a>连续的图像边框</h2><p>设置多层背景，再通过 background-clip 来裁剪各层背景。<br><a href="play.csssecrets.io/continuous-image-borders">图像边框</a><br><a href="play.csssecrets.io/vintage-envelope">信封背景</a><br><a href="play.csssecrets.io/marching-ants">蚂蚁行军边框</a><br><a href="play.csssecrets.io/footnote">footnote</a></p><h2 id="自适应的椭圆"><a href="#自适应的椭圆" class="headerlink" title="自适应的椭圆"></a>自适应的椭圆</h2><p>前提为 width === height<br>圆形：<code>border-radius: 100px;</code><br>椭圆：<code>border-radius: 100px / 75px;</code><br>适应性椭圆：<code>border-radius: 50%;</code><br>PS：50%; === 50% / 50%;分别为该元素的宽的50%和高的50%。<br><a href="play.csssecrets.io/ellipse">适应性椭圆</a><br>适应性的半椭圆：<code>border-radius: 100% 0 0 100% / 50%;</code><br>PS：上面的写法，分别为四个角设置。<br><a href="play.csssecrets.io/half-ellipse">适应性的半椭圆</a><br>四分之一椭圆：<code>border-radius: 100% 0 0 0;</code><br>PS：其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。<br><a href="play.csssecrets.io/quarter-ellipse">quarter-ellipse</a></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p>需求为让容器元素为平行四边形，但文本不可倾斜。</p><h3 id="嵌套元素方案"><a href="#嵌套元素方案" class="headerlink" title="嵌套元素方案"></a>嵌套元素方案</h3><p><a href="play.csssecrets.io/parallelograms">抵消策略</a><br>PS：对容器进行 skew() 变形，对内容再应用一次反向的 skew() 变形，从而抵消容器的变形效果</p><h3 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><p><a href="play.csssecrets.io/parallelograms-pseudo">parallelograms-pseudo</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p><h2 id="菱形图片"><a href="#菱形图片" class="headerlink" title="菱形图片"></a>菱形图片</h2><h3 id="基于变形的方案"><a href="#基于变形的方案" class="headerlink" title="基于变形的方案"></a>基于变形的方案</h3><p><a href="play.csssecrets.io/diamond-images">diamond-images</a><br>PS：运用 rotate(-45deg) 再使用 scale(1.42) 填满菱形区域。</p><h3 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p><code>clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);</code><br><a href="play.csssecrets.io/diamond-clip">diamond-clip</a></p><h2 id="切角效果"><a href="#切角效果" class="headerlink" title="切角效果"></a>切角效果</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p><a href="play.csssecrets.io/bevel-corners-gradients">线性渐变</a></p><h3 id="弧形切角"><a href="#弧形切角" class="headerlink" title="弧形切角"></a>弧形切角</h3><p><a href="play.csssecrets.io/scoop-corners">径向渐变</a></p><h3 id="内联-SVG-与-border-image-方案"><a href="#内联-SVG-与-border-image-方案" class="headerlink" title="内联 SVG 与 border-image 方案"></a>内联 SVG 与 border-image 方案</h3><p>相关 SVG 支持，以背景形式引入 SVG。<br><a href="play.csssecrets.io/bevel-corners">bevel-corners</a></p><h3 id="裁切路径方案-1"><a href="#裁切路径方案-1" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p>主要使用 clip-path 属性。<br><a href="play.csssecrets.io/bevel-corners-clipped">bevel-corners-clipped</a></p><h2 id="梯形标签页"><a href="#梯形标签页" class="headerlink" title="梯形标签页"></a>梯形标签页</h2><p>需求为让容器元素为梯形，但文本不可倾斜。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform: perspective(.5em) rotateX(5deg);</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/trapezoid-tabs">trapezoid-tabs</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p><h2 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h2><h3 id="基于-transform-的解决方案"><a href="#基于-transform-的解决方案" class="headerlink" title="基于 transform 的解决方案"></a>基于 transform 的解决方案</h3><p><a href="play.csssecrets.io/pie-animated">pie-animated</a><br><a href="play.csssecrets.io/pie-static">pie-static</a></p><h3 id="SVG-解决方案"><a href="#SVG-解决方案" class="headerlink" title="SVG 解决方案"></a>SVG 解决方案</h3><p><a href="play.csssecrets.io/pie-svg">pie-svg</a></p><h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>box-shadow: hl vl blur spread color;<br>PS：hl为水平位置，vl为垂直位置，blur为模糊距离（模糊面积越大，阴影就越大越淡），spread为阴影大小（取正值时，阴影扩大；取负值时，阴影收缩）。    </p><h3 id="单侧投影"><a href="#单侧投影" class="headerlink" title="单侧投影"></a>单侧投影</h3><p><code>box-shadow: 0 5px 4px -4px black;</code><br><a href="play.csssecrets.io/shadow-one-side">shadow-one-side</a><br>PS：第四个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。</p><h3 id="对边投影"><a href="#对边投影" class="headerlink" title="对边投影"></a>对边投影</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box-shadow: 5px 0 5px -5px black,</div><div class="line">-5px 0 5px -5px black;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/shadow-opposite-sides">shadow-opposite-sides</a><br>PS：利用 box-shadow 可以设置多重阴影。</p><h2 id="不规则投影"><a href="#不规则投影" class="headerlink" title="不规则投影"></a>不规则投影</h2><h3 id="filter-之-drop-shadow"><a href="#filter-之-drop-shadow" class="headerlink" title="filter 之 drop-shadow()"></a>filter 之 drop-shadow()</h3><p><a href="https://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/" target="_blank" rel="external">drop-shadow滤镜与box-shadow区别应用</a><br><a href="https://www.zhangxinxu.com/study/201605/drop-shadow-point-to.html" target="_blank" rel="external">demo</a><br><a href="play.csssecrets.io/drop-shadow">demo1</a><br>PS：drop-shadow 没有 inset，不能叠加，有颜色就会有阴影（不特定于盒模型）。</p><h2 id="染色效果"><a href="#染色效果" class="headerlink" title="染色效果"></a>染色效果</h2><h3 id="基于滤镜的方案"><a href="#基于滤镜的方案" class="headerlink" title="基于滤镜的方案"></a>基于滤镜的方案</h3><p><a href="play.csssecrets.io/color-tint-filter">color-tint-filter</a><br><a href="http://www.runoob.com/cssref/css3-pr-filter.html" target="_blank" rel="external">滤镜文档</a></p><h3 id="基于混合模式的方案"><a href="#基于混合模式的方案" class="headerlink" title="基于混合模式的方案"></a>基于混合模式的方案</h3><p>background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。<br><a href="play.csssecrets.io/color-tint">color-tint</a></p><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p><a href="play.csssecrets.io/frosted-glass">frosted-glass</a><br>PS：伪类来实现效果，原本元素放文本，就不会导致文本模糊。</p><h2 id="折角效果"><a href="#折角效果" class="headerlink" title="折角效果"></a>折角效果</h2><h3 id="45°折角的解决方案"><a href="#45°折角的解决方案" class="headerlink" title="45°折角的解决方案"></a>45°折角的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">background: #58a; /* 回退样式 */</div><div class="line">background: linear-gradient(to left bottom,</div><div class="line">transparent 50%, rgba(0,0,0,.4) 0)</div><div class="line">no-repeat 100% 0 / 2em 2em,</div><div class="line">linear-gradient(-135deg,</div><div class="line">transparent 1.5em, #58a 0);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/folded-corner">folded-corner</a></p><h3 id="其他角度的解决方案"><a href="#其他角度的解决方案" class="headerlink" title="其他角度的解决方案"></a>其他角度的解决方案</h3><p><a href="play.csssecrets.io/folded-corner-realistic">folded-corner-realistic</a><br><a href="play.csssecrets.io/folded-corner-mixin">folded-corner-mixin</a></p><h2 id="连字符断行"><a href="#连字符断行" class="headerlink" title="连字符断行"></a>连字符断行</h2><p>CSS 属性 hyphens 告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。<br><a href="play.csssecrets.io/hyphenation">hyphenation</a></p><h2 id="插入换行"><a href="#插入换行" class="headerlink" title="插入换行"></a>插入换行</h2><p><a href="play.csssecrets.io/line-breaks">line-breaks</a><br>PS：有一个 Unicode 字符是专门代表换行符的： 0x000A ① 。在 CSS 中，这个字符可以写作 “\000A” ，或简化为 “\A” ，类似于 br 标签。</p><h2 id="文本行的斑马条纹"><a href="#文本行的斑马条纹" class="headerlink" title="文本行的斑马条纹"></a>文本行的斑马条纹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">padding: .5em;</div><div class="line">line-height: 1.5;</div><div class="line">background: beige;</div><div class="line">background-size: auto 3em;</div><div class="line">background-origin: content-box;</div><div class="line">background-image: linear-gradient(rgba(0,0,0,.2) 50%,</div><div class="line">transparent 0);</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/zebra-lines">zebra-lines</a></p><h2 id="调整-tab-的宽度"><a href="#调整-tab-的宽度" class="headerlink" title="调整 tab 的宽度"></a>调整 tab 的宽度</h2><p>tab-size 属性规定制表符（tab）字符的空格长度，只对 textarea 和 pre 有效。<br><a href="play.csssecrets.io/tab-size">tab-size</a></p><h2 id="连字"><a href="#连字" class="headerlink" title="连字"></a>连字</h2><p>font-variant-ligatures<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures;</div></pre></td></tr></table></figure></p><h2 id="未来的文本下划线"><a href="#未来的文本下划线" class="headerlink" title="未来的文本下划线"></a>未来的文本下划线</h2><p>text-decoration-color 用于自定义下划线或其他装饰效果的颜色。<br>text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。<br>text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。<br>text-underline-position 用于微调下划线的具体摆放位置。<br><a href="play.csssecrets.io/underlines">underlines</a></p><h2 id="现实中的文字效果"><a href="#现实中的文字效果" class="headerlink" title="现实中的文字效果"></a>现实中的文字效果</h2><p><a href="play.csssecrets.io/letterpress">凸版印刷效果</a><br><a href="play.csssecrets.io/stroked-text">空心字效果</a><br><a href="play.csssecrets.io/glow">文字外发光效果</a><br><a href="play.csssecrets.io/extruded">文字凸起效果</a></p><h2 id="环形文字"><a href="#环形文字" class="headerlink" title="环形文字"></a>环形文字</h2><p><a href="play.csssecrets.io/circular-text">SVG实现</a></p><h2 id="选用合适的鼠标光标"><a href="#选用合适的鼠标光标" class="headerlink" title="选用合适的鼠标光标"></a>选用合适的鼠标光标</h2><h3 id="提示禁用状态"><a href="#提示禁用状态" class="headerlink" title="提示禁用状态"></a>提示禁用状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</div><div class="line">cursor: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/disabled">disabled</a></p><h3 id="隐藏鼠标光标"><a href="#隐藏鼠标光标" class="headerlink" title="隐藏鼠标光标"></a>隐藏鼠标光标</h3><p>适用于播放 video 等情形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cursor: url(&apos;transparent.gif&apos;); // 兼容低版本</div><div class="line">cursor: none;</div></pre></td></tr></table></figure></p><h2 id="扩大可点击区域"><a href="#扩大可点击区域" class="headerlink" title="扩大可点击区域"></a>扩大可点击区域</h2><h3 id="Fitts-法则-或-菲茨定律-或-费茨法则"><a href="#Fitts-法则-或-菲茨定律-或-费茨法则" class="headerlink" title="Fitts 法则 或 菲茨定律 或 费茨法则"></a>Fitts 法则 或 菲茨定律 或 费茨法则</h3><p>人机交互的一个法则<br>Fitts 法则认为，人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。</p><h3 id="border-增加用户交互区域"><a href="#border-增加用户交互区域" class="headerlink" title="border 增加用户交互区域"></a>border 增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">border: 10px solid transparent;</div><div class="line">box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;</div><div class="line">background-clip: padding-box;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/hit-area-border">hit-area-border</a></p><h3 id="伪类增加用户交互区域"><a href="#伪类增加用户交互区域" class="headerlink" title="伪类增加用户交互区域"></a>伪类增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">button &#123;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">button::before &#123;</div><div class="line">content: &apos;&apos;;</div><div class="line">position: absolute;</div><div class="line">top: -10px; right: -10px;</div><div class="line">bottom: -10px; left: -10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/hit-area">hit-area</a></p><h2 id="自定义复选框"><a href="#自定义复选框" class="headerlink" title="自定义复选框"></a>自定义复选框</h2><p><a href="play.csssecrets.io/checkboxes">checkboxes</a><br><a href="play.csssecrets.io/toggle-buttons">toggle-buttons</a></p><h2 id="通过阴影来弱化背景"><a href="#通过阴影来弱化背景" class="headerlink" title="通过阴影来弱化背景"></a>通过阴影来弱化背景</h2><h3 id="伪元素方案-1"><a href="#伪元素方案-1" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body.dimmed::before &#123;</div><div class="line">position: fixed;</div><div class="line">top: 0;</div><div class="line">right: 0;</div><div class="line">bottom: 0;</div><div class="line">left: 0;</div><div class="line">z-index: 1;</div><div class="line">background: rgba(0,0,0,.8);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="box-shadow-方案-1"><a href="#box-shadow-方案-1" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);</div></pre></td></tr></table></figure><p><a href="box-shadow: 0 0 0 50vmax rgba(0,0,0,.8" target="_blank" rel="external">box-shadow</a>;)</p><h3 id="backdrop-方案"><a href="#backdrop-方案" class="headerlink" title="backdrop 方案"></a>backdrop 方案</h3><p><a href="play.csssecrets.io/native-modal">backdrop</a><br>PS：dialog 元素（ <dialog> 元素可以由它的 showModal() 方法显示出来），那么根据浏览器的默认样式，它会自带一个遮罩层（ ::backdrop 伪元素）。</dialog></p><h2 id="通过模糊来弱化背景"><a href="#通过模糊来弱化背景" class="headerlink" title="通过模糊来弱化背景"></a>通过模糊来弱化背景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main.de-emphasized &#123;</div><div class="line">filter: blur(3px) contrast(.8) brightness(.8);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/deemphasizing-blur">滤镜效果</a></p><h2 id="滚动提示"><a href="#滚动提示" class="headerlink" title="滚动提示"></a>滚动提示</h2><p><a href="play.csssecrets.io/scrolling-hints">上下滚动</a></p><h2 id="交互式的图片对比控件"><a href="#交互式的图片对比控件" class="headerlink" title="交互式的图片对比控件"></a>交互式的图片对比控件</h2><p><a href="play.csssecrets.io/image-slider">image-slider</a></p><h2 id="自适应内部元素"><a href="#自适应内部元素" class="headerlink" title="自适应内部元素"></a>自适应内部元素</h2><p>width 新添了一些属性，如min-content。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">figure &#123;</div><div class="line">max-width: 300px;</div><div class="line">max-width: min-content;</div><div class="line">margin: auto;</div><div class="line">&#125;</div><div class="line">figure &gt; img &#123; max-width: inherit; &#125;</div></pre></td></tr></table></figure></p><p><a href="play.csssecrets.io/intrinsic-sizing">intrinsic-sizing</a></p><h2 id="精确控制表格列宽"><a href="#精确控制表格列宽" class="headerlink" title="精确控制表格列宽"></a>精确控制表格列宽</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table &#123;</div><div class="line">table-layout: fixed;</div><div class="line">width: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="play.csssecrets.io/table-column-widths">table-column-widths</a></p><h2 id="根据兄弟元素的数量来设置样式"><a href="#根据兄弟元素的数量来设置样式" class="headerlink" title="根据兄弟元素的数量来设置样式"></a>根据兄弟元素的数量来设置样式</h2><h3 id="相当于li-only-child"><a href="#相当于li-only-child" class="headerlink" title="相当于li:only-child"></a>相当于li:only-child</h3><p>li:first-child:nth-last-child(1)</p><h3 id="当列表正好包含四项时，命中所有列表项"><a href="#当列表正好包含四项时，命中所有列表项" class="headerlink" title="当列表正好包含四项时，命中所有列表项"></a>当列表正好包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(4),<br>li:first-child:nth-last-child(4) ~ li</p><h3 id="当列表至少包含四项时，命中所有列表项"><a href="#当列表至少包含四项时，命中所有列表项" class="headerlink" title="当列表至少包含四项时，命中所有列表项"></a>当列表至少包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+4),<br>li:first-child:nth-last-child(n+4) ~ li</p><h3 id="当列表最多包含四项时，命中所有列表项"><a href="#当列表最多包含四项时，命中所有列表项" class="headerlink" title="当列表最多包含四项时，命中所有列表项"></a>当列表最多包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(-n+4),<br>li:first-child:nth-last-child(-n+4) ~ li </p><h3 id="当列表包含2～6项时，命中所有列表项"><a href="#当列表包含2～6项时，命中所有列表项" class="headerlink" title="当列表包含2～6项时，命中所有列表项"></a>当列表包含2～6项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+2):nth-last-child(-n+6),<br>li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li<br><a href="play.csssecrets.io/styling-sibling-count">styling-sibling-count</a></p><h2 id="满幅的背景，定宽的内容"><a href="#满幅的背景，定宽的内容" class="headerlink" title="满幅的背景，定宽的内容"></a>满幅的背景，定宽的内容</h2><p><a href="play.csssecrets.io/fluid-fixed">fluid-fixed</a></p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">position: absolute;</div><div class="line">top: 50%;</div><div class="line">left: 50%;</div><div class="line">transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">width: 18em;</div><div class="line">padding: 1em 1.5em;</div><div class="line">margin: 50vh auto 0; // 这里不能使用50%，详细请了解包含快知识</div><div class="line">transform: translateY(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">&#125;</div><div class="line">main &#123;</div><div class="line">margin: auto; // 水平和垂直都可以居中</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案（匿名容器）"><a href="#基于-Flexbox-的解决方案（匿名容器）" class="headerlink" title="基于 Flexbox 的解决方案（匿名容器）"></a>基于 Flexbox 的解决方案（匿名容器）</h3><p>PS：匿名容器即为没有被标签包裹的文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">align-items: center;</div><div class="line">justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="紧贴底部的页脚"><a href="#紧贴底部的页脚" class="headerlink" title="紧贴底部的页脚"></a>紧贴底部的页脚</h2><p>下列 header、main、footer 为 body 的子元素。</p><h3 id="固定高度的解决方案"><a href="#固定高度的解决方案" class="headerlink" title="固定高度的解决方案"></a>固定高度的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">min-height: calc(100vh - footerHeight);</div><div class="line">/* 避免内边距或边框搞乱高度的计算： */</div><div class="line">box-sizing: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="flex的解决方案"><a href="#flex的解决方案" class="headerlink" title="flex的解决方案"></a>flex的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">display: flex;</div><div class="line">flex-flow: column;</div><div class="line">min-height: 100vh;</div><div class="line">&#125;</div><div class="line">main &#123; </div><div class="line">// 自动伸展并占满所有的可用空间</div><div class="line">flex: 1; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="缓动效果（动画和过渡）"><a href="#缓动效果（动画和过渡）" class="headerlink" title="缓动效果（动画和过渡）"></a>缓动效果（动画和过渡）</h2><p><a href="play.csssecrets.io/bounce">回弹动画</a><br><a href="play.csssecrets.io/elastic">弹性过渡</a><br>PS：对颜色过渡时小心，RGB 三个通道的值是独立进行插值运算的，在过渡过程中会产生其他颜色。<br>一般通过 transition-property 设置指定过渡属性来避免。</p><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p>运动曲线适用性：贝塞尔曲线适用于平滑运动， steps(步进数, [start || end])适用于逐帧动画<br>PS：参数一为步进数（把动画分为多少步，然后在逐步运行），参数二用于指定动画在每个循环周期的什么位置发生帧的切换动作。<br><a href="play.csssecrets.io/frame-by-frame">逐帧动画</a></p><h3 id="闪烁效果"><a href="#闪烁效果" class="headerlink" title="闪烁效果"></a>闪烁效果</h3><p>animation-direction 属性定义是否循环交替反向播放动画。<br>reverse    动画反向播放。<br>alternate    动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。<br>alternate-reverse    动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。<br><a href="play.csssecrets.io/blink">闪烁效果</a></p><h3 id="打字动画"><a href="#打字动画" class="headerlink" title="打字动画"></a>打字动画</h3><p><a href="play.csssecrets.io/typing">打字动画</a></p><h3 id="状态平滑的动画"><a href="#状态平滑的动画" class="headerlink" title="状态平滑的动画"></a>状态平滑的动画</h3><p>animation–play-state 属性指定动画是否正在运行或已暂停。<br>paused    指定暂停动画<br>running    指定正在运行的动画<br><a href="play.csssecrets.io/state-animations">指定暂停动画</a></p><h2 id="first-letter"><a href="#first-letter" class="headerlink" title="::first-letter"></a>::first-letter</h2><p>定义：::first-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。</p><ol><li>::first-letter 伪元素生效的前提，常见的标点符号、各类括号和引号在::first-letter 伪元素眼中全部都是“辅助类”字符，不会作为第一个字符计算。</li><li>与::before使用（::before 若有字符，会参与计算及 伪类的 content 的字符会被::first-letter生效）。</li><li>::first-letter 伪元素可以生效的 CSS 属性有：字体属性、背景属性、color、padding、border、margin等。</li></ol><p>PS：“辅助类”包括·@#%&amp;<em>()（）[]【】{}:：”“”;；’‘’》《,，.。？?!！…</em>、/\。<br><a href="https://github.com/cubiq/iscroll/" target="_blank" rel="external">iScroll, smooth scrolling for the web</a></p><h2 id="CJK（中文-日文-韩文）两端对齐"><a href="#CJK（中文-日文-韩文）两端对齐" class="headerlink" title="CJK（中文/日文/韩文）两端对齐"></a>CJK（中文/日文/韩文）两端对齐</h2><p>text-align: justify;<br>text-justify: inter-ideograph;</p><h2 id="用户交互反馈（通用的按钮及连接交互反馈）"><a href="#用户交互反馈（通用的按钮及连接交互反馈）" class="headerlink" title="用户交互反馈（通用的按钮及连接交互反馈）"></a>用户交互反馈（通用的按钮及连接交互反馈）</h2><p>通用的连接和按钮交互反馈，原理为：background-color 总是在最底下的位置，所以这里的 background-image 一定是覆盖在按钮等元素背景色之上的，不会影响按钮原来的背景色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[href]:active, button:active &#123;</div><div class="line">background-image: linear-gradient(to top, rgba(0,0,0,.05), rgba(0,0,0,.05));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="script-标签"><a href="#script-标签" class="headerlink" title="script 标签"></a>script 标签</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，同时不渲染，不进行资源加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/html&quot;&gt;</div><div class="line">&lt;img src=&quot;1.jpg&quot;&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>PS：script标签隐藏内容获取使用 script.innerHTML</p><h3 id="display-none-隐藏"><a href="#display-none-隐藏" class="headerlink" title="display:none 隐藏"></a>display:none 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但资源有加载，DOM 可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.dn &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="visibility-hidden-隐藏"><a href="#visibility-hidden-隐藏" class="headerlink" title="visibility: hidden 隐藏"></a>visibility: hidden 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但显隐的时候可以有 transition 淡入淡出效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.hidden &#123;</div><div class="line">position: absolute;</div><div class="line">visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果希望元素不可见，不能点击，辅助设备无法访问，但占据空间保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.hidden &#123;</div><div class="line">visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="clip-剪裁隐藏"><a href="#clip-剪裁隐藏" class="headerlink" title="clip 剪裁隐藏"></a>clip 剪裁隐藏</h3><p>如果希望元素不可见，不能点击，不占据空间，但键盘可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.clip &#123;</div><div class="line">position: absolute;</div><div class="line">clip: rect(0 0 0 0);</div><div class="line">&#125;</div><div class="line">.out &#123;</div><div class="line">position: relative;</div><div class="line">left: -999em;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="relative-隐藏"><a href="#relative-隐藏" class="headerlink" title="relative 隐藏"></a>relative 隐藏</h3><p>如果希望元素不可见，不能点击，但占据空间，且键盘可访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.lower &#123;</div><div class="line">position: relative;</div><div class="line">z-index: -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="透明度隐藏"><a href="#透明度隐藏" class="headerlink" title="透明度隐藏"></a>透明度隐藏</h3><p>如果希望元素不可见，但可以点击，而且不占据空间，则可以使用透明度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.opacity &#123;</div><div class="line">position: absolute;</div><div class="line">opacity: 0;</div><div class="line">filter: Alpha(opacity=0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果单纯希望元素看不见，但位置保留，依然可以点可以选，则直接让透明度为 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.opacity &#123;</div><div class="line">opacity: 0;</div><div class="line">filter: Alpha(opacity=0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：img元素，设置 display:none 在所有浏览器下依旧都会请求图片资源（浪费了宽带）。</p><h3 id="流向的改"><a href="#流向的改" class="headerlink" title="流向的改"></a>流向的改</h3><p>direction（改变水平流向）<br>unicode-bidi（文字流向）<br>writing-mode（改变 CSS 世界纵横规则）<br>writing-mode: lr-tb | tb-rl | tb-lr (IE8+);<br>writing-mode: horizontal-tb | vertical-rl | vertical-lr;</p><h2 id="1px边框（移动端）"><a href="#1px边框（移动端）" class="headerlink" title="1px边框（移动端）"></a>1px边框（移动端）</h2><h3 id="box-shadow-border-transform"><a href="#box-shadow-border-transform" class="headerlink" title="box-shadow/border + transform"></a>box-shadow/border + transform</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.border &#123;</div><div class="line">width: 100%;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.border::after &#123;</div><div class="line">content:&apos;&apos;;</div><div class="line">position: absolute;</div><div class="line">bottom: 0;left: 0;</div><div class="line">width: 100%;</div><div class="line">box-shadow: 0 0 0 1px red;</div><div class="line">transform-origin: 0 bottom;</div><div class="line">transform: scaleY(.5);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：还可以结合 @media (min-resolution: xdppx)做进一步处理。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background-origin: padding-box; 默认<br>background-position: top 20px left 20px; 参照点为默认padding-box<br>background-size: x y;<br>圆锥渐变<br>background: conic-gradient(red, yellow, lime, aqua, blue, fuchsia, red);<br>background缩写语法<br>background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><ol><li>可以通过’/‘设置水平水平和垂直半径，如<code>border-radius: 100px / 75px;</code></li><li>它不仅可以接受长度值，还可以接受百分比值（这个百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。）。</li><li></li></ol><h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>指定元素内的空白怎样处理。<br>normal    默认。空白会被浏览器忽略。<br>pre    空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。<br>nowrap    文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。<br>pre-wrap    保留空白符序列，但是正常地进行换行。<br>pre-line    合并空白符序列，但是保留换行符。<br>inherit    规定应该从父元素继承 white-space 属性的值。</pre></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>line-height 的百分比时相对于 font-size 计算的。<br>vertical-align 的百分比时相对于 line-height 计算的。<br>ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。)<br>ch 数字 0 的宽度，使用场景（需要配合等宽字体）：全数字输入框：手机号等。<br>font-weight 运行原理：字体不同粗细需要字体文件是否存在该粗细的字体。<br>font-style  同样有效的前提为字体文件中存在该类型的字体，italic 和 oblique。<br>font-family: system-ui; // 让网页的字体跟系统走，，网站字体能时时刻刻与时俱进。<br>text-transform 属性控制文本的大小写，支持capitalize、uppercase、lowercase。<br>适用场景：身份证输入，最后以为X，帮助用户转为大写；验证码输入，帮助用户转为大写。<br>::backdrop CSS 伪元素 是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结日常CSS技巧，大多收集于网络、&lt;a href=&quot;http://www.ituring.com.cn/book/1695&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《CSS揭秘》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;半透明边框&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记</title>
    <link href="https://fanerge.github.io/2018/CSS%E7%AC%94%E8%AE%B0.html"/>
    <id>https://fanerge.github.io/2018/CSS笔记.html</id>
    <published>2018-06-06T12:45:51.000Z</published>
    <updated>2018-06-12T13:28:13.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。</p><h1 id="CSS方法"><a href="#CSS方法" class="headerlink" title="CSS方法"></a>CSS方法</h1><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p>用来获取选择到的元素的某一HTML属性值，并用于其样式。</p><h2 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h2><p>可以通过计算来决定一个CSS属性的值了。<br>PS：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px);</code></p><h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p><code>counter-reset</code>属性创建或重置一个或多个计数器。<br><code>counter-increment</code>属性递增一个或多个计数器值。<br><code>counter(name)</code>方法用于获取计数器的值。<br>PS：<code>counter-reset</code>属性通常是和<code>counter-increment</code>属性，<code>content</code>属性一起使用。</p><h2 id="cubic-bezier"><a href="#cubic-bezier" class="headerlink" title="cubic-bezier()"></a>cubic-bezier()</h2><p>它主要作用于动画和过渡的运动曲线函数 animation-timing-function 和 transition-timing-function 。<br><a href="http://cubic-bezier.com/" target="_blank" rel="external">cubic-bezier转换网站</a></p><h2 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h2><h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h3><p>线性渐变<br><code>background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);</code><br><code>repeating-linear-gradient</code> – 重复线性渐变<br><code>background: repeating-linear-gradient(to top left, lightpink, lightpink 5px, white 5px, white 10px);</code></p><h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient"></a>radial-gradient</h3><p>径向渐变<br><code>background: radial-gradient(red, yellow, rgb(30, 144, 255));</code><br><code>repeating-radial-gradient</code> – 重复径向渐变<br><code>background: repeating-radial-gradient(powderblue, powderblue 8px, white 8px, white 16px);</code></p><h2 id="image-set"><a href="#image-set" class="headerlink" title="image-set()"></a>image-set()</h2><p>可以根据用户设备的分辨率匹配合适的图像。<br><code>background-image: image-set( &quot;test.png&quot; 1x, &quot;test-2x.png&quot; 2x, &quot;test-print.png&quot; 600dpi );</code></p><h3 id="img-的-srcset属性"><a href="#img-的-srcset属性" class="headerlink" title="img 的 srcset属性"></a>img 的 srcset属性</h3><p>以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。<br><code>&lt;img src=&quot;mm-width-128px.jpg&quot; srcset=&quot;mm-width-128px.jpg 1x, mm-width-256px.jpg 2x&quot;&gt;</code><br>PS：img的srcset属性方便的解决了页面图片适应不同屏幕密度的情况。</p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h2><p>matrix() 指定了一个由指定的 6 个值组成的 2D 变换矩阵。这种矩阵的常量值是隐含的，而不是由参数传递的；其他的参数是以列优先的顺序描述的。<br>matrix3d() 参数为 9 个值，对应 3D 变换。<br>PS：所有的 transform 参数值都可以用矩阵来表示。</p><h2 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h2><p>var()函数可以代替元素中任何属性中的值的任何部分。<br>语法：<code>var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? )</code><br>ps：带有前缀–的属性名，比如–example–name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。</p><h1 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h1><h2 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h2><p>指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。</p><h2 id="cross-fade"><a href="#cross-fade" class="headerlink" title="cross-fade"></a>cross-fade</h2><p>作用：CSS3背景图片透明叠加属性。<br>方法：<code>background-image: -webkit-cross-fade(url(1.jpg), url(2.jpg), 50%);</code><br>PS：透明度是作用在第二张图片上的。<br><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-background-image-cross-fade/" target="_blank" rel="external">Cross-fade</a></p><h2 id="caret-color"><a href="#caret-color" class="headerlink" title="caret-color"></a>caret-color</h2><p>用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。</p><h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><p>可以创建一个只有元素的部分区域可以显示的剪切区域（也就是说可以让一个元素显示出不同的形式，如圆形、椭圆、多边形等等）。<br><a href="http://yunkus.com/css-clip-path/" target="_blank" rel="external">CSS3 clip-path 用法详解</a></p><h2 id="shape-outside"><a href="#shape-outside" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>属性指定使用下面列表的值来定义浮动元素的浮动区域。这个浮动区域决定了行内内容（浮动元素）所包裹的形状。<br>其中还包括basic-shape有inset()、 circle()、ellipse()、polygon()</p><h2 id="resolution"><a href="#resolution" class="headerlink" title="resolution"></a>resolution</h2><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>每英寸包含点的数量（dots per inch）<br>普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx）。</p><h3 id="dpcm"><a href="#dpcm" class="headerlink" title="dpcm"></a>dpcm</h3><p>每厘米包含点的数量（dots per centimeter）</p><h3 id="dppx"><a href="#dppx" class="headerlink" title="dppx"></a>dppx</h3><p>每像素包含点的数量（dots per pixel）<br>基本的换算单位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1dppx = 96dpi</div><div class="line">1dpi ≈ 0.39dpcm</div><div class="line">1dpcm ≈ 2.54dpi</div><div class="line">1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px</div></pre></td></tr></table></figure></p><h2 id="empty-cells"><a href="#empty-cells" class="headerlink" title="empty-cells"></a>empty-cells</h2><p>渲染表格 table 中没有可见内容的单元格的边框和背景，取值为show 和 hide。</p><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>width属性又多了几个关键字成员，fill-available, max-content, min-content, 以及fit-content，兼容性还有很大问题，暂不深究。</p><h3 id="max-content"><a href="#max-content" class="headerlink" title="max-content"></a>max-content</h3><p>固有的首选宽度.</p><h3 id="min-content"><a href="#min-content" class="headerlink" title="min-content"></a>min-content</h3><p>这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素）。</p><h3 id="available"><a href="#available" class="headerlink" title="available"></a>available</h3><p>包含块的宽度减去水平 margin, border 和 padding.</p><h3 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h3><p>以下两种情况下的较大值:固有的最小宽度 或 固有首选宽度（max-content）和可用宽度（available）的较小值  </p><h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><p>之前的 length 或 percentage 应用到元素的边框盒子.</p><h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><p>之前的 length 或 percentage 应用到元素的内容盒子.</p><h2 id="hanging-punctuation"><a href="#hanging-punctuation" class="headerlink" title="hanging-punctuation"></a>hanging-punctuation</h2><p>指定了标点符号应该放在文本句子的开头还是结尾。悬挂标点符号可能被放在线框外。</p><h2 id="hyphens"><a href="#hyphens" class="headerlink" title="hyphens"></a>hyphens</h2><p>告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。</p><h2 id="image-rendering"><a href="#image-rendering" class="headerlink" title="image-rendering"></a>image-rendering</h2><p>决定浏览器对缩放图像采取的缩放算法.它适用于元素本身和有其他属性的图像.它对非缩放图像没有影响。</p><h2 id="image-orientation"><a href="#image-orientation" class="headerlink" title="image-orientation"></a>image-orientation</h2><p>用来修正某些图片的预设方向。<br>PS：该属性不是用来对图片进行任意角度旋转的, 它是用来修正那些带有不正确的预设方向的图片的. 因此该属性值会被四舍五入到 90 度的整数倍.</p><h2 id="通用关键字"><a href="#通用关键字" class="headerlink" title="通用关键字"></a>通用关键字</h2><p><code>inherit</code> – 关键字使得元素获取其父元素的计算值(computed value )，当然肯定只针对可继承属性。<br><code>initial</code> – 是将属性的初始值( initial value)赋给元素，至于那些为<a href="https://www.w3.org/TR/CSS2/propidx.html" target="_blank" rel="external">不同属性的初始值，请参见W3C</a>。<br><code>unset</code> – CSS 关键字 unset 是 关键字 initial 和 inherit的组合（换句话说这个unset关键字会优先用inherit的样式，其次会应该用initial的样式）。<br><code>all</code> – CSS all简写属性重设除了unicode-bidi 和 direction 之外的所有属性至它们的初始值或继承值。</p><h2 id="inline-size"><a href="#inline-size" class="headerlink" title="inline-size"></a>inline-size</h2><p>定义元素的块的水平或垂直大小，这取决于它的写入模式。它对应于 width 或 height，取决于 writing-mode 属性。</p><h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>定义该元素是否必须创建一个新的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="external">stacking context</a>。<br>PS：该属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。</p><h2 id="支持欠佳的属性，暂不深究"><a href="#支持欠佳的属性，暂不深究" class="headerlink" title="支持欠佳的属性，暂不深究"></a>支持欠佳的属性，暂不深究</h2><p>margin-block-start 和 margin-block-end<br>定义元素的逻辑块结束余量，该元素根据元素的writing-mode、方向性和文本方向映射到物理量度。<br>margin-inline-start 和 margin-inline-end<br>min-block-size 和 min-inline-size<br>offset-block-start 和 offset-block-end<br>offset-inline-start 和 offset-inline-end<br>padding-block-start 和 padding-block-end<br>padding-inline-end 和 padding-inline-start</p><h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。<br>遮罩mask是一个复合属性，包括mask-image、mask-mode、mask-repeat、mask-position、mask-clip、mask-origin、mask-size、mask-composite这8个属性</p><h3 id="mask-image"><a href="#mask-image" class="headerlink" title="mask-image"></a>mask-image</h3><p>默认值为none，值为透明图片，或透明渐变</p><h3 id="mask-repeat"><a href="#mask-repeat" class="headerlink" title="mask-repeat"></a>mask-repeat</h3><p>默认值为repeat，可选值与background-repeat相同</p><h3 id="mask-position"><a href="#mask-position" class="headerlink" title="mask-position"></a>mask-position</h3><p>默认值为0 0，可选值与background-position相同</p><h3 id="mask-clip"><a href="#mask-clip" class="headerlink" title="mask-clip"></a>mask-clip</h3><p>默认值为border-box，可选值与background-clip相同</p><h3 id="mask-origin"><a href="#mask-origin" class="headerlink" title="mask-origin"></a>mask-origin</h3><p>默认值为border-box，可选值与background-origin相同</p><h3 id="mask-size"><a href="#mask-size" class="headerlink" title="mask-size"></a>mask-size</h3><p>默认值为auto，可选值与background-size相同</p><h3 id="mask-mode"><a href="#mask-mode" class="headerlink" title="mask-mode"></a>mask-mode</h3><p>默认值为match-source，可选值为alpha、luminance、match-source，或者它们的组合</p><h3 id="mask-composite"><a href="#mask-composite" class="headerlink" title="mask-composite"></a>mask-composite</h3><p>默认值为add，可选值为add、subtract、intersect、exclude</p><h2 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h2><p>描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p><h2 id="作用于替换元素，如img"><a href="#作用于替换元素，如img" class="headerlink" title="作用于替换元素，如img"></a>作用于替换元素，如img</h2><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p>指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</p><h3 id="object-position"><a href="#object-position" class="headerlink" title="object-position"></a>object-position</h3><p>指定元素的替换内容在其盒子内的对齐方式。</p><h2 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h2><p>是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。<br>PS：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。</p><h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><p>指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。</p><h2 id="quotes"><a href="#quotes" class="headerlink" title="quotes"></a>quotes</h2><p>设置嵌套引用的引号类型。<br>PS：当4个参数时，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。</p><h2 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h2><p>CSS 规则关联了一组嵌套的CSS语句,这些语句被放置在一个CSS区块中,该区块以大括号分割, 还有一个由多个CSS声明检测组成的条件,它是一个键值组合, 由逻辑与,逻辑或,逻辑非组合而成. 这样的条件语句称为支持条件.<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@supports &lt;supports_condition&gt; &#123;</div><div class="line">  /* specific rules */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：在 supports_condition 中还支持 not、or、and 逻辑。</p><h2 id="tab-size"><a href="#tab-size" class="headerlink" title="tab-size"></a>tab-size</h2><p>用于自定义制表符 (U+0009) 的宽度。</p><h2 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h2><p>用于布局表格单元格，行和列的算法。</p><h2 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h2><p>描述的是一段文本中最后一行在被强制换行之前的对齐规则。</p><h2 id="text-combine-upright"><a href="#text-combine-upright" class="headerlink" title="text-combine-upright"></a>text-combine-upright</h2><p>文本结合 writing-mode（为vertical-rl 或 vertical-lr） 指定多个字符的组合到单个字符的空间中。</p><h2 id="text-emphasis"><a href="#text-emphasis" class="headerlink" title="text-emphasis"></a>text-emphasis</h2><p>主要效果为文本强调。<br>text-emphasis-color<br>text-emphasis-position<br>text-emphasis-style</p><h2 id="text-orientation"><a href="#text-orientation" class="headerlink" title="text-orientation"></a>text-orientation</h2><p>设置文本的方向。</p><h2 id="text-rendering"><a href="#text-rendering" class="headerlink" title="text-rendering"></a>text-rendering</h2><p>CSS 属性定义浏览器渲染引擎如何渲染字体。浏览器会在速度、清晰度、几何精度之间进行权衡。</p><h2 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h2><p>CSS属性指定如何将元素的文本大小写。</p><h2 id="text-underline-position"><a href="#text-underline-position" class="headerlink" title="text-underline-position"></a>text-underline-position</h2><p>当 text-decoration属性的值设置为 underline 之后，可以用 text-underline-position 属性为其设置下划线的位置。</p><h2 id="touch-action"><a href="#touch-action" class="headerlink" title="touch-action"></a>touch-action</h2><p>用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。</p><h2 id="transform-box"><a href="#transform-box" class="headerlink" title="transform-box"></a>transform-box</h2><p>defines the layout box, to which the transform and transform-origin properties relate to.</p><h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><p>确定元素的子元素是否位于3D空间中，还是在该元素所在的平面内被扁平化。</p><h2 id="unicode-bidi"><a href="#unicode-bidi" class="headerlink" title="unicode-bidi"></a>unicode-bidi</h2><p>CSS 的 unicode-bidi 属性和 direction 属性一起决定了如何处理文档中的双向文本（bidirectional text）。</p><h2 id="unicode-range"><a href="#unicode-range" class="headerlink" title="unicode-range"></a>unicode-range</h2><p>属性值可以是单个字符编码、字符编码区间、通配符区间、多个值等，如小写字母：[0x61,0x7a]（或十进制[97, 122]）<br>CSS unicode-range 特定字符使用 font-face 自定义字体。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。<br><code>baseline</code><br>元素基线与父元素的基线对齐。<br>对于一些 可替换元素，比如 textarea ， HTML标准没有说明它的基线，这意味着对其使用这个关键字，各浏览器表现可能不一样。<br><code>sub</code><br>元素基线与父元素的下标基线对齐。<br><code>super</code><br>元素基线与父元素的上标基线对齐。<br><code>text-top</code><br>元素顶端与父元素字体的顶端对齐。<br><code>text-bottom</code><br>元素底端与父元素字体的底端对齐。<br><code>middle</code><br>元素中垂线与父元素的基线加上小写x一半的高度值对齐。<br><code>length</code><br>元素基线超过父元素的基线指定高度。可以取负值。<br><code>percentage</code><br>同 length , 百分比相对于 line-height 。<br>以下两个值是相对于整行来说的：<br><code>top</code><br> 元素及其后代的顶端与整行的顶端对齐。<br><code>bottom</code><br>元素及其后代的底端与整行的底端对齐。</p><h2 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h2><p>CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。<br>PS：这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p><h2 id="增加热区的范围"><a href="#增加热区的范围" class="headerlink" title="增加热区的范围"></a>增加热区的范围</h2><ol><li>border 可以增加热区（与用户交互的区域），outline 和 box-shadow 是不能办到的。</li><li>伪元素同样可以代表其宿主元素来响应鼠标交互。</li></ol><p>通常的做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">border: 10px solid transparent;</div></pre></td></tr></table></figure></p><h1 id="filter-滤镜效果"><a href="#filter-滤镜效果" class="headerlink" title="filter(滤镜效果)"></a>filter(滤镜效果)</h1><p>CSS滤镜（filter）属提供的图形特效，像模糊，锐化或元素变色。过滤器通常被用于调整图片，背景和边界的渲染。<br>filter 可以开启浏览器的硬件加速GPU，优化性能。</p><h2 id="blur"><a href="#blur" class="headerlink" title="blur()"></a>blur()</h2><p>给图像设置高斯模糊。filter: blur(number);</p><h2 id="brightness"><a href="#brightness" class="headerlink" title="brightness()"></a>brightness()</h2><p>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</p><h2 id="drop-shadow"><a href="#drop-shadow" class="headerlink" title="drop-shadow()"></a>drop-shadow()</h2><p>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 </p><h2 id="contrast"><a href="#contrast" class="headerlink" title="contrast()"></a>contrast()</h2><p>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</p><h2 id="grayscale"><a href="#grayscale" class="headerlink" title="grayscale()"></a>grayscale()</h2><p>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p><h2 id="hue-rotate"><a href="#hue-rotate" class="headerlink" title="hue-rotate()"></a>hue-rotate()</h2><p>给图像应用色相旋转。“angle”一值设定图像会被调整的色环角度值。</p><h2 id="invert"><a href="#invert" class="headerlink" title="invert()"></a>invert()</h2><p>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</p><h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity()"></a>opacity()</h2><p>转化图像的透明程度。</p><h2 id="saturate"><a href="#saturate" class="headerlink" title="saturate()"></a>saturate()</h2><p>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。</p><h2 id="sepia"><a href="#sepia" class="headerlink" title="sepia()"></a>sepia()</h2><p>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。<br>PS：你可以组合任意数量的函数来控制渲染。下面的例子可以增强图像的对比度和亮度。<br><code>filter: contrast(175%) brightness(3%)</code></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background 是CSS简写属性，用来集中设置各种背景属性。background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat,background-size, background-attachment。</p><h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p>如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。</p><h2 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h2><p>定义该元素的背景图片，以及背景色如何混合。</p><h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>置元素的背景（背景图片或颜色）是否延伸到边框下面。<br>PS：简写形式background:bg-color bg-image bg-position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p><h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><h2 id="active"><a href="#active" class="headerlink" title=":active"></a>:active</h2><p>:active CSS伪类匹配被用户激活的元素。<br>PS：当多伪类同时使用时，需要注意顺序，否则就会发生被覆盖，如链接:link — :visited — :hover — :active。</p><h2 id="target"><a href="#target" class="headerlink" title=":target"></a>:target</h2><p>代表一个唯一的页面元素(目标元素)，其ID与当前URL片段匹配.</p><h2 id="default"><a href="#default" class="headerlink" title=":default"></a>:default</h2><p>表示一组相关元素中的默认表单元素。<br><code>该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用。</code></p><h2 id="dir"><a href="#dir" class="headerlink" title=":dir"></a>:dir</h2><p>伪类匹配特定文字书写方向的元素。在HTML中, 文字方向由dir属性决定。</p><h2 id="enabled"><a href="#enabled" class="headerlink" title=":enabled"></a>:enabled</h2><p>表示任何启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入）或获取焦点，则该元素是启用的。</p><h2 id="disabled"><a href="#disabled" class="headerlink" title=":disabled"></a>:disabled</h2><p>表示任何被禁用的元素。如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。</p><h2 id="read-only"><a href="#read-only" class="headerlink" title=":read-only"></a>:read-only</h2><p>表示元素不可被用户编辑的状态（如锁定的文本输入框）。</p><h2 id="read-write"><a href="#read-write" class="headerlink" title=":read-write"></a>:read-write</h2><p>代表一个元素（例如可输入文本的 input元素）可以被用户编辑。<br>PS：这个选择器不仅仅选择 input 元素，它也会选择所有可以被用户编辑的元素，例如设置了 contenteditable 属性的 p 元素。</p><h2 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h2><p>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格），无论一个元素是否为 (empty 或 not), 注释或处理指令都不会产生影响。</p><h2 id="not"><a href="#not" class="headerlink" title=":not()"></a>:not()</h2><p>是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。<br>PS：:not伪类不像其它伪类，它不会增加选择器的优先级。</p><h2 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h2><p>表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。</p><h2 id="fullscreen"><a href="#fullscreen" class="headerlink" title=":fullscreen"></a>:fullscreen</h2><p>应用于当前处于全屏显示模式的元素。 它不仅仅选择顶级元素，还包括所有已显示的栈内元素。</p><h2 id="in-range"><a href="#in-range" class="headerlink" title=":in-range"></a>:in-range</h2><p>代表一个 input 元素，其当前值处于属性min 和max 限定的范围之内.</p><h2 id="out-of-range"><a href="#out-of-range" class="headerlink" title=":out-of-range"></a>:out-of-range</h2><p>代表一个 input 元素，其当前值不在属性min 和max 限定的范围之内.</p><h2 id="indeterminate"><a href="#indeterminate" class="headerlink" title=":indeterminate"></a>:indeterminate</h2><p>表示状态不确定的表单元素.</p><h2 id="invalid"><a href="#invalid" class="headerlink" title=":invalid"></a>:invalid</h2><p>表示任意内容未通过验证的 input 或其他 form 元素 .</p><h2 id="valid"><a href="#valid" class="headerlink" title=":valid"></a>:valid</h2><p>表示任意内容通过验证的 input 或其他 form 元素 .</p><h2 id="required"><a href="#required" class="headerlink" title=":required"></a>:required</h2><p>表示 任意 input 元素表示任意拥有required属性的 input 或 textarea 元素使用它. 它允许表单在提交之前容易的展示必填字段并且渲染其外观. </p><h2 id="lang"><a href="#lang" class="headerlink" title=":lang()"></a>:lang()</h2><p>基于元素语言来匹配页面元素。</p><h2 id="optional"><a href="#optional" class="headerlink" title=":optional"></a>:optional</h2><p>表示任意没有required属性的 input，select 或  textarea 元素使用它。</p><h2 id="only-child"><a href="#only-child" class="headerlink" title=":only-child"></a>:only-child</h2><p>代表了属于某个父元素的唯一一个子元素.<br>PS：等价的方法还有:first-child:last-child或者:nth-child(1):nth-last-child(1)</p><h2 id="root"><a href="#root" class="headerlink" title=":root"></a>:root</h2><p>这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 html 元素，除了优先级更高之外，与 html 选择器相同。</p><h2 id="scope"><a href="#scope" class="headerlink" title=":scope"></a>:scope</h2><p>它将会匹配作为选择符匹配元素的参考点(css的作用域或作用点)。在HTML中，可以使用 style 的scoped属性来重新定义新的参考点。如果HTML中没有使用这个属性，那么默认的参考点(css的作用域或作用点)是 html。</p><h2 id="scroll-behavior"><a href="#scroll-behavior" class="headerlink" title="scroll-behavior"></a>scroll-behavior</h2><p>当由于导航或者CSSOM滚动api产生滚动时，CSS属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。<br>PS：可以配合 a 链接来实现平滑滚动到对应锚点位置。<br><a href="https://codepen.io/fanerge/pen/ERPELJ" target="_blank" rel="external">可以在Chrome浏览器中测试下</a></p><h2 id="scroll-snap-type"><a href="#scroll-snap-type" class="headerlink" title="scroll-snap-type"></a>scroll-snap-type</h2><p>CSS属性定义在滚动容器中的一个snap点如何被严格的执行。<br>PS：此属性不能用来指定任何精确的动画或者物理运动效果来执行snap点，而是交给用户代理来处理。</p><h2 id="shape-outside-1"><a href="#shape-outside-1" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>CSS 属性定义了一个行内内容应该包裹的形状。默认表现是行内元素包裹该形状的margin box。</p><h2 id="shape-image-threshold"><a href="#shape-image-threshold" class="headerlink" title="shape-image-threshold"></a>shape-image-threshold</h2><p>CSS property defines the alpha channel threshold used to extract the shape using an image as the value for shape-outside.</p><h2 id="shape-margin"><a href="#shape-margin" class="headerlink" title="shape-margin"></a>shape-margin</h2><p>CSS property specifies a margin for a CSS shape created using shape-outside.</p><h1 id="page"><a href="#page" class="headerlink" title="@page"></a>@page</h1><p>@page 规则用于在打印文档时修改某些CSS属性。<br>你不能用@page规则来修改所有的CSS属性，而是只能修改margin,orphans,widow 和 page breaks of the document。对其他属性的修改是无效的。</p><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>指定页面盒模型所在的容器的大小和方向。一般情况下，因为一个页面盒模型被渲染到一面纸张上，所以这个属性也指示了目标纸张的大小。</p><h2 id="marks"><a href="#marks" class="headerlink" title="marks"></a>marks</h2><p>向文档添加剪切标记和/或注册标记。</p><h2 id="bleed"><a href="#bleed" class="headerlink" title="bleed"></a>bleed</h2><p>指定一个超出页面盒模型的区域，在这个区域的页面内容将被裁剪。</p><h2 id="first"><a href="#first" class="headerlink" title=":first"></a>:first</h2><p>需要和 @page 配套使用，打印文档的时候，第一页的样式。</p><h2 id="left"><a href="#left" class="headerlink" title=":left"></a>:left</h2><p>需要和 @page 配套使用, 对打印文档的左侧页设置CSS样式.</p><h2 id="right"><a href="#right" class="headerlink" title=":right"></a>:right</h2><p>需要和 @page 配套使用, 对打印文档的右侧页设置CSS样式.</p><h2 id="blank"><a href="#blank" class="headerlink" title=":blank"></a>:blank</h2><p>与 :empty 关系类似，浏览器支持不佳。</p><h2 id="两个实验性"><a href="#两个实验性" class="headerlink" title="两个实验性"></a>两个实验性</h2><p>:recto 和 :verso </p><h2 id="page-break-after"><a href="#page-break-after" class="headerlink" title="page-break-after"></a>page-break-after</h2><p>CSS 属性调整当前元素之后的分页符</p><h2 id="page-break-before"><a href="#page-break-before" class="headerlink" title="page-break-before"></a>page-break-before</h2><p>CSS属性调整当前元素之前的分页符。</p><h2 id="page-break-inside"><a href="#page-break-inside" class="headerlink" title="page-break-inside"></a>page-break-inside</h2><p>CSS 属性调整当前元素内的分页符。</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><h2 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h2><p>::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。<br>PS：这个虚拟元素默认是行内元素。</p><h2 id="fitst-letter"><a href="#fitst-letter" class="headerlink" title="::fitst-letter"></a>::fitst-letter</h2><p>会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。<br>PS：你可能还不知道，::before 伪元素 和 content 属性结合起来有可能会在元素前面注入一些文本。如此，::first-letter 将会匹配到content文本的首字母。<br>首行只在 block-container box内部才有意义, 因此 ::first-letter 伪元素 只在display属性值为block, inline-block, table-cell, list-item 或者 table-caption的元素上才起作用. 其他情况下, ::first-letter 毫无意义.</p><h2 id="backdrop"><a href="#backdrop" class="headerlink" title="::backdrop"></a>::backdrop</h2><p>是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p><h2 id="placeholder"><a href="#placeholder" class="headerlink" title="::placeholder"></a>::placeholder</h2><p>可以选择一个表单元素的占位文本，它允许开发者和设计师自定义占位文本的样式。</p><h2 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h2><p>应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。</p><h2 id="slotted"><a href="#slotted" class="headerlink" title="::slotted()"></a>::slotted()</h2><p>CSS pseudo-element represents any element that has been placed into a slot inside an HTML template (see Using templates and slots for more information).</p><h1 id="css3-布局"><a href="#css3-布局" class="headerlink" title="css3 布局"></a>css3 布局</h1><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>place-content<br><a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/0320%E6%80%BB%E7%BB%93flex%E5%B8%83%E5%B1%80.txt" target="_blank" rel="external">Study-Notes</a></p><h2 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h2><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>通过设置 display: grid;  可以定义一个 CSS 网格。然后使用 grid-template-rows 和 grid-template-columns 属性来定义网格的 columns 和 rows。<br>PS：grid-template-rows 和 grid-template-columns 有较多种参数。<br>minmax(min, max)<br>可以设置最小值和最大值，当某个值为 auto 时不限制。<br>repeat( [ <positive-integer> | auto-fill | auto-fit ] , <track-list> )<br>重复的多个 track，第一个参数指定了 repeat 的次数。<br>auto-fit<br>倾向于使用最少列数占满当前行空间，浏览器先是和 auto-fill 一样，暗中创建一些列来填充多出来的行空间，然后坍缩（collapse）这些列以便腾出空间让其余列扩张。<br>auto-fill<br>倾向于容纳更多的列，所以如果在满足宽度限制的前提下还有空间能容纳新列，那么它会暗中创建一些列来填充当前行。</track-list></positive-integer></p><h3 id="Grid-Areas"><a href="#Grid-Areas" class="headerlink" title="Grid Areas"></a>Grid Areas</h3><p>网格区域是网格中由一个或者多个网格单元格组成的一个矩形区域。当你使用基于网格线位置放置一个项目或者使用命名的网格区域定义区域时，网格区域被创建。<br>通常用 grid-area 属性命名它们（为子网格命名），然后用 grid-template-areas 把它们放在网格上。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_areas" target="_blank" rel="external">Grid Areas</a></p><h3 id="Grid-Lines"><a href="#Grid-Lines" class="headerlink" title="Grid Lines"></a>Grid Lines</h3><p>使用Grid布局在显式网格中定义轨道的同时会创建网格线。<br>网格线可以用它们的编号来寻址，线编号遵循文档的写入模式，因此在从右到左的语言中，列线1行将位于网格的右侧。<br>PS：主要给下列属性使用grid-column-start、grid-column-end、grid-row-start、grid-row-end。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_lines" target="_blank" rel="external">Grid Lines</a></p><h3 id="Gutters"><a href="#Gutters" class="headerlink" title="Gutters"></a>Gutters</h3><p>网格间距是网格轨道之间的间距，可以通过 grid-column-gap 或者 grid-row-gap 在Grid布局中创建。</p><h1 id="动画和过渡和转换"><a href="#动画和过渡和转换" class="headerlink" title="动画和过渡和转换"></a>动画和过渡和转换</h1><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>animation属性是如下属性的一个简写属性形式: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode.</p><h2 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h2><p>指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。</p><h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p>CSS属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。</p><h2 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h2><p>CSS 属性指示动画是否反向播放，它通常在简写属性animation中设定。</p><h2 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h2><p>用来指定在动画执行之前和之后如何给动画的目标应用样式。</p><h2 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h2><p>定义动画在结束前运行的次数 可以是1次 无限循环。</p><h2 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h2><p>定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。</p><h2 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h2><p>定义CSS动画在每一动画周期中执行的节奏。</p><h2 id="perspective-或-perspective"><a href="#perspective-或-perspective" class="headerlink" title="perspective 或 perspective()"></a>perspective 或 perspective()</h2><p>指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。</p><h2 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h2><p>指定了观察者的位置，在属性perspective中被用作消失点。</p><h1 id="百分比属性参照对象"><a href="#百分比属性参照对象" class="headerlink" title="百分比属性参照对象"></a>百分比属性参照对象</h1><h2 id="参照包含块宽高"><a href="#参照包含块宽高" class="headerlink" title="参照包含块宽高"></a>参照包含块宽高</h2><ol><li>参照包含块的width（margin、padding、width、left、right、font-size、text-index）</li><li>参照包含块的height（height、top、bottom）</li></ol><h2 id="参照自身盒子宽高"><a href="#参照自身盒子宽高" class="headerlink" title="参照自身盒子宽高"></a>参照自身盒子宽高</h2><ol><li>盒子模型中的border-radius</li><li>背景中的background-size</li><li>在transform变换中，translate()、transform-origin、scale()<br><a href="https://juejin.im/post/5b0bc994f265da092918d421" target="_blank" rel="external">你知道我们平时在CSS中写的%都是相对于谁吗？</a></li></ol><h1 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h1><h2 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h2><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>相对长度单位，这个单位表示元素的font-size的计算值。如果用在font-size 属性本身，它会继承父元素的font-size。</p><h3 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h3><p>这个单位表示元素font的 x-height 。在含有“x”字母的字体中，它是该字体的小写字母的高度；对于很多字体， 1ex ≈ 0.5em。</p><h3 id="ch"><a href="#ch" class="headerlink" title="ch"></a>ch</h3><p>这一单位代表元素所用字体 font中“0”这一字形的宽度（“0”，Unicode字符U+0030），或更准确地说是“0”这一字形的预测尺寸（advance measure）。</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>这个单位代表根元素的 font-size 大小（html 元素的font-size）。</p><h3 id="lh"><a href="#lh" class="headerlink" title="lh"></a>lh</h3><p>等于元素行高line-height的计算值。</p><h3 id="rlh"><a href="#rlh" class="headerlink" title="rlh"></a>rlh</h3><p>等于根元素行高line-height的计算值。</p><h2 id="视口比例的长度"><a href="#视口比例的长度" class="headerlink" title="视口比例的长度"></a>视口比例的长度</h2><h3 id="vh"><a href="#vh" class="headerlink" title="vh"></a>vh</h3><p>视口高度的 1/100。</p><h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h3><p>视口宽度的 1/100。</p><h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>等于初始包含块的大小的1%，在根元素的内联轴的方向上。</p><h3 id="vb"><a href="#vb" class="headerlink" title="vb"></a>vb</h3><p>等于初始包含块的大小的1%，在根元素的块轴的方向上。</p><h3 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a>vmin</h3><p>视口高度和宽度之间的最小值的 1/100。</p><h3 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a>vmax</h3><p>视口高度和宽度之间的最大值的 1/100。</p><h2 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h2><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>对于屏幕显示，通常是一个设备像素（点）的显示。</p><h3 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h3><p>毫米。</p><h3 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h3><p>厘米（10毫米）。</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>英寸（2.54厘米）。</p><h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>磅（1/72 英寸）。</p><h3 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h3><p>12 点活字 (1 pc 等于 12 点)。</p><h1 id="color"><a href="#color" class="headerlink" title="color"></a>color</h1><h2 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h2><p>black（黑） 、silver（银）、gray[*]（灰）、white（白）等等。</p><h2 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h2><p>transparent 关键字，是 rgba(0,0,0,0) 的简写。<br>currentColor 关键字，取当前 color 的值。</p><h2 id="颜色表达式"><a href="#颜色表达式" class="headerlink" title="颜色表达式"></a>颜色表达式</h2><p>十六进制符号 #RRGGBB<br>rgb(r, g, b)<br>rgba(r, g, b, a)<br>hsl(h, s, l) // 分别代表：色相、饱和度、亮度<br>hsla(h, s, l, a)</p><h1 id="angle"><a href="#angle" class="headerlink" title="angle"></a>angle</h1><p>用于表示角的大小，单位为度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）。在 gradient 和 transform 的某些方法等场景中有所应用。</p><h2 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h2><p>度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。</p><h2 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h2><p>百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。</p><h2 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h2><p>弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。</p><h2 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h2><p>圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。</p><h1 id="cusor（各属性使用的场景）"><a href="#cusor（各属性使用的场景）" class="headerlink" title="cusor（各属性使用的场景）"></a>cusor（各属性使用的场景）</h1><h2 id="not-allowed"><a href="#not-allowed" class="headerlink" title="not-allowed"></a>not-allowed</h2><p>提示禁用状态，如按钮禁用、禁止拖动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</div><div class="line">cursor: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p>隐藏鼠标光标，如播放视频等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">video &#123;</div><div class="line">cursor: url(transparent.gif); // 兼容</div><div class="line">cursor: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。&lt;/p&gt;
&lt;h1 id=&quot;CSS方法&quot;&gt;&lt;a href=&quot;#CSS方法&quot; class=&quot;headerlink&quot; title=&quot;CSS方法&quot;&gt;&lt;/a&gt;CSS方
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>记录一些有趣的repo</title>
    <link href="https://fanerge.github.io/2018/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84repo.html"/>
    <id>https://fanerge.github.io/2018/记录一些有趣的repo.html</id>
    <published>2018-05-31T12:22:58.000Z</published>
    <updated>2018-08-12T02:41:50.008Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hellogithub.com/" target="_blank" rel="external">大量开源项目hellogithub</a></p><h1 id="best-resume-ever"><a href="#best-resume-ever" class="headerlink" title="best-resume-ever"></a>best-resume-ever</h1><p>用Vue和LESS简单、快速建立许多漂亮的简历，并创建你最好的简历。<br><a href="https://github.com/salomonelli/best-resume-ever" target="_blank" rel="external">best-resume-ever</a><br><a href="https://salomonelli.github.io/best-resume-ever/#/" target="_blank" rel="external">官网地址</a></p><h1 id="css知识"><a href="#css知识" class="headerlink" title="css知识"></a>css知识</h1><p><a href="https://github.com/l-hammer/You-need-to-know-css" target="_blank" rel="external">You-need-to-know-css</a></p><h1 id="Web性能测试工具"><a href="#Web性能测试工具" class="headerlink" title="Web性能测试工具"></a>Web性能测试工具</h1><p><a href="https://github.com/pod4g/hiper" target="_blank" rel="external">hiper</a></p><h1 id="实现数字动画"><a href="#实现数字动画" class="headerlink" title="实现数字动画"></a>实现数字动画</h1><p><a href="https://github.com/inorganik/CountUp.js" target="_blank" rel="external">countUp.js</a></p><h1 id="Web页面加载进度条"><a href="#Web页面加载进度条" class="headerlink" title="Web页面加载进度条"></a>Web页面加载进度条</h1><p><a href="https://github.com/rstacruz/nprogress/" target="_blank" rel="external">nprogress</a><br><a href="https://github.com/jacoborus/nanobar" target="_blank" rel="external">nanobar</a></p><h1 id="UI库"><a href="#UI库" class="headerlink" title="UI库"></a>UI库</h1><p><a href="https://github.com/yued-fe/lulu" target="_blank" rel="external">阅文-lulu（jQuery）</a></p><h1 id="Web水印"><a href="#Web水印" class="headerlink" title="Web水印"></a>Web水印</h1><p><a href="https://github.com/loadchange/gwm" target="_blank" rel="external">Web水印</a></p><h1 id="常用的网址"><a href="#常用的网址" class="headerlink" title="常用的网址"></a>常用的网址</h1><p><a href="https://codepoints.net/" target="_blank" rel="external">码点查询大全</a><br><a href="https://licecap.en.softonic.com/" target="_blank" rel="external">屏幕录制-LICEcap</a><br><a href="https://giphy.com/apps/giphycapture" target="_blank" rel="external">mac-屏幕录制giphy capture</a></p><h1 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h1><h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><p>Fiddler、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hellogithub.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大量开源项目hellogithub&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;best-resume-ever&quot;&gt;&lt;a href=&quot;#best-resu
      
    
    </summary>
    
      <category term="杂项" scheme="https://fanerge.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="优秀项目" scheme="https://fanerge.github.io/tags/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Chrome调试</title>
    <link href="https://fanerge.github.io/2018/Chrome%E8%B0%83%E8%AF%95.html"/>
    <id>https://fanerge.github.io/2018/Chrome调试.html</id>
    <published>2018-05-24T14:13:30.000Z</published>
    <updated>2018-08-01T13:22:56.305Z</updated>
    
    <content type="html"><![CDATA[<p>记录Chrome DevTools比较少用但又很重要的技巧。</p><h1 id="检查动画"><a href="#检查动画" class="headerlink" title="检查动画"></a>检查动画</h1><p>使用Chrome DevTools Animations(动画)检查器检查和修改动画。<br>功能：<br>通过打开Animation Inspector(动画检查器)捕获动画。它会自动检测动画并将它们分组。<br>通过减慢动画，重播动画，或查看源代码，来检查动画。<br>通过更改动画的时间，延迟，持续时间或关键帧偏移来修改动画。</p><h1 id="设置DOM断点"><a href="#设置DOM断点" class="headerlink" title="设置DOM断点"></a>设置DOM断点</h1><p>设置DOM断点可以用来调试复杂的JavaScript应用程序。例如，如果你的JavaScript改变了DOM元素的样式，设置一个DOM断点当元素的属性被修改时触发。<br>在以下DOM更改都会触发断点：子树的变化，属性改变，节点删除。<br>设置DOM断点<br>Elements –&gt; Break on –&gt; Subtree Modifications/Attributes Modifications/Node Removal<br>查看DOM断点（包含断点类型）<br>Elements –&gt; DOM Breakpoints</p><h1 id="查看元素事件监听器"><a href="#查看元素事件监听器" class="headerlink" title="查看元素事件监听器"></a>查看元素事件监听器</h1><p>在Event Listeners(事件侦听器)窗格中查看与DOM节点相关联的JavaScript事件。<br>查看事件<br>Elements –&gt; Event Listeners<br>当取消勾选Framework listeners(框架侦听器)复选框时，事件侦听器代码可能会解析框架或库代码中的某处。</p><h1 id="模拟传感器"><a href="#模拟传感器" class="headerlink" title="模拟传感器"></a>模拟传感器</h1><p>Main menu –&gt; More Tools –&gt; Sensors<br>模拟地理位置坐标以测试地理位置覆盖。<br>模拟设备方向来测试加速计数据。</p><h1 id="在XHR上中断"><a href="#在XHR上中断" class="headerlink" title="在XHR上中断"></a>在XHR上中断</h1><p>有两种方法可以触发XHR上的断点：当任何XHR到达XHR生命周期的某个阶段时（readystatechange，load等），或者当XHR的URL与某个字符串匹配时。</p><h1 id="调试杂项"><a href="#调试杂项" class="headerlink" title="调试杂项"></a>调试杂项</h1><p>命名函数可以提高调用堆栈的可读性，不限于回掉函数。</p><h2 id="把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等"><a href="#把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等" class="headerlink" title="把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等"></a>把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等</h2><p>1.打开 DevTools Settings(设置)。<br>2.在左侧的导航菜单中，单击Blackboxing(黑箱)。<br>3.点击Add pattern…(添加模式)按钮。<br>4.在Pattern(模式)文本框输入您希望从调用堆栈中排除的文件名模式。DevTools 会排除该模式匹配的任何脚本。<br>5.在文本字段右侧的下拉菜单中，选择Blackbox(黑箱)以执行脚本文件但是排除来自调用堆栈的调用，或选择6.Disabled(禁用)来阻止文件执行。<br>7.点击 Add(添加) 保存。<br>下次运行页面并触发断点时，DevTools 将在Call Stack(调用堆栈)中隐藏任何来自放入黑盒脚本函数的调用。<br><a href="http://www.css88.com/doc/chrome-devtools/javascript/step-code/" target="_blank" rel="external">把第三方代码放入Blackbox</a><br>管理线程执行<br>使用Sources(源文件)面板上的Threads(线程)窗格暂停，step into(步入)，并检查其他线程，例如service worker 或 web worker 线程。</p><h2 id="启动-JavaScript-CPU-状态分析"><a href="#启动-JavaScript-CPU-状态分析" class="headerlink" title="启动 JavaScript CPU 状态分析"></a>启动 JavaScript CPU 状态分析</h2><p>启动一个JavaScript CPU 状态分析，可以添加一个可选标签名。要停止分析，请调用console.profileEnd()。每个分析结果都将添加到Profiles(分析)面板。<br>console.profile([label])<br>console.profileEnd();<br>在调用该方法的地方打印堆栈跟踪。<br>console.trace(object)</p><h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>monitorEvents()方法指示DevTools记录指定目标事件的信息。<br>monitorEvents(document.body, “click”);<br>要停止监听事件，请调用unmonitorEvents()方法,传递一个停止监视对象的参数。<br>unmonitorEvents(document.body);<br>查看在对象上注册事件监听器<br>getEventListeners() API返回在指定对象上注册事件的监听器。<br>返回值是一个对象，其中包含每个已注册事件类型的数组（例如，click 或 keydown）。 每个数组的成员都是对象，描述每中类型的已注册监听器。</p><h1 id="Chrome-滚动截屏"><a href="#Chrome-滚动截屏" class="headerlink" title="# Chrome 滚动截屏"></a># Chrome 滚动截屏</h1><h2 id="Chrome-截全屏（PC）"><a href="#Chrome-截全屏（PC）" class="headerlink" title="Chrome 截全屏（PC）"></a>Chrome 截全屏（PC）</h2><ol><li>打开控制台  Alt + Command+ I (Mac) 或 Ctrl + Shift + I (Windows)</li><li>功能搜索  Command + Shift + P(Mac) 或 Ctrl + Shift + P (Windows)</li><li>输入“Screen” 并选择 Capture full size screenshot 功能即可</li></ol><h2 id="Chrome-截全屏（移动端）"><a href="#Chrome-截全屏（移动端）" class="headerlink" title="Chrome 截全屏（移动端）"></a>Chrome 截全屏（移动端）</h2><p>只需在 toggle device toolbar 选择移动端<br>进行上面2的操作即可</p><h2 id="部分截屏"><a href="#部分截屏" class="headerlink" title="部分截屏"></a>部分截屏</h2><p>只需在选择对应的DOM基础上<br>进行上面2的操作即可<br><a href="https://weibo.com/ttarticle/p/show?id=2309404241869646237445" target="_blank" rel="external">如何利用 Chrome 浏览器实现滚动截屏</a></p><h1 id="Chrome-模拟移动端降低CPU及网速"><a href="#Chrome-模拟移动端降低CPU及网速" class="headerlink" title="Chrome 模拟移动端降低CPU及网速"></a>Chrome 模拟移动端降低CPU及网速</h1><p>Performance -&gt; setting -&gt; CPU/Network</p><blockquote><p>   参考文档：<br><a href="http://www.css88.com/doc/chrome-devtools/" target="_blank" rel="external">参考</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录Chrome DevTools比较少用但又很重要的技巧。&lt;/p&gt;
&lt;h1 id=&quot;检查动画&quot;&gt;&lt;a href=&quot;#检查动画&quot; class=&quot;headerlink&quot; title=&quot;检查动画&quot;&gt;&lt;/a&gt;检查动画&lt;/h1&gt;&lt;p&gt;使用Chrome DevTools Animat
      
    
    </summary>
    
      <category term="调试" scheme="https://fanerge.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://fanerge.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Web知识</title>
    <link href="https://fanerge.github.io/2018/Web%E6%9C%AF%E8%AF%AD.html"/>
    <id>https://fanerge.github.io/2018/Web术语.html</id>
    <published>2018-05-14T12:53:23.000Z</published>
    <updated>2018-07-19T12:54:53.120Z</updated>
    
    <content type="html"><![CDATA[<p>本文所有知识点，点到即止，详细内容请看各部分的连接。</p><h2 id="点击穿透（多见于移动端模态框等浮层）"><a href="#点击穿透（多见于移动端模态框等浮层）" class="headerlink" title="点击穿透（多见于移动端模态框等浮层）"></a>点击穿透（多见于移动端模态框等浮层）</h2><p>产生：上层元素触发touch事件-&gt;上层元素消失（300ms之内）-&gt;底层元素click事件触发<br>PS：touch事件之后会有300ms延迟在执行click事件是因为，在这300ms中若再次tap行为则认定为double tap事件，否则就触发click事件。<br>方案：只用touch事件、只用click事件（不推荐）、fastclick类库等<br><a href="https://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="external">点击穿透原理及解决</a></p><h2 id="CSP（内容安全策略Content-Security-Policy）"><a href="#CSP（内容安全策略Content-Security-Policy）" class="headerlink" title="CSP（内容安全策略Content-Security-Policy）"></a>CSP（内容安全策略Content-Security-Policy）</h2><p>定义：内容安全策略 (Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP 策略指令</a></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>定义：CORS (跨域资源共享)是一个系统, 包括传输的 HTTP headers, 其确定是否阻止或完成从该资源所在的域外的另一个域的网页上的受限资源的请求。<br>PS：同源安全策略( same-origin security policy)默认禁止“跨域”请求. CORS 给予Web服务器跨域访问控制, 启用安全的跨域数据传输。<br><a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" target="_blank" rel="external">CORS</a></p><h2 id="BFC（块格式化上下文Block-Formatting-Context）"><a href="#BFC（块格式化上下文Block-Formatting-Context）" class="headerlink" title="BFC（块格式化上下文Block Formatting Context）"></a>BFC（块格式化上下文Block Formatting Context）</h2><p>定义：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br>如何触发BFC：<br>• html 根元素；<br>• float 的值不为 none；<br>• overflow 的值为 auto、scroll 或 hidden；<br>• display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；<br>• position 的值不为 relative 和 static。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">块格式化上下文</a></p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p>CRLF实际上是两个字符：CR是Carriage Return（ASCII 13，\r），LF是Line Feed（ASCII 10，\n）。<br>\r\n这两个字符是用于表示换行的，其十六进制编码分别为 0x0d、0x0a。</p><h2 id="containing-block（包含块）"><a href="#containing-block（包含块）" class="headerlink" title="containing block（包含块）"></a>containing block（包含块）</h2><p>定义：在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。<br>PS：主要作用是以百分比（相关于包含块）计算自身的width、height、top、left、padding、margin等css Layout 属性。<br><a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">我所了解的CSS包含块</a>    </p><h2 id="FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）"><a href="#FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）" class="headerlink" title="FOUC（无样式内容闪烁Flash Of Unstyled Content）"></a>FOUC（无样式内容闪烁Flash Of Unstyled Content）</h2><p>定义：指的是加载网页时出现的短暂的CSS样式失效。<br>方案：head头部放css、避免使用import<br><a href="https://www.cnblogs.com/fsjohnhuang/p/6739064.html" target="_blank" rel="external">FOUC</a></p><h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>定义：由于不同的浏览器对CSS的支持程度不同，同样CSS的样式代码在不同浏览器当中的表现可能出现不一致。为了让所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。<br>方案：属性前缀法、选择器前缀法、条件注释法（<!--[if lt IE 8]-->）</p><h2 id="Domain-Name（域名）"><a href="#Domain-Name（域名）" class="headerlink" title="Domain Name（域名）"></a>Domain Name（域名）</h2><p>域名（英语：Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>顶级域名又称为跟域名（TLD）共1058+（.com、.net、.cn等等）<br>13个根域名服务器（不代表只有13台服务器，事实上517+台服务器）</p><h2 id="DNS（网域名称系统Domain-Name-System）"><a href="#DNS（网域名称系统Domain-Name-System）" class="headerlink" title="DNS（网域名称系统Domain Name System）"></a>DNS（网域名称系统Domain Name System）</h2><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p><h2 id="a链接问题"><a href="#a链接问题" class="headerlink" title="a链接问题"></a>a链接问题</h2><p>a链接使用绑定 mousedown 事件且 event.preventDefault() 会导致 :active 伪类失效（Firefox）。<br>PS：Firefox 认为 mousedown 事件在 :active 之前发生。</p><h2 id="min-width、max-width、width、-important优先级"><a href="#min-width、max-width、width、-important优先级" class="headerlink" title="min-width、max-width、width、!important优先级"></a>min-width、max-width、width、!important优先级</h2><p>如果min-width、max-width、width、!important同时存在时，优先级顺序：min-width &gt;&gt; max-width &gt;&gt; !important &gt;&gt; width</p><h2 id="巧用css-兄弟选择器（如导航分割线）"><a href="#巧用css-兄弟选择器（如导航分割线）" class="headerlink" title="巧用css 兄弟选择器（如导航分割线）"></a>巧用css 兄弟选择器（如导航分割线）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;</div><div class="line">// 这样排除第一个元素</div><div class="line">a + a:before &#123;</div><div class="line">content: &quot;&quot;;</div><div class="line">font-size: 0;</div><div class="line">padding: 10px 3px 1px;</div><div class="line">margin-left: 6px;</div><div class="line">border-left: 1px solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="img-在firefox和其他浏览器的差异"><a href="#img-在firefox和其他浏览器的差异" class="headerlink" title="img 在firefox和其他浏览器的差异"></a>img 在firefox和其他浏览器的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">// width 和 height 无效，需要设置display: inline-block;</div><div class="line">width: xx;</div><div class="line">height: xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="关于百分比设置下列属性"><a href="#关于百分比设置下列属性" class="headerlink" title="关于百分比设置下列属性"></a>关于百分比设置下列属性</h2><p>left（right）、width、padding、margin、background-position、text-index设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>的width值<br>top（bottom）、height设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>height值</p><h2 id="滚动容器底部留白"><a href="#滚动容器底部留白" class="headerlink" title="滚动容器底部留白"></a>滚动容器底部留白</h2><p>滚动容器底部留白使用 margin-bottom，使用 padding-bottom 存在兼容性问题。</p><h2 id="margin-合并（只存在垂直方向）"><a href="#margin-合并（只存在垂直方向）" class="headerlink" title="margin 合并（只存在垂直方向）"></a>margin 合并（只存在垂直方向）</h2><ol><li>相邻兄弟元素 margin 合并。</li><li>父级和第一个、父级和最后一个子元素。（虽然是在子元素上设置的 margin-top，但实际上就等同于在父元素上设置了 margin-top）</li><li>空块级元素的 margin 合并。</li></ol><p>PS：合并规则，正正取大值，正负值相加，负负最小值。</p><h2 id="margin-auto-的理解"><a href="#margin-auto-的理解" class="headerlink" title="margin: auto;的理解"></a>margin: auto;的理解</h2><p>margin: auto; 表示对剩余空白进行分配。<br>下面元素 .son 的 margin-left 为 300 - 200 -80 = 20px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-right: 80px;</div><div class="line">margin-left: auto; // 20px</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 margin 来进行 right 对齐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">width: 200px;</div><div class="line">margin-left: auto; // 此时 auto 值为100px</div><div class="line">// flot: right; 等价</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：块级元素的左中右对齐使用 margin ，内联元素使用 text-align 控制左中右对戏。<br>水平和垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">width: 300px; height:150px;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line">.son &#123;</div><div class="line">position: absolute; // 很关键</div><div class="line">top: 0; right: 0; bottom: 0; left: 0;</div><div class="line">width: 200px; height: 100px;</div><div class="line">margin: auto; // 很关键</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="border-的一些秘密"><a href="#border-的一些秘密" class="headerlink" title="border 的一些秘密"></a>border 的一些秘密</h2><p>border-width 不支持百分比值（outline、box-shadow、text-shadow同样）<br>border-style:double 至少 3px 才有效果。<br>border-style:dashed 不同浏览器不一致（虚线颜色区的宽高比以及颜色区和透明区的宽度比例），如chrome上为方形ie为圆形。<br>thin（1px）、medium（默认值3px）、thick（4px）。</p><h2 id="border-技巧"><a href="#border-技巧" class="headerlink" title="border 技巧"></a>border 技巧</h2><p>等腰三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>直角三角形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 0;</div><div class="line">border-width: 10px 20px;</div><div class="line">border-style: solid;</div><div class="line">border-color: #f30 #f30 transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>边框 3D 效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 10px; height: 10px;</div><div class="line">border: 10px solid;</div><div class="line">border-color: #f30 #00f #396 #0f0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="http://www.cnblogs.com/xiaohuochai/p/5457127.html" target="_blank" rel="external">等高布局</a></p><h2 id="css-度量单位-ex"><a href="#css-度量单位-ex" class="headerlink" title="css 度量单位 ex"></a>css 度量单位 ex</h2><p>相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。<br>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>作用：基于ex单位的天然垂直居中对齐效果</p><h2 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h2><p>行距 = line-height - font-size</p><h2 id="line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？"><a href="#line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？" class="headerlink" title="line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？"></a>line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？</h2><p>因为继承细节有所差别，如果使用数值作为 line-height 的属性值，那么所有的子元素继承的都是这个值（如1.5）；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值（16px*150%=24px，此时继承的就是24px这个值，不是150%）。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>作用：只能应用于内联元素以及 display 值为 table-cell 的元素。<br>定义：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。<br>线类，如 baseline（默认值）、top、middle、bottom；<br>文本类，如 text-top、text-bottom；<br>上标下标类，如 sub、super；<br>数值百分比类，如 20px、2em、20%等<br>PS：其实middle为基线往上 1/2 x-height 处（ x-height 为 x 的高度）</p><h2 id="消除图片下间隙"><a href="#消除图片下间隙" class="headerlink" title="消除图片下间隙"></a>消除图片下间隙</h2><ol><li>display:block;</li><li>vertical-align:top; // top，text-top，bottom，text-bottom 均可</li><li>font-size:0; // 父级设置</li><li>overflow:hidden;</li><li>float:left;</li></ol><p><a href="http://www.cnblogs.com/luojianqun/archive/2013/07/08/3177969.html" target="_blank" rel="external">CSS图片下面产生间隙的6种解决方案</a></p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>规范约定了浮动元素和内联元素在一行显示。<br>浮动元素会生成一个块级框，而不论它本身是何种元素。</p><h2 id="clip属性"><a href="#clip属性" class="headerlink" title="clip属性"></a>clip属性</h2><p>fixed 固定定位的剪裁<br>最佳可访问性隐藏（clip: rect(0,0,0,0)）</p><h2 id="stacking-context（层叠上下文）"><a href="#stacking-context（层叠上下文）" class="headerlink" title="stacking context（层叠上下文）"></a>stacking context（层叠上下文）</h2><p>层叠上下文，英文称作 stacking context，是 HTML 中的一个三维的概念。</p><h3 id="层叠水平（stacking-level-（逐渐升高）"><a href="#层叠水平（stacking-level-（逐渐升高）" class="headerlink" title="层叠水平（stacking level)（逐渐升高）"></a>层叠水平（stacking level)（逐渐升高）</h3><ol><li>层叠上下文（background/border） – 充当背景色</li><li>负的z-index</li><li>block块状水平盒子 – 布局</li><li>float浮动盒子</li><li>inline水平盒子（inline/inline-block/inline-table） – 内容</li><li>z-index:anto 或 看成 z-index:0</li><li>正的z-index</li></ol><p>一般情况都会满足满足上面的规则，详情可以看下面demo：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="pKverE" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/pKverE/" target="_blank" rel="external">stackingContext</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="external">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="如何触发一个元素形成堆叠上下文？"><a href="#如何触发一个元素形成堆叠上下文？" class="headerlink" title="如何触发一个元素形成堆叠上下文？"></a>如何触发一个元素形成堆叠上下文？</h3><ol><li>根元素 (HTML),</li><li>z-index 值不为 “auto”的 绝对/相对定位，</li><li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li><li>transform 属性值不为 “none”的元素，</li><li>mix-blend-mode 属性值不为 “normal”的元素，</li><li>filter值不为“none”的元素，</li><li>perspective值不为“none”的元素，</li><li>isolation 属性被设置为 “isolate”的元素，</li><li>position: fixed</li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li></ol><p>PS：使用了上述属性就会形成一个stacking context（堆叠上下文）。此时，要对两者进行层叠排列，就需要 z-index ，z-index 越高的层叠层级越高。<br>做了一个上述情况的demo：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="JZoWWp" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext2" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/JZoWWp/" target="_blank" rel="external">stackingContext2</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="external">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><a href="https://www.cnblogs.com/coco1s/p/5899089.html" target="_blank" rel="external">层叠顺序与堆栈上下文知多少</a></p><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。<br><a href="https://segmentfault.com/a/1190000014457824" target="_blank" rel="external">你应该知道的requestIdleCallback</a></p><h2 id="敏捷开发的原则编辑"><a href="#敏捷开发的原则编辑" class="headerlink" title="敏捷开发的原则编辑"></a>敏捷开发的原则编辑</h2><h3 id="快速迭代"><a href="#快速迭代" class="headerlink" title="快速迭代"></a>快速迭代</h3><p>相对那种半年一次的大版本发布来说，小版本的需求、开发和测试更加简单快速。一些公司，一年发布仅2~3个版本，发布流程缓慢，它们仍采用瀑布开发模式，更严重的是对敏捷开发模式存在误解。</p><h3 id="让测试人员和开发者参与需求讨论"><a href="#让测试人员和开发者参与需求讨论" class="headerlink" title="让测试人员和开发者参与需求讨论"></a>让测试人员和开发者参与需求讨论</h3><p>需求讨论以研讨组的形式展开最有效率。研讨组，需要包括测试人员和开发者，这样可以更加轻松定义可测试的需求，将需求分组并确定优先级。 同时，该种方式也可以充分利用团队成员间的互补特性。如此确定的需求往往比开需求讨论大会的形式效率更高，大家更活跃，参与感更强。</p><h3 id="编写可测试的需求文档"><a href="#编写可测试的需求文档" class="headerlink" title="编写可测试的需求文档"></a>编写可测试的需求文档</h3><p>开始就要用“用户故事”（User Story）的方法来编写需求文档。这种方法，可以让我们将注意力放在需求上，而不是解决方法和实施技术上。过早的提及技术实施方案，会降低对需求的注意力。</p><h3 id="多沟通，尽量减少文档"><a href="#多沟通，尽量减少文档" class="headerlink" title="多沟通，尽量减少文档"></a>多沟通，尽量减少文档</h3><p>任何项目中，沟通都是一个常见的问题。好的沟通，是敏捷开发的先决条件。在圈子里面混得越久，越会强调良好高效的沟通的重要性。<br>团队要确保日常的交流，面对面沟通比邮件强得多。</p><h3 id="做好产品原型"><a href="#做好产品原型" class="headerlink" title="做好产品原型"></a>做好产品原型</h3><p>建议使用草图和模型来阐明用户界面。并不是所有人都可以理解一份复杂的文档，但人人都会看图。</p><h3 id="及早考虑测试"><a href="#及早考虑测试" class="headerlink" title="及早考虑测试"></a>及早考虑测试</h3><p>及早地考虑测试在敏捷开发中很重要。传统的软件开发，测试用例很晚才开始写，这导致过晚发现需求中存在的问题，使得改进成本过高。较早地开始编写测试用例，当需求完成时，可以接受的测试用例也基本一块完成了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文所有知识点，点到即止，详细内容请看各部分的连接。&lt;/p&gt;
&lt;h2 id=&quot;点击穿透（多见于移动端模态框等浮层）&quot;&gt;&lt;a href=&quot;#点击穿透（多见于移动端模态框等浮层）&quot; class=&quot;headerlink&quot; title=&quot;点击穿透（多见于移动端模态框等浮层）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="前端面试" scheme="https://fanerge.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Web" scheme="https://fanerge.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>dom接口</title>
    <link href="https://fanerge.github.io/2018/dom%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://fanerge.github.io/2018/dom接口.html</id>
    <published>2018-05-08T12:43:18.000Z</published>
    <updated>2018-05-08T14:24:35.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CustomEvent"><a href="#CustomEvent" class="headerlink" title="CustomEvent"></a>CustomEvent</h1><p>创建一个自定义事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 添加一个适当的事件监听器</div><div class="line">obj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;)</div><div class="line"></div><div class="line">// 创建一个自定义事件</div><div class="line">var event = new CustomEvent(&quot;cat&quot;, &#123;&quot;detail&quot;:&#123;&quot;hazcheeseburger&quot;:true&#125;&#125;)</div><div class="line">// 分发事件</div><div class="line">obj.dispatchEvent(event)</div></pre></td></tr></table></figure></p><h1 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h1><p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。<br>DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。</p><h2 id="创建一个DocumentFragment"><a href="#创建一个DocumentFragment" class="headerlink" title="创建一个DocumentFragment"></a>创建一个DocumentFragment</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let ul = document.querySelector(`[data-uid=&quot;ul&quot;]`);</div><div class="line">let frag = document.createDocumentFragment();</div><div class="line">const list = [</div><div class="line">&apos;IE&apos;,</div><div class="line">&apos;Chrome&apos;</div><div class="line">];</div><div class="line">list.forEach(item =&gt; &#123;</div><div class="line">let li = document.creteElement(&apos;li&apos;);</div><div class="line">li.textContent = item;</div><div class="line">frag.appendChild(li);</div><div class="line">&#125;);</div><div class="line">// 只进行一次dom操作，触发一次reflow</div><div class="line">ul.appendChild(frag);</div><div class="line">```</div><div class="line">##其他方法（实例方法）</div></pre></td></tr></table></figure><p>documentFragment.find()<br>返回 DocumentFragment 树里第一个匹配的元素 Element 。<br>documentFragment.findAll()<br>返回 DocumentFragment 树里所有匹配的元素  NodeList。<br>documentFragment.querySelector()<br>documentFragment.querySelectorAll()<br>documentFragment.getElementById()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#MutationObserver</div><div class="line">给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</div><div class="line">##实例方法</div><div class="line">observe()</div><div class="line">给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.</div><div class="line">disconnect()</div><div class="line">让该观察者对象停止观察指定目标的DOM变化.即使再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.</div><div class="line">takeRecords()</div><div class="line">清空观察者对象的记录队列,并返回里面的内容.</div><div class="line">##示例</div></pre></td></tr></table></figure></p><p>let target = document.querySelector(‘#some-id’);</p><p>// 创建观察者对象<br>let observer = new MutationObserver(function(mutations) {<br>  mutations.forEach(function(mutation) {<br>    console.log(mutation.type);<br>  });<br>});</p><p>// 配置观察选项:<br>let config = { attributes: true, childList: true, characterData: true }</p><p>// 传入目标节点和观察选项<br>observer.observe(target, config);</p><p>// 随后,你还可以停止观察<br>observer.disconnect();<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CustomEvent&quot;&gt;&lt;a href=&quot;#CustomEvent&quot; class=&quot;headerlink&quot; title=&quot;CustomEvent&quot;&gt;&lt;/a&gt;CustomEvent&lt;/h1&gt;&lt;p&gt;创建一个自定义事件。&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="js" scheme="https://fanerge.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://fanerge.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>git工具书</title>
    <link href="https://fanerge.github.io/2018/git%E5%B7%A5%E5%85%B7%E4%B9%A6.html"/>
    <id>https://fanerge.github.io/2018/git工具书.html</id>
    <published>2018-04-23T14:41:30.000Z</published>
    <updated>2018-08-03T13:51:20.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%86.png" alt="git原理"><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">图片来源</a><br><a href="https://juejin.im/entry/5ac04d195188255c946bcd4a" target="_blank" rel="external">Git 常用操作总结</a><br>PS：<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="git托管项目（新建-or-clone一个git项目）"><a href="#git托管项目（新建-or-clone一个git项目）" class="headerlink" title="git托管项目（新建 or clone一个git项目）"></a>git托管项目（新建 or clone一个git项目）</h2><p>mkdir gitdemo // 在当前目录创建gitdemo目录<br>cd gitdemo<br>pwd // 显示当前目录<br>git init // 将当前目录设置为git管理的仓库<br>git init [projectName] // 新建一个目录，将其初始化为Git代码库<br>or<br>git clone [ssh/https]</p><h2 id="工作区-gt-gt-暂存区（add为添加文件rm为移除文件）"><a href="#工作区-gt-gt-暂存区（add为添加文件rm为移除文件）" class="headerlink" title="工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）"></a>工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）</h2><p>git add [fileName] // 单个或多个文件<br>git add *.js // 通配符<br>git add -u  // 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .  // 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件<br>git add -A  // 提交所有变化（是git add .和git add -u的结合，git add -all的简写</p><p>git rm [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区<br>git rm --cached [fileName] // 停止追踪指定文件，但该文件会保留在工作区<br>git mv [fileNameOld] [fileNameNew] // 改名文件，并且将这个改名放入暂存区</p><h2 id="暂存区-gt-gt-本地仓库"><a href="#暂存区-gt-gt-本地仓库" class="headerlink" title="暂存区&gt;&gt;本地仓库"></a>暂存区&gt;&gt;本地仓库</h2><p>git commit -m ‘说明信息’ // 提交<br>git commit -am ‘说明’ // git add . 和 git commit的简写（一次完成两个动作）<br>常用commit type</p><ul><li>feat: 新功能</li><li>fix: 修复问题</li><li>docs: 修改文档</li><li>style: 修改代码格式，不影响代码逻辑</li><li>refactor: 重构代码，理论上不影响现有功能</li><li>perf: 提升性能</li><li>test: 增加修改测试用例</li><li>chore: 修改工具相关（包括但不限于文档、代码生成等）</li></ul><h2 id="本地仓库-gt-gt-远程仓库"><a href="#本地仓库-gt-gt-远程仓库" class="headerlink" title="本地仓库&gt;&gt;远程仓库"></a>本地仓库&gt;&gt;远程仓库</h2><p>git push ssh://git@dev.fanerge.com/gitdemo.git master // 把本地仓库提交到远程仓库的master分支中<br>git push -u origin master // 当前分支提交到远程 master 分支<br>git push // 如果当前分支与远程分支存在追踪关系</p><h2 id="远程仓库-gt-gt-本地仓库"><a href="#远程仓库-gt-gt-本地仓库" class="headerlink" title="远程仓库&gt;&gt;本地仓库"></a>远程仓库&gt;&gt;本地仓库</h2><p>git fetch [远程主机名] [分支名] // 远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地<br>git fetch origin master<br>git clone [ssh/https]// 从远程主机克隆一个版本库<br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">更详细的资料</a></p><h2 id="远程仓库-gt-gt-工作区"><a href="#远程仓库-gt-gt-工作区" class="headerlink" title="远程仓库&gt;&gt;工作区"></a>远程仓库&gt;&gt;工作区</h2><p>git pull [远程主机名] [远程分支名]:[本地分支名] // 远程主机某个分支的更新，再与本地的指定分支合并<br>git pull // 当前分支只有一个追踪分支时可省略部分参数</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>git branch // 查看本地所有分支（*表示当前分支）<br>git branch -v // 查看本地所有分支及最近一次提交信息<br>git branch -vv // 查看本地所有分支及最近一次提交信息和远程追踪分支<br>git branch -r // 查看远程所有分支<br>git branch -a // 查看本地/远程所有分支</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout [branchName] // 切换分支<br>git checkout - // 切换到上一个分支</p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>git branch [branchName] // 新建一个分支（但仍然留在当前分支）<br>git checkout -b [branchName] // 新建一个分支（并切换到该分支）<br>git branch [branchName] [commitId] // 新建一个分支（并指向指定的commitId）<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>如：新建 test 分支，并指向远程的 orign/dev 分支<br>git branch --track test origin/dev</p><h2 id="新建远程分支（新建本地分支，推送的远程作为远程分支）"><a href="#新建远程分支（新建本地分支，推送的远程作为远程分支）" class="headerlink" title="新建远程分支（新建本地分支，推送的远程作为远程分支）"></a>新建远程分支（新建本地分支，推送的远程作为远程分支）</h2><p>git branch [branchName]<br>git push origin [branchName]:[remoteBranchName]<br>还需要为新建本地分支和远程分支建立追踪关系<br>如：本地的 test 分支作为远程的 dev 分支<br>git push origin test:dev</p><h2 id="建立追踪关系（当前分支和远程分支）"><a href="#建立追踪关系（当前分支和远程分支）" class="headerlink" title="建立追踪关系（当前分支和远程分支）"></a>建立追踪关系（当前分支和远程分支）</h2><p>作用：用来描述当前和远程分支的位置关系，在使用git pull 和 git push 的时候可以省略远程参数<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>git branch –-set-upstream-to=origin/[branchName]<br>如：当前分支和远程 dev 分支建立追踪关系<br>git branch –-set-upstream-to=origin/dev</p><h2 id="合并分支（branchName合并到当前分支）"><a href="#合并分支（branchName合并到当前分支）" class="headerlink" title="合并分支（branchName合并到当前分支）"></a>合并分支（branchName合并到当前分支）</h2><p>git merge [branchName]<br>git rebase [branchName]<br>PS：<br>git merge dev（当前分支为master）<br>会在 master 分支产生一个新的commit。<br>git rebase dev（当前分支为master）<br>会将master上的提交推至顶端。</p><h2 id="删除分支（本地）"><a href="#删除分支（本地）" class="headerlink" title="删除分支（本地）"></a>删除分支（本地）</h2><p>git branch -d [branchName] // 删除分支（本地）<br>git push origin --delete [branchName] // 删除分支（远程）<br>git branch -dr [remoteBranchName] // 删除分支（远程）</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>tag作用类似于里程碑，可以快速找到里程碑的代码。</p><h2 id="查看所有tag"><a href="#查看所有tag" class="headerlink" title="查看所有tag"></a>查看所有tag</h2><p>git tag</p><h2 id="新建tag在当前commit"><a href="#新建tag在当前commit" class="headerlink" title="新建tag在当前commit"></a>新建tag在当前commit</h2><p>git tag [tagName]</p><h2 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h2><p>git tag [tagName] [commitId]</p><h2 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h2><p>git tag -d [tagName]</p><h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><p>git push origin :refs/tags/[tagName]</p><h2 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h2><p>git show [tagName]</p><h2 id="向远程提交指定tag"><a href="#向远程提交指定tag" class="headerlink" title="向远程提交指定tag"></a>向远程提交指定tag</h2><p>git push [remoteBranchName] [tagName]</p><h2 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h2><p>git checkout -b [branchName] [tagName]</p><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><h2 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h2><p>git status</p><h2 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h2><p>git log</p><h2 id="显示当前分支的版本历史（包括commit发生变更的文件）"><a href="#显示当前分支的版本历史（包括commit发生变更的文件）" class="headerlink" title="显示当前分支的版本历史（包括commit发生变更的文件）"></a>显示当前分支的版本历史（包括commit发生变更的文件）</h2><p>git log –stat</p><h2 id="显示当前分支的版本历史（通过关键词）"><a href="#显示当前分支的版本历史（通过关键词）" class="headerlink" title="显示当前分支的版本历史（通过关键词）"></a>显示当前分支的版本历史（通过关键词）</h2><p>git log -S [keyword]</p><h2 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h2><p>git log [tagName] HEAD –pretty=format:%s</p><h2 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h2><p>git log [tagName] HEAD –grep feature</p><h2 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h2><p>git log –follow [fileName]<br>git whatchanged [fileName]</p><h2 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h2><p>git log -p [fileName]</p><h2 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h2><p>git log -5 –pretty –oneline</p><h2 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h2><p>git shortlog -sn</p><h2 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h2><p>git blame [file]</p><h2 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h2><p>git biff</p><h2 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h2><p>git diff –cached [fileName]</p><h2 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h2><p>git diff HEAD</p><h2 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h2><p>git diff [first-branch]…[second-branch]</p><h2 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h2><p>git diff –shortstat “@{0 day ago}”</p><h2 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h2><p>git show [commitId]</p><h2 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h2><p>git show –name-only [commitId]</p><h2 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h2><p>git show [commitId]:[fileName]</p><h2 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h2><p>git reflog</p><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h2><p>git fetch [ssh/https]</p><h2 id="显示所有远程仓库（包括fetch和push地址）"><a href="#显示所有远程仓库（包括fetch和push地址）" class="headerlink" title="显示所有远程仓库（包括fetch和push地址）"></a>显示所有远程仓库（包括fetch和push地址）</h2><p>git remote -v</p><h2 id="显示某一远程仓库的信息"><a href="#显示某一远程仓库的信息" class="headerlink" title="显示某一远程仓库的信息"></a>显示某一远程仓库的信息</h2><p>git remote show [remoteRepositoryName]</p><h2 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h2><p>git remote add [shortname] [url]</p><h2 id="取回远程仓库的变化，并与本地分支合并（merge）"><a href="#取回远程仓库的变化，并与本地分支合并（merge）" class="headerlink" title="取回远程仓库的变化，并与本地分支合并（merge）"></a>取回远程仓库的变化，并与本地分支合并（merge）</h2><p>git pull [remote] [remoteBranchName]<br>PS：remote 一般为 origin ，当建立追踪关系，可以git pull 省略两个参数</p><h2 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h2><p>git push [remote] [branchName]</p><h2 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h2><p>git push [remote] –force</p><h2 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h2><p>git push [remote] –all</p><h1 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销/恢复"></a>撤销/恢复</h1><h2 id="撤销工作区修改（指定文件）"><a href="#撤销工作区修改（指定文件）" class="headerlink" title="撤销工作区修改（指定文件）"></a>撤销工作区修改（指定文件）</h2><p>git chekout – [fileName]</p><h2 id="撤销工作区（所有文件）"><a href="#撤销工作区（所有文件）" class="headerlink" title="撤销工作区（所有文件）"></a>撤销工作区（所有文件）</h2><p>git checkout – .</p><h2 id="暂存区–-gt-工作区（指定文件）"><a href="#暂存区–-gt-工作区（指定文件）" class="headerlink" title="暂存区–&gt;工作区（指定文件）"></a>暂存区–&gt;工作区（指定文件）</h2><p>git reset HEAD [fileName] // 撤销暂存区的修改<br>git checkout [fileName] // 撤销工作区的修改</p><h2 id="重置暂存区到上次提交commit（工作区不变）"><a href="#重置暂存区到上次提交commit（工作区不变）" class="headerlink" title="重置暂存区到上次提交commit（工作区不变）"></a>重置暂存区到上次提交commit（工作区不变）</h2><p>git reset [fileName]</p><h2 id="重置暂存区、工作区到上次提交commit"><a href="#重置暂存区、工作区到上次提交commit" class="headerlink" title="重置暂存区、工作区到上次提交commit"></a>重置暂存区、工作区到上次提交commit</h2><p>git reset –hard<br>git reset HEAD^ –hard // 回到上一次commit<br>git reset HEAD^^ –hard // 回到上一次的上一次commit</p><h2 id="重置暂存区、当前分支指定commitId（工作区不变）"><a href="#重置暂存区、当前分支指定commitId（工作区不变）" class="headerlink" title="重置暂存区、当前分支指定commitId（工作区不变）"></a>重置暂存区、当前分支指定commitId（工作区不变）</h2><p>git reset [commitId]</p><h2 id="重置暂存区、工作区、当前分支为指定commitId"><a href="#重置暂存区、工作区、当前分支为指定commitId" class="headerlink" title="重置暂存区、工作区、当前分支为指定commitId"></a>重置暂存区、工作区、当前分支为指定commitId</h2><p>git reset –hard [commitId]</p><h2 id="重置当前HEAD为指定commitId（暂存区、工作区不表）"><a href="#重置当前HEAD为指定commitId（暂存区、工作区不表）" class="headerlink" title="重置当前HEAD为指定commitId（暂存区、工作区不表）"></a>重置当前HEAD为指定commitId（暂存区、工作区不表）</h2><p>git reset –keep [commitId]</p><h2 id="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"><a href="#新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）" class="headerlink" title="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"></a>新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）</h2><p>git revert [commitId]</p><h2 id="暂时将未提交的变化存于stash，后续再从stash中取出"><a href="#暂时将未提交的变化存于stash，后续再从stash中取出" class="headerlink" title="暂时将未提交的变化存于stash，后续再从stash中取出"></a>暂时将未提交的变化存于stash，后续再从stash中取出</h2><p>git stash list // 查看 stash 列表<br>git stash // 保存当前暂未提交的修改<br>git stash apply // 从stash中恢复，但不清除该stash<br>git stash drop  // 清除该stash<br>git stash pop // 从stash中恢复并清除该stash<br>PS：一般用于停下手中活，处理更加紧急的任务，处理完任务后在回过头继续。<br>git stash pop = git stash apply + git stash drop</p><h1 id="开发分支合并到master分支"><a href="#开发分支合并到master分支" class="headerlink" title="开发分支合并到master分支"></a>开发分支合并到master分支</h1><p>更新与2018-07-17<br>git rebase的作用用于增删改当前 commits ，并将其合并到对应分支。<br>适用于：dev分支有开发，master分支其他人有合并，合并时需要以最新的master分支作为基础合并。<br>假如在dev分支开发完毕需要合并时：</p><ol><li>git checkout dev // 确保在你所在的开发分支如dev</li><li>git rebase master </li><li>如果有冲突，解决冲突</li><li>git rebase --continue</li><li>git checkout master // 回到master分支，进行合并</li><li>git merge dev</li></ol><p><a href="https://juejin.im/post/5b46c784f265da0f540513cd" target="_blank" rel="external">git：rebase（变基）的使用和理解</a></p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="Vim共有3种模式"><a href="#Vim共有3种模式" class="headerlink" title="Vim共有3种模式"></a>Vim共有3种模式</h2><p>编辑模式(命令模式)-默认模式<br>输入模式<br>末行模式</p><h2 id="各种模式的切换"><a href="#各种模式的切换" class="headerlink" title="各种模式的切换"></a>各种模式的切换</h2><h3 id="编辑–-gt-输入"><a href="#编辑–-gt-输入" class="headerlink" title="编辑–&gt;输入"></a>编辑–&gt;输入</h3><p> i: 在当前光标所在字符的前面，转为输入模式；<br> a: 在当前光标所在字符的后面，转为输入模式；<br> o: 在当前光标所在行的下方，新建一行，并转为输入模式；<br> I：在当前光标所在行的行首，转换为输入模式<br> A：在当前光标所在行的行尾，转换为输入模式<br> O：在当前光标所在行的上方，新建一行，并转为输入模式；</p><h3 id="输入–-gt-编辑"><a href="#输入–-gt-编辑" class="headerlink" title="输入–&gt;编辑"></a>输入–&gt;编辑</h3><p>ESC</p><h3 id="编辑–-gt-末行"><a href="#编辑–-gt-末行" class="headerlink" title="编辑–&gt;末行"></a>编辑–&gt;末行</h3><p>:</p><h3 id="末行–-gt-编辑"><a href="#末行–-gt-编辑" class="headerlink" title="末行–&gt;编辑"></a>末行–&gt;编辑</h3><p>ESC, ESC</p><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>1、末行模式关闭文件<br>:q  退出<br>:wq 保存并退出<br>:q! 不保存并退出<br>:w 保存<br>:w! 强行保存<br>:wq –&gt; :x<br>2、编辑模式下退出<br>ZZ: 保存并退出</p><blockquote><p>   参考文档：<br><a href="https://git-scm.com/" target="_blank" rel="external">git 官网</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="external">Git教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%
      
    
    </summary>
    
      <category term="代码管理" scheme="https://fanerge.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://fanerge.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>js算法集合</title>
    <link href="https://fanerge.github.io/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html"/>
    <id>https://fanerge.github.io/2018/js算法集合.html</id>
    <published>2018-04-08T14:20:17.000Z</published>
    <updated>2018-04-25T14:04:52.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断文本是否为回文"><a href="#判断文本是否为回文" class="headerlink" title="判断文本是否为回文"></a>判断文本是否为回文</h1><p>定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。</p><h2 id="方法一（字符串、数组内置方法）"><a href="#方法一（字符串、数组内置方法）" class="headerlink" title="方法一（字符串、数组内置方法）"></a>方法一（字符串、数组内置方法）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome1(val)&#123;</div><div class="line">// 允许输入字符串和数字和布尔值</div><div class="line">if (typeof val !== &apos;string&apos;) val = val.toString();</div><div class="line">let newVal = val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line"></div><div class="line">return val === newVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome1(121) // true</div><div class="line">isPalindrome1(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>// PS：方法简单，但效率不高，会产生一个新的变量</p><h2 id="方法二（循环）"><a href="#方法二（循环）" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 判断文字是否为回文</div><div class="line">* @param &#123;string|number&#125; val 需要判断的文字</div><div class="line">* @return &#123;boolean&#125; bool 是否为回文 </div><div class="line">*/</div><div class="line">function isPalindrome2(val)&#123;</div><div class="line">val = val + &apos;&apos;; // 非字符串转化为字符串</div><div class="line"></div><div class="line">// 这里为什么 i &lt;= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！</div><div class="line">for(let i = 0, j = val.length - 1; i &lt; j; i++, j--)&#123;</div><div class="line">if(val.charAt(i) !== val.charAt(j))&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPalindrome2(121) // true</div><div class="line">isPalindrome2(&apos;yuzuy&apos;) // true</div></pre></td></tr></table></figure><p>PS：网上还有其他解法，大多为以上两种的变形。</p><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="方法一（字符串、数组内置方法））"><a href="#方法一（字符串、数组内置方法））" class="headerlink" title="方法一（字符串、数组内置方法））"></a>方法一（字符串、数组内置方法））</h2><p>借用反转字符串的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal1(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">return val.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法二（循环）-1"><a href="#方法二（循环）-1" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><p>循环系列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal2(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">i = 0,</div><div class="line">len = val.length;</div><div class="line">while(i &lt; len)&#123;</div><div class="line">str += val.charAt(len - 1 - i);</div><div class="line">i++; </div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">* 反转字符串</div><div class="line">* @param &#123;string&#125; val 需要反转的字符串</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function reverseVal3(val)&#123;</div><div class="line">if (typeof val !== &apos;string&apos;) return;</div><div class="line"></div><div class="line">let str = &apos;&apos;,</div><div class="line">len = val.length;</div><div class="line">for(let i = len - 1; i &gt;= 0; i--)&#123;</div><div class="line">str += val.charAt(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：reverseVal(‘abc’) // ‘cba’</p><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="方法一（递归）"><a href="#方法一（递归）" class="headerlink" title="方法一（递归）"></a>方法一（递归）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize1(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line"></div><div class="line">// 建议不要使用 arguments.callee，目前已经废弃了。</div><div class="line">return n * factorialize1(n - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</p><h2 id="方法二（ES6尾调用优化）"><a href="#方法二（ES6尾调用优化）" class="headerlink" title="方法二（ES6尾调用优化）"></a>方法二（ES6尾调用优化）</h2><p>（递归优化版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize2(n, total = 1)&#123;</div><div class="line">if(typeof n !== &apos;number&apos; || typeof total !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return total;</div><div class="line"></div><div class="line">return factorialize2(n - 1, n * total)</div><div class="line">// f(3) =&gt; f(2, 3 * 2) =&gt; f(1, 6) =&gt; 6</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="external">ES6尾调用优化</a>但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><h2 id="方法三（循环）"><a href="#方法三（循环）" class="headerlink" title="方法三（循环）"></a>方法三（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 阶乘</div><div class="line">* @param &#123;number&#125; n 需要求的阶乘</div><div class="line">* @return &#123;number&#125; 阶乘值</div><div class="line">*/</div><div class="line">function factorialize3(n)&#123;</div><div class="line">if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</div><div class="line">if(n === 1) return 1;</div><div class="line">let total = 1;</div><div class="line"></div><div class="line">while(n&gt;1)&#123;</div><div class="line">total = n * total;</div><div class="line">n--;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：factorialize1(3) // 6</p><h1 id="随机生成长度为n字符串"><a href="#随机生成长度为n字符串" class="headerlink" title="随机生成长度为n字符串"></a>随机生成长度为n字符串</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString1(n)&#123;</div><div class="line">let str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;</div><div class="line">let tem = &apos;&apos;,</div><div class="line">i = 0;</div><div class="line"></div><div class="line">// Math.random 函数产生值的范围[0,1)</div><div class="line">while(i&lt;n)&#123;</div><div class="line">tem += str.charAt(Math.floor(Math.random() * str.length))</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：Math.round(Math.random() <em> (str.length - 1))<br>Math.ceil(Math.random() </em> (str.length - 1))<br>Math.floor(Math.random() * str.length)<br>这三种方式等价，都能生成[0, str.length-1]随机数</p><h2 id="方法二（进制转化）"><a href="#方法二（进制转化）" class="headerlink" title="方法二（进制转化）"></a>方法二（进制转化）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString2(n)&#123;</div><div class="line">return Math.random().toString(36).substr(2).slice(0, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法原理为随机产生的数转换为指定进制字符串<br>toString(n)，n为[2,36]，n&lt;=10时只产生0-9也就是10进制数字<br>该方法有个缺点，产生字符串的长度有一定的限制。</p><h2 id="方法三（随机码点）"><a href="#方法三（随机码点）" class="headerlink" title="方法三（随机码点）"></a>方法三（随机码点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 生成指定长度的随机字符串</div><div class="line">* @param &#123;number&#125; n 生成字符串个数</div><div class="line">* @return &#123;string&#125; str 反转后的字符串</div><div class="line">*/</div><div class="line">function randomString3(n)&#123;</div><div class="line">let str = &apos;&apos;;</div><div class="line"></div><div class="line">function randomChar()&#123;</div><div class="line">let l = Math.floor(Math.random() * 62);</div><div class="line">if(l &lt; 10) return l; // 数字部分 0-9</div><div class="line">if(l &lt; 36) return String.fromCharCode(l + 55); // 大写字母</div><div class="line"></div><div class="line">return String.fromCharCode(l + 61); // 小写字母</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(str.length &lt; n) str += randomChar();</div><div class="line"></div><div class="line">return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以参考对于的<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="external">ASCII码表</a>。<br>测试：randomString1(3) // ‘1sd’</p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="方法一（ES6的Set数据结构）"><a href="#方法一（ES6的Set数据结构）" class="headerlink" title="方法一（ES6的Set数据结构）"></a>方法一（ES6的Set数据结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique1(ary)&#123;</div><div class="line">return [...new Set(ary)];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法二（对象的key唯一性）"><a href="#方法二（对象的key唯一性）" class="headerlink" title="方法二（对象的key唯一性）"></a>方法二（对象的key唯一性）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique2(ary)&#123;</div><div class="line">let obj = &#123;&#125;,</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(!obj[ary[i]])&#123;</div><div class="line">obj[ary[i]] = true; // 如果不存在</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">return Object.keys(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串。<br>会把数字1和字符串’1’，会被视为同一个值。</p><h2 id="方法三（临时数组判断插入）"><a href="#方法三（临时数组判断插入）" class="headerlink" title="方法三（临时数组判断插入）"></a>方法三（临时数组判断插入）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique3(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">// tem.indexOf() === -1 同理</div><div class="line">!tem.includes(ary[i]) ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法四（判断首次出现的位置）"><a href="#方法四（判断首次出现的位置）" class="headerlink" title="方法四（判断首次出现的位置）"></a>方法四（判断首次出现的位置）</h2><p>如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique4(ary)&#123;</div><div class="line">let tem = [ary[0]],</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">for(let i = 1; i &lt; len; i++ )&#123;</div><div class="line">// 核心，首次的索引出现是否为当前的索引</div><div class="line">if(ary.indexOf(ary[i]) === i) tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="方法五（排序后逐个比较插入）"><a href="#方法五（排序后逐个比较插入）" class="headerlink" title="方法五（排序后逐个比较插入）"></a>方法五（排序后逐个比较插入）</h2><p>给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; array 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique5(array)&#123;</div><div class="line">let ary = array.slice();</div><div class="line">ary.sort();</div><div class="line">let tem = [ary[0]];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">ary[i] !== tem[tem.length - 1] ? tem.push(ary[i]) : &apos;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PS：返回的数组顺序发生了改变。</p><h2 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h2><p>获取没有重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 数组去重</div><div class="line">* @param &#123;array&#125; ary 需要去重的数组</div><div class="line">* @return &#123;array&#125; 去重后的数组</div><div class="line">*/</div><div class="line">function unique6(ary)&#123;</div><div class="line">let tem = [];</div><div class="line">for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</div><div class="line">for(let j = i + 1; j &lt; len; j++)&#123;</div><div class="line">if(ary[i] === ary[j]) j = ++i;</div><div class="line">&#125;</div><div class="line">tem.push(ary[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：unique1([1, 2, 3, 2]) // [1, 2, 3]</p><h1 id="出现次数最多的字符"><a href="#出现次数最多的字符" class="headerlink" title="出现次数最多的字符"></a>出现次数最多的字符</h1><h2 id="方法一（对象key的唯一性进行累加）"><a href="#方法一（对象key的唯一性进行累加）" class="headerlink" title="方法一（对象key的唯一性进行累加）"></a>方法一（对象key的唯一性进行累加）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function maxNum1(str)&#123;</div><div class="line">if(typeof(str) !== &apos;string&apos;) str = str.toString();</div><div class="line">let obj = &#123;&#125;,</div><div class="line">maxChar = []; // 使用数组保存出现最多次的某些字符</div><div class="line">str.split(&apos;&apos;).forEach( (val) =&gt; &#123;</div><div class="line">if(!obj[val])&#123;</div><div class="line">let demo = obj[val] = 1;</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line">obj[val]++;</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">let maxCount =  Math.max.apply(null, Object.values(obj))</div><div class="line"></div><div class="line">// forEach方法总是返回 undefined 且 没有办法中止或者跳出 forEach 循环。</div><div class="line">Object.entries(obj).forEach( item =&gt; &#123;</div><div class="line">if(item[1] == maxCount)&#123;</div><div class="line">maxChar.push(item[0])</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return maxChar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：maxNum1(‘11223333’) // ‘3’</p><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>实现方法：Array.prototype.flatten(depth)，参数depth表示需要扁平化的层数，返回一个新的数组。 </p><h2 id="方法一（递归遍历数组拼接）"><a href="#方法一（递归遍历数组拼接）" class="headerlink" title="方法一（递归遍历数组拼接）"></a>方法一（递归遍历数组拼接）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function flatten1(ary)&#123;</div><div class="line">let tem = [],</div><div class="line">i = 0,</div><div class="line">len = ary.length;</div><div class="line"></div><div class="line">while(i &lt; len)&#123;</div><div class="line">if(Array.isArray(ary[i]))&#123;</div><div class="line">// 递归进行上面步骤</div><div class="line">// [].concat(...ary)，它的参数可以为数组或值，作用为将数组或值连接成新数组。</div><div class="line">tem = tem.concat(flatten1(ary[i]))</div><div class="line">&#125;else&#123;</div><div class="line">tem.push(ary[i]);</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法二（reduce结合concat）"><a href="#方法二（reduce结合concat）" class="headerlink" title="方法二（reduce结合concat）"></a>方法二（reduce结合concat）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.reduce((pre, cur) =&gt; &#123;</div><div class="line">return pre.concat(Array.isArray(cur) ? flatten2(cur) : cur)</div><div class="line">&#125;, [])</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：可以处理多层数组。</p><h2 id="方法三（转化为字符串）"><a href="#方法三（转化为字符串）" class="headerlink" title="方法三（转化为字符串）"></a>方法三（转化为字符串）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function flatten2(ary)&#123;</div><div class="line"></div><div class="line">return ary.toString().split(&apos;,&apos;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：返回的数组项将为字符串。</p><h2 id="方法四（解构数组）"><a href="#方法四（解构数组）" class="headerlink" title="方法四（解构数组）"></a>方法四（解构数组）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function flatten4(ary)&#123;</div><div class="line"></div><div class="line">let tem = []</div><div class="line">ary.forEach(item =&gt; &#123;</div><div class="line">if(Array.isArray(item))&#123;</div><div class="line">tem = tem.concat(...item);</div><div class="line">&#125;else&#123;</div><div class="line">tem = tem.concat(item);</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">return tem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：只能处理2维数组。<br>测试：getMaxProfit1([1, 2, 3, [4, 5, 6]]) // [1, 2, 3, 4, 5, 6]</p><h1 id="数组中最大差值"><a href="#数组中最大差值" class="headerlink" title="数组中最大差值"></a>数组中最大差值</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getMaxProfit1(ary)&#123;</div><div class="line">return Math.max.apply(null, ary) - Math.min.apply(null, ary);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：getMaxProfit1([1, 2, 3, 4]) // 3 </p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>这里我们只实现通项公式</p><h2 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fib1(n)&#123;</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return fib1(n - 1) + fib1(n - 2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(2^n)，空间复杂度为O(n)</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let tem = [1, 1];</div><div class="line">if(n === 1 || n === 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 数组索引从0开始，数列索引从1开始</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">tem[i] = tem[i-1] + tem[i-2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return tem[n-1];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(n)</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fib2(n)&#123;</div><div class="line">let prev = 1, </div><div class="line">next = 1,</div><div class="line">res;</div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">res = prev + next;  </div><div class="line">prev = next; </div><div class="line">next = res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：时间复杂度为O(n)，空间复杂度为O(1)<br>测试：fib2(3) // 2 </p><h1 id="判断是否为质数（prime-number）素数"><a href="#判断是否为质数（prime-number）素数" class="headerlink" title="判断是否为质数（prime number）素数"></a>判断是否为质数（prime number）素数</h1><p>质数：只能被1和自己整除且大于1的数。<br>合数：数大于1且因数多余2个（大于1的数质数的补集）。</p><h2 id="方法一（循环）"><a href="#方法一（循环）" class="headerlink" title="方法一（循环）"></a>方法一（循环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">if(n &lt; 2) return false;</div><div class="line">if(n === 2) return true; // 最小的质数</div><div class="line"></div><div class="line">for(let i = 2; i &lt; n; i++)&#123;</div><div class="line">if(n % i === 0)&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：isPrimeNumber1(2) // true</p><h2 id="方法二（正则）"><a href="#方法二（正则）" class="headerlink" title="方法二（正则）"></a>方法二（正则）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function isPrimeNumber1(n)&#123;</div><div class="line">  return n&lt;2?false:!/^(11+?)\1+$/.test(Array(n+1).join(&apos;1&apos;))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS：该方法很巧妙，于2018-04-25在掘金上发现。<br><a href="https://juejin.im/post/5adeb462f265da0b9c104358" target="_blank" rel="external">方法详解</a></p><h1 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function greatestCommonDivisor1(a, b)&#123;</div><div class="line">if(a &lt; 0 || b &lt; 0) throw new Error(&apos;参数只能为正整数&apos;);</div><div class="line">if(a &lt; 2 || b &lt; 2) return 1;</div><div class="line">let min = a,</div><div class="line">max = b,</div><div class="line">arymin = [];</div><div class="line"></div><div class="line">if(a &gt; b) &#123;</div><div class="line">min = b;</div><div class="line">max = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(let i = 1; i &lt;= min; i++)&#123;</div><div class="line">if(min % i === 0)&#123;</div><div class="line">arymin.push(i);</div><div class="line">console.log(1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">arymin.reverse();</div><div class="line"></div><div class="line">for(let j = 0, len = arymin.length; j &lt; len; j++)&#123;</div><div class="line">if(max % arymin[j] === 0)&#123;</div><div class="line">return arymin[j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：greatestCommonDivisor1(5, 10) // 5</p><h1 id="金额转大写"><a href="#金额转大写" class="headerlink" title="金额转大写"></a>金额转大写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function money2Chinese(num) &#123;</div><div class="line">  if(typeof num) throw new Error(&apos;参数为数字&apos;)</div><div class="line">  let strOutput = &quot;&quot;</div><div class="line">  let strUnit = &apos;仟佰拾亿仟佰拾万仟佰拾元角分&apos;</div><div class="line">  num += &quot;00&quot;</div><div class="line">  const intPos = num.indexOf(&apos;.&apos;)</div><div class="line">  if (intPos &gt;= 0) &#123;</div><div class="line">    num = num.substring(0, intPos) + num.substr(intPos + 1, 2)</div><div class="line">  &#125;</div><div class="line">  strUnit = strUnit.substr(strUnit.length - num.length)</div><div class="line">  for (let i = 0; i &lt; num.length; i++) &#123;</div><div class="line">    strOutput += &apos;零壹贰叁肆伍陆柒捌玖&apos;.substr(num.substr(i, 1), 1) + strUnit.substr(i, 1)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  return strOutput.replace(/零角零分$/, &apos;整&apos;).replace(/零[仟佰拾]/g, &apos;零&apos;).replace(/零&#123;2,&#125;/g, &apos;零&apos;).replace(/零([亿|万])/g, &apos;$1&apos;).replace(/零+元/, &apos;元&apos;).replace(/亿零&#123;0,3&#125;万/, &apos;亿&apos;).replace(/^元/, &quot;零元&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：money2Chinese(1234) // 壹仟贰佰叁拾肆元整</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断文本是否为回文&quot;&gt;&lt;a href=&quot;#判断文本是否为回文&quot; class=&quot;headerlink&quot; title=&quot;判断文本是否为回文&quot;&gt;&lt;/a&gt;判断文本是否为回文&lt;/h1&gt;&lt;p&gt;定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://fanerge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我所了解的CSS包含块</title>
    <link href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://fanerge.github.io/2018/一次详细的包含块学习.html</id>
    <published>2018-03-29T11:53:04.000Z</published>
    <updated>2018-05-27T03:00:44.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指出错误观念"><a href="#指出错误观念" class="headerlink" title="指出错误观念"></a>指出错误观念</h1><p>许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！<br>一个元素的尺寸和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。<br>下面我们看看盒模型：<br>当浏览器展示一个文档的时候，对于每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域：</p><ol><li>内容区</li><li>内边距区</li><li>边框区</li><li>外边距区<br><img src="http://p677fntmi.bkt.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></li></ol><h1 id="什么是包含块？"><a href="#什么是包含块？" class="headerlink" title="什么是包含块？"></a>什么是包含块？</h1><p>包含块有分为根元素包含块和其他元素的包含块。</p><h2 id="根元素包含块"><a href="#根元素包含块" class="headerlink" title="根元素包含块"></a>根元素包含块</h2><p>根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。<br>可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。<br>对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。</p><h2 id="其他元素的包含块"><a href="#其他元素的包含块" class="headerlink" title="其他元素的包含块"></a>其他元素的包含块</h2><p>大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样，下面就来学习如何确定这些元素的包含块。</p><h1 id="如何确定元素的包含块？"><a href="#如何确定元素的包含块？" class="headerlink" title="如何确定元素的包含块？"></a>如何确定元素的包含块？</h1><p>确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景：</p><ol><li>如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）或格式化上下文<a href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#BFC">BFC</a>(比如说 a table container, flex container, grid container, or the block container itself)的<span style="color: red">内容区的边缘</span>组成的。</li><li>如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的<span style="color: red">内边距区的边缘</span>组成的。</li><li>如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in  the case of paged media) 组成的。</li><li>如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的<span style="color: red">内边距区的边缘</span>组成的：<br>A transform or perspective value other than none<br>A will-change value of transform or perspective<br>A filter value other than none or a will-change value of filter (only works on Firefox).</li></ol><h1 id="元素包含块的作用？"><a href="#元素包含块的作用？" class="headerlink" title="元素包含块的作用？"></a>元素包含块的作用？</h1><p>元素的尺寸和位置经常受其包含块的影响。对于一个绝对定位的元素来说（他的 position 属性被设定为 absolute 或 fixed），如果它的 width, height, padding, margin, 和 offset 这些属性的值是一个比例值（如百分比等）的话，那这些值的计算值就是由它的包含块计算而来的。<br>简单来说，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</p><ol><li>height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。</li><li>width, left, right, padding, margin, text-indent(2018-05-27修改)这些属性由包含块的 width 属性的值来计算它的百分值。</li></ol><h1 id="下面看些例子"><a href="#下面看些例子" class="headerlink" title="下面看些例子"></a>下面看些例子</h1><p>下面示例公用HTML代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;section&gt;</div><div class="line">    &lt;p&gt;This is a paragraph!&lt;/p&gt;</div><div class="line">  &lt;/section&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: block;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;   /* == 400px * .5 = 200px */</div><div class="line">  height: 25%;  /* == 160px * .25 = 40px */</div><div class="line">  margin: 5%;   /* == 400px * .05 = 20px */</div><div class="line">  padding: 5%;  /* == 400px * .05 = 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk1.png" alt=""></p><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  display: inline;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  width: 50%;     /* == half the body&apos;s width */</div><div class="line">  height: 200px;  /* Note: a percentage would be 0 */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk2.png" alt=""></p><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  transform: rotate(0deg);</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 80px;</div><div class="line">  top: 30px;</div><div class="line">  width: 50%;   /* == 200px */</div><div class="line">  height: 25%;  /* == 40px */</div><div class="line">  margin: 5%;   /* == 20px */</div><div class="line">  padding: 5%;  /* == 20px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk3.png" alt=""></p><h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  position: absolute;</div><div class="line">  left: 30px;</div><div class="line">  top: 30px;</div><div class="line">  width: 400px;</div><div class="line">  height: 160px;</div><div class="line">  padding: 30px 20px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: absolute;</div><div class="line">  width: 50%;   /* == (400px + 20px + 20px) * .5 = 220px */</div><div class="line">  height: 25%;  /* == (160px + 30px + 30px) * .25 = 55px */</div><div class="line">  margin: 5%;   /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  padding: 5%;  /* == (400px + 20px + 20px) * .05 = 22px */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk4.png" alt=""></p><h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: beige;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section &#123;</div><div class="line">  width: 300px;</div><div class="line">  height: 300px;</div><div class="line">  margin: 30px;</div><div class="line">  padding: 15px;</div><div class="line">  background: lightgray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p &#123;</div><div class="line">  position: fixed;</div><div class="line">  width: 50%;   /* == (50vw - (width of vertical scrollbar)) */</div><div class="line">  height: 50%;  /* == (50vh - (height of horizontal scrollbar)) */</div><div class="line">  margin: 5%;   /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  padding: 5%;  /* == (5vw - (width of vertical scrollbar)) */</div><div class="line">  background: cyan;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk5.png" alt=""></p><p>如果本文对你有帮助，记得给我的博客项目<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="external">star</a>(⊙﹏⊙)，<a href="https://fanerge.github.io">顺便找找成都氛围好的前端团队，也许我就是你们要找的の</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指出错误观念&quot;&gt;&lt;a href=&quot;#指出错误观念&quot; class=&quot;headerlink&quot; title=&quot;指出错误观念&quot;&gt;&lt;/a&gt;指出错误观念&lt;/h1&gt;&lt;p&gt;许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！&lt;br&gt;一个元素的尺
      
    
    </summary>
    
      <category term="css" scheme="https://fanerge.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://fanerge.github.io/tags/css/"/>
    
  </entry>
  
</feed>
