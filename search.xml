<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS开发者大会5th</title>
    <url>/2019/CSS%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A5th.html</url>
    <content><![CDATA[<p>周末看了CSS2019开发者大会的视频，受益匪浅。本文记录大部分视频内容以及自己的理解，如有理解不当的地方，还望指出。</p>
<h3 id="为什么块格式自动-margin-不垂直居中元素？"><a href="#为什么块格式自动-margin-不垂直居中元素？" class="headerlink" title="为什么块格式自动 margin 不垂直居中元素？"></a>为什么块格式自动 margin 不垂直居中元素？</h3><p>如果 margin-left 和 margin-right 都设置为 auto，则他们两个值相等，所以水平能够居中。<br>如果 margin-top 和 margin-bottom 都设置为 auto，则他们实际等于0，所以就不能垂直居中。<br><a href="https://www.chenhuijing.com/slides/53-cssconfcn-2019/#/18" target="_blank" rel="noopener">CSS5th分享原文</a></p>
<h3 id="移动端设置-viewport-的两种写法"><a href="#移动端设置-viewport-的两种写法" class="headerlink" title="移动端设置 viewport 的两种写法"></a>移动端设置 viewport 的两种写法</h3><p>meta 标签<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS(暂不可用)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@viewport &#123;</span><br><span class="line">    width: extend-to-zoom 100%;</span><br><span class="line">    height: auto;</span><br><span class="line">    zoon: 1.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="滚动捕捉（实验性）"><a href="#滚动捕捉（实验性）" class="headerlink" title="滚动捕捉（实验性）"></a>滚动捕捉（实验性）</h3><p>scroll-snap-type // 定义在滚动容器中的一个snap点如何被执行。<br>scroll-snap-align<br>scroll-margin // 定义滚动捕捉区域的开始，该区域用于将此框捕捉到snapport。<br>scroll-padding</p>
<h3 id="自定义属性（非CSS变量）"><a href="#自定义属性（非CSS变量）" class="headerlink" title="自定义属性（非CSS变量）"></a>自定义属性（非CSS变量）</h3><p>声明属性(–开头)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 任何元素都可以使用</span><br><span class="line">:root &#123;</span><br><span class="line">    --gutter: 1em;</span><br><span class="line">&#125;</span><br><span class="line">// 局部可使用</span><br><span class="line">#side div &#123;</span><br><span class="line">    --gutter: 1em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用($开头)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    padding: $gutter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CSS-Houdini（Js-in-CSS）"><a href="#CSS-Houdini（Js-in-CSS）" class="headerlink" title="CSS Houdini（Js in CSS）"></a>CSS Houdini（Js in CSS）</h3><p>CSS Houdini 是各大厂商的工程师所组成的工作小组，志在建立一系列的 API，让开发者能够介入浏览器的 CSS engine 操作，帶给开发者更多的解决方案。</p>
<h3 id="以内容为主的尺寸计算方式"><a href="#以内容为主的尺寸计算方式" class="headerlink" title="以内容为主的尺寸计算方式"></a>以内容为主的尺寸计算方式</h3><p>外部尺寸： 根据元素的上下文确定大小，而不考虑其内容。<br>如：width: 400px;<br>内部尺寸： 根据元素的内容确定大小，而不考虑其上下文。<br>如：widht: min-content;<br><a href="https://www.w3.org/TR/css-sizing-3/#intrinsic-sizes" target="_blank" rel="noopener">w3c#intrinsic-sizes</a><br>利用@supports，本地CSS功能检测<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.selector &#123;</span><br><span class="line">  /* Styles that are supported in old browsers */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@supports (property:value) &#123;</span><br><span class="line">  .selector &#123;</span><br><span class="line">    /* Styles for browsers that support the specified property */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="混合模式和滤镜"><a href="#混合模式和滤镜" class="headerlink" title="混合模式和滤镜"></a>混合模式和滤镜</h3><p>mix-blend-mode // 描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。<br>background-blend-mode // 定义该元素的背景图片和背景色如何混合。<br>isolation // 定义该元素是否必须创建一个新的stacking context。<br>filter // 将滤镜效果应用于元素。<br>isolation 属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。</p>
<h3 id="镂空"><a href="#镂空" class="headerlink" title="镂空"></a>镂空</h3><p>矩形镂空<br>outline: 999px solid rgba(0, 0, 0, .5);<br>椭圆镂空<br>box-shadow: 0 0 0 9999px rgba(0, 0, 0, .5);<br>不规则镂空<br>mask-composite</p>
<h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><p>允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。<br>具体有下列属性<br>mask-image<br>mask-mode<br>mask-repeat<br>mask-position<br>mask-clip<br>mask-origin<br>mask-size<br>mask-type<br>mask-composite<br><a href="https://www.zhangxinxu.com/wordpress/2017/11/css-css3-mask-masks/" target="_blank" rel="noopener">CSS遮罩CSS3 mask/masks详细介绍</a></p>
<h3 id="transition-amp-amp-animation"><a href="#transition-amp-amp-animation" class="headerlink" title="transition &amp;&amp; animation"></a>transition &amp;&amp; animation</h3><p>要创建一个 transition,浏览器需要看到样式的变化</p>
<ol>
<li><p>使用 requestAnimationFrame 来让浏览器看到样式变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button.onclick = () =&gt; &#123;</span><br><span class="line">  // Make the panel</span><br><span class="line">  const panel = document.createElement(&apos;div&apos;);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Stretch it in</span><br><span class="line">  panel.style.transform = &apos;scale(0)&apos;;</span><br><span class="line">  panel.style.transition = &apos;transform .5s&apos;;</span><br><span class="line">  requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">    requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      panel.style.transform = &apos;scale(1)&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 getComputedStyle(elem).property 来让浏览器看到样式变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button.onclick = () =&gt; &#123;</span><br><span class="line">  // Make the panel</span><br><span class="line">  const panel = document.createElement(&apos;div&apos;);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Stretch it in</span><br><span class="line">  panel.style.transform = &apos;scale(0)&apos;;</span><br><span class="line">  getComputedStyle(panel).transform;</span><br><span class="line">  panel.style.transition = &apos;transform .5s&apos;;</span><br><span class="line">  panel.style.transform = &apos;scale(1)&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然 getComputedStyle(elem) 不会更新样式，但是 getComputedStyle(elem).property 会更新样式。<br>使用 getComputedStyle 的代价很高<br>transitionend<br>transitionend 事件会在 CSS transition 结束后触发。<br>但下列情况不会出发<br>当 transition 完成前移除 transition 时，比如移除css的transition-property 属性，事件将不会被触发。<br>当 transition 完成前设置 display 为”none”，事件同样不会被触发。<br>当 transition 完成前元素被移除不会触发。<br>为了防止以上 transition 被取消<br>setTimeout 将其添加到异步任务队列中。<br>transitioncancel 事件。<br>还有 transitionrun 事件（需确保一开始是有 transition 的）。</p>
<p>animation<br>animation-timing-function只在关键帧之间 适用<br>WEB ANIMATIONS<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.animate(</span><br><span class="line">  &#123;</span><br><span class="line">    transform: [&apos;scale(1)&apos;, &apos;scale(2)&apos;],</span><br><span class="line">    opacity: [1, 0],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    duration: 3000,</span><br><span class="line">    iterations: Infinity,</span><br><span class="line">    easing: &apos;cubic-bezier(0.7, 0.0, 1.0, 1.0)&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>特性检查（html.animate）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (&apos;animate&apos; in elem) &#123;</span><br><span class="line">  // ... Animate away...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="noopener">polyfill (web-animations-js)</a><br><a href="https://hacks.mozilla.org/2016/08/animating-like-you-just-dont-care-with-element-animate/" target="_blank" rel="noopener">Animating like you just don’t care with Element.animate</a><br>尽量只对 transform 和 opacity 使用动画。<br>根据用户的偏好，禁用复杂动画，媒体查询 prefers-reduced-motion 可偏向于用户。<br>移动端一般动画和过渡时间把握在300ms，根据屏幕大小适当调整。</p>
<h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><p>text-fill-color<br>设置字体的填充颜色，如果未设置此属性，则字体颜色为 color 属性的值。<br>text-fill-color 与 color 的区别<br>text-fill-color 只设置字体的颜色，color 设置所有的前景色。相当于 text-fill-color 为 color 的子集。<br>background-clip<br>置元素的背景（背景图片或颜色）是否延伸的范围（border-box/padding-box/content-box/text等）。<br>box-decoration-break<br>指定一个元素的片段时、多行、多列或页面断应该呈现形式（ 默认slice，clone独立呈现）。<br>clip-path<br>该属性可以创建一个只有元素的部分区域可以显示的剪切区域（circle、ellipse、polygon等）。<br>object-fit<br>指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。<br>可替换元素有哪些？iframe、video、embed、img等<br>writing-mode<br>设置文本行如何被布置（水平或垂直），以及其中块前进方向。<br>shape-outside<br>shape-outside的CSS 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行排列。<br>CSS Regions &amp;&amp; CSS Exclusions</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>linux备忘录</title>
    <url>/2019/linux%E5%A4%87%E5%BF%98%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="public-key"><a href="#public-key" class="headerlink" title="public key"></a>public key</h2><p>也就是你本地的 id_rsa.pub 文件，将文件内容添加到远程下列目录中<br>/root/.ssh/authorized_keys</p>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令。<br>yum [options] [command] [package …]<br>options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。<br>command：要进行的操作。<br>package操作的对象。<br>1.列出所有可更新的软件清单命令：yum check-update<br>2.更新所有软件命令：yum update<br>3.仅安装指定的软件命令：yum install &lt;package_name&gt;<br>4.仅更新指定的软件命令：yum update &lt;package_name&gt;<br>5.列出所有可安裝的软件清单命令：yum list<br>6.删除软件包命令：yum remove &lt;package_name&gt;<br>7.查找软件包 命令：yum search <keyword><br>8.清除缓存命令:<br>yum clean packages: 清除缓存目录下的软件包<br>yum clean headers: 清除缓存目录下的 headers<br>yum clean oldheaders: 清除缓存目录下旧的 headers<br>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</keyword></p>
<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>list open files<br>是一个列出当前系统打开文件的工具</p>
<h3 id="处理端口占用"><a href="#处理端口占用" class="headerlink" title="处理端口占用"></a>处理端口占用</h3><p>lsof -i tcp:port // 返回pid<br>kill pid // 杀死进程</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>显示目录<br>ls 目录名称<br>ls 无参数时，显示当前目录下的文件<br>ls / 显示根目录下的文件</p>
<h3 id="显示一个文件的属性以及文件所属的用户和组"><a href="#显示一个文件的属性以及文件所属的用户和组" class="headerlink" title="显示一个文件的属性以及文件所属的用户和组"></a>显示一个文件的属性以及文件所属的用户和组</h3><p>ls -l<br>前0～9位分别代表<br>0代表文件类型，d为目录，-为文件，l为链接文档等<br>1～3代表属主权限user（rwx分别代表read、write、execute，没有该权限则-表示）<br>4～6代表属组权限group<br>7～9代表其他用户权限others</p>
<h3 id="查看全部文件"><a href="#查看全部文件" class="headerlink" title="查看全部文件"></a>查看全部文件</h3><p>ls -a</p>
<h3 id="仅列出目录本身，而不是列出目录内的文件数据-常用"><a href="#仅列出目录本身，而不是列出目录内的文件数据-常用" class="headerlink" title="仅列出目录本身，而不是列出目录内的文件数据(常用)"></a>仅列出目录本身，而不是列出目录内的文件数据(常用)</h3><p>ls -d</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>Change Directory<br>切换目录<br>cd 相对路径或绝对路径</p>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>Print Working Directory<br>显示目前所在的目录</p>
<h3 id="pwd-P"><a href="#pwd-P" class="headerlink" title="pwd [-P]"></a>pwd [-P]</h3><p>-P ：显示出确实的路径，而非使用连结 (link) 路径。</p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>make directory<br>创建新目录</p>
<h3 id="mkdir-mp-目录名称"><a href="#mkdir-mp-目录名称" class="headerlink" title="mkdir [-mp] 目录名称"></a>mkdir [-mp] 目录名称</h3><p>-m ：配置文件的权限<br>mkdir -m 711 test2<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！<br>mkdir -p test1/test2</p>
<h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><p>删除空的目录<br>-p ：连同上一级『空的』目录也一起删除</p>
<h2 id="cp-adfilprsu-来源档-目标档"><a href="#cp-adfilprsu-来源档-目标档" class="headerlink" title="cp [-adfilprsu] 来源档 目标档"></a>cp [-adfilprsu] 来源档 目标档</h2><p>拷贝文件和目录</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>rm [-fir] 文件或目录<br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！</p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>移动文件与目录，或修改名称<br>mv [-fiu] source destination<br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</p>
<h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>chgrp [-R] 属组名 文件名<br>更改文件属组，-R代表递归操作目录中的所有文件和目录</p>
<h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>chown [–R] 属主名 文件名<br>chown [-R] 属主名：属组名 文件名<br>更改文件属主，也可以同时更改文件属组</p>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>更改文件9个属性<br>Linux文件属性有两种设置方法，一种是数字，一种是符号。<br>chmod [-R] xyz 文件或目录 // xyz分别代表权限值，x为user，y为grounp，z为others，r(4)w(2)x(1)<br>chmod u=rwx,g=rx,o=r  文件或目录<br><a href="https://www.runoob.com/linux/linux-file-attr-permission.html" target="_blank" rel="noopener">chmod</a></p>
<h1 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h1><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>由第一行开始显示文件内容<br>cat [-AbEnTv]</p>
<h2 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h2><p>文件内容从最后一行开始显示，tac与cat命令刚好相反。<br>tac 文件路径</p>
<h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>查看文件显示行号<br>nl [-bnw] 文件路径</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>一页一页翻动查看文件<br>more 文件路径</p>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>一页一页翻动查看文件（可以往前翻）<br>less 文件路径<br>less运行时可以进行下列操作<br>/字串     ：向下搜寻『字串』的功能；<br>?字串     ：向上搜寻『字串』的功能；<br>n         ：重复前一个搜寻 (与 / 或 ? 有关！)</p>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>取出文件前面几行<br>head [-n number] 文件<br>显示前number行</p>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>取出文件后面几行<br>tail [-n number] 文件<br>-n ：后面接数字，代表显示几行的意思<br>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测<br>看服务端日志用的比较多： tail -nf 100 文件</p>
<h1 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h1><h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>添加新的用户账号<br>useradd 选项 用户名<br>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。<br>如：useradd -d /usr/sam -m sam</p>
<h2 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h2><p>删除帐号，将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。<br>userdel 选项 用户名<br>-r 它的作用是把用户的主目录一起删除。</p>
<h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。<br>usermod 选项 用户名</p>
<h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>指定和修改用户口令<br>passwd 选项 用户名<br>-l 锁定口令，即禁用账号。<br>-u 口令解锁。<br>-d 使账号无口令。<br>-f 强迫用户下次登录时修改口令。</p>
<h2 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h2><p>增加一个新的用户组<br>groupadd 选项 用户组<br>如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。<br>-g GID 指定新用户组的组标识号（GID）。<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</p>
<h2 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h2><p>删除一个已有的用户组<br>groupdel 用户组</p>
<h2 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h2><p>修改用户组的属性<br>roupmod 选项 用户组<br>-g GID 为用户组指定新的组标识号。<br>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br>-n 新用户组 将用户组的名字改为新名字。</p>
<h2 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h2><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。<br>newgrp groupName</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。<br>/etc/group文件记录的是用户所属的用户组。<br>/etc/shadow<br>主目录：一般是用户登录后的目录，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。<br><a href="https://www.runoob.com/linux/linux-user-manage.html" target="_blank" rel="noopener">添加批量用户</a></p>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>检查文件系统的磁盘空间占用情况。<br>df [-ahikHTm] 目录或文件名<br>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；<br>-k ：以 KBytes 的容量显示各文件系统；<br>-m ：以 MBytes 的容量显示各文件系统；<br>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>-H ：以 M=1000K 取代 M=1024K 的进位方式；<br>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；<br>-i ：不用硬盘容量，而以 inode 的数量来显示</p>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>对文件和目录磁盘使用的空间的查看。<br>du [-ahskm] 文件或目录名称<br>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。<br>-h ：以人们较易读的容量格式 (G/M) 显示；<br>-s ：列出总量而已，而不列出每个各别的目录占用容量；<br>-S ：不包括子目录下的总计，与 -s 有点差别。<br>-k ：以 KBytes 列出容量显示；<br>-m ：以 MBytes 列出容量显示；</p>
<h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><p>Linux 的磁盘分区表操作工具<br>fdisk [-l] 装置名称<br>-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p>
<h2 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h2><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。<br>mkfs [-t 文件系统格式] 装置文件名</p>
<h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>file system check<br>用来检查和维护不一致的文件系统<br>fsck [-t 文件系统] [-ACay] 装置名称</p>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>磁盘挂载与卸除<br>mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</p>
<blockquote>
<p>参考文档<br><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="noopener">linux启动流程</a><br><a href="https://www.runoob.com/linux/linux-system-boot.html" target="_blank" rel="noopener">runoob/linux</a></p>
</blockquote>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试-手撕代码篇</title>
    <url>/2019/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前端面试有一个非常重要的环节，也是面试者最担心的一个环节。对“手撕代码”的考察需要面试者平时总结和积累（临时抱佛脚是不好使的），在这里笔者就自己如何攻破“手撕代码”环节总结了一些经验，希望能帮助你挑战高薪，迎娶白富美😄😄😄。</p>
<ol>
<li>使用IDE时尽量避免直接使用提示API，亲自输入（孰能生巧，当然感觉没问题的API就不用浪费时间了）</li>
<li>遇到不熟悉的API，一定要查文档研究清楚（参数个数和具体意义以及返回值）</li>
<li>如在模拟某个原生API时，先写出原生API并分析出形参和返回值</li>
<li>感觉功能完成时，需要在考虑一下边界条件（参数非比填情况、undefined、null）</li>
<li>平常有空时多刷刷一二线大厂的面试题（扩充自己的知识广度）</li>
<li>多关照一些前端动态（比如说curry、compose你没听过，这就有点尴尬）</li>
</ol>
<h1 id="常见的“手撕代码”，都是高频题哦"><a href="#常见的“手撕代码”，都是高频题哦" class="headerlink" title="常见的“手撕代码”，都是高频题哦"></a>常见的“手撕代码”，都是高频题哦</h1><h2 id="curry（柯里化）"><a href="#curry（柯里化）" class="headerlink" title="curry（柯里化）"></a>curry（柯里化）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry(fn: any) &#123;</span><br><span class="line">  return function judgeCurry(...args: any) &#123;</span><br><span class="line">      return fn.length &gt; args.length ? </span><br><span class="line">          (...args1: any) =&gt; judgeCurry(...args,...args1):</span><br><span class="line">          fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="compose（函数组合）"><a href="#compose（函数组合）" class="headerlink" title="compose（函数组合）"></a>compose（函数组合）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(...args: any[]) &#123;</span><br><span class="line">  return (subArgs: any) =&gt; &#123;</span><br><span class="line">    // for(let i = args.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    //   res = args[i](res);</span><br><span class="line">    // &#125;</span><br><span class="line">    return args.reverse().reduce((acc, func,index) =&gt; &#123;</span><br><span class="line">      return func(acc);</span><br><span class="line">    &#125;, subArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pipe（函数管道）"><a href="#pipe（函数管道）" class="headerlink" title="pipe（函数管道）"></a>pipe（函数管道）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function pipe(...args: any[]) &#123;</span><br><span class="line">  return (subArgs: any) =&gt; &#123;</span><br><span class="line">    // for(let i = args.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    //   res = args[i](res);</span><br><span class="line">    // &#125;</span><br><span class="line">    return args.reduce((acc, func,index) =&gt; &#123;</span><br><span class="line">      return func(acc);</span><br><span class="line">    &#125;, subArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="throttle（函数节流）"><a href="#throttle（函数节流）" class="headerlink" title="throttle（函数节流）"></a>throttle（函数节流）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn: any, wait: number)&#123;</span><br><span class="line">  let last: any;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let now: any = Date.now();</span><br><span class="line">    // 初次执行</span><br><span class="line">    if (!last) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last = now;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 以后触发，需要判断是否到延迟</span><br><span class="line">    if(now - last &gt;= wait) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="debounce（函数防抖）"><a href="#debounce（函数防抖）" class="headerlink" title="debounce（函数防抖）"></a>debounce（函数防抖）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func: any, delay: number) &#123;              </span><br><span class="line">    // 初次触发定时器为null，后面产生一份定时器并记下定时器id</span><br><span class="line">    let timer: any = null; </span><br><span class="line">    // 闭包使定时器id逃逸   </span><br><span class="line">    return function() &#123;                             </span><br><span class="line">        let args = arguments;  </span><br><span class="line">        // 如果已有定时器id，则需要清除，重新开始延迟执行           </span><br><span class="line">        if (timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = null;                                   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        timer = setTimeout( () =&gt; &#123; </span><br><span class="line">            func.apply(this, args); </span><br><span class="line">            // 销毁定时器id，以便下次节流函数触发                       </span><br><span class="line">            timer = null;                    </span><br><span class="line">        &#125;, delay); </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="formatMoney（千分位）"><a href="#formatMoney（千分位）" class="headerlink" title="formatMoney（千分位）"></a>formatMoney（千分位）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fmoney(num: number)&#123;</span><br><span class="line">    /* 正则实现 */</span><br><span class="line">    // 参考：https://www.cnblogs.com/lvmylife/p/8287247.html</span><br><span class="line">    let [integer, decimal] = String(num).split(&apos;.&apos;);</span><br><span class="line">    let regExp = /\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g;</span><br><span class="line">    integer = integer.replace(regExp, &apos;$&amp;,&apos;);</span><br><span class="line">    return `$&#123;integer&#125;$&#123;decimal === undefined ? &apos;&apos;: &apos;.&apos;+decimal&#125;`;</span><br><span class="line">    // 正则解释</span><br><span class="line">    // 正则表达式 \d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾</span><br><span class="line">    // 先行肯定断言(?=)会作为匹配校验，但不会出现在匹配结果字符串里面</span><br><span class="line">    // ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始</span><br><span class="line">    // $&amp; 表示与正则表达式相匹配的内容，具体的可查看 w3school的replace()方法</span><br><span class="line"></span><br><span class="line">    /* Number.prototype.toLocaleString()实现 */</span><br><span class="line">    // Number.prototype.toLocaleString()</span><br><span class="line">    // return num.toLocaleString(&apos;en&apos;);</span><br><span class="line"></span><br><span class="line">    /* Intl.NumberFormat().format(number)实现 */</span><br><span class="line">    // Intl.NumberFormat().format(number)</span><br><span class="line">    // return Intl.NumberFormat(&apos;en&apos;).format(num);</span><br><span class="line"></span><br><span class="line">    // reduce 方案</span><br><span class="line">    // let arr = String(num).split(&apos;.&apos;);</span><br><span class="line">    // let char = arr[0].split(&apos;&apos;).reverse();   </span><br><span class="line">    // let IntStr = char.reduce((acc, value, index) =&gt; &#123;</span><br><span class="line">    //     return `$&#123;index % 3 === 0 ? String(value)+&apos;,&apos; : String(value)&#125;$&#123;acc&#125;`;</span><br><span class="line">    // &#125;, &apos;&apos;).slice(0, -1);</span><br><span class="line">    // return `$&#123;IntStr&#125;$&#123;arr[1]? &apos;.&apos;+arr[1] : &apos;&apos; &#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deepClone（深拷贝）"><a href="#deepClone（深拷贝）" class="headerlink" title="deepClone（深拷贝）"></a>deepClone（深拷贝）</h2><p>说明：通过new WeakMap()来避免循环引用（拷贝引用类型时并保存其地址，后面遇到引用类型先检查是否已经保存了）<br><br>通过Reflect.ownKeys(obj)遍历出obj自身的所有可枚举和不可枚举的属性以及symbol属性<br><br>拷贝对应属性的属性描述符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function checkType(obj: any): string &#123;</span><br><span class="line"></span><br><span class="line">  const type = Object.prototype.toString.call(obj);</span><br><span class="line">  return type.slice(8, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 深拷贝（hash = new WeakMap()考虑循环引用的问题）</span><br><span class="line">export function deepClone(obj: any, hash = new WeakMap()) : any&#123;</span><br><span class="line">  if(checkType(obj) === &apos;RegExp&apos;) &#123;</span><br><span class="line">    // regExp.source 正则对象的源模式文本;</span><br><span class="line">    // regExp.flags 正则表达式对象的标志字符串;</span><br><span class="line">    // regExp.lastIndex 下次匹配开始的字符串索引位置</span><br><span class="line">    let temp =  new RegExp(obj.source, obj.flags);</span><br><span class="line">    temp.lastIndex = obj.lastIndex;</span><br><span class="line">    return temp;</span><br><span class="line">  &#125;</span><br><span class="line">  if(checkType(obj) === &apos;Date&apos;) &#123;</span><br><span class="line">      return new Date(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  // 非复杂类型(null、undefined、string、number、symbol、boolean、function)</span><br><span class="line">  if(obj === null || typeof obj !== &apos;object&apos;) &#123;</span><br><span class="line">      return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  // 还可以扩展其他类型。。。</span><br><span class="line">  // 与后面hash.set()防止循环引用</span><br><span class="line">  if(hash.has(obj)) &#123;</span><br><span class="line">      return hash.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let newObj = new obj.constructor();</span><br><span class="line">  hash.set(obj, newObj);</span><br><span class="line">  // Object.keys(obj)类型于 for in 和 obj.hasOwnProperty</span><br><span class="line">  // 是否应该拷贝自身属性（可枚举的和不可枚举的以及symbol）</span><br><span class="line">  Reflect.ownKeys(obj).forEach(function(key) &#123;</span><br><span class="line">      if(typeof obj[key] === &apos;object&apos; &amp;&amp; obj[key] !== null) &#123;</span><br><span class="line">          newObj[key] = deepClone(obj[key], hash);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          // 直接赋值</span><br><span class="line">          // newObj[key] = obj[key];</span><br><span class="line">          // 是否应该保留属性描述符</span><br><span class="line">          Object.defineProperty(newObj, key, Object.getOwnPropertyDescriptor(obj, key));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模拟instanceof"><a href="#模拟instanceof" class="headerlink" title="模拟instanceof"></a>模拟instanceof</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function instance_of(L: Object, R: any)&#123;</span><br><span class="line">  let protoChain = Object.getPrototypeOf(L);</span><br><span class="line">  const Lprototype = R.prototype;</span><br><span class="line">  // 最坏情况递归查到Object.prototype === null</span><br><span class="line">  while(protoChain) &#123;</span><br><span class="line">      // 两个对象指向同一个内存地址，则为同一个对象</span><br><span class="line">      if(protoChain === Lprototype) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      protoChain = Object.getPrototypeOf(protoChain);</span><br><span class="line">  &#125;</span><br><span class="line">  // 找到终点还没找到，那就没有了呗</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现call方法"><a href="#实现call方法" class="headerlink" title="实现call方法"></a>实现call方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myCall = function myCall() &#123;</span><br><span class="line">  let [thisArg, ...args] = Array.from(arguments);</span><br><span class="line">  if (!thisArg) &#123;</span><br><span class="line">      //context 为 null 或者是 undefined</span><br><span class="line">      thisArg = typeof window === &apos;undefined&apos; ? global : window;</span><br><span class="line">  &#125;</span><br><span class="line">  // this 的指向的是当前函数 func (func.call)</span><br><span class="line">  // 为thisArg对象添加func方法，func方法又指向myCall，所以在func中this指向thisArg</span><br><span class="line">  thisArg.func = this;</span><br><span class="line">  // 执行函数</span><br><span class="line">  let result = thisArg.func(...args);</span><br><span class="line">  // thisArg 上并没有 func 属性，因此需要移除</span><br><span class="line">  delete thisArg.func; </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现apply方法"><a href="#实现apply方法" class="headerlink" title="实现apply方法"></a>实现apply方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myApply = function myApply() &#123;</span><br><span class="line">  // 第一个参数为this对象，第二个参数为数组（与myCall唯一的区别就在第二个参数是数组）</span><br><span class="line">  let [thisArg, args] = Array.from(arguments);</span><br><span class="line">  if (!thisArg) &#123;</span><br><span class="line">      //context 为 null 或者是 undefined</span><br><span class="line">      thisArg = typeof window === &apos;undefined&apos; ? global : window;</span><br><span class="line">  &#125;</span><br><span class="line">  // this 的指向的是当前函数 func (func.call)</span><br><span class="line">  thisArg.func = this;</span><br><span class="line">  // 执行函数</span><br><span class="line">  let result = thisArg.func(...args);</span><br><span class="line">  // thisArg 上并没有 func 属性，因此需要移除</span><br><span class="line">  delete thisArg.func; </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现bind方法"><a href="#实现bind方法" class="headerlink" title="实现bind方法"></a>实现bind方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function myBind() &#123;</span><br><span class="line">  let [thisArg, ...args] = [...arguments];</span><br><span class="line">  if (!thisArg) &#123;</span><br><span class="line">      //context 为 null 或者是 undefined</span><br><span class="line">      thisArg = typeof window === &apos;undefined&apos; ? global : window;</span><br><span class="line">  &#125;</span><br><span class="line">  let that = this;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">      // 防止第二次调用 func 是，该func已经被delete了，需要重新赋值 </span><br><span class="line">      if(!thisArg.func) &#123;</span><br><span class="line">        thisArg.func = that;</span><br><span class="line">      &#125;</span><br><span class="line">      let result = thisArg.func(...args);</span><br><span class="line">      // thisArg原本没有func方法</span><br><span class="line">      delete thisArg.func;</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟Promise-all（多个Promise并行执行）"><a href="#模拟Promise-all（多个Promise并行执行）" class="headerlink" title="模拟Promise.all（多个Promise并行执行）"></a>模拟Promise.all（多个Promise并行执行）</h2><p>目前还存在参数适配的问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 = function()&#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;setTimeout(function()&#123;resolve(&apos;12&apos;)&#125;, 1000)&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">var p2 = function()&#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;setTimeout(function()&#123;resolve(2)&#125;, 2000)&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">var p3 = function()&#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;setTimeout(function()&#123;resolve(3)&#125;, 1000)&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">function promiseAll(tasks) &#123;</span><br><span class="line">  let ary = new Array(tasks.length).fill(1).map(item =&gt; &#123;return &#123;val: undefined, success: false&#125;&#125;);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    for(let i = 0; i &lt; tasks.length; i++) &#123;</span><br><span class="line">      tasks[i]().then(res =&gt; &#123;</span><br><span class="line">        ary[i].val = res;</span><br><span class="line">        ary[i].success = true;</span><br><span class="line">        if(ary.every(item =&gt; item.success === true))&#123;</span><br><span class="line">          resolve(ary.map(item =&gt; item.val))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(err =&gt; &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">promiseAll([p1, p2, p3]).then(res =&gt; console.log(res)).catch(err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="多个Promise串行执行-两种方式"><a href="#多个Promise串行执行-两种方式" class="headerlink" title="多个Promise串行执行(两种方式)"></a>多个Promise串行执行(两种方式)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parallelPromises1(tasks)&#123;</span><br><span class="line">  var result = [];</span><br><span class="line">  return tasks.reduce((accumulator,item,index)=&gt;&#123;</span><br><span class="line">    return accumulator.then(res=&gt;&#123;</span><br><span class="line">        item = typeof item === &apos;function&apos; ? item() : item;</span><br><span class="line">        return item.then(res=&gt;&#123;</span><br><span class="line">          // debugger</span><br><span class="line">              result[index] = res</span><br><span class="line">              return index == tasks.length - 1 ? result : item</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,Promise.resolve())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function parallelPromises2(tasks) &#123;</span><br><span class="line">  let ary = [];</span><br><span class="line">  for (let task of tasks) &#123;</span><br><span class="line">    let temp = await task();</span><br><span class="line">    ary.push(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>上面代码完全是笔者手敲，难免有错误，还望斧正。这种题目还有很多（实现简易版的EventEmitter、简易版模版引擎等），笔者会持续更新。如果对你有帮助，俺希望送上你的<a href="https://github.com/fanerge/WEB-repo" target="_blank" rel="noopener">github小星星</a>，在此感谢。<br><br>本文同步发布于<a href="https://fanerge.github.io/2019/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E7%AF%87.html">个人博客</a><a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" rel="noopener">掘金</a><a href="https://zhuanlan.zhihu.com/p/95165262" target="_blank" rel="noopener">知乎专栏</a><br></p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel工作原理及Babel插件开发探索</title>
    <url>/2018/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8ABabel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2.html</url>
    <content><![CDATA[<p>在掘金上看见了<a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="noopener">面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒</a>，正巧自己对Babel工作原理和Babel插件开发也不够了解，赶紧来补一波吧。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>首先我们这里需要了解一些基本的概念，<a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="noopener">这篇文章介绍的很详细</a>，我这边只提一下。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。<br>意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p>
<h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。<br>和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。<br>一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote>
<p>   静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。<br>静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p>
</blockquote>
<h1 id="Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）"><a href="#Babel-的三个主要处理步骤分别是：-解析（parse），转换（transform），生成（generate）" class="headerlink" title="Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）"></a>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接收代码并输出AST。这个步骤又分为两个阶段：词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段把字符串形式的代码转换成令牌（tokens）流。<br>你可以把令牌看作是一个扁平化的语法片段数组。<br>如：n*n代码经过词法分析转换成令牌<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// n*n</span><br><span class="line">[</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>每一个type有一组属性来描述该令牌：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#123;</span><br><span class="line">    label: &apos;name&apos;,</span><br><span class="line">    keyword: undefined,</span><br><span class="line">    beforeExpr: false,</span><br><span class="line">    startsExpr: true,</span><br><span class="line">    rightAssociative: false,</span><br><span class="line">    isLoop: false,</span><br><span class="line">    isAssign: false,</span><br><span class="line">    prefix: false,</span><br><span class="line">    postfix: false,</span><br><span class="line">    binop: null,</span><br><span class="line">    updateContext: null</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析阶段会把一个令牌(tokens)流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。<br>这个过程我们可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="noopener">astexplorer</a>来查看我们代码生成的AST。<br>这个时候我们的AST就产生了，如下图。<br><img src="http://p52glq5m1.bkt.clouddn.com/ASTdemo1.png" alt="源代码到AST"><br>PS：上图左边为我们的源代码，右边为对应生成的抽象语法树AST。</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。<br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。<br>Babel工作原理见下图表示。<br><img src="http://p52glq5m1.bkt.clouddn.com/Babel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="Babel工作原理"><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="noopener">图片来源，探索 babel 和 babel 插件是怎么工作的</a></p>
<h1 id="开发一个Babel插件"><a href="#开发一个Babel插件" class="headerlink" title="开发一个Babel插件"></a>开发一个Babel插件</h1><h2 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a>Visitors（访问者）</h2><p>当我们谈及“进入”一个节点，实际上是说我们在访问它们， 之所以使用这样的术语是因为有一个访问者模式（visitor）的概念。<br>访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MyVisitor = &#123;</span><br><span class="line">  Identifier: &#123;</span><br><span class="line">	// 当进入Identifier节点的时候执行</span><br><span class="line">	enter() &#123; </span><br><span class="line">	  console.log(&quot;Entered&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">	// 当退出Identifier节点的时候执行</span><br><span class="line">	exit() &#123;</span><br><span class="line">      console.log(&quot;Exited!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS： 许多时候我们只需要关心进入节点，就可以使用简写 Identifier() { … } 或者 Identifier: { enter() { … } } 。<br>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier里面的enter方法和exit方法。</p>
<h2 id="Paths（路径）"><a href="#Paths（路径）" class="headerlink" title="Paths（路径）"></a>Paths（路径）</h2><blockquote>
<p>   我们通过 visitor可以在遍历到对应节点执行对应的函数，当需要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置 （即和其他节点间的关系）, visitor在遍历到对应节点执行对应函数时候会给我们传入 path参数，辅助我们完成上面这些操作。注意 Path 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了 Identifier节点，它传入的 path参数看起来是这样的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;parent&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line">    &quot;id&quot;: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;node&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;...&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以通过：path.node.name 获得当前节点的name；path.parent.id 获得父节点的id<br>另外path对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。</p>
<h2 id="开始动手写插件了"><a href="#开始动手写插件了" class="headerlink" title="开始动手写插件了"></a>开始动手写插件了</h2><p>输入的源代码为：<br><code>yuzhenfan === wangkemei</code><br>生成的AST<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;BinaryExpression&quot;,</span><br><span class="line">  operator: &quot;===&quot;,</span><br><span class="line">  left: &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;yuzhenfan&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;yuzhenfan&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>省略部分属性，可以通过<a href="http://astexplorer.net/#/gist/5579c7f7b371a6f7781f974c9aa1bb6a/238c6f5a96217c0e3b403e33e9de2483da50b0fe" target="_blank" rel="noopener">http://astexplorer.net</a>查看全部属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const babel = require(&apos;babel-core&apos;)</span><br><span class="line"></span><br><span class="line">// 我们的babel插件</span><br><span class="line">let MyVisitor = function(&#123; types: t &#125;) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">		</span><br><span class="line">      BinaryExpression(path) &#123;</span><br><span class="line">		  </span><br><span class="line">        if (path.node.operator !== &quot;===&quot;) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 改变当前节点的left、right（插件的核心代码）</span><br><span class="line">		path.node.left = t.identifier(&quot;fanerge1&quot;);</span><br><span class="line">		path.node.right = t.identifier(&quot;fanerge2&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">	  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const code = `yuzhenfan === wangkemei;`;</span><br><span class="line"></span><br><span class="line">let demo = babel.transform(code, &#123;</span><br><span class="line">  // 使用我们的插件</span><br><span class="line">  plugins: [MyVisitor]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(demo); // fanerge1===fanerge2</span><br></pre></td></tr></table></figure></p>
<p>输出的代码为（经过我们的插件处理）：<br><code>fanerge1===fanerge2</code><br>下图为node打印出Balbel输出的代码：<br><img src="http://p52glq5m1.bkt.clouddn.com/result.png" alt="babel转换的代码"><br><a href="https://github.com/fanerge/babel_plugin" target="_blank" rel="noopener">项目地址，非常简单的Babel插件，后续再继续学习</a></p>
<blockquote>
<p>   参考文档<br><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-introduction" target="_blank" rel="noopener">Babel 插件手册</a><br><a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree</a><br><a href="http://astexplorer.net/" target="_blank" rel="noopener">AST Explorer</a><br><a href="https://www.hazyzh.com/b/180211145458" target="_blank" rel="noopener">探索 babel 和 babel 插件是怎么工作的</a><br><a href="https://juejin.im/post/5a9315e46fb9a0633a711f25" target="_blank" rel="noopener">掘金-babel插件</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome调试</title>
    <url>/2018/Chrome%E8%B0%83%E8%AF%95.html</url>
    <content><![CDATA[<p>记录Chrome DevTools比较少用但又很重要的技巧。</p>
<h1 id="检查动画"><a href="#检查动画" class="headerlink" title="检查动画"></a>检查动画</h1><p>使用Chrome DevTools Animations(动画)检查器检查和修改动画。<br>功能：<br>通过打开Animation Inspector(动画检查器)捕获动画。它会自动检测动画并将它们分组。<br>通过减慢动画，重播动画，或查看源代码，来检查动画。<br>通过更改动画的时间，延迟，持续时间或关键帧偏移来修改动画。</p>
<h1 id="设置DOM断点"><a href="#设置DOM断点" class="headerlink" title="设置DOM断点"></a>设置DOM断点</h1><p>设置DOM断点可以用来调试复杂的JavaScript应用程序。例如，如果你的JavaScript改变了DOM元素的样式，设置一个DOM断点当元素的属性被修改时触发。<br>在以下DOM更改都会触发断点：子树的变化，属性改变，节点删除。<br>设置DOM断点<br>Elements –&gt; Break on –&gt; Subtree Modifications/Attributes Modifications/Node Removal<br>查看DOM断点（包含断点类型）<br>Elements –&gt; DOM Breakpoints</p>
<h1 id="查看元素事件监听器"><a href="#查看元素事件监听器" class="headerlink" title="查看元素事件监听器"></a>查看元素事件监听器</h1><p>在Event Listeners(事件侦听器)窗格中查看与DOM节点相关联的JavaScript事件。<br>查看事件<br>Elements –&gt; Event Listeners<br>当取消勾选Framework listeners(框架侦听器)复选框时，事件侦听器代码可能会解析框架或库代码中的某处。</p>
<h1 id="模拟传感器"><a href="#模拟传感器" class="headerlink" title="模拟传感器"></a>模拟传感器</h1><p>Main menu –&gt; More Tools –&gt; Sensors<br>模拟地理位置坐标以测试地理位置覆盖。<br>模拟设备方向来测试加速计数据。</p>
<h1 id="在XHR上中断"><a href="#在XHR上中断" class="headerlink" title="在XHR上中断"></a>在XHR上中断</h1><p>有两种方法可以触发XHR上的断点：当任何XHR到达XHR生命周期的某个阶段时（readystatechange，load等），或者当XHR的URL与某个字符串匹配时。</p>
<h1 id="调试杂项"><a href="#调试杂项" class="headerlink" title="调试杂项"></a>调试杂项</h1><p>命名函数可以提高调用堆栈的可读性，不限于回掉函数。</p>
<h2 id="把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等"><a href="#把第三方代码放入Blackbox-黑箱-例如第三方库：jQuery、React等" class="headerlink" title="把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等"></a>把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等</h2><p>1.打开 DevTools Settings(设置)。<br>2.在左侧的导航菜单中，单击Blackboxing(黑箱)。<br>3.点击Add pattern…(添加模式)按钮。<br>4.在Pattern(模式)文本框输入您希望从调用堆栈中排除的文件名模式。DevTools 会排除该模式匹配的任何脚本。<br>5.在文本字段右侧的下拉菜单中，选择Blackbox(黑箱)以执行脚本文件但是排除来自调用堆栈的调用，或选择6.Disabled(禁用)来阻止文件执行。<br>7.点击 Add(添加) 保存。<br>下次运行页面并触发断点时，DevTools 将在Call Stack(调用堆栈)中隐藏任何来自放入黑盒脚本函数的调用。<br><a href="http://www.css88.com/doc/chrome-devtools/javascript/step-code/" target="_blank" rel="noopener">把第三方代码放入Blackbox</a><br>管理线程执行<br>使用Sources(源文件)面板上的Threads(线程)窗格暂停，step into(步入)，并检查其他线程，例如service worker 或 web worker 线程。</p>
<h2 id="启动-JavaScript-CPU-状态分析"><a href="#启动-JavaScript-CPU-状态分析" class="headerlink" title="启动 JavaScript CPU 状态分析"></a>启动 JavaScript CPU 状态分析</h2><p>启动一个JavaScript CPU 状态分析，可以添加一个可选标签名。要停止分析，请调用console.profileEnd()。每个分析结果都将添加到Profiles(分析)面板。<br>console.profile([label])<br>console.profileEnd();<br>在调用该方法的地方打印堆栈跟踪。<br>console.trace(object)</p>
<h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>monitorEvents()方法指示DevTools记录指定目标事件的信息。<br>monitorEvents(document.body, “click”);<br>要停止监听事件，请调用unmonitorEvents()方法,传递一个停止监视对象的参数。<br>unmonitorEvents(document.body);<br>查看在对象上注册事件监听器<br>getEventListeners() API返回在指定对象上注册事件的监听器。<br>返回值是一个对象，其中包含每个已注册事件类型的数组（例如，click 或 keydown）。 每个数组的成员都是对象，描述每中类型的已注册监听器。</p>
<h1 id="Chrome-滚动截屏"><a href="#Chrome-滚动截屏" class="headerlink" title="# Chrome 滚动截屏"></a># Chrome 滚动截屏</h1><h2 id="Chrome-截全屏（PC）"><a href="#Chrome-截全屏（PC）" class="headerlink" title="Chrome 截全屏（PC）"></a>Chrome 截全屏（PC）</h2><ol>
<li>打开控制台  Alt + Command+ I (Mac) 或 Ctrl + Shift + I (Windows)</li>
<li>功能搜索  Command + Shift + P(Mac) 或 Ctrl + Shift + P (Windows)</li>
<li>输入“Screen” 并选择 Capture full size screenshot 功能即可</li>
</ol>
<h2 id="Chrome-截全屏（移动端）"><a href="#Chrome-截全屏（移动端）" class="headerlink" title="Chrome 截全屏（移动端）"></a>Chrome 截全屏（移动端）</h2><p>只需在 toggle device toolbar 选择移动端<br>进行上面2的操作即可</p>
<h2 id="部分截屏"><a href="#部分截屏" class="headerlink" title="部分截屏"></a>部分截屏</h2><p>只需在选择对应的DOM基础上<br>进行上面2的操作即可<br><a href="https://weibo.com/ttarticle/p/show?id=2309404241869646237445" target="_blank" rel="noopener">如何利用 Chrome 浏览器实现滚动截屏</a></p>
<h1 id="Chrome-模拟移动端降低CPU及网速"><a href="#Chrome-模拟移动端降低CPU及网速" class="headerlink" title="Chrome 模拟移动端降低CPU及网速"></a>Chrome 模拟移动端降低CPU及网速</h1><p>Performance -&gt; setting -&gt; CPU/Network</p>
<blockquote>
<p>   参考文档：<br><a href="http://www.css88.com/doc/chrome-devtools/" target="_blank" rel="noopener">参考</a></p>
</blockquote>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS笔记</title>
    <url>/2018/CSS%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。</p>
<h1 id="CSS方法"><a href="#CSS方法" class="headerlink" title="CSS方法"></a>CSS方法</h1><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p>用来获取选择到的元素的某一HTML属性值，并用于其样式。</p>
<h2 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h2><p>可以通过计算来决定一个CSS属性的值了。<br>PS：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px);</code></p>
<h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p><code>counter-reset</code>属性创建或重置一个或多个计数器。<br><code>counter-increment</code>属性递增一个或多个计数器值。<br><code>counter(name)</code>方法用于获取计数器的值。<br>PS：<code>counter-reset</code>属性通常是和<code>counter-increment</code>属性，<code>content</code>属性一起使用。</p>
<h2 id="cubic-bezier"><a href="#cubic-bezier" class="headerlink" title="cubic-bezier()"></a>cubic-bezier()</h2><p>它主要作用于动画和过渡的运动曲线函数 animation-timing-function 和 transition-timing-function 。<br><a href="http://cubic-bezier.com/" target="_blank" rel="noopener">cubic-bezier转换网站</a></p>
<h2 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h2><h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h3><p>线性渐变<br><code>background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);</code><br><code>repeating-linear-gradient</code> – 重复线性渐变<br><code>background: repeating-linear-gradient(to top left, lightpink, lightpink 5px, white 5px, white 10px);</code></p>
<h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient"></a>radial-gradient</h3><p>径向渐变<br><code>background: radial-gradient(red, yellow, rgb(30, 144, 255));</code><br><code>repeating-radial-gradient</code> – 重复径向渐变<br><code>background: repeating-radial-gradient(powderblue, powderblue 8px, white 8px, white 16px);</code></p>
<h2 id="image-set"><a href="#image-set" class="headerlink" title="image-set()"></a>image-set()</h2><p>可以根据用户设备的分辨率匹配合适的图像。<br><code>background-image: image-set( &quot;test.png&quot; 1x, &quot;test-2x.png&quot; 2x, &quot;test-print.png&quot; 600dpi );</code></p>
<h3 id="img-的-srcset属性"><a href="#img-的-srcset属性" class="headerlink" title="img 的 srcset属性"></a>img 的 srcset属性</h3><p>以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。<br><code>&lt;img src=&quot;mm-width-128px.jpg&quot; srcset=&quot;mm-width-128px.jpg 1x, mm-width-256px.jpg 2x&quot;&gt;</code><br>PS：img的srcset属性方便的解决了页面图片适应不同屏幕密度的情况。</p>
<h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h2><p>matrix() 指定了一个由指定的 6 个值组成的 2D 变换矩阵。这种矩阵的常量值是隐含的，而不是由参数传递的；其他的参数是以列优先的顺序描述的。<br>matrix3d() 参数为 9 个值，对应 3D 变换。<br>PS：所有的 transform 参数值都可以用矩阵来表示。</p>
<h2 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h2><p>var()函数可以代替元素中任何属性中的值的任何部分。<br>语法：<code>var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? )</code><br>ps：带有前缀–的属性名，比如–example–name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。</p>
<h1 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h1><h2 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h2><p>指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。</p>
<h2 id="cross-fade"><a href="#cross-fade" class="headerlink" title="cross-fade"></a>cross-fade</h2><p>作用：CSS3背景图片透明叠加属性。<br>方法：<code>background-image: -webkit-cross-fade(url(1.jpg), url(2.jpg), 50%);</code><br>PS：透明度是作用在第二张图片上的。<br><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-background-image-cross-fade/" target="_blank" rel="noopener">Cross-fade</a></p>
<h2 id="caret-color"><a href="#caret-color" class="headerlink" title="caret-color"></a>caret-color</h2><p>用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。</p>
<h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><p>可以创建一个只有元素的部分区域可以显示的剪切区域（也就是说可以让一个元素显示出不同的形式，如圆形、椭圆、多边形等等）。<br><a href="http://yunkus.com/css-clip-path/" target="_blank" rel="noopener">CSS3 clip-path 用法详解</a></p>
<h2 id="shape-outside"><a href="#shape-outside" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>属性指定使用下面列表的值来定义浮动元素的浮动区域。这个浮动区域决定了行内内容（浮动元素）所包裹的形状。<br>其中还包括basic-shape有inset()、 circle()、ellipse()、polygon()</p>
<h2 id="resolution"><a href="#resolution" class="headerlink" title="resolution"></a>resolution</h2><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>每英寸包含点的数量（dots per inch）<br>普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx）。</p>
<h3 id="dpcm"><a href="#dpcm" class="headerlink" title="dpcm"></a>dpcm</h3><p>每厘米包含点的数量（dots per centimeter）</p>
<h3 id="dppx"><a href="#dppx" class="headerlink" title="dppx"></a>dppx</h3><p>每像素包含点的数量（dots per pixel）<br>基本的换算单位<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1dppx = 96dpi</span><br><span class="line">1dpi ≈ 0.39dpcm</span><br><span class="line">1dpcm ≈ 2.54dpi</span><br><span class="line">1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px</span><br></pre></td></tr></table></figure></p>
<h2 id="empty-cells"><a href="#empty-cells" class="headerlink" title="empty-cells"></a>empty-cells</h2><p>渲染表格 table 中没有可见内容的单元格的边框和背景，取值为show 和 hide。</p>
<h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>width属性又多了几个关键字成员，fill-available, max-content, min-content, 以及fit-content，兼容性还有很大问题，暂不深究。</p>
<h3 id="max-content"><a href="#max-content" class="headerlink" title="max-content"></a>max-content</h3><p>固有的首选宽度.</p>
<h3 id="min-content"><a href="#min-content" class="headerlink" title="min-content"></a>min-content</h3><p>这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素）。</p>
<h3 id="available"><a href="#available" class="headerlink" title="available"></a>available</h3><p>包含块的宽度减去水平 margin, border 和 padding.</p>
<h3 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h3><p>以下两种情况下的较大值:固有的最小宽度 或 固有首选宽度（max-content）和可用宽度（available）的较小值  </p>
<h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><p>之前的 length 或 percentage 应用到元素的边框盒子.</p>
<h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><p>之前的 length 或 percentage 应用到元素的内容盒子.</p>
<h2 id="hanging-punctuation"><a href="#hanging-punctuation" class="headerlink" title="hanging-punctuation"></a>hanging-punctuation</h2><p>指定了标点符号应该放在文本句子的开头还是结尾。悬挂标点符号可能被放在线框外。</p>
<h2 id="hyphens"><a href="#hyphens" class="headerlink" title="hyphens"></a>hyphens</h2><p>告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。</p>
<h2 id="image-rendering"><a href="#image-rendering" class="headerlink" title="image-rendering"></a>image-rendering</h2><p>决定浏览器对缩放图像采取的缩放算法.它适用于元素本身和有其他属性的图像.它对非缩放图像没有影响。</p>
<h2 id="image-orientation"><a href="#image-orientation" class="headerlink" title="image-orientation"></a>image-orientation</h2><p>用来修正某些图片的预设方向。<br>PS：该属性不是用来对图片进行任意角度旋转的, 它是用来修正那些带有不正确的预设方向的图片的. 因此该属性值会被四舍五入到 90 度的整数倍.</p>
<h2 id="通用关键字"><a href="#通用关键字" class="headerlink" title="通用关键字"></a>通用关键字</h2><p><code>inherit</code> – 关键字使得元素获取其父元素的计算值(computed value )，当然肯定只针对可继承属性。<br><code>initial</code> – 是将属性的初始值( initial value)赋给元素，至于那些为<a href="https://www.w3.org/TR/CSS2/propidx.html" target="_blank" rel="noopener">不同属性的初始值，请参见W3C</a>。<br><code>unset</code> – CSS 关键字 unset 是 关键字 initial 和 inherit的组合（换句话说这个unset关键字会优先用inherit的样式，其次会应该用initial的样式）。<br><code>all</code> – CSS all简写属性重设除了unicode-bidi 和 direction 之外的所有属性至它们的初始值或继承值。</p>
<h2 id="inline-size"><a href="#inline-size" class="headerlink" title="inline-size"></a>inline-size</h2><p>定义元素的块的水平或垂直大小，这取决于它的写入模式。它对应于 width 或 height，取决于 writing-mode 属性。</p>
<h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>定义该元素是否必须创建一个新的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">stacking context</a>。<br>PS：该属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。</p>
<h2 id="支持欠佳的属性，暂不深究"><a href="#支持欠佳的属性，暂不深究" class="headerlink" title="支持欠佳的属性，暂不深究"></a>支持欠佳的属性，暂不深究</h2><p>margin-block-start 和 margin-block-end<br>定义元素的逻辑块结束余量，该元素根据元素的writing-mode、方向性和文本方向映射到物理量度。<br>margin-inline-start 和 margin-inline-end<br>min-block-size 和 min-inline-size<br>offset-block-start 和 offset-block-end<br>offset-inline-start 和 offset-inline-end<br>padding-block-start 和 padding-block-end<br>padding-inline-end 和 padding-inline-start</p>
<h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。<br>遮罩mask是一个复合属性，包括mask-image、mask-mode、mask-repeat、mask-position、mask-clip、mask-origin、mask-size、mask-composite这8个属性</p>
<h3 id="mask-image"><a href="#mask-image" class="headerlink" title="mask-image"></a>mask-image</h3><p>默认值为none，值为透明图片，或透明渐变</p>
<h3 id="mask-repeat"><a href="#mask-repeat" class="headerlink" title="mask-repeat"></a>mask-repeat</h3><p>默认值为repeat，可选值与background-repeat相同</p>
<h3 id="mask-position"><a href="#mask-position" class="headerlink" title="mask-position"></a>mask-position</h3><p>默认值为0 0，可选值与background-position相同</p>
<h3 id="mask-clip"><a href="#mask-clip" class="headerlink" title="mask-clip"></a>mask-clip</h3><p>默认值为border-box，可选值与background-clip相同</p>
<h3 id="mask-origin"><a href="#mask-origin" class="headerlink" title="mask-origin"></a>mask-origin</h3><p>默认值为border-box，可选值与background-origin相同</p>
<h3 id="mask-size"><a href="#mask-size" class="headerlink" title="mask-size"></a>mask-size</h3><p>默认值为auto，可选值与background-size相同</p>
<h3 id="mask-mode"><a href="#mask-mode" class="headerlink" title="mask-mode"></a>mask-mode</h3><p>默认值为match-source，可选值为alpha、luminance、match-source，或者它们的组合</p>
<h3 id="mask-composite"><a href="#mask-composite" class="headerlink" title="mask-composite"></a>mask-composite</h3><p>默认值为add，可选值为add、subtract、intersect、exclude</p>
<h2 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h2><p>描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p>
<h2 id="作用于替换元素，如img"><a href="#作用于替换元素，如img" class="headerlink" title="作用于替换元素，如img"></a>作用于替换元素，如img</h2><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p>指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</p>
<h3 id="object-position"><a href="#object-position" class="headerlink" title="object-position"></a>object-position</h3><p>指定元素的替换内容在其盒子内的对齐方式。</p>
<h2 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h2><p>是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。<br>PS：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。</p>
<h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><p>指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。</p>
<h2 id="quotes"><a href="#quotes" class="headerlink" title="quotes"></a>quotes</h2><p>设置嵌套引用的引号类型。<br>PS：当4个参数时，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。</p>
<h2 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h2><p>CSS 规则关联了一组嵌套的CSS语句,这些语句被放置在一个CSS区块中,该区块以大括号分割, 还有一个由多个CSS声明检测组成的条件,它是一个键值组合, 由逻辑与,逻辑或,逻辑非组合而成. 这样的条件语句称为支持条件.<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@supports &lt;supports_condition&gt; &#123;</span><br><span class="line">  /* specific rules */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：在 supports_condition 中还支持 not、or、and 逻辑。</p>
<h2 id="tab-size"><a href="#tab-size" class="headerlink" title="tab-size"></a>tab-size</h2><p>用于自定义制表符 (U+0009) 的宽度。</p>
<h2 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h2><p>用于布局表格单元格，行和列的算法。</p>
<h2 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h2><p>描述的是一段文本中最后一行在被强制换行之前的对齐规则。</p>
<h2 id="text-combine-upright"><a href="#text-combine-upright" class="headerlink" title="text-combine-upright"></a>text-combine-upright</h2><p>文本结合 writing-mode（为vertical-rl 或 vertical-lr） 指定多个字符的组合到单个字符的空间中。</p>
<h2 id="text-emphasis"><a href="#text-emphasis" class="headerlink" title="text-emphasis"></a>text-emphasis</h2><p>主要效果为文本强调。<br>text-emphasis-color<br>text-emphasis-position<br>text-emphasis-style</p>
<h2 id="text-orientation"><a href="#text-orientation" class="headerlink" title="text-orientation"></a>text-orientation</h2><p>设置文本的方向。</p>
<h2 id="text-rendering"><a href="#text-rendering" class="headerlink" title="text-rendering"></a>text-rendering</h2><p>CSS 属性定义浏览器渲染引擎如何渲染字体。浏览器会在速度、清晰度、几何精度之间进行权衡。</p>
<h2 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h2><p>CSS属性指定如何将元素的文本大小写。</p>
<h2 id="text-underline-position"><a href="#text-underline-position" class="headerlink" title="text-underline-position"></a>text-underline-position</h2><p>当 text-decoration属性的值设置为 underline 之后，可以用 text-underline-position 属性为其设置下划线的位置。</p>
<h2 id="touch-action"><a href="#touch-action" class="headerlink" title="touch-action"></a>touch-action</h2><p>用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。</p>
<h2 id="transform-box"><a href="#transform-box" class="headerlink" title="transform-box"></a>transform-box</h2><p>defines the layout box, to which the transform and transform-origin properties relate to.</p>
<h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><p>确定元素的子元素是否位于3D空间中，还是在该元素所在的平面内被扁平化。</p>
<h2 id="unicode-bidi"><a href="#unicode-bidi" class="headerlink" title="unicode-bidi"></a>unicode-bidi</h2><p>CSS 的 unicode-bidi 属性和 direction 属性一起决定了如何处理文档中的双向文本（bidirectional text）。</p>
<h2 id="unicode-range"><a href="#unicode-range" class="headerlink" title="unicode-range"></a>unicode-range</h2><p>属性值可以是单个字符编码、字符编码区间、通配符区间、多个值等，如小写字母：[0x61,0x7a]（或十进制[97, 122]）<br>CSS unicode-range 特定字符使用 font-face 自定义字体。</p>
<h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。<br><code>baseline</code><br>元素基线与父元素的基线对齐。<br>对于一些 可替换元素，比如 textarea ， HTML标准没有说明它的基线，这意味着对其使用这个关键字，各浏览器表现可能不一样。<br><code>sub</code><br>元素基线与父元素的下标基线对齐。<br><code>super</code><br>元素基线与父元素的上标基线对齐。<br><code>text-top</code><br>元素顶端与父元素字体的顶端对齐。<br><code>text-bottom</code><br>元素底端与父元素字体的底端对齐。<br><code>middle</code><br>元素中垂线与父元素的基线加上小写x一半的高度值对齐。<br><code>length</code><br>元素基线超过父元素的基线指定高度。可以取负值。<br><code>percentage</code><br>同 length , 百分比相对于 line-height 。<br>以下两个值是相对于整行来说的：<br><code>top</code><br> 元素及其后代的顶端与整行的顶端对齐。<br><code>bottom</code><br>元素及其后代的底端与整行的底端对齐。</p>
<h2 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h2><p>CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。<br>PS：这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p>
<h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p>
<h2 id="增加热区的范围"><a href="#增加热区的范围" class="headerlink" title="增加热区的范围"></a>增加热区的范围</h2><ol>
<li>border 可以增加热区（与用户交互的区域），outline 和 box-shadow 是不能办到的。</li>
<li>伪元素同样可以代表其宿主元素来响应鼠标交互。</li>
</ol>
<p>通常的做法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border: 10px solid transparent;</span><br></pre></td></tr></table></figure></p>
<h1 id="filter-滤镜效果"><a href="#filter-滤镜效果" class="headerlink" title="filter(滤镜效果)"></a>filter(滤镜效果)</h1><p>CSS滤镜（filter）属提供的图形特效，像模糊，锐化或元素变色。过滤器通常被用于调整图片，背景和边界的渲染。<br>filter 可以开启浏览器的硬件加速GPU，优化性能。</p>
<h2 id="blur"><a href="#blur" class="headerlink" title="blur()"></a>blur()</h2><p>给图像设置高斯模糊。filter: blur(number);</p>
<h2 id="brightness"><a href="#brightness" class="headerlink" title="brightness()"></a>brightness()</h2><p>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</p>
<h2 id="drop-shadow"><a href="#drop-shadow" class="headerlink" title="drop-shadow()"></a>drop-shadow()</h2><p>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 </p>
<h2 id="contrast"><a href="#contrast" class="headerlink" title="contrast()"></a>contrast()</h2><p>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</p>
<h2 id="grayscale"><a href="#grayscale" class="headerlink" title="grayscale()"></a>grayscale()</h2><p>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p>
<h2 id="hue-rotate"><a href="#hue-rotate" class="headerlink" title="hue-rotate()"></a>hue-rotate()</h2><p>给图像应用色相旋转。“angle”一值设定图像会被调整的色环角度值。</p>
<h2 id="invert"><a href="#invert" class="headerlink" title="invert()"></a>invert()</h2><p>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</p>
<h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity()"></a>opacity()</h2><p>转化图像的透明程度。</p>
<h2 id="saturate"><a href="#saturate" class="headerlink" title="saturate()"></a>saturate()</h2><p>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。</p>
<h2 id="sepia"><a href="#sepia" class="headerlink" title="sepia()"></a>sepia()</h2><p>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。<br>PS：你可以组合任意数量的函数来控制渲染。下面的例子可以增强图像的对比度和亮度。<br><code>filter: contrast(175%) brightness(3%)</code></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background 是CSS简写属性，用来集中设置各种背景属性。background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat,background-size, background-attachment。</p>
<h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p>如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。</p>
<h2 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h2><p>定义该元素的背景图片，以及背景色如何混合。</p>
<h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>置元素的背景（背景图片或颜色）是否延伸到边框下面。<br>PS：简写形式background:bg-color bg-image bg-position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p>
<h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><h2 id="active"><a href="#active" class="headerlink" title=":active"></a>:active</h2><p>:active CSS伪类匹配被用户激活的元素。<br>PS：当多伪类同时使用时，需要注意顺序，否则就会发生被覆盖，如链接:link — :visited — :hover — :active。</p>
<h2 id="target"><a href="#target" class="headerlink" title=":target"></a>:target</h2><p>代表一个唯一的页面元素(目标元素)，其ID与当前URL片段匹配.</p>
<h2 id="default"><a href="#default" class="headerlink" title=":default"></a>:default</h2><p>表示一组相关元素中的默认表单元素。<br><code>该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用。</code></p>
<h2 id="dir"><a href="#dir" class="headerlink" title=":dir"></a>:dir</h2><p>伪类匹配特定文字书写方向的元素。在HTML中, 文字方向由dir属性决定。</p>
<h2 id="enabled"><a href="#enabled" class="headerlink" title=":enabled"></a>:enabled</h2><p>表示任何启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入）或获取焦点，则该元素是启用的。</p>
<h2 id="disabled"><a href="#disabled" class="headerlink" title=":disabled"></a>:disabled</h2><p>表示任何被禁用的元素。如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。</p>
<h2 id="read-only"><a href="#read-only" class="headerlink" title=":read-only"></a>:read-only</h2><p>表示元素不可被用户编辑的状态（如锁定的文本输入框）。</p>
<h2 id="read-write"><a href="#read-write" class="headerlink" title=":read-write"></a>:read-write</h2><p>代表一个元素（例如可输入文本的 input元素）可以被用户编辑。<br>PS：这个选择器不仅仅选择 input 元素，它也会选择所有可以被用户编辑的元素，例如设置了 contenteditable 属性的 p 元素。</p>
<h2 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h2><p>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格），无论一个元素是否为 (empty 或 not), 注释或处理指令都不会产生影响。</p>
<h2 id="not"><a href="#not" class="headerlink" title=":not()"></a>:not()</h2><p>是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。<br>PS：:not伪类不像其它伪类，它不会增加选择器的优先级。</p>
<h2 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h2><p>表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。</p>
<h2 id="fullscreen"><a href="#fullscreen" class="headerlink" title=":fullscreen"></a>:fullscreen</h2><p>应用于当前处于全屏显示模式的元素。 它不仅仅选择顶级元素，还包括所有已显示的栈内元素。</p>
<h2 id="in-range"><a href="#in-range" class="headerlink" title=":in-range"></a>:in-range</h2><p>代表一个 input 元素，其当前值处于属性min 和max 限定的范围之内.</p>
<h2 id="out-of-range"><a href="#out-of-range" class="headerlink" title=":out-of-range"></a>:out-of-range</h2><p>代表一个 input 元素，其当前值不在属性min 和max 限定的范围之内.</p>
<h2 id="indeterminate"><a href="#indeterminate" class="headerlink" title=":indeterminate"></a>:indeterminate</h2><p>表示状态不确定的表单元素.</p>
<h2 id="invalid"><a href="#invalid" class="headerlink" title=":invalid"></a>:invalid</h2><p>表示任意内容未通过验证的 input 或其他 form 元素 .</p>
<h2 id="valid"><a href="#valid" class="headerlink" title=":valid"></a>:valid</h2><p>表示任意内容通过验证的 input 或其他 form 元素 .</p>
<h2 id="required"><a href="#required" class="headerlink" title=":required"></a>:required</h2><p>表示 任意 input 元素表示任意拥有required属性的 input 或 textarea 元素使用它. 它允许表单在提交之前容易的展示必填字段并且渲染其外观. </p>
<h2 id="lang"><a href="#lang" class="headerlink" title=":lang()"></a>:lang()</h2><p>基于元素语言来匹配页面元素。</p>
<h2 id="optional"><a href="#optional" class="headerlink" title=":optional"></a>:optional</h2><p>表示任意没有required属性的 input，select 或  textarea 元素使用它。</p>
<h2 id="only-child"><a href="#only-child" class="headerlink" title=":only-child"></a>:only-child</h2><p>代表了属于某个父元素的唯一一个子元素.<br>PS：等价的方法还有:first-child:last-child或者:nth-child(1):nth-last-child(1)</p>
<h2 id="root"><a href="#root" class="headerlink" title=":root"></a>:root</h2><p>这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 html 元素，除了优先级更高之外，与 html 选择器相同。</p>
<h2 id="scope"><a href="#scope" class="headerlink" title=":scope"></a>:scope</h2><p>它将会匹配作为选择符匹配元素的参考点(css的作用域或作用点)。在HTML中，可以使用 style 的scoped属性来重新定义新的参考点。如果HTML中没有使用这个属性，那么默认的参考点(css的作用域或作用点)是 html。</p>
<h2 id="scroll-behavior"><a href="#scroll-behavior" class="headerlink" title="scroll-behavior"></a>scroll-behavior</h2><p>当由于导航或者CSSOM滚动api产生滚动时，CSS属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。<br>PS：可以配合 a 链接来实现平滑滚动到对应锚点位置。<br><a href="https://codepen.io/fanerge/pen/ERPELJ" target="_blank" rel="noopener">可以在Chrome浏览器中测试下</a></p>
<h2 id="scroll-snap-type"><a href="#scroll-snap-type" class="headerlink" title="scroll-snap-type"></a>scroll-snap-type</h2><p>CSS属性定义在滚动容器中的一个snap点如何被严格的执行。<br>PS：此属性不能用来指定任何精确的动画或者物理运动效果来执行snap点，而是交给用户代理来处理。</p>
<h2 id="shape-outside-1"><a href="#shape-outside-1" class="headerlink" title="shape-outside"></a>shape-outside</h2><p>CSS 属性定义了一个行内内容应该包裹的形状。默认表现是行内元素包裹该形状的margin box。</p>
<h2 id="shape-image-threshold"><a href="#shape-image-threshold" class="headerlink" title="shape-image-threshold"></a>shape-image-threshold</h2><p>CSS property defines the alpha channel threshold used to extract the shape using an image as the value for shape-outside.</p>
<h2 id="shape-margin"><a href="#shape-margin" class="headerlink" title="shape-margin"></a>shape-margin</h2><p>CSS property specifies a margin for a CSS shape created using shape-outside.</p>
<h1 id="page"><a href="#page" class="headerlink" title="@page"></a>@page</h1><p>@page 规则用于在打印文档时修改某些CSS属性。<br>你不能用@page规则来修改所有的CSS属性，而是只能修改margin,orphans,widow 和 page breaks of the document。对其他属性的修改是无效的。</p>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>指定页面盒模型所在的容器的大小和方向。一般情况下，因为一个页面盒模型被渲染到一面纸张上，所以这个属性也指示了目标纸张的大小。</p>
<h2 id="marks"><a href="#marks" class="headerlink" title="marks"></a>marks</h2><p>向文档添加剪切标记和/或注册标记。</p>
<h2 id="bleed"><a href="#bleed" class="headerlink" title="bleed"></a>bleed</h2><p>指定一个超出页面盒模型的区域，在这个区域的页面内容将被裁剪。</p>
<h2 id="first"><a href="#first" class="headerlink" title=":first"></a>:first</h2><p>需要和 @page 配套使用，打印文档的时候，第一页的样式。</p>
<h2 id="left"><a href="#left" class="headerlink" title=":left"></a>:left</h2><p>需要和 @page 配套使用, 对打印文档的左侧页设置CSS样式.</p>
<h2 id="right"><a href="#right" class="headerlink" title=":right"></a>:right</h2><p>需要和 @page 配套使用, 对打印文档的右侧页设置CSS样式.</p>
<h2 id="blank"><a href="#blank" class="headerlink" title=":blank"></a>:blank</h2><p>与 :empty 关系类似，浏览器支持不佳。</p>
<h2 id="两个实验性"><a href="#两个实验性" class="headerlink" title="两个实验性"></a>两个实验性</h2><p>:recto 和 :verso </p>
<h2 id="page-break-after"><a href="#page-break-after" class="headerlink" title="page-break-after"></a>page-break-after</h2><p>CSS 属性调整当前元素之后的分页符</p>
<h2 id="page-break-before"><a href="#page-break-before" class="headerlink" title="page-break-before"></a>page-break-before</h2><p>CSS属性调整当前元素之前的分页符。</p>
<h2 id="page-break-inside"><a href="#page-break-inside" class="headerlink" title="page-break-inside"></a>page-break-inside</h2><p>CSS 属性调整当前元素内的分页符。</p>
<h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><h2 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h2><p>::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。<br>PS：这个虚拟元素默认是行内元素。</p>
<h2 id="fitst-letter"><a href="#fitst-letter" class="headerlink" title="::fitst-letter"></a>::fitst-letter</h2><p>会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。<br>PS：你可能还不知道，::before 伪元素 和 content 属性结合起来有可能会在元素前面注入一些文本。如此，::first-letter 将会匹配到content文本的首字母。<br>首行只在 block-container box内部才有意义, 因此 ::first-letter 伪元素 只在display属性值为block, inline-block, table-cell, list-item 或者 table-caption的元素上才起作用. 其他情况下, ::first-letter 毫无意义.</p>
<h2 id="backdrop"><a href="#backdrop" class="headerlink" title="::backdrop"></a>::backdrop</h2><p>是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p>
<h2 id="placeholder"><a href="#placeholder" class="headerlink" title="::placeholder"></a>::placeholder</h2><p>可以选择一个表单元素的占位文本，它允许开发者和设计师自定义占位文本的样式。</p>
<h2 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h2><p>应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。</p>
<h2 id="slotted"><a href="#slotted" class="headerlink" title="::slotted()"></a>::slotted()</h2><p>CSS pseudo-element represents any element that has been placed into a slot inside an HTML template (see Using templates and slots for more information).</p>
<h1 id="css3-布局"><a href="#css3-布局" class="headerlink" title="css3 布局"></a>css3 布局</h1><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>place-content<br><a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/0320%E6%80%BB%E7%BB%93flex%E5%B8%83%E5%B1%80.txt" target="_blank" rel="noopener">Study-Notes</a></p>
<h2 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h2><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>通过设置 display: grid;  可以定义一个 CSS 网格。然后使用 grid-template-rows 和 grid-template-columns 属性来定义网格的 columns 和 rows。<br>PS：grid-template-rows 和 grid-template-columns 有较多种参数。<br>minmax(min, max)<br>可以设置最小值和最大值，当某个值为 auto 时不限制。<br>repeat( [ <positive-integer> | auto-fill | auto-fit ] , <track-list> )<br>重复的多个 track，第一个参数指定了 repeat 的次数。<br>auto-fit<br>倾向于使用最少列数占满当前行空间，浏览器先是和 auto-fill 一样，暗中创建一些列来填充多出来的行空间，然后坍缩（collapse）这些列以便腾出空间让其余列扩张。<br>auto-fill<br>倾向于容纳更多的列，所以如果在满足宽度限制的前提下还有空间能容纳新列，那么它会暗中创建一些列来填充当前行。</track-list></positive-integer></p>
<h3 id="Grid-Areas"><a href="#Grid-Areas" class="headerlink" title="Grid Areas"></a>Grid Areas</h3><p>网格区域是网格中由一个或者多个网格单元格组成的一个矩形区域。当你使用基于网格线位置放置一个项目或者使用命名的网格区域定义区域时，网格区域被创建。<br>通常用 grid-area 属性命名它们（为子网格命名），然后用 grid-template-areas 把它们放在网格上。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_areas" target="_blank" rel="noopener">Grid Areas</a></p>
<h3 id="Grid-Lines"><a href="#Grid-Lines" class="headerlink" title="Grid Lines"></a>Grid Lines</h3><p>使用Grid布局在显式网格中定义轨道的同时会创建网格线。<br>网格线可以用它们的编号来寻址，线编号遵循文档的写入模式，因此在从右到左的语言中，列线1行将位于网格的右侧。<br>PS：主要给下列属性使用grid-column-start、grid-column-end、grid-row-start、grid-row-end。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_lines" target="_blank" rel="noopener">Grid Lines</a></p>
<h3 id="Gutters"><a href="#Gutters" class="headerlink" title="Gutters"></a>Gutters</h3><p>网格间距是网格轨道之间的间距，可以通过 grid-column-gap 或者 grid-row-gap 在Grid布局中创建。</p>
<h1 id="动画和过渡和转换"><a href="#动画和过渡和转换" class="headerlink" title="动画和过渡和转换"></a>动画和过渡和转换</h1><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>animation属性是如下属性的一个简写属性形式: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode.</p>
<h2 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h2><p>指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。</p>
<h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p>CSS属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。</p>
<h2 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h2><p>CSS 属性指示动画是否反向播放，它通常在简写属性animation中设定。</p>
<h2 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h2><p>用来指定在动画执行之前和之后如何给动画的目标应用样式。</p>
<h2 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h2><p>定义动画在结束前运行的次数 可以是1次 无限循环。</p>
<h2 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h2><p>定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。</p>
<h2 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h2><p>定义CSS动画在每一动画周期中执行的节奏。</p>
<h2 id="perspective-或-perspective"><a href="#perspective-或-perspective" class="headerlink" title="perspective 或 perspective()"></a>perspective 或 perspective()</h2><p>指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。</p>
<h2 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h2><p>指定了观察者的位置，在属性perspective中被用作消失点。</p>
<h1 id="百分比属性参照对象"><a href="#百分比属性参照对象" class="headerlink" title="百分比属性参照对象"></a>百分比属性参照对象</h1><h2 id="参照包含块宽高"><a href="#参照包含块宽高" class="headerlink" title="参照包含块宽高"></a>参照包含块宽高</h2><ol>
<li>参照包含块的width（margin、padding、width、left、right、font-size、text-index）</li>
<li>参照包含块的height（height、top、bottom）</li>
</ol>
<h2 id="参照自身盒子宽高"><a href="#参照自身盒子宽高" class="headerlink" title="参照自身盒子宽高"></a>参照自身盒子宽高</h2><ol>
<li>盒子模型中的border-radius</li>
<li>背景中的background-size</li>
<li>在transform变换中，translate()、transform-origin、scale()<br><a href="https://juejin.im/post/5b0bc994f265da092918d421" target="_blank" rel="noopener">你知道我们平时在CSS中写的%都是相对于谁吗？</a></li>
</ol>
<h1 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h1><h2 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h2><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>相对长度单位，这个单位表示元素的font-size的计算值。如果用在font-size 属性本身，它会继承父元素的font-size。</p>
<h3 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h3><p>这个单位表示元素font的 x-height 。在含有“x”字母的字体中，它是该字体的小写字母的高度；对于很多字体， 1ex ≈ 0.5em。</p>
<h3 id="ch"><a href="#ch" class="headerlink" title="ch"></a>ch</h3><p>这一单位代表元素所用字体 font中“0”这一字形的宽度（“0”，Unicode字符U+0030），或更准确地说是“0”这一字形的预测尺寸（advance measure）。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>这个单位代表根元素的 font-size 大小（html 元素的font-size）。</p>
<h3 id="lh"><a href="#lh" class="headerlink" title="lh"></a>lh</h3><p>等于元素行高line-height的计算值。</p>
<h3 id="rlh"><a href="#rlh" class="headerlink" title="rlh"></a>rlh</h3><p>等于根元素行高line-height的计算值。</p>
<h2 id="视口比例的长度"><a href="#视口比例的长度" class="headerlink" title="视口比例的长度"></a>视口比例的长度</h2><h3 id="vh"><a href="#vh" class="headerlink" title="vh"></a>vh</h3><p>视口高度的 1/100。</p>
<h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h3><p>视口宽度的 1/100。</p>
<h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>等于初始包含块的大小的1%，在根元素的内联轴的方向上。</p>
<h3 id="vb"><a href="#vb" class="headerlink" title="vb"></a>vb</h3><p>等于初始包含块的大小的1%，在根元素的块轴的方向上。</p>
<h3 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a>vmin</h3><p>视口高度和宽度之间的最小值的 1/100。</p>
<h3 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a>vmax</h3><p>视口高度和宽度之间的最大值的 1/100。</p>
<h2 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h2><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>对于屏幕显示，通常是一个设备像素（点）的显示。</p>
<h3 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h3><p>毫米。</p>
<h3 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h3><p>厘米（10毫米）。</p>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>英寸（2.54厘米）。</p>
<h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>磅（1/72 英寸）。</p>
<h3 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h3><p>12 点活字 (1 pc 等于 12 点)。</p>
<h1 id="color"><a href="#color" class="headerlink" title="color"></a>color</h1><h2 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h2><p>black（黑） 、silver（银）、gray[*]（灰）、white（白）等等。</p>
<h2 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h2><p>transparent 关键字，是 rgba(0,0,0,0) 的简写。<br>currentColor 关键字，取当前 color 的值。</p>
<h2 id="颜色表达式"><a href="#颜色表达式" class="headerlink" title="颜色表达式"></a>颜色表达式</h2><p>十六进制符号 #RRGGBB<br>rgb(r, g, b)<br>rgba(r, g, b, a)<br>hsl(h, s, l) // 分别代表：色相、饱和度、亮度<br>hsla(h, s, l, a)</p>
<h1 id="angle"><a href="#angle" class="headerlink" title="angle"></a>angle</h1><p>用于表示角的大小，单位为度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）。在 gradient 和 transform 的某些方法等场景中有所应用。</p>
<h2 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h2><p>度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。</p>
<h2 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h2><p>百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。</p>
<h2 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h2><p>弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。</p>
<h2 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h2><p>圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。</p>
<h1 id="cusor（各属性使用的场景）"><a href="#cusor（各属性使用的场景）" class="headerlink" title="cusor（各属性使用的场景）"></a>cusor（各属性使用的场景）</h1><h2 id="not-allowed"><a href="#not-allowed" class="headerlink" title="not-allowed"></a>not-allowed</h2><p>提示禁用状态，如按钮禁用、禁止拖动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</span><br><span class="line">	cursor: not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p>隐藏鼠标光标，如播放视频等<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">video &#123;</span><br><span class="line">	cursor: url(transparent.gif); // 兼容</span><br><span class="line">	cursor: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS技巧</title>
    <url>/2018/CSS%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<p>本文总结日常CSS技巧，大多收集于网络、<a href="http://www.ituring.com.cn/book/1695" target="_blank" rel="noopener">《CSS揭秘》</a></p>
<h2 id="半透明边框"><a href="#半透明边框" class="headerlink" title="半透明边框"></a>半透明边框</h2><p>思路：默认 background 是从  border-box 裁切，我们可以通过 background-clip 属性来改变 background 裁切区域如 padding-box，在使用 rgba 或者 hsla 来指定边框颜色即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.border &#123;</span><br><span class="line">	border: 10px solid hsla(0,0%,100%,.5);</span><br><span class="line">	background: white;</span><br><span class="line">	background-clip: padding-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="play.csssecrets.io/translucent-borders">半透明边框</a><br>PS：根据 stack context 层级关系 background 在 border 下层。</p>
<h2 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h2><h3 id="box-shadow-方案"><a href="#box-shadow-方案" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><p>思路：首先要知道 box-shadow 的参数：vl hl blurl spreadl color inset，并且支持多重阴影。<br><a href="play.csssecrets.io/multiple-borders">demo</a><br>PS：box-shadow 不影响布局（不占用空间）、不受 box-sizing 的控制、不适用于增加热点区域。</p>
<h3 id="outline-方案"><a href="#outline-方案" class="headerlink" title="outline 方案"></a>outline 方案</h3><p>只适用于两层边框。<br>PS：当 border 为圆角时，outline 不会贴合元素的圆角，需要使用 box-shadow 来填补。 </p>
<h2 id="灵活的背景定位"><a href="#灵活的背景定位" class="headerlink" title="灵活的背景定位"></a>灵活的背景定位</h2><h3 id="background-position-的扩展语法方案"><a href="#background-position-的扩展语法方案" class="headerlink" title="background-position 的扩展语法方案"></a>background-position 的扩展语法方案</h3><p><code>background-position: right 20px bottom 10px;</code><br>PS：背景定位于 right 的 20px处，bottom 的 10px处。<br><a href="play.csssecrets.io/extended-bg-position">bg-position</a></p>
<h3 id="background-origin-方案"><a href="#background-origin-方案" class="headerlink" title="background-origin 方案"></a>background-origin 方案</h3><p>background-origin 属性指定 background-position 属性应该是相对位置。<br><a href="play.csssecrets.io/background-origin">background-origin</a></p>
<h3 id="calc-方案"><a href="#calc-方案" class="headerlink" title="calc() 方案"></a>calc() 方案</h3><p><code>background-position: calc(100% - 20px) calc(100% - 10px);</code><br>PS：需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)。<br><a href="play.csssecrets.io/background-position-calc">background-position-calc</a></p>
<h2 id="边框内圆角"><a href="#边框内圆角" class="headerlink" title="边框内圆角"></a>边框内圆角</h2><p>我们知道box-shadow是会紧贴border-radius圆角边的，但是，描边outline并不会与圆角边border-radius贴合，我们可以将两者组合，通过box-shadow去填补描边outline所产生的间隙来达到我们想要的效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">	border-radius: 8px;</span><br><span class="line">    outline: 6px solid #b4a078;</span><br><span class="line">    box-shadow: 0 0 0 5px #b4a078; // 用于填充 outline 不能紧靠 border-radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://lhammer.cn/You-need-to-know-css/#/inner-rounding" target="_blank" rel="noopener">边框内圆角</a></p>
<h2 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h2><h3 id="横向条纹（默认横向渐变）"><a href="#横向条纹（默认横向渐变）" class="headerlink" title="横向条纹（默认横向渐变）"></a>横向条纹（默认横向渐变）</h3><p>如形成三条间隔条纹背景。<br><code>background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);</code><br>PS：#58a 0 的作用为直接填充 &gt; 33.3% 的部分。<br><a href="play.csssecrets.io/horizontal-stripes">horizontal-stripes</a></p>
<h3 id="垂直条纹"><a href="#垂直条纹" class="headerlink" title="垂直条纹"></a>垂直条纹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(to right, /* 或 90deg */#fb3 50%, #58a 0);</span><br><span class="line">background-size: 30px 100%;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/vertical-stripes">vertical-stripes</a></p>
<h3 id="斜向条纹"><a href="#斜向条纹" class="headerlink" title="斜向条纹"></a>斜向条纹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);</span><br><span class="line">background-size: 42.426406871px 42.426406871px;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/diagonal-stripes">diagonal-stripes</a><br><a href="play.csssecrets.io/diagonal-stripes-60deg">diagonal-stripes-60deg</a></p>
<h3 id="灵活的同色系条纹"><a href="#灵活的同色系条纹" class="headerlink" title="灵活的同色系条纹"></a>灵活的同色系条纹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: #58a;</span><br><span class="line">background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px);</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/subtle-stripes">subtle-stripes</a></p>
<h2 id="复杂的背景图案"><a href="#复杂的背景图案" class="headerlink" title="复杂的背景图案"></a>复杂的背景图案</h2><p><a href="play.csssecrets.io/blueprint">网格</a><br><a href="play.csssecrets.io/polka">波点</a><br><a href="play.csssecrets.io/test-conic-gradient">角向渐变</a><br><a href="http://lea.verou.me/css3patterns/" target="_blank" rel="noopener">css3patterns</a><br><a href="http://bennettfeely.com/gradients/" target="_blank" rel="noopener">图案库</a></p>
<h2 id="连续的图像边框"><a href="#连续的图像边框" class="headerlink" title="连续的图像边框"></a>连续的图像边框</h2><p>设置多层背景，再通过 background-clip 来裁剪各层背景。<br><a href="play.csssecrets.io/continuous-image-borders">图像边框</a><br><a href="play.csssecrets.io/vintage-envelope">信封背景</a><br><a href="play.csssecrets.io/marching-ants">蚂蚁行军边框</a><br><a href="play.csssecrets.io/footnote">footnote</a></p>
<h2 id="自适应的椭圆"><a href="#自适应的椭圆" class="headerlink" title="自适应的椭圆"></a>自适应的椭圆</h2><p>前提为 width === height<br>圆形：<code>border-radius: 100px;</code><br>椭圆：<code>border-radius: 100px / 75px;</code><br>适应性椭圆：<code>border-radius: 50%;</code><br>PS：50%; === 50% / 50%;分别为该元素的宽的50%和高的50%。<br><a href="play.csssecrets.io/ellipse">适应性椭圆</a><br>适应性的半椭圆：<code>border-radius: 100% 0 0 100% / 50%;</code><br>PS：上面的写法，分别为四个角设置。<br><a href="play.csssecrets.io/half-ellipse">适应性的半椭圆</a><br>四分之一椭圆：<code>border-radius: 100% 0 0 0;</code><br>PS：其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。<br><a href="play.csssecrets.io/quarter-ellipse">quarter-ellipse</a></p>
<h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p>需求为让容器元素为平行四边形，但文本不可倾斜。</p>
<h3 id="嵌套元素方案"><a href="#嵌套元素方案" class="headerlink" title="嵌套元素方案"></a>嵌套元素方案</h3><p><a href="play.csssecrets.io/parallelograms">抵消策略</a><br>PS：对容器进行 skew() 变形，对内容再应用一次反向的 skew() 变形，从而抵消容器的变形效果</p>
<h3 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><p><a href="play.csssecrets.io/parallelograms-pseudo">parallelograms-pseudo</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p>
<h2 id="菱形图片"><a href="#菱形图片" class="headerlink" title="菱形图片"></a>菱形图片</h2><h3 id="基于变形的方案"><a href="#基于变形的方案" class="headerlink" title="基于变形的方案"></a>基于变形的方案</h3><p><a href="play.csssecrets.io/diamond-images">diamond-images</a><br>PS：运用 rotate(-45deg) 再使用 scale(1.42) 填满菱形区域。</p>
<h3 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p><code>clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);</code><br><a href="play.csssecrets.io/diamond-clip">diamond-clip</a></p>
<h2 id="切角效果"><a href="#切角效果" class="headerlink" title="切角效果"></a>切角效果</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p><a href="play.csssecrets.io/bevel-corners-gradients">线性渐变</a></p>
<h3 id="弧形切角"><a href="#弧形切角" class="headerlink" title="弧形切角"></a>弧形切角</h3><p><a href="play.csssecrets.io/scoop-corners">径向渐变</a></p>
<h3 id="内联-SVG-与-border-image-方案"><a href="#内联-SVG-与-border-image-方案" class="headerlink" title="内联 SVG 与 border-image 方案"></a>内联 SVG 与 border-image 方案</h3><p>相关 SVG 支持，以背景形式引入 SVG。<br><a href="play.csssecrets.io/bevel-corners">bevel-corners</a></p>
<h3 id="裁切路径方案-1"><a href="#裁切路径方案-1" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p>主要使用 clip-path 属性。<br><a href="play.csssecrets.io/bevel-corners-clipped">bevel-corners-clipped</a></p>
<h2 id="梯形标签页"><a href="#梯形标签页" class="headerlink" title="梯形标签页"></a>梯形标签页</h2><p>需求为让容器元素为梯形，但文本不可倾斜。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform: perspective(.5em) rotateX(5deg);</span><br></pre></td></tr></table></figure></p>
<p><a href="play.csssecrets.io/trapezoid-tabs">trapezoid-tabs</a><br>PS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。</p>
<h2 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h2><h3 id="基于-transform-的解决方案"><a href="#基于-transform-的解决方案" class="headerlink" title="基于 transform 的解决方案"></a>基于 transform 的解决方案</h3><p><a href="play.csssecrets.io/pie-animated">pie-animated</a><br><a href="play.csssecrets.io/pie-static">pie-static</a></p>
<h3 id="SVG-解决方案"><a href="#SVG-解决方案" class="headerlink" title="SVG 解决方案"></a>SVG 解决方案</h3><p><a href="play.csssecrets.io/pie-svg">pie-svg</a></p>
<h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>box-shadow: hl vl blur spread color;<br>PS：hl为水平位置，vl为垂直位置，blur为模糊距离（模糊面积越大，阴影就越大越淡），spread为阴影大小（取正值时，阴影扩大；取负值时，阴影收缩）。    </p>
<h3 id="单侧投影"><a href="#单侧投影" class="headerlink" title="单侧投影"></a>单侧投影</h3><p><code>box-shadow: 0 5px 4px -4px black;</code><br><a href="play.csssecrets.io/shadow-one-side">shadow-one-side</a><br>PS：第四个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。</p>
<h3 id="对边投影"><a href="#对边投影" class="headerlink" title="对边投影"></a>对边投影</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-shadow: 5px 0 5px -5px black,</span><br><span class="line">			-5px 0 5px -5px black;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/shadow-opposite-sides">shadow-opposite-sides</a><br>PS：利用 box-shadow 可以设置多重阴影。</p>
<h2 id="不规则投影"><a href="#不规则投影" class="headerlink" title="不规则投影"></a>不规则投影</h2><h3 id="filter-之-drop-shadow"><a href="#filter-之-drop-shadow" class="headerlink" title="filter 之 drop-shadow()"></a>filter 之 drop-shadow()</h3><p><a href="https://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/" target="_blank" rel="noopener">drop-shadow滤镜与box-shadow区别应用</a><br><a href="https://www.zhangxinxu.com/study/201605/drop-shadow-point-to.html" target="_blank" rel="noopener">demo</a><br><a href="play.csssecrets.io/drop-shadow">demo1</a><br>PS：drop-shadow 没有 inset，不能叠加，有颜色就会有阴影（不特定于盒模型）。</p>
<h2 id="染色效果"><a href="#染色效果" class="headerlink" title="染色效果"></a>染色效果</h2><h3 id="基于滤镜的方案"><a href="#基于滤镜的方案" class="headerlink" title="基于滤镜的方案"></a>基于滤镜的方案</h3><p><a href="play.csssecrets.io/color-tint-filter">color-tint-filter</a><br><a href="http://www.runoob.com/cssref/css3-pr-filter.html" target="_blank" rel="noopener">滤镜文档</a></p>
<h3 id="基于混合模式的方案"><a href="#基于混合模式的方案" class="headerlink" title="基于混合模式的方案"></a>基于混合模式的方案</h3><p>background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。<br><a href="play.csssecrets.io/color-tint">color-tint</a></p>
<h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p><a href="play.csssecrets.io/frosted-glass">frosted-glass</a><br>PS：伪类来实现效果，原本元素放文本，就不会导致文本模糊。</p>
<h2 id="折角效果"><a href="#折角效果" class="headerlink" title="折角效果"></a>折角效果</h2><h3 id="45°折角的解决方案"><a href="#45°折角的解决方案" class="headerlink" title="45°折角的解决方案"></a>45°折角的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: #58a; /* 回退样式 */</span><br><span class="line">background: linear-gradient(to left bottom,</span><br><span class="line">	transparent 50%, rgba(0,0,0,.4) 0)</span><br><span class="line">	no-repeat 100% 0 / 2em 2em,</span><br><span class="line">	linear-gradient(-135deg,</span><br><span class="line">	transparent 1.5em, #58a 0);</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/folded-corner">folded-corner</a></p>
<h3 id="其他角度的解决方案"><a href="#其他角度的解决方案" class="headerlink" title="其他角度的解决方案"></a>其他角度的解决方案</h3><p><a href="play.csssecrets.io/folded-corner-realistic">folded-corner-realistic</a><br><a href="play.csssecrets.io/folded-corner-mixin">folded-corner-mixin</a></p>
<h2 id="连字符断行"><a href="#连字符断行" class="headerlink" title="连字符断行"></a>连字符断行</h2><p>CSS 属性 hyphens 告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。<br><a href="play.csssecrets.io/hyphenation">hyphenation</a></p>
<h2 id="插入换行"><a href="#插入换行" class="headerlink" title="插入换行"></a>插入换行</h2><p><a href="play.csssecrets.io/line-breaks">line-breaks</a><br>PS：有一个 Unicode 字符是专门代表换行符的： 0x000A ① 。在 CSS 中，这个字符可以写作 “\000A” ，或简化为 “\A” ，类似于 br 标签。</p>
<h2 id="文本行的斑马条纹"><a href="#文本行的斑马条纹" class="headerlink" title="文本行的斑马条纹"></a>文本行的斑马条纹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">padding: .5em;</span><br><span class="line">line-height: 1.5;</span><br><span class="line">background: beige;</span><br><span class="line">background-size: auto 3em;</span><br><span class="line">background-origin: content-box;</span><br><span class="line">background-image: linear-gradient(rgba(0,0,0,.2) 50%,</span><br><span class="line">transparent 0);</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/zebra-lines">zebra-lines</a></p>
<h2 id="调整-tab-的宽度"><a href="#调整-tab-的宽度" class="headerlink" title="调整 tab 的宽度"></a>调整 tab 的宽度</h2><p>tab-size 属性规定制表符（tab）字符的空格长度，只对 textarea 和 pre 有效。<br><a href="play.csssecrets.io/tab-size">tab-size</a></p>
<h2 id="连字"><a href="#连字" class="headerlink" title="连字"></a>连字</h2><p>font-variant-ligatures<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures;</span><br></pre></td></tr></table></figure></p>
<h2 id="未来的文本下划线"><a href="#未来的文本下划线" class="headerlink" title="未来的文本下划线"></a>未来的文本下划线</h2><p>text-decoration-color 用于自定义下划线或其他装饰效果的颜色。<br>text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。<br>text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。<br>text-underline-position 用于微调下划线的具体摆放位置。<br><a href="play.csssecrets.io/underlines">underlines</a></p>
<h2 id="现实中的文字效果"><a href="#现实中的文字效果" class="headerlink" title="现实中的文字效果"></a>现实中的文字效果</h2><p><a href="play.csssecrets.io/letterpress">凸版印刷效果</a><br><a href="play.csssecrets.io/stroked-text">空心字效果</a><br><a href="play.csssecrets.io/glow">文字外发光效果</a><br><a href="play.csssecrets.io/extruded">文字凸起效果</a></p>
<h2 id="环形文字"><a href="#环形文字" class="headerlink" title="环形文字"></a>环形文字</h2><p><a href="play.csssecrets.io/circular-text">SVG实现</a></p>
<h2 id="选用合适的鼠标光标"><a href="#选用合适的鼠标光标" class="headerlink" title="选用合适的鼠标光标"></a>选用合适的鼠标光标</h2><h3 id="提示禁用状态"><a href="#提示禁用状态" class="headerlink" title="提示禁用状态"></a>提示禁用状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;</span><br><span class="line">	cursor: not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/disabled">disabled</a></p>
<h3 id="隐藏鼠标光标"><a href="#隐藏鼠标光标" class="headerlink" title="隐藏鼠标光标"></a>隐藏鼠标光标</h3><p>适用于播放 video 等情形。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cursor: url(&apos;transparent.gif&apos;); // 兼容低版本</span><br><span class="line">cursor: none;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩大可点击区域"><a href="#扩大可点击区域" class="headerlink" title="扩大可点击区域"></a>扩大可点击区域</h2><h3 id="Fitts-法则-或-菲茨定律-或-费茨法则"><a href="#Fitts-法则-或-菲茨定律-或-费茨法则" class="headerlink" title="Fitts 法则 或 菲茨定律 或 费茨法则"></a>Fitts 法则 或 菲茨定律 或 费茨法则</h3><p>人机交互的一个法则<br>Fitts 法则认为，人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。</p>
<h3 id="border-增加用户交互区域"><a href="#border-增加用户交互区域" class="headerlink" title="border 增加用户交互区域"></a>border 增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border: 10px solid transparent;</span><br><span class="line">box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;</span><br><span class="line">background-clip: padding-box;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/hit-area-border">hit-area-border</a></p>
<h3 id="伪类增加用户交互区域"><a href="#伪类增加用户交互区域" class="headerlink" title="伪类增加用户交互区域"></a>伪类增加用户交互区域</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button &#123;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">button::before &#123;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	position: absolute;</span><br><span class="line">	top: -10px; right: -10px;</span><br><span class="line">	bottom: -10px; left: -10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/hit-area">hit-area</a></p>
<h2 id="自定义复选框"><a href="#自定义复选框" class="headerlink" title="自定义复选框"></a>自定义复选框</h2><p><a href="play.csssecrets.io/checkboxes">checkboxes</a><br><a href="play.csssecrets.io/toggle-buttons">toggle-buttons</a></p>
<h2 id="通过阴影来弱化背景"><a href="#通过阴影来弱化背景" class="headerlink" title="通过阴影来弱化背景"></a>通过阴影来弱化背景</h2><h3 id="伪元素方案-1"><a href="#伪元素方案-1" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body.dimmed::before &#123;</span><br><span class="line">	position: fixed;</span><br><span class="line">	top: 0;</span><br><span class="line">	right: 0;</span><br><span class="line">	bottom: 0;</span><br><span class="line">	left: 0;</span><br><span class="line">	z-index: 1;</span><br><span class="line">	background: rgba(0,0,0,.8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="box-shadow-方案-1"><a href="#box-shadow-方案-1" class="headerlink" title="box-shadow 方案"></a>box-shadow 方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);</span><br></pre></td></tr></table></figure>
<p><a href="box-shadow: 0 0 0 50vmax rgba(0,0,0,.8" target="_blank" rel="noopener">box-shadow</a>;)</p>
<h3 id="backdrop-方案"><a href="#backdrop-方案" class="headerlink" title="backdrop 方案"></a>backdrop 方案</h3><p><a href="play.csssecrets.io/native-modal">backdrop</a><br>PS：dialog 元素（ <dialog> 元素可以由它的 showModal() 方法显示出来），那么根据浏览器的默认样式，它会自带一个遮罩层（ ::backdrop 伪元素）。</dialog></p>
<h2 id="通过模糊来弱化背景"><a href="#通过模糊来弱化背景" class="headerlink" title="通过模糊来弱化背景"></a>通过模糊来弱化背景</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.de-emphasized &#123;</span><br><span class="line">	filter: blur(3px) contrast(.8) brightness(.8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/deemphasizing-blur">滤镜效果</a></p>
<h2 id="滚动提示"><a href="#滚动提示" class="headerlink" title="滚动提示"></a>滚动提示</h2><p><a href="play.csssecrets.io/scrolling-hints">上下滚动</a></p>
<h2 id="交互式的图片对比控件"><a href="#交互式的图片对比控件" class="headerlink" title="交互式的图片对比控件"></a>交互式的图片对比控件</h2><p><a href="play.csssecrets.io/image-slider">image-slider</a></p>
<h2 id="自适应内部元素"><a href="#自适应内部元素" class="headerlink" title="自适应内部元素"></a>自适应内部元素</h2><p>width 新添了一些属性，如min-content。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">figure &#123;</span><br><span class="line">	max-width: 300px;</span><br><span class="line">	max-width: min-content;</span><br><span class="line">	margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">figure &gt; img &#123; max-width: inherit; &#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="play.csssecrets.io/intrinsic-sizing">intrinsic-sizing</a></p>
<h2 id="精确控制表格列宽"><a href="#精确控制表格列宽" class="headerlink" title="精确控制表格列宽"></a>精确控制表格列宽</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table &#123;</span><br><span class="line">	table-layout: fixed;</span><br><span class="line">	width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="play.csssecrets.io/table-column-widths">table-column-widths</a></p>
<h2 id="根据兄弟元素的数量来设置样式"><a href="#根据兄弟元素的数量来设置样式" class="headerlink" title="根据兄弟元素的数量来设置样式"></a>根据兄弟元素的数量来设置样式</h2><h3 id="相当于li-only-child"><a href="#相当于li-only-child" class="headerlink" title="相当于li:only-child"></a>相当于li:only-child</h3><p>li:first-child:nth-last-child(1)</p>
<h3 id="当列表正好包含四项时，命中所有列表项"><a href="#当列表正好包含四项时，命中所有列表项" class="headerlink" title="当列表正好包含四项时，命中所有列表项"></a>当列表正好包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(4),<br>li:first-child:nth-last-child(4) ~ li</p>
<h3 id="当列表至少包含四项时，命中所有列表项"><a href="#当列表至少包含四项时，命中所有列表项" class="headerlink" title="当列表至少包含四项时，命中所有列表项"></a>当列表至少包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+4),<br>li:first-child:nth-last-child(n+4) ~ li</p>
<h3 id="当列表最多包含四项时，命中所有列表项"><a href="#当列表最多包含四项时，命中所有列表项" class="headerlink" title="当列表最多包含四项时，命中所有列表项"></a>当列表最多包含四项时，命中所有列表项</h3><p>li:first-child:nth-last-child(-n+4),<br>li:first-child:nth-last-child(-n+4) ~ li </p>
<h3 id="当列表包含2～6项时，命中所有列表项"><a href="#当列表包含2～6项时，命中所有列表项" class="headerlink" title="当列表包含2～6项时，命中所有列表项"></a>当列表包含2～6项时，命中所有列表项</h3><p>li:first-child:nth-last-child(n+2):nth-last-child(-n+6),<br>li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li<br><a href="play.csssecrets.io/styling-sibling-count">styling-sibling-count</a></p>
<h2 id="满幅的背景，定宽的内容"><a href="#满幅的背景，定宽的内容" class="headerlink" title="满幅的背景，定宽的内容"></a>满幅的背景，定宽的内容</h2><p><a href="play.csssecrets.io/fluid-fixed">fluid-fixed</a></p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	top: 50%;</span><br><span class="line">	left: 50%;</span><br><span class="line">	transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">	width: 18em;</span><br><span class="line">	padding: 1em 1.5em;</span><br><span class="line">	margin: 50vh auto 0; // 这里不能使用50%，详细请了解包含快知识</span><br><span class="line">	transform: translateY(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br><span class="line">main &#123;</span><br><span class="line">	margin: auto; // 水平和垂直都可以居中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于-Flexbox-的解决方案（匿名容器）"><a href="#基于-Flexbox-的解决方案（匿名容器）" class="headerlink" title="基于 Flexbox 的解决方案（匿名容器）"></a>基于 Flexbox 的解决方案（匿名容器）</h3><p>PS：匿名容器即为没有被标签包裹的文本节点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	align-items: center;</span><br><span class="line">	justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="紧贴底部的页脚"><a href="#紧贴底部的页脚" class="headerlink" title="紧贴底部的页脚"></a>紧贴底部的页脚</h2><p>下列 header、main、footer 为 body 的子元素。</p>
<h3 id="固定高度的解决方案"><a href="#固定高度的解决方案" class="headerlink" title="固定高度的解决方案"></a>固定高度的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">	min-height: calc(100vh - footerHeight);</span><br><span class="line">	/* 避免内边距或边框搞乱高度的计算： */</span><br><span class="line">	box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex的解决方案"><a href="#flex的解决方案" class="headerlink" title="flex的解决方案"></a>flex的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	flex-flow: column;</span><br><span class="line">	min-height: 100vh;</span><br><span class="line">&#125;</span><br><span class="line">main &#123; </span><br><span class="line">	// 自动伸展并占满所有的可用空间</span><br><span class="line">	flex: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓动效果（动画和过渡）"><a href="#缓动效果（动画和过渡）" class="headerlink" title="缓动效果（动画和过渡）"></a>缓动效果（动画和过渡）</h2><p><a href="play.csssecrets.io/bounce">回弹动画</a><br><a href="play.csssecrets.io/elastic">弹性过渡</a><br>PS：对颜色过渡时小心，RGB 三个通道的值是独立进行插值运算的，在过渡过程中会产生其他颜色。<br>一般通过 transition-property 设置指定过渡属性来避免。</p>
<h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p>运动曲线适用性：贝塞尔曲线适用于平滑运动， steps(步进数, [start || end])适用于逐帧动画<br>PS：参数一为步进数（把动画分为多少步，然后在逐步运行），参数二用于指定动画在每个循环周期的什么位置发生帧的切换动作。<br><a href="play.csssecrets.io/frame-by-frame">逐帧动画</a></p>
<h3 id="闪烁效果"><a href="#闪烁效果" class="headerlink" title="闪烁效果"></a>闪烁效果</h3><p>animation-direction 属性定义是否循环交替反向播放动画。<br>reverse    动画反向播放。<br>alternate    动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。<br>alternate-reverse    动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。<br><a href="play.csssecrets.io/blink">闪烁效果</a></p>
<h3 id="打字动画"><a href="#打字动画" class="headerlink" title="打字动画"></a>打字动画</h3><p><a href="play.csssecrets.io/typing">打字动画</a></p>
<h3 id="状态平滑的动画"><a href="#状态平滑的动画" class="headerlink" title="状态平滑的动画"></a>状态平滑的动画</h3><p>animation–play-state 属性指定动画是否正在运行或已暂停。<br>paused    指定暂停动画<br>running    指定正在运行的动画<br><a href="play.csssecrets.io/state-animations">指定暂停动画</a></p>
<h2 id="first-letter"><a href="#first-letter" class="headerlink" title="::first-letter"></a>::first-letter</h2><p>定义：::first-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。</p>
<ol>
<li>::first-letter 伪元素生效的前提，常见的标点符号、各类括号和引号在::first-letter 伪元素眼中全部都是“辅助类”字符，不会作为第一个字符计算。</li>
<li>与::before使用（::before 若有字符，会参与计算及 伪类的 content 的字符会被::first-letter生效）。</li>
<li>::first-letter 伪元素可以生效的 CSS 属性有：字体属性、背景属性、color、padding、border、margin等。</li>
</ol>
<p>PS：“辅助类”包括·@#%&amp;<em>()（）[]【】{}:：”“”;；’‘’》《,，.。？?!！…</em>、/\。<br><a href="https://github.com/cubiq/iscroll/" target="_blank" rel="noopener">iScroll, smooth scrolling for the web</a></p>
<h2 id="CJK（中文-日文-韩文）两端对齐"><a href="#CJK（中文-日文-韩文）两端对齐" class="headerlink" title="CJK（中文/日文/韩文）两端对齐"></a>CJK（中文/日文/韩文）两端对齐</h2><p>text-align: justify;<br>text-justify: inter-ideograph;</p>
<h2 id="用户交互反馈（通用的按钮及连接交互反馈）"><a href="#用户交互反馈（通用的按钮及连接交互反馈）" class="headerlink" title="用户交互反馈（通用的按钮及连接交互反馈）"></a>用户交互反馈（通用的按钮及连接交互反馈）</h2><p>通用的连接和按钮交互反馈，原理为：background-color 总是在最底下的位置，所以这里的 background-image 一定是覆盖在按钮等元素背景色之上的，不会影响按钮原来的背景色。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[href]:active, button:active &#123;</span><br><span class="line">	background-image: linear-gradient(to top, rgba(0,0,0,.05), rgba(0,0,0,.05));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="script-标签"><a href="#script-标签" class="headerlink" title="script 标签"></a>script 标签</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，同时不渲染，不进行资源加载。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/html&quot;&gt;</span><br><span class="line">	&lt;img src=&quot;1.jpg&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>PS：script标签隐藏内容获取使用 script.innerHTML</p>
<h3 id="display-none-隐藏"><a href="#display-none-隐藏" class="headerlink" title="display:none 隐藏"></a>display:none 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但资源有加载，DOM 可访问。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.dn &#123;</span><br><span class="line">	display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="visibility-hidden-隐藏"><a href="#visibility-hidden-隐藏" class="headerlink" title="visibility: hidden 隐藏"></a>visibility: hidden 隐藏</h3><p>如果希望元素不可见，同时不占据空间，辅助设备无法访问，但显隐的时候可以有 transition 淡入淡出效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hidden &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果希望元素不可见，不能点击，辅助设备无法访问，但占据空间保留。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hidden &#123;</span><br><span class="line">	visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="clip-剪裁隐藏"><a href="#clip-剪裁隐藏" class="headerlink" title="clip 剪裁隐藏"></a>clip 剪裁隐藏</h3><p>如果希望元素不可见，不能点击，不占据空间，但键盘可访问。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clip &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	clip: rect(0 0 0 0);</span><br><span class="line">&#125;</span><br><span class="line">.out &#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	left: -999em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="relative-隐藏"><a href="#relative-隐藏" class="headerlink" title="relative 隐藏"></a>relative 隐藏</h3><p>如果希望元素不可见，不能点击，但占据空间，且键盘可访问。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.lower &#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="透明度隐藏"><a href="#透明度隐藏" class="headerlink" title="透明度隐藏"></a>透明度隐藏</h3><p>如果希望元素不可见，但可以点击，而且不占据空间，则可以使用透明度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.opacity &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	opacity: 0;</span><br><span class="line">	filter: Alpha(opacity=0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果单纯希望元素看不见，但位置保留，依然可以点可以选，则直接让透明度为 0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.opacity &#123;</span><br><span class="line">	opacity: 0;</span><br><span class="line">	filter: Alpha(opacity=0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：img元素，设置 display:none 在所有浏览器下依旧都会请求图片资源（浪费了宽带）。</p>
<h3 id="流向的改"><a href="#流向的改" class="headerlink" title="流向的改"></a>流向的改</h3><p>direction（改变水平流向）<br>unicode-bidi（文字流向）<br>writing-mode（改变 CSS 世界纵横规则）<br>writing-mode: lr-tb | tb-rl | tb-lr (IE8+);<br>writing-mode: horizontal-tb | vertical-rl | vertical-lr;</p>
<h2 id="1px边框（移动端）"><a href="#1px边框（移动端）" class="headerlink" title="1px边框（移动端）"></a>1px边框（移动端）</h2><h3 id="box-shadow-border-transform"><a href="#box-shadow-border-transform" class="headerlink" title="box-shadow/border + transform"></a>box-shadow/border + transform</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.border &#123;</span><br><span class="line">	width: 100%;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.border::after &#123;</span><br><span class="line">	content:&apos;&apos;;</span><br><span class="line">	position: absolute;</span><br><span class="line">	bottom: 0;left: 0;</span><br><span class="line">	width: 100%;</span><br><span class="line">	box-shadow: 0 0 0 1px red;</span><br><span class="line">	transform-origin: 0 bottom;</span><br><span class="line">	transform: scaleY(.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：还可以结合 @media (min-resolution: xdppx)做进一步处理。</p>
<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background-origin: padding-box; 默认<br>background-position: top 20px left 20px; 参照点为默认padding-box<br>background-size: x y;<br>圆锥渐变<br>background: conic-gradient(red, yellow, lime, aqua, blue, fuchsia, red);<br>background缩写语法<br>background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p>
<h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><ol>
<li>可以通过’/‘设置水平水平和垂直半径，如<code>border-radius: 100px / 75px;</code></li>
<li>它不仅可以接受长度值，还可以接受百分比值（这个百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。）。</li>
<li></li>
</ol>
<h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>指定元素内的空白怎样处理。<br>normal    默认。空白会被浏览器忽略。<br>pre    空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。<br>nowrap    文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。<br>pre-wrap    保留空白符序列，但是正常地进行换行。<br>pre-line    合并空白符序列，但是保留换行符。<br>inherit    规定应该从父元素继承 white-space 属性的值。</pre></p>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>line-height 的百分比时相对于 font-size 计算的。<br>vertical-align 的百分比时相对于 line-height 计算的。<br>ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。)<br>ch 数字 0 的宽度，使用场景（需要配合等宽字体）：全数字输入框：手机号等。<br>font-weight 运行原理：字体不同粗细需要字体文件是否存在该粗细的字体。<br>font-style  同样有效的前提为字体文件中存在该类型的字体，italic 和 oblique。<br>font-family: system-ui; // 让网页的字体跟系统走，，网站字体能时时刻刻与时俱进。<br>text-transform 属性控制文本的大小写，支持capitalize、uppercase、lowercase。<br>适用场景：身份证输入，最后以为X，帮助用户转为大写；验证码输入，帮助用户转为大写。<br>::backdrop CSS 伪元素 是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的内存管理（垃圾回收）</title>
    <url>/2018/JS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>在JS这门语言中，变量分为两种类型：基本类型（Undefined、Null、Boolean、Number 和String）和引用类型（Object、Array、Function等）。<br>对应存储内存又分为栈内存（Stack）和堆内存（Heap）。</p>
<h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>作用：存储基本类型的变量和存储引用类型的变量内存地址。<br>特点：这些基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。</p>
<h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>作用：实际存储引用类型的变量的值（通过和栈内存中保存的内存地址关联起来）。<br>特点：这种值的大小不固定（比如说一个Array的length是可以动态改变的，因此不知道其需要的内存大小），因此不能把它们保存到栈内存中。</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当已经不需要某块内存时这块内存不能被垃圾回收机制及时处理（间歇的不定期的寻找到不再使用的变量），并释放掉它们所指向的内存。</p>
<h2 id="常见的产生内存泄漏场景"><a href="#常见的产生内存泄漏场景" class="headerlink" title="常见的产生内存泄漏场景"></a>常见的产生内存泄漏场景</h2><ol>
<li>在声明变量没有带var、let、const等，它将直接挂载到全局上（即在浏览器中的window对象上），window对象上的属性及方法不会被回收。</li>
<li>盲目使用闭包（在闭包中存在对外部变量的引用，所以不会回收外部变量）</li>
<li>移除DOM节点是，没有清除对应的事件处理函数</li>
<li>没有及时清理定时器（没有清理setTimeout、setInterval等，就不能回收定时器的依赖）</li>
</ol>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="标记清除（常见）"><a href="#标记清除（常见）" class="headerlink" title="标记清除（常见）"></a>标记清除（常见）</h2><p>这是javascript中最常用的垃圾回收方式。当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。<br>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境所引用变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量不需要访问这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。<br>如何给对象添加标记？<br>反转特殊位或者添加对象列表</p>
<blockquote>
<p>  【2018-11-22看见优秀的文章，比较好的说明了JS内存机制】<br>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。<br><a href="https://juejin.im/post/5b10ba336fb9a01e66164346#comment" target="_blank" rel="noopener">JavaScript 内存机制</a></p>
</blockquote>
<h2 id="引用计数（早起IE机制）"><a href="#引用计数（早起IE机制）" class="headerlink" title="引用计数（早起IE机制）"></a>引用计数（早起IE机制）</h2><p>另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。<br>PS：该方式不能处理循环引用。</p>
<h1 id="排查内存泄漏"><a href="#排查内存泄漏" class="headerlink" title="排查内存泄漏"></a>排查内存泄漏</h1><p>通过控制面板 Performance 选中 Memory 查看 JS Heap（正常情况会有升有降）<br>通过查看 Main 了解主线程在各个时间段执行了那些函数来进行排查（所以避免在开发中写过多的匿名函数，不然你将看到很多anonymous function）<br>通过控制面板 Memory 选中 Heap snapshot 可以进行具体分析（快照有一个相互比较的功能，可能比较两个快照的差异）</p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>React-基础知识整理</title>
    <url>/2018/React-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h1 id="setState-一定是异步的吗？"><a href="#setState-一定是异步的吗？" class="headerlink" title="setState 一定是异步的吗？"></a>setState 一定是异步的吗？</h1><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是“同步”的。<br><a href="https://juejin.im/entry/5b45c6955188251abd7d14be" target="_blank" rel="noopener">你真的理解setState吗？</a></p>
<h1 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h1><p>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。<br>对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。<br>对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p>
<h2 id="Reconciliation-阶段"><a href="#Reconciliation-阶段" class="headerlink" title="Reconciliation 阶段"></a>Reconciliation 阶段</h2><p>componentWillMount<br>componentWillReceiveProps（使用 getDerivedStateFromProps 代替）<br>shouldComponentUpdate<br>componentWillUpdate</p>
<h2 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h2><p>componentDidMount<br>componentDidUpdate<br>componentWillUnmount<br><a href="https://yuchengkai.cn/docs/zh/frontend/react.html" target="_blank" rel="noopener">react</a></p>
<h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ExampleComponent extends React.Component &#123;</span><br><span class="line">  // 用于初始化 state</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用</span><br><span class="line">  // 因为该函数是静态函数，所以取不到 `this`</span><br><span class="line">  // 如果需要对比 `prevProps` 需要单独在 `state` 中维护</span><br><span class="line">  static getDerivedStateFromProps(nextProps, prevState) &#123;&#125;</span><br><span class="line">  // 判断是否需要更新组件，多用于组件性能优化</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  // 组件挂载后调用</span><br><span class="line">  // 可以在该函数中进行请求或者订阅</span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line">  // 用于获得最新的 DOM 数据</span><br><span class="line">  getSnapshotBeforeUpdate() &#123;&#125;</span><br><span class="line">  // 组件即将销毁</span><br><span class="line">  // 可以在此处移除订阅，定时器等等</span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line">  // 组件销毁后调用</span><br><span class="line">  componentDidUnMount() &#123;&#125;</span><br><span class="line">  // 组件更新后调用</span><br><span class="line">  componentDidUpdate() &#123;&#125;</span><br><span class="line">  // 渲染组件函数</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">  // 以下函数不建议使用</span><br><span class="line">  componentWillMount() &#123;&#125;</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">```	</span><br><span class="line">##	首次渲染触发的生命周期</span><br><span class="line">constructor()</span><br><span class="line">UNSAFE_componentWillMount()</span><br><span class="line">render()</span><br><span class="line">componentDidMount()</span><br><span class="line">##	非初次渲染触发的生命周期</span><br><span class="line">UNSAFE_componentWillReceiveProps(nextProps) </span><br><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br><span class="line">UNSAFE_componentWillUpdate()</span><br><span class="line">render()</span><br><span class="line">componentDidUpdate()</span><br><span class="line">##	其他什么周期函数</span><br><span class="line">componentWillUnmount()</span><br><span class="line">static getDerivedStateFromProps(nextProps, prevState) // 代替 componentWillReceiveProps 在初始化和 update 时触发，由于时静态方法无 this</span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) // 此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）与componentDidUpdate一起，这个新的生命周期将覆盖旧版componentWillUpdate的所有用例。</span><br><span class="line"></span><br><span class="line">#	React16.0中的portal</span><br><span class="line">作用：将子节点插入到父节点之外的dom（render到一个组件里面去，实际改变的是网页上另一处的DOM结构。）。</span><br><span class="line">使用场景：Modal、Dialog、Message等全局提示组件</span><br><span class="line">比如写一个Dialog通用组件</span><br></pre></td></tr></table></figure>
<p>import React from ‘react’;<br>import {createPortal} from ‘react-dom’;</p>
<p>class Dialog extends React.Component {<br>  constructor() {<br>    super(…arguments);</p>
<pre><code>const doc = window.document;
this.node = doc.createElement(&apos;div&apos;);
doc.body.appendChild(this.node);
</code></pre><p>  }</p>
<p>  render() {<br>    return createPortal(<br>      <div class="dialog"><br>        {this.props.children}<br>      </div>, //塞进传送门的JSX<br>      this.node //传送门的另一端DOM node<br>    );<br>  }</p>
<p>  componentWillUnmount() {<br>    window.document.body.removeChild(this.node);<br>  }<br>}<br><code>`</code><br><a href="https://zhuanlan.zhihu.com/p/29880992?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage" target="_blank" rel="noopener">React-DOM Portal</a></p>
<h1 id="React16新特性"><a href="#React16新特性" class="headerlink" title="React16新特性"></a>React16新特性</h1><h2 id="Error-Boundary（错误边界）"><a href="#Error-Boundary（错误边界）" class="headerlink" title="Error Boundary（错误边界）"></a>Error Boundary（错误边界）</h2><p>之前，一旦某个组件发生错误，整个组件树将会从根节点被unmount下来。<br>Error Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）<br>PS：最佳实践封装通用错误组件，用起包裹可能出错的组件，来捕获子组件可能发生的错误。</p>
<h2 id="render方法新增返回类型"><a href="#render方法新增返回类型" class="headerlink" title="render方法新增返回类型"></a>render方法新增返回类型</h2><p>render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。</p>
<h2 id="支持自定义DOM属性"><a href="#支持自定义DOM属性" class="headerlink" title="支持自定义DOM属性"></a>支持自定义DOM属性</h2><p>现在React可以将属性直接传递给DOM，不过有些写法任然无效。</p>
<h2 id="setState传入null时不会再触发更新"><a href="#setState传入null时不会再触发更新" class="headerlink" title="setState传入null时不会再触发更新"></a>setState传入null时不会再触发更新</h2><p>比如在一个选择城市的函数中，当点击某个城市时，newValue的值可能发生改变，也可能是点击了原来的城市，值没有变化，返回null则可以直接避免触发更新，不会引起重复渲染，不需要在shouldComponentUpdate函数里面去判断。<br><a href="https://www.jianshu.com/p/af0ae26eac18" target="_blank" rel="noopener">十分钟快速了解React16新特性</a></p>
<h1 id="React编码优化"><a href="#React编码优化" class="headerlink" title="React编码优化"></a>React编码优化</h1><ol>
<li>使用 key 属性为列表项组件做身份标记</li>
<li>shouldComponentUpdate 决定组件是否render</li>
<li>PureComponent 来定义组件</li>
<li>Stateless components 函数式组件</li>
<li>慎用bind，它会返回一个新的函数</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobx使用初探api</title>
    <url>/2018/Mobx%E4%BD%BF%E7%94%A8%E5%88%9D%E6%8E%A2api.html</url>
    <content><![CDATA[<h1 id="Mobx数据流"><a href="#Mobx数据流" class="headerlink" title="Mobx数据流"></a>Mobx数据流</h1><p>简单总结下Mobx常用api的使用<br><img src="https://cn.mobx.js.org/flow.png" alt="mobx数据流"></p>
<h1 id="可观察数据"><a href="#可观察数据" class="headerlink" title="可观察数据"></a>可观察数据</h1><h2 id="Array、Object、Map、"><a href="#Array、Object、Map、" class="headerlink" title="Array、Object、Map、"></a>Array、Object、Map、</h2><p>Observable // 将一个数据变成可观察数据（数组不是真正的数组）<br>extendObservable() // 将动态添加的数据变为可观察（对象）</p>
<h2 id="String、Number、Boolean"><a href="#String、Number、Boolean" class="headerlink" title="String、Number、Boolean"></a>String、Number、Boolean</h2><p>如果是方法的还需要observable.box来修饰<br>调用get和set方法可以访问和修改原始类型值</p>
<h1 id="对可观察数据做出的反应"><a href="#对可观察数据做出的反应" class="headerlink" title="对可观察数据做出的反应"></a>对可观察数据做出的反应</h1><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>可以根据多个可观察数据产生一个新的可观察数据</p>
<h2 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h2><p>自动追踪可观察数据，当在可观察数据发生变化时执行（会初始化执行一次）</p>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>当第一个参数为true，执行第二个参数方法</p>
<h2 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a>reaction</h2><p>它接收两个函数参数，第一个(数据函数)是用来追踪并返回数据作为第二个函数(效果 函数)的输入</p>
<h1 id="修改可观察数据"><a href="#修改可观察数据" class="headerlink" title="修改可观察数据"></a>修改可观察数据</h1><p>action<br>action.bound // 多一个功能绑定this<br>runInAction<br>将多次可观察数据的改变合并到一次触发（优化性能）</p>
<h1 id="mobx-react"><a href="#mobx-react" class="headerlink" title="mobx-react"></a>mobx-react</h1><p>import {PropTypes as mobxPropTypes} from ‘mobs-react’;<br>给UI组件使用 @observer // 把react组件的render方法包装成autorun</p>
<h1 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h1><h2 id="import-intercept-observe-from-‘mobx’"><a href="#import-intercept-observe-from-‘mobx’" class="headerlink" title="import {intercept, observe} from ‘mobx’;"></a>import {intercept, observe} from ‘mobx’;</h2><p>observe 和 intercept 可以用来监测单个 observable(它们不追踪嵌套的 observable) 的变化。<br>intercept 可以在变化作用于 observable 之前监测和修改变化。 observe 允许你在 observable 变化之后拦截改变。</p>
<h2 id="toJS"><a href="#toJS" class="headerlink" title="toJS"></a>toJS</h2><p>递归地将一个(observable)对象转换为 javascript 结构。<br>支持 observable 数组、对象、映射和原始类型。 </p>
<h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h2><p>spy(listener). 注册一个全局间谍监听器，用来监听所有 MobX 中的事件。</p>
<h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>trace 是一个小工具，它能帮助你查找为什么计算值、 reactions 或组件会重新计算。</p>
<h1 id="mobx提升性能法则"><a href="#mobx提升性能法则" class="headerlink" title="mobx提升性能法则"></a>mobx提升性能法则</h1><p>细粒度拆分视图组件<br>使用专用组件处理列表<br>尽可能晚地解构可观察数据</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Mobx</tag>
      </tags>
  </entry>
  <entry>
    <title>Web实验性知识</title>
    <url>/2018/Web%E5%AE%9E%E9%AA%8C%E6%80%A7%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h1 id="伪类-placeholder-shown"><a href="#伪类-placeholder-shown" class="headerlink" title="伪类:placeholder-shown"></a>伪类:placeholder-shown</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CSS 伪类在 input 或 textarea 元素显示 placeholder text 时生效。<br>PS：可以配合 :not() 伪类等配合，优化表单。</p>
<h1 id="伪-focus-within"><a href="#伪-focus-within" class="headerlink" title="伪:focus-within"></a>伪:focus-within</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>CSS 伪类，表示一个元素获得焦点或该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配:focus伪类。<br><a href="https://github.com/chokcoco/iCSS/issues/36" target="_blank" rel="noopener">神奇的选择器 :focus-within</a></p>
<h1 id="display-contents"><a href="#display-contents" class="headerlink" title="display:contents"></a>display:contents</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>元素本身不产生任何边界框，而元素的子元素与伪元素仍然生成边界框，元素文字照常显示。为了同时照顾边界框与布局，处理这个元素时，要想象这个元素不在元素树型结构里，而只有内容留下。这包括元素在原文档中的子元素与伪元素，比如::before和::after这两个伪元素，如平常一样，前者仍然在元素子元素之前生成，后者在之后生成。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown" target="_blank" rel="noopener">MDN-placeholder-shown</a><br><a href="https://zhuanlan.zhihu.com/p/40736286" target="_blank" rel="noopener">五个最新的CSS特性以及如何使用它们</a></p>
<h1 id="contain"><a href="#contain" class="headerlink" title="contain"></a>contain</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain" target="_blank" rel="noopener">MDN-contain</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>html,css,js</tag>
      </tags>
  </entry>
  <entry>
    <title>Web性能优化</title>
    <url>/2018/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content><![CDATA[<h1 id="页面渲染的4个关键指示"><a href="#页面渲染的4个关键指示" class="headerlink" title="页面渲染的4个关键指示"></a>页面渲染的4个关键指示</h1><h2 id="First-Paint（FP）"><a href="#First-Paint（FP）" class="headerlink" title="First Paint（FP）"></a>First Paint（FP）</h2><p>仅有一个需要挂载的根节点。</p>
<h2 id="First-Contentful-Paint（FCP）"><a href="#First-Contentful-Paint（FCP）" class="headerlink" title="First Contentful Paint（FCP）"></a>First Contentful Paint（FCP）</h2><p>包含页面的基本框架，但没有数据内容。</p>
<h2 id="First-Meaningful（FMP）"><a href="#First-Meaningful（FMP）" class="headerlink" title="First Meaningful（FMP）"></a>First Meaningful（FMP）</h2><p>包含页面所有元素及数据。</p>
<h2 id="Time-to-Interactive（TTI）"><a href="#Time-to-Interactive（TTI）" class="headerlink" title="Time to Interactive（TTI）"></a>Time to Interactive（TTI）</h2><p>允许交互时间。</p>
<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><h2 id="DNS-prefetch"><a href="#DNS-prefetch" class="headerlink" title="DNS prefetch"></a>DNS prefetch</h2><p>DNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。<br><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</code></p>
<h2 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h2><p>和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。<br><code>&lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt;</code></p>
<h2 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h2><p>当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用，prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。<br><code>&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;</code><br>PS：可以解决字体文件必须等DOM和CSSOM创建好后才能下载的性能瓶颈。</p>
<h2 id="Subresource"><a href="#Subresource" class="headerlink" title="Subresource"></a>Subresource</h2><p>可以用来指定资源是最高优先级的。<br><code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code><br>PS：rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。</p>
<h2 id="Prerender"><a href="#Prerender" class="headerlink" title="Prerender"></a>Prerender</h2><p>prerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。<br>一些适用场景用户搜索后的结果页面、登录成功后的页面、多页文章（预先加载下一页的资源）<br><code>&lt;link rel=&quot;prerender&quot;  href=&quot;/thenextpage.html&quot; /&gt;</code><br>PS：该属性会下载所有的资源、创建DOM、渲染页面、执行JS<a href="https://www.w3.org/TR/page-visibility/" target="_blank" rel="noopener">这篇文章可以防止页面还没有展示给用户就出发JS的执行</a>等等。</p>
<h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源。<br><code>&lt;link rel=&quot;preload&quot; href=&quot;image.png&quot;&gt;</code><br><a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/" target="_blank" rel="noopener">AlloyTeam-一箩筐的预加载技术</a></p>
<h1 id="微任务（jobs）和宏任务（task）"><a href="#微任务（jobs）和宏任务（task）" class="headerlink" title="微任务（jobs）和宏任务（task）"></a>微任务（jobs）和宏任务（task）</h1><p>微任务包括：process.nextTick，原生Promise(有些实现的promise将then方法放到了宏任务中)，Object.observe(已废弃)，MutationObserver<br>宏任务包括：script，setTimeout，setInterval，setImmediate，I/O ，UI rendering，MessageChannel </p>
<h1 id="如何生成新图层（避免重排影响其他图层）"><a href="#如何生成新图层（避免重排影响其他图层）" class="headerlink" title="如何生成新图层（避免重排影响其他图层）"></a>如何生成新图层（避免重排影响其他图层）</h1><p>通过以下几个常用属性可以生成新图层<br>3D 变换：translate3d、translateZ<br>will-change<br>video、iframe 标签<br>通过动画实现的 opacity 动画转换<br>position: fixed</p>
<h1 id="React-16-加载性能优化"><a href="#React-16-加载性能优化" class="headerlink" title="React 16 加载性能优化"></a>React 16 加载性能优化</h1><p><a href="https://juejin.im/entry/5b506b315188251b24382faa" target="_blank" rel="noopener">React 16 加载性能优化指南</a></p>
<h1 id="CSS性能优化技巧"><a href="#CSS性能优化技巧" class="headerlink" title="CSS性能优化技巧"></a>CSS性能优化技巧</h1><h2 id="内联首屏关键CSS（Critical-CSS）"><a href="#内联首屏关键CSS（Critical-CSS）" class="headerlink" title="内联首屏关键CSS（Critical CSS）"></a>内联首屏关键CSS（Critical CSS）</h2><p>即为只将渲染首屏内容所需的关键CSS内联到HTML中。<br><a href="https://github.com/filamentgroup/criticalCSS" target="_blank" rel="noopener">github-首屏的关键样式提取</a></p>
<h2 id="异步加载CSS（四种方式）"><a href="#异步加载CSS（四种方式）" class="headerlink" title="异步加载CSS（四种方式）"></a>异步加载CSS（四种方式）</h2><p>第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。<br>第二种方式是将link元素的media属性设置为用户浏览器不匹配的媒体类型甚至不存在的类型都可以，对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。<br>`</p>
<p><link rel="stylesheet" href="mystyles.css" media="noexist" onload="this.media='all'"><br><code>第三种方式是通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。</code></p>
<p><link rel="alternate stylesheet" href="mystyles.css" onload="this.rel='stylesheet'"><br><code>第四中方式是rel=”preload”5这一Web标准指出了如何异步加载资源，包括CSS类资源。</code></p>
<p><link rel="preload" href="mystyles.css" as="style" onload="this.rel='stylesheet'"><br>`<br>PS：第四中为标准方案，as 属性是必须的。</p>
<h2 id="去除无用CSS"><a href="#去除无用CSS" class="headerlink" title="去除无用CSS"></a>去除无用CSS</h2><p><a href="https://github.com/uncss/uncss" target="_blank" rel="noopener">github-去除无用CSS</a></p>
<h2 id="有选择地使用选择器"><a href="#有选择地使用选择器" class="headerlink" title="有选择地使用选择器"></a>有选择地使用选择器</h2><p>CSS选择器的匹配是从右向左进行的。</p>
<h1 id="如何启用GPU硬件加速"><a href="#如何启用GPU硬件加速" class="headerlink" title="如何启用GPU硬件加速"></a>如何启用GPU硬件加速</h1><h2 id="什么情况形成新的层-layer？（作用为重绘时只影响该层，不影响层外的元素。）"><a href="#什么情况形成新的层-layer？（作用为重绘时只影响该层，不影响层外的元素。）" class="headerlink" title="什么情况形成新的层 layer？（作用为重绘时只影响该层，不影响层外的元素。）"></a>什么情况形成新的层 layer？（作用为重绘时只影响该层，不影响层外的元素。）</h2><ol>
<li>3D 或者 CSS的transform属性</li>
<li>video 和 canvas 元素</li>
<li>CSS的filter属性</li>
<li>覆盖在其它元素之上的元素，比如通过z-index提升层级</li>
</ol>
<h2 id="哪些属性直接在GPU处理？"><a href="#哪些属性直接在GPU处理？" class="headerlink" title="哪些属性直接在GPU处理？"></a>哪些属性直接在GPU处理？</h2><p>transform<br>opacity<br>filter<br>transform: translateZ(0); // 可以强制GPU渲染</p>
<h2 id="使用硬件加速需要注意的地方？"><a href="#使用硬件加速需要注意的地方？" class="headerlink" title="使用硬件加速需要注意的地方？"></a>使用硬件加速需要注意的地方？</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>GPU处理过多的内容会导致内存问题。这在移动端和移动端浏览器会导致崩溃。因此，通常不会对所有的元素使用硬件加速。</p>
<h3 id="Font-rendering"><a href="#Font-rendering" class="headerlink" title="Font rendering"></a>Font rendering</h3><p>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p>
<h3 id="浏览器的优化"><a href="#浏览器的优化" class="headerlink" title="浏览器的优化"></a>浏览器的优化</h3><p>通常配合will-change属性使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.example &#123;</span><br><span class="line">	transform: rotate(1turn);</span><br><span class="line">	will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：这个功能允许你告诉浏览器这个属性会发生变化，因此浏览器会在开始之前对其进行优化。<br><a href="https://juejin.im/post/5b6143996fb9a04fd343ae28" target="_blank" rel="noopener">在 CSS 动画中使用硬件加速</a></p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>dom接口</title>
    <url>/2018/dom%E6%8E%A5%E5%8F%A3.html</url>
    <content><![CDATA[<h1 id="CustomEvent"><a href="#CustomEvent" class="headerlink" title="CustomEvent"></a>CustomEvent</h1><p>创建一个自定义事件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加一个适当的事件监听器</span><br><span class="line">obj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;)</span><br><span class="line"></span><br><span class="line">// 创建一个自定义事件</span><br><span class="line">var event = new CustomEvent(&quot;cat&quot;, &#123;&quot;detail&quot;:&#123;&quot;hazcheeseburger&quot;:true&#125;&#125;)</span><br><span class="line">// 分发事件</span><br><span class="line">obj.dispatchEvent(event)</span><br></pre></td></tr></table></figure></p>
<h1 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h1><p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。<br>DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。</p>
<h2 id="创建一个DocumentFragment"><a href="#创建一个DocumentFragment" class="headerlink" title="创建一个DocumentFragment"></a>创建一个DocumentFragment</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ul = document.querySelector(`[data-uid=&quot;ul&quot;]`);</span><br><span class="line">let frag = document.createDocumentFragment();</span><br><span class="line">const list = [</span><br><span class="line">	&apos;IE&apos;,</span><br><span class="line">	&apos;Chrome&apos;</span><br><span class="line">];</span><br><span class="line">list.forEach(item =&gt; &#123;</span><br><span class="line">	let li = document.creteElement(&apos;li&apos;);</span><br><span class="line">	li.textContent = item;</span><br><span class="line">	frag.appendChild(li);</span><br><span class="line">&#125;);</span><br><span class="line">// 只进行一次dom操作，触发一次reflow</span><br><span class="line">ul.appendChild(frag);</span><br><span class="line">```	</span><br><span class="line">##	其他方法（实例方法）</span><br></pre></td></tr></table></figure>
<p>documentFragment.find()<br>返回 DocumentFragment 树里第一个匹配的元素 Element 。<br>documentFragment.findAll()<br>返回 DocumentFragment 树里所有匹配的元素  NodeList。<br>documentFragment.querySelector()<br>documentFragment.querySelectorAll()<br>documentFragment.getElementById()<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#	MutationObserver</span><br><span class="line">给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</span><br><span class="line">##	实例方法</span><br><span class="line">observe()</span><br><span class="line">给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.</span><br><span class="line">disconnect()</span><br><span class="line">让该观察者对象停止观察指定目标的DOM变化.即使再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.</span><br><span class="line">takeRecords()</span><br><span class="line">清空观察者对象的记录队列,并返回里面的内容.</span><br><span class="line">##	示例</span><br></pre></td></tr></table></figure></p>
<p>let target = document.querySelector(‘#some-id’);</p>
<p>// 创建观察者对象<br>let observer = new MutationObserver(function(mutations) {<br>  mutations.forEach(function(mutation) {<br>    console.log(mutation.type);<br>  });<br>});</p>
<p>// 配置观察选项:<br>let config = { attributes: true, childList: true, characterData: true }</p>
<p>// 传入目标节点和观察选项<br>observer.observe(target, config);</p>
<p>// 随后,你还可以停止观察<br>observer.disconnect();<br><code>`</code></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Web知识</title>
    <url>/2018/Web%E6%9C%AF%E8%AF%AD.html</url>
    <content><![CDATA[<p>本文所有知识点，点到即止，详细内容请看各部分的连接。</p>
<h2 id="点击穿透（多见于移动端模态框等浮层）"><a href="#点击穿透（多见于移动端模态框等浮层）" class="headerlink" title="点击穿透（多见于移动端模态框等浮层）"></a>点击穿透（多见于移动端模态框等浮层）</h2><p>产生：上层元素触发touch事件-&gt;上层元素消失（300ms之内）-&gt;底层元素click事件触发<br>PS：touch事件之后会有300ms延迟在执行click事件是因为，在这300ms中若再次tap行为则认定为double tap事件，否则就触发click事件。<br>方案：只用touch事件、只用click事件（不推荐）、fastclick类库等<br><a href="https://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="noopener">点击穿透原理及解决</a></p>
<h2 id="CSP（内容安全策略Content-Security-Policy）"><a href="#CSP（内容安全策略Content-Security-Policy）" class="headerlink" title="CSP（内容安全策略Content-Security-Policy）"></a>CSP（内容安全策略Content-Security-Policy）</h2><p>定义：内容安全策略 (Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="noopener">CSP 策略指令</a></p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>定义：CORS (跨域资源共享)是一个系统, 包括传输的 HTTP headers, 其确定是否阻止或完成从该资源所在的域外的另一个域的网页上的受限资源的请求。<br>PS：同源安全策略( same-origin security policy)默认禁止“跨域”请求. CORS 给予Web服务器跨域访问控制, 启用安全的跨域数据传输。<br><a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" target="_blank" rel="noopener">CORS</a></p>
<h2 id="BFC（块格式化上下文Block-Formatting-Context）"><a href="#BFC（块格式化上下文Block-Formatting-Context）" class="headerlink" title="BFC（块格式化上下文Block Formatting Context）"></a>BFC（块格式化上下文Block Formatting Context）</h2><p>定义：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br>如何触发BFC：<br>• html 根元素；<br>• float 的值不为 none；<br>• overflow 的值为 auto、scroll 或 hidden；<br>• display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；<br>• position 的值不为 relative 和 static。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">块格式化上下文</a></p>
<h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p>CRLF实际上是两个字符：CR是Carriage Return（ASCII 13，\r），LF是Line Feed（ASCII 10，\n）。<br>\r\n这两个字符是用于表示换行的，其十六进制编码分别为 0x0d、0x0a。</p>
<h2 id="containing-block（包含块）"><a href="#containing-block（包含块）" class="headerlink" title="containing block（包含块）"></a>containing block（包含块）</h2><p>定义：在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。<br>PS：主要作用是以百分比（相关于包含块）计算自身的width、height、top、left、padding、margin等css Layout 属性。<br><a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">我所了解的CSS包含块</a>    </p>
<h2 id="FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）"><a href="#FOUC（无样式内容闪烁Flash-Of-Unstyled-Content）" class="headerlink" title="FOUC（无样式内容闪烁Flash Of Unstyled Content）"></a>FOUC（无样式内容闪烁Flash Of Unstyled Content）</h2><p>定义：指的是加载网页时出现的短暂的CSS样式失效。<br>方案：head头部放css、避免使用import<br><a href="https://www.cnblogs.com/fsjohnhuang/p/6739064.html" target="_blank" rel="noopener">FOUC</a></p>
<h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>定义：由于不同的浏览器对CSS的支持程度不同，同样CSS的样式代码在不同浏览器当中的表现可能出现不一致。为了让所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。<br>方案：属性前缀法、选择器前缀法、条件注释法（<!--[if lt IE 8]-->）</p>
<h2 id="Domain-Name（域名）"><a href="#Domain-Name（域名）" class="headerlink" title="Domain Name（域名）"></a>Domain Name（域名）</h2><p>域名（英语：Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>顶级域名又称为跟域名（TLD）共1058+（.com、.net、.cn等等）<br>13个根域名服务器（不代表只有13台服务器，事实上517+台服务器）</p>
<h2 id="DNS（网域名称系统Domain-Name-System）"><a href="#DNS（网域名称系统Domain-Name-System）" class="headerlink" title="DNS（网域名称系统Domain Name System）"></a>DNS（网域名称系统Domain Name System）</h2><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<h2 id="a链接问题"><a href="#a链接问题" class="headerlink" title="a链接问题"></a>a链接问题</h2><p>a链接使用绑定 mousedown 事件且 event.preventDefault() 会导致 :active 伪类失效（Firefox）。<br>PS：Firefox 认为 mousedown 事件在 :active 之前发生。</p>
<h2 id="min-width、max-width、width、-important优先级"><a href="#min-width、max-width、width、-important优先级" class="headerlink" title="min-width、max-width、width、!important优先级"></a>min-width、max-width、width、!important优先级</h2><p>如果min-width、max-width、width、!important同时存在时，优先级顺序：min-width &gt;&gt; max-width &gt;&gt; !important &gt;&gt; width</p>
<h2 id="巧用css-兄弟选择器（如导航分割线）"><a href="#巧用css-兄弟选择器（如导航分割线）" class="headerlink" title="巧用css 兄弟选择器（如导航分割线）"></a>巧用css 兄弟选择器（如导航分割线）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;</span><br><span class="line">// 这样排除第一个元素</span><br><span class="line">a + a:before &#123;</span><br><span class="line">	content: &quot;&quot;;</span><br><span class="line">	font-size: 0;</span><br><span class="line">	padding: 10px 3px 1px;</span><br><span class="line">	margin-left: 6px;</span><br><span class="line">	border-left: 1px solid gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="img-在firefox和其他浏览器的差异"><a href="#img-在firefox和其他浏览器的差异" class="headerlink" title="img 在firefox和其他浏览器的差异"></a>img 在firefox和其他浏览器的差异</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">	// width 和 height 无效，需要设置display: inline-block;</span><br><span class="line">	width: xx;</span><br><span class="line">	height: xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于百分比设置下列属性"><a href="#关于百分比设置下列属性" class="headerlink" title="关于百分比设置下列属性"></a>关于百分比设置下列属性</h2><p>left（right）、width、padding、margin、background-position、text-index设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>的width值<br>top（bottom）、height设置值为百分比时，其计算基准为<a href="https://fanerge.github.io/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html">包含块</a>height值</p>
<h2 id="滚动容器底部留白"><a href="#滚动容器底部留白" class="headerlink" title="滚动容器底部留白"></a>滚动容器底部留白</h2><p>滚动容器底部留白使用 margin-bottom，使用 padding-bottom 存在兼容性问题。</p>
<h2 id="margin-合并（只存在垂直方向）"><a href="#margin-合并（只存在垂直方向）" class="headerlink" title="margin 合并（只存在垂直方向）"></a>margin 合并（只存在垂直方向）</h2><ol>
<li>相邻兄弟元素 margin 合并。</li>
<li>父级和第一个、父级和最后一个子元素。（虽然是在子元素上设置的 margin-top，但实际上就等同于在父元素上设置了 margin-top）</li>
<li>空块级元素的 margin 合并。</li>
</ol>
<p>PS：合并规则，正正取大值，正负值相加，负负最小值。</p>
<h2 id="margin-auto-的理解"><a href="#margin-auto-的理解" class="headerlink" title="margin: auto;的理解"></a>margin: auto;的理解</h2><p>margin: auto; 表示对剩余空白进行分配。<br>下面元素 .son 的 margin-left 为 300 - 200 -80 = 20px<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">	width: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	margin-right: 80px;</span><br><span class="line">	margin-left: auto; // 20px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 margin 来进行 right 对齐<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">	width: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	margin-left: auto; // 此时 auto 值为100px</span><br><span class="line">	// flot: right; 等价</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：块级元素的左中右对齐使用 margin ，内联元素使用 text-align 控制左中右对戏。<br>水平和垂直居中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">	width: 300px; height:150px;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">	position: absolute; // 很关键</span><br><span class="line">	top: 0; right: 0; bottom: 0; left: 0;</span><br><span class="line">	width: 200px; height: 100px;</span><br><span class="line">	margin: auto; // 很关键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="border-的一些秘密"><a href="#border-的一些秘密" class="headerlink" title="border 的一些秘密"></a>border 的一些秘密</h2><p>border-width 不支持百分比值（outline、box-shadow、text-shadow同样）<br>border-style:double 至少 3px 才有效果。<br>border-style:dashed 不同浏览器不一致（虚线颜色区的宽高比以及颜色区和透明区的宽度比例），如chrome上为方形ie为圆形。<br>thin（1px）、medium（默认值3px）、thick（4px）。</p>
<h2 id="border-技巧"><a href="#border-技巧" class="headerlink" title="border 技巧"></a>border 技巧</h2><p>等腰三角形<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	width: 0;</span><br><span class="line">	border-width: 10px 20px;</span><br><span class="line">	border-style: solid;</span><br><span class="line">	border-color: #f30 transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直角三角形<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	width: 0;</span><br><span class="line">	border-width: 10px 20px;</span><br><span class="line">	border-style: solid;</span><br><span class="line">	border-color: #f30 #f30 transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>边框 3D 效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	width: 10px; height: 10px;</span><br><span class="line">	border: 10px solid;</span><br><span class="line">	border-color: #f30 #00f #396 #0f0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/xiaohuochai/p/5457127.html" target="_blank" rel="noopener">等高布局</a></p>
<h2 id="css-度量单位-ex"><a href="#css-度量单位-ex" class="headerlink" title="css 度量单位 ex"></a>css 度量单位 ex</h2><p>相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。<br>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>作用：基于ex单位的天然垂直居中对齐效果</p>
<h2 id="行距"><a href="#行距" class="headerlink" title="行距"></a>行距</h2><p>行距 = line-height - font-size</p>
<h2 id="line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？"><a href="#line-height-1-5、line-height-150-和-line-height-1-5em-表现一样，为什么重置css时只能用第一种呢？" class="headerlink" title="line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？"></a>line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？</h2><p>因为继承细节有所差别，如果使用数值作为 line-height 的属性值，那么所有的子元素继承的都是这个值（如1.5）；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值（16px*150%=24px，此时继承的就是24px这个值，不是150%）。</p>
<h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>作用：只能应用于内联元素以及 display 值为 table-cell 的元素。<br>定义：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。<br>线类，如 baseline（默认值）、top、middle、bottom；<br>文本类，如 text-top、text-bottom；<br>上标下标类，如 sub、super；<br>数值百分比类，如 20px、2em、20%等<br>PS：其实middle为基线往上 1/2 x-height 处（ x-height 为 x 的高度）</p>
<h2 id="消除图片下间隙"><a href="#消除图片下间隙" class="headerlink" title="消除图片下间隙"></a>消除图片下间隙</h2><ol>
<li>display:block;</li>
<li>vertical-align:top; // top，text-top，bottom，text-bottom 均可</li>
<li>font-size:0; // 父级设置</li>
<li>overflow:hidden;</li>
<li>float:left;</li>
</ol>
<p><a href="http://www.cnblogs.com/luojianqun/archive/2013/07/08/3177969.html" target="_blank" rel="noopener">CSS图片下面产生间隙的6种解决方案</a></p>
<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>规范约定了浮动元素和内联元素在一行显示。<br>浮动元素会生成一个块级框，而不论它本身是何种元素。</p>
<h2 id="clip属性"><a href="#clip属性" class="headerlink" title="clip属性"></a>clip属性</h2><p>fixed 固定定位的剪裁<br>最佳可访问性隐藏（clip: rect(0,0,0,0)）</p>
<h2 id="stacking-context（层叠上下文）"><a href="#stacking-context（层叠上下文）" class="headerlink" title="stacking context（层叠上下文）"></a>stacking context（层叠上下文）</h2><p>层叠上下文，英文称作 stacking context，是 HTML 中的一个三维的概念。</p>
<h3 id="层叠水平（stacking-level-（逐渐升高）"><a href="#层叠水平（stacking-level-（逐渐升高）" class="headerlink" title="层叠水平（stacking level)（逐渐升高）"></a>层叠水平（stacking level)（逐渐升高）</h3><ol>
<li>层叠上下文（background/border） – 充当背景色</li>
<li>负的z-index</li>
<li>block块状水平盒子 – 布局</li>
<li>float浮动盒子</li>
<li>inline水平盒子（inline/inline-block/inline-table） – 内容</li>
<li>z-index:anto 或 看成 z-index:0</li>
<li>正的z-index</li>
</ol>
<p>一般情况都会满足满足上面的规则，详情可以看下面demo：</p>
<p></p><p data-height="265" data-theme-id="dark" data-slug-hash="pKverE" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/pKverE/" target="_blank" rel="noopener">stackingContext</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="noopener">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="如何触发一个元素形成堆叠上下文？"><a href="#如何触发一个元素形成堆叠上下文？" class="headerlink" title="如何触发一个元素形成堆叠上下文？"></a>如何触发一个元素形成堆叠上下文？</h3><ol>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ol>
<p>PS：使用了上述属性就会形成一个stacking context（堆叠上下文）。此时，要对两者进行层叠排列，就需要 z-index ，z-index 越高的层叠层级越高。<br>做了一个上述情况的demo：</p>
<p></p><p data-height="265" data-theme-id="dark" data-slug-hash="JZoWWp" data-default-tab="css,result" data-user="fanerge" data-embed-version="2" data-pen-title="stackingContext2" class="codepen">See the Pen <a href="https://codepen.io/fanerge/pen/JZoWWp/" target="_blank" rel="noopener">stackingContext2</a> by 余真帆 (<a href="https://codepen.io/fanerge" target="_blank" rel="noopener">@fanerge</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><a href="https://www.cnblogs.com/coco1s/p/5899089.html" target="_blank" rel="noopener">层叠顺序与堆栈上下文知多少</a></p>
<h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。<br><a href="https://segmentfault.com/a/1190000014457824" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></p>
<h2 id="敏捷开发的原则编辑"><a href="#敏捷开发的原则编辑" class="headerlink" title="敏捷开发的原则编辑"></a>敏捷开发的原则编辑</h2><h3 id="快速迭代"><a href="#快速迭代" class="headerlink" title="快速迭代"></a>快速迭代</h3><p>相对那种半年一次的大版本发布来说，小版本的需求、开发和测试更加简单快速。一些公司，一年发布仅2~3个版本，发布流程缓慢，它们仍采用瀑布开发模式，更严重的是对敏捷开发模式存在误解。</p>
<h3 id="让测试人员和开发者参与需求讨论"><a href="#让测试人员和开发者参与需求讨论" class="headerlink" title="让测试人员和开发者参与需求讨论"></a>让测试人员和开发者参与需求讨论</h3><p>需求讨论以研讨组的形式展开最有效率。研讨组，需要包括测试人员和开发者，这样可以更加轻松定义可测试的需求，将需求分组并确定优先级。 同时，该种方式也可以充分利用团队成员间的互补特性。如此确定的需求往往比开需求讨论大会的形式效率更高，大家更活跃，参与感更强。</p>
<h3 id="编写可测试的需求文档"><a href="#编写可测试的需求文档" class="headerlink" title="编写可测试的需求文档"></a>编写可测试的需求文档</h3><p>开始就要用“用户故事”（User Story）的方法来编写需求文档。这种方法，可以让我们将注意力放在需求上，而不是解决方法和实施技术上。过早的提及技术实施方案，会降低对需求的注意力。</p>
<h3 id="多沟通，尽量减少文档"><a href="#多沟通，尽量减少文档" class="headerlink" title="多沟通，尽量减少文档"></a>多沟通，尽量减少文档</h3><p>任何项目中，沟通都是一个常见的问题。好的沟通，是敏捷开发的先决条件。在圈子里面混得越久，越会强调良好高效的沟通的重要性。<br>团队要确保日常的交流，面对面沟通比邮件强得多。</p>
<h3 id="做好产品原型"><a href="#做好产品原型" class="headerlink" title="做好产品原型"></a>做好产品原型</h3><p>建议使用草图和模型来阐明用户界面。并不是所有人都可以理解一份复杂的文档，但人人都会看图。</p>
<h3 id="及早考虑测试"><a href="#及早考虑测试" class="headerlink" title="及早考虑测试"></a>及早考虑测试</h3><p>及早地考虑测试在敏捷开发中很重要。传统的软件开发，测试用例很晚才开始写，这导致过晚发现需求中存在的问题，使得改进成本过高。较早地开始编写测试用例，当需求完成时，可以接受的测试用例也基本一块完成了。 </p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas开发参考手册</title>
    <url>/2018/canvas%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html</url>
    <content><![CDATA[<p><iframe src="https://fanerge.github.io/canvas_solar_system/" width="700" height="350" frameborder="0"></iframe></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://fanerge.github.io/canvas_solar_system/">学完canvas的相关知识可以做一些小动画了</a><br>最早由Apple引入WebKit，用于Mac OS X 的 Dashboard。<br>canvas 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，交互式游戏，甚至可以进行实时视频处理或渲染。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>canvas 它是一个元素，当然具有元素通用的属性，如id、class等。</p>
<h2 id="渲染上下文（The-rendering-context）"><a href="#渲染上下文（The-rendering-context）" class="headerlink" title="渲染上下文（The rendering context）"></a>渲染上下文（The rendering context）</h2><p>canvas 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取渲染上下文</span><br><span class="line">let canvas = document.querySelector(&apos;#canvas&apos;)</span><br><span class="line">let ctx = canvas.getContext(&apos;2d&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="检查支持性"><a href="#检查支持性" class="headerlink" title="检查支持性"></a>检查支持性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (canvas.getContext) &#123;</span><br><span class="line">	// 支持</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	// 不支持</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h1><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p>fillRect(x, y, width, height)<br>    绘制一个填充的矩形<br>strokeRect(x, y, width, height)<br>    绘制一个矩形的边框<br>clearRect(x, y, width, height)<br>    清除指定矩形区域，让清除部分完全透明。<br>    常用于清理画布。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p>
<ol>
<li>首先，你需要创建路径起始点。</li>
<li>然后你使用画图命令去画出路径。</li>
<li>之后你把路径封闭。</li>
<li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。<br>beginPath()<br>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br>closePath()<br>闭合路径之后图形绘制命令又重新指向到上下文中。<br>stroke() – 轮廓<br>通过线条来绘制图形轮廓。<br>fill() – 整体<br>通过填充路径的内容区域生成实心的图形。<br>PS：fill会自动闭合儿stroke不会。<br>moveTo(x, y) – 移动笔触<br>将笔触移动到指定的坐标x以及y上。<br>当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径<br>lineTo(x, y) – 直线<br>绘制一条从当前位置到指定x以及y位置的直线。<br>arc(x, y, radius, startAngle, endAngle, anticlockwise) – 圆弧<br>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。<br>arcTo(x1, y1, x2, y2, radius)<br>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。<br>PS：角度是以x轴为基准且为弧度，转化公式：radians=(Math.PI/180)*degrees<br>quadraticCurveTo(cp1x, cp1y, x, y) – 二次贝塞尔曲线<br>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) – 三次贝塞尔曲线<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。<br>PS：贝塞尔曲线都会以开始路径作为起点，实际上二次贝塞尔曲线由3个点控制，N次贝塞尔曲线由n+1个点控制。<br><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="noopener">wiki-贝塞尔曲线</a><br>绘制矩形的额外方法<br>rect(x, y, width, height)<br>绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。    <h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3>为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径。<br>Path2D()<br>Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。<br>Path2D.addPath(path [, transform])​<br>添加了一条路径到当前路径（可能添加了一个变换矩阵）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用 SVG paths</span><br><span class="line">var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用样式和颜色"><a href="#使用样式和颜色" class="headerlink" title="使用样式和颜色"></a>使用样式和颜色</h1><h2 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h2><p>fillStyle = color<br>    设置图形的填充颜色。<br>strokeStyle = color<br>    设置图形轮廓的颜色。<br>PS：orange、#ffa500、rgb(255, 165, 0)、rgba(255, 165, 0, 1)、hsl(360, 50%, 50%)、hsla(360, 50%, 50%, 1)</p>
<h2 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h2><p>globalAlpha = transparencyValue<br>    这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。<br>ctx.strokeStyle = “rgba(255,0,0,0.5)”;<br>ctx.fillStyle = “rgba(255,0,0,0.5)”;    </p>
<h2 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h2><p>可以通过一系列属性来设置线的样式。<br>lineWidth = value<br>    设置线条宽度。<br>    线宽是指给定路径的中心到两边距离之和的粗细。换句话说就是在路径的两边各绘制线宽的一半。<br>lineCap = type<br>    设置线条末端样式。<br>    butt，round 和 square。<br>    默认是 butt。<br>lineJoin = type<br>    设定线条与线条间接合处的样式。<br>    round, bevel 和 miter。<br>    默认是 miter。<br>miterLimit = value<br>    限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。<br>getLineDash()<br>    返回一个包含当前虚线样式，长度为非负偶数的数组。<br>    [a, b] a表示实线，b表示空白，这样交替出现。<br>setLineDash(segments)<br>    设置当前虚线样式。<br>lineDashOffset = value<br>    设置虚线样式的起始偏移量。</p>
<h2 id="渐变-Gradients（新建的渐变对象）"><a href="#渐变-Gradients（新建的渐变对象）" class="headerlink" title="渐变 Gradients（新建的渐变对象）"></a>渐变 Gradients（新建的渐变对象）</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>let lineargradient = createLinearGradient(x1, y1, x2, y2)<br>    createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</p>
<h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>let radialgradient = createRadialGradient(x1, y1, r1, x2, y2, r2)<br>    createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。<br>gradient.addColorStop(position, color)<br>    addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。</p>
<h2 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h2><p>createPattern(image, type)<br>    该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。<br>    你需要确认 image 对象已经装载(onload)完毕，否则图案可能效果不对的。</p>
<h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h2><p>shadowOffsetX = float<br>    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。<br>shadowOffsetY = float<br>    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。<br>shadowBlur = float<br>    shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。<br>shadowColor = color<br>    shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</p>
<h2 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h2><p>当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。<br>“nonzero”: 默认值.<br>“evenodd”</p>
<h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p>canvas 提供了两种方法来渲染文本:<br>fillText(text, x, y [, maxWidth])<br>    在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.<br>strokeText(text, x, y [, maxWidth])<br>    在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</p>
<h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>font = value<br>    当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。<br>textAlign = value<br>    文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。<br>textBaseline = value<br>    基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。<br>direction = value<br>    文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</p>
<h2 id="先进的文本测量"><a href="#先进的文本测量" class="headerlink" title="先进的文本测量"></a>先进的文本测量</h2><p>当你需要获得更多的文本细节时，下面的方法可以给你测量文本的方法。<br>measureText()<br>    将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。<br><code>var text = ctx.measureText(&quot;foo&quot;); // TextMetrics object
text.width; // 16;</code>    </p>
<h1 id="使用图像-Using-images"><a href="#使用图像-Using-images" class="headerlink" title="使用图像 Using images"></a>使用图像 Using images</h1><p>canvas更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。<br>引入图像到canvas里需要以下两步基本操作：    </p>
<ol>
<li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片（参见例子）</li>
<li>使用drawImage()函数将图片绘制到画布上<h2 id="获得需要绘制的图片"><a href="#获得需要绘制的图片" class="headerlink" title="获得需要绘制的图片"></a>获得需要绘制的图片</h2>HTMLImageElement<br>这些图片是由Image()函数构造出来的，或者任何的<img>元素<br>HTMLVideoElement<br>用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像<br>HTMLCanvasElement<br>可以使用另一个 <canvas> 元素作为你的图片源。<br>ImageBitmap<br>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。<br>PS：这些源统一由 CanvasImageSource类型来引用。    </canvas></video></li>
<li>使用相同页面内的图片<br>document.images集合<br>document.getElementsByTagName()方法<br>document.getElementById()获得这个图片    </li>
<li>使用其它域名下的图片<br>在 HTMLImageElement上使用crossOrigin属性，你可以请求加载其它域名上的图片。    </li>
<li>由零开始创建图像（需要onload保证图片加载完毕）<br><code>var img = new Image();   // 创建一个&lt;img&gt;元素
img.src = &#39;myImage.png&#39;; // 设置图片源地址</code>    </li>
<li>通过 data: url 方式嵌入图像<br><code>img.src = &#39;data:image/gif;base64,...&#39;</code></li>
<li>使用视频帧<br><code>return document.getElementById(&#39;myvideo&#39;);</code>    <h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2>drawImage(image, x, y)<br>其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。    <h2 id="缩放-Scaling"><a href="#缩放-Scaling" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2>drawImage(image, x, y, width, height)<br>这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小<h2 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片 Slicing"></a>切片 Slicing</h2>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)<br>第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。    <h2 id="控制图像的缩放行为-Controlling-image-scaling-behavior"><a href="#控制图像的缩放行为-Controlling-image-scaling-behavior" class="headerlink" title="控制图像的缩放行为 Controlling image scaling behavior"></a>控制图像的缩放行为 Controlling image scaling behavior</h2>Gecko 1.9.2 引入了 mozImageSmoothingEnabled 属性，值为 false 时，图像不会平滑地缩放。默认是 true 。<br><code>cx.mozImageSmoothingEnabled = false;</code><h1 id="变形-Transformations"><a href="#变形-Transformations" class="headerlink" title="变形 Transformations"></a>变形 Transformations</h1><h2 id="状态的保存和恢复-Saving-and-restoring-state"><a href="#状态的保存和恢复-Saving-and-restoring-state" class="headerlink" title="状态的保存和恢复 Saving and restoring state"></a>状态的保存和恢复 Saving and restoring state</h2>save()restore()<br>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。<br>PS：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。    <h2 id="绘画状态包括："><a href="#绘画状态包括：" class="headerlink" title="绘画状态包括："></a>绘画状态包括：</h2>当前应用的变形（即移动，旋转和缩放，见下）<br>strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值<br>当前的裁切路径（clipping path）<h2 id="移动-Translating"><a href="#移动-Translating" class="headerlink" title="移动 Translating"></a>移动 Translating</h2>我们先介绍 translate 方法，它用来移动 canvas 和它的原点到一个不同的位置。<br>translate(x, y)<br>translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。<br>PS：在做变形之前先保存状态是一个良好的习惯。<br>在绘制螺旋（spirograph）图案，如果不使用 translate 方法，那么只能看见其中的四分之一。<h2 id="旋转-Rotating"><a href="#旋转-Rotating" class="headerlink" title="旋转 Rotating"></a>旋转 Rotating</h2>它用于以原点为中心旋转 canvas。<br>rotate(angle)<br>这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。<br>旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。<h2 id="缩放-Scaling-1"><a href="#缩放-Scaling-1" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2>我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。<br>scale(x, y)<br>scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。<br>PS：默认情况下，canvas 的 1 单位就是 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。<h2 id="变形-Transforms"><a href="#变形-Transforms" class="headerlink" title="变形 Transforms"></a>变形 Transforms</h2>允许对变形矩阵直接修改。<br>transform(m11, m12, m21, m22, dx, dy)<br>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：<br><code>m11 m21 dx
m12 m22 dy
0     0     1</code><br>m11：水平方向的缩放<br>m12：水平方向的偏移<br>m21：竖直方向的偏移<br>m22：竖直方向的缩放<br>dx：水平方向的移动<br>dy：竖直方向的移动<br>setTransform(m11, m12, m21, m22, dx, dy)<br>这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。<br>从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。<br>resetTransform()<br>重置当前变形为单位矩阵，它和调用以下语句是一样的：<br>ctx.setTransform(1, 0, 0, 1, 0, 0);<h1 id="组合-Compositing"><a href="#组合-Compositing" class="headerlink" title="组合 Compositing"></a>组合 Compositing</h1>对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。此外, clip属性允许我们隐藏不想看到的部分图形.    <h2 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h2>globalCompositeOperation = type<br>这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。<br>具体type值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source-over	默认。在目标图像上显示源图像。</span><br><span class="line">source-atop	在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。</span><br><span class="line">source-in	在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。</span><br><span class="line">source-out	在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。</span><br><span class="line">destination-over	在源图像上方显示目标图像。</span><br><span class="line">destination-atop	在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。</span><br><span class="line">destination-in	在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。</span><br><span class="line">destination-out	在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。</span><br><span class="line">lighter	显示源图像 + 目标图像。</span><br><span class="line">copy	显示源图像。忽略目标图像。</span><br><span class="line">xor	使用异或操作对源图像与目标图像进行组合。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="裁切路径-Clipping-paths"><a href="#裁切路径-Clipping-paths" class="headerlink" title="裁切路径 Clipping paths"></a>裁切路径 Clipping paths</h2><p>裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。<br>clip()<br>    来创建一个新的裁切路径。<br>    默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p>
<h1 id="基本的动画"><a href="#基本的动画" class="headerlink" title="基本的动画"></a>基本的动画</h1><p>如果需要移动Canvas中的shape，我们不得不对所有东西（包括之前的）进行重绘。重绘是相当费时的，而且性能很依赖于电脑的速度。    </p>
<h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><p>1.清空 canvas<br>    除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。<br>2.保存 canvas 状态<br>    如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。<br>3.绘制动画图形（animated shapes）<br>    这一步才是重绘动画帧。<br>4.恢复 canvas 状态<br>    如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。    </p>
<h2 id="操控动画-Controlling-an-animation"><a href="#操控动画-Controlling-an-animation" class="headerlink" title="操控动画 Controlling an animation"></a>操控动画 Controlling an animation</h2><p>为了实现动画，我们需要一些可以定时执行重绘的方法。</p>
<h3 id="有安排的更新画布-Scheduled-updates"><a href="#有安排的更新画布-Scheduled-updates" class="headerlink" title="有安排的更新画布 Scheduled updates"></a>有安排的更新画布 Scheduled updates</h3><p>window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。<br>requestAnimationFrame(callback)<br>    方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。<br>    该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。<br>window.cancelAnimationFrame(ID)<br>    以取消回调函数。    </p>
<h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><h3 id="添加速率"><a href="#添加速率" class="headerlink" title="添加速率"></a>添加速率</h3><p>window.requestAnimationFrame(callback) 该方式帮助我们控制动画。<br>ctx.clearRect(0,0, canvas.width, canvas.height) 在callback前面调用清除画布。    </p>
<h3 id="设置边界"><a href="#设置边界" class="headerlink" title="设置边界"></a>设置边界</h3><p>物体碰到边缘，反弹回来，将速度更换方向即可。<br><code>if (ball.y + ball.vy &gt; canvas.height || ball.y + ball.vy &lt; 0 ) {
    ball.vy = -ball.vy;
}</code><br>PS：这里对垂直方向上分析，水平方向类似。<br>小球的y坐标+小球y的速度大于canvas的高度（下边缘）或者小球的y坐标+小球y的速度小于0（上边缘）反向</p>
<h3 id="添加加速度"><a href="#添加加速度" class="headerlink" title="添加加速度"></a>添加加速度</h3><p><code>ball.vy *= .99;
ball.vy += .25;</code>    </p>
<h3 id="长尾效果"><a href="#长尾效果" class="headerlink" title="长尾效果"></a>长尾效果</h3><p>用一个半透明的 fillRect 函数取代之，就可轻松制作长尾效果。<br><code>ctx.fillStyle = &#39;rgba(255,255,255,0.3)&#39;;
ctx.fillRect(0,0,canvas.width,canvas.height);</code>    </p>
<h3 id="添加鼠标控制"><a href="#添加鼠标控制" class="headerlink" title="添加鼠标控制"></a>添加鼠标控制</h3><p>为canvas元素添加 mousemove、 mouseout、click等事件，在通过 canvas 的 shape 来进行精确控制</p>
<h2 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h2><p>可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。    </p>
<h3 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h3><p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：<br>width<br>    图片宽度，单位是像素<br>height<br>    图片高度，单位是像素<br>data<br>    Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。<br>    每一个像素又数组4为组成，分别对应r、g、b、a</p>
<h3 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h3><p>去创建一个新的，空白的ImageData对象，你应该会使用createImageData() 方法。有2个版本的createImageData()方法。<br>var myImageData = ctx.createImageData(width, height);<br>    上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。<br>var myImageData = ctx.createImageData(anotherImageData);<br>    你也可以创建一个被anotherImageData对象指定的相同像素的ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。</p>
<h3 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h3><p>为了获得一个包含画布场景像素数据的ImageData对像，你可以用getImageData()方法：<br>var myImageData = ctx.getImageData(left, top, width, height);<br>    这个方法会返回一个ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为(left, top), (left + width, top), (left, top + height), 以及(left + width, top + height)四个点。这些坐标点被设定为画布坐标空间元素。</p>
<h3 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h3><p>你可以用putImageData()方法去对场景进行像素数据的写入。<br>ctx.putImageData(myImageData, dx, dy);<br>    dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标。</p>
<h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p>在drawImage() 方法， 第二个画布和imageSmoothingEnabled 属性的帮助下，我们可以放大显示我们的图片及看到详情内容。<br>因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。<br>禁用反锯齿<br><code>ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = true;
ctx.webkitImageSmoothingEnabled = true;
ctx.msImageSmoothingEnabled = true;</code>        </p>
<h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>HTMLCanvasElement  提供一个toDataURL()方法，此方法在保存图片的时候非常有用。<br>它返回一个包含被类型参数规定的图像表现格式的数据链接。返回的图片分辨率是96dpi。<br>canvas.toDataURL(‘image/png’)<br>    默认设定。创建一个PNG图片。<br>canvas.toDataURL(‘image/jpeg’, quality)<br>    创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。<br>canvas.toBlob(callback, type, encoderOptions)<br>    这个创建了一个在画布中的代表图片的Blob对像。<br>PS：这里是canvas对象上的方法，而不是画布上下文对象的方法。    </p>
<h2 id="点击区域和无障碍访问"><a href="#点击区域和无障碍访问" class="headerlink" title="点击区域和无障碍访问"></a>点击区域和无障碍访问</h2><p>canvas 标签只是一个位图，它并不提供任何已经绘制在上面的对象的信息。    </p>
<h3 id="内容兼容"><a href="#内容兼容" class="headerlink" title="内容兼容"></a>内容兼容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas&gt; ... &lt;/canvas&gt;标签里的内容被可以对一些不支持canvas的浏览器提供兼容。</span><br></pre></td></tr></table></figure>
<h3 id="ARIA-规则"><a href="#ARIA-规则" class="headerlink" title="ARIA 规则"></a>ARIA 规则</h3><p>Accessible Rich Internet Applications (ARIA) 定义了让Web内容和Web应用更容易被有身体缺陷的人获取的办法。你可以用ARIA属性来描述canvas元素的行为和存在目的    </p>
<h3 id="点击区域（hit-region）"><a href="#点击区域（hit-region）" class="headerlink" title="点击区域（hit region）"></a>点击区域（hit region）</h3><p>判断鼠标坐标是否在canvas上一个特定区域里一直是个有待解决的问题。hit region API让你可以在canvas上定义一个区域，这让无障碍工具获取canvas上的交互内容成为可能。它能让你更容易地进行点击点击检测并把事件转发到DOM元素去。这个API有以下三个方法（都是实验性特性，请先在浏览器兼容表上确认再使用）。<br>CanvasRenderingContext2D.addHitRegion()<br>    在canvas上添加一个点击区域。<br>    ctx.addHitRegion({control: element});<br>    addHitRegion()方法也可以带一个control选项来指定把事件转发到哪个元素上（canvas里的元素）。<br>ctx.removeHitRegion()<br>    从canvas上移除指定id的点击区域。<br>ctx.clearHitRegions()<br>    移除canvas上的所有点击区域。<br>PS：实验性方法，浏览器暂不支持    </p>
<h2 id="焦点圈"><a href="#焦点圈" class="headerlink" title="焦点圈"></a>焦点圈</h2><p>当用键盘控制时，焦点圈是一个能帮我们在页面上快速导航的标记。要在canvas上绘制焦点圈，可以使用drawFocusIfNeeded 属性。<br>ctx.drawFocusIfNeeded()<br>    如果给定的元素获得了焦点，这个方法会沿着在当前的路径画个焦点圈。<br>ctx.scrollPathIntoView()<br>    把当前的路径或者一个给定的路径滚动到显示区域内。<br>    scrollPathIntoView()方法可以让一个元素获得焦点的时候在屏幕上可见(滚动到元素所在的区域)。    </p>
<h2 id="canvas的优化"><a href="#canvas的优化" class="headerlink" title="canvas的优化"></a>canvas的优化</h2><h3 id="性能贴士"><a href="#性能贴士" class="headerlink" title="性能贴士"></a>性能贴士</h3><p>下面是一些改善性能的建议    </p>
<ol>
<li><p>在离屏canvas上预渲染相似的图形或重复的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myEntity.offscreenCanvas = document.createElement(&quot;canvas&quot;);</span><br><span class="line">myEntity.offscreenCanvas.width = myEntity.width;</span><br><span class="line">myEntity.offscreenCanvas.height = myEntity.height;</span><br><span class="line">myEntity.offscreenContext = myEntity.offscreenCanvas.getContext(&quot;2d&quot;);</span><br><span class="line">myEntity.render(myEntity.offscreenContext);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免浮点数的坐标点，用整数取而代之    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当你画一个没有整数坐标点的对象时会发生子像素渲染。</span><br><span class="line">ctx.drawImage(myImage, 0.3, 0.5);</span><br><span class="line">浏览器为了达到抗锯齿的效果会做额外的运算。为了避免这种情况，请保证在你调用drawImage()函数时，用Math.floor()函数对所有的坐标点取整。</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在用drawImage时缩放图像（多个 canvas 元素）<br>在离屏canvas中缓存图片的不同尺寸，而不要用drawImage()去缩放它们。        </p>
</li>
<li>使用多层画布去画一个复杂的场景<br>你可能会发现，你有些元素不断地改变或者移动，而其它的元素，例如外观，永远不变。这种情况的一种优化是去用多个画布元素去创建不同层次。    <h3 id="用CSS设置大的背景图"><a href="#用CSS设置大的背景图" class="headerlink" title="用CSS设置大的背景图"></a>用CSS设置大的背景图</h3>如果像大多数游戏那样，你有一张静态的背景图，用一个静态的<div>元素，结合background 特性，以及将它置于画布元素之后。这么做可以避免在每一帧在画布上绘制大图。    </div></li>
<li>用CSS transforms特性缩放画布<br>CSS transforms 特性由于调用GPU，因此更快捷。最好的情况是，不要将小画布放大，而是去将大画布缩小。    </li>
<li>使用moz-opaque属性(仅限Gecko)<br>如果你的游戏使用画布而且不需要透明，请在画布上设置moz-opaque属性。这能够用于内部渲染优化。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=&quot;mycanvas&quot; moz-opaque&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）<br>避免不必要的画布状态改变<br>渲染画布中的不同点，而非整个新状态<br>尽可能避免 shadowBlur特性<br>尽可能避免text rendering<br>使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)<br>有动画，请使用window.requestAnimationFrame() 而非window.setInterval()<br>请谨慎使用大型物理库<br>用JSPerf测试性能<br><a href="https://fanerge.github.io/canvas_solar_system/">demo地址</a><br><a href="https://antv.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">这里向大家推荐一下阿里开源的数据可视化库antV（g2、g6、f2）</a></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">MDN-canvas教程</a><br>    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449990549914b596ac1da54a228a6fa9643e88bc0c000" target="_blank" rel="noopener">廖雪峰老师的Canvas</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="noopener">MDN-canvas标签</a><br>    <a href="https://segmentfault.com/a/1190000004469449" target="_blank" rel="noopener">Canvas 的基本原理</a><br>    <a href="http://www.webhek.com/post/html5-canvas-cheat-sheet.html" target="_blank" rel="noopener">HTML5画布(CANVAS)速查简表</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>git工具书</title>
    <url>/2018/git%E5%B7%A5%E5%85%B7%E4%B9%A6.html</url>
    <content><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/git%E5%8E%9F%E7%90%86.png" alt="git原理"><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">图片来源</a><br><a href="https://juejin.im/entry/5ac04d195188255c946bcd4a" target="_blank" rel="noopener">Git 常用操作总结</a><br>PS：<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="git托管项目（新建-or-clone一个git项目）"><a href="#git托管项目（新建-or-clone一个git项目）" class="headerlink" title="git托管项目（新建 or clone一个git项目）"></a>git托管项目（新建 or clone一个git项目）</h2><p>mkdir gitdemo // 在当前目录创建gitdemo目录<br>cd gitdemo<br>pwd // 显示当前目录<br>git init // 将当前目录设置为git管理的仓库<br>git init [projectName] // 新建一个目录，将其初始化为Git代码库<br>or<br>git clone [ssh/https]</p>
<h2 id="工作区-gt-gt-暂存区（add为添加文件rm为移除文件）"><a href="#工作区-gt-gt-暂存区（add为添加文件rm为移除文件）" class="headerlink" title="工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）"></a>工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）</h2><p>git add [fileName] // 单个或多个文件<br>git add *.js // 通配符<br>git add -u  // 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .  // 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件<br>git add -A  // 提交所有变化（是git add .和git add -u的结合，git add -all的简写</p>
<p>git rm [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区<br>git rm --cached [fileName] // 停止追踪指定文件，但该文件会保留在工作区<br>git mv [fileNameOld] [fileNameNew] // 改名文件，并且将这个改名放入暂存区</p>
<h2 id="暂存区-gt-gt-本地仓库"><a href="#暂存区-gt-gt-本地仓库" class="headerlink" title="暂存区&gt;&gt;本地仓库"></a>暂存区&gt;&gt;本地仓库</h2><p>git commit -m ‘说明信息’ // 提交<br>git commit -am ‘说明’ // git add . 和 git commit的简写（一次完成两个动作）<br>常用commit type</p>
<ul>
<li>feat: 新功能</li>
<li>fix: 修复问题</li>
<li>docs: 修改文档</li>
<li>style: 修改代码格式，不影响代码逻辑</li>
<li>refactor: 重构代码，理论上不影响现有功能</li>
<li>perf: 提升性能</li>
<li>test: 增加修改测试用例</li>
<li>chore: 修改工具相关（包括但不限于文档、代码生成等）</li>
</ul>
<h2 id="本地仓库-gt-gt-远程仓库"><a href="#本地仓库-gt-gt-远程仓库" class="headerlink" title="本地仓库&gt;&gt;远程仓库"></a>本地仓库&gt;&gt;远程仓库</h2><p>git push ssh:<a href="mailto://git@dev.fanerge.com" target="_blank" rel="noopener">//git@dev.fanerge.com</a>/gitdemo.git master // 把本地仓库提交到远程仓库的master分支中<br>git push -u origin master // 当前分支提交到远程 master 分支<br>git push // 如果当前分支与远程分支存在追踪关系</p>
<h2 id="远程仓库-gt-gt-本地仓库"><a href="#远程仓库-gt-gt-本地仓库" class="headerlink" title="远程仓库&gt;&gt;本地仓库"></a>远程仓库&gt;&gt;本地仓库</h2><p>git fetch [远程主机名] [分支名] // 远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地<br>git fetch origin master<br>git clone [ssh/https]// 从远程主机克隆一个版本库<br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">更详细的资料</a></p>
<h2 id="远程仓库-gt-gt-工作区"><a href="#远程仓库-gt-gt-工作区" class="headerlink" title="远程仓库&gt;&gt;工作区"></a>远程仓库&gt;&gt;工作区</h2><p>git pull [远程主机名] [远程分支名]:[本地分支名] // 远程主机某个分支的更新，再与本地的指定分支合并<br>git pull // 当前分支只有一个追踪分支时可省略部分参数</p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>git branch // 查看本地所有分支（*表示当前分支）<br>git branch -v // 查看本地所有分支及最近一次提交信息<br>git branch -vv // 查看本地所有分支及最近一次提交信息和远程追踪分支<br>git branch -r // 查看远程所有分支<br>git branch -a // 查看本地/远程所有分支</p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout [branchName] // 切换分支<br>git checkout - // 切换到上一个分支</p>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>git branch [branchName] // 新建一个分支（但仍然留在当前分支）<br>git checkout -b [branchName] // 新建一个分支（并切换到该分支）<br>git branch [branchName] [commitId] // 新建一个分支（并指向指定的commitId）<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>如：新建 test 分支，并指向远程的 orign/dev 分支<br>git branch --track test origin/dev</p>
<h2 id="新建远程分支（新建本地分支，推送的远程作为远程分支）"><a href="#新建远程分支（新建本地分支，推送的远程作为远程分支）" class="headerlink" title="新建远程分支（新建本地分支，推送的远程作为远程分支）"></a>新建远程分支（新建本地分支，推送的远程作为远程分支）</h2><p>git branch [branchName]<br>git push origin [branchName]:[remoteBranchName]<br>还需要为新建本地分支和远程分支建立追踪关系<br>如：本地的 test 分支作为远程的 dev 分支<br>git push origin test:dev</p>
<h2 id="建立追踪关系（当前分支和远程分支）"><a href="#建立追踪关系（当前分支和远程分支）" class="headerlink" title="建立追踪关系（当前分支和远程分支）"></a>建立追踪关系（当前分支和远程分支）</h2><p>作用：用来描述当前和远程分支的位置关系，在使用git pull 和 git push 的时候可以省略远程参数<br>git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）<br>git branch –-set-upstream-to=origin/[branchName]<br>如：当前分支和远程 dev 分支建立追踪关系<br>git branch –-set-upstream-to=origin/dev</p>
<h2 id="合并分支（branchName合并到当前分支）"><a href="#合并分支（branchName合并到当前分支）" class="headerlink" title="合并分支（branchName合并到当前分支）"></a>合并分支（branchName合并到当前分支）</h2><p>git merge [branchName]<br>git rebase [branchName]<br>PS：<br>git merge dev（当前分支为master）<br>会在 master 分支产生一个新的commit。<br>git rebase dev（当前分支为master）<br>会将master上的提交推至顶端。</p>
<h2 id="删除分支（本地）"><a href="#删除分支（本地）" class="headerlink" title="删除分支（本地）"></a>删除分支（本地）</h2><p>git branch -d [branchName] // 删除分支（本地）<br>git push origin --delete [branchName] // 删除分支（远程）<br>git branch -dr [remoteBranchName] // 删除分支（远程）</p>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>tag作用类似于里程碑，可以快速找到里程碑的代码。</p>
<h2 id="查看所有tag"><a href="#查看所有tag" class="headerlink" title="查看所有tag"></a>查看所有tag</h2><p>git tag</p>
<h2 id="新建tag在当前commit"><a href="#新建tag在当前commit" class="headerlink" title="新建tag在当前commit"></a>新建tag在当前commit</h2><p>git tag [tagName]</p>
<h2 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h2><p>git tag [tagName] [commitId]</p>
<h2 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h2><p>git tag -d [tagName]</p>
<h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><p>git push origin :refs/tags/[tagName]</p>
<h2 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h2><p>git show [tagName]</p>
<h2 id="向远程提交指定tag"><a href="#向远程提交指定tag" class="headerlink" title="向远程提交指定tag"></a>向远程提交指定tag</h2><p>git push [remoteBranchName] [tagName]</p>
<h2 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h2><p>git checkout -b [branchName] [tagName]</p>
<h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><h2 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h2><p>git status</p>
<h2 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h2><p>git log</p>
<h2 id="显示当前分支的版本历史（包括commit发生变更的文件）"><a href="#显示当前分支的版本历史（包括commit发生变更的文件）" class="headerlink" title="显示当前分支的版本历史（包括commit发生变更的文件）"></a>显示当前分支的版本历史（包括commit发生变更的文件）</h2><p>git log –stat</p>
<h2 id="显示当前分支的版本历史（通过关键词）"><a href="#显示当前分支的版本历史（通过关键词）" class="headerlink" title="显示当前分支的版本历史（通过关键词）"></a>显示当前分支的版本历史（通过关键词）</h2><p>git log -S [keyword]</p>
<h2 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h2><p>git log [tagName] HEAD –pretty=format:%s</p>
<h2 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h2><p>git log [tagName] HEAD –grep feature</p>
<h2 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h2><p>git log –follow [fileName]<br>git whatchanged [fileName]</p>
<h2 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h2><p>git log -p [fileName]</p>
<h2 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h2><p>git log -5 –pretty –oneline</p>
<h2 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h2><p>git shortlog -sn</p>
<h2 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h2><p>git blame [file]</p>
<h2 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h2><p>git biff</p>
<h2 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h2><p>git diff –cached [fileName]</p>
<h2 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h2><p>git diff HEAD</p>
<h2 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h2><p>git diff [first-branch]…[second-branch]</p>
<h2 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h2><p>git diff –shortstat “@{0 day ago}”</p>
<h2 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h2><p>git show [commitId]</p>
<h2 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h2><p>git show –name-only [commitId]</p>
<h2 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h2><p>git show [commitId]:[fileName]</p>
<h2 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h2><p>git reflog</p>
<h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h2><p>git fetch [ssh/https]</p>
<h2 id="显示所有远程仓库（包括fetch和push地址）"><a href="#显示所有远程仓库（包括fetch和push地址）" class="headerlink" title="显示所有远程仓库（包括fetch和push地址）"></a>显示所有远程仓库（包括fetch和push地址）</h2><p>git remote -v</p>
<h2 id="显示某一远程仓库的信息"><a href="#显示某一远程仓库的信息" class="headerlink" title="显示某一远程仓库的信息"></a>显示某一远程仓库的信息</h2><p>git remote show [remoteRepositoryName]</p>
<h2 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h2><p>git remote add [shortname] [url]</p>
<h2 id="取回远程仓库的变化，并与本地分支合并（merge）"><a href="#取回远程仓库的变化，并与本地分支合并（merge）" class="headerlink" title="取回远程仓库的变化，并与本地分支合并（merge）"></a>取回远程仓库的变化，并与本地分支合并（merge）</h2><p>git pull [remote] [remoteBranchName]<br>PS：remote 一般为 origin ，当建立追踪关系，可以git pull 省略两个参数</p>
<h2 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h2><p>git push [remote] [branchName]</p>
<h2 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h2><p>git push [remote] –force</p>
<h2 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h2><p>git push [remote] –all</p>
<h1 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销/恢复"></a>撤销/恢复</h1><h2 id="撤销工作区修改（指定文件）"><a href="#撤销工作区修改（指定文件）" class="headerlink" title="撤销工作区修改（指定文件）"></a>撤销工作区修改（指定文件）</h2><p>git chekout – [fileName]</p>
<h2 id="撤销工作区（所有文件）"><a href="#撤销工作区（所有文件）" class="headerlink" title="撤销工作区（所有文件）"></a>撤销工作区（所有文件）</h2><p>git checkout – .</p>
<h2 id="暂存区–-gt-工作区（指定文件）"><a href="#暂存区–-gt-工作区（指定文件）" class="headerlink" title="暂存区–&gt;工作区（指定文件）"></a>暂存区–&gt;工作区（指定文件）</h2><p>git reset HEAD [fileName] // 撤销暂存区的修改<br>git checkout [fileName] // 撤销工作区的修改</p>
<h2 id="重置暂存区到上次提交commit（工作区不变）"><a href="#重置暂存区到上次提交commit（工作区不变）" class="headerlink" title="重置暂存区到上次提交commit（工作区不变）"></a>重置暂存区到上次提交commit（工作区不变）</h2><p>git reset [fileName]</p>
<h2 id="重置暂存区、工作区到上次提交commit"><a href="#重置暂存区、工作区到上次提交commit" class="headerlink" title="重置暂存区、工作区到上次提交commit"></a>重置暂存区、工作区到上次提交commit</h2><p>git reset –hard<br>git reset HEAD^ –hard // 回到上一次commit<br>git reset HEAD^^ –hard // 回到上一次的上一次commit</p>
<h2 id="重置暂存区、当前分支指定commitId（工作区不变）"><a href="#重置暂存区、当前分支指定commitId（工作区不变）" class="headerlink" title="重置暂存区、当前分支指定commitId（工作区不变）"></a>重置暂存区、当前分支指定commitId（工作区不变）</h2><p>git reset [commitId]</p>
<h2 id="重置暂存区、工作区、当前分支为指定commitId"><a href="#重置暂存区、工作区、当前分支为指定commitId" class="headerlink" title="重置暂存区、工作区、当前分支为指定commitId"></a>重置暂存区、工作区、当前分支为指定commitId</h2><p>git reset –hard [commitId]</p>
<h2 id="重置当前HEAD为指定commitId（暂存区、工作区不表）"><a href="#重置当前HEAD为指定commitId（暂存区、工作区不表）" class="headerlink" title="重置当前HEAD为指定commitId（暂存区、工作区不表）"></a>重置当前HEAD为指定commitId（暂存区、工作区不表）</h2><p>git reset –keep [commitId]</p>
<h2 id="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"><a href="#新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）" class="headerlink" title="新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）"></a>新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）</h2><p>git revert [commitId]</p>
<h2 id="暂时将未提交的变化存于stash，后续再从stash中取出"><a href="#暂时将未提交的变化存于stash，后续再从stash中取出" class="headerlink" title="暂时将未提交的变化存于stash，后续再从stash中取出"></a>暂时将未提交的变化存于stash，后续再从stash中取出</h2><p>git stash list // 查看 stash 列表<br>git stash // 保存当前暂未提交的修改<br>git stash apply // 从stash中恢复，但不清除该stash<br>git stash drop  // 清除该stash<br>git stash pop // 从stash中恢复并清除该stash<br>PS：一般用于停下手中活，处理更加紧急的任务，处理完任务后在回过头继续。<br>git stash pop = git stash apply + git stash drop</p>
<h1 id="开发分支合并到master分支"><a href="#开发分支合并到master分支" class="headerlink" title="开发分支合并到master分支"></a>开发分支合并到master分支</h1><p>更新与2018-07-17<br>git rebase的作用用于增删改当前 commits ，并将其合并到对应分支。<br>适用于：dev分支有开发，master分支其他人有合并，合并时需要以最新的master分支作为基础合并。<br>假如在dev分支开发完毕需要合并时：</p>
<ol>
<li>git checkout dev // 确保在你所在的开发分支如dev</li>
<li>git rebase master </li>
<li>如果有冲突，解决冲突</li>
<li>git rebase --continue</li>
<li>git checkout master // 回到master分支，进行合并</li>
<li>git merge dev</li>
</ol>
<p><a href="https://juejin.im/post/5b46c784f265da0f540513cd" target="_blank" rel="noopener">git：rebase（变基）的使用和理解</a></p>
<h1 id="如何将fork别人的库与原项目同步呢"><a href="#如何将fork别人的库与原项目同步呢" class="headerlink" title="如何将fork别人的库与原项目同步呢"></a>如何将fork别人的库与原项目同步呢</h1><p>更新于2018-09-12</p>
<ol>
<li>在fork库中添加上游代码库的 remote 源<br>git remote add {upstream} <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx/xxx.git </li>
<li>将本地的修改提交commit</li>
<li>在每次PR前，做如下操作即可与上游{upstream}同步<br>git remote update upstream<br>git rebase upstream/{branch name} 如：git rebase upstream/dev</li>
<li>Push 代码<br>git push origin dev</li>
</ol>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="Vim共有3种模式"><a href="#Vim共有3种模式" class="headerlink" title="Vim共有3种模式"></a>Vim共有3种模式</h2><p>编辑模式(命令模式)-默认模式<br>输入模式<br>末行模式</p>
<h2 id="各种模式的切换"><a href="#各种模式的切换" class="headerlink" title="各种模式的切换"></a>各种模式的切换</h2><h3 id="编辑–-gt-输入"><a href="#编辑–-gt-输入" class="headerlink" title="编辑–&gt;输入"></a>编辑–&gt;输入</h3><p> i: 在当前光标所在字符的前面，转为输入模式；<br> a: 在当前光标所在字符的后面，转为输入模式；<br> o: 在当前光标所在行的下方，新建一行，并转为输入模式；<br> I：在当前光标所在行的行首，转换为输入模式<br> A：在当前光标所在行的行尾，转换为输入模式<br> O：在当前光标所在行的上方，新建一行，并转为输入模式；</p>
<h3 id="输入–-gt-编辑"><a href="#输入–-gt-编辑" class="headerlink" title="输入–&gt;编辑"></a>输入–&gt;编辑</h3><p>ESC</p>
<h3 id="编辑–-gt-末行"><a href="#编辑–-gt-末行" class="headerlink" title="编辑–&gt;末行"></a>编辑–&gt;末行</h3><p>:</p>
<h3 id="末行–-gt-编辑"><a href="#末行–-gt-编辑" class="headerlink" title="末行–&gt;编辑"></a>末行–&gt;编辑</h3><p>ESC, ESC</p>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>1、末行模式关闭文件<br>:q  退出<br>:wq 保存并退出<br>:q! 不保存并退出<br>:w 保存<br>:w! 强行保存<br>:wq –&gt; :x<br>2、编辑模式下退出<br>ZZ: 保存并退出</p>
<blockquote>
<p>   参考文档：<br><a href="https://git-scm.com/" target="_blank" rel="noopener">git 官网</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">Git教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>拖放（Drag 和 Drop）</title>
    <url>/2018/html5-DragAndDrop.html</url>
    <content><![CDATA[<h1 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h1><p>拖放（Drag 和 drop）是 HTML5 标准的组成部分。<br>DataTransfer 对象：拖拽对象用来传递的媒介，使用一般为Event.dataTransfer。<br>draggable 属性：为需要拖拽的元素设置该属性。<br>Event.effectAllowed 属性：就是拖拽的效果。<br>Event.preventDefault() 方法：阻止默认的些事件方法等执行。<br>在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。</p>
<h2 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h2><h3 id="拖动目标上触发事件"><a href="#拖动目标上触发事件" class="headerlink" title="拖动目标上触发事件"></a>拖动目标上触发事件</h3><p>ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件。<br>ondrag 事件：当元素或者选择的文本被拖动时触发 drag 事件，大约每几百毫秒的触发一次。<br>ondragend 事件：当拖拽完成后触发的事件（比如松开鼠标按键或敲“Esc”键）。</p>
<h3 id="释放目标时触发的事件"><a href="#释放目标时触发的事件" class="headerlink" title="释放目标时触发的事件"></a>释放目标时触发的事件</h3><p>ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件。<br>ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件。<br>ondragleave 事件：当被鼠标拖动的对象离开其容器范围内时触发此事件。<br>ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件。<br>ondragexit 事件：当一个元素不再拖动立即选择目标元素触发。</p>
<h1 id="DataTransfer-对象详解"><a href="#DataTransfer-对象详解" class="headerlink" title="DataTransfer 对象详解"></a>DataTransfer 对象详解</h1><p>在进行拖放操作时，DataTransfer 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>dropEffect    String<br>    设置实际的放置效果，它应该始终设置成 effectAllowed  的可能值之一 。<br>effectAllowed    String<br>    用来指定拖动时被允许的效果。<br>files     FileList<br>    包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。<br>types    DOMStringList<br>    保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>addElement(element)<br>    设置拖动源。通常你不需要改变这项，如果修改这项将会影响拖动的哪个节点和dragend事件的触发。默认目标是被拖动的节点。<br>setData(type,data)<br>    为一个给定的类型设置数据。<br>getData()<br>    根据指定的类型检索数据，如果指定类型的数据不存在或者该 DataTransfer 对象中没有数据，方法将返回一个空字符串。<br>clearData(type)<br>    删除与给定类型关联的数据。类型参数是可选的。<br>setDragImage(imgElement,offsetX,offsetY)<br>    自定义一个期望的拖动时的图片。大多数情况下，这项不用设置，因为被拖动的节点被创建成默认图片。</p>
<h1 id="实现拖拽"><a href="#实现拖拽" class="headerlink" title="实现拖拽"></a>实现拖拽</h1><h2 id="确定什么是可拖动的"><a href="#确定什么是可拖动的" class="headerlink" title="确定什么是可拖动的"></a>确定什么是可拖动的</h2><p>让一个元素被拖动需要添加 draggable 属性，再加上全局事件处理函数ondragstart。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dragstart_handler(ev) &#123;</span><br><span class="line">	console.log(&quot;dragStart&quot;);</span><br><span class="line">	ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义拖动数据"><a href="#定义拖动数据" class="headerlink" title="定义拖动数据"></a>定义拖动数据</h2><p>应用程序可以在拖动操作中包含任意数量的数据项。每个数据项都是一个  string 类型，典型的MIME类型，如：text/html。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dragstart_handler(ev) &#123;</span><br><span class="line">	// 添加拖拽数据</span><br><span class="line">	ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</span><br><span class="line">	ev.dataTransfer.setData(&quot;text/html&quot;, &quot;&lt;p&gt;Example paragraph&lt;/p&gt;&quot;);</span><br><span class="line">	ev.dataTransfer.setData(&quot;text/uri-list&quot;, &quot;http://developer.mozilla.org&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义拖动图像"><a href="#定义拖动图像" class="headerlink" title="定义拖动图像"></a>定义拖动图像</h2><p>拖动过程中，浏览器会在鼠标旁显示一张默认图片。当然，应用程序也可以通过setDragImage() 方法自定义一张图片.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dragstart_handler(ev) &#123; </span><br><span class="line">	var img = new Image(); </span><br><span class="line">	img.src = &apos;example.gif&apos;; </span><br><span class="line">	ev.dataTransfer.setDragImage(img, 10, 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：img 的 src 属性路径是以使用该 js 页面为基准。</p>
<h2 id="定义拖动效果"><a href="#定义拖动效果" class="headerlink" title="定义拖动效果"></a>定义拖动效果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dragstart_handler(ev) &#123;</span><br><span class="line">  // Set the drag effect to copy</span><br><span class="line">  ev.dataTransfer.dropEffect = &quot;copy&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义一个放置区"><a href="#定义一个放置区" class="headerlink" title="定义一个放置区"></a>定义一个放置区</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dragover_handler(ev) &#123;</span><br><span class="line">	// 这里必须阻止默认行为，否则没有效果</span><br><span class="line">	ev.preventDefault();</span><br><span class="line">	ev.dataTransfer.dropEffect = &quot;move&quot;</span><br><span class="line">&#125;</span><br><span class="line">function drop_handler(ev) &#123;</span><br><span class="line">	ev.preventDefault();</span><br><span class="line">	// Get the id of the target and add the moved element to the target&apos;s DOM</span><br><span class="line">	var data = ev.dataTransfer.getData(&quot;text&quot;);</span><br><span class="line">	ev.target.appendChild(document.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="处理放置效果"><a href="#处理放置效果" class="headerlink" title="处理放置效果"></a>处理放置效果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dragstart_handler(ev) &#123;</span><br><span class="line">	ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);</span><br><span class="line">	ev.dropEffect = &quot;move&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function dragover_handler(ev) &#123;</span><br><span class="line">	ev.preventDefault();</span><br><span class="line">	// Set the dropEffect to move</span><br><span class="line">	ev.dataTransfer.dropEffect = &quot;move&quot;</span><br><span class="line">&#125;</span><br><span class="line">function drop_handler(ev) &#123;</span><br><span class="line">	ev.preventDefault();</span><br><span class="line">	var data = ev.dataTransfer.getData(&quot;text&quot;);</span><br><span class="line">	ev.target.appendChild(document.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;</span><br><span class="line">	&lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="拖动结束"><a href="#拖动结束" class="headerlink" title="拖动结束"></a>拖动结束</h2><p>在拖动目标元素上监听 dragend 事件，此时你可以做一起其他事情。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.zhangxinxu.com/wordpress/2011/02/html5-drag-drop-%E6%8B%96%E6%8B%BD%E4%B8%8E%E6%8B%96%E6%94%BE%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">HTML5 drag &amp; drop 拖拽与拖放简介</a><br>    <a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="noopener">HTML5 拖放（Drag 和 Drop）详解与实例</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="noopener">DataTransfer</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener">Drag and Drop API</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用手册</title>
    <url>/2018/git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</url>
    <content><![CDATA[<h1 id="git基础知识"><a href="#git基础知识" class="headerlink" title="git基础知识"></a>git基础知识</h1><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的 工作目录，它持有实际文件；<br>第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；<br>最后是 HEAD，它指向你最后一次提交的结果。<br>下图展示其关系<br><img src="http://www.runoob.com/manual/git-guide/img/trees.png" alt="git工作流"></p>
<h2 id="git配置用户信息"><a href="#git配置用户信息" class="headerlink" title="git配置用户信息"></a>git配置用户信息</h2><p>Git是分布式版本控制系统，SVN都是集中式的版本控制系统（需要中央服务器）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>PS：注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir dirname </span><br><span class="line">cd dirname</span><br><span class="line">pwd // pwd命令用于显示当前目录(绝对路径)</span><br><span class="line">git init // 把这个目录变成Git可以管理的仓库</span><br></pre></td></tr></table></figure></p>
<p>PS：目录名和文件名不可有中文<br>    .git 文件就是Git来跟踪管理版本库，千万别手动更改。<br>    如果没有.git 文件（系统隐藏关键文件），可以 ls -ah命令来查看</p>
<h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>第一步，用命令git add告诉Git，把文件<span style="color: red">添加</span>到仓库：<br>实际上就是把文件修改添加到暂存区<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add fileName</span><br><span class="line">git add *.js // 通配符</span><br><span class="line">git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</span><br><span class="line">git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</span><br><span class="line">git add -A  提交所有变化（是git add .和git add -u的结合，git add -all的简写）</span><br></pre></td></tr></table></figure></p>
<p>git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。<br>git add -u ：（git add –update的缩写）他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。<br><strong>2018-03-16更新</strong><br>PS：可以向git库多次添加文件，并一次提交<br>第二步，用命令git commit告诉Git，把文件<span style="color: red">提交</span>到仓库：<br>实际上就是把暂存区的所有内容提交到当前分支（默认是master分支）<br><code>git commit -m &quot;说明文本&quot;</code><br>PS：-m后面输入的是本次提交的说明，方便以后查看<br>更好的理解：需要提交的文件修改通过放到暂存区，然后，一次性提交暂存区的所有修改。<br><code>git commit -am &#39;说明&#39;</code><br>PS：git add 和 git commit的简写<br>清屏<br><code>reset + Enter</code><br>该命令可以让我们时刻掌握仓库当前的状态（当前是否有需要提交的修改）<br><code>git mv &lt;oldName&gt; &lt;nemeName&gt;</code><br>PS：git mv 命令用于移动或重命名一个文件、目录、软连接。<br><code>git status</code><br>PS：列出当前目录所有还没有被git管理的文件和 被git管理且被修改但还未提交（git commit）的文件。<br>查看具体修改了什么内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line">git diff HEAD -- fileName // 比对某个文件</span><br><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br><span class="line">	比对两个分支</span><br><span class="line">尚未缓存的改动：git diff</span><br><span class="line">查看已缓存的改动： git diff --cached</span><br><span class="line">查看已缓存的与未缓存的所有改动：git diff HEAD</span><br><span class="line">显示摘要而非整个 diff：git diff --stat</span><br></pre></td></tr></table></figure></p>
<p>PS：提交仓库前最好看一下，这是不是我们更改的。<br>经过对比后，就可以放心的添加和提交文件了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add fileName</span><br><span class="line">git commit -m &apos;note&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>该命令显示从最近到最远的提交日志<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log // 下面命令仅仅显示commit id（版本号），它是16进制数</span><br><span class="line">git log --oneline // 历史记录的简洁的版本</span><br><span class="line">git log --oneline --graph // 查看历史中什么时候出现了分支、合并</span><br><span class="line">git log --reverse --oneline // 逆向显示所有日志</span><br><span class="line">git log --author=fanerge // 查找指定用户的提交日志</span><br><span class="line">git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges </span><br><span class="line">// --since 和 --before，但是你也可以用 --until 和 --after</span><br></pre></td></tr></table></figure></p>
<p>回到上一个版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当前版本是HEAD，上一个版本就是HEAD^，上上一个版本就是HEAD^^，前100的版本HEAD~100</span><br><span class="line">git reset --hard HEAD^ // 回到上一个版本</span><br></pre></td></tr></table></figure></p>
<p>回到未来的版本<br><code>git reset --hard 版本号 // 版本号可以只写几位，git帮我们完善</code><br>显示文件<br><code>cat fileName</code><br>如果忘记版本号想回到最新的版本怎么办？该命令可以查看到版本号<br><code>git reflog</code><br>PS：可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。</p>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><pre><code>就是之前mkdir生产的目录，存放git项目的目录。
</code></pre><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><pre><code>工作区有一个隐藏目录.git，这个就是Git的版本库。
</code></pre><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>PS：其实git add fileName命令就是讲对应的文件添加到暂存区<br>    其实git commit 命令仅仅是将暂存区的东西提交到当前分支</p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>Git跟踪并管理的是修改，而非文件。<br>Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>把 fileName 文件在工作区的修改全部撤销，这里有三种情况：</p>
<ol>
<li>一是 fileName 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>二是 fileName 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
<li>三是 fileName 已经提交到本地版本库中，请使用 git reset –hard HEAD^<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。</li>
</ol>
<p>处理方式：</p>
<h3 id="尚未存在暂存区"><a href="#尚未存在暂存区" class="headerlink" title="尚未存在暂存区"></a>尚未存在暂存区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- fileName</span><br></pre></td></tr></table></figure>
<p>PS：git checkout -- fileName命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。</p>
<h3 id="已存在暂存区"><a href="#已存在暂存区" class="headerlink" title="已存在暂存区"></a>已存在暂存区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD fileName	</span><br><span class="line">git checkout -- fileName // 必须要使用第一点的方式</span><br></pre></td></tr></table></figure>
<p>PS：git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。<br><img src="http://marklodato.github.io/visual-git-guide/basic-usage.svg" alt="工作区-暂存区-HEAD"><br>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p>
<ul>
<li>git add files 把当前文件放入暂存区域。</li>
<li>git commit 给暂存区域生成快照并提交。</li>
<li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li>
<li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li>
</ul>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>直接右键或命令删除文件<br><code>rm fileName</code><br>PS：此时，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了<br>这是有两种处理方式：</p>
<ol>
<li><p>真的想删除这个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm fileName // git中删除对应文件</span><br><span class="line">git commit -m &apos;说明&apos; // 同步工作区和版本库</span><br></pre></td></tr></table></figure>
</li>
<li><p>删错了，你想从版本库中恢复（无论工作区是修改还是删除，都可以“一键还原”）<br><code>git checkout -- fieName</code><br>PS：命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。    </p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="设置ssh（以github举例）"><a href="#设置ssh（以github举例）" class="headerlink" title="设置ssh（以github举例）"></a>设置ssh（以github举例）</h2><p>第1步：创建SSH Key。<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa（私钥）和id_rsa.pub（公钥）两个文件<br>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>这里包括title和key字段</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p><code>git remote add origin git@github.com:fanerge/repositoryName.git</code><br>把本地库与远程库进行关联（在本地库目录下进行）<br>远程库的名字就是origin，这是Git默认的叫法<br><code>git push -u origin master</code><br>把本地库的所有内容推送到远程库上<br>其实git push 是把当前分支如 master 推送到远程<br>PS：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>以后推送只需下面命令：<br><code>git push origin master</code>    </p>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:fanerge/仓库名.git	</span><br><span class="line">or</span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt; // 克隆到指定的目录</span><br><span class="line">cd 仓库名</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：git支持多种协议 ssh、https等</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。    </p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b branchName	</span><br><span class="line">	git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：	</span><br><span class="line">	git branch branchName // 创建分支</span><br><span class="line">	git checkout branchName // 切换到分支</span><br><span class="line">git branch</span><br><span class="line">	查看分支</span><br></pre></td></tr></table></figure></p>
<p>PS：git branch 命令会列出所有分支，当前分支前面会标一个*号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">	dev分支的工作完成，我们就可以切换回master分支</span><br><span class="line">git merge branchName</span><br><span class="line">	git merge命令用于合并指定分支到当前分支（这里是将dev合并到master）。</span><br></pre></td></tr></table></figure></p>
<p>PS：这个操作只能在主分支master上进行。<br>    Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p><code>git branch -d branchName</code></p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。<br>    假如 readme.txt 存在冲突。<br>第一步：打开 readme.txt 文件手动处理冲突<br>第二步：添加到暂存区 git add readme.txt<br>第三步：提交到当前分支 git commit -m ‘说明’<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">	用带参数的git log也可以看到分支的合并情况</span><br><span class="line">	用git log --graph命令可以看到分支合并图。</span><br></pre></td></tr></table></figure></p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev	</span><br><span class="line">git add readme.txt </span><br><span class="line">git commit -m &quot;add merge&quot;	</span><br><span class="line">git checkout master	</span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev	</span><br><span class="line">	准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward。</span><br><span class="line">	因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span><br></pre></td></tr></table></figure></p>
<h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>所有人都在 dev 分支上开发，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br>使用场景，在开发过程中新接收到一个bug需要紧急处理。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">	Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span><br></pre></td></tr></table></figure></p>
<p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master	</span><br><span class="line">git checkout -b issue-101</span><br></pre></td></tr></table></figure></p>
<h3 id="创建bug分支"><a href="#创建bug分支" class="headerlink" title="创建bug分支"></a>创建bug分支</h3><p>修复bug之后（提交修复bug相关的代码）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add readme.txt </span><br><span class="line">git commit -m &quot;fix bug 101&quot;</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">git branch -d issue-101</span><br></pre></td></tr></table></figure></p>
<p>现在需要切换到原来分支继续开发<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git status</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure></p>
<p>PS：工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一种 git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除<br>一种 git stash pop，恢复的同时把stash内容也删了<br>PS：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>    当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br><code>git branch -D branchName</code><br>    强行删除一个没有合并的分支<br>PS：开发一个新feature，最好新建一个分支；<br>    如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。    </name></p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。<br><code>git remote</code><br>    查看远程库的信息（origin）<br><code>git remote -v</code><br>    显示更详细的信息，显示了可以抓取（fetch）和推送（push）的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<br><code>git push origin master</code><br>    master 表示你要往远程那个分支推送<br>PS：一般 master、dev 分支需要推送到远程库，其它分支不需要。</p>
<h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p><code>git branch --set-upstream dev origin/dev</code><br>    把本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接<br><code>git fetch</code><br>PS：相当于是从远程获取最新版本到本地，不会自动merge<br><code>git pull</code><br>PS：相当于是从远程获取最新版本并merge到本地（git fetch + git merge）<br>    把最新的提交从origin/dev抓下来（提交前需要拉取分支的最新代码）<br>手动处理冲突<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;说明&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></p>
<pre><code>推送到远程dev分支
</code></pre><p>多人协作的工作模式的步骤：    </p>
<ol>
<li>首先，可以试图用git push origin branch-name推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</li>
</ol>
<p>PS：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。    </p>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。    </p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git checkout master</span><br><span class="line">	切换到需要打标签的分支</span><br><span class="line">git tag tagName</span><br><span class="line">	打标签</span><br><span class="line">git tag -a tagName </span><br><span class="line">	-a 选项意为&quot;创建一个带注解的标签&quot;（谁打的，什么时候打的）</span><br><span class="line">git tag	</span><br><span class="line">	查看所有标签</span><br><span class="line">git tag tagName commitId</span><br><span class="line">	给特定版本号打标签</span><br><span class="line">git show tagName</span><br><span class="line">	查看标签信息</span><br><span class="line">git tag -a tagName -m &quot;说明&quot; commitId</span><br><span class="line">	创建带有说明的标签，用-a指定标签名，-m指定说明文字</span><br><span class="line">git tag -s tagName -m &quot;说明&quot; commitId	</span><br><span class="line">	通过-s用私钥签名（PGP签名标签）一个标签</span><br></pre></td></tr></table></figure>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p><code>git tag -d tagName</code><br>    如果标签打错了，也可以删除<br>PS：因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin tagName	</span><br><span class="line">	推送某一个标签到远端</span><br><span class="line">git push origin --tags</span><br><span class="line">	推送全部尚未推送到远端的本地标签</span><br><span class="line">git tag -d tagName	</span><br><span class="line">git push origin :refs/tags/tagName	</span><br><span class="line">	如果标签已经推送到远程，先本地删除，再远程删除。</span><br></pre></td></tr></table></figure></p>
<h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;fanerge&quot;</span><br><span class="line">git config --global user.email fanerge@example.com</span><br><span class="line">	配置用户信息</span><br><span class="line">git config --global color.ui true</span><br><span class="line">	让Git显示颜色，会让命令输出看起来更醒目。</span><br><span class="line">git config --global core.editor notepad++</span><br><span class="line">	配置文本编辑器</span><br><span class="line">git config --global merge.tool vimdiff	</span><br><span class="line">	配置差异分析工具</span><br><span class="line">git config --list	</span><br><span class="line">	查看全部配置信息</span><br><span class="line">git config configName	</span><br><span class="line">	查看单个配置信息</span><br></pre></td></tr></table></figure>
<h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>创建一个特殊的.gitignore文件，把需要忽略的文件名填进去就可。<br>    在这个目录的文件<br>    <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">所有配置文件可以直接在线浏览</a><br>忽略文件的原则是：<br>    忽略操作系统自动生成的文件，比如缩略图等；<br>    忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>    忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br>有时需要向git添加文件，但又添加不上，需要检查.gitignore哪里写错了<br><code>git check-ignore -v fileName</code><br>暴力向git添加文件<br><code>git add -f fileName // 不建议使用</code></p>
<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status	</span><br><span class="line">	为status 设置为 st 别名</span><br><span class="line">	git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>每个仓库的Git配置文件都放在.git/config文件中。<br>cat .git/config<br>    查看本仓库的配置</p>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">具体步骤</a><br><a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">管理公钥</a><br><a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">管理权限</a></p>
<h1 id="速记手册"><a href="#速记手册" class="headerlink" title="速记手册"></a>速记手册</h1><p>工作区：就是git版本管理的目录。<br>暂存区（stage或index）：git add添加到暂存区<br>当前分支：git commit将暂存区内容提交到当前分支<br>常用注释前缀：issue、bug、feature、fix、</p>
<p>把这个目录变成Git可以管理的仓库<br>    git init<br>把文件添加到版本库（实际上就是把文件修改添加到暂存区）<br>    git add fileName<br>    git add *.js // 通配符<br>    git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>    git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件<br>    git add -A  提交所有变化（是git add .和git add -u的结合，git add -all的简写）<br>把文件提交到当前仓库（实际上就是把暂存区的所有内容提交到当前分支）<br>    git commit -m “本次提交注释”</p>
<p>当前版本设置（跳转版本，HEAD为当前版本的指针）<br>    git reset –hard HEAD^ // 回到上一个版本<br>    git reset –hard HEAD~100 // 回到前100个版本<br>    git reset –hard commitId // 回到commitId的版本</p>
<p>撤销操作<br>    还没git add放入暂存区<br>        git checkout – readme.txt<br>    文件已经git add添加到暂存区（依次执行）<br>        git reset HEAD fileName.txt<br>        git checkout – readme.txt<br>    文件已经提交到当前版本（版本回退）<br>        git reset HEAD^<br>    文件已经提交到远程库<br>        无力回天<br>查看当前仓库的状态<br>    git status    </p>
<p>删除文件<br>    第一步：<br>    rm fileName.txt<br>    第二步：<br>    git rm fileName.txt // 告诉git确实要删除<br>    or<br>    git checkout – fileName.txt // 删错了想恢复文件 </p>
<p>本地分支代码推送到远端<br>    git push -u origin master // 这里本地代码推送到了master主干上了<br>    git push origin master // 将当前分支推送到master分支<br>分支操作（新需求，主要是为了不影响其他人开发）<br>    git branch // 查看所有分支（*表示当前分支）<br>    git branch Name // 新建分支<br>    git checkout Name // 切换到分支<br>    or<br>    git checkout -b Name // 新建并切换到分支<br>    git branch -d Name // 删除Name分支<br>    git branch -D Name // 强行删除Name分支（危险）<br>    git checkout -b branch-name origin/branch-name // 新建并切换并建立本地分支和远程分支的联系分支<br>    git branch –set-upstream branch-name origin/branch-name // 设置本地的dev分支与远端的dev分支的链接<br>    <span style="color: red">git push origin dev:dev // 提交本地dev分支作为远程的dev分支</span><br>远程分支操作<br>远程分支的新建和关联<br>    新建并切换至dev分支<br>    <span style="color: red">git checkout -b ‘dev’</span><br>    本地dev分支作用远程dev分支并推送至远端<br>    <span style="color: red">git push origin dev:dev</span><br>    当前分支关联远程分支（dev-&gt;origin/dev）<br>    <span style="color: red">git branch –set-upstream-to=origin/dev</span><br>合并分支<br>    git merge Name // 将Name分支合并到当前分支，直接把当前指向Name分支的当前提交（快进模式）<br>    // Git就会在merge时生成一个新的commit（仅一个）<br>     git merge –no-ff -m “部分注释” dev // 禁用Fast forward进行合并<br>处理冲突<br>    git pull // 拉最新代码，no tracking information表示本地分支和远程分支的链接关系没有创建<br>    <span style="color: red">git branch –set-upstream dev origin/dev // 设置本地的dev分支与远端的dev分支的链接</span></p>
<p>储藏工作现场（用于临时处理bug但目前代码又不可提交的场景，等修复bug后再回来处理）<br>    git stash // 向储藏室添加工作现场，在其他分支上处理bug<br>    // 处理完bug，有回到之前的工作现场<br>    git stash list // 查看所有储藏室的工作现场<br>    // 恢复工作现场<br>    git stash apply // 只恢复<br>    git stash apply stash@{0} // 恢复某个工作现场<br>    git stash drop // 从储藏室删除<br>    or<br>    git stash pop<br>关联远程库<br>    git remote // 查看远程库的信息<br>    git remote -v // 更详细的信息<br>    git remote add origin git@server-name:path/repo-name.git<br>从远程clone<br>    git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:fanerge/gitskills.git</p>
<p>标签管理<br>    git tag <name> // 为最新的commit打一个标签<br>    git tag // 查看所有标签<br>    git tag <name> commitId // 为某次commitId打标签<br>    git tag -a <tagname> -m “blablabla…” // 可以指定标签信息<br>    git tag -s <tagname> -m “blablabla…” // 可以用PGP签名标签<br>    git show <name> // 查看说明文字<br>    git tag -d <name> // 删除某个标签<br>    git push origin <tagname> // 推送某个标签到远程<br>    git push origin –tags // 一次性推送全部尚未推送到远程的本地标签<br>    // 如果标签在远程要删除<br>    git tag -d <name> // 删除某个标签<br>    git push origin :refs/tags/<name> // 删除一个远程标签</name></name></tagname></name></name></tagname></tagname></name></name></p>
<p>diff文件（difference）<br>    git diff fileName.txt<br>    git diff HEAD – readme.txt // 查看工作区和版本库里面最新版本的区别<br>查看提交日志<br>    git log<br>    git log –pretty=oneline //<br>    git log –graph    // 查看分支合并图<br>    git log –graph –pretty=oneline –abbrev-commit // 查看分支合并情况<br>查看历史命令（用于回到未来版本）<br>    git relog</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://shimo.im/docs/m2m3ZhdmJqgXY7JA" target="_blank" rel="noopener">git 手册</a><br>    <a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a><br>    <a href="http://www.runoob.com/manual/git-guide/" target="_blank" rel="noopener">git - 简明指南</a><br>    <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">廖雪峰-git教程</a><br>    <a href="http://www.runoob.com/git/git-basic-operations.html" target="_blank" rel="noopener">Git 教程</a><br>    <a href="http://blog.csdn.net/hudashi/article/details/7664457" target="_blank" rel="noopener">Git fetch和git pull的区别</a><br>    <a href="http://blog.csdn.net/ibingow/article/details/7541402" target="_blank" rel="noopener">git reflog</a><br>    <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解git</a></p>
</blockquote>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用语法汇总</title>
    <url>/2018/git%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<p>本文不会介绍git的<a href="https://fanerge.github.io/2018/git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html">工作原理</a>，需要你对git有一定的了解。本文几乎罗列出了所有常用的git命令，可作为日常开发的查询手册。</p>
<h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><p>git clone [remoteUrl] // clone远程库到当前目录（项目名为远程项目名，会自动设置origin为remoteUrl的引用）<br>git clone [remoteUrl] [本地项目名] // clone项目并会重命名为[本地项目名]<br>PS：自动设置本地 master 分支跟踪clone的远程仓库的 master 分支</p>
<h1 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h1><p>用于从另一个存储库下载对象和引用<br>git fetch // 取回远程主机所有分支的更新<br>git fetch [remoteUrl] // 取回远程主机[remoteUrl]的更新到本地仓库（不自动合并到工作区）<br>git fetch [upstream] // 取回远程主机的引用[upstream]的更新到本地仓库<br>git fetch [remoteUrl] [branchName] // 取回远程主机[remoteUrl]的分支[branchName]的更新<br>git fetch [remoteUrl|upstream] [远程分支名]:[本地分支名] // 将[远程分支]fetch到本地并命名为[本地分支名]</p>
<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><p>用于切换分支或恢复工作区文件<br>git checkout - // 切到最近的一次分支<br>git checkout [branchName] // 切换到[branchName]分支<br>git checkout -b [branchName] // 创建并切换到[branchName]分支<br>git checkout -b [localBranch] [remoteUrl]/[remoteBranch] // 创建并切换到[localBranch]并追踪[remoteUrl]/[remoteBranch]<br>git checkout -m [branchName] // 如果你在错误分支中开发，但又不允许直接切换分支（因为本地有修改），git会帮我们将错误分支到代码合并到branchNane<br>git checkout -- [fileName] // 撤销工作区的指定文件的操作（没有通过git add添加到暂存区）<br>git checkout . // 撤销工作区的所有文件的操作<br>git checkout head -- [fileName] // 撤销文件到上次commit的时候（head指向上次commit）<br>git checkout -b [localBranchName] [upstream]/[remoteBranchName] // 以远程[remoteBranchName]为模板新建[localBranchName]并切换到该分支并追踪到[upstream]/[remoteBranchName]【2018-12-19】</p>
<h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h1><p>用于从另一个存储库或本地分支获取并集成（git fetch + git merge FETCH_HEAD）<br>git pull [远程主机名] [远程分支名]:[本地分支名]<br>git pull origin next:master // 取回origin主机的next分支，与本地的master分支合并<br>git pull origin next // 若想取回origin主机的next分支并与当前分支合并，可省略当前分支名<br>一旦当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名<br>git pull origin<br>如果当前分支只有一个追踪分支，连远程主机名都可以省略<br>git pull<br>清理远程已删除本地还存在的分支（2020-04-20）<br>git pull -p</p>
<h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1><p>将文件内容添加到索引/暂存区<br>git add [path] // [path]可以是文件也可以是目录<br>git add . // 将所有修改添加到暂存区<br>git add -u [path] // 把[path]中所有跟踪文件中被修改过或已删除文件的信息添加到暂存区（省略<path>表示 . ,即当前目录）<br>git add -A [path] // 所有跟踪文件中被修改过或已删除文件和所有未跟踪的文件信息添加到暂存区（省略<path>表示 . ,即当前目录）<br>git add -i [path] // 查看已跟踪的文件是否有更改、是否有添加到暂存区</path></path></p>
<h1 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h1><p>用于显示工作目录和暂存区的状态<br>git status -uno // 只列出所有已经被git管理的且被修改但没提交的文件<br>git status -s // --short 格式化输出git status </p>
<h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h1><p>将暂存区当前内容与描述更改的用户和日志消息一起存储在新的提交中<br>git commit -a // 会对以已追踪的文件自动执行git add并commit（只会对已追踪的文件有效果）<br>git commit -m ‘注释’ // 带注释的提交<br>git commit --amend -m ‘注释’// 尝试重写提交（修改上次commit，如果提交内容没有更改，将使用本次提交注释覆盖上次提交注释）</p>
<h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><p>用于将本地分支的更新<br>git push [远程主机名] [本地分支名]:[远程分支名] // 将[本地分支名]推送到[远程主机名]的[远程分支名]（远程分支名不存在时则新建）<br>git push [远程主机名] :[远程分支名] // 省略本地分支，表示删除[远程主机名]的[远程分支名]<br>git push [远程主机名] -d [远程分支名] // 与上等价（--delete）<br>git push [upstream] [branchName] // 推送[branchName]分支到远端<br>git push -a [远程主机名] // 将本地的所有分支都推送到远程主机（--all）<br>git push [远程主机名] HEAD // 将当前分支推送到远程的同名分支<br>git push [远程主机名] --tags // 推送所有标签<br>git push [远程主机名] [tagName] // 推送单个标签<br>git push [远程主机名] :[tagName] // 删除远程标签<br>git push [远程主机名] tag [tagName] // 将本地标签[tagName]推送到远端[remoteUrl]</p>
<h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><p>查看（当前分支前会有星号）、创建、删除分支<br>git branch // 查看本地分支<br>git branch -r // 查看远端分支<br>git branch -a // 本地+远程分支列表（--all）<br>git branch [branchName] // 新建[branchName]分支<br>git branch -v // 查看分支的最近commit及注释<br>git branch -vv // 查看本地<br>git branch -D [branchName] // 删除[branchName]分支（需要切换到要删除分支以外的分支）<br>git branch -m [oldBranchName] [newBranchName] // 重命名分支<br>git branch --set-upstream-to [remoteUrl]/[branchName] // 为当前分支建立追踪关系，追踪为[remoteUrl]/[branchName]<br>git branch --unset-upstream // 撤销本地分支与远程分支的追踪关系</p>
<h1 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h1><p>用于将两个或两个以上的开发历史加入一起<br>git merge [branchName] // 合并branchName分支到当前分支的顶部<br>git merge -s ours [branchName] // 合并branchName分支到当前分支,并使用ours合并策略（该参数将强迫冲突发生时，自动使用当前分支的版本）<br>git merge -s theies [branchName] // 同上，但该参数将强迫冲突发生时，自动使用被合并分支的版本</p>
<h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>如在 dev 分支上执行：git rebase master<br>作用：该命令会把你的”dev”分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把最新的“master”代码合并到“dev”分支，最后把之前临时保存的这些补丁应用到”dev”分支上。<br>git describe // 显示离当前提交最近的标签</p>
<h2 id="需求（开发分支-dev-远程分支-remoteDev）"><a href="#需求（开发分支-dev-远程分支-remoteDev）" class="headerlink" title="需求（开发分支 dev 远程分支 remoteDev）"></a>需求（开发分支 dev 远程分支 remoteDev）</h2><p>git checkout dev<br>Git rebase remoteDev<br>// 如果有冲突，解决冲突—循环<br>git add .<br>git rebase --continue<br>git rebase --abort // 在过程中可以终止rebase，恢复到rebase开始前的状态。<br><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">git rebase 与 git merge</a></p>
<h2 id="合并多次commitMessage（由于自己的分支）"><a href="#合并多次commitMessage（由于自己的分支）" class="headerlink" title="合并多次commitMessage（由于自己的分支）"></a>合并多次commitMessage（由于自己的分支）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例如将最近的5次commitMessage合并到倒数第6次（倒数第6次commitId为sha1）</span><br><span class="line">git rebase -i sha1</span><br><span class="line">// 后面进行交互式处理</span><br><span class="line">一般把需要保留的前面留p（pick），需要合并到前面的改为s（squash），注意一定要保证第一个为p</span><br><span class="line">后面还会确认commitMessage</span><br></pre></td></tr></table></figure>
<h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>用于显示提交日志信息<br>git log -1 // 查看最近一条commit记录<br>git log -n // 最近n次提交<br>git log --oneline // 单行显示日志<br>git log --pretty=oneline // 查看以前提交记录<br>git log --no-merges // 显示整个提交历史记录，但跳过合并<br>git log [dirName]/[fileName] // 查看当前分支dirName目录下fileName文件的提交日志<br>git log --since=”2 weeks ago” -- [fileName] // 显示最近两周fileName文件的提交日志<br>git log --name-status [branchName1]..[branchName2] // 显示branchName2分支尚未在branchName1分支中的提交<br>git log --follow [fileName] // 显示fileName文件的更改信息，包括更名之前的提交<br>git log --branches // 显示所有分支的提交<br>git log --branches --not --remotes=origin // 显示所有分支的提交（但不包括本地追踪远程分支origin）<br>git log [remoteUrl]/[branchName] // 查看远端某分支的日志<br>git log [commitId] // 查看对应commitId的提交<br>git log --author=[userName] // 查看属于userName提交的记录<br>git log -p // 查看提交历史并显示每次提交的内容差异<br>git log -p -2 // 最近两条<br>git log --stat // 每次提交的简略的统计<br>git log --pretty=[args] // 参数为 oneline：一行显示，还有short，full ，fuller</p>
<h1 id="git-shortlog"><a href="#git-shortlog" class="headerlink" title="git shortlog"></a>git shortlog</h1><p>用于汇总git日志输出（commit次数+提交注释）<br>git shortlog -s // 汇总每位开发者commit次数<br>git shortlog -n // commit次数排名</p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>工作目录(Working tree)和暂存区域快照(index)之间的差异<br>git diff [fileName] // 比较当前文件和暂存区文件差异<br>git diff [commitId1] [commitId2] // 比较两次提交之间的差异<br>git diff [branch1] [branch2] // 比较两个分支之间的差异<br>git diff --staged // 比较暂存区和版本库差异<br>git diff --cached // 比较暂存区和版本库差异（git add后尚未git commit）<br>git diff --stat // 仅仅比较统计信息<br>git diff HEAD // 自上次提交以来工作树中的更改<br>git diff [branchName] // 查看工作目录和某分支的差异<br>git diff HEAD^ HEAD // 比较上次提交和上上次提交<br>git diff // 查看未暂存的修改<br>git diff --cached // --staged 查看已暂存的修改</p>
<h1 id="git-rm-amp-amp-git-mv"><a href="#git-rm-amp-amp-git-mv" class="headerlink" title="git rm &amp;&amp; git mv"></a>git rm &amp;&amp; git mv</h1><p>用于从工作区和索引中删除文件（git rm 删除文件可以被git记录下来，rm只是物理删除）<br>git rm --cached [fileName] // 只是从暂存区中删除文件索引<br>git rm [fileName] // 工作区和暂存区同时删除文件<br>PS：其他参数-f为--force -r为递归处理该目录下的所有文件<br>用于移动或重命名文件<br>git mv [fileName] [dirName] // 将文件[fileName]移动到目录[dirName]中去<br>git mv [oldFileName] [newFileName] // 重命名</p>
<h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><p>作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本（这个版本之后的commit都将消失）【2018-12-18更新】<br>git reset HEAD [fileName] // 撤销已经git add到暂存区的指定文件的操作（原理是重新取最后一次commit的内容）<br>git reset HEAD // 撤销已经git add到暂存区的操作<br>git reset HEAD~1 // 重置到上次commit<br>git reset [commitId] // 重置到commitId<br>git reset --soft [commitId] // HEAD回退到commitId，暂存区和工作区不变<br>git reset --mixed [commitId] // HEAD回退到commitId，暂存区改变，工作区不变（默认方式）<br>git reset --hard [commitId] // HEAD回退到commitId，暂存区和工作区都将改变（非常危险）<br><a href="https://www.cnblogs.com/kidsitcn/p/4513297.html" target="_blank" rel="noopener">git reset soft,hard,mixed之区别深解</a></p>
<h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。<br>适用场景： 如果我们想恢复之前的某一版本（该版本不是merge类型），但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。<br><a href="https://blog.csdn.net/yxlshk/article/details/79944535" target="_blank" rel="noopener">Git恢复之前版本的两种方法reset、revert（图文详解）</a>【2018-12-18更新】</p>
<h1 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h1><p>git remote rename [shortOldName] [shortNewName]// 修改一个远程仓库的简写名（引用）<br>git remote rm [shortname] // 移除一个源<br>git remote show [remoteName] // 查看某一个远程仓库的更多信息<br>git remote // 查看远程仓库（origin代表你本地clone的远程地址）<br>git remote -v // 查看远程仓库（带fetch、push地址）<br>git remote add [shortName] [url] // 添加远程仓库（shortname为以后的引用名）<br>git remote set-url [shortOldName] [url] // 修改源[shortOldName]的地址<br>git remote // 管理一组跟踪的存储库<br>git remote // 查询当前库的远程库<br>git remote -v // （--verbose）查看库的远程fetch和push地址（前提是有对应权限）<br>git remote add [shortName] [remoteUrl] // 添加远程仓库[shortName]为其简短引用</p>
<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>适用于在处理需要较长时间的任务task1时又有紧急任务task2需要处理，可以通过git stash来保存本次的修改并将工作目录恢复到HEAD提交，等完成紧急任务task2后又继续之前的任务task1<br>git stash // 将当前任务存储起来（保存本地修改，并恢复工作目录以匹配HEAD提交）<br>git stash list // 查看已存储的任务列表<br>git stash apply stash@{2} // 应用已存储的任务列表的第2+1条<br>git stash drop stash@{2} // 从已存储的任务列表移除第2+1条<br>git stash pop // 取出已保存的最近任务（git stash apply + git stash drop）<br>PS：适用于在处理需要较长时间的任务时，有紧急任务需要处理在其他分支处理</p>
<h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><p>用于创建，列出，删除或验证使用GPG签名的标签对象<br>git tag // 列出所有标签<br>git tag -a [tagName] -m [options] HEAD // 为当前HEAD创建标签<br>git tag -a [tagName] -m [options] [commitID] // 为某个commitID创建标签<br>git tag -l // 查看所有标签<br>git tag -d [tagName] // 删除某个标签<br>git tag -l ‘关键字’ // 列出满足关键字的标签<br>git tag -v [tagName] // 查询tagName是否已经使用<br>git tag [tagName] // 创建轻量级标签（轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件，其实就是不带-a，-s 或 -m）<br>git tag -a [tagName] -m [说明] // 创建一个带说明的标签名为tagName的标签<br>git tag -a [tagName] [commitId] // 为某个commitId创建tagName<br>PS：实质tag保存在.git/refs/tags中</p>
<h1 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h1><p>用于初始化或更新或检查子模块<br>场景：基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，下面介绍下基本使用步骤<br>克隆含有子模块的项目<br>git clone [remoteUrl] // clone 主项目<br>git submodule init // 初始化本地配置文件<br>git submodule update // clone相关的子模块<br>或者<br>git clone --recursive [remoteUrl] // 先clone主项目，再递归clone子模块<br>为项目添加子项目<br>git submodule add [remoteUrl] // 添加子模块，[remoteUrl]为子模块远程地址<br>删除某个子项目<br>git rm --cached [subModuleName]<br>rm -rf [subModuleName]<br>rm .gitmodules<br>vim .git/config<br>git commit -a -m ‘remove [subModuleName] submodule’<br><a href="https://www.yiibai.com/git/git_submodule.html#article-start" target="_blank" rel="noopener">git submodule命令</a></p>
<h1 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h1><p>用于显示各种类型的对象<br>git show [tagName] // 查看相应标签的版本信息<br>git show [tagName]^{tree} // 显示标签[tagName]指向的树<br>git show -s --format=%s [tagName]^{commit} // 显示标签[tagName]指向的提交主题<br>git show next~10:Documentation/README //<br>git show [commitId] // 查看某次提交的内容</p>
<h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><p>git format-patch // 创建最新提交的修补程序<br>git format-patch [commitId] // 为指定[commitId]创建补丁<br>git apply [补丁标记id] // 使用补丁修改本地文件而不创建提交<br>git am [补丁标记id] // 使用补丁修改本地文件并创建提交 </p>
<h1 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h1><p>用于获取并设置存储库或全局选项<br>git config --list // 查看所有的git配置<br>git config [key] // 查看特定项配置</p>
<h1 id="重置分支"><a href="#重置分支" class="headerlink" title="重置分支"></a>重置分支</h1><p>git branch -D [branchName] // 删除本地分支<br>git push [远程主机名] -d [远程分支名] // 删除远程分支<br>git fetch [远程主机名] master:[本地分支名] // 以远程的master作为本地的[本地分支名]<br>git push [远程主机名] [本地分支名] // 将本地分支推送到远端<br>git branch --set-upstream-to [远程主机名]/[远程分支名]<br>git checkout -b [localBranchName] [upstream]/[remoteBranchName]</p>
<h1 id="gitignore文件常用操作"><a href="#gitignore文件常用操作" class="headerlink" title=".gitignore文件常用操作"></a>.gitignore文件常用操作</h1><p>git update-index –assume-unchanged -path 可以忽略文件<br><br>git update-index –no-assume-unchanged –path 可以取消忽略文件<br></p>
<h1 id="查端口所用PID，并kill【2019-02-01更新】"><a href="#查端口所用PID，并kill【2019-02-01更新】" class="headerlink" title="查端口所用PID，并kill【2019-02-01更新】"></a>查端口所用PID，并kill【2019-02-01更新】</h1><h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><p>lsof -i:port号 // 查端口所用PID<br>kill PID // 杀掉进程</p>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>netstat -aon | findstr port号 // 查端口所用PID<br>tasklist | findstr PID // 根据PID查进程<br>taskkill /pid  PID -t -f // 杀掉进程</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>git init // 创建一个空的Git仓库或重新初始化一个现有仓库<br>git reflog // 查看所有分支的所有操作记录（包括commit和reset的操作）<br>git cherry-pick [commitHash] // 把某个分支的commit作为一个新的commit引入到你当前分支上<br>git help // 查看帮助列表<br>git help [key] // 查看特定[key]相关帮助<br>git mergetool // 用于运行合并冲突解决工具来解决合并冲突<br>git blame [file] // 用来定位每一行代码的最后一次修改者<br>ifconfig // 查看ip地址等信息<br>ipconfig // 查看ip地址（window）</p>
<h1 id="Git-异常处理清单"><a href="#Git-异常处理清单" class="headerlink" title="Git 异常处理清单"></a>Git 异常处理清单</h1><p>更新于[2020-06-08]<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 本地工作区文件恢复</span><br><span class="line">git checkout &lt;filename/dirname&gt;</span><br><span class="line">// 远程分支删除后，删除本地分支及关联</span><br><span class="line">git branch --set-upstream-to=origin/master master</span><br><span class="line">git push origin --delete feature/test</span><br><span class="line">git branch --unset-upstream &lt;branchname&gt;</span><br><span class="line">// 修改分支名</span><br><span class="line">git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;</span><br><span class="line">// 撤回提交</span><br><span class="line">git reset --soft [&lt;commit-id&gt;/HEAD~n&gt;] // 只撤销commit</span><br><span class="line">git reset --mixed [&lt;commit-id&gt;/HEAD~n&gt;] // 撤销stage Index + commit</span><br><span class="line">git reset --hard [&lt;commit-id&gt;/HEAD~n&gt;] // 撤销work Space + stage Index + commit </span><br><span class="line">// 撤销本地分支合并</span><br><span class="line">git revert &lt;commit-id&gt;</span><br><span class="line">// 时光机</span><br><span class="line">git reflog</span><br><span class="line">// 恢复误删的本地分支</span><br><span class="line">git checkout -b &lt;branch-name&gt; &lt;commit-id&gt;</span><br><span class="line">// 查看哪个分支有自己提交的 commit &lt;commit-id&gt;</span><br><span class="line">git branch --contains &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://mp.weixin.qq.com/s/GKdhcb0ekirjg4jEwERizA" target="_blank" rel="noopener">一份值得收藏的 Git 异常处理清单</a></p>
<blockquote>
<p>   参考文档：<br><a href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-A:-%E5%85%B6%E5%AE%83%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84-Git-Bash-%E4%B8%AD%E7%9A%84-Git" target="_blank" rel="noopener">配置tab快捷键补全</a><br><a href="https://blog.csdn.net/ligang2585116/article/details/71094887" target="_blank" rel="noopener">Git撤销&amp;回滚操作</a><br><a href="https://shfshanyue.github.io/cheat-sheets/git" target="_blank" rel="noopener">Git Cheat Sheet</a><br><a href="https://github.com/git-tips/tips" target="_blank" rel="noopener">git-tips</a></p>
</blockquote>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Geolocation（地理定位）</title>
    <url>/2018/html5-Geolocation.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地理位置提供定制的信息。<br>其实Geolocation 就是用来获取到当前设备的经纬度（位置）<br>带有此接口的对象可以用由 Navigator实现的属性NavigatorGeolocation.geolocation 来获得。<br>PS：鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="检测是否支持地理定位"><a href="#检测是否支持地理定位" class="headerlink" title="检测是否支持地理定位"></a>检测是否支持地理定位</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (navigator.geolocation) &#123;</span><br><span class="line">	// 做相应的操作 </span><br><span class="line">&#125; else &#123;</span><br><span class="line">	console.error(&apos;不支持地理&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取当前定位"><a href="#获取当前定位" class="headerlink" title="获取当前定位"></a>获取当前定位</h2><p>Geolocation.getCurrentPosition(success, error, options)<br>    确定设备的位置并返回一个携带位置信息的 Position 对象。<br>参数：</p>
<h3 id="success"><a href="#success" class="headerlink" title="success"></a>success</h3><p>成功得到位置信息时的回调函数，使用Position 对象作为唯一的参数。 </p>
<h4 id="Position-coords-只读（latitude、longitude、accuracy）"><a href="#Position-coords-只读（latitude、longitude、accuracy）" class="headerlink" title="Position.coords 只读（latitude、longitude、accuracy）"></a>Position.coords 只读（latitude、longitude、accuracy）</h4><p>返回一个定义了当前位置的Coordinates 对象.<br>    coords.latitude    十进制数的纬度<br>    coords.longitude    十进制数的经度<br>    coords.accuracy    位置精度<br>    coords.altitude    海拔，海平面以上以米计<br>    coords.altitudeAccuracy    位置的海拔精度<br>    coords.heading    方向，从正北开始以度计<br>    coords.speed    速度，以米/每秒计</p>
<h4 id="Position-timestamp-只读"><a href="#Position-timestamp-只读" class="headerlink" title="Position.timestamp 只读"></a>Position.timestamp 只读</h4><p>返回一个时间戳DOMTimeStamp， 这个时间戳表示获取到的位置的时间。</p>
<h3 id="error-可选"><a href="#error-可选" class="headerlink" title="error 可选"></a>error 可选</h3><p>获取位置信息失败时的回调函数，使用 PositionError 对象作为唯一的参数，这是一个可选项。 </p>
<h4 id="PositionError-code-只读"><a href="#PositionError-code-只读" class="headerlink" title="PositionError.code 只读"></a>PositionError.code 只读</h4><p>返回无符号的、简短的错误码。<br>    PERMISSION_DENIED–权限问题<br>    POSITION_UNAVAILABLE–内部错误<br>    TIMEOUT–超时</p>
<h4 id="PositionError-message-只读"><a href="#PositionError-message-只读" class="headerlink" title="PositionError.message 只读"></a>PositionError.message 只读</h4><p>返回一个开发者可以理解的 DOMString 来描述错误的详细信息。</p>
<h3 id="options-可选"><a href="#options-可选" class="headerlink" title="options 可选"></a>options 可选</h3><h5 id="一个可选的PositionOptions-对象。"><a href="#一个可选的PositionOptions-对象。" class="headerlink" title="一个可选的PositionOptions 对象。"></a>一个可选的PositionOptions 对象。</h5><pre><code>enableHighAccuracy: false;--是否高精度，默认false 
timeout: 5000;--超时事件ms 
maximumAge: 0; 地理位置缓存时长ms
</code></pre><h2 id="监视定位"><a href="#监视定位" class="headerlink" title="监视定位"></a>监视定位</h2><p>Geolocation.watchPosition(success[, error[, options]])<br>    用于注册监听器，在设备的地理位置发生改变的时候自动被调用。也可以选择特定的错误处理函数。<br>    该方法会返回一个 ID，如要取消监听可以通过  Geolocation.clearWatch() 传入该 ID 实现取消的目的。<br>参数：</p>
<h3 id="success-1"><a href="#success-1" class="headerlink" title="success"></a>success</h3><p>成功时候的回调函数， 同时传入一个 Position 对象当作参数。</p>
<h3 id="error-可选-1"><a href="#error-可选-1" class="headerlink" title="error 可选"></a>error 可选</h3><p>失败时候的回调函数，可选， 会传入一个 PositionError 对象当作参数。</p>
<h3 id="options-可选-1"><a href="#options-可选-1" class="headerlink" title="options 可选"></a>options 可选</h3><p>一个可选的 PositionOptions 对象。<br>PS：Position、PositionError、PositionOptions对象和上面一样。</p>
<h2 id="清理监视定位"><a href="#清理监视定位" class="headerlink" title="清理监视定位"></a>清理监视定位</h2><p>Geolocation.clearWatch(id)<br>    这个方法主要用于使用 Geolocation.watchPosition() 注册的 位置/错误 监听器。<br>参数：</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>希望移除的监听器所对应的 Geolocation.watchPosition() 返回的 ID 数字。<br>    Geolocation.watchPosition()注册一个位置改变监听器，每当设备位置改变时，返回一个 long 类型的该监听器的ID值。<br>Geolocation.clearWatch()<br>    取消由 watchPosition()注册的位置监听器。</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation" target="_blank" rel="noopener">Geolocation</a><br>    <a href="http://www.runoob.com/html/html5-geolocation.html" target="_blank" rel="noopener">HTML5 Geolocation（地理定位）</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionError" target="_blank" rel="noopener">PositionError</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PositionOptions" target="_blank" rel="noopener">PositionOptions</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/watchPosition" target="_blank" rel="noopener">watchPosition</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>MathML</title>
    <url>/2018/html5-MathML.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。<br>MathML 是一个用于标记数学表达式的 XML 词汇表，它包含两个子语言：Presentation MathML 和 Content MathML。<br>Presentation MathML 主要负责描述数学表达式的布局（因此可与 TeX 或更早的 SGML 标记语言相比较，SGML 用于描述诸如 ISO 12083 之类格式的数学表达式的布局）。<br>Content MathML 主要负责标记表达式的某些含义或数学结构。MathML 的这一方面受到 OpenMath 语言的很大影响，在 MathML3 中，与 OpenMath 更为贴近。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;</span><br><span class="line">	&lt;mrow&gt;</span><br><span class="line">		&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</span><br><span class="line">		&lt;mo&gt;+&lt;/mo&gt;	</span><br><span class="line">		&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</span><br><span class="line">		&lt;mo&gt;=&lt;/mo&gt;</span><br><span class="line">		&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;</span><br><span class="line">	&lt;/mrow&gt;</span><br><span class="line">&lt;/math&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/12/mathml1.jpg" alt="demo"></p>
<h1 id="MathML-元素"><a href="#MathML-元素" class="headerlink" title="MathML 元素"></a>MathML 元素</h1><p>这是一份关于 MathML 呈现型元素的、按字母表排序的清单。<br>MathML元素的细节和在桌面浏览器与移动设备浏览器上的兼容性情况。</p>
<h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p><code>&lt;math&gt;  （顶层元素）</code></p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;maction&gt;   （绑定动作到子表达式）</span><br><span class="line">&lt;maligngroup&gt; （对齐分组）</span><br><span class="line">&lt;malignmark&gt;  （对齐点）</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;menclose&gt; （包含的内容）</span><br><span class="line">&lt;merror&gt; （包含的语法错误消息）</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mfenced&gt; （圆括号）</span><br><span class="line">&lt;mfrac&gt; （因子）</span><br></pre></td></tr></table></figure>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><code>&lt;mglyph&gt; （显示非标准符号）</code></p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p><code>&lt;mi&gt; （标识符）</code></p>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mlabeledtr&gt;（表格或矩阵中的行标签）</span><br><span class="line">&lt;mlongdiv&gt;（长除法记号）</span><br></pre></td></tr></table></figure>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><code>&lt;mmultiscripts&gt; （惯例和张量指标）</code></p>
<h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><p><code>&lt;mn&gt; （数量）</code></p>
<h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mo&gt; （运算符）</span><br><span class="line">&lt;mover&gt; （上标）</span><br></pre></td></tr></table></figure>
<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mpadded&gt;（内容周围的填充空间）</span><br><span class="line">&lt;mphantom&gt; （预留空间的不可见内容）</span><br></pre></td></tr></table></figure>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mroot&gt; （带指定根数的根号）</span><br><span class="line">&lt;mrow&gt; （分组后的子表达式）</span><br></pre></td></tr></table></figure>
<h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ms&gt; （字符串字面量）</span><br><span class="line">&lt;mscarries&gt; （诸如进位的附注）</span><br><span class="line">&lt;mscarry&gt; （单位进位， </span><br><span class="line">&lt;mscarries&gt;的子元素）</span><br><span class="line">&lt;msgroup&gt; （在 &lt;mstack&gt; 和 </span><br><span class="line">&lt;mlongdiv&gt;元素中分组后的若干行）</span><br><span class="line">&lt;msline&gt; （在 &lt;mstack&gt; 内部的水平行）</span><br><span class="line">&lt;mspace&gt; （空格）</span><br><span class="line">&lt;msqrt&gt; （不带根数的平方根）</span><br><span class="line">&lt;msrow&gt; （在&lt;mstack&gt;元素中的行）</span><br><span class="line">&lt;mstack&gt; （堆叠式对齐）</span><br><span class="line">&lt;mstyle&gt; （样式变更）</span><br><span class="line">&lt;msub&gt; （下角标）</span><br><span class="line">&lt;msup&gt; （上角标）</span><br><span class="line">&lt;msubsup&gt; （上下角标对）</span><br></pre></td></tr></table></figure>
<h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mtable&gt; （表格或矩阵）</span><br><span class="line">&lt;mtd&gt; （表格或矩阵中的单元格）</span><br><span class="line">&lt;mtext&gt; （文本）</span><br><span class="line">&lt;mtr&gt; （表格或矩阵中的行）</span><br></pre></td></tr></table></figure>
<h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;munder&gt; （下标）</span><br><span class="line">&lt;munderover&gt; （上标-下标对）</span><br></pre></td></tr></table></figure>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;semantics&gt; （语义附注的容器）</span><br><span class="line">&lt;annotation&gt; （数据附注）</span><br><span class="line">&lt;annotation-xml&gt;  （XML 附注）</span><br></pre></td></tr></table></figure>
<h1 id="MathML-属性"><a href="#MathML-属性" class="headerlink" title="MathML 属性"></a>MathML 属性</h1><p>关于MathML属性的参考文档。用这些属性可以修改这些元素的显示效果。</p>
<iframe heigth="50vh" width="100%" src="https://developer.mozilla.org/zh-CN/docs/Web/MathML/Attribute"><br></iframe>







<p>PS：MathML的 mstyle 和 math 元素接受所有 MathML 的描述元素。<br>    请参阅MathML中值（values）和单位的注释值。</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/MathML" target="_blank" rel="noopener">MDN-MathML</a><br>    <a href="http://www.runoob.com/html/html5-mathml.html" target="_blank" rel="noopener">html5-mathml</a><br>    <a href="https://www.ibm.com/developerworks/cn/xml/x-mathml3/" target="_blank" rel="noopener">MathML 介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>IndexDB探索之路</title>
    <url>/2018/html5-IndexDB.html</url>
    <content><![CDATA[<p><a href="https://fanerge.github.io/indexedDB/static/">demo地址</a></p>
<h1 id="什么是-IndexDB？"><a href="#什么是-IndexDB？" class="headerlink" title="什么是 IndexDB？"></a>什么是 IndexDB？</h1><p>IndexedDB 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供索引功能以实现高性能查找. 像其他基于 SQL 的 关系型数据库管理系统 (RDBMS) 一样, IndexedDB 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的.</p>
<h2 id="IndexDB-的特点"><a href="#IndexDB-的特点" class="headerlink" title="IndexDB 的特点"></a>IndexDB 的特点</h2><p>IndexDB 和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。<br>IndexDB API包含异步(asynchronous) API 和同步(synchronous)API两种。  异步API适合大多数情况, 同步API必须同 WebWorkers一同使用.</p>
<h2 id="为什么我们要使用-IndexDB？"><a href="#为什么我们要使用-IndexDB？" class="headerlink" title="为什么我们要使用 IndexDB？"></a>为什么我们要使用 IndexDB？</h2><p>WebStorage在浏览器中有大小限制，存放较大的数据就不能满足了。<br>IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql.<br>IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）.</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IndexedDB-数据库使用key-value键值对储存数据"><a href="#IndexedDB-数据库使用key-value键值对储存数据" class="headerlink" title="IndexedDB 数据库使用key-value键值对储存数据"></a>IndexedDB 数据库使用key-value键值对储存数据</h2><p>key可以是二进制对象。<br>values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。<br>你可以对对象的某个属性创建索引（index）以实现快速查询和列举排序。</p>
<h2 id="IndexedDB-是事务模式的数据库"><a href="#IndexedDB-是事务模式的数据库" class="headerlink" title="IndexedDB 是事务模式的数据库"></a>IndexedDB 是事务模式的数据库</h2><p>任何操作都发生在事务(transaction)中。<br>IndexedDB API提供了索引(indexes), 表(tables), 指针(cursors)等等,<br>但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。<br>当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。<br>如果没有事务操作的支持，这两个实例就会互相影响对方的修改。</p>
<h2 id="IndexedDB-API-基本上是异步的"><a href="#IndexedDB-API-基本上是异步的" class="headerlink" title="IndexedDB API 基本上是异步的"></a>IndexedDB API 基本上是异步的</h2><p>IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。<br>执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。<br>当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。<br>类似于XMLHttpRequest。</p>
<h2 id="IndexedDB数据库“请求”无处不在"><a href="#IndexedDB数据库“请求”无处不在" class="headerlink" title="IndexedDB数据库“请求”无处不在"></a>IndexedDB数据库“请求”无处不在</h2><p>数据库“请求”负责接受成功或失败的DOM事件。<br>每一个“请求”都包含onsuccess和onerror事件属性，同时你还对“事件”调用addEventListener()和removeEventListener()。<br>“请求”还包括readyState，result和errorCode属性，用来表示“请求”的状态。<br>result属性尤其神奇，他可以根据“请求”生成的方式变成不同的东西，例如：IDBCursor实例、刚插入数据库的数值对应的键值（key）等。</p>
<h2 id="IndexedDB在结果准备好之后通过DOM事件通知用户"><a href="#IndexedDB在结果准备好之后通过DOM事件通知用户" class="headerlink" title="IndexedDB在结果准备好之后通过DOM事件通知用户"></a>IndexedDB在结果准备好之后通过DOM事件通知用户</h2><p>DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。<br>DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。<br>成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。<br>这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。</p>
<h2 id="IndexedDB是面向对象的"><a href="#IndexedDB是面向对象的" class="headerlink" title="IndexedDB是面向对象的"></a>IndexedDB是面向对象的</h2><p>indexedDB不是用二维表来表示集合的关系型数据库。这一点非常重要，将影响你设计和建立你的应用程序。​​​​<br>传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象存储(object Store)，只要这种数据一个JavaScript对象即可。<br>每个对象存储都有一个索引(index)集合以方便查询和迭代遍历。</p>
<h2 id="indexedDB不使用结构化查询语言（SQL）"><a href="#indexedDB不使用结构化查询语言（SQL）" class="headerlink" title="indexedDB不使用结构化查询语言（SQL）"></a>indexedDB不使用结构化查询语言（SQL）</h2><p>它通过索引(index)所产生的指针(cursor)来完成查询操作，从而使你可以迭代遍历到结果集合。</p>
<h2 id="IndexedDB遵循同源（same-origin）策略"><a href="#IndexedDB遵循同源（same-origin）策略" class="headerlink" title="IndexedDB遵循同源（same-origin）策略"></a>IndexedDB遵循同源（same-origin）策略</h2><p>“源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。<br>在同一个“源”内的所有数据库都有唯一、可区别的名称。</p>
<h1 id="使用-IndexedDB"><a href="#使用-IndexedDB" class="headerlink" title="使用 IndexedDB"></a>使用 IndexedDB</h1><h2 id="检测浏览器支持情况"><a href="#检测浏览器支持情况" class="headerlink" title="检测浏览器支持情况"></a>检测浏览器支持情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (window.indexedDB) &#123;</span><br><span class="line">	// todo</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	alert(&apos;您的浏览器不支持indexdb&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我将会以demo来做常用的数据库操作说明，使用火狐浏览器做测试。</p>
<h2 id="新建数据库-关闭数据库"><a href="#新建数据库-关闭数据库" class="headerlink" title="新建数据库/关闭数据库"></a>新建数据库/关闭数据库</h2><p>indexedDB 有一个open(indexDbName[, version])，这个方法会打开某个数据库，若不存在则新建。<br>第一个参数为数据库名称 ‘demo’，第二个参数为 版本号。<br>db为打开数据库成功回掉 event.target.result 戴白哦数据库实例，有 close() 为关闭该数据库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createDatabase(indexDbName) &#123;</span><br><span class="line">	</span><br><span class="line">	// 不存在则新建，存在则打开</span><br><span class="line">	let openRequest = indexedDB.open(indexDbName);</span><br><span class="line">	</span><br><span class="line">	openRequest.onerror = function(event) &#123;</span><br><span class="line">        console.log(&quot;Database error: &quot; + event.target.errorCode);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">	openRequest.onsuccess = function(event) &#123;</span><br><span class="line">		console.log(&quot;Database created&quot;);</span><br><span class="line">		let db = event.target.result;</span><br><span class="line">		// db.close();</span><br><span class="line">		console.log(&quot;this is :&quot;+db);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	//更改数据库，或者存储对象时候在这里处理</span><br><span class="line">	openRequest.onupgradeneeded = function (e) &#123;</span><br><span class="line">		console.log(e);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBIns.png" alt="新建数据库"></p>
<h2 id="确定数据结构并添加数据"><a href="#确定数据结构并添加数据" class="headerlink" title="确定数据结构并添加数据"></a>确定数据结构并添加数据</h2><p>onupgradeneeded 唯一可以修改数据库结构的地方。<br>在 indexedDB 中一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。<br>创建 objectStore 的方法为数据库实例的 createObjectStore(name[, options]);<br>删除 objectStore 的方法为数据库实例的 deleteObjectStore(name);<br>其中options 有两个可选key，分别是 keyPath（选择objectStore中某个指定字段作为键值）、autoIncrement（若为true，objectStore有一个key generator）<br>我们创建好的 objectStore 也有一些方法：<br>createIndex(indexName, keyPath[, objectParameters]) 该方法作用为创建一个索引来通过 indexName 搜索 objectStore 里的数据。<br>objectStore.add(value[, key]) 该方法作用为将数据添加到 objectStore 中。<br>介绍了相关的方法，我们就通过循环来向 objectStore 添加数据。<br>下面是具体实现代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insertData(indexDbName)&#123;</span><br><span class="line">	// 带写入的数据</span><br><span class="line">	const customerData = [</span><br><span class="line">	  &#123; ssn: &quot;444-44-4444&quot;, name: &quot;Bill&quot;, age: 35, email: &quot;bill@company.com&quot; &#125;,</span><br><span class="line">	  &#123; ssn: &quot;555-55-5555&quot;, name: &quot;Donna&quot;, age: 32, email: &quot;donna@home.org&quot; &#125;</span><br><span class="line">	];</span><br><span class="line">	</span><br><span class="line">	// 如果在没有新建数据库时写入数据，这里只能带高版本的数据库版本才能出发 onupgradeneeded 事件</span><br><span class="line">	let openRequest = indexedDB.open(indexDbName, &apos;3.0&apos;);</span><br><span class="line">	</span><br><span class="line">	openRequest.onerror = function(e) &#123;</span><br><span class="line">		console.log(&quot;Database error: &quot; + e.target.errorCode);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	openRequest.onsuccess = function(event) &#123;</span><br><span class="line">		console.log(&quot;Database created&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	openRequest.onupgradeneeded = function(event) &#123;</span><br><span class="line">		</span><br><span class="line">		console.log(&quot;开始写入数据&quot;);</span><br><span class="line">		let db = event.target.result;</span><br><span class="line">		// keyPath、autoIncrement</span><br><span class="line">		let objectStore = db.createObjectStore(&quot;customers&quot;, &#123; keyPath: &quot;ssn&quot; &#125;);</span><br><span class="line">		objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125;);</span><br><span class="line">		objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, &#123; unique: true &#125;);</span><br><span class="line">		</span><br><span class="line">		for (let item of customerData) &#123;</span><br><span class="line">			objectStore.add(item);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 删除 objectStore</span><br><span class="line">		// db.deleteObjectStore(&quot;customers&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p26lefllv.bkt.clouddn.com/indexed%20DBIns1.png" alt="新建数据库"><br>PS： 这里有个坑，需要说明一下。<br>onupgradeneeded事件在下列情况下被触发：<br>1.数据库第一次被打开时即新建<br>2.打开数据库时指定的版本号高于当前被持久化的数据库版本号</p>
<h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>添加数据在 onsuccess 钩子中进行。<br>IndexedDB 添加数据通过事务来添加数据。<br>下面重点介绍下 transaction(storeNames[, mode]);<br>第一个参数是事务希望跨越的对象存储空间的列表。<br>第二个参数事务中可以执行的访问类型。<br>返回一个事务对象。<br>事务可以接收三种不同类型的 DOM 事件： error，abort，以及 complete。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addData(storeName) &#123;</span><br><span class="line">	const datas = [</span><br><span class="line">	  &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;,</span><br><span class="line">	  &#123; ssn: &quot;777-77-7777&quot;, name: &quot;sdsd&quot;, age: 22, email: &quot;sdsd@home.org&quot; &#125;</span><br><span class="line">	];</span><br><span class="line">	</span><br><span class="line">	let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</span><br><span class="line">	</span><br><span class="line">	openRequest.onerror = function(e) &#123;</span><br><span class="line">		console.log(&quot;Database error: &quot; + e.target.errorCode);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	openRequest.onsuccess = function(event) &#123;</span><br><span class="line">		let db = event.target.result;</span><br><span class="line">		let transaction=db.transaction(storeName,&apos;readwrite&apos;);</span><br><span class="line">        let store=transaction.objectStore(storeName); </span><br><span class="line">		</span><br><span class="line">		for(let i=0;i&lt;datas.length;i++)&#123;</span><br><span class="line">            store.add(datas[i]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBAdd.png" alt="添加数据"></p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>同样删除数据也使用 transaction。<br>唯一区别是使用了 objectStore的 delete(key)，该方法为删除指定key的数据项。<br>objectStore 还有一个方法 clear()清空该 store 中的数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function del66(key)&#123;</span><br><span class="line">	let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</span><br><span class="line">	</span><br><span class="line">	openRequest.onerror = function(e) &#123;</span><br><span class="line">		console.log(&quot;Database error: &quot; + e.target.errorCode);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	openRequest.onsuccess = function(event) &#123;</span><br><span class="line">		let db = event.target.result;</span><br><span class="line">		let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</span><br><span class="line">		let store=transaction.objectStore(&apos;customers&apos;); </span><br><span class="line">		let request = store.delete(key);</span><br><span class="line">		</span><br><span class="line">		request.onsuccess = function(event) &#123;</span><br><span class="line">			console.log(&apos;删除成功&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		request.onerror = function(event) &#123;</span><br><span class="line">			console.log(&apos;删除失败&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>同样查找数据也使用 transaction。<br>唯一区别是使用了 objectStore的 get(key)，该方法为删除指定key的数据项。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getDataByKey(key)&#123;</span><br><span class="line">	let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</span><br><span class="line">	</span><br><span class="line">	openRequest.onerror = function(e) &#123;</span><br><span class="line">		console.log(&quot;Database error: &quot; + e.target.errorCode);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	openRequest.onsuccess = function(event) &#123;</span><br><span class="line">		let db = event.target.result;</span><br><span class="line">		let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</span><br><span class="line">		let store=transaction.objectStore(&apos;customers&apos;); </span><br><span class="line">		let request = store.get(key);</span><br><span class="line">		</span><br><span class="line">		request.onsuccess = function(event) &#123;</span><br><span class="line">			let item =event.target.result; </span><br><span class="line">			console.log(item); // 获得的该数据项</span><br><span class="line">			console.log(&apos;查找成功&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		request.onerror = function(event) &#123;</span><br><span class="line">			console.log(&apos;查找失败&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>可以调用object store的put方法更新数据，会自动替换键值相同的记录，达到更新目的，没有相同的则添加，以使用keyPath做键为例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function updateDataByKey(key)&#123;</span><br><span class="line">	let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;);</span><br><span class="line">	</span><br><span class="line">	openRequest.onerror = function(e) &#123;</span><br><span class="line">		console.log(&quot;Database error: &quot; + e.target.errorCode);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	openRequest.onsuccess = function(event) &#123;</span><br><span class="line">		let db = event.target.result;</span><br><span class="line">		let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;);</span><br><span class="line">		let store=transaction.objectStore(&apos;customers&apos;); </span><br><span class="line">		let request = store.get(key);</span><br><span class="line">		</span><br><span class="line">		request.onsuccess = function(event) &#123;</span><br><span class="line">			let item =event.target.result; </span><br><span class="line">			 // &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;</span><br><span class="line">			item.ssn = &quot;666-66-6666&quot;</span><br><span class="line">			item.name = &quot;yuzhenfan&quot;</span><br><span class="line">			item.age = 18</span><br><span class="line">			item.email = &quot;yzf@alipay.com&quot;</span><br><span class="line">            store.put(item); </span><br><span class="line">			console.log(&apos;更新成功&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		request.onerror = function(event) &#123;</span><br><span class="line">			console.log(&apos;更新失败&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p26lefllv.bkt.clouddn.com/indexedDBupdate.png" alt="更新数据"></p>
<blockquote>
<p>   参考文档<br><a href="https://www.cnblogs.com/lovelgx/articles/6026957.html" target="_blank" rel="noopener">数据库写入时机</a><br><a href="http://www.php.cn/html5-tutorial-359628.html" target="_blank" rel="noopener">html5使用indexdb的代码实例分享</a><br><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">wiki-数据库事务</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IndexedDB" target="_blank" rel="noopener">MDN-IndexedDB</a><br><a href="http://w3c.github.io/IndexedDB/" target="_blank" rel="noopener">w3c-IndexDB-API</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB" target="_blank" rel="noopener">IndexDB-Guides</a><br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">HTML5本地存储——IndexedDB（一：基本使用）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>html5-svg开发手册</title>
    <url>/2018/html5-svg%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.html</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h2><ol>
<li>img的src</li>
<li>background-image: url()</li>
<li>object: data</li>
<li>embed: src</li>
<li>foreignObject<br>foreignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。<h2 id="样式的写法（优先级逐渐降低）"><a href="#样式的写法（优先级逐渐降低）" class="headerlink" title="样式的写法（优先级逐渐降低）"></a>样式的写法（优先级逐渐降低）</h2>1.内联style<br><code>&lt;g style=&quot;fill: red;&quot;&gt;&lt;/g&gt;</code><br>2.class<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;g class=&quot;font&quot;&gt;&lt;/g&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[</span><br><span class="line">.font &#123;</span><br><span class="line">	fill: red;</span><br><span class="line">&#125;</span><br><span class="line">]]&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.外链样式表<br><code>&lt;?xml-stylesheet href=&quot;style.css&quot; type=&quot;text\css&quot; ?&gt;</code><br>4.样式属性<br><code>&lt;g fill=&quot;red&quot;&gt;&lt;/g&gt;</code></p>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[解析器忽略的内容]]&gt;</span><br><span class="line">作用：xml解析器忽略解析，将表示为纯文本。</span><br></pre></td></tr></table></figure>
<p>默认用户坐标（视口svg的width和height）<br>指定用户坐标（viewBox属性）<br>保持宽高比（SVG的宽高和viewBox的宽高比是不一样），使用preserveAspectRatio属性<br>preserveAspectRatio=”xMidYMid meet”<br>第1个值表示，viewBox如何与SVG viewport对齐；第2个值表示，如何维持高宽比（如果有）。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><p>class、style</p>
<h2 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h2><p>color、display、opacity、overflow<br>fill、fill-opacity、fill-rule<br>stroke、stroke-dasharray、stroke-dashoffset、stroke-linecap、stroke-linejoin、stroke-miterlimit、stroke-opacity、stroke-width</p>
<h2 id="动画事件属性"><a href="#动画事件属性" class="headerlink" title="动画事件属性"></a>动画事件属性</h2><p>onbegin, onend, onload, onrepeat</p>
<h2 id="动画属性目标属性"><a href="#动画属性目标属性" class="headerlink" title="动画属性目标属性"></a>动画属性目标属性</h2><p>attributeType, attributeName</p>
<h2 id="动画定时属性"><a href="#动画定时属性" class="headerlink" title="动画定时属性"></a>动画定时属性</h2><p>begin, dur, end, min, max, restart, repeatCount, repeatDur, fill</p>
<h2 id="动画值属性"><a href="#动画值属性" class="headerlink" title="动画值属性"></a>动画值属性</h2><p>calcMode, values, keyTimes, keySplines, from, to, by, autoReverse, accelerate, decelerate</p>
<h2 id="动画累加属性"><a href="#动画累加属性" class="headerlink" title="动画累加属性"></a>动画累加属性</h2><p>additive, accumulate</p>
<h2 id="条件处理属性"><a href="#条件处理属性" class="headerlink" title="条件处理属性"></a>条件处理属性</h2><p>requiredExtensions, requiredFeatures, systemLanguage.</p>
<h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><p>id, xml:base, xml:lang, xml:space</p>
<h2 id="文档事件属性"><a href="#文档事件属性" class="headerlink" title="文档事件属性"></a>文档事件属性</h2><p>onabort, onerror, onresize, onscroll, onunload, onzoom</p>
<h2 id="过滤器原始属性"><a href="#过滤器原始属性" class="headerlink" title="过滤器原始属性"></a>过滤器原始属性</h2><p>height, result, width, x, y</p>
<h2 id="图形事件属性"><a href="#图形事件属性" class="headerlink" title="图形事件属性"></a>图形事件属性</h2><p>onactivate, onclick, onfocusin, onfocusout, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup</p>
<h1 id="svg-元素"><a href="#svg-元素" class="headerlink" title="svg 元素"></a>svg 元素</h1><h2 id="基本形状元素"><a href="#基本形状元素" class="headerlink" title="基本形状元素"></a>基本形状元素</h2><h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><p>line元素是一个SVG基本形状，用来创建一条连接两个点的线。<br>属性：x1、y1、x2、y2<br><code>&lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;5&quot; y2=&quot;5&quot;&gt;&lt;/line&gt;</code></p>
<h3 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h3><p>用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形。<br>属性：x、y、width、height、rx、ry<br><code>&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; rx=&quot;3&quot; ry=&quot;3&quot;&gt;&lt;/rect&gt;</code></p>
<h3 id="circle"><a href="#circle" class="headerlink" title="circle"></a>circle</h3><p>用来创建圆,基于一个圆心和一个半径。<br>属性：cx、cy、r<br><code>&lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;5&quot;&gt;&lt;/circle&gt;</code></p>
<h3 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse"></a>ellipse</h3><p>用来创建一个椭圆，基于一个中心坐标以及它们的x半径和y半径。<br>利用transform属性椭圆的倾斜。<br>属性：cx、cy、rx、ry<br><code>&lt;ellipse cx=&quot;60&quot; cy=&quot;60&quot; rx=&quot;50&quot; ry=&quot;25&quot;/&gt;</code></p>
<h3 id="polygon"><a href="#polygon" class="headerlink" title="polygon"></a>polygon</h3><p>polygon元素定义了一个由一组点左边的构成的闭合多边形形状。<br>属性：points<br><code>&lt;polygon points=&quot;100,40 100,80 60,100 20,80 20,40&quot;/&gt;</code></p>
<h3 id="polyline"><a href="#polyline" class="headerlink" title="polyline"></a>polyline</h3><p>用来创建一系列直线连接多个点。典型的一个polyline是用来创建一个开放的形状，最后一点不与第一点相连。<br>属性：points<br><code>&lt;polyline fill=&quot;none&quot; stroke=&quot;black&quot; points=&quot;20,100 40,60 70,80 100,20&quot;/&gt;</code></p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path元素是用来定义形状的通用元素。所有的基本形状都可以用path元素来创建。<br>属性：d（data）、pathLength<br>PS：d属性有下列值（大写字母为绝对坐标，小写字母为相对坐标）<br>M（m）-x，y-移动到给定坐标。<br>L（l）-x，y-绘制一条到给定坐标的线，可以提供多组坐标来绘制折线。<br>H（h）-x-绘制一条到给定x坐标的水平线。<br>V（v）-y-绘制一条到指定y坐标的竖线。<br>A（a）-rx ry x-axis-rotation large-arc-flag sweep-flag x y。<br>Q（q）-x1，y1，x，y-绘制一条从当前点到（x，y），控制点为（x1，y1）的二次贝塞尔曲线。<br>T（t）-x，y-绘制一条从当前点到（x，y）的二次贝塞尔曲线，控制点是前一个Q命令的控制点的中心对称点。如果没有前一条曲线，当前点会被用作控制点。<br>C（c）-x1，y1，x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，x1和x2分别为开始和终点控制点。<br>S（s）-x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，使用x2作为终点控制点，开始控制点为前一个C命令的终点控制点的中心对称点。<br><code>&lt;path d=&quot;M 100 100 L 300 100 L 200 300 z&quot; /&gt;</code><br>PS：x-axis-rotation为x轴旋转角度，large-arc-flag为角度大小，sweep-flag（弧线方向）<br>large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。<br>sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。</p>
<h2 id="功能元素"><a href="#功能元素" class="headerlink" title="功能元素"></a>功能元素</h2><h3 id="title（提升可访问性）"><a href="#title（提升可访问性）" class="headerlink" title="title（提升可访问性）"></a>title（提升可访问性）</h3><p>SVG绘图中的每个窗口元素或图形元素都可以提供一个title描述性字符串，该描述只能是纯文本。<br>title元素必须是它的父元素的第一个子元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;g&gt;</span><br><span class="line">   &lt;title&gt;SVG Title Demo example&lt;/title&gt;</span><br><span class="line">   &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;200&quot; height=&quot;50&quot; style=&quot;fill:none; stroke:blue; stroke-width:1px&quot;/&gt;</span><br><span class="line">	&lt;desc&gt;提升可访问性&lt;/desc&gt;</span><br><span class="line">&lt;/g&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="desc（提升可访问性）"><a href="#desc（提升可访问性）" class="headerlink" title="desc（提升可访问性）"></a>desc（提升可访问性）</h3><p>SVG绘画中的每个容器元素或图形元素都可以提供一个desc描述性字符串，这些描述只是纯文本的。</p>
<h3 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h3><p>SVG 允许我们定义以后需要重复使用的图形元素， 建议把所有需要再次使用的引用元素定义在defs元素里面。<br>需要使用\&lt;use>元素来呈现defs定义的元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">	&lt;linearGradient id=&quot;Gradient01&quot;&gt;</span><br><span class="line">		&lt;stop offset=&quot;20%&quot; stop-color=&quot;#39F&quot; /&gt;</span><br><span class="line">		&lt;stop offset=&quot;90%&quot; stop-color=&quot;#F3F&quot; /&gt;</span><br><span class="line">	&lt;/linearGradient&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;60&quot; height=&quot;10&quot; fill=&quot;url(#Gradient01)&quot;  /&gt;</span><br><span class="line">PS：radialGradient、linearGradient、pattern等元素必须要放在defs元素中</span><br></pre></td></tr></table></figure></p>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>use元素在SVG文档内取得目标节点，并在别的地方复制它们。<br>属性：x、y、width、height、href<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;g id=&quot;Port&quot;&gt;</span><br><span class="line">      &lt;circle style=&quot;fill: inherit;&quot; r=&quot;10&quot;/&gt;</span><br><span class="line">    &lt;/g&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;use x=&quot;50&quot; y=&quot;10&quot; href=&quot;#Port&quot; /&gt;</span><br><span class="line">&lt;use x=&quot;50&quot; y=&quot;30&quot; href=&quot;#Port&quot; class=&quot;classA&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>使用 SVG 的锚元素\&lt;a>定义一个超链接。<br>属性：href、target<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;www.alipay.com&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">    &lt;rect height=&quot;30&quot; width=&quot;120&quot; y=&quot;0&quot; x=&quot;0&quot; rx=&quot;15&quot;/&gt;</span><br><span class="line">    &lt;text fill=&quot;white&quot; text-anchor=&quot;middle&quot; y=&quot;21&quot; x=&quot;60&quot;&gt;SVG on MDN&lt;/text&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="clipPath"><a href="#clipPath" class="headerlink" title="clipPath"></a>clipPath</h3><p>clipPath用于指定可绘制区域（超出了剪切路径所指定的区域，将不会被绘制。）。<br>属性：clipPathUnits=”userSpaceOnUse’或’objectBoundingBox”。第二个值childern一个对象的边框，会使用掩码的一小部分单位（默认：”userSpaceOnUse”）”<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;clipPath id=&quot;myClip&quot;&gt;</span><br><span class="line">      &lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;20&quot;/&gt;</span><br><span class="line">    &lt;/clipPath&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; clip-path=&quot;url(#myClip)&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>PS：其他元素通过clip-path=”引用剪贴路径和引用剪贴路径交叉”</p>
<h3 id="color-profile"><a href="#color-profile" class="headerlink" title="color-profile"></a>color-profile</h3><p>该元素允许描述用于图像的颜色配置文件。<br>属性：local、name、rendering-intent、href</p>
<h3 id="foreignObject"><a href="#foreignObject" class="headerlink" title="foreignObject"></a>foreignObject</h3><p>foreignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。这个被包含的外来图形内容服从SVG变形和合成。<br>foreignObject元素通常与 switch 元素和requiredExtensions属性联用，来做兼容。</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>SVG文档中的SVG元素包含图像信息。它表现为图像文件或者其他SVG文件。<br>属性：x、y、width、height、href、preserveAspectRatio（控制图像比例）</p>
<h3 id="linearGradient"><a href="#linearGradient" class="headerlink" title="linearGradient"></a>linearGradient</h3><p>linearGradient元素用来定义线性渐变，用于图形元素的填充或描边。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;linearGradient id=&quot;MyGradient&quot;&gt;</span><br><span class="line">        &lt;stop offset=&quot;5%&quot;  stop-color=&quot;green&quot;/&gt;</span><br><span class="line">        &lt;stop offset=&quot;95%&quot; stop-color=&quot;gold&quot;/&gt;</span><br><span class="line">    &lt;/linearGradient&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect fill=&quot;url(#MyGradient)&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>属性：gradientUnits、gradientTransform、x1、y1、x2、y2、spreadMethod、href</p>
<h3 id="radialGradient"><a href="#radialGradient" class="headerlink" title="radialGradient"></a>radialGradient</h3><p>radialGradient用来定义径向，用于图形元素的填充或描边。<br>属性：gradientUnits、gradientTransform、cx、cy、r、fx、fy、spreadMethod、href<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;radialGradient id=&quot;exampleGradient&quot;&gt;</span><br><span class="line">      &lt;stop offset=&quot;10%&quot; stop-color=&quot;gold&quot;/&gt;</span><br><span class="line">      &lt;stop offset=&quot;95%&quot; stop-color=&quot;green&quot;/&gt;</span><br><span class="line">    &lt;/radialGradient&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;circle fill=&quot;url(#exampleGradient)&quot; cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>一个渐变上的颜色坡度，是用stop元素定义的。<br>stop元素可以是linearGradient、radialGradient的子元素。</p>
<h3 id="marker"><a href="#marker" class="headerlink" title="marker"></a>marker</h3><p>marker元素定义了在特定的path、line、polyline、polygon上绘制的箭头或者多边标记图形。<br>属性：marker-end、marker-mid、marker-start、markerUnits、refx、refy、markerWidth、markerHeight、orient<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;marker id=&quot;Triangle&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;1&quot; refY=&quot;5&quot; markerWidth=&quot;6&quot; markerHeight=&quot;6&quot; orient=&quot;auto&quot;&gt;</span><br><span class="line">      &lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; /&gt;</span><br><span class="line">    &lt;/marker&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;polyline points=&quot;10,90 50,80 90,20&quot; fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#Triangle)&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><p>在SVG中，你可以指一个透明的遮罩层和当前对象合成，形成背景。属性mask用来引用一个遮罩元素。<br>属性：maskUnits、maskContentUnits、x、y、width、height</p>
<h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>metadata是数据的结构化数据。</p>
<h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>使用预定义的图形对一个对象进行填充或描边，就要用到pattern元素，在下轴或y轴上重复。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;pattern id=&quot;Triangle&quot; width=&quot;10&quot; height=&quot;10&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;</span><br><span class="line">		&lt;polygon points=&quot;5,0 10,10 0,10&quot;/&gt;</span><br><span class="line">	&lt;/pattern&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;circle cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;url(#Triangle)&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>text元素定义了一个由文字组成的图形。注意：我们可以将渐变、图案、剪切路径、遮罩或者滤镜应用到text上。<br>属性：x、y、dx、dy、text-anchor、rotate、textLength、lengthAdjust<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text x=&quot;0&quot; y=&quot;20&quot; transform=&quot;rotate(30 20,40)&quot;&gt;</span><br><span class="line">    SVG Text Rotation example</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="textPath"><a href="#textPath" class="headerlink" title="textPath"></a>textPath</h3><p>textPath使用path来展示文字。<br>属性：startOffset、method、spacing、href<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;path id=&quot;MyPath&quot; fill=&quot;none&quot; stroke=&quot;red&quot; d=&quot;M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50&quot; /&gt;</span><br><span class="line">&lt;text&gt;</span><br><span class="line">	&lt;textPath href=&quot;#MyPath&quot;&gt;</span><br><span class="line">	  The quick brown fox jumps over the lazy dog.</span><br><span class="line">	&lt;/textPath&gt;</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="tspan"><a href="#tspan" class="headerlink" title="tspan"></a>tspan</h3><p>在text元素中，利用内含的tspan元素，可以调整文本和字体的属性以及当前文本的位置、绝对或相对坐标值。<br>属性：x、y、dx、dy、rotate、textLength、lengthAdjust<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text x=&quot;15&quot; y=&quot;30&quot;&gt;</span><br><span class="line">    You are </span><br><span class="line">    &lt;tspan&gt;not&lt;/tspan&gt; </span><br><span class="line">    a banana</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view元素是查看图片的一个限定方法，就像一个缩放级别或者一个详细视图。<br>属性：viewBox、preserveAspectRatio、zoomAndPan、viewTarget</p>
<h2 id="不显示元素"><a href="#不显示元素" class="headerlink" title="不显示元素"></a>不显示元素</h2><h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><p>元素g是用来组合对象的容器，对与transform、属性会作用与子元素。<br>通过\&lt;use>    元素来实现组合对象的复制。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;g stroke=&quot;green&quot; fill=&quot;white&quot; stroke-width=&quot;5&quot;&gt;</span><br><span class="line">    &lt;circle cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;</span><br><span class="line">    &lt;circle cx=&quot;40&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;</span><br><span class="line">&lt;/g&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>一个SVG脚本元素等同于HTML中的script元素。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set元素可以用来设定一个属性值，并为该值赋予一个持续时间。</p>
<h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>style元素元素样式表直接在SVG内容中间嵌入。</p>
<h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>如果svg不是根元素，svg 元素可以用于在当前文档内嵌套一个独立的svg片段 。<br>这个独立片段拥有独立的视口和坐标系统。<br>属性：version、baseProfile、x、y、width、height、preserveAspectRatio、contentScriptType、contentStyleType、viewBox</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch元素对它的直接子元素上的属性requiredFeatures、属性requiredExtensions 和 属性systemLanguage按照顺序进行评估，然后处理和呈现第一个评估为true的子元素。<br>属性：allowReorder<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;switch&gt;</span><br><span class="line">	&lt;text systemLanguage=&quot;ar&quot;&gt;مرحبا&lt;/text&gt;</span><br><span class="line">	&lt;text systemLanguage=&quot;ja&quot;&gt;こんにちは&lt;/text&gt;</span><br><span class="line">	&lt;text&gt;☺&lt;/text&gt;</span><br><span class="line">   &lt;/switch&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。<br>symbol元素对图形的作用是在同一文档中多次使用，添加结构和语义。<br>属性：preserveAspectRatio、viewBox<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt;</span><br><span class="line">	&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line">	&lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot;/&gt;</span><br><span class="line">&lt;/symbol&gt;</span><br><span class="line">&lt;!-- actual drawing by &quot;use&quot; element --&gt;</span><br><span class="line">&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot;/&gt;</span><br><span class="line">&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="动画元素"><a href="#动画元素" class="headerlink" title="动画元素"></a>动画元素</h2><h3 id="animate"><a href="#animate" class="headerlink" title="animate"></a>animate</h3><p>动画元素放在形状元素的内部，用来定义一个元素的某个属性根据时间点如何改变。<br>属性：attributeName、attributeType（CSS/XML）、from、to、dur、repeatCount<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;</span><br><span class="line">    &lt;animate attributeType=&quot;XML&quot; attributeName=&quot;x&quot; from=&quot;-100&quot; to=&quot;120&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;/&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h3><p>animateMotion元素导致引用的元素沿着运动路径移动。<br>属性：calcMode、path、keyPoints、rotate、origin<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;path d=&quot;M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110&quot; stroke=&quot;lightgrey&quot; stroke-width=&quot;2&quot;  fill=&quot;none&quot; id=&quot;theMotionPath&quot;/&gt;</span><br><span class="line">&lt;circle cx=&quot;&quot; cy=&quot;&quot; r=&quot;5&quot; fill=&quot;red&quot;&gt;</span><br><span class="line">    &lt;animateMotion dur=&quot;6s&quot; repeatCount=&quot;indefinite&quot;&gt;</span><br><span class="line">		&lt;mpath xlink:href=&quot;#theMotionPath&quot;/&gt;</span><br><span class="line">    &lt;/animateMotion&gt;</span><br><span class="line">&lt;/circle&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="mpath"><a href="#mpath" class="headerlink" title="mpath"></a>mpath</h3><p>animateMotion元素的 mpath 子元素使 animateMotion 元素能够引用一个外部的 path 元素作为运动路径的定义。<br>属性：href</p>
<h3 id="animateTransform"><a href="#animateTransform" class="headerlink" title="animateTransform"></a>animateTransform</h3><p>animateTransform元素变动了目标元素上的一个变形属性，从而允许动画控制转换、缩放、旋转或斜切。<br>属性：by、from、to、type<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;polygon points=&quot;60,30 90,90 30,90&quot;&gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot;</span><br><span class="line">		attributeType=&quot;XML&quot;</span><br><span class="line">		type=&quot;rotate&quot;</span><br><span class="line">		from=&quot;0 60 70&quot;</span><br><span class="line">		to=&quot;360 60 70&quot;</span><br><span class="line">		dur=&quot;10s&quot;</span><br><span class="line">		repeatCount=&quot;indefinite&quot;/&gt;</span><br><span class="line">&lt;/polygon&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="滤镜元素"><a href="#滤镜元素" class="headerlink" title="滤镜元素"></a>滤镜元素</h2><h3 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h3><p>x、y、width、height属性置顶应用滤镜的画布的尺寸。<br>filterUnits指定用来定义滤镜范围的单位。<br>primitiveUnits为滤镜基元中的各种长度值指定坐标系统。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter元素作用是作为原子滤镜操作的容器。它不能直接呈现。可以利用目标SVG元素上的filter属性引用一个滤镜。<br>属性：x、y、width、height、filterRes、filterUnits、primitiveUnits、href<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter id=&quot;blurMe&quot;&gt;</span><br><span class="line">	&lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot;/&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;circle cx=&quot;60&quot;  cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; /&gt;</span><br><span class="line">&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="feBlend"><a href="#feBlend" class="headerlink" title="feBlend"></a>feBlend</h3><p>feBlend滤镜把两个对象组合在一起，使它们受特定的混合模式控制。这类似于图像编辑软件中混合两个图层。该模式由属性mode定义。<br>属性：in、in2、mode<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;filter id=&quot;spotlight&quot;&gt;</span><br><span class="line">		&lt;feFlood result=&quot;floodFill&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; flood-color=&quot;green&quot; flood-opacity=&quot;1&quot;/&gt;</span><br><span class="line">		&lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;floodFill&quot; mode=&quot;multiply&quot;/&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;image xlink:href=&quot;/files/6457/mdn_logo_only_color.png&quot; x=&quot;10%&quot; y=&quot;10%&quot; width=&quot;80%&quot; height=&quot;80%&quot; style=&quot;filter:url(#spotlight);&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="feColorMatrix（颜色转换滤镜）"><a href="#feColorMatrix（颜色转换滤镜）" class="headerlink" title="feColorMatrix（颜色转换滤镜）"></a>feColorMatrix（颜色转换滤镜）</h3><p>该滤镜基于转换矩阵对颜色进行变换。每一像素的颜色值(一个表示为[R,G,B,A] 的矢量)都经过矩阵乘法计算出的新颜色。<br>属性：in、type、values</p>
<h3 id="feComponentTransfer"><a href="#feComponentTransfer" class="headerlink" title="feComponentTransfer"></a>feComponentTransfer</h3><p>SVG滤镜基元对每个像素执行颜色分量的数据重映射.它允许进行像亮度调整,对比度调整,色彩平衡或阈值的操作。<br>属性：in</p>
<h3 id="feFuncR"><a href="#feFuncR" class="headerlink" title="feFuncR"></a>feFuncR</h3><p>该滤镜为它的父<fecomponenttransfer>元素的输入图形的红色成分定义了变换函数。<br>属性：type、tableValues、slope、intercept、amplitude、exponent、offset</fecomponenttransfer></p>
<h3 id="feFuncG"><a href="#feFuncG" class="headerlink" title="feFuncG"></a>feFuncG</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的绿色成分定义了变换函数。</p>
<h3 id="feFuncB"><a href="#feFuncB" class="headerlink" title="feFuncB"></a>feFuncB</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的蓝色成分定义了变换函数。</p>
<h3 id="feFuncA"><a href="#feFuncA" class="headerlink" title="feFuncA"></a>feFuncA</h3><p>该滤镜为它的父feComponentTransfer元素的输入图形的alpha成分定义了变换函数。</p>
<h3 id="feComposite（合成滤镜）"><a href="#feComposite（合成滤镜）" class="headerlink" title="feComposite（合成滤镜）"></a>feComposite（合成滤镜）</h3><p>该滤镜执行两个输入图像的智能像素组合，在图像空间中使用以下Porter-Duff合成操作之一：over、in、atop、xor<br>属性：in、in2、operator、k1、k2、k3、k4</p>
<h3 id="feConvolveMatrix"><a href="#feConvolveMatrix" class="headerlink" title="feConvolveMatrix"></a>feConvolveMatrix</h3><p>feConvolveMatrix元素应用了一个矩阵卷积滤镜效果。一个卷积在输入图像中把像素与邻近像素组合起来制作出结果图像。<br>属性：in、order、kernelMatrix、divisor、bias、targetX、targetY、edgeMode、kernelUnitLength、preserveAlpha</p>
<h3 id="feDiffuseLighting（散开照明滤镜）"><a href="#feDiffuseLighting（散开照明滤镜）" class="headerlink" title="feDiffuseLighting（散开照明滤镜）"></a>feDiffuseLighting（散开照明滤镜）</h3><p>滤镜光照一个图像，使用alpha通道作为隆起映射。<br>属性：in、surfaceScale、diffuseConstant、kernelUnitLength</p>
<h3 id="feDisplacementMap"><a href="#feDisplacementMap" class="headerlink" title="feDisplacementMap"></a>feDisplacementMap</h3><p>映射置换滤镜，该滤镜用来自图像中从in2到空间的像素值置换图像从in到空间的像素值。<br>属性：in、in2、scale、xChannelSelector、yChannelSelector</p>
<h3 id="feDistantLight（平行光滤镜）"><a href="#feDistantLight（平行光滤镜）" class="headerlink" title="feDistantLight（平行光滤镜）"></a>feDistantLight（平行光滤镜）</h3><p>该滤镜定义了一个距离光源，可以用在灯光滤镜feDiffuseLighting元素或feSpecularLighting元素的内部。<br>属性：azimuth、elevation</p>
<h3 id="feFlood"><a href="#feFlood" class="headerlink" title="feFlood"></a>feFlood</h3><p>该滤镜用flood-color元素定义的颜色和flood-opacity元素定义的不透明度填充了滤镜子区域。<br>属性：flood-color、flood-opacity</p>
<h3 id="feGaussianBlur（高斯模糊滤镜）"><a href="#feGaussianBlur（高斯模糊滤镜）" class="headerlink" title="feGaussianBlur（高斯模糊滤镜）"></a>feGaussianBlur（高斯模糊滤镜）</h3><p>该滤镜对输入图像进行高斯模糊，属性stdDeviation中指定的数量定义了钟形。<br>属性：in、stdDeviation<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter id=&quot;blurMe&quot;&gt;</span><br><span class="line">    &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot; /&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="feImage（图片滤镜）"><a href="#feImage（图片滤镜）" class="headerlink" title="feImage（图片滤镜）"></a>feImage（图片滤镜）</h3><p>feImage滤镜从外部来源取得图像数据，并提供像素数据作为输出（意味着如果外部来源是一个SVG图像，这个图像将被栅格化。）<br>属性：preserveAspectRatio、href</p>
<h3 id="feMerge（合并滤镜）"><a href="#feMerge（合并滤镜）" class="headerlink" title="feMerge（合并滤镜）"></a>feMerge（合并滤镜）</h3><p>feMerge滤镜允许同时应用滤镜效果而不是按顺序应用滤镜效果。利用result存储别的滤镜的输出可以实现这一点，然后在一个feMergeNode子元素中访问它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter id=&quot;feOffset&quot; x=&quot;-40&quot; y=&quot;-20&quot; width=&quot;100&quot; height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;feMerge&gt;</span><br><span class="line">		&lt;feMergeNode in=&quot;blur2&quot; /&gt;</span><br><span class="line">		&lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt;</span><br><span class="line">    &lt;/feMerge&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;rect x=&quot;40&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #000000; fill: green; filter: url(#feOffset);&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="feMergeNode"><a href="#feMergeNode" class="headerlink" title="feMergeNode"></a>feMergeNode</h3><p>feMergeNode元素拿另一个滤镜的结果，让它的父feMerge元素处理。<br>属性：in</p>
<h3 id="feMorphology（扩张滤镜）"><a href="#feMorphology（扩张滤镜）" class="headerlink" title="feMorphology（扩张滤镜）"></a>feMorphology（扩张滤镜）</h3><p>该滤镜用来侵蚀或扩张输入的图像。它在增肥或瘦身效果方面特别有用。<br>属性：in、operator、radius</p>
<h3 id="feOffset（位移滤镜）"><a href="#feOffset（位移滤镜）" class="headerlink" title="feOffset（位移滤镜）"></a>feOffset（位移滤镜）</h3><p>该输入图像作为一个整体，在属性dx和属性dy的值指定了它的偏移量。<br>属性：in、dx、dy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter id=&quot;offset&quot; width=&quot;180&quot; height=&quot;180&quot;&gt;</span><br><span class="line">    &lt;feOffset in=&quot;SourceGraphic&quot; dx=&quot;60&quot; dy=&quot;60&quot; /&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; stroke=&quot;black&quot; fill=&quot;green&quot; filter=&quot;url(#offset)&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="fePointLight（点光源滤镜）"><a href="#fePointLight（点光源滤镜）" class="headerlink" title="fePointLight（点光源滤镜）"></a>fePointLight（点光源滤镜）</h3><p>SVG创建一个点光源效果。<br>属性：x、y、z</p>
<h3 id="feSpecularLighting（镜子照明滤镜）"><a href="#feSpecularLighting（镜子照明滤镜）" class="headerlink" title="feSpecularLighting（镜子照明滤镜）"></a>feSpecularLighting（镜子照明滤镜）</h3><p>该滤镜照亮一个源图形，使用alpha通道作为隆起映射。<br>属性：in、surfaceScale、specularConstant、specularExponent、kernelUnitLength</p>
<h3 id="feSpotLight（斑点照明滤镜）"><a href="#feSpotLight（斑点照明滤镜）" class="headerlink" title="feSpotLight（斑点照明滤镜）"></a>feSpotLight（斑点照明滤镜）</h3><p>feSpotLight元素是一种光源元素，用于SVG文件。<br>属性：x、y、z、pointsAtX、pointsAtY、pointsAtZ、specularExponent、limitingConeAngle</p>
<h3 id="feTile（平铺滤镜）"><a href="#feTile（平铺滤镜）" class="headerlink" title="feTile（平铺滤镜）"></a>feTile（平铺滤镜）</h3><p>输入图像是平铺的，结果用来填充目标。它的效果近似于一个pattern图案对象。<br>属性：in</p>
<h3 id="feTurbulence"><a href="#feTurbulence" class="headerlink" title="feTurbulence"></a>feTurbulence</h3><p>该滤镜利用Perlin噪声函数创建了一个图像。它实现了人造纹理比如说云纹、大理石纹的合成。<br>属性：baseFrequency、numOctaves、seed、stitchTiles、type</p>
<blockquote>
<p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="noopener">MDN-SVG系列资料</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute#Transfer_function_attributes" target="_blank" rel="noopener">svg-属性参考</a><br><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/an-in-depth-svg-tutorial.md" target="_blank" rel="noopener">掘金翻译-深入浅出 SVG</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Worker</title>
    <url>/2018/html5-webWorker.html</url>
    <content><![CDATA[<p><a href="https://fanerge.github.io/H5WebWorker/static/">先放上demo，打开控制台试试</a></p>
<h1 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker"></a>什么是Web Worker</h1><p>Web Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。<br>局限性：在worker内不能直接操作DOM节点，或者使用window对象的默认方法和属性。</p>
<h1 id="Worker特性检测"><a href="#Worker特性检测" class="headerlink" title="Worker特性检测"></a>Worker特性检测</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(window.Worker)&#123;</span><br><span class="line">	// todo</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	// 不支持web Worker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：假设页面为index.html，页面js为main.js，这里的path是相对于index.html到该worker.js。</p>
<h1 id="专用Worker"><a href="#专用Worker" class="headerlink" title="专用Worker"></a>专用Worker</h1><h2 id="生成一个专用worker"><a href="#生成一个专用worker" class="headerlink" title="生成一个专用worker"></a>生成一个专用worker</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myWorker = new Worker(&apos;worker.js&apos;);</span><br></pre></td></tr></table></figure>
<p>PS：假设页面为index.html，页面主线程js为main.js，这里的path是相对于index.html到该worker.js。</p>
<h2 id="主线程js和Worker的通信（数据交互）"><a href="#主线程js和Worker的通信（数据交互）" class="headerlink" title="主线程js和Worker的通信（数据交互）"></a>主线程js和Worker的通信（数据交互）</h2><h3 id="主线程js（main-js-用来生成-myWorker）"><a href="#主线程js（main-js-用来生成-myWorker）" class="headerlink" title="主线程js（main.js 用来生成 myWorker）"></a>主线程js（main.js 用来生成 myWorker）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myWorker</span><br><span class="line">if(window.Worker)&#123;</span><br><span class="line">	// todo</span><br><span class="line">	myWorker = new Worker(&apos;./js/worker.js&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	// 不支持web Worker</span><br><span class="line">	alert(&apos;不支持web Worker&apos;)</span><br><span class="line">&#125;</span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    num: 1000000,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">	computed () &#123;</span><br><span class="line">		console.log(`Message posted to worker=$&#123;this.num&#125;`);</span><br><span class="line">		// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</span><br><span class="line">		myWorker.postMessage(this.num)</span><br><span class="line">	&#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>PS：如果想发送多个消息，可以这样myWorker.postMessage([msg1, msg2…])，对应接收的e.data对象也就是一个数组了，若是对象的话需要序列化，接收的时候需要反序列化。</p>
<h3 id="myWorker脚本代码"><a href="#myWorker脚本代码" class="headerlink" title="myWorker脚本代码"></a>myWorker脚本代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 有数据发过来，就触发</span><br><span class="line">onmessage = function(e) &#123;</span><br><span class="line">	let num1 = e.data;</span><br><span class="line">	let num2 = 0;</span><br><span class="line">	</span><br><span class="line">	console.time(&apos;计算耗时&apos;)</span><br><span class="line">	for(let i = 0; i &lt; num1; i++)&#123;</span><br><span class="line">		num2 += i;</span><br><span class="line">	&#125;</span><br><span class="line">	console.timeEnd(&apos;计算耗时&apos;)</span><br><span class="line">	</span><br><span class="line">	console.log(`Worker 计算结果=$&#123;num2&#125;`)</span><br><span class="line">	</span><br><span class="line">	// 当我们计算出结果，应该回传</span><br><span class="line">	postMessage(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我向一个Worker发送一个较大num，然后求出该1到num的整数和。<br>在页面中input的值分别为：1000000、10000000、100000000各执行了一次计算，最后一次花费了11s左右（算的上耗时计算了吧）。<br>下面是我的测试截图<br><img src="http://p26lefllv.bkt.clouddn.com/WebWorker.png" alt><br>就这么简单，我们就实现了主线程js和WebWorker的双向通信。</p>
<h2 id="终止worker"><a href="#终止worker" class="headerlink" title="终止worker"></a>终止worker</h2><h3 id="在主线程中终止"><a href="#在主线程中终止" class="headerlink" title="在主线程中终止"></a>在主线程中终止</h3><p>如果你需要从主线程中立刻终止一个运行中的worker，可以调用worker的terminate 方法：<br><code>myWorker.terminate();</code><br>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p>
<h3 id="在Worker中终止（自杀）"><a href="#在Worker中终止（自杀）" class="headerlink" title="在Worker中终止（自杀）"></a>在Worker中终止（自杀）</h3><p><code>close()</code></p>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>当然我们刚刚仅仅考虑了正常情况，还有需要错误等待我们处理呢？<br>当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。<br>它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。<br>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。<br>错误事件有以下三个用户关心的字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message</span><br><span class="line">	可读性良好的错误消息。</span><br><span class="line">filename</span><br><span class="line">	发生错误的脚本文件名。</span><br><span class="line">lineno</span><br><span class="line">	发生错误时所在脚本文件的行号。</span><br></pre></td></tr></table></figure></p>
<h2 id="生成subworker"><a href="#生成subworker" class="headerlink" title="生成subworker"></a>生成subworker</h2><p>如果需要的话 worker 能够生成更多的 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>而且，subworker 解析 URI 时会相对于父 worker 的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。</p>
<h2 id="在Worker中引入脚本与库"><a href="#在Worker中引入脚本与库" class="headerlink" title="在Worker中引入脚本与库"></a>在Worker中引入脚本与库</h2><p>Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">importScripts();                       </span><br><span class="line">importScripts(&apos;cube.js&apos;);                </span><br><span class="line">importScripts(&apos;cube1.js&apos;, &apos;cube2&apos;);</span><br></pre></td></tr></table></figure></p>
<h1 id="共享Worker（SharedWorker）"><a href="#共享Worker（SharedWorker）" class="headerlink" title="共享Worker（SharedWorker）"></a>共享Worker（SharedWorker）</h1><p>一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。<br>由于SharedWorker 与 专有Worker 非常相似，这里我只是提一下它们的区别。<br>读者若需要做测试的话，可以考虑在2个html页面中的javascript代码使用的是同一个worker。</p>
<h2 id="生成一个共享worker"><a href="#生成一个共享worker" class="headerlink" title="生成一个共享worker"></a>生成一个共享worker</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myWorker = new SharedWorker(&apos;worker.js&apos;);</span><br><span class="line">// 父级线程中的调用</span><br><span class="line">myWorker.port.start();</span><br><span class="line">// worker线程中的调用, 假设port变量代表一个端口  </span><br><span class="line">port.start();</span><br></pre></td></tr></table></figure>
<p>一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。<br>在使用start()方法打开端口连接时，如果父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。</p>
<h2 id="共享worker中消息的接收和发送"><a href="#共享worker中消息的接收和发送" class="headerlink" title="共享worker中消息的接收和发送"></a>共享worker中消息的接收和发送</h2><h3 id="主线程发送消息给Worker"><a href="#主线程发送消息给Worker" class="headerlink" title="主线程发送消息给Worker"></a>主线程发送消息给Worker</h3><p>改写我们的computed方法（vue组件中）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed () &#123;</span><br><span class="line">	console.log(`Message posted to worker=$&#123;this.num&#125;`);</span><br><span class="line">	// 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算</span><br><span class="line">	myWorker.port.postMessage(this.num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Worker接收到消息并处理及回传"><a href="#Worker接收到消息并处理及回传" class="headerlink" title="Worker接收到消息并处理及回传"></a>Worker接收到消息并处理及回传</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onconnect = function(e) &#123;</span><br><span class="line">	var port = e.ports[0];</span><br><span class="line"></span><br><span class="line">	port.onmessage = function(e) &#123;</span><br><span class="line">		// 同样e.data为主线程发送的数据</span><br><span class="line">		console.log(e.data)</span><br><span class="line">		//复杂的计算</span><br><span class="line">		let result = e.data*1000*23*3</span><br><span class="line">		// Worker需要回传至主线程</span><br><span class="line">		port.postMessage(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主线程接收并处理消息"><a href="#主线程接收并处理消息" class="headerlink" title="主线程接收并处理消息"></a>主线程接收并处理消息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myWorker.port.onmessage = function(e) &#123;</span><br><span class="line">	result2.textContent = e.data;</span><br><span class="line">	console.log(&apos;Message received from worker&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：总结差异，主线程和Worker都要执行start()，通信时需要带上port。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>Worker接口会生成真正的操作系统级别的线程，如果你不太小心，那么并发(concurrency)会对你的代码产生有趣的影响。然而，对于 web worker 来说，与其他线程的通信点会被很小心的控制，这意味着你很难引起并发问题。</p>
<h1 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP全称Content Security Policy为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。<br>可以限制如下资源的加载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script-src：外部脚本</span><br><span class="line">style-src：样式表</span><br><span class="line">img-src：图像</span><br><span class="line">media-src：媒体文件（音频和视频）</span><br><span class="line">font-src：字体文件</span><br><span class="line">object-src：插件（比如 Flash）</span><br><span class="line">child-src：框架</span><br><span class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</span><br><span class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</span><br><span class="line">worker-src：worker脚本</span><br><span class="line">manifest-src：manifest 文件</span><br></pre></td></tr></table></figure></p>
<p>除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。<br>但它必须与report-uri选项配合使用。<br><code>Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser;</code></p>
<h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</code></p>
<h3 id="服务器上设置"><a href="#服务器上设置" class="headerlink" title="服务器上设置"></a>服务器上设置</h3><p>以下语句设置在请求头部（Header）<br><code>Content-Security-Policy &quot;default-src &#39;self&#39;;&quot;</code><br>如果要为Worker指定CSP策略，可以为Worker脚本的请求的响应的头部设置CSP策略。<br>这时这个Worker会继承它所属的文档或者创建它的Worker的CSP策略。 </p>
<h2 id="worker中数据的接收与发送"><a href="#worker中数据的接收与发送" class="headerlink" title="worker中数据的接收与发送"></a>worker中数据的接收与发送</h2><p>在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。<br>传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。</p>
<blockquote>
<p>   参考手册<br>    <a href="http://balance9.iteye.com/blog/1992118" target="_blank" rel="noopener">测试html5专用线程与共享线程的区别</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">MDN-WebWorker</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">WebWorkerAPI</a><br>    <a href="https://cn.vuejs.org/v2/api/#v-model" target="_blank" rel="noopener">vue</a><br>    <a href="http://www.runoob.com/html/html5-webworkers.html" target="_blank" rel="noopener">HTML5 Web Workers</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid" target="_blank" rel="noopener">CSP</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP知识（前端相关）</title>
    <url>/2018/http%E5%BD%92%E7%BA%B3.html</url>
    <content><![CDATA[<h1 id="安全（Safe）"><a href="#安全（Safe）" class="headerlink" title="安全（Safe）"></a>安全（Safe）</h1><p>说一个HTTP方法是安全的，是说这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD和OPTIONS。<br>所有安全的方法都是idempotent（幂等），有些不安全的方法如PUT和DELETE则不是。<br>PS：网络爬虫也是依赖于安全的HTTP方法，安全方法: GET, HEAD, OPTIONS；非安全方法: PUT, DELETE, POST。<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe" target="_blank" rel="noopener">MDN-Safe</a></p>
<h1 id="幂等（Idempotent）"><a href="#幂等（Idempotent）" class="headerlink" title="幂等（Idempotent）"></a>幂等（Idempotent）</h1><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态（不是返回的状态码而是数据）也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p>
<h1 id="HTTP方法比较"><a href="#HTTP方法比较" class="headerlink" title="HTTP方法比较"></a>HTTP方法比较</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体（也就是说只存在响应头无响应体）。<br>PS：该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST方法用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改。 </p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>请求方法 PUT  用于新增资源或者使用请求中的有效负载替换目标资源的表现形式。<br>PS：PUT 与 POST 方法的区别在于，PUT方法是幂等的。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>DELETE 请求方法用于删除指定的资源。</p>
<h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>OPTIONS 方法 用于获取目的资源所支持的通信选项。在 CORS 作为预检请求。</p>
<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>TRACE 方法 实行了向目标资源的沿路径的消息环回(loop-back)测试 ，提供了一种实用的debug机制。</p>
<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><p>请求方法 PATCH  用于对资源进行部分修改。<br>PS：在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于  PUT 方法，而与 POST 方法类似，PATCH  方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="Cache-Control（请求头和响应头）"><a href="#Cache-Control（请求头和响应头）" class="headerlink" title="Cache-Control（请求头和响应头）"></a>Cache-Control（请求头和响应头）</h3><p>通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。<br>max-age：指定设置缓存最大的有效时间（单位为s）。<br>s-maxage：覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理CDN)，并且私有缓存中它被忽略。<br>public：表明响应可以被接收的客户端、代理服务器等缓存。<br>private：表明响应只能被客户端缓存，不能作为共享缓存（即代理服务器不能缓存它）。<br>no-cache：在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。<br>no-store：缓存不应存储有关客户端请求或服务器响应的任何内容。</p>
<h3 id="Expires（响应头）"><a href="#Expires（响应头）" class="headerlink" title="Expires（响应头）"></a>Expires（响应头）</h3><p>响应头包含日期/时间， 即在此时候之后，响应过期。<br>PS：如果在Cache-Control响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="Last-modified（响应头）"><a href="#Last-modified（响应头）" class="headerlink" title="Last-modified（响应头）"></a>Last-modified（响应头）</h3><p>它包含源头服务器认定的资源做出修改的日期及时间。<br>工作原理：浏览器首次请求资源是响应头中包含 Last-modified 字段，当再次请求时将上次 Last-modified 的值赋值给 If-Modified-Since 请求头，服务器根据对应资源的修改时间于 If-Modified-Since 的值进行比较，从而断定该资源是否被修改再响应304或200。</p>
<h3 id="ETag（响应头）"><a href="#ETag（响应头）" class="headerlink" title="ETag（响应头）"></a>ETag（响应头）</h3><p>工作原理：和 Last-modified（If-Modified-Since）工作原理基本一致，只不过服务器判断资源是否被更改的条件不是文件修改时间而是为资源生产的hash值是否发生变化。<br>PS：可以弥补 max-age 和 Last-modified 只能精确到秒的缺陷。<br><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/" target="_blank" rel="noopener">alloyteam-浅谈Web缓存</a></p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>shell笔记</title>
    <url>/2018/shell%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>最近公司需要做gitlab分支重置、部署、构建的可视化工具，涉及到Shell脚本相关的知识，先来补充一波。</p>
<h1 id="运行Shell脚本-amp-Shell-注释"><a href="#运行Shell脚本-amp-Shell-注释" class="headerlink" title="运行Shell脚本&amp;Shell 注释"></a>运行Shell脚本&amp;Shell 注释</h1><h2 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x ./demo.sh #使脚本具有执行权限</span><br><span class="line">./demo.sh #执行脚本</span><br></pre></td></tr></table></figure>
<h2 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/sh ./demo.sh</span><br></pre></td></tr></table></figure>
<h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>以 # 开头的行就是注释，会被解释器忽略。</p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>PS：EOF 也可以使用其他符号(‘ !)。</p>
<h1 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=fanerge </span><br><span class="line">name=&apos;fanerge&apos;</span><br><span class="line">name=&quot;fanerge&quot;</span><br></pre></td></tr></table></figure>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$name</span><br><span class="line">$&#123;name&#125;</span><br></pre></td></tr></table></figure>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=fanerge</span><br><span class="line">readonly name #表明该变量只读</span><br></pre></td></tr></table></figure>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset nmae</span><br></pre></td></tr></table></figure>
<h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=&quot;fanerge&quot;</span><br><span class="line">$&#123;#string&#125; # 7</span><br></pre></td></tr></table></figure>
<h2 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=&quot;fanerge&quot;</span><br><span class="line">$&#123;name:1&#125; # anerge</span><br><span class="line">$&#123;name:1:4&#125; # aner</span><br></pre></td></tr></table></figure>
<p>PS：分别代表开始位置和结束位置，没有结束位置则到字符串末尾</p>
<h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=&quot;fanerge&quot;</span><br><span class="line">`expr index &quot;$&#123;name&#125;&quot; e` # 4 // 从1开始计数</span><br></pre></td></tr></table></figure>
<h1 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h1><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=(1 2 3)</span><br></pre></td></tr></table></figure>
<h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;name[2]&#125; # 3 // 读取指定下标项目</span><br><span class="line">$&#123;name[*]&#125; # 1 2 3 // 读取数组所有项目</span><br><span class="line">$&#123;name[@]&#125; # 1 2 3 // 读取数组所有项目</span><br></pre></td></tr></table></figure>
<h2 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;#name[*]&#125; # 4</span><br><span class="line">$&#123;#name[@]&#125; # 4</span><br><span class="line">$&#123;#name[n]&#125; # n为下标，返回数组第n个项目的长度</span><br></pre></td></tr></table></figure>
<h2 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh test.sh f a n</span><br><span class="line">echo $0 # test.sh</span><br><span class="line">echo $1 # f</span><br></pre></td></tr></table></figure>
<p>PS：其他特殊符号。<br>参数处理    说明<br>$#    传递到脚本的参数个数<br>$<em>    以一个单字符串显示所有向脚本传递的参数。<br>如”$</em>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$$    脚本运行的当前进程ID号<br>$!    后台运行的最后一个进程的ID号<br>$@    与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br>$-    显示Shell使用的当前选项，与set命令功能相同。<br>$?    显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>
<h1 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h1><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val=`expr 2 + 3` # 5</span><br></pre></td></tr></table></figure>
<p>PS：表达式和运算符之间要有空格，加（+）、减（-）、乘（*）、除（/）、取余（%）、赋值（=）、条件表达式的等于（==）和不等于（!=）</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br>运算符    说明<br>-eq    检测两个数是否相等，相等返回 true。<br>-ne    检测两个数是否不相等，不相等返回 true。<br>-gt    检测左边的数是否大于右边的，如果是，则返回 true。<br>-lt    检测左边的数是否小于右边的，如果是，则返回 true。<br>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。<br>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。</p>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>运算符    说明<br>!    非运算，表达式为 true 则返回 false，否则返回 true。<br>-o    或运算，有一个表达式为 true 则返回 true。<br>-a    与运算，两个表达式都为 true 才返回 true。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>运算符    说明<br>&amp;&amp;    逻辑的 AND<br>||    逻辑的 OR</p>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>运算符    说明<br>=    检测两个字符串是否相等，相等返回 true。<br>!=    检测两个字符串是否相等，不相等返回 true。<br>-z    检测字符串长度是否为0，为0返回 true。<br>-n    检测字符串长度是否为0，不为0返回 true。<br>str    检测字符串是否为空，不为空返回 true。</p>
<h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。<br>操作符    说明<br>-b file    检测文件是否是块设备文件，如果是，则返回 true。<br>-c file    检测文件是否是字符设备文件，如果是，则返回 true。<br>-d file    检测文件是否是目录，如果是，则返回 true。<br>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。<br>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。<br>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。<br>-p file    检测文件是否是有名管道，如果是，则返回 true。<br>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。<br>-r file    检测文件是否可读，如果是，则返回 true。<br>-w file    检测文件是否可写，如果是，则返回 true。<br>-x file    检测文件是否可执行，如果是，则返回 true。<br>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。</p>
<h1 id="Shell-echo命令"><a href="#Shell-echo命令" class="headerlink" title="Shell echo命令"></a>Shell echo命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo I am fanerge</span><br><span class="line">echo &apos;I am fanerge&apos; # 原样输出</span><br><span class="line">echo &quot;I am fanerge&quot;</span><br><span class="line">echo &quot;\&quot;I am fanerge\&quot;&quot; # 带有转义字符</span><br><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义 \n为换行 \c为不换行</span><br><span class="line">echo `date` # 显示命令执行结果</span><br></pre></td></tr></table></figure>
<h1 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h1><p>printf  format-string  [arguments…]<br>参数说明：<br>    format-string: 为格式控制字符串<br>    arguments: 为参数列表。</p>
<h2 id="format-string部分参数"><a href="#format-string部分参数" class="headerlink" title="format-string部分参数"></a>format-string部分参数</h2><p>%d,用来输出十进制整数。<br>%f,用来输出实数（包括单，双精度），以小数形式输出，默认情况下保留小数点6位。<br>%c,用来输出一个字符。<br>%s,用来输出一个字符串。<br>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<h2 id="printf的转义序列"><a href="#printf的转义序列" class="headerlink" title="printf的转义序列"></a>printf的转义序列</h2><p>序列    说明<br>\a    警告字符，通常为ASCII的BEL字符<br>\b    后退<br>\c    抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略<br>\f    换页（formfeed）<br>\n    换行<br>\r    回车（Carriage return）<br>\t    水平制表符<br>\v    垂直制表符<br>\    一个字面上的反斜杠字符<br>\ddd    表示1到3位数八进制值的字符。仅在格式字符串中有效<br>\0ddd    表示1到3位的八进制值字符</p>
<h1 id="Shell-test-命令"><a href="#Shell-test-命令" class="headerlink" title="Shell test 命令"></a>Shell test 命令</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。<br>数值测试、字符串测试、文件测试类似<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &apos;两个数相等！&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个数不相等！&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h1 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>PS：let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;</span><br><span class="line">echo -n &apos;输入你最喜欢的网站URL: &apos;</span><br><span class="line">while read url</span><br><span class="line">do</span><br><span class="line">    echo &quot;是的！$&#123;url&#125; 是一个好网站&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>PS：while循环可用于读取键盘信息。</p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line">---------</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line">---------</span><br><span class="line">for (( ; ; ))</span><br></pre></td></tr></table></figure>
<h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>PS：until 循环执行一系列命令直至条件为 true 时停止，这恰好与 while 相反。</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">	command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>PS：case以esac结尾。</p>
<h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。<br>break命令<br>break命令允许跳出所有循环（终止执行后面的所有循环）。<br>continue<br>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<h1 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-------</span><br></pre></td></tr></table></figure>
<p>PS：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。<br>$1、$2、${10}分别代表第一个、第二个、第十个参数。<br>函数返回值在调用该函数后通过 $? 来获得。<br>参数处理    说明<br>$#    传递到脚本的参数个数<br>$<em>    以一个单字符串显示所有向脚本传递的参数<br>$$    脚本运行的当前进程ID号<br>$!    后台运行的最后一个进程的ID号<br>$@    与$</em>相同，但是使用时加引号，并在引号中返回每个参数。<br>$-    显示Shell使用的当前选项，与set命令功能相同。<br>$?    显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>
<h1 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h1><p>命令    说明<br>command &gt; file    将输出重定向到 file。<br>PS：注意任何file1内的已经存在的内容将被新内容替代。<br>command &lt; file    将输入重定向到 file。<br>command &gt;&gt; file    将输出以追加的方式重定向到 file。<br>PS：追加。<br>n &gt; file    将文件描述符为 n 的文件重定向到 file。<br>n &gt;&gt; file    将文件描述符为 n 的文件以追加的方式重定向到 file。<br>n &gt;&amp; m    将输出文件 m 和 n 合并。<br>n &lt;&amp; m    将输入文件 m 和 n 合并。<br>&lt;&lt; tag    将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<h1 id="Shell-文件包含"><a href="#Shell-文件包含" class="headerlink" title="Shell 文件包含"></a>Shell 文件包含</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. filename   # 注意点号(.)和文件名中间有一空格</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-基础知识</title>
    <url>/2018/vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h1 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h1><h2 id="单向与双向"><a href="#单向与双向" class="headerlink" title="单向与双向"></a>单向与双向</h2><p>Model&gt;View（单向）<br>Model&lt;&gt;View（单向）</p>
<h2 id="双向的原理"><a href="#双向的原理" class="headerlink" title="双向的原理"></a>双向的原理</h2><p>通过数据劫持和发布者-订阅者模式的方式来实现。</p>
<ol>
<li>数据劫持主要通过 Object.defineProperty(obj, prop, descriptor) 的set和get方法执行对应的改变视图的方法。</li>
<li>new Proxy(target, handler) 来实现数据劫持。</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js算法集合</title>
    <url>/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<h1 id="判断文本是否为回文"><a href="#判断文本是否为回文" class="headerlink" title="判断文本是否为回文"></a>判断文本是否为回文</h1><p>定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。</p>
<h2 id="方法一（字符串、数组内置方法）"><a href="#方法一（字符串、数组内置方法）" class="headerlink" title="方法一（字符串、数组内置方法）"></a>方法一（字符串、数组内置方法）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 判断文字是否为回文</span><br><span class="line">* @param &#123;string|number&#125; val 需要判断的文字</span><br><span class="line">* @return &#123;boolean&#125; bool 是否为回文 </span><br><span class="line">*/</span><br><span class="line">function isPalindrome1(val)&#123;</span><br><span class="line">	// 允许输入字符串和数字和布尔值</span><br><span class="line">	if (typeof val !== &apos;string&apos;) val = val.toString();</span><br><span class="line">	let newVal = val.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">	</span><br><span class="line">	return val === newVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPalindrome1(121) // true</span><br><span class="line">isPalindrome1(&apos;yuzuy&apos;) // true</span><br></pre></td></tr></table></figure>
<p>// PS：方法简单，但效率不高，会产生一个新的变量</p>
<h2 id="方法二（循环）"><a href="#方法二（循环）" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 判断文字是否为回文</span><br><span class="line">* @param &#123;string|number&#125; val 需要判断的文字</span><br><span class="line">* @return &#123;boolean&#125; bool 是否为回文 </span><br><span class="line">*/</span><br><span class="line">function isPalindrome2(val)&#123;</span><br><span class="line">	val = val + &apos;&apos;; // 非字符串转化为字符串</span><br><span class="line">	</span><br><span class="line">	// 这里为什么 i &lt;= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！</span><br><span class="line">	for(let i = 0, j = val.length - 1; i &lt; j; i++, j--)&#123;</span><br><span class="line">		if(val.charAt(i) !== val.charAt(j))&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPalindrome2(121) // true</span><br><span class="line">isPalindrome2(&apos;yuzuy&apos;) // true</span><br></pre></td></tr></table></figure>
<p>PS：网上还有其他解法，大多为以上两种的变形。</p>
<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="方法一（字符串、数组内置方法））"><a href="#方法一（字符串、数组内置方法））" class="headerlink" title="方法一（字符串、数组内置方法））"></a>方法一（字符串、数组内置方法））</h2><p>借用反转字符串的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 反转字符串</span><br><span class="line">* @param &#123;string&#125; val 需要反转的字符串</span><br><span class="line">* @return &#123;string&#125; str 反转后的字符串</span><br><span class="line">*/</span><br><span class="line">function reverseVal1(val)&#123;</span><br><span class="line">	if (typeof val !== &apos;string&apos;) return;</span><br><span class="line">	</span><br><span class="line">	return val.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二（循环）-1"><a href="#方法二（循环）-1" class="headerlink" title="方法二（循环）"></a>方法二（循环）</h2><p>循环系列<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 反转字符串</span><br><span class="line">* @param &#123;string&#125; val 需要反转的字符串</span><br><span class="line">* @return &#123;string&#125; str 反转后的字符串</span><br><span class="line">*/</span><br><span class="line">function reverseVal2(val)&#123;</span><br><span class="line">	if (typeof val !== &apos;string&apos;) return;</span><br><span class="line">	</span><br><span class="line">	let str = &apos;&apos;,</span><br><span class="line">		i = 0,</span><br><span class="line">		len = val.length;</span><br><span class="line">	while(i &lt; len)&#123;</span><br><span class="line">		str += val.charAt(len - 1 - i);</span><br><span class="line">		i++; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 反转字符串</span><br><span class="line">* @param &#123;string&#125; val 需要反转的字符串</span><br><span class="line">* @return &#123;string&#125; str 反转后的字符串</span><br><span class="line">*/</span><br><span class="line">function reverseVal3(val)&#123;</span><br><span class="line">	if (typeof val !== &apos;string&apos;) return;</span><br><span class="line">	</span><br><span class="line">	let str = &apos;&apos;,</span><br><span class="line">		len = val.length;</span><br><span class="line">	for(let i = len - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">		str += val.charAt(i)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试：reverseVal(‘abc’) // ‘cba’</p>
<h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="方法一（递归）"><a href="#方法一（递归）" class="headerlink" title="方法一（递归）"></a>方法一（递归）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 阶乘</span><br><span class="line">* @param &#123;number&#125; n 需要求的阶乘</span><br><span class="line">* @return &#123;number&#125; 阶乘值</span><br><span class="line">*/</span><br><span class="line">function factorialize1(n)&#123;</span><br><span class="line">	if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</span><br><span class="line">	if(n === 1) return 1;</span><br><span class="line"></span><br><span class="line">	// 建议不要使用 arguments.callee，目前已经废弃了。</span><br><span class="line">	return n * factorialize1(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</p>
<h2 id="方法二（ES6尾调用优化）"><a href="#方法二（ES6尾调用优化）" class="headerlink" title="方法二（ES6尾调用优化）"></a>方法二（ES6尾调用优化）</h2><p>（递归优化版）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 阶乘</span><br><span class="line">* @param &#123;number&#125; n 需要求的阶乘</span><br><span class="line">* @return &#123;number&#125; 阶乘值</span><br><span class="line">*/</span><br><span class="line">function factorialize2(n, total = 1)&#123;</span><br><span class="line">	if(typeof n !== &apos;number&apos; || typeof total !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</span><br><span class="line">	if(n === 1) return total;</span><br><span class="line"></span><br><span class="line">	return factorialize2(n - 1, n * total)</span><br><span class="line">	// f(3) =&gt; f(2, 3 * 2) =&gt; f(1, 6) =&gt; 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="noopener">ES6尾调用优化</a>但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<h2 id="方法三（循环）"><a href="#方法三（循环）" class="headerlink" title="方法三（循环）"></a>方法三（循环）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 阶乘</span><br><span class="line">* @param &#123;number&#125; n 需要求的阶乘</span><br><span class="line">* @return &#123;number&#125; 阶乘值</span><br><span class="line">*/</span><br><span class="line">function factorialize3(n)&#123;</span><br><span class="line">	if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;)</span><br><span class="line">	if(n === 1) return 1;	</span><br><span class="line">	let total = 1;</span><br><span class="line"></span><br><span class="line">	while(n&gt;1)&#123;</span><br><span class="line">		total = n * total;</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：factorialize1(3) // 6</p>
<h1 id="随机生成长度为n字符串"><a href="#随机生成长度为n字符串" class="headerlink" title="随机生成长度为n字符串"></a>随机生成长度为n字符串</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 生成指定长度的随机字符串</span><br><span class="line">* @param &#123;number&#125; n 生成字符串个数</span><br><span class="line">* @return &#123;string&#125; str 反转后的字符串</span><br><span class="line">*/</span><br><span class="line">function randomString1(n)&#123;</span><br><span class="line">	let str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;</span><br><span class="line">	let tem = &apos;&apos;,</span><br><span class="line">		i = 0;</span><br><span class="line">	</span><br><span class="line">	// Math.random 函数产生值的范围[0,1)</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		tem += str.charAt(Math.floor(Math.random() * str.length))</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：Math.round(Math.random() <em> (str.length - 1))<br>Math.ceil(Math.random() </em> (str.length - 1))<br>Math.floor(Math.random() * str.length)<br>这三种方式等价，都能生成[0, str.length-1]随机数</p>
<h2 id="方法二（进制转化）"><a href="#方法二（进制转化）" class="headerlink" title="方法二（进制转化）"></a>方法二（进制转化）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 生成指定长度的随机字符串</span><br><span class="line">* @param &#123;number&#125; n 生成字符串个数</span><br><span class="line">* @return &#123;string&#125; 反转后的字符串</span><br><span class="line">*/</span><br><span class="line">function randomString2(n)&#123;</span><br><span class="line">	return Math.random().toString(36).substr(2).slice(0, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：该方法原理为随机产生的数转换为指定进制字符串<br>toString(n)，n为[2,36]，n&lt;=10时只产生0-9也就是10进制数字<br>该方法有个缺点，产生字符串的长度有一定的限制。</p>
<h2 id="方法三（随机码点）"><a href="#方法三（随机码点）" class="headerlink" title="方法三（随机码点）"></a>方法三（随机码点）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 生成指定长度的随机字符串</span><br><span class="line">* @param &#123;number&#125; n 生成字符串个数</span><br><span class="line">* @return &#123;string&#125; str 反转后的字符串</span><br><span class="line">*/</span><br><span class="line">function randomString3(n)&#123;</span><br><span class="line">	let str = &apos;&apos;;</span><br><span class="line">	</span><br><span class="line">	function randomChar()&#123;</span><br><span class="line">		let l = Math.floor(Math.random() * 62);</span><br><span class="line">		if(l &lt; 10) return l; // 数字部分 0-9</span><br><span class="line">		if(l &lt; 36) return String.fromCharCode(l + 55); // 大写字母</span><br><span class="line">		</span><br><span class="line">		return String.fromCharCode(l + 61); // 小写字母</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(str.length &lt; n) str += randomChar();</span><br><span class="line">	</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：可以参考对于的<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">ASCII码表</a>。<br>测试：randomString1(3) // ‘1sd’</p>
<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="方法一（ES6的Set数据结构）"><a href="#方法一（ES6的Set数据结构）" class="headerlink" title="方法一（ES6的Set数据结构）"></a>方法一（ES6的Set数据结构）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 数组去重</span><br><span class="line">* @param &#123;array&#125; ary 需要去重的数组</span><br><span class="line">* @return &#123;array&#125; 去重后的数组</span><br><span class="line">*/</span><br><span class="line">function unique1(ary)&#123;</span><br><span class="line">	return [...new Set(ary)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二（对象的key唯一性）"><a href="#方法二（对象的key唯一性）" class="headerlink" title="方法二（对象的key唯一性）"></a>方法二（对象的key唯一性）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 数组去重</span><br><span class="line">* @param &#123;array&#125; ary 需要去重的数组</span><br><span class="line">* @return &#123;array&#125; 去重后的数组</span><br><span class="line">*/</span><br><span class="line">function unique2(ary)&#123;</span><br><span class="line">	let obj = &#123;&#125;,</span><br><span class="line">		i = 0,</span><br><span class="line">		len = ary.length;</span><br><span class="line">	</span><br><span class="line">	while(i &lt; len)&#123;</span><br><span class="line">		if(!obj[ary[i]])&#123;</span><br><span class="line">			obj[ary[i]] = true; // 如果不存在</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	return Object.keys(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串。<br>会把数字1和字符串’1’，会被视为同一个值。</p>
<h2 id="方法三（临时数组判断插入）"><a href="#方法三（临时数组判断插入）" class="headerlink" title="方法三（临时数组判断插入）"></a>方法三（临时数组判断插入）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 数组去重</span><br><span class="line">* @param &#123;array&#125; ary 需要去重的数组</span><br><span class="line">* @return &#123;array&#125; 去重后的数组</span><br><span class="line">*/</span><br><span class="line">function unique3(ary)&#123;</span><br><span class="line">	let tem = [],</span><br><span class="line">		i = 0,</span><br><span class="line">		len = ary.length;</span><br><span class="line">	</span><br><span class="line">	while(i &lt; len)&#123;</span><br><span class="line">		// tem.indexOf() === -1 同理</span><br><span class="line">		!tem.includes(ary[i]) ? tem.push(ary[i]) : &apos;&apos;;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法四（判断首次出现的位置）"><a href="#方法四（判断首次出现的位置）" class="headerlink" title="方法四（判断首次出现的位置）"></a>方法四（判断首次出现的位置）</h2><p>如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 数组去重</span><br><span class="line">* @param &#123;array&#125; ary 需要去重的数组</span><br><span class="line">* @return &#123;array&#125; 去重后的数组</span><br><span class="line">*/</span><br><span class="line">function unique4(ary)&#123;</span><br><span class="line">	let tem = [ary[0]],</span><br><span class="line">		len = ary.length;</span><br><span class="line">	</span><br><span class="line">	for(let i = 1; i &lt; len; i++ )&#123;</span><br><span class="line">		// 核心，首次的索引出现是否为当前的索引</span><br><span class="line">		if(ary.indexOf(ary[i]) === i) tem.push(ary[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法五（排序后逐个比较插入）"><a href="#方法五（排序后逐个比较插入）" class="headerlink" title="方法五（排序后逐个比较插入）"></a>方法五（排序后逐个比较插入）</h2><p>给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 数组去重</span><br><span class="line">* @param &#123;array&#125; array 需要去重的数组</span><br><span class="line">* @return &#123;array&#125; 去重后的数组</span><br><span class="line">*/</span><br><span class="line">function unique5(array)&#123;</span><br><span class="line">	let ary = array.slice();</span><br><span class="line">	ary.sort();</span><br><span class="line">	let tem = [ary[0]];</span><br><span class="line">	for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</span><br><span class="line">		ary[i] !== tem[tem.length - 1] ? tem.push(ary[i]) : &apos;&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：返回的数组顺序发生了改变。</p>
<h2 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h2><p>获取没有重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 数组去重</span><br><span class="line">* @param &#123;array&#125; ary 需要去重的数组</span><br><span class="line">* @return &#123;array&#125; 去重后的数组</span><br><span class="line">*/</span><br><span class="line">function unique6(ary)&#123;</span><br><span class="line">	let tem = [];</span><br><span class="line">	for(let i = 0, len = ary.length; i &lt; len; i++)&#123;</span><br><span class="line">		for(let j = i + 1; j &lt; len; j++)&#123;</span><br><span class="line">			if(ary[i] === ary[j]) j = ++i;</span><br><span class="line">		&#125;</span><br><span class="line">		tem.push(ary[i])</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试：unique1([1, 2, 3, 2]) // [1, 2, 3]</p>
<h1 id="出现次数最多的字符"><a href="#出现次数最多的字符" class="headerlink" title="出现次数最多的字符"></a>出现次数最多的字符</h1><h2 id="方法一（对象key的唯一性进行累加）"><a href="#方法一（对象key的唯一性进行累加）" class="headerlink" title="方法一（对象key的唯一性进行累加）"></a>方法一（对象key的唯一性进行累加）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function maxNum1(str)&#123;</span><br><span class="line">	if(typeof(str) !== &apos;string&apos;) str = str.toString();</span><br><span class="line">	let obj = &#123;&#125;,</span><br><span class="line">		maxChar = []; // 使用数组保存出现最多次的某些字符</span><br><span class="line">	str.split(&apos;&apos;).forEach( (val) =&gt; &#123;</span><br><span class="line">		if(!obj[val])&#123;</span><br><span class="line">			let demo = obj[val] = 1;</span><br><span class="line"></span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			obj[val]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	let maxCount =  Math.max.apply(null, Object.values(obj))</span><br><span class="line"></span><br><span class="line">	// forEach方法总是返回 undefined 且 没有办法中止或者跳出 forEach 循环。</span><br><span class="line">	Object.entries(obj).forEach( item =&gt; &#123;</span><br><span class="line">		if(item[1] == maxCount)&#123;</span><br><span class="line">			maxChar.push(item[0])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	return maxChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：maxNum1(‘11223333’) // ‘3’</p>
<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>实现方法：Array.prototype.flatten(depth)，参数depth表示需要扁平化的层数，返回一个新的数组。 </p>
<h2 id="方法一（递归遍历数组拼接）"><a href="#方法一（递归遍历数组拼接）" class="headerlink" title="方法一（递归遍历数组拼接）"></a>方法一（递归遍历数组拼接）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flatten1(ary)&#123;</span><br><span class="line">	let tem = [],</span><br><span class="line">		i = 0,</span><br><span class="line">		len = ary.length;</span><br><span class="line"></span><br><span class="line">	while(i &lt; len)&#123;</span><br><span class="line">		if(Array.isArray(ary[i]))&#123;</span><br><span class="line">			// 递归进行上面步骤</span><br><span class="line">			// [].concat(...ary)，它的参数可以为数组或值，作用为将数组或值连接成新数组。</span><br><span class="line">			tem = tem.concat(flatten1(ary[i]))</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			tem.push(ary[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：可以处理多层数组。</p>
<h2 id="方法二（reduce结合concat）"><a href="#方法二（reduce结合concat）" class="headerlink" title="方法二（reduce结合concat）"></a>方法二（reduce结合concat）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flatten2(ary)&#123;</span><br><span class="line"></span><br><span class="line">	return ary.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">		return pre.concat(Array.isArray(cur) ? flatten2(cur) : cur)</span><br><span class="line">	&#125;, [])</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：可以处理多层数组。</p>
<h2 id="方法三（转化为字符串）"><a href="#方法三（转化为字符串）" class="headerlink" title="方法三（转化为字符串）"></a>方法三（转化为字符串）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flatten2(ary)&#123;</span><br><span class="line"></span><br><span class="line">	return ary.toString().split(&apos;,&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：返回的数组项将为字符串。</p>
<h2 id="方法四（解构数组）"><a href="#方法四（解构数组）" class="headerlink" title="方法四（解构数组）"></a>方法四（解构数组）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flatten4(ary)&#123;</span><br><span class="line"></span><br><span class="line">	let tem = []</span><br><span class="line">	ary.forEach(item =&gt; &#123;</span><br><span class="line">		if(Array.isArray(item))&#123;</span><br><span class="line">			tem = tem.concat(...item);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			tem = tem.concat(item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：只能处理2维数组。<br>测试：getMaxProfit1([1, 2, 3, [4, 5, 6]]) // [1, 2, 3, 4, 5, 6]</p>
<h1 id="数组中最大差值"><a href="#数组中最大差值" class="headerlink" title="数组中最大差值"></a>数组中最大差值</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getMaxProfit1(ary)&#123;</span><br><span class="line">	return Math.max.apply(null, ary) - Math.min.apply(null, ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：getMaxProfit1([1, 2, 3, 4]) // 3 </p>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>这里我们只实现通项公式</p>
<h2 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fib1(n)&#123;</span><br><span class="line">	if(n === 1 || n === 2)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return fib1(n - 1) + fib1(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：时间复杂度为O(2^n)，空间复杂度为O(n)</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fib2(n)&#123;</span><br><span class="line">	let tem = [1, 1];</span><br><span class="line">	if(n === 1 || n === 2)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 数组索引从0开始，数列索引从1开始</span><br><span class="line">	for(let i = 2; i &lt; n; i++)&#123;</span><br><span class="line">		tem[i] = tem[i-1] + tem[i-2];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return tem[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：时间复杂度为O(n)，空间复杂度为O(n)</p>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fib2(n)&#123;</span><br><span class="line">	let prev = 1, </span><br><span class="line">		next = 1,</span><br><span class="line">		res;</span><br><span class="line">	for(let i = 2; i &lt; n; i++)&#123;</span><br><span class="line">		res = prev + next;  </span><br><span class="line">		prev = next; </span><br><span class="line">		next = res;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：时间复杂度为O(n)，空间复杂度为O(1)<br>测试：fib2(3) // 2 </p>
<h1 id="判断是否为质数（prime-number）素数"><a href="#判断是否为质数（prime-number）素数" class="headerlink" title="判断是否为质数（prime number）素数"></a>判断是否为质数（prime number）素数</h1><p>质数：只能被1和自己整除且大于1的数。<br>合数：数大于1且因数多余2个（大于1的数质数的补集）。</p>
<h2 id="方法一（循环）"><a href="#方法一（循环）" class="headerlink" title="方法一（循环）"></a>方法一（循环）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isPrimeNumber1(n)&#123;</span><br><span class="line">	if(n &lt; 2) return false;</span><br><span class="line">	if(n === 2) return true; // 最小的质数</span><br><span class="line"></span><br><span class="line">	for(let i = 2; i &lt; n; i++)&#123;</span><br><span class="line">		if(n % i === 0)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：isPrimeNumber1(2) // true</p>
<h2 id="方法二（正则）"><a href="#方法二（正则）" class="headerlink" title="方法二（正则）"></a>方法二（正则）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isPrimeNumber1(n)&#123;</span><br><span class="line">  return n&lt;2?false:!/^(11+?)\1+$/.test(Array(n+1).join(&apos;1&apos;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：该方法很巧妙，于2018-04-25在掘金上发现。<br><a href="https://juejin.im/post/5adeb462f265da0b9c104358" target="_blank" rel="noopener">方法详解</a></p>
<h1 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function greatestCommonDivisor1(a, b)&#123;</span><br><span class="line">	if(a &lt; 0 || b &lt; 0) throw new Error(&apos;参数只能为正整数&apos;);</span><br><span class="line">	if(a &lt; 2 || b &lt; 2) return 1;</span><br><span class="line">	let min = a,</span><br><span class="line">		max = b,</span><br><span class="line">		arymin = [];</span><br><span class="line"></span><br><span class="line">	if(a &gt; b) &#123;</span><br><span class="line">		min = b;</span><br><span class="line">		max = a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(let i = 1; i &lt;= min; i++)&#123;</span><br><span class="line">		if(min % i === 0)&#123;</span><br><span class="line">			arymin.push(i);</span><br><span class="line">			console.log(1)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arymin.reverse();</span><br><span class="line"></span><br><span class="line">	for(let j = 0, len = arymin.length; j &lt; len; j++)&#123;</span><br><span class="line">		if(max % arymin[j] === 0)&#123;</span><br><span class="line">			return arymin[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：greatestCommonDivisor1(5, 10) // 5</p>
<h1 id="金额转大写"><a href="#金额转大写" class="headerlink" title="金额转大写"></a>金额转大写</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function money2Chinese(num) &#123;</span><br><span class="line">  if(typeof num) throw new Error(&apos;参数为数字&apos;)</span><br><span class="line">  let strOutput = &quot;&quot;</span><br><span class="line">  let strUnit = &apos;仟佰拾亿仟佰拾万仟佰拾元角分&apos;</span><br><span class="line">  num += &quot;00&quot;</span><br><span class="line">  const intPos = num.indexOf(&apos;.&apos;)</span><br><span class="line">  if (intPos &gt;= 0) &#123;</span><br><span class="line">    num = num.substring(0, intPos) + num.substr(intPos + 1, 2)</span><br><span class="line">  &#125;</span><br><span class="line">  strUnit = strUnit.substr(strUnit.length - num.length)</span><br><span class="line">  for (let i = 0; i &lt; num.length; i++) &#123;</span><br><span class="line">    strOutput += &apos;零壹贰叁肆伍陆柒捌玖&apos;.substr(num.substr(i, 1), 1) + strUnit.substr(i, 1)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return strOutput.replace(/零角零分$/, &apos;整&apos;).replace(/零[仟佰拾]/g, &apos;零&apos;).replace(/零&#123;2,&#125;/g, &apos;零&apos;).replace(/零([亿|万])/g, &apos;$1&apos;).replace(/零+元/, &apos;元&apos;).replace(/亿零&#123;0,3&#125;万/, &apos;亿&apos;).replace(/^元/, &quot;零元&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：money2Chinese(1234) // 壹仟贰佰叁拾肆元整</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>懂这些，你将能构建更安全的Web应用</title>
    <url>/2018/web%E5%AE%89%E5%85%A8.html</url>
    <content><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="同源策略（Same-Origin-Policy）"><a href="#同源策略（Same-Origin-Policy）" class="headerlink" title="同源策略（Same Origin Policy）"></a>同源策略（Same Origin Policy）</h2><p>同源策略限制了一个源（origin）中加载的文档或脚本与其他源（origin）中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。<br>源的定义：如果两个页面的协议、域名、端口（如果有指定）和都相同，则两个页面具有相同的源。</p>
<h2 id="浏览器沙箱Sandbox-和-多线程架构"><a href="#浏览器沙箱Sandbox-和-多线程架构" class="headerlink" title="浏览器沙箱Sandbox 和 多线程架构"></a>浏览器沙箱Sandbox 和 多线程架构</h2><p>浏览器为我们提供了一个独立的沙箱环境，尽量来保障浏览器的安全，也有部分浏览器采用一个 tab 页面一个线程，这样多线程架构增强了浏览器的安全（即使某个线程崩溃了，也不至于浏览器崩溃）。 </p>
<h2 id="恶意网址拦截（大多基于黑名单）"><a href="#恶意网址拦截（大多基于黑名单）" class="headerlink" title="恶意网址拦截（大多基于黑名单）"></a>恶意网址拦截（大多基于黑名单）</h2><p>常见的黑名单获取：<a href="https://www.phishtank.com/" target="_blank" rel="noopener">PhishTank恶意网址黑名单</a>、Google 的SafeBrowsing API、EVSSL证书</p>
<h2 id="更安全的浏览器进化"><a href="#更安全的浏览器进化" class="headerlink" title="更安全的浏览器进化"></a>更安全的浏览器进化</h2><p>IE8 的 XSS Filter功能<br>Firefox 的 CSP（Content Security Policy）</p>
<h1 id="XSS（跨站脚本攻击Cross-Site-Script）"><a href="#XSS（跨站脚本攻击Cross-Site-Script）" class="headerlink" title="XSS（跨站脚本攻击Cross Site Script）"></a>XSS（跨站脚本攻击Cross Site Script）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意 Web 用户将代码植入到提供给其它用户使用的页面中。<br>XSS分为三种类型：1.反射型XSS 2.存储型XSS 3.DOM Based XSS（通过修改页面的DOM节点形成的XSS）</p>
<h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>Cookie劫持（一般Cookie作为登录凭证，通过HttpOnly可以防止）、构造GET与POST请求、XSS钓鱼、识别用户浏览器、CSS HIstory Hack（访问过的连接会使用:visited的样式）、获取用户的真实IP地址（前提如用户安装了Java环境JRE等）、XSS Worm</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>CSP(Content Security Policy)、对特殊字符转义，不要相信任何来自用户的输入（包括请求体、queryString甚至是请求Headers）</p>
<ol>
<li>响应头 HttpOnly 有效保护 Cookie</li>
<li>XSS Filter输入检查 排除、转义特殊字符</li>
<li>输出检查</li>
<li>安全的编码函数 HtmlEncode （将特殊字符转换为实体字符）</li>
<li>只需一种编码吗 浏览器解析 htmlparser 优先于 JavaScript Parser</li>
</ol>
<h2 id="对于处理富文本开发："><a href="#对于处理富文本开发：" class="headerlink" title="对于处理富文本开发："></a>对于处理富文本开发：</h2><ol>
<li>我们应该让事件被严格禁止，不包含iframe、script、base、form等危险标签。</li>
<li>使用白名单，避免使用黑名单。</li>
<li>OWASP 开源的 XSS Filter 项目（Antisamy–Java 和 .NET）（HTML Purifier–PHP） </li>
</ol>
<p><a href="https://www.zhuyingda.com/blog/article.html?id=2" target="_blank" rel="noopener">XSS漏洞的原理</a></p>
<h1 id="CSRF（跨站点脚本Cross-site-request-forgery）"><a href="#CSRF（跨站点脚本Cross-site-request-forgery）" class="headerlink" title="CSRF（跨站点脚本Cross-site request forgery）"></a>CSRF（跨站点脚本Cross-site request forgery）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>是指在黑客已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器 CRUD 来执行读写操作。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>验证码，我们应该使用验证码作为防御 CSRF 的辅助手段，而不应该作为最主要的解决方案（毕竟不可能所有操作都加上验证码，多次验证码不利于用户体验）。<br>Referer Check ，常见应用为防止图片盗链，直白的讲就是后端需要检查请求头中的 Referer 字段，是否为我们期望的”源”。<br>Anti CSRF Token，需要保证使用足够安全的随机数生产算法或真随机数生成器，只有用户和服务器共同持有，才能保证安全。<br>PS：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。<br><a href="https://www.zhuyingda.com/blog/article.html?id=5" target="_blank" rel="noopener">CSRF漏洞的原理</a></p>
<h1 id="clickjacking（点击劫持）"><a href="#clickjacking（点击劫持）" class="headerlink" title="clickjacking（点击劫持）"></a>clickjacking（点击劫持）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>点击劫持其实是一种视觉上的欺骗手段，攻击者将一个透明的、不可见的iframe覆盖在一个网页上，通过调整iframe页面位置，诱使用户在页面上进行操作，在不知情的情况下用户的点击恰好是点击在iframe页面的一些功能按钮上，其实还也可使用 img 来代替 iframe，这就是后面要说的 XSIO。<br>HTML5的Drag 和 Drop API会发生数据窃取，分别在 Drag 隐藏一个 iframe ，在 Drop 中 隐藏一个 textarea ，在 drop 事件时就可以获取来自 drag 的数据，从而形成数据劫持，event.dataTransfer.getData()</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>frame busting：禁止iframe的嵌套<a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html">JS防止潜入</a><br>X-Frame-Options：防止或限制网页内嵌（http头部X-FRAME-OPTIONS）<br>CSP的frame-ancestors：指定了一个可以包含frame，iframe，object，embed，or applet等元素的有效来源。<br>PS：http头部X-FRAME-OPTIONS为非标准的（但所有浏览器都支持），你可以使用CSP的frame-ancestors（标准属性）。<br>同样还有触屏劫持（TapJacking）实现原理基本类似。<br><a href="https://www.zhuyingda.com/blog/article.html?id=6" target="_blank" rel="noopener">ClickJacking漏洞的原理</a></p>
<h1 id="window-name-的妙用"><a href="#window-name-的妙用" class="headerlink" title="window.name 的妙用"></a>window.name 的妙用</h1><p>window.name 属性可设置或返回存放窗口的名称的一个字符串。<br>因为 window 对象是浏览器的窗体，并非 document 对象，因此许多时候 window 对象不受同源策略的限制。<br>可以利用该属性实现跨域、跨页面传递数据<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">可以使用postMessage来进行跨源通信</a>。</p>
<h1 id="XSIO"><a href="#XSIO" class="headerlink" title="XSIO"></a>XSIO</h1><p>原理：没有限制图片的position属性为absolute，导致可以控制一张图片出现在网页的任意位置。<br><a href="https://blog.csdn.net/inject2006/article/details/3057045" target="_blank" rel="noopener">百度的XSIO</a></p>
<h1 id="iframe-的-sandbox-属性"><a href="#iframe-的-sandbox-属性" class="headerlink" title="iframe 的 sandbox 属性"></a>iframe 的 sandbox 属性</h1><p>可以防止以下操作：</p>
<ol>
<li>访问父页面的DOM（从技术角度来说，这是因为相对于父页面iframe已经成为不同的源了）</li>
<li>执行脚本</li>
<li>通过脚本嵌入自己的表单或操作表单</li>
<li>对cookie、本地存储Storage、本地数据库IndexDB的读写</li>
</ol>
<p>PS：sandbox 属性有 allow-same-origin（允许同源访问）、allow-top-navigation（允许访问顶层窗口）、allow-forms（允许提交表单）、allow-script（允许执行脚本）</p>
<h1 id="a标签-和-area标签的安全问题"><a href="#a标签-和-area标签的安全问题" class="headerlink" title="a标签 和 area标签的安全问题"></a>a标签 和 area标签的安全问题</h1><p>当a链接有target=”_blank”属性时，必须添加rel=”noreferrer noopener”，不然新产生的页面可以通过window.opener来获取到父窗口的window对象。<br><code>&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; &gt;</code></p>
<h1 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP (内容安全策略)"></a>CSP (内容安全策略)</h1><p>内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。<br>其实CSP的本质是以白名单的机制对网站加载或执行的资源起作用。</p>
<h2 id="适用方式"><a href="#适用方式" class="headerlink" title="适用方式"></a>适用方式</h2><ol>
<li>可以通过配置你的网络服务器返回  Content-Security-Policy  HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部，它是旧版本)。</li>
<li>在html页面中meta元素中使用，如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="隐私与-visited选择器"><a href="#隐私与-visited选择器" class="headerlink" title="隐私与:visited选择器"></a>隐私与:visited选择器</h1><h2 id="为什么说-visited选择器暴露了用户隐私？"><a href="#为什么说-visited选择器暴露了用户隐私？" class="headerlink" title="为什么说:visited选择器暴露了用户隐私？"></a>为什么说:visited选择器暴露了用户隐私？</h2><p>曾经，CSS选择器 :visited 被网站用来查看用户的浏览记录。通过使用 getComputedStyle() 或其他方法扫描用户的浏览记录来获取用户访问了哪些网站。这很容易实现，不仅能够判断用户是否曾经访问过这个页面，还能猜测出大量的用户身份信息。<br>不过现代浏览器已经做了相应的修复和只能给已访问链接设置少量的样式（color、background-color、border-color、outline-color、fill 和 stroke 等）</p>
<h1 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h1><p>CORS属于HTTP访问控制特性，以下内容大多针对于XMLHttpRequest，有些并不适用于 Fetch 。<br>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。<br>比如，站点 <code>http://domain-a.com</code> 的某 HTML 页面通过 <code>img</code> 的 <code>src</code> 请求 <code>http://domain-b.com/image.jpg</code>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。<br>PS：跨域并非不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）<br>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p>
<h1 id="X-Frame-Options-响应头"><a href="#X-Frame-Options-响应头" class="headerlink" title="X-Frame-Options 响应头"></a>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>frame</code>（已废弃）, <code>iframe</code> 或者 <code>object</code> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p>
<h2 id="使用-X-Frame-Options"><a href="#使用-X-Frame-Options" class="headerlink" title="使用 X-Frame-Options"></a>使用 X-Frame-Options</h2><p>X-Frame-Options 有三个值:<br>DENY–表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。<br>SAMEORIGIN–表示该页面可以在相同域名页面的 frame 中展示。<br>ALLOW-FROM uri–表示该页面可以在指定来源的 frame 中展示。<br>PS：如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p>
<h1 id="前端反爬虫"><a href="#前端反爬虫" class="headerlink" title="前端反爬虫"></a>前端反爬虫</h1><p>该课题是在腾讯的<a href="http://imweb.io/topic/595b7161d6ca6b4f0ac71f05" target="_blank" rel="noopener">IMWeb前端博客上看到的，整理于此，非常感谢。</a><br><a href="http://litten.me/2017/07/09/prevent-spiders/" target="_blank" rel="noopener">反击爬虫，前端工程师的脑洞可以有多大？</a></p>
<h2 id="FONT-FACE拼凑式"><a href="#FONT-FACE拼凑式" class="headerlink" title="FONT-FACE拼凑式"></a>FONT-FACE拼凑式</h2><p><a href="http://maoyan.com/films/#content" target="_blank" rel="noopener">猫眼电影</a>-页面使用了font-face定义了字符集，并通过unicode去映射展示。</p>
<h2 id="BACKGROUND拼凑式"><a href="#BACKGROUND拼凑式" class="headerlink" title="BACKGROUND拼凑式"></a>BACKGROUND拼凑式</h2><p>美团-与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p>
<h2 id="字符穿插式"><a href="#字符穿插式" class="headerlink" title="字符穿插式"></a>字符穿插式</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&amp;mid=2247484365&amp;idx=4&amp;sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&amp;chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&amp;scene=4" target="_blank" rel="noopener">微信公众号文章</a>-某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。</p>
<h2 id="伪元素隐藏式"><a href="#伪元素隐藏式" class="headerlink" title="伪元素隐藏式"></a>伪元素隐藏式</h2><p><a href="https://car.autohome.com.cn/config/series/3170.html" target="_blank" rel="noopener">汽车之家</a>-把关键的厂商信息，做到了伪元素的content里（如汽车厂家）。</p>
<h2 id="元素定位覆盖式"><a href="#元素定位覆盖式" class="headerlink" title="元素定位覆盖式"></a>元素定位覆盖式</h2><p><a href="https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&amp;searchArrivalAirport=%E5%8C%97%E4%BA%AC&amp;searchDepartureTime=2018-06-27&amp;searchArrivalTime=2018-06-29&amp;nextNDays=0&amp;startSearch=true&amp;fromCode=CAN&amp;toCode=BJS&amp;from=qunarindex&amp;lowestPrice=null" target="_blank" rel="noopener">去哪网</a>-对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格。</p>
<h2 id="IFRAME异步加载式"><a href="#IFRAME异步加载式" class="headerlink" title="IFRAME异步加载式"></a>IFRAME异步加载式</h2><p><a href="http://music.163.com/#/song?id=424477863" target="_blank" rel="noopener">网易云音乐</a>-页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面。</p>
<h2 id="字符分割式"><a href="#字符分割式" class="headerlink" title="字符分割式"></a>字符分割式</h2><p><a href="http://www.goubanjia.com/" target="_blank" rel="noopener">全网代理IP</a>-他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p>
<h2 id="字符集替换式"><a href="#字符集替换式" class="headerlink" title="字符集替换式"></a>字符集替换式</h2><p><a href="https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&amp;arrCity=%E4%B8%8A%E6%B5%B7&amp;goDate=2018-06-27&amp;from=touch_index_search&amp;child=0&amp;baby=0&amp;cabinType=0" target="_blank" rel="noopener">去哪儿移动侧</a>-html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果<br>PS：常用的后端反爬有 User-Agent + Referer检测、账号及Cookie验证、验证码、IP限制频次。</p>
<h1 id="子资源完整性（SRI-Subresource-Integrity）"><a href="#子资源完整性（SRI-Subresource-Integrity）" class="headerlink" title="子资源完整性（SRI,Subresource Integrity）"></a>子资源完整性（SRI,Subresource Integrity）</h1><p>子资源完整性(Subresource Integrity)是允许浏览器检查其获得的资源（例如从 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CDN" target="_blank" rel="noopener">CDN</a> 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。<br>子资源完整性 (SRI) 是一种安全功能，允许浏览器验证所获取的文件 (比如，从一个 CDN 内容分发网络) 是无意外操作而交付的。它的工作原理是允许你提供一个获取文件必须匹配的加密哈希。</p>
<h2 id="SRI-如何工作"><a href="#SRI-如何工作" class="headerlink" title="SRI 如何工作"></a>SRI 如何工作</h2><p>使用 内容分发网络 (CDN) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件)，因此可能潜在地攻击所有从该 CDN 获取文件的站点。<br>子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。</p>
<h2 id="如何使用-SRI"><a href="#如何使用-SRI" class="headerlink" title="如何使用 SRI"></a>如何使用 SRI</h2><p>将使用 base64 编码过后的文件哈希值写入你所引用的 script 或 link 标签的 integrigy 属性值中即可启用子资源完整性功能。<br>PS：integrity 值分成两个部分，第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。<br>integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。</p>
<h3 id="内容安全策略（CSP）和子资源完整性（SRI）共同使用"><a href="#内容安全策略（CSP）和子资源完整性（SRI）共同使用" class="headerlink" title="内容安全策略（CSP）和子资源完整性（SRI）共同使用"></a>内容安全策略（CSP）和子资源完整性（SRI）共同使用</h3><p>你可以根据内容安全策略来配置你的服务器使得指定类型的文件遵守 SRI。这是通过在 CSP 头部添加 require-sri-for 指令实现的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这条指令规定了所有 JavaScript 都要有 integrity 属性，且通过验证才能被加载。</span><br><span class="line">Content-Security-Policy: require-sri-for script;</span><br><span class="line">// 你也可以指定所有样式表也要通过 SRI 验证：</span><br><span class="line">Content-Security-Policy: require-sri-for style;</span><br></pre></td></tr></table></figure></p>
<p>你也可以对两者都加上验证。</p>
<h2 id="生成-SRI-哈希的工具"><a href="#生成-SRI-哈希的工具" class="headerlink" title="生成 SRI 哈希的工具"></a>生成 SRI 哈希的工具</h2><h3 id="openssl-在命令行"><a href="#openssl-在命令行" class="headerlink" title="openssl 在命令行"></a>openssl 在命令行</h3><p>你可以用 openssl 在命令行中执行如下命令来生成 SRI 哈希值：<br><code>cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A</code><br><a href="https://www.srihash.org/" target="_blank" rel="noopener">在线生成 SRI 哈希值的工具</a><br>下面以知乎的一个js文件为例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 原js文件地址</span><br><span class="line">https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js</span><br><span class="line">// 生成的脚本标签</span><br><span class="line">&lt;script src=&quot;https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js&quot; integrity=&quot;sha384-B4YDh2AljLezOmNwiezobW8FJbJQfyZxm1SksT7THfKULK6SVxN+dRNSvLxEmXtA&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="shasum-在命令行"><a href="#shasum-在命令行" class="headerlink" title="shasum 在命令行"></a>shasum 在命令行</h3><p><code>shasum -b -a 384 FILENAME.js | xxd -r -p | base64</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">MDN-SRI</a></p>
<h1 id="用户密码是泄漏的原因？"><a href="#用户密码是泄漏的原因？" class="headerlink" title="用户密码是泄漏的原因？"></a>用户密码是泄漏的原因？</h1><p> HTTPS 协议旨在保护用户数据在网络上不被窃听（机密性） 和不被篡改（完整性）。处理用户数据的网站应该使用 HTTPS 协议保护他们的用户不受黑客的侵害。如果网站使用 HTTP 协议而不是 HTTPS 协议，窃取用户信息（比如他们的登录凭证）将会轻而易举。这曾经被 <a href="http://codebutler.github.io/firesheep/" target="_blank" rel="noopener">Firesheep</a> 很好地演示过。<br>这里罗列出密码所牵涉到的安全问题：</p>
<ol>
<li>在HTTP之上运行登录表单. 即使表单的action对象是HTTPS链接,用户的登录表单信息也会受到威胁,因为攻击者能够通过用户修改用户接收到的页面(例如,攻击者插入键盘记录脚本来盗取用户输入的密码.他们还能改变表单目的页从而将敏感信息传递到受他们控制的服务器).</li>
<li>在表单的action链接中使用HTTP链接.在这种情况下,用户输入的任何信息都将以明文方式通过网络传递.这样,从密码离开用户的电脑到密码到达服务器过程中,用户的密码将清楚地展现在任何嗅探用户网络的人眼前.</li>
<li>在网页iframe中递交登录表单(或是嵌入在HTTP frame中的HTTPS frame).即使最上层页面是HTTPS,但在HTTP iframe中包含密码域和在HTTP页面中包含密码域是没有区别的.攻击者同样能够修改这个页面以及偷取用户信息.</li>
<li>有时网页需要用户名及密码,但实际上却没有存储这些敏感的信息.例如,一个新闻页面可能存储一个用户想要再次阅读的文章,却没有存储任何关于这位用户的其他信息.这个新闻站点的网页开发者可能没有动力去对于提高他的网站的安全性以及保护他们用户的信息.不幸的是,密码重用也是一个大问题.用户可能在不同的站点使用相同的密码(新闻网页,社交网络,电子邮箱及其银行).因此即使通过用户名及密码登陆你的网页对你来说不是很大的问题,对于重复使用相同用户名及密码来登陆他们银行账户的用户来说却是一个极大的威胁.网络攻击者正变得越来越聪明.他们在一个网站同时盗取用户名及密码然后在另一个可能能给他们带来金钱的网站上使用这些密码.</li>
</ol>
<h1 id="弱签名算法"><a href="#弱签名算法" class="headerlink" title="弱签名算法"></a>弱签名算法</h1><p>在签署数字证书时，哈希算法的完整性是决定证书安全性的关键因素。哈希算法的弱点可能导致攻击者在某些情况下能够获得伪造的证书。由于技术的升级和已知的新型攻击，此类攻击的可行性已经大为提升。因此，不推荐使用旧算法，对于旧算法的支持最终也会停止。</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>对基于MD5的签名的支持已在2012年初停止。</p>
<h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>基于SHA-1的签名非常普遍；截至2015年5月，大约45%的数字证书皆使用此算法。但是，SHA-1已经过时因而不再推荐使用。<br>SHA-1的证书将从2017开始不再被主流浏览器厂商视为安全的。</p>
<h2 id="SHA-2（推荐使用）"><a href="#SHA-2（推荐使用）" class="headerlink" title="SHA-2（推荐使用）"></a>SHA-2（推荐使用）</h2><p>SHA-2是一个哈希算法家族，其中包括SHA-256和SHA-512。截至2015年，SHA-2家族被认为足够安全强大。许多证书颁发机构颁发新的证书使用SHA-256。</p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用预编译语句、使用存储过程、检查数据类型、使用安全函数（编码特殊字符）、最小权限原则（是否可操作数据库）<br>PS：防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。</p>
<h1 id="MIMT-中间人攻击Man-in-the-middle-attacks"><a href="#MIMT-中间人攻击Man-in-the-middle-attacks" class="headerlink" title="MIMT(中间人攻击Man-in-the-middle-attacks)"></a>MIMT(中间人攻击Man-in-the-middle-attacks)</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>Client <--> Proxy Server(Middle Man这里可能存在攻击) <--> Web Server真实的服务器<br>Client 发出的请求 和 Web Server返回的数据都经过Proxy Server 转发，这个Proxy Server 就起到了一个Middle Man的作用，如果这个“中间人” 够黑，那么整个代理过程的数据都可以由这个“中间人”控制，“中间人”可以进行截取敏感数据、代码注射、Proxp worm操作。</--></--></p>
<h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p>启用虚拟专用网(VPN)、https(传输报文加密)<br><a href="https://www.zhuyingda.com/blog/article.html?id=7" target="_blank" rel="noopener">web中间人攻击的威胁</a></p>
<h1 id="DDOS（分布式拒绝服务Distributed-Denial-of-Service）"><a href="#DDOS（分布式拒绝服务Distributed-Denial-of-Service）" class="headerlink" title="DDOS（分布式拒绝服务Distributed Denial of Service）"></a>DDOS（分布式拒绝服务Distributed Denial of Service）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>最基本的DDOS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。</p>
<h2 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h2><p>限制请求频率、高防服务器、黑名单、DDoS 清洗、CDN（隐藏真实IP及分流）</p>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="SYN-flood（网络层DDOS）"><a href="#SYN-flood（网络层DDOS）" class="headerlink" title="SYN flood（网络层DDOS）"></a>SYN flood（网络层DDOS）</h3><p><a href="https://www.cnblogs.com/popduke/p/5823801.html" target="_blank" rel="noopener">什么是SYN Flood攻击?</a><br>对抗措施：SYN Cookie 为每一个IP地址分配一个Cookie，并统计每个IP地址的访问频率。如果短时间内收到大量的来自同一个IP地址的数据包，则认为是受到攻击，之后来自这个IP地址的包将被丢失。</p>
<h3 id="Challenge-Collapasar（应用层DDOS）"><a href="#Challenge-Collapasar（应用层DDOS）" class="headerlink" title="Challenge Collapasar（应用层DDOS）"></a>Challenge Collapasar（应用层DDOS）</h3><p>原理：对一些消耗资源较大的应用页面不断发起正常的请求（查询数据库、读写硬盘文件等），以达到消耗服务端资源的目的。<br>对抗措施：在应用中针对每个”客户端”做一个请求频率的限制，可以通过IP地址与Cookie定位一个客户端。<br>若IP地址改变（代理服务器）或Cookie清空，应该使用应用代码要做好性能优化（常用数据转移到内存中），在网络架构上做好优化（利用负载均衡、CDN、镜像站点等分流，减轻主站的压力）。<br><a href="https://www.zhihu.com/question/22259175" target="_blank" rel="noopener">知乎-什么是 DDoS 攻击？</a></p>
<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><ol>
<li>上传文件是Web脚本语言</li>
<li>上传文件是木马、病毒文件，诱骗用户或者管理员下载执行</li>
<li>上传文件是钓鱼图片或包含了脚本的图片，在某些浏览器会被作为脚本执行</li>
</ol>
<h2 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h2><p>文件上传的目录设置为不可执行<br>判断文件类型（使用白名单而不是黑名单）<br>使用随机数改写文件名和文件路径<br>单独设置文件服务器的域名</p>
<h2 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h2><h3 id="绕过文件上传检查功能"><a href="#绕过文件上传检查功能" class="headerlink" title="绕过文件上传检查功能"></a>绕过文件上传检查功能</h3><p>UI原本允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\0].JPG，其中[\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为0x00字符截断的关系，最终会变成xxx.php。<br>对应的解决方案，可以检查附件头信息（同样也可以使用脚本语言来伪造一个合法头信息，这时应该提供不让脚本执行的容器，Web Server将其当做静态文件来解析，从而避免）。</p>
<h2 id="Apache文件解析问题"><a href="#Apache文件解析问题" class="headerlink" title="Apache文件解析问题"></a>Apache文件解析问题</h2><p>在Apache1.x、Apache2.x中，对文件名的解析就存在以下特性。<br>Apache对于文件的解析是从后往前解析的，知道遇到一个Apache认识的文件类型为止。<br>Apache的mime.types文件配置了Apache能认识那些文件。</p>
<h1 id="认证与会话管理"><a href="#认证与会话管理" class="headerlink" title="认证与会话管理"></a>认证与会话管理</h1><h2 id="认证和授权？"><a href="#认证和授权？" class="headerlink" title="认证和授权？"></a>认证和授权？</h2><p>认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。</p>
<h2 id="常见的认证方式"><a href="#常见的认证方式" class="headerlink" title="常见的认证方式"></a>常见的认证方式</h2><p>密码认证<br>多因素认证（手机号+身份证+护照等等）<br>Session 与认证（对SessionID加密后保存在Cookie中，Cookie随HTTP请求发送，且受浏览器同源策略的保护）</p>
<h2 id="常见攻击"><a href="#常见攻击" class="headerlink" title="常见攻击"></a>常见攻击</h2><p>Session Fixation 攻击：登录前和登录后，重写 Session ID。</p>
<h2 id="单点登录（SSO）"><a href="#单点登录（SSO）" class="headerlink" title="单点登录（SSO）"></a>单点登录（SSO）</h2><p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。<br>OpenID：OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。</p>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="垂直权限管理"><a href="#垂直权限管理" class="headerlink" title="垂直权限管理"></a>垂直权限管理</h2><p>主要为基于角色的访问控制（Role-Based Access Control）RBAC<br>一个用户有多个角色，一个角色有一个权限集合，最小粒度为每个权限（权限码）。<br>有以下几个分类</p>
<h3 id="基于URL的访问控制"><a href="#基于URL的访问控制" class="headerlink" title="基于URL的访问控制"></a>基于URL的访问控制</h3><p>如不同角色能访问不同的页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sec:http&gt;</span><br><span class="line">	&lt;sec:intercept-url pattern=&quot;/admin&quot; access=&quot;ROLE_ADMIN&quot;/&gt;</span><br><span class="line">	&lt;sec:intercept-url pattern=&quot;/user/*&quot; access=&quot;ROLE_USER&quot;/&gt;</span><br><span class="line">&lt;/sec:http&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于method的访问控制"><a href="#基于method的访问控制" class="headerlink" title="基于method的访问控制"></a>基于method的访问控制</h3><p>如限定角色调用方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasRole(&apos;ROLE_USER&apos;)&quot;)</span><br><span class="line">public void create(Contact contact)</span><br></pre></td></tr></table></figure></p>
<h3 id="基于表达式的访问控制"><a href="#基于表达式的访问控制" class="headerlink" title="基于表达式的访问控制"></a>基于表达式的访问控制</h3><p>如角色和IP地址验证<br><code>hasRole(&#39;admin&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;)</code></p>
<h2 id="水平权限管理"><a href="#水平权限管理" class="headerlink" title="水平权限管理"></a>水平权限管理</h2><h3 id="什么叫水平权限？"><a href="#什么叫水平权限？" class="headerlink" title="什么叫水平权限？"></a>什么叫水平权限？</h3><p>用户A只能访问用户A的数据，不能通过构造URL等手段访问到用户B的数据。</p>
<h2 id="OAuth（Open-Authorization）"><a href="#OAuth（Open-Authorization）" class="headerlink" title="OAuth（Open Authorization）"></a>OAuth（Open Authorization）</h2><p>OAUTH协议是一个在不提供用户名和密码的情况下，授权第三方应用访问 Web 资源的安全协议。<br>OAuth1.0中分为3个角色（Consumer：消费方 Client、Service Provider：服务提供方 Server、User：用户 Resource Owner）<br>如我们在人人网，想要导入用户MSN里的好友<br>这里人人网为消费方；MSN为服务提供方、用户为资源拥有者</p>
<h1 id="cookie防篡改（实现思路）"><a href="#cookie防篡改（实现思路）" class="headerlink" title="cookie防篡改（实现思路）"></a>cookie防篡改（实现思路）</h1><ol>
<li>服务端提供一个签名生成算法secret</li>
<li>根据方法生成签名secret(wall)=34Yult8i</li>
<li>将生成的签名放入对应的Cookie项username=wall|34Yult8i。其中，内容和签名用|隔开。</li>
<li>服务端根据接收到的内容和签名，校验内容是否被篡改（签名和服务器之前生成的不一致则表示cookie被篡改了）。</li>
</ol>
<p><a href="https://juejin.im/post/5b02fe326fb9a07ab1117c82" target="_blank" rel="noopener">Cookie防篡改机制</a></p>
<blockquote>
<p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">浏览器的同源策略</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="noopener">CSP 策略指令</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="noopener">X-Frame-Options</a><br><a href="https://publicsuffix.org/" target="_blank" rel="noopener">PUBLIC SUFFIX LIST</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">X-Frame-Options</a><br><a href="https://www.srihash.org/" target="_blank" rel="noopener">SRI Hash Generator</a><br><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a><br><a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="noopener">Let’s Encrypt，免费好用的 HTTPS 证书</a></p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript标准库总结</title>
    <url>/2018/javascript%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="值属性"><a href="#值属性" class="headerlink" title="值属性"></a>值属性</h1><p>这部分属性只是简单的值，它们没有自己的属性和方法。</p>
<h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><pre><code>全局属性 Infinity 是一个数值，表示无穷大。
</code></pre><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><pre><code>全局属性 NaN 的值表示不是一个数字（Not-A-Number）。
</code></pre><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><pre><code>全局属性undefined表示原始值undefined。它是一个JavaScript的 原始数据类型 。
</code></pre><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><pre><code>值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。
</code></pre><h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。    </p>
<h3 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h3><pre><code>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。
</code></pre><p>PS：eval会造成安全和性能方面的问题，具体参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval#Don.27t_use_eval.21" target="_blank" rel="noopener">避免在不必要的情况下使用 eval</a>。</p>
<h3 id="isFinite-arg"><a href="#isFinite-arg" class="headerlink" title="isFinite(arg)"></a>isFinite(arg)</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为有限值。
</code></pre><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><pre><code>判断被传入的值（非number类型将转换为number类型）是否为NaN。
</code></pre><p>PS：使用Number.isNaN()来代替更有语义性。</p>
<h3 id="parseFloat-str"><a href="#parseFloat-str" class="headerlink" title="parseFloat(str)"></a>parseFloat(str)</h3><pre><code>parseFloat() 函数解析一个字符串参数并返回一个浮点数。
</code></pre><p>PS：如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略.<br>    如果第一个字符不能解析，直接返回NaN。</p>
<h3 id="parseInt-str-radix"><a href="#parseInt-str-radix" class="headerlink" title="parseInt(str, radix);"></a>parseInt(str, radix);</h3><pre><code>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。
</code></pre><p>PS：radix一个介于2和36之间的整数，表示上述字符串的基数（默认为10）。</p>
<h3 id="encodeURI-URI"><a href="#encodeURI-URI" class="headerlink" title="encodeURI(URI)"></a>encodeURI(URI)</h3><p>函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。<br>PS：encodeURI 字母、数字、;、,、/、?、:、@、&amp;、=、+、$、-、_、.、!、~、*、’、(、)、#、之外的所有字符。</p>
<h3 id="decodeURI-encodeURI"><a href="#decodeURI-encodeURI" class="headerlink" title="decodeURI(encodeURI)"></a>decodeURI(encodeURI)</h3><pre><code>decodeURI() 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。
</code></pre><h3 id="encodeURIComponent-str"><a href="#encodeURIComponent-str" class="headerlink" title="encodeURIComponent(str)"></a>encodeURIComponent(str)</h3><pre><code>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。
</code></pre><p>PS：encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。<br>    为了避免服务器收到不可预知的请求，对任何用户输入的作为URI部分的内容你都需要用encodeURIComponent进行转义。</p>
<h3 id="decodeURIComponent-encodedURI"><a href="#decodeURIComponent-encodedURI" class="headerlink" title="decodeURIComponent(encodedURI)"></a>decodeURIComponent(encodedURI)</h3><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p>
<h3 id="encodeURI和encodeURIComponent的区别与使用场景"><a href="#encodeURI和encodeURIComponent的区别与使用场景" class="headerlink" title="encodeURI和encodeURIComponent的区别与使用场景"></a>encodeURI和encodeURIComponent的区别与使用场景</h3><pre><code>区别在于编码的字符范围不同。
</code></pre><p>encodeURI使用于编码整个URI而encodeURIComponent主要query部分（当你需要编码URL中的参数）。<br><a href="https://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="noopener">简单明了区分escape、encodeURI和encodeURIComponent</a></p>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。</p>
<h2 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>定义：指明函数的形参个数（确定多少个必须要传入的参数）区别于arguments.length实参个数（确定函数被调用时的实际传参个数）。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>定义：返回创建实例对象的 Object 构造函数的引用。</p>
<h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="func-apply-thisArg-argsArray"><a href="#func-apply-thisArg-argsArray" class="headerlink" title="func.apply(thisArg, [argsArray])"></a>func.apply(thisArg, [argsArray])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为func函数执行时this的指向，argsArray为类数组参数数组。<br>返回：调用有指定this值和参数的函数的结果。</p>
<h3 id="fun-call-thisArg-arg1-arg2-…"><a href="#fun-call-thisArg-arg1-arg2-…" class="headerlink" title="fun.call(thisArg, arg1, arg2, …)"></a>fun.call(thisArg, arg1, arg2, …)</h3><p>定义：调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。<br>参数：thisArg为func函数执行时this的指向，arg1, arg2, …为指定的参数列表。<br>返回：返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。<br>运用：1.使用call方法调用父构造函数（在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承）<br>  2.使用call方法调用匿名函数3.使用call方法调用函数并且指定上下文的’this’<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#示例" target="_blank" rel="noopener">运用举例</a></p>
<h3 id="fun-bind-thisArg-arg1-arg2-…"><a href="#fun-bind-thisArg-arg1-arg2-…" class="headerlink" title="fun.bind(thisArg[, arg1[, arg2[, …]]])"></a>fun.bind(thisArg[, arg1[, arg2[, …]]])</h3><p>定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。<br>参数：thisArg为当绑定函数被调用时，该参数会作为原函数运行时的 this 指向，arg1、arg2…为当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。<br>返回：由指定的this值和初始化参数改造的原函数拷贝（返回一个函数）。<br>运用：1.创建绑定函数（显式绑定this）2.偏函数（使一个函数拥有预设的初始参数）。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#示例" target="_blank" rel="noopener">运用举例</a></p>
<h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p>定义：返回一个表示当前函数源代码的字符串。<br>参数：null。<br>返回：表示函数源代码的一个字符串。</p>
<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。<br>Number()，如果参数无法被转换为数字，则返回 NaN。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>两个可表示(representable)数之间的最小间隔，在进行计算时误差在这个范围内被认为是合理的。</p>
<h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>JavaScript 中最大的安全整数 (2^53 - 1)。</p>
<h3 id="Number-MIN-SAFE-INTEGER"><a href="#Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MIN_SAFE_INTEGER"></a>Number.MIN_SAFE_INTEGER</h3><p>JavaScript 中最小的安全整数 (-(2^53 - 1)).</p>
<h3 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h3><p>能表示的最大正数。最小的负数是 -MAX_VALUE。</p>
<h3 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h3><p>能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。</p>
<h3 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h3><p>Not A Number.</p>
<h3 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h3><p>特殊的负无穷大值，在溢出时返回该值。</p>
<h3 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h3><p>特殊的正无穷大值，在溢出时返回改值。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>下列方法均不会发生将String转化为Number的过程。</p>
<h3 id="Number-isNaN-value"><a href="#Number-isNaN-value" class="headerlink" title="Number.isNaN(value)"></a>Number.isNaN(value)</h3><p>定义：确定传递的值是否为 NaN和其类型是 Number。它是用于代替原始的全局isNaN()。<br>参数：要被检测是否是 NaN 的值。<br>返回：一个布尔值，表示给定的值是否是 NaN。<br>PS：该方法不同于全局的isNaN()，不会将字符串转换为数字。</p>
<h3 id="Number-isFinite-value"><a href="#Number-isFinite-value" class="headerlink" title="Number.isFinite(value)"></a>Number.isFinite(value)</h3><p>定义：用来检测传入的参数是否是一个有穷数（finite number）。<br>参数：value要被检测有穷性的值。<br>返回：一个布尔值表示给定的值是否是一个有穷数。<br>PS：和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值。</p>
<h3 id="Number-isInteger-value"><a href="#Number-isInteger-value" class="headerlink" title="Number.isInteger(value)"></a>Number.isInteger(value)</h3><p>定义：用来判断给定的参数是否为整数。<br>参数：value要判断此参数是否为整数。<br>返回：判断给定值是否是整数的 Boolean 值。</p>
<h3 id="Number-isSafeInteger-testValue"><a href="#Number-isSafeInteger-testValue" class="headerlink" title="Number.isSafeInteger(testValue)"></a>Number.isSafeInteger(testValue)</h3><p>定义：用来判断传入的参数值是否是一个“安全整数”（safe integer）。<br>参数：testValue需要检测的参数。<br>返回：一个布尔值 表示给定的值是否是一个安全整数（safe integer）。</p>
<h3 id="Number-parseFloat-string"><a href="#Number-parseFloat-string" class="headerlink" title="Number.parseFloat(string)"></a>Number.parseFloat(string)</h3><p>定义：可以把一个字符串解析成浮点数。<br>参数：string被解析的字符串。<br>返回：对应的浮点数。<br>PS：与全局函数 parseFloat()一样。</p>
<h3 id="Number-parseInt-string-radix"><a href="#Number-parseInt-string-radix" class="headerlink" title="Number.parseInt(string[, radix])"></a>Number.parseInt(string[, radix])</h3><p>定义：可以根据给定的进制数的一个字符串数解析成整数。<br>参数：string要解析的值，radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>下列方法均返回为字符串。</p>
<h3 id="numObj-toExponential-fractionDigits"><a href="#numObj-toExponential-fractionDigits" class="headerlink" title="numObj.toExponential([fractionDigits])"></a>numObj.toExponential([fractionDigits])</h3><p>定义：以指数表示法返回该数值字符串表示形式。<br>参数：fractionDigits一个整数，用来指定小数点后有几位数字。<br>返回：一个用幂的形式 (科学记数法) 来表示Number 对象的字符串。</p>
<h3 id="numObj-toFixed-digits"><a href="#numObj-toFixed-digits" class="headerlink" title="numObj.toFixed(digits)"></a>numObj.toFixed(digits)</h3><p>定义：使用定点表示法来格式化一个数。<br>参数：digits小数点后数字的个数。<br>返回：所给数值的定点数表示法的字符串形式。</p>
<h3 id="numObj-toPrecision-precision"><a href="#numObj-toPrecision-precision" class="headerlink" title="numObj.toPrecision(precision)"></a>numObj.toPrecision(precision)</h3><p>定义：以指定的精度返回该数值对象的字符串表示。<br>参数：precision一个用来指定有效数个数的整数。<br>返回：以定点表示法或指数表示法表示的一个数值对象的字符串表示。</p>
<h3 id="numObj-toLocaleString-locales-options"><a href="#numObj-toLocaleString-locales-options" class="headerlink" title="numObj.toLocaleString([locales [, options]])"></a>numObj.toLocaleString([locales [, options]])</h3><p>定义：返回这个数字在特定语言环境下的表示字符串。<br>参数：locales为指定本地要使用的编号系统，options为有下列属性（localeMatcher、style、currency等等但存在一定的兼容性）<br>返回：返回一个语言环境下的表示字符串。<br>PS：通常用于格式化为某种货币形式。</p>
<h3 id="numObj-toString-radix"><a href="#numObj-toString-radix" class="headerlink" title="numObj.toString([radix])"></a>numObj.toString([radix])</h3><p>定义：返回指定 Number 对象的字符串表示形式。<br>参数：radix指定要用于数字到字符串的转换的基数(从2到36)。<br>返回：转换后的字符串。</p>
<h3 id="numObj-valueOf"><a href="#numObj-valueOf" class="headerlink" title="numObj.valueOf()"></a>numObj.valueOf()</h3><p>定义：返回一个被 Number 对象包装的原始值。<br>返回：表示指定 Number 对象的原始值的数字。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode-num1-…-numN"><a href="#String-fromCharCode-num1-…-numN" class="headerlink" title="String.fromCharCode(num1, …, numN)"></a>String.fromCharCode(num1, …, numN)</h3><p>定义：返回使用指定的Unicode值序列创建的字符串。</p>
<h3 id="String-fromCodePoint-num1-…-numN"><a href="#String-fromCodePoint-num1-…-numN" class="headerlink" title="String.fromCodePoint(num1[, …[, numN]])"></a>String.fromCodePoint(num1[, …[, numN]])</h3><p>定义：返回使用指定的代码点序列创建的字符串，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p>
<h3 id="String-raw-callSite-…substitutions-String-rawtemplateString"><a href="#String-raw-callSite-…substitutions-String-rawtemplateString" class="headerlink" title="String.raw(callSite, …substitutions) || String.rawtemplateString"></a>String.raw(callSite, …substitutions) || String.raw<code>templateString</code></h3><p>是用来获取一个模板字符串的原始字面量值的。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h3><p>返回：字符串的长度。</p>
<h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>返回：第N个字符串，但不能更改。</p>
<h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="str-charAt-index"><a href="#str-charAt-index" class="headerlink" title="str.charAt(index)"></a>str.charAt(index)</h3><p>定义：从一个字符串中返回指定index的字符，缺省参数为0。</p>
<h3 id="str-charCodeAt-index"><a href="#str-charCodeAt-index" class="headerlink" title="str.charCodeAt(index)"></a>str.charCodeAt(index)</h3><p>定义：返回给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。</p>
<h3 id="str-codePointAt-index"><a href="#str-codePointAt-index" class="headerlink" title="str.codePointAt(index)"></a>str.codePointAt(index)</h3><p>定义：返回 一个 Unicode 编码点值的非负整数。</p>
<h3 id="str-concat-string2-string3-…-stringN"><a href="#str-concat-string2-string3-…-stringN" class="headerlink" title="str.concat(string2, string3[, …, stringN])"></a>str.concat(string2, string3[, …, stringN])</h3><p>定义：将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p>
<h3 id="str-includes-searchString-index"><a href="#str-includes-searchString-index" class="headerlink" title="str.includes(searchString[, index])"></a>str.includes(searchString[, index])</h3><p>定义：判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。</p>
<h3 id="str-startsWith-searchString-index"><a href="#str-startsWith-searchString-index" class="headerlink" title="str.startsWith(searchString [, index])"></a>str.startsWith(searchString [, index])</h3><p>定义：用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。</p>
<h3 id="str-endsWith-searchString-index"><a href="#str-endsWith-searchString-index" class="headerlink" title="str.endsWith(searchString [, index]);"></a>str.endsWith(searchString [, index]);</h3><p>定义：判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p>
<h3 id="str-indexOf-searchValue-index"><a href="#str-indexOf-searchValue-index" class="headerlink" title="str.indexOf(searchValue[, index])"></a>str.indexOf(searchValue[, index])</h3><p>定义：第一次出现的指定值的索引，开始在Index进行搜索，否则返回-1。</p>
<h3 id="str-lastIndexOf-searchValue-index"><a href="#str-lastIndexOf-searchValue-index" class="headerlink" title="str.lastIndexOf(searchValue[, index])"></a>str.lastIndexOf(searchValue[, index])</h3><p>定义：返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</p>
<h3 id="str-localeCompare-compareString-locales-options"><a href="#str-localeCompare-compareString-locales-options" class="headerlink" title="str.localeCompare(compareString[, locales[, options]])"></a>str.localeCompare(compareString[, locales[, options]])</h3><p>定义：localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。</p>
<h3 id="str-match-regexp"><a href="#str-match-regexp" class="headerlink" title="str.match(regexp);"></a>str.match(regexp);</h3><p>定义：当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。</p>
<h3 id="str-normalize-form"><a href="#str-normalize-form" class="headerlink" title="str.normalize([form]);"></a>str.normalize([form]);</h3><p>定义：会按照指定的一种 Unicode 正规形式将当前字符串正规化。</p>
<h3 id="str-padStart-targetLength-padString"><a href="#str-padStart-targetLength-padString" class="headerlink" title="str.padStart(targetLength [, padString])"></a>str.padStart(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之前（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p>
<h3 id="str-padEnd-targetLength-padString"><a href="#str-padEnd-targetLength-padString" class="headerlink" title="str.padEnd(targetLength [, padString])"></a>str.padEnd(targetLength [, padString])</h3><p>定义：会用一个字符串填充在当前字符串之后（如果需要的话则重复填充），返回填充后达到指定长度的字符串。</p>
<h3 id="str-repeat-count"><a href="#str-repeat-count" class="headerlink" title="str.repeat(count);"></a>str.repeat(count);</h3><p>定义：返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。<br>PS：参数从零开始。</p>
<h3 id="str-replace-regexp-substr-newSubStr-function"><a href="#str-replace-regexp-substr-newSubStr-function" class="headerlink" title="str.replace(regexp|substr, newSubStr|function)"></a>str.replace(regexp|substr, newSubStr|function)</h3><p>定义：返回一个由替换值替换一些或所有匹配的模式后的新字符串。<br>如果第一个参数为regexp第二个参数为function时，该函数参数说明<br>参数1：匹配模式的字符串。<br>参数2–：子表达是匹配的子字符串（就是捕获分组）。<br>倒数参数2：声明匹配在string中出现的位置。<br>倒数参数1：进行匹配的sting本身。</p>
<h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>定义：行正则表达式和 String对象之间的一个搜索匹配。<br>返回：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p>
<h3 id="str-slice-beginSlice-endSlice"><a href="#str-slice-beginSlice-endSlice" class="headerlink" title="str.slice(beginSlice[, endSlice])"></a>str.slice(beginSlice[, endSlice])</h3><p>定义：提取一个字符串的一部分，并返回一新的字符串。<br>参数：beginSlice从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度。<br>endSlice在该索引（以 0 为基数）处结束提取字符串，同样可为负数。</p>
<h3 id="str-split-separator-limit"><a href="#str-split-separator-limit" class="headerlink" title="str.split([separator[, limit]])"></a>str.split([separator[, limit]])</h3><p>定义：使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 </p>
<h3 id="str-substr-start-length"><a href="#str-substr-start-length" class="headerlink" title="str.substr(start[, length])"></a>str.substr(start[, length])</h3><p>定义：返回一个字符串中从指定位置开始到指定字符数的字符。<br>PS：start &gt;=str.length 或 length &lt;= 0 返回空字符串;start &lt; 0 则转换为start + str.length。</p>
<h3 id="str-substring-indexStart-indexEnd"><a href="#str-substring-indexStart-indexEnd" class="headerlink" title="str.substring(indexStart[, indexEnd])"></a>str.substring(indexStart[, indexEnd])</h3><p>定义：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。<br>PS：一些特殊情况。<br>如果 indexStart 等于 indexEnd，substring 返回一个空字符串。<br>如果省略 indexEnd，substring 提取字符一直到字符串末尾。<br>如果任一参数小于 0 或为 NaN，则被当作 0。<br>如果任一参数大于 stringName.length，则被当作 stringName.length。<br>如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。</p>
<h3 id="str-toLowerCase"><a href="#str-toLowerCase" class="headerlink" title="str.toLowerCase()"></a>str.toLowerCase()</h3><p>定义：将调用该方法的字符串值转为小写形式，并返回新字符串。</p>
<h3 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h3><p>定义：将调用该方法的字符串值转换为大写形式，并返回新字符串。</p>
<h3 id="str-toLocaleLowerCase"><a href="#str-toLocaleLowerCase" class="headerlink" title="str.toLocaleLowerCase()"></a>str.toLocaleLowerCase()</h3><p>定义：根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。<br>PS：在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同（除土耳其等）。</p>
<h3 id="str-toLocaleUpperCase"><a href="#str-toLocaleUpperCase" class="headerlink" title="str.toLocaleUpperCase()"></a>str.toLocaleUpperCase()</h3><p>定义：使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。</p>
<h3 id="str-toString"><a href="#str-toString" class="headerlink" title="str.toString()"></a>str.toString()</h3><p>定义：返回指定对象的字符串形式。</p>
<h3 id="str-trim"><a href="#str-trim" class="headerlink" title="str.trim()"></a>str.trim()</h3><p>定义：会从一个字符串的两端删除空白字符，返回一个新的字符串。<br>PS：str.trimLeft() 和 str.trimRight() 不是标准方法。</p>
<h3 id="string-Symbol-iterator"><a href="#string-Symbol-iterator" class="headerlink" title="string[Symbol.iterator]"></a>string[Symbol.iterator]</h3><p>返回一个新的Iterator对象，它遍历字符串的代码点，返回每一个代码点的字符串值。<br>PS：下列内置类型拥有默认迭代器行为Array、String、Set、Map等，而Object没有。</p>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><p>在 ES2015 中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。</p>
<h3 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike[, mapFn[, thisArg]])"></a>Array.from(arrayLike[, mapFn[, thisArg]])</h3><p>定义：从一个类似数组或可迭代对象中创建一个新的数组实例。<br>参数：<br>  arrayLike想要转换成数组的伪数组对象或可迭代对象。<br>  mapFn (可选参数)如果指定了该参数，新数组中的每个元素会执行该回调函数。<br>  thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。<br>返回：一个新的数组。<br>PS：Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg)，ES6之前的做法：Array.prototype.slice.call(arrayLike)。</p>
<h3 id="Array-isArray-obj"><a href="#Array-isArray-obj" class="headerlink" title="Array.isArray(obj)"></a>Array.isArray(obj)</h3><p>定义：确定传递的值是否是一个 Array。<br>返回：boolean。<br>PS：ES6之前的做法Object.prototype.toString.call(arg) === ‘[object Array]’。</p>
<h3 id="Array-of-element0-element1-…-elementN"><a href="#Array-of-element0-element1-…-elementN" class="headerlink" title="Array.of(element0[, element1[, …[, elementN]]])"></a>Array.of(element0[, element1[, …[, elementN]]])</h3><p>定义：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。<br>参数：任意个参数，将按顺序成为返回数组中的元素。<br>返回：参数列表组成的数组。<br>PS：Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。</p>
<h2 id="实例方法及属性"><a href="#实例方法及属性" class="headerlink" title="实例方法及属性"></a>实例方法及属性</h2><h3 id="ary-length"><a href="#ary-length" class="headerlink" title="ary.length"></a>ary.length</h3><p>返回：读写数组的长度。</p>
<h3 id="修改器方法（改变原数组）"><a href="#修改器方法（改变原数组）" class="headerlink" title="修改器方法（改变原数组）"></a>修改器方法（改变原数组）</h3><h4 id="arr-copyWithin-target-start-end"><a href="#arr-copyWithin-target-start-end" class="headerlink" title="arr.copyWithin(target[, start[, end]])"></a>arr.copyWithin(target[, start[, end]])</h4><p>定义：浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。<br>参数：<br>target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。<br>start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。<br>end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。<br>返回值：操作原数组。</p>
<h4 id="arr-fill-value-start-end"><a href="#arr-fill-value-start-end" class="headerlink" title="arr.fill(value[, start[, end]])"></a>arr.fill(value[, start[, end]])</h4><p>定义：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。<br>参数：<br>  value 用来填充数组元素的值。<br>  start 开始索引，默认为0。<br>  end 结束索引，默认为arr.length（不包括）。<br>返回：修改后的数组。</p>
<h4 id="arr-push-element1-…-elementN"><a href="#arr-push-element1-…-elementN" class="headerlink" title="arr.push(element1, …, elementN)"></a>arr.push(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br>参数：<br>  elementN 被添加到数组末尾的元素。<br>返回：操作后的数组的长度。</p>
<h4 id="arr-pop"><a href="#arr-pop" class="headerlink" title="arr.pop()"></a>arr.pop()</h4><p>定义：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素(当数组为空时返回undefined)。</p>
<h4 id="arr-reverse"><a href="#arr-reverse" class="headerlink" title="arr.reverse()"></a>arr.reverse()</h4><p>定义：将数组中元素的位置颠倒。<br>返回：颠倒数组中元素的位置，并返回该数组的引用。</p>
<h4 id="arr-sort-compareFunction"><a href="#arr-sort-compareFunction" class="headerlink" title="arr.sort(compareFunction)"></a>arr.sort(compareFunction)</h4><p>定义：可以根据指定方法对数组进行排序。<br>compareFunction 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>返回：返回排序后的数组。原数组已经被排序后的数组代替。</p>
<h4 id="arr-shift"><a href="#arr-shift" class="headerlink" title="arr.shift()"></a>arr.shift()</h4><p>定义：从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。<br>返回：从数组中删除的元素; 如果数组为空则返回undefined。 </p>
<h4 id="arr-unshift-element1-…-elementN"><a href="#arr-unshift-element1-…-elementN" class="headerlink" title="arr.unshift(element1, …, elementN)"></a>arr.unshift(element1, …, elementN)</h4><p>定义：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br>参数：element1, …, elementN 要添加到数组开头的元素。<br>返回：当一个对象调用该方法时，返回其 length 属性值。</p>
<h4 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start, [deleteCount], [item1], [item2], …)"></a>array.splice(start, [deleteCount], [item1], [item2], …)</h4><p>定义：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br>参数：<br>  start 开始修改的位置。<br>  deleteCount 移除数组元素的个数。<br>  item1、item2…为添加的元素。<br>返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p>
<h3 id="访问方法（不直接操作原理的数组）"><a href="#访问方法（不直接操作原理的数组）" class="headerlink" title="访问方法（不直接操作原理的数组）"></a>访问方法（不直接操作原理的数组）</h3><h4 id="old-array-concat-value1-value2-…-valueN"><a href="#old-array-concat-value1-value2-…-valueN" class="headerlink" title="old_array.concat(value1[, value2[, …[, valueN]]])"></a>old_array.concat(value1[, value2[, …[, valueN]]])</h4><p>定义：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br>参数：valueN 将数组和/或值连接成新数组。<br>返回：新数组。</p>
<h4 id="arr-includes-searchElement-fromIndex"><a href="#arr-includes-searchElement-fromIndex" class="headerlink" title="arr.includes(searchElement, [fromIndex])"></a>arr.includes(searchElement, [fromIndex])</h4><p>定义：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：boolean。</p>
<h4 id="arr-join-separator"><a href="#arr-join-separator" class="headerlink" title="arr.join([separator])"></a>arr.join([separator])</h4><p>定义：将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。<br>参数：<br>  searchElement 需要查找的元素值。<br>  fromIndex 从该索引处开始查找 searchElement。<br>返回：string。</p>
<h4 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin], [end])"></a>arr.slice([begin], [end])</h4><p>定义：返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。<br>返回：一个含有提取元素的新数组。</p>
<h4 id="arr-indexOf-searchElement-fromIndex-0"><a href="#arr-indexOf-searchElement-fromIndex-0" class="headerlink" title="arr.indexOf(searchElement[, fromIndex = 0])"></a>arr.indexOf(searchElement[, fromIndex = 0])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。</p>
<h4 id="arr-lastIndexOf-searchElement-fromIndex-arr-length-1"><a href="#arr-lastIndexOf-searchElement-fromIndex-arr-length-1" class="headerlink" title="arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])"></a>arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</h4><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>返回：数组中最后一个元素的索引，如未找到返回-1。</p>
<h4 id="arr-toString"><a href="#arr-toString" class="headerlink" title="arr.toString()"></a>arr.toString()</h4><p>定义：返回一个字符串，表示指定的数组及其元素。<br>返回：逗号分隔的字符串。</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="array-forEach-callback-currentValue-index-array-do-something-this"><a href="#array-forEach-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.forEach(callback(currentValue, index, array){ //do something}, this)"></a>array.forEach(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：对数组的每个元素执行一次提供的函数。<br>返回：undefined。<br>PS：没有办法中止或者跳出 forEach 循环，需要跳出请使用循环代替。<br>已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不会跳过那些值为 undefined、null 的项）。</p>
<h4 id="array-map-callback-currentValue-index-array-do-something-this"><a href="#array-map-callback-currentValue-index-array-do-something-this" class="headerlink" title="array.map(callback(currentValue, index, array){ //do something}, this)"></a>array.map(callback(currentValue, index, array){ //do something}, this)</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>返回：一个新数组，每个元素都是回调函数的结果。</p>
<h4 id="arr-keys"><a href="#arr-keys" class="headerlink" title="arr.keys()"></a>arr.keys()</h4><p>定义：返回一个新的Array迭代器，它包含数组中每个索引的键。<br>返回：一个新的 Array 迭代器对象。</p>
<h4 id="arr-values"><a href="#arr-values" class="headerlink" title="arr.values()"></a>arr.values()</h4><p>定义：返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。<br>返回：一个新的 Array 迭代器对象。</p>
<h4 id="arr-entries"><a href="#arr-entries" class="headerlink" title="arr.entries()"></a>arr.entries()</h4><p>定义：返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。<br>返回：一个新的 Array 迭代器对象。</p>
<h4 id="arr-every-callback-thisArg"><a href="#arr-every-callback-thisArg" class="headerlink" title="arr.every(callback[, thisArg])"></a>arr.every(callback[, thisArg])</h4><p>定义：测试数组的所有元素是否都通过了指定函数的测试。<br>返回：boolean。</p>
<h4 id="arr-some-callback-thisArg"><a href="#arr-some-callback-thisArg" class="headerlink" title="arr.some(callback[, thisArg])"></a>arr.some(callback[, thisArg])</h4><p>定义：测试数组中的某些元素是否通过由提供的函数实现的测试。<br>返回：boolean。</p>
<h4 id="arr-filter-callback-thisArg"><a href="#arr-filter-callback-thisArg" class="headerlink" title="arr.filter(callback[, thisArg])"></a>arr.filter(callback[, thisArg])</h4><p>定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br>返回：新数组。</p>
<h4 id="arr-findIndex-callback-thisArg"><a href="#arr-findIndex-callback-thisArg" class="headerlink" title="arr.findIndex(callback[, thisArg])"></a>arr.findIndex(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值的索引，否则返回 -1。</p>
<h4 id="arr-find-callback-thisArg"><a href="#arr-find-callback-thisArg" class="headerlink" title="arr.find(callback[, thisArg])"></a>arr.find(callback[, thisArg])</h4><p>定义：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br>返回：当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。</p>
<h4 id="arr-reduce-callback-initialValue"><a href="#arr-reduce-callback-initialValue" class="headerlink" title="arr.reduce(callback[, initialValue])"></a>arr.reduce(callback[, initialValue])</h4><p>定义：对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<br>参数：<br>  callback 执行数组中每个值的函数，包含四个参数：<br>    accumulato 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br>    currentValue 数组中正在处理的元素。<br>    currentIndex可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。<br>    array可选 调用reduce的数组。<br>  initialValue 可选用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br>返回：函数累计处理的结果。</p>
<h4 id="arr-reduceRight-callback-initialValue"><a href="#arr-reduceRight-callback-initialValue" class="headerlink" title="arr.reduceRight(callback[, initialValue])"></a>arr.reduceRight(callback[, initialValue])</h4><p>定义：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。</p>
<h4 id="arrSymbol-iterator"><a href="#arrSymbol-iterator" class="headerlink" title="arrSymbol.iterator"></a>arr<a href>Symbol.iterator</a></h4><p>定义：默认为数组不说了迭代器，@@iterator 属性和 values() 属性的初始值均为同一个函数对象。<br>返回：数组的 iterator 方法，默认情况下与 values() 返回值相同。</p>
<h4 id="arr-flatten-depth"><a href="#arr-flatten-depth" class="headerlink" title="arr.flatten(depth)"></a>arr.flatten(depth)</h4><p>定义：会递归到指定深度将所有子数组连接，并返回一个新数组。<br>参数：depth 可选指定嵌套数组中的结构深度，默认值为1。<br>返回：一个将子数组连接的新数组。</p>
<h4 id="arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg"><a href="#arr-flatMap-function-callback-currentValue-index-array-返回新数组的元素-thisArg" class="headerlink" title="arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])"></a>arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])</h4><p>定义：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flatten 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。<br>返回：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</p>
<h1 id="Proxy-amp-amp-Reflect"><a href="#Proxy-amp-amp-Reflect" class="headerlink" title="Proxy &amp;&amp; Reflect"></a>Proxy &amp;&amp; Reflect</h1><p>Proxy是一个构造函数（对对象的访问进行拦截），Reflect（操作对象提供的API）。<br>Reflect它与Proxy对象的方法是一一对应的，这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy方法：target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy = new Proxy(person, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    if (property in target) &#123;</span><br><span class="line">      return target[property];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name // &quot;张三&quot;</span><br><span class="line">proxy.age // 抛出一个错误</span><br></pre></td></tr></table></figure></p>
<p><a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" target="_blank" rel="noopener">Proxy使用详解</a></p>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。<br>// 下列方法说明：target为目标对象，name为某个属性，receiver为如果name属性设置了赋值函数，则为函数的this指向<br>Reflect.apply(target, thisArg, args)<br>  Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。<br>Reflect.construct(target, args)<br>  Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。<br>Reflect.get(target, name, receiver)<br>  Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>Reflect.set(target, name, value, receiver)<br>  Reflect.set方法设置target对象的name属性等于value。<br>Reflect.defineProperty(target, name, desc)<br>  Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。<br>Reflect.deleteProperty(target, name)<br>  Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。<br>Reflect.has(target, name)<br>  Reflect.has方法对应name in obj里面的in运算符。<br>Reflect.ownKeys(target)<br>  Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。<br>Reflect.isExtensible(target)<br>  Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。<br>Reflect.preventExtensions(target)<br>  Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。<br>Reflect.getOwnPropertyDescriptor(target, name)<br>  Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。<br>Reflect.getPrototypeOf(target)<br>  Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。<br>Reflect.setPrototypeOf(target, prototype)<br>  Reflect.setPrototypeOf方法用于设置对象的<strong>proto</strong>属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。</p>
<h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>Event接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="bubbles（只读）"><a href="#bubbles（只读）" class="headerlink" title="bubbles（只读）"></a>bubbles（只读）</h3><p>定义：用来表示该事件是否在DOM中冒泡的boolean值。</p>
<h3 id="cancelBubble（废弃）"><a href="#cancelBubble（废弃）" class="headerlink" title="cancelBubble（废弃）"></a>cancelBubble（废弃）</h3><p>定义：获取或设置当前事件是否要取消冒泡（使用e.stopPropagation()代替）。</p>
<h3 id="cancelable（只读）"><a href="#cancelable（只读）" class="headerlink" title="cancelable（只读）"></a>cancelable（只读）</h3><p>定义：表示这个事件是否可以取消默认行为（阻止默认行为e.preventDefault()）。</p>
<h3 id="composed（只读）"><a href="#composed（只读）" class="headerlink" title="composed（只读）"></a>composed（只读）</h3><p>定义：表示该事件是否可以Shadow DOM 传递到一般的 DOM。</p>
<h3 id="currentTarget（只读）"><a href="#currentTarget（只读）" class="headerlink" title="currentTarget（只读）"></a>currentTarget（只读）</h3><p>定义：当前注册事件的对象的引用，这个值会在传递途中发生变化。</p>
<h3 id="deepPath"><a href="#deepPath" class="headerlink" title="deepPath"></a>deepPath</h3><p>定义：返回事件冒泡过程所有经过的节点所构成的Array数组。</p>
<h3 id="defaultPrevented（只读）"><a href="#defaultPrevented（只读）" class="headerlink" title="defaultPrevented（只读）"></a>defaultPrevented（只读）</h3><p>定义：返回是否已经调用了e.preventDefault()来阻止默认行为。</p>
<h3 id="eventPhase（只读）"><a href="#eventPhase（只读）" class="headerlink" title="eventPhase（只读）"></a>eventPhase（只读）</h3><p>定义：返回事件流正在哪个阶段。</p>
<h3 id="returnValue（废弃）"><a href="#returnValue（废弃）" class="headerlink" title="returnValue（废弃）"></a>returnValue（废弃）</h3><p>定义：获取或设置事件的默认操作是否已被阻止。</p>
<h3 id="target（只读）"><a href="#target（只读）" class="headerlink" title="target（只读）"></a>target（只读）</h3><p>定义：返回一个触发事件的对象的引用（ie的srcElement）。</p>
<h3 id="timeStamp（只读）"><a href="#timeStamp（只读）" class="headerlink" title="timeStamp（只读）"></a>timeStamp（只读）</h3><p>定义：事件创建时的时间戳，毫秒级别。</p>
<h3 id="type（只读）"><a href="#type（只读）" class="headerlink" title="type（只读）"></a>type（只读）</h3><p>定义：返回一个字符串（不区分大小写）, 表示该事件对象的事件类型。</p>
<h3 id="isTrusted（只读）"><a href="#isTrusted（只读）" class="headerlink" title="isTrusted（只读）"></a>isTrusted（只读）</h3><p>定义：指明事件是否是由浏览器（当用户点击实例后）或者由脚本（使用事件的创建方法，例如event.initEvent）启动。</p>
<h3 id="target与currentTarget的区别"><a href="#target与currentTarget的区别" class="headerlink" title="target与currentTarget的区别"></a>target与currentTarget的区别</h3><p>event.target返回触发事件的元素<br>event.currentTarget返回绑定事件的元素<br><a href="https://www.cnblogs.com/yewenxiang/p/6171411.html" target="_blank" rel="noopener">event对象中 target和currentTarget 属性的区别</a></p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="document-createEvent-“UIEvents”"><a href="#document-createEvent-“UIEvents”" class="headerlink" title="document.createEvent(“UIEvents”)"></a>document.createEvent(“UIEvents”)</h3><p>创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化。</p>
<h3 id="event-initEvent-type-bubbles-cancelable"><a href="#event-initEvent-type-bubbles-cancelable" class="headerlink" title="event.initEvent(type, bubbles, cancelable)"></a>event.initEvent(type, bubbles, cancelable)</h3><p>定义：Event.initEvent() 方法可以用来初始化由Document.createEvent() 创建的 event 实例，且在触发之前event.dispatchEvent()。</p>
<h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h3><p>定义：如果此事件没有需要显式处理，那么它默认的动作也不要做（因为默认是要做的）。</p>
<h3 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation()"></a>event.stopPropagation()</h3><p>定义：阻止捕获和冒泡阶段中当前事件的进一步传播（只阻止当前侦听器）。</p>
<h3 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h3><p>定义：阻止调用相同事件的其他侦听器。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>web常见的安全问题及解决方法</title>
    <url>/2018/web%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="前端安全问题"><a href="#前端安全问题" class="headerlink" title="前端安全问题"></a>前端安全问题</h1><h2 id="XSS-漏洞"><a href="#XSS-漏洞" class="headerlink" title="XSS 漏洞"></a>XSS 漏洞</h2><pre><code>定义：
    跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。
    恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
举例：
1.HTML DOM
    视图（textContent）
        &lt;a href=&quot;/user/1&quot;&gt;{{ user_name }}&lt;/a&gt;
    数据
        &lt;script&gt;alert(1)&lt;/script&gt;
    结果
        &lt;a href=&quot;/user/1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/a&gt;
    最基本的例子，如果此处不对 user_name 中的特殊符号进行 escape，就会造成 XSS。
2.HTML Attribute
    视图（attribute）
        &lt;img src=&quot;{{ image_url }}&quot;&gt;
    数据
        onerror=&quot;alert(1)&quot;
    结果
        &lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt;
    这个例子表明，如果只对尖括号进行 escape 是不够的，很多时候引号也需要被 escape。
    简单来说，对不同输出场景，需要使用不同的 escape 规则。
3.Javascript
        &lt;script&gt;var user_data = {{ user_data|json_encode }};&lt;/script&gt;
    数据
        {&quot;exploit&quot;: &quot;&lt;/script&gt;&lt;script&gt;alert(1);//&quot;}
    结果
        &lt;script&gt;var user_data = {&quot;exploit&quot;: &quot;&lt;/script&gt;&lt;script&gt;alert(1);//&quot;};&lt;/script&gt;
    这是一个特别的例子，大多数人觉得，对于输出在 &lt;script&gt; 中的内容，json_encode 一下就安全了，其实不然。在这个例子中，XSS 仍然发生了。
解决方案：
    1.在不同上下文中，使用合适的 escape 方式
    2.不要相信任何来自用户的输入，（不仅限于 POST Body，还包括 QueryString，甚至是 Headers）
</code></pre><h2 id="CSRF-漏洞"><a href="#CSRF-漏洞" class="headerlink" title="CSRF 漏洞"></a>CSRF 漏洞</h2><pre><code>定义：    
    CSRF（Cross-site request forgery）跨站请求伪造通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。
    它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。
    与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。
理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。
    CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......
    造成的问题包括：个人隐私泄露以及财产安全。    
CSRF攻击攻击原理及过程如下：
   1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
   2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
   3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
   4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
   5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
   网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 
举例：    
1.跨站转账
    银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000
　　危险网站B，它里面有一段HTML的代码如下：
　　&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;
　　首先，你登录了银行网站A保存了cookie，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块......
　　为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。
    在访问危险网站B的之前，你已经登录了银行网站A，而B中的&lt;img&gt;以GET的方式请求第三方资源（这里的第三方就是指银行网站了，
    原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，
    去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，
    认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作......    
解决方案：（让服务器分辨出是真实用户还是攻击者）    
    1.为请求带上 token
    2.验证HTTP Referer字段
        根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。
    3.在HTTP头中自定义属性并验证
</code></pre><h2 id="a链接的安全问题"><a href="#a链接的安全问题" class="headerlink" title="a链接的安全问题"></a>a链接的安全问题</h2><p>阐述问题：当a链接有target=”_blank”属性时，必须添加rel=”noreferrer noopener”，不然新产生的页面可以通过window.opener来获取到父窗口的window对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;nofollow me noopener noreferrer&quot; &gt;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://juejin.im/post/5950f387f265da6c44072d6c" target="_blank" rel="noopener">聊聊 rel=noopener</a><br><a href="https://juejin.im/post/5addbf3bf265da0b78682131" target="_blank" rel="noopener">关于a标签target=“_blank”使用rel=noopener</a></p>
<h1 id="后端安全问题"><a href="#后端安全问题" class="headerlink" title="后端安全问题"></a>后端安全问题</h1><h2 id="SQL-注入漏洞"><a href="#SQL-注入漏洞" class="headerlink" title="SQL 注入漏洞"></a>SQL 注入漏洞</h2><pre><code>问题展示：
    &lt;?php $user = mysql_query(&apos;SELECT * FROM USERS WHERE UserName=&quot;&apos;.$_GET[&apos;user&apos;].&apos;&quot;&apos;); ?&gt;
    那么当请求中 user 参数为 &quot;;DROP TABLE USERS;-- 时，合成的 SQL 语句是：
    SELECT * FROM USERS WHERE UserName=&quot;&quot;;DROP TABLE USERS;--&quot;
    // 这样将删除表 users
解决方案：
    所有 SQL 语句都使用参数化查询（推荐）或对参数进行 escape（不推荐）
</code></pre><h2 id="权限控制漏洞"><a href="#权限控制漏洞" class="headerlink" title="权限控制漏洞"></a>权限控制漏洞</h2><pre><code>问题展示：
    未经授权可以进行的操作都是权限控制漏洞。
    例如，某些网站的后台操作就仗着「以为用户不知道入口地址」不进行任何权限检查，
    又例如，某些操作可能出现不允许更改的字段被用户递交更改（往往是那些网页上标记为 disabled 或者 hidden 的字段），
    再例如，允许通过 ../ 访问到不应该被访问的文件等（一般存在于 include 中）。
解决方案：
    所有地方都要进行权限检查（如是否已登录、当前用户是否有足够权限、该项是否可修改等），
    总之，不要相信任何来自用户的数据，URL 当然也是。
</code></pre><h2 id="SESSION-与-COOKIE"><a href="#SESSION-与-COOKIE" class="headerlink" title="SESSION 与 COOKIE"></a>SESSION 与 COOKIE</h2><pre><code>问题展示：
    Session 和 Cookie 是两种用于存储用户当前状态的工具。
    某些开发者不了解 Session 与 Cookie 的区别，误用或者混用，导致敏感信息泄露或者信息篡改。
    Cookie 存储在浏览器上，用户可以查看和修改 Cookie。
解决方案：
    Session 是存储在服务端的数据，一般来说安全可靠；大多数 Session 都是基于 Cookie 实现的
    （在 Cookie 中存储一串 SESSION_ID，在服务器上存储该 SESSION_ID 对应的内容）。
</code></pre><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><pre><code>问题展示：
    首先，用户的 IP 地址一般存储在 REMOTE_ADDR 中，这是唯一的可信的 IP 地址数据（视不同语言而定）。
    然后某些代理服务器，会将用户的真实 IP 地址附加在 header 的 VIA 或 X_FORWARDED_FOR 中（因为REMOTE_ADDR 是代理服务器自身的 IP）。
    所以，要获取用户 IP 地址，一般做法是，判断是否存在 VIA 或者 X_FORWARDED_FOR 头，
    如果存在，则使用它们，如果不存在则使用 REMOTE_ADDR。
    这就产生问题了，X_FORWARDED_FOR 或 VIA 是 HTTP Header，换句话说，它们是可以被伪造的。
    例如，在投票中，如果采信了 X_FORWARDED_FOR，往往意味着被刷票。
解决方案：
    只使用 REMOTE_ADDR 作为获取 IP 的手段。
</code></pre><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><pre><code>问题展示：
    验证码里常见的问题有：非一次性、容易被识别。
解决方案：
    非一次性指的是，同一个验证码可以一直被用下去。一般来说，每进行一次验证码校对（无论正确与否），
    都应该强制更换或清除 Session 中的验证码。
    关于识别问题，在当前科技水平下，不加噪点不加扭曲的验证码几乎是 100% 可识别的。
</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="nodeJs项目重新安装依赖包"><a href="#nodeJs项目重新安装依赖包" class="headerlink" title="nodeJs项目重新安装依赖包"></a>nodeJs项目重新安装依赖包</h2><p>rm -rf node_modules<br>rm package-lock.json<br>npm cache clear –force<br>npm install</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/fengyinchao/article/details/50775121" target="_blank" rel="noopener">Web 开发常见安全问题</a><br>    <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a><br>    <a href="https://www.hacksplaining.com/features" target="_blank" rel="noopener">汇总网络安全demo</a></p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>我所了解的CSS包含块</title>
    <url>/2018/%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="指出错误观念"><a href="#指出错误观念" class="headerlink" title="指出错误观念"></a>指出错误观念</h1><p>许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！<br>一个元素的尺寸和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。<br>下面我们看看盒模型：<br>当浏览器展示一个文档的时候，对于每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域：</p>
<ol>
<li>内容区</li>
<li>内边距区</li>
<li>边框区</li>
<li>外边距区<br><img src="http://p677fntmi.bkt.clouddn.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></li>
</ol>
<h1 id="什么是包含块？"><a href="#什么是包含块？" class="headerlink" title="什么是包含块？"></a>什么是包含块？</h1><p>包含块有分为根元素包含块和其他元素的包含块。</p>
<h2 id="根元素包含块"><a href="#根元素包含块" class="headerlink" title="根元素包含块"></a>根元素包含块</h2><p>根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。<br>可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。<br>对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。</p>
<h2 id="其他元素的包含块"><a href="#其他元素的包含块" class="headerlink" title="其他元素的包含块"></a>其他元素的包含块</h2><p>大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样，下面就来学习如何确定这些元素的包含块。</p>
<h1 id="如何确定元素的包含块？"><a href="#如何确定元素的包含块？" class="headerlink" title="如何确定元素的包含块？"></a>如何确定元素的包含块？</h1><p>确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景：</p>
<ol>
<li>如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）或格式化上下文<a href="https://fanerge.github.io/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#BFC">BFC</a>(比如说 a table container, flex container, grid container, or the block container itself)的<span style="color: red">内容区的边缘</span>组成的。</li>
<li>如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的<span style="color: red">内边距区的边缘</span>组成的。</li>
<li>如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in  the case of paged media) 组成的。</li>
<li>如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的<span style="color: red">内边距区的边缘</span>组成的：<br>A transform or perspective value other than none<br>A will-change value of transform or perspective<br>A filter value other than none or a will-change value of filter (only works on Firefox).</li>
</ol>
<h1 id="元素包含块的作用？"><a href="#元素包含块的作用？" class="headerlink" title="元素包含块的作用？"></a>元素包含块的作用？</h1><p>元素的尺寸和位置经常受其包含块的影响。对于一个绝对定位的元素来说（他的 position 属性被设定为 absolute 或 fixed），如果它的 width, height, padding, margin, 和 offset 这些属性的值是一个比例值（如百分比等）的话，那这些值的计算值就是由它的包含块计算而来的。<br>简单来说，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</p>
<ol>
<li>height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。</li>
<li>width, left, right, padding, margin, text-indent(2018-05-27修改)这些属性由包含块的 width 属性的值来计算它的百分值。</li>
</ol>
<h1 id="下面看些例子"><a href="#下面看些例子" class="headerlink" title="下面看些例子"></a>下面看些例子</h1><p>下面示例公用HTML代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;p&gt;This is a paragraph!&lt;/p&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 400px;</span><br><span class="line">  height: 160px;</span><br><span class="line">  background: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  width: 50%;   /* == 400px * .5 = 200px */</span><br><span class="line">  height: 25%;  /* == 160px * .25 = 40px */</span><br><span class="line">  margin: 5%;   /* == 400px * .05 = 20px */</span><br><span class="line">  padding: 5%;  /* == 400px * .05 = 20px */</span><br><span class="line">  background: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk1.png" alt></p>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">  display: inline;</span><br><span class="line">  background: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  width: 50%;     /* == half the body&apos;s width */</span><br><span class="line">  height: 200px;  /* Note: a percentage would be 0 */</span><br><span class="line">  background: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk2.png" alt></p>
<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">  transform: rotate(0deg);</span><br><span class="line">  width: 400px;</span><br><span class="line">  height: 160px;</span><br><span class="line">  background: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 80px;</span><br><span class="line">  top: 30px;</span><br><span class="line">  width: 50%;   /* == 200px */</span><br><span class="line">  height: 25%;  /* == 40px */</span><br><span class="line">  margin: 5%;   /* == 20px */</span><br><span class="line">  padding: 5%;  /* == 20px */</span><br><span class="line">  background: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk3.png" alt></p>
<h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 30px;</span><br><span class="line">  top: 30px;</span><br><span class="line">  width: 400px;</span><br><span class="line">  height: 160px;</span><br><span class="line">  padding: 30px 20px;</span><br><span class="line">  background: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 50%;   /* == (400px + 20px + 20px) * .5 = 220px */</span><br><span class="line">  height: 25%;  /* == (160px + 30px + 30px) * .25 = 55px */</span><br><span class="line">  margin: 5%;   /* == (400px + 20px + 20px) * .05 = 22px */</span><br><span class="line">  padding: 5%;  /* == (400px + 20px + 20px) * .05 = 22px */</span><br><span class="line">  background: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk4.png" alt></p>
<h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  margin: 30px;</span><br><span class="line">  padding: 15px;</span><br><span class="line">  background: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  width: 50%;   /* == (50vw - (width of vertical scrollbar)) */</span><br><span class="line">  height: 50%;  /* == (50vh - (height of horizontal scrollbar)) */</span><br><span class="line">  margin: 5%;   /* == (5vw - (width of vertical scrollbar)) */</span><br><span class="line">  padding: 5%;  /* == (5vw - (width of vertical scrollbar)) */</span><br><span class="line">  background: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。<br><img src="http://p52glq5m1.bkt.clouddn.com/css_bhk5.png" alt></p>
<p>如果本文对你有帮助，记得给我的博客项目<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="noopener">star</a>(⊙﹏⊙)，<a href="https://fanerge.github.io">顺便找找成都氛围好的前端团队，也许我就是你们要找的の</a>。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>全面了解Object对象</title>
    <url>/2018/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Object%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<h1 id="为什么一切皆为对象"><a href="#为什么一切皆为对象" class="headerlink" title="为什么一切皆为对象"></a>为什么一切皆为对象</h1><p>‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一探究竟吧？<br>为了解决这个问题，我们的从javascript的原型链说起。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在js几乎任何对象有一个 [[prototype]] 属性，在标准中，这是一个隐藏属性。<br>虽然说 [[prototype]] 是一个隐藏属性，但很多浏览器都给每一个对象提供 __proto__ 这一属性，这个属性就是该对象的[[prototype]]。</p>
<blockquote>
<p>   Object.prototype 的 __proto__  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部 [[Prototype]] (一个对象或 null)。<br>使用 __proto__ 是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__ 属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 赞成Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf 来获取或设置对象的原型链。</p>
</blockquote>
<p>下面我们用标准的方法来获取对象的原型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 基本数据类型（Number,String,Boolean,Symbol）</span><br><span class="line">let str = &apos;strstr&apos;;</span><br><span class="line">// 1</span><br><span class="line">Object.getPrototypeOf(str) // String对象（这里包括字符串原型链上的所有方法如slice、indexOf等）</span><br><span class="line">// 2</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(str)) // Object对象</span><br><span class="line">// 3</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(str))) // null</span><br><span class="line">console.dir(Object.getPrototypeOf(str))</span><br><span class="line"></span><br><span class="line">// 其他类型（Object,Function,Array,Error,Math,Date,Map,Set,WeakMap,WeakSet,JSON）</span><br><span class="line">function demo() &#123;&#125;</span><br><span class="line">// 4</span><br><span class="line">Object.getPrototypeOf(demo) // anonymous函数</span><br><span class="line">// 5</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(demo)) // Object对象</span><br><span class="line">// 6</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(demo))) // null</span><br></pre></td></tr></table></figure></p>
<p>PS：博主分别以基本数据类型Number,String,Boolean,Symbol（这里不考虑undefined和null，因为它们是特殊的两个值，木有原型）做了测试，上面代码注释1,2,3最终到达原型链的顶端null。<br>对于其他类型也是同样的，通过4,5,6到达原型链顶端Object.prototype === null。<br>从上面可以整个javascript语法系统都是基于这个原型链来实现方法和属性的继承的，并且可以看到原型链是有终点的值为 null。</p>
<p>搞清楚了原型链，在回到‘一切皆为对象’。<br>明白了javascript的原型链，明白了所有的继承终点都到了Object上，就不难理解‘一切皆为对象’了吧。</p>
<h1 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name: &apos;yzf&apos;,</span><br><span class="line">	age: 27,</span><br><span class="line">	city: &apos;chengdu&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是大家最熟悉的创建方式。</p>
<h2 id="Object实例化"><a href="#Object实例化" class="headerlink" title="Object实例化"></a>Object实例化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = new Object(&#123;</span><br><span class="line">	// name: &apos;yzf&apos;,</span><br><span class="line">	// age: 27,</span><br><span class="line">	// city: &apos;chengdu&apos;</span><br><span class="line">&#125;);</span><br><span class="line">obj.name = &apos;yzf&apos;;</span><br><span class="line">obj.age = 27;</span><br><span class="line">obj.city = &apos;chengdu&apos;;</span><br></pre></td></tr></table></figure>
<p>这里两种方式，为obj赋值，一种在实例化是进行，一种在实例化之后添加。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, city)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.city = city;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fanerge = new Person(&apos;yzf&apos;, 27, &apos;chengdu&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="Object对象的方法"><a href="#Object对象的方法" class="headerlink" title="Object对象的方法"></a>Object对象的方法</h1><p>Object对象的方法分为Object静态方法和Object的实例方法，静态方法定义在Object自身上，而实例方法定义在Object.prototype上；<br>在使用方式上也有区别，静态方法使用’如Object.keys(obj)’而实例方法使用’如obj.hasOwnProperty(prop)’。<br>我认为我们学习API是需要重点了解一个API的使用方式、定义、参数说明、返回值，下面我给出Object标准库中的方法，其中有部分是ES6+的方法，存在一定的兼容性问题。</p>
<h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><h3 id="Object-assign-target-…sources"><a href="#Object-assign-target-…sources" class="headerlink" title="Object.assign(target, …sources)"></a>Object.assign(target, …sources)</h3><p>定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>参数：target为目标对象，sources为源对象。<br>返回：目标对象。</p>
<h3 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [propertiesObject])"></a>Object.create(proto, [propertiesObject])</h3><p>定义：创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>参数：proto为新创建对象的原型对象，propertiesObject为相关属性的描述符。<br>返回：新对象。</p>
<h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>定义：会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>参数：obj为要在其上定义属性的对象，prop为要定义或修改的属性的名称，descriptor为将被定义或修改的属性描述符。<br>返回：obj。</p>
<h3 id="Object-defineProperties-obj-props"><a href="#Object-defineProperties-obj-props" class="headerlink" title="Object.defineProperties(obj, props)"></a>Object.defineProperties(obj, props)</h3><p>定义：直接在一个对象上定义新的属性或修改现有属性，并返回该对象。<br>参数：obj为要在其上定义属性的对象，props为要定义或修改的一个或多个属性的描述符。<br>返回：obj。</p>
<h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><p>定义：返回一个由一个给定对象的自身可枚举属性组成的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个表示给定对象的所有可枚举属性的字符串数组。</p>
<h3 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：一个包含对象自身的所有可枚举属性值的数组。</p>
<h3 id="Object-values-obj-1"><a href="#Object-values-obj-1" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h3><p>定义：返回一个给定对象自己的所有可枚举属性值的数组。<br>参数：obj为要返回其枚举自身属性的对象。<br>返回：给定对象自身可枚举属性的键值（键值对也为数组）对数组。</p>
<h3 id="Object-preventExtensions-obj"><a href="#Object-preventExtensions-obj" class="headerlink" title="Object.preventExtensions(obj)"></a>Object.preventExtensions(obj)</h3><p>定义：让一个对象变的不可扩展，也就是永远不能再添加新的属性。<br>参数：obj为将要变得不可扩展的对象。<br>返回：已经不可扩展的对象。<br>PS：该对象的属性可能仍然可删除，且对象的原型仍然可以添加属性。</p>
<h3 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h3><p>定义：判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否可扩展的一个Boolean 。</p>
<h3 id="Object-seal-obj"><a href="#Object-seal-obj" class="headerlink" title="Object.seal(obj)"></a>Object.seal(obj)</h3><p>定义：封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。<br>参数：obj为将要被密封的对象。<br>返回：被密封的对象。<br>PS：属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性（get）。</p>
<h3 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h3><p>定义：判断一个对象是否被密封。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被密封的一个Boolean。</p>
<h3 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h3><p>定义：可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。<br>参数：obj为要被冻结的对象。<br>返回：要被冻结的对象。</p>
<h3 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h3><p>定义：判断一个对象是否被冻结。<br>参数：obj为需要检测的对象。<br>返回：表示给定对象是否被冻结的Boolean。</p>
<h3 id="Object-getOwnPropertyDescriptor-obj-prop"><a href="#Object-getOwnPropertyDescriptor-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptor(obj, prop)"></a>Object.getOwnPropertyDescriptor(obj, prop)</h3><p>定义：返回指定对象上一个自有属性对应的属性描述符。<br>参数：obj为需要查找的目标对象，prop为目标对象内属性名称（String类型）。<br>返回：如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</p>
<h3 id="Object-getOwnPropertyDescriptors-obj"><a href="#Object-getOwnPropertyDescriptors-obj" class="headerlink" title="Object.getOwnPropertyDescriptors(obj)"></a>Object.getOwnPropertyDescriptors(obj)</h3><p>定义：用来获取一个对象的所有自身属性的描述符。<br>参数：obj为需要查找的目标对象。<br>返回：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p>
<h3 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>返回：在给定对象上找到的属性对应的字符串数组。</p>
<h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><p>定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>参数：obj为要返回 Symbol 属性的对象。<br>返回：在给定对象自身上找到的所有 Symbol 属性的数组。</p>
<h3 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h3><p>定义：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或null。<br>参数：obj为要设置其原型的对象，prototype为该对象的新原型(一个对象 或 null)。<br>返回：返回obj对象。</p>
<h3 id="Object-getPrototypeOf-object"><a href="#Object-getPrototypeOf-object" class="headerlink" title="Object.getPrototypeOf(object)"></a>Object.getPrototypeOf(object)</h3><p>定义：返回指定对象的原型（内部[[Prototype]]属性的值）。<br>参数：要返回其原型的对象。<br>返回：给定对象的原型。如果没有继承属性，则返回null。</p>
<h3 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2);"></a>Object.is(value1, value2);</h3><p>定义：判断两个值是否是相同的值。<br>参数：value1为需要比较的第一个值，value2为需要比较的第二个值。<br>返回：表示两个参数是否相同的Boolean 。</p>
<h2 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>下面obj为Object的实例。</p>
<h3 id="obj-hasOwnProperty-prop"><a href="#obj-hasOwnProperty-prop" class="headerlink" title="obj.hasOwnProperty(prop)"></a>obj.hasOwnProperty(prop)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：prop为要检测的属性String或者Symbol。<br>返回：用来判断某个对象是否含有指定的属性的Boolean。</p>
<h3 id="prototypeObj-isPrototypeOf-obj"><a href="#prototypeObj-isPrototypeOf-obj" class="headerlink" title="prototypeObj.isPrototypeOf(obj)"></a>prototypeObj.isPrototypeOf(obj)</h3><p>定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。<br>参数：obj为在该对象的原型链上搜寻。<br>返回：表示调用对象是否在另一个对象的原型链上的Boolean。</p>
<h3 id="obj-propertyIsEnumerable-prop"><a href="#obj-propertyIsEnumerable-prop" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个布尔值，表示指定的属性是否可枚举。<br>参数：prop为需要测试的属性名。<br>返回：用来表示指定的属性名是否可枚举的Boolean。</p>
<h3 id="obj-toLocaleString"><a href="#obj-toLocaleString" class="headerlink" title="obj.toLocaleString()"></a>obj.toLocaleString()</h3><p>定义：方法返回一个该对象的字符串表示。<br>返回：表示对象的字符串。</p>
<h3 id="obj-propertyIsEnumerable-prop-1"><a href="#obj-propertyIsEnumerable-prop-1" class="headerlink" title="obj.propertyIsEnumerable(prop)"></a>obj.propertyIsEnumerable(prop)</h3><p>定义：返回一个表示该对象的字符串。<br>返回：表示该对象的字符串。<br>PS：ES6之前经常这样用Object.prototype.toString.call(obj) === ‘[object Object]’ 来区别Object和Array。</p>
<h3 id="ob-valueOf"><a href="#ob-valueOf" class="headerlink" title="ob.valueOf()"></a>ob.valueOf()</h3><p>定义：返回指定对象的原始值。<br>返回：返回值为该对象的原始值。</p>
<h3 id="object-instanceof-constructor"><a href="#object-instanceof-constructor" class="headerlink" title="object instanceof constructor"></a>object instanceof constructor</h3><p>定义：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>参数：object为要检测的对象，constructor为某个构造函数。<br>返回：boolean值。[2018-03-21]</p>
<blockquote>
<p>   参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">MDN__proto__</a><br><a href="https://www.zhihu.com/question/34183746/answer/58068402" target="_blank" rel="noopener">__proto__和prototype的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">Object</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>品算法图解</title>
    <url>/2018/%E5%93%81%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E6%9C%89%E6%84%9F.html</url>
    <content><![CDATA[<h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><p>数组、链表、散列表、栈、队列、图、树</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组，在内存上必须给出连续的空间（一但内存空间不足时，需要将整个数组移位到另一块内存足够大的地方）。<br>内存空间占用的少，因为链表还要保存下一个节点的内存地址。<br>访问性：访问性好，数组内的数据可随机访问，因为其内存地址时连续的。<br>操作性：操作性差，在数组中插入、删除元素，都会导致其后的元素整体移动（插入时向后移动、删除时向前移动）。<br>扩展性：扩展性差，因为一个数组建立后所占用的空间大小就是固定的（大多数语言时这样的）。<br>大O表示：读取 O(1)，插入 O(n)，删除 O(n)</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表，内存地址上可以是不连续的,每个链表的节点包括当前节点的值和下一个节点的内存地址(单向链表的一个,双向链表的话会有两个)。<br>访问性：访问性差，链表不具备随机访问性，其每次访问都是从头开始访问。<br>操作性：操作性好，只需要操作对应节点之前的内存地址为变更后的节点地址。<br>扩展性：扩展性好，因为其内存不连续，只要还有剩余内存即可。<br>大O表示：读取 O(n)，插入 O(1)，删除 O(1)</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表使用数组来存储数据，通过一个散列函数将其映射到数组不同位置。</p>
<h3 id="避免hash冲突"><a href="#避免hash冲突" class="headerlink" title="避免hash冲突"></a>避免hash冲突</h3><p>较低的填装因子（填装因子=散列表包含的元素数/位置总数）。<br>良好的散列函数。<br>使用数组链表处理冲突。<br>大O表示：平均情况读取、插入、删除都为O(1)，最糟糕情况读取、插入、删除都为O(n)</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>非加权图—广度优先搜索用于查找其最短路径。<br>加权图（权重为正）—狄克斯特拉算法用于查找其最短路径。<br>加权图（权重有负）—贝尔曼-福德算法用于查找其最短路径。</p>
<blockquote>
<p>   参考文档<br><a href="https://blog.csdn.net/u014082714/article/details/44259029/" target="_blank" rel="noopener">数组与链表的优缺点</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常识-gj</title>
    <url>/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj.html</url>
    <content><![CDATA[<h2 id="React-virtualDOM（batching）"><a href="#React-virtualDOM（batching）" class="headerlink" title="React virtualDOM（batching）"></a>React virtualDOM（batching）</h2><p>在React中，render执行的结果返回的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。<br>通过 React 的 diff，再由虚拟 DOM 来确保只对界面上真正变化的部分进行实际的DOM操作，这样就极大提升了性能。<br>batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。</p>
<blockquote>
<p>DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起30次（潜在的）布局重算，30次（潜在的）重绘。<br>当你在这个单独的 virtualDOM 树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。<br>一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/f75c1f0af3f0" target="_blank" rel="noopener">React中一个没人能解释清楚的问题——为什么要使用Virtual DOM</a></p>
<h2 id="React-diff"><a href="#React-diff" class="headerlink" title="React diff"></a>React diff</h2><p>React diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础。<br>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。<br>React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。<br>diff 策略（—为具体比对）<br>1.Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 — tree diff<br>2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 — component diff<br>3.对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 — element diff</p>
<h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%85.jpg" alt="tree-diff"></p>
<h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。<br>1.如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。<br>2.如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。<br>3.对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。<br><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%851.jpg" alt="component diff"></p>
<h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。<br>1.INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。<br>2.MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。<br>3.REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。<br>React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，这也是为什么React建议我们在列表项目中添加key属性的原因！</p>
<p><img src="http://p26lefllv.bkt.clouddn.com/ms_%E5%9B%BD%E9%99%852.jpg" alt="element diff"><br><a href="https://zhuanlan.zhihu.com/purerender/20346379" target="_blank" rel="noopener">知乎专栏-react diff，写的很不错</a></p>
<h2 id="webkit-渲染机制"><a href="#webkit-渲染机制" class="headerlink" title="webkit 渲染机制"></a>webkit 渲染机制</h2><p>先看下简单版的（我们从浏览器地址栏输入网址开始到web页面被完整的呈现在眼前做了哪些事，暂不考虑DNS缓存、本地资源缓存）<br>网址被DNS解析为IP地址 -&gt; 通过IP地址建立TCP连接 -&gt; 发送HTTP请求 -&gt; 服务器处理请求并返回响应 -&gt;  浏览器解析渲染页面 -&gt; 断开TCP连接</p>
<h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>一般渲染引擎主要包括HTML解释器、CSS解释器、Javascript引擎、布局、绘图等模块。<br>HTML解释器 ：HTML解释器的工作就是将网络或者本地磁盘获取到的HTML网页和资源从字节流解释成DOM树的结构（首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（TOKENS），经过语法分析器构建成节点，最后这些节点被组建成一颗DOM树）<br>CSS解释器 ：CSS字符串被CSS解释器处理后变成渲染引擎的内部规则表示。（样式规则建立完成之后，webkit会保存规则结果，当DOM的节点建立之后，webkit会为可视化节点选择合适的样式信息，即作样式规则匹配）<br>Javascript引擎 ：将Javascript代码处理并执行，一个Javascript引擎可以包括以下几个部分<br>　　编译器 -&gt; 主要工作是将源代码编译成抽象语法树，在某些引擎中还包括将抽象语法树转换为字节码（JavascriptCore 引擎）。<br>　　解释器  -&gt; 在某些引擎中，解释器主要是接收字节码，解释执行字节码，同时也依赖垃圾回收机制等。<br>　　JIT工具 -&gt; 将字节码或者抽象语法树转换为本地代码 （V8 引擎）。<br>　　垃圾回收器和分析工具。<br>布局 ：计算RenderObject对象的位置、大小等信息。<br>绘图 ：将构建好的渲染内部表示模型使用图形库绘制出来。<br><img src="http://p26lefllv.bkt.clouddn.com/webkitflow.png" alt="webkit渲染过程"><br><a href="http://www.sohu.com/a/115715208_472885" target="_blank" rel="noopener">WEBKIT渲染不可不知的这四棵树</a><br><a href="https://www.cnblogs.com/tianheila/p/6413586.html" target="_blank" rel="noopener">webkit 渲染机制</a></p>
<h2 id="http1-1-amp-2较1有哪些新东西？"><a href="#http1-1-amp-2较1有哪些新东西？" class="headerlink" title="http1.1&amp;2较1有哪些新东西？"></a>http1.1&amp;2较1有哪些新东西？</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</p>
<h2 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h2><p>1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可<br>2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页<br>3.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br>4.重要内容不要用js输出：爬虫不会执行js获取内容（目前chrome浏览器可以了）<br>5.少用iframe：搜索引擎不会抓取iframe中的内容<br>6.非装饰性图片必须加alt<br>7.提高网站速度：网站速度是搜索引擎排序的一个重要指标</p>
<h2 id="点击穿透"><a href="#点击穿透" class="headerlink" title="点击穿透"></a>点击穿透</h2><p>如何产生：<br>    现在有两层DOM结构（但不嵌套），底层和弹出层（底层在弹出层下面且弹出层的投影在底层内部），弹出层有一个 touchend 事件，底层有一个 click 事件。<br>当点击弹出层就会触发 touchend 事件（弹出层立即消失，这时事件的 target 为弹出层），300ms后触发 click 事件（由于弹出层消失了，这时事件的 target 就为底层了）。<br>看出来了吗？这样就发生了‘点击穿透’。<br>产生的原因：<br>    click事件延迟且弹出层消失了。<br>解决方案：<br>    1.只用touch事件<br>    2.只用click事件（不推荐只用click事件，这样所有点击都有延迟了，实在要使用可以使用事件库 fastclick）<br>    3.可以延迟（&gt;300ms,好像不太科学）弹出层消失<br><a href="http://blog.csdn.net/qq_17746623/article/details/55805425" target="_blank" rel="noopener">点击穿透原理及解决</a></p>
<h2 id="服务器’推‘技术"><a href="#服务器’推‘技术" class="headerlink" title="服务器’推‘技术"></a>服务器’推‘技术</h2><p>webSocket、Comet、轮询<br>Comet主要是利用客户端向服务器发出请求时，服务器发回响应内容，并利用javascript建立一个长时间链接的“长连接”，这个连接在没有接收到服务器或者没有到达连接时间限制时会一直等待服务器的消息，如果服务器有消息传来，立即显示最新信息。长连接每隔一段时间会重新向服务器发出连接请求。服务器在有新消息产生的时候立即检查消息的接收方是否存在长连接，如果存在马上发送，如果没有则不发送。</p>
<h2 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h2><p>1.cookie（一般不能存关键字段，最好存sessionID配合session使用）<br>2.session<br>3.url重写<br>4.隐藏input<br>5.ip地址</p>
<h2 id="img的title和alt有什么区别"><a href="#img的title和alt有什么区别" class="headerlink" title="img的title和alt有什么区别"></a>img的title和alt有什么区别</h2><p>title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。<br>alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p>
<h2 id="doctype是什么-举例常见doctype及特点"><a href="#doctype是什么-举例常见doctype及特点" class="headerlink" title="doctype是什么,举例常见doctype及特点"></a>doctype是什么,举例常见doctype及特点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写</span><br><span class="line">&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</span><br><span class="line">现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</span><br><span class="line">在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</span><br><span class="line">HTML5不基于SGML，所以不用指定DTD</span><br></pre></td></tr></table></figure>
<h3 id="常见dotype"><a href="#常见dotype" class="headerlink" title="常见dotype"></a>常见dotype</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class="line">HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">HTML4.01 Frameset:允许表现性元素，废弃元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br><span class="line">XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</span><br><span class="line">XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</span><br><span class="line">HTML 5: &lt;!doctype html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HTML全局属性-global-attribute-有哪些"><a href="#HTML全局属性-global-attribute-有哪些" class="headerlink" title="HTML全局属性(global attribute)有哪些"></a>HTML全局属性(global attribute)有哪些</h2><p>accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素<br>class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class、classList属性获取元素<br>contenteditable: 指定元素内容是否可编辑<br>contextmenu: 自定义鼠标右键弹出菜单内容<br>data-*: 为元素增加自定义属性<br>dir: 设置元素文本方向<br>draggable: 设置元素是否可拖拽<br>dropzone: 设置元素拖放类型： copy, move, link<br>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果<br>id: 元素id，文档内唯一<br>lang: 元素内容的的语言<br>spellcheck: 是否启动拼写和语法检查<br>style: 行内css样式<br>tabindex: 设置元素可以获得焦点，通过tab可以导航<br>title: 元素相关的建议信息<br>translate: 元素和子孙节点内容是否需要本地化</p>
<h2 id="什么是web语义化-有什么好处"><a href="#什么是web语义化-有什么好处" class="headerlink" title="什么是web语义化,有什么好处"></a>什么是web语义化,有什么好处</h2><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。<br>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构<br>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息<br>为什么需要语义化：<br>1.去掉样式后页面呈现清晰的结构<br>2.搜索引擎更好地理解页面，有利于收录<br>3.便团队项目的可持续运作及维护<br>5.盲人使用读屏器更好地阅读</p>
<h2 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。<br>GET是最常用的方法，通常用于请求服务器发送某个资源。<br>HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分<br>PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它<br>POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。<br>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。<br>OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。<br>DELETE请求服务器删除请求URL指定的资源。</p>
<h2 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h2><p>首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF<br>首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束<br>请求头和消息实体之间有一个CRLF分隔<br>根据实际请求需要可能包含一个消息实体<br>一个请求报文例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</span><br><span class="line">Host: www.w3.org</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</span><br><span class="line">Referer: https://www.google.com.hk/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">Cookie: authorstyle=yes</span><br><span class="line">If-None-Match: &quot;2cc8-3e3073913b100&quot;</span><br><span class="line">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class="line"></span><br><span class="line">name=fanerge&amp;age=26</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h2><p>首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF<br>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部<br>响应头部和响应实体之间用一个CRLF空行分隔<br>最后是一个可能的消息实体<br>响应报文例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 08 Jul 2014 05:28:43 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class="line">ETag: &quot;40d7-3e3073913b100&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 16599</span><br><span class="line">Cache-Control: max-age=21600</span><br><span class="line">Expires: Tue, 08 Jul 2014 11:28:43 GMT</span><br><span class="line">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</span><br><span class="line">Content-Type: text/html; charset=iso-8859-1</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><h3 id="content方面"><a href="#content方面" class="headerlink" title="content方面"></a>content方面</h3><p>减少HTTP请求：合并文件、CSS精灵、inline Image<br>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br>避免重定向：多余的中间访问<br>使Ajax可缓存<br>非必须组件延迟加载<br>未来所需组件预加载<br>减少DOM元素数量<br>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br>减少iframe数量<br>不要404</p>
<h3 id="Server方面"><a href="#Server方面" class="headerlink" title="Server方面"></a>Server方面</h3><p>使用CDN<br>添加Expires或者Cache-Control响应头<br>对组件使用Gzip压缩<br>配置ETag<br>Flush Buffer Early<br>Ajax使用GET进行请求<br>避免空src的img标签</p>
<h3 id="Cookie方面"><a href="#Cookie方面" class="headerlink" title="Cookie方面"></a>Cookie方面</h3><p>减小cookie大小<br>引入资源的域名不要包含cookie</p>
<h3 id="css方面"><a href="#css方面" class="headerlink" title="css方面"></a>css方面</h3><p>将样式表放到页面顶部<br>不使用CSS表达式<br>使用不使用@import<br>不使用IE的Filter</p>
<h3 id="Javascript方面"><a href="#Javascript方面" class="headerlink" title="Javascript方面"></a>Javascript方面</h3><p>将脚本放到页面底部<br>将javascript和css从外部引入<br>压缩javascript和css<br>删除不需要的脚本<br>减少DOM访问<br>合理设计事件监听器</p>
<h3 id="图片方面"><a href="#图片方面" class="headerlink" title="图片方面"></a>图片方面</h3><p>优化图片：根据实际颜色需要选择色深、压缩<br>优化css精灵<br>不要在HTML中拉伸图片<br>保证favicon.ico小并且可缓存</p>
<h3 id="移动方面"><a href="#移动方面" class="headerlink" title="移动方面"></a>移动方面</h3><p>保证组件小于25k<br>Pack Components into a Multipart Document<br><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">yahoo Best Practices for Speeding Up Your Web Site</a></p>
<h2 id="什么是渐进增强"><a href="#什么是渐进增强" class="headerlink" title="什么是渐进增强"></a>什么是渐进增强</h2><p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。<br>核心原则如下:<br>所有浏览器都必须能访问基本内容<br>所有浏览器都必须能使用基本功能<br>所有内容都包含在语义化标签中<br>通过外部CSS提供增强的布局<br>通过非侵入式、外部javascript提供增强功能<br>end-user web browser preferences are respected</p>
<h2 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h2><p>1XX：信息状态码<br>100 Continue：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求之后向客户端发送一个最终响应。<br>101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。<br>2XX：成功状态码<br>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回<br>201 Created：<br>202 Accepted：<br>203 Non-Authoritative Information：<br>204 No Content：<br>205 Reset Content：<br>206 Partial Content：<br>3XX：重定向<br>300 Multiple Choices：<br>301 Moved Permanently：<br>302 Found：<br>303 See Other：<br>304 Not Modified：<br>305 Use Proxy：<br>306 （unused）：<br>307 Temporary Redirect：<br>4XX：客户端错误<br>400 Bad Request:<br>401 Unauthorized:<br>402 Payment Required:<br>403 Forbidden:<br>404 Not Found:<br>405 Method Not Allowed:<br>406 Not Acceptable:<br>407 Proxy Authentication Required:<br>408 Request Timeout:<br>409 Conflict:<br>410 Gone:<br>411 Length Required:<br>412 Precondition Failed:<br>413 Request Entity Too Large:<br>414 Request-URI Too Long:<br>415 Unsupported Media Type:<br>416 Requested Range Not Satisfiable:<br>417 Expectation Failed:<br>5XX: 服务器错误<br>500 Internal Server Error:<br>501 Not Implemented:<br>502 Bad Gateway:<br>503 Service Unavailable:<br>504 Gateway Timeout:<br>505 HTTP Version Not Supported:</p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端话题</title>
    <url>/2018/%E5%89%8D%E7%AB%AF%E8%AF%9D%E9%A2%98.html</url>
    <content><![CDATA[<p>记录一些比较有意思的话题。</p>
<h1 id="new操作符的工作原理"><a href="#new操作符的工作原理" class="headerlink" title="new操作符的工作原理"></a>new操作符的工作原理</h1><p>我们都知道 new 运算符是用来实例化一个类，从而在内存中分配一个实例对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Person = function(name, age)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = function()&#123;</span><br><span class="line">	return this.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：这里我先说明一下直接执行 Person 会返回 undefined，new Person(…) 会返回一个对象（即我们的this对象）。</p>
<h2 id="调用构造函数实际上会经历以下4个步骤"><a href="#调用构造函数实际上会经历以下4个步骤" class="headerlink" title="调用构造函数实际上会经历以下4个步骤"></a>调用构造函数实际上会经历以下4个步骤</h2><p>(1) 创建一个新对象<br>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象即类的实例）<br>(3) 执行构造函数中的代码（即为这个新对象添加属性）<br>(4) 返回新对象<br><a href="https://www.jb51.net/article/137370.htm" target="_blank" rel="noopener">如果不明白，请看前辈整理的文章</a></p>
<h1 id="JavaScript内部属性-Scope-与作用域链的理解"><a href="#JavaScript内部属性-Scope-与作用域链的理解" class="headerlink" title="JavaScript内部属性[[Scope]]与作用域链的理解"></a>JavaScript内部属性[[Scope]]与作用域链的理解</h1><h2 id="Scope-属性"><a href="#Scope-属性" class="headerlink" title="[[Scope]]属性"></a>[[Scope]]属性</h2><p>每一个 function 声明时都会有一个内部属性 [[Scope]]，例如声明 foo 函数会创建一个 foo.[[Scope]] 属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// 当我们的 foo 函数创建时，它的作用域链中插入了一个全局对象GO（Global Object），包含全局所有定义的变量</span><br><span class="line">// 伪代码</span><br><span class="line">foo.[[Scope]] = &#123;</span><br><span class="line">    GO: &#123;</span><br><span class="line">        this: window ,</span><br><span class="line">        window: ... ,</span><br><span class="line">        document: ... ,</span><br><span class="line">        ......</span><br><span class="line">        a: undefined, // 预编译阶段还不知道a值是多少</span><br><span class="line">        foo: function()&#123;...&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>在函数执行时，会创建一个叫做执行环境/执行上下文（execution context，下文均用EC表示）的内部对象（独一无二）。</p>
<h3 id="执行环境有以下特点"><a href="#执行环境有以下特点" class="headerlink" title="执行环境有以下特点"></a>执行环境有以下特点</h3><p>函数每次执行时的执行环境独一无二<br>多次调用同一函数就多次创建执行环境<br>并且函数执行完毕后，执行环境就会被销毁<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// foo函数执行前，创建了执行期上下文（EC）</span><br><span class="line">// 首先取得foo内部[[Scope]]属性保存的作用域链（复制）到 EC 的底部</span><br><span class="line">// 然后foo函数执行前预编译产生了一个活动对象AO（Active Object），这个对象被推入EC作用域链的最前端</span><br><span class="line">// 伪代码：foo函数预编译产生AO活动对象，挂载到foo中EC作用域链的最前端</span><br><span class="line">foo.EC = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        this: window,</span><br><span class="line">        arguments: [100,200],</span><br><span class="line">        x: 100,</span><br><span class="line">        y: 200,</span><br><span class="line">        b: undefined,</span><br><span class="line">        bar: function()&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GO: &#123;</span><br><span class="line">        this: window ,</span><br><span class="line">        window: ... ,</span><br><span class="line">        document: ... ,</span><br><span class="line">        a: 1,</span><br><span class="line">        foo: function()&#123;...&#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="案列分析"><a href="#案列分析" class="headerlink" title="案列分析"></a>案列分析</h2><p>这里我们来看一个稍微复杂一点的场景<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function foo(x, y)&#123;</span><br><span class="line">    var b = 2;</span><br><span class="line">    function bar()&#123;</span><br><span class="line">        var c = 3;</span><br><span class="line">		// console.log(a); </span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo(100, 200);</span><br></pre></td></tr></table></figure></p>
<p>foo函数在预编译阶段创建了bar函数，于是bar函数创建了属性[[Scope]]，包含bar被创建的作用域中对象的集合，也就是复制了foo.EC<br>所以我们可以得到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 伪代码：bar函数创建产生[[Scope]]对象</span><br><span class="line">// bar.[[Scope]] = foo.EC</span><br><span class="line">bar.[[Scope]] = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        this: window,</span><br><span class="line">        arguments: [100,200],</span><br><span class="line">        x: 100,</span><br><span class="line">        y: 200,</span><br><span class="line">        b: undefined,</span><br><span class="line">        bar: function()&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GO: &#123;</span><br><span class="line">        this: window ,</span><br><span class="line">        window: ... ,</span><br><span class="line">        document: ... ,</span><br><span class="line">        a: 1, </span><br><span class="line">        foo: function()&#123;...&#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：由于bar函数是在foo函数执行时创建的，所以bar[[Scope]]=foo.EC<br>bar函数执行，过程同foo函数执行相近，整理出 bar.EC<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar.EC = &#123;</span><br><span class="line">	AO: &#123; // bar 产生的 AO</span><br><span class="line">        this: window,</span><br><span class="line">        arguments: [],</span><br><span class="line">        c: undefined,</span><br><span class="line">    &#125;,</span><br><span class="line">    AO: &#123; // foo 产生的 EC</span><br><span class="line">        this: window,</span><br><span class="line">        arguments: [100,200],</span><br><span class="line">        x: 100,</span><br><span class="line">        y: 200,</span><br><span class="line">        b: 2,</span><br><span class="line">        bar: function()&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GO: &#123; // foo 的 [[Scope]]</span><br><span class="line">        this: window ,</span><br><span class="line">        window: ... ,</span><br><span class="line">        document: ... ,</span><br><span class="line">        a: 1,</span><br><span class="line">        foo: function()&#123;...&#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>js引擎就是通过作用域链的规则来进行变量查找（准确的说应该是执行上下文的作用域链）<br>查找过程就拿上面的代码来说，比如说我在bar函数执行console.log(a);<br>那么bar函数执行时，js引擎想要打印a，于是就去作用域链上查找<br>第一层AO没有（bar运行时产生的）<br>第二层AO没有（foo运行时产生的）<br>第三层GO找到了变量a （foo定义是a为undefined，预编译时a被赋值为1）<br>于是返回了变量a的值<br>如果在bar函数中在创建一个der函数，der的EC又会是怎么样呢？读者自行脑补吧（大体思路类似）<br>[<a href="https://blog.csdn.net/q1056843325/article/details/53086893?locationNum=12&amp;fps=1" target="_blank" rel="noopener">[Scope]]与作用域链</a></p>
<h1 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h1><h2 id="四种组合关系"><a href="#四种组合关系" class="headerlink" title="四种组合关系"></a>四种组合关系</h2><h3 id="lt-script-src-quot-script-js-quot-gt-lt-script-gt"><a href="#lt-script-src-quot-script-js-quot-gt-lt-script-gt" class="headerlink" title="&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;"></a><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></h3><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
<h3 id="lt-script-async-src-quot-script-js-quot-gt-lt-script-gt"><a href="#lt-script-async-src-quot-script-js-quot-gt-lt-script-gt" class="headerlink" title="&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;"></a><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></h3><p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载并行进行，且并立即执行。</p>
<h3 id="lt-script-defer-src-quot-script-js-quot-gt-lt-script-gt"><a href="#lt-script-defer-src-quot-script-js-quot-gt-lt-script-gt" class="headerlink" title="&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;"></a><code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></h3><p>有 defer，加载和渲染后续文档元素的过程将和 script.js 的加载并行进行，但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<h3 id="lt-script-defer-async-src-quot-script-js-quot-gt-lt-script-gt"><a href="#lt-script-defer-async-src-quot-script-js-quot-gt-lt-script-gt" class="headerlink" title="&lt;script defer async src=&quot;script.js&quot;&gt;&lt;/script&gt;"></a><code>&lt;script defer async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></h3><p>同时存在时，async生效。</p>
<h2 id="defer和async-共同点"><a href="#defer和async-共同点" class="headerlink" title="defer和async 共同点"></a>defer和async 共同点</h2><p>defer 和 async 在内联脚本无作用。<br>在下载时和与HTML解析异步的，执行时阻塞HTML解析（包括没有defer 和 async属性的场景）。</p>
<h2 id="defer和async的区别"><a href="#defer和async的区别" class="headerlink" title="defer和async的区别"></a>defer和async的区别</h2><p>async异步下载后立即执行（可能不按下载顺序执行，适用于无任何依赖的脚本）。<br>defer异步下载后等文档完成解析后，触发 DOMContentLoaded 事件前执行（安下载顺序执行，适用于有依赖关系的脚本）。<br>PS：CSS并行下载，JS串行下载，相对于HTML解析来说。<br><a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener">defer和async的区别</a></p>
<h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><h2 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h2><p>可以添加至主屏幕<br>实现离线缓存功能<br>实现了消息推送</p>
<h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><p>App Manifest<br>Service Worker<br>Push &amp;&amp; Notification（push: server 将更新的信息传递给 SW notification: SW 将更新的信息推送给用户）<br><a href="https://segmentfault.com/a/1190000012353473" target="_blank" rel="noopener">讲讲PWA</a></p>
<h1 id="jsEvent-Loop机制"><a href="#jsEvent-Loop机制" class="headerlink" title="jsEvent Loop机制"></a>jsEvent Loop机制</h1><p>在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。</p>
<h2 id="MicroTask"><a href="#MicroTask" class="headerlink" title="MicroTask"></a>MicroTask</h2><p>process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver</p>
<h2 id="MacroTask"><a href="#MacroTask" class="headerlink" title="MacroTask"></a>MacroTask</h2><p>script(同步代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>script(同步代码) -&gt; MicroTask -&gt; MacroTask<br>在执行上面代码时有产生了一些 MicroTask 和 MacroTask 会挂起，在一下次Event Loop再触发，以此类推。<br><a href="https://fanerge.github.io/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html#Event-Loop%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%EF%BC%89">可以看看我之前的博客</a></p>
<h1 id="通用-curry-实现"><a href="#通用-curry-实现" class="headerlink" title="通用 curry 实现"></a>通用 curry 实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//柯里函数实质：传递给函数一部分参数来调用它，让它返回一个函数来处理剩余参数</span><br><span class="line">function curry(fx) &#123;</span><br><span class="line">    //要进行柯里化的函数的形参数量</span><br><span class="line">    let arity = fx.length;</span><br><span class="line">	</span><br><span class="line">    return function f1() &#123;</span><br><span class="line">        //第一次传入的参数数量</span><br><span class="line">        let args = Array.from(arguments);</span><br><span class="line">        //若传入的参数数量大于等于形参数量</span><br><span class="line">        if (args.length &gt;= arity) &#123;</span><br><span class="line">            return fx.apply(null,args)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let f2 = function() &#123;</span><br><span class="line">                //如果只传入了一部分参数</span><br><span class="line">                let args2 = Array.from(arguments)</span><br><span class="line">                //判断是否所有参数都传完了，如果没有，不断concat新传的参数，然后执行f1函数</span><br><span class="line">                return f1.apply(null, args.concat(args2))</span><br><span class="line">            &#125;</span><br><span class="line">            return f2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">let add = (num1, num2, num3)=&gt; num1 + num2 + num3;</span><br><span class="line">console.log(curry(add)(1)(2)(3)) // 6</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000012135934" target="_blank" rel="noopener">curry实现</a></p>
<h1 id="通用的-compose-的实现"><a href="#通用的-compose-的实现" class="headerlink" title="通用的 compose 的实现"></a>通用的 compose 的实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let compose = function(...args) &#123;</span><br><span class="line">	var len = args.length,</span><br><span class="line">		count = len - 1,</span><br><span class="line">		result;</span><br><span class="line">		</span><br><span class="line">	return function f1(...args1) &#123;</span><br><span class="line">		result = args[count].apply(this, args1);</span><br><span class="line">		if (count &lt;= 0) &#123;</span><br><span class="line">			count = len - 1;</span><br><span class="line">			return result;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			count--;</span><br><span class="line">			return f1.call(null, result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000008394749" target="_blank" rel="noopener">关于javascript函数式编程中compose的实现</a></p>
<blockquote>
<p>   参考文档：<br><a href="https://www.jb51.net/article/137370.htm" target="_blank" rel="noopener">详解Javascript中new()到底做了些什么？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常识-gj2</title>
    <url>/2018/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj2.html</url>
    <content><![CDATA[<h1 id="从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h1><ol>
<li>在浏览器地址栏输入URL</li>
<li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control<br>  HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期<br>  HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间    </li>
<li>浏览器解析URL获取协议，主机，端口，path    </li>
<li>浏览器组装一个HTTP（GET）请求报文    </li>
<li>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存<br>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
<li>打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z</li>
<li>TCP链接建立后发送HTTP请求    </li>
<li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序    </li>
<li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码    </li>
<li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作    </li>
<li>服务器将响应报文通过TCP连接发送回浏览器    </li>
<li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</li>
<li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同    </li>
<li>如果资源可缓存，进行缓存    </li>
<li>对响应进行解码（例如gzip压缩）    </li>
<li>根据资源类型决定如何处理（假设资源为HTML文档）    </li>
<li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释    </li>
<li>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树    </li>
<li>解析过程中遇到图片、样式表、js文件，启动下载    </li>
<li>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</li>
<li>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式</li>
<li>js解析如下：<br>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading<br>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素<br>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</li>
<li>显示页面（HTML解析过程中会逐步显示页面）<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="CSS选择器有哪些"><a href="#CSS选择器有哪些" class="headerlink" title="CSS选择器有哪些"></a>CSS选择器有哪些</h2></li>
</ol>
<ul>
<li>通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+<br>#X id选择器：选择id值为X的元素，兼容性：IE6+<br>.X 类选择器： 选择class包含X的元素，兼容性：IE6+<br>X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+<br>X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+<br>:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+<br>X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+<br>X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+<br>X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+<br>[attr]：选择所有设置了attr属性的元素，兼容性IE7+<br>[attr=value]：选择属性值刚好为value的元素<br>[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素<br>[attr|=value]：选择属性值刚好为value或者value-开头的元素<br>[attr^=value]：选择属性值以value开头的元素<br>[attr$=value]：选择属性值以value结尾的元素<br>[attribute*=value]：选择属性值中包含value的元素<br>X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+<br>:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+<br>:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+<br>::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+<br>::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+<br>:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+<br>:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+<br>X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+<br>X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+<br>X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+<br>X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+<br>X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+<br>X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+<br>X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+<h2 id="css-sprite是什么-有什么优缺点"><a href="#css-sprite是什么-有什么优缺点" class="headerlink" title="css sprite是什么,有什么优缺点"></a>css sprite是什么,有什么优缺点</h2>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。<br>优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br>缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要从新布局整个图片，样式<h2 id="display-none-与visibility-hidden-的区别"><a href="#display-none-与visibility-hidden-的区别" class="headerlink" title="display: none;与visibility: hidden;的区别"></a>display: none;与visibility: hidden;的区别</h2>相同点：它们都能让元素不可见<br>区别：<br>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见<br>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式<br>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。<br>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容<h2 id="specified-value-computed-value-used-value计算方法"><a href="#specified-value-computed-value-used-value计算方法" class="headerlink" title="specified value,computed value,used value计算方法"></a>specified value,computed value,used value计算方法</h2>specified value: 计算方法如下：<br>  如果样式表设置了一个值，使用这个值<br>  如果没有设置值，这个属性是继承属性，从父元素继承<br>  如果没设置，并且不是继承属性，使用css规范指定的初始值及浏览器初始值<br>computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承<br>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局，<br>  background-position<br>  bottom, left, right, top<br>  height, width<br>  margin-bottom, margin-left, margin-right, margin-top<br>  min-height, min-width<br>  padding-bottom, padding-left, padding-right, padding-top<br>  text-indent<h2 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h2>  link是HTML方式， @import是CSS方式<br>  link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC无样式内容闪烁(Flash Of Unstyled Content)<br>  link可以通过rel=”alternate stylesheet”指定候选样式<br>  浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br>  @import必须在样式规则之前，可以在css文件中引用其他文件<br>  总体来说：link优于@import<h2 id="display-block-和display-inline-的区别"><a href="#display-block-和display-inline-的区别" class="headerlink" title="display: block;和display: inline;的区别"></a>display: block;和display: inline;的区别</h2>block元素特点：<br>  1.处于常规流中时，如果width没有设置，会自动填充满父容器<br>  2.可以应用margin/padding<br>  3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素<br>  4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）<br>  5.忽略vertical-align<br>inline元素特点<br>  1.水平方向上根据direction依次布局<br>  2.不会在元素前后进行换行<br>  3.受white-space控制<br>  4.margin/padding在竖直方向上无效，水平方向上有效<br>  5.width/height属性对非替换行内元素无效，宽度由元素内容决定<br>  6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定<br>  6.浮动或绝对定位时会转换为block<br>  7.vertical-align属性生效<h2 id="PNG-GIF-JPG-webp-svg的区别及如何选"><a href="#PNG-GIF-JPG-webp-svg的区别及如何选" class="headerlink" title="PNG,GIF,JPG,webp,svg的区别及如何选"></a>PNG,GIF,JPG,webp,svg的区别及如何选</h2>GIF:<br>  8位像素，256色<br>  无损压缩<br>  支持简单动画<br>  支持boolean透明<br>  适合简单动画<br>JPEG：<br>  颜色限于256<br>  有损压缩<br>  可控制压缩质量<br>  不支持透明<br>  适合照片<br>PNG：<br>  有PNG8和truecolor PNG<br>  PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画<br>  适合图标、背景、按钮<br>未来趋势：<br>  webp（google推出的图片格式，目前存在浏览器兼容）<br>  svg（矢量图如：iconfont）<h2 id="CSS有哪些继承属性"><a href="#CSS有哪些继承属性" class="headerlink" title="CSS有哪些继承属性"></a>CSS有哪些继承属性</h2>关于文字排版的属性如：<br>  font<br>  word-break<br>  letter-spacing<br>  text-align<br>  text-rendering<br>  word-spacing<br>  white-space<br>  text-indent<br>  text-transform<br>  text-shadow<br>line-height<br>color<br>visibility<br>cursor<h2 id="容器包含若干浮动元素时如何清理-包含-浮动"><a href="#容器包含若干浮动元素时如何清理-包含-浮动" class="headerlink" title="容器包含若干浮动元素时如何清理(包含)浮动"></a>容器包含若干浮动元素时如何清理(包含)浮动</h2>容器元素闭合标签前添加额外元素并设置clear: both<br>父元素触发块级格式化上下文(见块级可视化上下文部分)<br>设置容器元素伪元素进行清理推荐的清理浮动方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在标准浏览器下使用</span><br><span class="line">* 1 content内容为空格用于修复opera下文档中出现</span><br><span class="line">*   contenteditable属性时在清理浮动元素上下的空白</span><br><span class="line">* 2 使用display使用table而不是block：可以防止容器和</span><br><span class="line">*   子元素margin-top折叠,这样能使清理效果与BFC，IE6/7</span><br><span class="line">*   zoom: 1;一致</span><br><span class="line">* 3 overflow: hidden;</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &quot; &quot;; /* 1 */</span><br><span class="line">    display: table; /* 2 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* IE 6/7下使用</span><br><span class="line">* 通过触发hasLayout实现包含浮动</span><br><span class="line">**/</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="什么是FOUC-如何避免"><a href="#什么是FOUC-如何避免" class="headerlink" title="什么是FOUC?如何避免"></a>什么是FOUC?如何避免</h2><p>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head使用link元素。</p>
<h2 id="什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用"><a href="#什么是BFC？如何创建块级格式化上下文-block-formatting-context-BFC有什么用" class="headerlink" title="什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用"></a>什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于布局中的普通流。<br>创建规则：<br>    根元素<br>    浮动元素（float不是none）<br>    绝对定位元素（position取值为absolute或fixed）<br>    display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素<br>    overflow不是visible的元素<br>作用：<br>    可以包含浮动元素（父布局overflow: hidden）<br>    不被浮动元素覆盖（两列自适应布局：子1浮动，子2不浮动且有overflow: hidden）<br>    阻止父子元素的margin折叠（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中）<br><img src="https://zhuanlan.zhihu.com/p/25321647" alt="https://zhuanlan.zhihu.com/p/25321647"></p>
<h2 id="display-float-position的关系"><a href="#display-float-position的关系" class="headerlink" title="display,float,position的关系"></a>display,float,position的关系</h2><p>如果display为none，那么position和float都不起作用，这种情况下元素不产生框<br>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。<br>否则，如果float不是none，框是浮动的，display根据下表进行调整<br>否则，如果元素是根元素，display根据下表进行调整<br>其他情况下display的值为指定值<br>总结起来：绝对定位、浮动、根元素都需要调整display</p>
<h2 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h2><p>毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下：<br>1.两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠<br>2.浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠<br>3.创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠<br>4.元素自身的margin-bottom和margin-top相邻时也会折叠</p>
<h2 id="如何确定一个元素的包含块-containing-block"><a href="#如何确定一个元素的包含块-containing-block" class="headerlink" title="如何确定一个元素的包含块(containing block)"></a>如何确定一个元素的包含块(containing block)</h2><p>1.根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。<br>2.position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成。<br>3.如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area<br>4.如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下：<br>    如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element.<br>    其他情况下包含块由祖先节点的padding edge组成<br>如果找不到定位的祖先元素，包含块为初始包含块</p>
<h2 id="stacking-context-布局规则"><a href="#stacking-context-布局规则" class="headerlink" title="stacking context,布局规则"></a>stacking context,布局规则</h2><p>z轴上的默认层叠顺序如下（从下到上）：<br>    根元素的边界和背景<br>    常规流中的元素按照html中顺序<br>    浮动块<br>    positioned元素按照html中出现顺序<br>如何创建stacking context：<br>    根元素<br>    z-index不为auto的定位元素<br>    a flex item with a z-index value other than ‘auto’<br>    opacity小于1的元素<br>    在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context</p>
<h2 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h2><p>如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现<br>如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。<br>如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1<br>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto</p>
<h2 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h2><p>需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height<br><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="noopener">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术</a><br><a href="http://vanseodesign.com/css/vertical-centering/" target="_blank" rel="noopener">6 Methods For Vertical Centering With CSS</a></p>
<h1 id="JavaScript概念部分"><a href="#JavaScript概念部分" class="headerlink" title="JavaScript概念部分"></a>JavaScript概念部分</h1><h2 id="DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系"><a href="#DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系" class="headerlink" title="DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系"></a>DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</h2><p>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性<br>e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问<br>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）<br>e.propName返回值可能是字符串、布尔值、对象、undefined等<br>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性<br>一些布尔属性’<input hidden>‘的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property<br>像’<a href="../index.html">link</a>‘中href属性，转换成property的时候需要通过转换得到完整URL<br>一些attribute和property不是一一对应如：form控件中’input value=”hello”‘对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</p>
<h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h2><p>offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同<br>clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸</p>
<h2 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h2><p>1.readyState:表示请求状态的整数，取值：<br>    UNSENT（0）：对象已创建<br>    OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求<br>    HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到<br>    LOADING(3)：响应体正在接收<br>    DONE(4)：数据传输完成或者传输产生错误<br>2.onreadystatechange：readyState改变时调用的函数<br>3.status：服务器返回的HTTP状态码（如，200， 404）<br>4.statusText:服务器返回的HTTP状态信息（如，OK，No Content）<br>5.responseText:作为字符串形式的来自服务器的完整响应<br>6.responseXML: Document对象，表示服务器的响应解析成的XML文档<br>7.abort():取消异步HTTP请求<br>8.getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行<br>9.getResponseHeader(headerName):返回headName对应的报头值<br>10.open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证<br>11.setRequestHeader(name, value):设置HTTP报头<br>12.send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</p>
<h2 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h2><p>mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持<br>mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能<br>标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素</p>
<h2 id="sessionStorage-localStorage-cookie区别"><a href="#sessionStorage-localStorage-cookie区别" class="headerlink" title="sessionStorage,localStorage,cookie区别"></a>sessionStorage,localStorage,cookie区别</h2><p>都会在浏览器端保存，有大小限制，同源限制<br>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器<br>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie<br>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除<br>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享<br>localStorage的修改会促发其他文档窗口的update事件<br>cookie有secure属性要求HTTPS传输<br>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</p>
<h2 id="javascript跨域通信"><a href="#javascript跨域通信" class="headerlink" title="javascript跨域通信"></a>javascript跨域通信</h2><p>同源：两个文档同源需满足<br>    协议相同<br>    域名相同<br>    端口相同<br>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法<br>如果是log之类的简单单项通信，新建img,script,link,iframe元素，通过src，href属性设置为目标url。实现跨域请求<br>如果请求json数据，使用script进行jsonp请求<br>现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用<br>内部服务器代理请求跨域url，然后返回数据<br>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源</p>
<h2 id="javascript有哪几种数据类型"><a href="#javascript有哪几种数据类型" class="headerlink" title="javascript有哪几种数据类型"></a>javascript有哪几种数据类型</h2><p>六种基本数据类型<br>    undefined<br>    null<br>    string<br>    boolean<br>    number<br>    symbol(ES6)<br>一种引用类型<br>    Object</p>
<h2 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h2><p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：<br>    函数本身作用域。<br>    闭包定义时的作用域。<br>    全局作用域。<br>闭包常见用途：<br>    创建特权方法用于访问控制<br>    事件处理程序及回调</p>
<h2 id="javascript有哪几种方法定义函数"><a href="#javascript有哪几种方法定义函数" class="headerlink" title="javascript有哪几种方法定义函数"></a>javascript有哪几种方法定义函数</h2><p>函数声明表达式<br>function操作符<br>Function 构造函数<br>ES6:arrow function</p>
<h2 id="应用程序存储和离线web应用"><a href="#应用程序存储和离线web应用" class="headerlink" title="应用程序存储和离线web应用"></a>应用程序存储和离线web应用</h2><p>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:’<html manifest="myapp.appcache">‘，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">myapp.html</span><br><span class="line">myapp.css</span><br><span class="line">myapp.js</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">videos/ offline_help.html</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">cgi/</span><br></pre></td></tr></table></figure></html></p>
<h2 id="客户端存储localStorage和sessionStorage"><a href="#客户端存储localStorage和sessionStorage" class="headerlink" title="客户端存储localStorage和sessionStorage"></a>客户端存储localStorage和sessionStorage</h2><p>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前<br>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。<br>Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key</p>
<h2 id="cookie及其操作"><a href="#cookie及其操作" class="headerlink" title="cookie及其操作"></a>cookie及其操作</h2><p>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。<br>通过读写cookie检测是否支持<br>cookie属性有name，value，max-age，path, domain，secure；<br>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期<br>cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问<br>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下<br>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</p>
<h2 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h2><p>对象字面量： var obj = {};<br>构造函数： var obj = new Object();<br>Object.create(): var obj = Object.create(Object.prototype); // Object.create(proto[, propertiesObject])</p>
<h2 id="运算符判断相等的流程是怎样的"><a href="#运算符判断相等的流程是怎样的" class="headerlink" title="===运算符判断相等的流程是怎样的"></a>===运算符判断相等的流程是怎样的</h2><p>如果两个值不是相同类型，它们不相等<br>如果两个值都是null或者都是undefined，它们相等<br>如果两个值都是布尔类型true或者都是false，它们相等<br>如果其中有一个是NaN，它们不相等<br>如果都是数值型并且数值相等，他们相等， -0等于0<br>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同和=都认为他们不相等<br>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</p>
<h2 id="运算符判断相等的流程是怎样的-1"><a href="#运算符判断相等的流程是怎样的-1" class="headerlink" title="==运算符判断相等的流程是怎样的"></a>==运算符判断相等的流程是怎样的</h2><p>如果两个值类型相同，按照===比较方法进行比较<br>如果类型不同，使用如下规则进行比较<br>如果其中一个值是null，另一个是undefined，它们相等<br>如果一个值是数字另一个是字符串，将字符串转换为数字进行比较<br>如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较<br>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较<br>其他所有情况都认为不相等</p>
<h2 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h2><p>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果<br>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果<br>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</p>
<h2 id="对象到数字的转换步骤"><a href="#对象到数字的转换步骤" class="headerlink" title="对象到数字的转换步骤"></a>对象到数字的转换步骤</h2><ol>
<li>如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果</li>
<li>否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果</li>
<li>否则，throws a TypeError<h2 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;,&gt;,&lt;=,&gt;=的比较规则"></a>&lt;,&gt;,&lt;=,&gt;=的比较规则</h2>所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:<br>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错<br>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）<br>否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较<h2 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h2>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象<br>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参<br>arguments.length为实参的个数（Function.length表示形参长度）<br>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化<br>arguments.caller为调用当前函数的函数（已被遗弃）<br>转换为数组：var args = Array.prototype.slice.call(arguments, 0);    <h2 id="列举数组相关的常用方法"><a href="#列举数组相关的常用方法" class="headerlink" title="列举数组相关的常用方法"></a>列举数组相关的常用方法</h2>参考答案: push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter<h2 id="列举字符串相关的常用方法"><a href="#列举字符串相关的常用方法" class="headerlink" title="列举字符串相关的常用方法"></a>列举字符串相关的常用方法</h2>参考答案: indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase<h2 id="请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”"><a href="#请用代码写出-今天是星期x-其中x表示当天是星期几-如果当天是星期一-输出应该是”今天是星期一”" class="headerlink" title="请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”"></a>请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];</span><br><span class="line">var date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(&apos;今天是星期&apos; + days[date.getDay()]);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="js里的作用域是什么样子的？"><a href="#js里的作用域是什么样子的？" class="headerlink" title="js里的作用域是什么样子的？"></a>js里的作用域是什么样子的？</h2><p>参考答案：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined.</p>
<pre><code>var globalVar = &apos;global var&apos;;

function test() {
alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义
var globalVar = &apos;overrided var&apos;; //　globalVar在本函数内被重定义
alert(globalVar);　// overrided var
}
alert(globalVar); // global var，使用全局变量
</code></pre><h2 id="js里边的this指的是什么"><a href="#js里边的this指的是什么" class="headerlink" title="js里边的this指的是什么?"></a>js里边的this指的是什么?</h2><p>参考答案: this指的是对象本身，而不是构造函数．    </p>
<h2 id="apply-call和bind有什么区别"><a href="#apply-call和bind有什么区别" class="headerlink" title="apply, call和bind有什么区别?"></a>apply, call和bind有什么区别?</h2><p>参考答案：三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，    </p>
<h2 id="caller-callee和arguments分别是什么"><a href="#caller-callee和arguments分别是什么" class="headerlink" title="caller, callee和arguments分别是什么?"></a>caller, callee和arguments分别是什么?</h2><p>参考答案: caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．    </p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>如何形成一个完整的HTML对象</title>
    <url>/2018/%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84HTML%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<p>写在前面，本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="noopener">个人技术博客项目</a>给个star哦。</p>
<h1 id="为何写这篇文章？"><a href="#为何写这篇文章？" class="headerlink" title="为何写这篇文章？"></a>为何写这篇文章？</h1><p>你可能做Web开发已经有一段时间，你是否有想过下列问题呢？<br>为什么div元素甚至是所有的html元素都可以使用addEventListener来添加事件呢？<br>为什么每个DOM节点都有parentNode、firstChild、nodeType等属性呢？<br>为什么每个DOM元素都有className、classList、innerHTML等属性呢？<br>为什么有些DOM元素有accessKey、contentEditable、isContentEditable等属性呢？<br>为什么每个DOM元素都有onclick、ondblclick、ondrag等属性？<br>本文就是来解答这些简单而又不“简单”的问题。</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>你可以在浏览器中选择一个节点，然后在控制台中输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$0.hasOwnProperty </span><br><span class="line">// ƒ hasOwnProperty() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：$0表示当前选择的DOM元素。<br>为什么我的一个元素会有对象的方法，追究其原因在设计HTML时，通过从各个接口继承不同的属性和方法。<br>例如span元素继承关系：span -&gt; HTMLSpanElement -&gt; HTMLElement -&gt; Element -&gt; Node -&gt; EventTarget-&gt; Object<br><img src="http://oxpnrlb4j.bkt.clouddn.com/html%E5%B1%9E%E6%80%A7.png" alt="property"><br>[2018-08-16]</p>
<h1 id="EventTarget"><a href="#EventTarget" class="headerlink" title="EventTarget"></a>EventTarget</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>EventTarget 是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如XMLHttpRequest，AudioNode，AudioContext 等等。<br>许多事件目标（包括元素，文档和 window）还支持通过 onXXX（如onclick） 属性和属性设置事件处理程序。</p>
<h2 id="该接口的方法"><a href="#该接口的方法" class="headerlink" title="该接口的方法"></a>该接口的方法</h2><h3 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p>在EventTarget上注册特定事件类型的事件处理程序。</p>
<h3 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h3><p>EventTarget中删除事件侦听器。</p>
<h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h3><p>将事件分派到此EventTarget。</p>
<h2 id="我们自己实现EventTarget"><a href="#我们自己实现EventTarget" class="headerlink" title="我们自己实现EventTarget"></a>我们自己实现EventTarget</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var EventTarget = function() &#123;</span><br><span class="line">  this.listeners = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.listeners = null;</span><br><span class="line">EventTarget.prototype.addEventListener = function(type, callback) &#123;</span><br><span class="line">  if (!(type in this.listeners)) &#123;</span><br><span class="line">    this.listeners[type] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  this.listeners[type].push(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.removeEventListener = function(type, callback) &#123;</span><br><span class="line">  if (!(type in this.listeners)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  var stack = this.listeners[type];</span><br><span class="line">  for (var i = 0, l = stack.length; i &lt; l; i++) &#123;</span><br><span class="line">    if (stack[i] === callback)&#123;</span><br><span class="line">      stack.splice(i, 1);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.dispatchEvent = function(event) &#123;</span><br><span class="line">  if (!(event.type in this.listeners)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  var stack = this.listeners[event.type].slice();</span><br><span class="line"></span><br><span class="line">  for (var i = 0, l = stack.length; i &lt; l; i++) &#123;</span><br><span class="line">    stack[i].call(this, event);</span><br><span class="line">  &#125;</span><br><span class="line">  return !event.defaultPrevented;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。</p>
<h2 id="有那些接口重Node继承其方法和属性？"><a href="#有那些接口重Node继承其方法和属性？" class="headerlink" title="有那些接口重Node继承其方法和属性？"></a>有那些接口重Node继承其方法和属性？</h2><p>Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference<br>PS：在方法和属性不相关的特定情况下，这些接口可能返回null。它们可能会抛出异常 - 例如，当将子节点添加到不允许子节点存在的节点时。</p>
<h2 id="接口相关的属性和方法"><a href="#接口相关的属性和方法" class="headerlink" title="接口相关的属性和方法"></a>接口相关的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="Node-baseURI"><a href="#Node-baseURI" class="headerlink" title="Node.baseURI"></a>Node.baseURI</h4><p>返回一个表示base URL的DOMString。不同语言中的base URL的概念都不一样。 在HTML中，base URL表示协议和域名，以及一直到最后一个’/‘之前的文件目录。</p>
<h4 id="Node-childNodes"><a href="#Node-childNodes" class="headerlink" title="Node.childNodes"></a>Node.childNodes</h4><p>返回一个包含了该节点所有子节点的实时的NodeList。NodeList 是“实时的”意思是，如果该节点的子节点发生了变化，NodeList对象就会自动更新。 </p>
<h4 id="Node-firstChild"><a href="#Node-firstChild" class="headerlink" title="Node.firstChild"></a>Node.firstChild</h4><p>返回该节点的第一个子节点，如果该节点没有子节点则返回null。</p>
<h4 id="Node-lastChild"><a href="#Node-lastChild" class="headerlink" title="Node.lastChild"></a>Node.lastChild</h4><p>返回该节点的最后一个子节点，如果该节点没有子节点则返回null。<br>此处省略若干Node接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node#属性" target="_blank" rel="noopener">更多属性查看这里</a>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>——————–重点分割线——————-<br>重点：从其父类EventTarget继承了addEventListener、removeEventListener、dispatchEvent等方法。</p>
<h4 id="Node-appendChild"><a href="#Node-appendChild" class="headerlink" title="Node.appendChild()"></a>Node.appendChild()</h4><p>将一个节点添加到指定父节点的子节点列表末尾。</p>
<h4 id="Node-contains"><a href="#Node-contains" class="headerlink" title="Node.contains()"></a>Node.contains()</h4><p>返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点。</p>
<h4 id="Node-cloneNode"><a href="#Node-cloneNode" class="headerlink" title="Node.cloneNode()"></a>Node.cloneNode()</h4><p>返回调用该方法的节点的一个副本。<br>此处省略若干Node接口方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node#方法" target="_blank" rel="noopener">更多方法查看这里</a>。</p>
<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Element是非常通用的基类，所有 Document对象下的对象都继承它。这个接口描述了所有相同种类的元素所普遍具有的方法和属性。 这些继承自Element并且增加了一些额外功能的接口描述了具体的行为。<br>PS：HTMLElement 接口是所有HTML元素的基础接口， 而 SVGElement 接口是所有SVG元素的基本接口。<br>在web以外的语言，像 XUL 可以通过 XULElement 的API，也能实现它。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>所有属性继承至它的祖先接口 Node, 和它所扩展的接口 EventTarget, 并且从以下部分继承了属性ParentNode, ChildNode, NonDocumentTypeChildNode, 和Animatable.</p>
<h3 id="Element-assignedSlot"><a href="#Element-assignedSlot" class="headerlink" title="Element.assignedSlot"></a>Element.assignedSlot</h3><p>返回元素对应的 HTMLSlotElement 接口</p>
<h3 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h3><p>返回一个与该元素相关的所有属性集合NamedNodeMap </p>
<h3 id="Element-classList"><a href="#Element-classList" class="headerlink" title="Element.classList"></a>Element.classList</h3><p>返回该元素包含的class属性是一个DOMTokenList.</p>
<h3 id="Element-className"><a href="#Element-className" class="headerlink" title="Element.className"></a>Element.className</h3><p>它是一个 DOMString 表示这个元素的class.<br>此处省略若干Element接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element#Properties" target="_blank" rel="noopener">更多方法查看这里</a>。</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>——————–重点分割线——————-<br>从它的父类（Node）和它父类的父类（EventTarget）继承方法，并实现parentNode、ChildNode、NonDocumentTypeChildNode、Animatable。<br>此处省略若干Element接口方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element#Properties" target="_blank" rel="noopener">更多方法查看这里</a>。</p>
<h3 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h3><p>方法用来获取匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。</p>
<h3 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h3><p>返回元素上一个指定的属性值。如果指定的属性不存在，则返回  null 或 “” （空字符串）。</p>
<h3 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h3><p>参数中给出类的列表，返回一个动态的 HTMLCollection ，这里面包含了所有持有这些类的后代元素。<br>此处省略若干Element接口方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element#Methods" target="_blank" rel="noopener">更多方法查看这里</a>。</p>
<h1 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>HTMLElement 接口表示所有的 HTML 元素。一些HTML元素直接实现了HTMLElement接口，其它的间接实现HTMLElement接口。</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>——————–重点分割线——————-<br>继承自父接口Element和 GlobalEventHandlers的属性。<br>HTMLElement.accessKey    DOMString    获取/设置元素访问的快捷键<br>HTMLElement.accessKeyLabel    DOMString    返回一个包含元素访问的快捷键的字符串（只读）<br>HTMLElement.contentEditable    DOMString    获取/设置元素的可编辑状态<br>HTMLElement.isContentEditable Boolean    表明元素的内容是否可编辑（只读）<br>此处省略若干HTMLElement接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement#属性" target="_blank" rel="noopener">更多方法查看这里</a>。</p>
<h2 id="Event-handlers"><a href="#Event-handlers" class="headerlink" title="Event handlers"></a>Event handlers</h2><p>HTMLElement.onTouchStart<br>HTMLElement.onTouchEnd<br>HTMLElement.onTouchMove<br>HTMLElement.onTouchEnter<br>HTMLElement.onTouchLeave<br>HTMLElement.onTouchCancel </p>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><p>HTMLElement.blur()    void    元素失去焦点<br>HTMLElement.click()    void    触发元素的点击事件<br>HTMLElement.focus()    void    元素获得焦点<br>HTMLElement.forceSpellCheck()     void     </p>
<h1 id="GlobalEventHandlers"><a href="#GlobalEventHandlers" class="headerlink" title="GlobalEventHandlers"></a>GlobalEventHandlers</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>GlobalEventHandlers接口描述了事件处理程序像HTMLElement常见的几个接口,文件,窗口,或WorkerGlobalScope Web Workers。这些接口可以实现更多的事件处理程序。</p>
<h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><h3 id="GlobalEventHandlers-onabort"><a href="#GlobalEventHandlers-onabort" class="headerlink" title="GlobalEventHandlers.onabort"></a>GlobalEventHandlers.onabort</h3><p>中断事件。</p>
<h3 id="GlobalEventHandlers-onblur"><a href="#GlobalEventHandlers-onblur" class="headerlink" title="GlobalEventHandlers.onblur"></a>GlobalEventHandlers.onblur</h3><p>失去焦点事件。</p>
<h3 id="GlobalEventHandlers-onfocus"><a href="#GlobalEventHandlers-onfocus" class="headerlink" title="GlobalEventHandlers.onfocus"></a>GlobalEventHandlers.onfocus</h3><p>获取焦点事件。<br>此处省略若干GlobalEventHandlers接口属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers#Properties" target="_blank" rel="noopener">更多方法查看这里</a>。</p>
<h1 id="元素接口"><a href="#元素接口" class="headerlink" title="元素接口"></a>元素接口</h1><p>该接口用于创建对应的元素。<br>如：<br>HTMLDivElement 接口提供了一些特殊属性（它也继承了通常的 HTMLElement 接口）来操作div元素。<br>HTMLFormElement接口可以创建或者修改<form>对象;它继承了HTMLElement接口的方法和属性。<br>HTMLAnchorElement 接口表示超链接元素，并提供一些特别的属性和方法（除了那些继承自普通 HTMLElement对象接口的之外）以用于操作这些元素的布局和显示。<br>……</form></p>
<h1 id="回答前面问题"><a href="#回答前面问题" class="headerlink" title="回答前面问题"></a>回答前面问题</h1><p>通过上面的知识，我们了解到：<br>HTMLDivElement（其他元素接口） 继承 HTMLElement 和 GlobalEventHandlers 接口。<br>HTMLElement 继承 Element 接口。<br>Element 继承 Node 接口。<br>Node 继承 EventTarget 接口。<br><img src="http://oxpnrlb4j.bkt.clouddn.com/html%E5%85%83%E7%B4%A0%E7%94%B1%E6%9D%A5%281%29.svg" alt="html由来"><br>为什么div元素甚至是所有的html元素都可以使用addEventListener来添加事件呢？<br>回答：从 EventTarget 接口中继承而来。<br>为什么每个DOM节点都有parentNode、firstChild、nodeType等属性呢？<br>回答：从 Node 接口中继承而来。<br>为什么每个DOM元素都有className、classList、innerHTML等属性呢？<br>回答：从 Element 接口中继承而来。<br>为什么有些DOM元素有accessKey、contentEditable、isContentEditable等属性呢？<br>回答：从 HTMLElement 接口中继承而来。<br>为什么每个DOM元素都有onclick、ondblclick、ondrag等属性？<br>回答：从 GlobalEventHandlers 接口中继承而来。<br>——————–重点分割线——————-</p>
<h2 id="只有通过上面的继承关系，我们得到的-DOM-元素才是一个完整的-HTML-对象，我们才能为它设置-获取属性、绑定事件、添加样式类等操作。"><a href="#只有通过上面的继承关系，我们得到的-DOM-元素才是一个完整的-HTML-对象，我们才能为它设置-获取属性、绑定事件、添加样式类等操作。" class="headerlink" title="只有通过上面的继承关系，我们得到的 DOM 元素才是一个完整的 HTML 对象，我们才能为它设置/获取属性、绑定事件、添加样式类等操作。"></a>只有通过上面的继承关系，我们得到的 DOM 元素才是一个完整的 HTML 对象，我们才能为它设置/获取属性、绑定事件、添加样式类等操作。</h2><p>参考文档：</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node" target="_blank" rel="noopener">Node</a><br><a href="https://developer.mozilla.org/en-US/docs/Glossary/Element" target="_blank" rel="noopener">Element</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" target="_blank" rel="noopener">HTMLElement</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers" target="_blank" rel="noopener">GlobalEventHandlers</a></p>
</blockquote>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>梳理下浏览器对象模型知识（BOM）</title>
    <url>/2018/%E6%A2%B3%E7%90%86%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%EF%BC%88BOM%EF%BC%89.html</url>
    <content><![CDATA[<p>本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。</p>
<h1 id="BOM介绍"><a href="#BOM介绍" class="headerlink" title="BOM介绍"></a>BOM介绍</h1><p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。<br>浏览器对象模型的构成<br><img src="http://p5hb0ypha.bkt.clouddn.com/BOM.svg" alt="浏览器对象模型的构成"></p>
<h1 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h1><p>Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。<br>在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。</p>
<h2 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" alt="Window对象的属性"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
<h2 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h2><p><img src="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" alt="Window对象的方法"><br><a href="http://p5hb0ypha.bkt.clouddn.com/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%281%29.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
<h1 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h1><p>Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。<br>Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。<br><img src="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" alt="Location对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/location%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
<h1 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h1><p>History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。<br><img src="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" alt="History对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/history%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
<h1 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h1><p>Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。<br><img src="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" alt="Navigator对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/navigator%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
<h1 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h1><p>Screen 对象包含有关用户屏幕的信息。<br><img src="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" alt="Screen对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/screen%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
<h1 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h1><p>Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。<br><img src="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" alt="document对象"><br><a href="http://p5hb0ypha.bkt.clouddn.com/document%E5%AF%B9%E8%B1%A1.svg" target="_blank" rel="noopener">看不清，点这里</a></p>
]]></content>
      <categories>
        <category>BOM</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>网页长度相关API</title>
    <url>/2018/%E7%BD%91%E9%A1%B5%E9%95%BF%E5%BA%A6%E7%9B%B8%E5%85%B3API.html</url>
    <content><![CDATA[<h1 id="元素的宽高"><a href="#元素的宽高" class="headerlink" title="元素的宽高"></a>元素的宽高</h1><p>clientWidth、clientHeight：是指元素内容+内边距大小，不包括边框、外边距、滚动条部分。<br>offsetWidth、offsetHeight：是指元素内容+内边距大小+边框大小，不包括外边距和滚动条部分。<br>scrollWidth、scrollHeight：是指元素内容+内边距+对应方向的溢出部分。</p>
<h1 id="元素的位置"><a href="#元素的位置" class="headerlink" title="元素的位置"></a>元素的位置</h1><p>clientLeft、clientTop：是指元素的内边距的外边缘和边框的外边缘的距离（其实边框的宽度）。<br>offsetLeft、offsetTop：元素的边框的外边缘距离与已定位的父容器（offsetparent）的左边距离（不包括元素的边框和父容器的边框）。<br>scrollTop、scrollLeft：获取或设置一个元素垂直或水平滚动的像素数。<br>pageXOffset、pageYOffset：返回文档在窗口左上角水平和垂直方向滚动的像素。</p>
<h1 id="鼠标位置"><a href="#鼠标位置" class="headerlink" title="鼠标位置"></a>鼠标位置</h1><p>event.clientX、event.clientY // 鼠标相对于视口左上角X,Y坐标（不包括工具栏和滚动条）<br>event.pageX、event.pageY // 鼠标相对于文档左上角X,Y坐标<br>event.offsetX、event.offsetY // 鼠标相对于事件源元素（srcElement）的X,Y坐标（只有ie支持）<br>event.screenX、event.screenY // 鼠标相对于用户显示器屏幕左上角的X,Y坐标。</p>
<h1 id="其他度量"><a href="#其他度量" class="headerlink" title="其他度量"></a>其他度量</h1><h2 id="视口大小"><a href="#视口大小" class="headerlink" title="视口大小"></a>视口大小</h2><p>document.documentElement.clientWidth<br>document.documentElement.clientHeight</p>
<h2 id="页面实际大小"><a href="#页面实际大小" class="headerlink" title="页面实际大小"></a>页面实际大小</h2><p>document.documentElement.scrollWidth<br>document.documentElement.scrollHeight</p>
<h2 id="屏幕大小"><a href="#屏幕大小" class="headerlink" title="屏幕大小"></a>屏幕大小</h2><p>window.screen.width<br>window.screen.height</p>
<h2 id="屏幕可用宽度（去除状态栏）"><a href="#屏幕可用宽度（去除状态栏）" class="headerlink" title="屏幕可用宽度（去除状态栏）"></a>屏幕可用宽度（去除状态栏）</h2><p>window.screen.availWidth<br>window.screen.availHeight</p>
<h2 id="窗口的内高度、内宽度（文档显示区域-滚动条）"><a href="#窗口的内高度、内宽度（文档显示区域-滚动条）" class="headerlink" title="窗口的内高度、内宽度（文档显示区域+滚动条）"></a>窗口的内高度、内宽度（文档显示区域+滚动条）</h2><p>window.innerWidth<br>window.innerHeight</p>
<h2 id="窗口的外高度、外宽度"><a href="#窗口的外高度、外宽度" class="headerlink" title="窗口的外高度、外宽度"></a>窗口的外高度、外宽度</h2><p>window.outerWidth<br>window.outerHeiht</p>
<h2 id="返回元素的大小及其相对于视口的位置"><a href="#返回元素的大小及其相对于视口的位置" class="headerlink" title="返回元素的大小及其相对于视口的位置"></a>返回元素的大小及其相对于视口的位置</h2><p>ele.getBoundingClientRect()</p>
<h2 id="返回一个指向客户端中每一个盒子的边界矩形的矩形集合"><a href="#返回一个指向客户端中每一个盒子的边界矩形的矩形集合" class="headerlink" title="返回一个指向客户端中每一个盒子的边界矩形的矩形集合"></a>返回一个指向客户端中每一个盒子的边界矩形的矩形集合</h2><p>ele.getClientRects()</p>
<h2 id="返回一个应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值"><a href="#返回一个应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值" class="headerlink" title="返回一个应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值"></a>返回一个应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值</h2><p>window.getComputedStyle(element, [pseudoElt])</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊伪元素（::after和::before）、pointer-events属性、touch-action属性</title>
    <url>/2018/%E8%81%8A%E8%81%8A%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%88-after%E5%92%8C-before%EF%BC%89%E5%92%8Cpointer-events%E5%B1%9E%E6%80%A7%E5%92%8Ctouch-action%E5%B1%9E%E6%80%A7.html</url>
    <content><![CDATA[<h1 id="伪元素（以-after举例）"><a href="#伪元素（以-after举例）" class="headerlink" title="伪元素（以::after举例）"></a>伪元素（以::after举例）</h1><h2 id="属性基础介绍"><a href="#属性基础介绍" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。<br>使用：CSS2.0为<code>element:after{content: &#39;&#39;;...}</code>；CSS3.0为<code>element::after{content: &#39;&#39;;...}</code><br>这些并不是我今天想讨论的，我们应该来看看伪元素的一些其他性质。</p>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>本文的重点：我们都知道我们不能为伪元素添加事件（目前是这样，不知道以后W3C会不会考虑），但是伪元素是可以触发元素本体上的事件。我认为伪元素的出现使我们在某种程度上可以精简DOM结构（伪元素可以达到补充、完善UI的目的），但是由于会触发元素本体上的事件，可能有些地方使用需要考虑一下了（在DOM简化的微小性能优化和是否适用于该场景中权衡一下）。<br>PS：元素本体：为了文章的好理解，我自己起的名字，意思为某个元素除了虚拟元素（::after等）以外的部分。<br>比如为了为了实现下图UI，用元素的 after伪类 实现登录和注册分割中的‘点.’，但这个 after伪类保留了 span标签 登录事件感觉有点不符合UI语义。<br><img src="http://pau044s3z.bkt.clouddn.com/after%E4%BC%AA%E7%B1%BB%E4%BD%BF%E7%94%A8.png" alt="after伪类的使用"></p>
<h1 id="CSS之pointer-events属性"><a href="#CSS之pointer-events属性" class="headerlink" title="CSS之pointer-events属性"></a>CSS之pointer-events属性</h1><p>我这里只讨论 pointer-events 的auto、none、inherit、initial、unset（不讨论SVG相关的属性值）。</p>
<h2 id="属性基础介绍-1"><a href="#属性基础介绍-1" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target，也就是说通过设置该属性可以控制该元素是否为事件的target。<br>对上面提到的属性值做下简单的介绍：<br>auto：  与 pointer-events 属性未指定时的表现效果相同<br>none：  元素永远不会成为鼠标事件的 target（不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍）。<br>inherit：  该关键字使得元素获取其父元素的计算值(computed value )，由于该属性为非继承属性 inherit 在这里指定的行为通常没有多大意义，一般使用使用 initial 或 unset 作为替代。<br>initial：  相关标准都设置了每个元素的的初始值，pointer-events 属性的初始值为 auto 。<br>unset：  关键字 unset 是 关键字 initial 和 inherit的组合（如果有继承父级样式，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值）。</p>
<h2 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h2><p>还记得我们刚刚讲到 pointer-events 的属性值为 none 时提到“不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍”，这里开始做说明。</p>
<blockquote>
<p> 使用pointer-events来阻止元素成为鼠标事件目标不一定意味着元素上的事件侦听器永远不会触发。如果元素后代明确指定了pointer-events属性并允许其成为鼠标事件的目标，那么指向该元素的任何事件在事件传播过程中都将通过父元素，并以适当的方式触发其上的事件侦听器。当然，位于父元素但不在后代元素上的鼠标活动都不会被父元素和后代元素捕获（鼠标活动将会穿过父元素而指向位于其下面的元素）。</p>
</blockquote>
<h3 id="该属性提高页面滚动时候的绘制性能是不准确的"><a href="#该属性提高页面滚动时候的绘制性能是不准确的" class="headerlink" title="该属性提高页面滚动时候的绘制性能是不准确的"></a>该属性提高页面滚动时候的绘制性能是不准确的</h3><p>为什么这么说呢？已经有前辈写过相应的文章，以及详细的测试数据<a href="https://www.zhangxinxu.com/wordpress/2014/01/pointer-events-none-avoiding-unnecessary-paints/" target="_blank" rel="noopener">pointer-events:none提高页面滚动时候的绘制性能？</a></p>
<h3 id="只能失效鼠标事件，并不能让键盘事件失效"><a href="#只能失效鼠标事件，并不能让键盘事件失效" class="headerlink" title="只能失效鼠标事件，并不能让键盘事件失效"></a>只能失效鼠标事件，并不能让键盘事件失效</h3><p>pointer-events 只能失效鼠标事件，并不能让键盘事件失效，所以用该属性对按钮的禁用需要小心<a href="https://www.zhangxinxu.com/wordpress/2011/12/css3-pointer-events-none-javascript/" target="_blank" rel="noopener">大家可以看看张鑫旭前辈的文章</a>。</p>
<h1 id="CSS之touch-action属性"><a href="#CSS之touch-action属性" class="headerlink" title="CSS之touch-action属性"></a>CSS之touch-action属性</h1><h2 id="属性基础介绍-2"><a href="#属性基础介绍-2" class="headerlink" title="属性基础介绍"></a>属性基础介绍</h2><p>定义：用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。<br>属性值介绍：<br>auto：  当触控事件发生在元素上时，由浏览器来决定进行哪些操作，比如对viewport进行平滑、缩放等。<br>none：  当触控事件发生在元素上时，不进行任何操作。<br>pan-x：  启用单指水平平移手势。可以与 pan-y 、pan-up、pan-down、pinch-zoom 组合使用。<br>pan-y：  启用单指垂直平移手势。可以与 pan-x 、pan-left 、pan-right、pinch-zoom 组合使用。<br>manipulation：  浏览器只允许进行滚动和持续缩放操作。任何其它被auto值支持的行为不被支持。启用平移和缩小缩放手势，但禁用其他非标准手势，例如双击以进行缩放。 禁用双击可缩放功能可减少浏览器在用户点击屏幕时延迟生成点击事件的需要。<br>pinch-zoom：  启用多手指平移和缩放页面。 这可以与任何平移值组合。</p>
<h2 id="补充知识-2"><a href="#补充知识-2" class="headerlink" title="补充知识"></a>补充知识</h2><p>移动端300ms延迟，就可以使用 touch-action: manipulation;因为 manipulation 会禁用双击事件（浏览器就不需要等待300ms之后来判断了）。<br>处理移动端点击延迟代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  touch-action: manipulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h3><ol>
<li><p>在地图或游戏开发中，最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#map &#123;</span><br><span class="line">  touch-action: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>水平图像轮播开发中，只想通过水平滑动但不想干扰网页的垂直滚动或缩放，可用以下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.image-carousel &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 150px;</span><br><span class="line">  touch-action: pan-y pinch-zoom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>自己踩过的坑</title>
    <url>/2018/%E8%87%AA%E5%B7%B1%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<h1 id="touchstart-和-click-的坑"><a href="#touchstart-和-click-的坑" class="headerlink" title="touchstart 和 click 的坑"></a>touchstart 和 click 的坑</h1><h2 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tap = &apos;ontouchstart&apos; in window ? &apos;touchstart&apos; : &apos;click&apos;;</span><br><span class="line">wrap.addEvenListener(tap, function()&#123;</span><br><span class="line">    signUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过上面代码简单为用户设置事件类型，但我们忽略了‘联想触控笔记本’，<span color="color: red">由于该笔记本支持‘touchstart’事件，但当用户使用鼠标时却不能触发‘touchstart’事件</span>，造成不能触发对应的事件处理函数。</p>
<ol>
<li>有些 PC 设备屏幕为触摸屏，同时支持touchstart和click事件；</li>
<li>用户触发touchstart事件，默认必然会导致触发click事件，但是触发click事件，不一定会导致touchstart事件被触发；</li>
<li>此类设备外接鼠标时，通过上面的绑定方式，会绑定touchstart事件，但是鼠标操作只能触发click，导致touchstart不触发；</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="均使用click事件（移动端存在300ms延迟）"><a href="#均使用click事件（移动端存在300ms延迟）" class="headerlink" title="均使用click事件（移动端存在300ms延迟）"></a>均使用click事件（移动端存在300ms延迟）</h3><h3 id="通过UA判断设备是否为移动端，再确认事件类型"><a href="#通过UA判断设备是否为移动端，再确认事件类型" class="headerlink" title="通过UA判断设备是否为移动端，再确认事件类型"></a>通过UA判断设备是否为移动端，再确认事件类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isMobile() &#123;</span><br><span class="line">    return navigator.userAgent.match(/(blackberry|configuration\/cldc|hp |hp-|htc |htc_|htc-|iemobile|kindle|midp|mmp|motorola|mobile|nokia|opera mini|opera |Googlebot-Mobile|YahooSeeker\/M1A1-R2D2|android|iphone|ipod|mobi|palm|palmos|pocket|portalmmm|ppc;|smartphone|sonyericsson|sqh|spv|symbian|treo|up.browser|up.link|vodafone|windows ce|xda |xda_)/i) ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"> var tap = isMobile() ? &apos;touchstart&apos; : &apos;click&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="全部使用click，通过FastClick解决300毫秒的延迟问题"><a href="#全部使用click，通过FastClick解决300毫秒的延迟问题" class="headerlink" title="全部使用click，通过FastClick解决300毫秒的延迟问题"></a>全部使用click，通过FastClick解决300毫秒的延迟问题</h3><h3 id="不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。"><a href="#不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。" class="headerlink" title="不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。"></a>不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。</h3><p>具体实现：</p>
<ol>
<li>在touchstart事件响应中调用preventDefault()方法，阻止后续click事件的触发（也会阻止多个事件绑定叠加和多人合作项目，导致以来 click 事件出现bug）</li>
<li>在touchstart事件中设置一些标记，或者取消click事件的绑定，使得click事件触发时不会触发我们绑定的逻辑，在一段时间（例如300-500ms）后再恢复</li>
<li>直接对事件处理函数进行节流（throttle），保证在一段时间内（300ms - 500ms），事件处理函数只触发一次</li>
</ol>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>object instanceof constructor<br>instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。<br>instanceof 运算符用来测试一个对象的原型链中是否存在一个构造函数的 prototype 属性。</p>
<h1 id="URL-构造函数-和-URLSearchParams-构造函数"><a href="#URL-构造函数-和-URLSearchParams-构造函数" class="headerlink" title="URL 构造函数 和 URLSearchParams 构造函数"></a>URL 构造函数 和 URLSearchParams 构造函数</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL() 构造函数返回一个新创建的URL对象，表示由参数定义的URL。</p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>URL 实例的属性与Location对象的属性基本一致，返回当前 URL 的信息。<br>URL.href、URL.protocol等</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>URL.createObjectURL()<br>URL.createObjectURL方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。<br>URL.revokeObjectURL()<br>URL.revokeObjectURL方法用来释放URL.createObjectURL方法生成的 URL 实例。它的参数就是URL.createObjectURL方法返回的 URL 字符串。</p>
<h2 id="URLSearchParams"><a href="#URLSearchParams" class="headerlink" title="URLSearchParams"></a>URLSearchParams</h2><p>URLSearchParams对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>URLSearchParams.append()<br> 插入一个指定的键/值对作为新的搜索参数。<br>URLSearchParams.delete()<br> 从搜索参数列表里删除指定的搜索参数及其对应的值。<br>URLSearchParams.entries()<br> 返回一个iterator可以遍历所有键/值对的对象。<br>URLSearchParams.get()<br> 获取指定搜索参数的第一个值。<br>URLSearchParams.getAll()<br> 获取指定搜索参数的所有值，返回是一个数组。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">URLSearchParams</a><br><a href="https://wangdoc.com/javascript/bom/location.html#url-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">URL 对象，URLSearchParams 对象</a></p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一些前端技巧</title>
    <url>/2018/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<h1 id="CSS技巧"><a href="#CSS技巧" class="headerlink" title="CSS技巧"></a>CSS技巧</h1><p><a href="https://github.com/happylindz/blog/issues/12" target="_blank" rel="noopener">纯 CSS 实现多行文字截断</a></p>
<h1 id="JS技巧"><a href="#JS技巧" class="headerlink" title="JS技巧"></a>JS技巧</h1><p><a href="https://juejin.im/post/5be54a286fb9a049ae07641b" target="_blank" rel="noopener">弹幕开发</a><br><a href="https://juejin.im/post/5bf35ef26fb9a049bc4c438a" target="_blank" rel="noopener">h5与webview如何互通</a></p>
<h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><p><a href="https://juejin.im/post/5bd66efcf265da0a8a6af2d2" target="_blank" rel="noopener">webpack4</a><br>webpack、webpack-cli、babel-core、babel-loader、babel-preset-env \ 常见依赖<br>babel-plugin-transform-class-properties // class支持属性<br>babel-plugin-transform-decorators-legacy // 支持decorators语法<br>babel-preset-react // jsx依赖</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><a href="http://www.17ce.com/" target="_blank" rel="noopener">查看某个网站全国访问速度情况</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一些有趣的repo</title>
    <url>/2018/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84repo.html</url>
    <content><![CDATA[<p><a href="https://hellogithub.com/" target="_blank" rel="noopener">大量开源项目hellogithub</a></p>
<h1 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h1><p><a href="https://github.com/sorrycc/awesome-javascript#package-managers" target="_blank" rel="noopener">awesome-javascript</a><br><a href="https://juejin.im/post/5ba7d5dd5188255c6140cc9d" target="_blank" rel="noopener">前端常用插件、工具类库汇总</a><br><a href="https://github.com/h5bp/html5-boilerplate" target="_blank" rel="noopener">Web开发前端模版</a><br><a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">美化代码-prettier</a><br><a href="https://github.com/zeit/hyper" target="_blank" rel="noopener">Web技术的终端</a><br><a href="https://github.com/Leaflet/Leaflet" target="_blank" rel="noopener">交互式地图</a><br><a href="https://github.com/zenorocha/clipboard.js/" target="_blank" rel="noopener">剪贴板</a><br><a href="https://github.com/headjs/headjs" target="_blank" rel="noopener">html的head标签</a><br><a href="https://github.com/IanLunn/Hover" target="_blank" rel="noopener">CSS-Hover.css</a><br><a href="https://github.com/Prinzhorn/skrollr" target="_blank" rel="noopener">视差滚动库</a><br><a href="https://github.com/quilljs/quill" target="_blank" rel="noopener">轻量级富文本编辑器</a><br><a href="https://github.com/knsv/mermaid" target="_blank" rel="noopener">markDown生成流程图</a><br><a href="https://github.com/markedjs/marked" target="_blank" rel="noopener">marked</a><br><a href="https://github.com/jaywcjlove/hotkeys" target="_blank" rel="noopener">键盘事件库-hotkeys</a><br><a href="https://github.com/inorganik/CountUp.js" target="_blank" rel="noopener">实现数字增长动画-countUp.js</a><br><a href="https://github.com/loadchange/gwm" target="_blank" rel="noopener">Web水印</a><br><a href="https://github.com/yanhaijing/jslib-base" target="_blank" rel="noopener">搭建标准的js库jslib-base</a><br><a href="https://github.com/Shopify/draggable" target="_blank" rel="noopener">draggable</a><br><a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">表格</a><br><a href="https://github.com/Olical/EventEmitter" target="_blank" rel="noopener">发布订阅模式-EventEmitter</a><br><a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener">同构fetch</a><br><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a><br><a href="https://github.com/transloadit/uppy/" target="_blank" rel="noopener">文件上传uppy</a></p>
<h1 id="微信小程序开发框架"><a href="#微信小程序开发框架" class="headerlink" title="微信小程序开发框架"></a>微信小程序开发框架</h1><p><a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">vue风格mpvue</a><br><a href="https://github.com/Tencent/wepy" target="_blank" rel="noopener">vue风格wepy</a><br><a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">react风格taro</a></p>
<h1 id="React相关"><a href="#React相关" class="headerlink" title="React相关"></a>React相关</h1><p><a href="https://www.npmjs.com/package/react-hover" target="_blank" rel="noopener">react-hover</a><br><a href="https://www.npmjs.com/package/autobind-decorator" target="_blank" rel="noopener">autobind-decorator</a><br><a href="https://www.npmjs.com/package/react-helmet" target="_blank" rel="noopener">react-helmet</a><br><a href="https://www.npmjs.com/package/react-loadable" target="_blank" rel="noopener">react-loadable</a><br><a href="https://www.npmjs.com/package/react-content-loader" target="_blank" rel="noopener">react-content-loader</a><br><a href="https://www.npmjs.com/package/react-lazyload" target="_blank" rel="noopener">react-lazyload</a><br><a href="https://react-slick.neostack.com/docs/get-started" target="_blank" rel="noopener">react-slick</a><br><a href="https://github.com/enaqx/awesome-react" target="_blank" rel="noopener">awesome-react</a><br><a href="https://dvemac.github.io/react-component-list/" target="_blank" rel="noopener">react-component-list</a><br><a href="https://www.npmjs.com/package/react-clipboard.js" target="_blank" rel="noopener">React-Clipboard</a><br><a href="https://www.npmjs.com/package/react-dnd-html5-backend" target="_blank" rel="noopener">react-dnd-html5-backend</a><br><a href="https://www.npmjs.com/package/react-dnd" target="_blank" rel="noopener">react-dnd</a><br><a href="https://github.com/bvaughn/react-highlight-words" target="_blank" rel="noopener">react-highlight-words</a></p>
<h1 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h1><p><a href="https://github.com/FortAwesome/Font-Awesome" target="_blank" rel="noopener">Font-Awesome</a></p>
<h1 id="Git（Commit规范）"><a href="#Git（Commit规范）" class="headerlink" title="Git（Commit规范）"></a>Git（Commit规范）</h1><p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a><br><a href="https://marionebl.github.io/commitlint/#/" target="_blank" rel="noopener">commitlint</a><br><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a></p>
<h1 id="页面生产图片"><a href="#页面生产图片" class="headerlink" title="页面生产图片"></a>页面生产图片</h1><p><a href="https://github.com/niklasvh/html2canvas/" target="_blank" rel="noopener">html2canvas</a><br><a href="https://github.com/tsayen/dom-to-image" target="_blank" rel="noopener">dom-to-image</a><br><a href="https://github.com/cburgmer/rasterizeHTML.js" target="_blank" rel="noopener">rasterizeHTML.js</a>  </p>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">Animate.css</a><br><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">演示文稿-reveal.js</a><br><a href="https://github.com/impress/impress.js" target="_blank" rel="noopener">演示文稿-impress.js</a><br><a href="https://github.com/qgh810/animate-text" target="_blank" rel="noopener">animate-text</a><br><a href="https://github.com/mozilla/pdf.js" target="_blank" rel="noopener">pdf.js</a><br><a href="https://github.com/nolimits4web/swiper" target="_blank" rel="noopener">轮播器-swiper</a></p>
<h1 id="图表库"><a href="#图表库" class="headerlink" title="图表库"></a>图表库</h1><p><a href="https://github.com/apache/incubator-echarts" target="_blank" rel="noopener">ECharts</a><br><a href="https://github.com/alibaba/BizCharts/" target="_blank" rel="noopener">BizCharts</a><br><a href="http://antv.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">AntV</a><br><a href="https://github.com/chartjs/Chart.js" target="_blank" rel="noopener">Chart</a></p>
<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p><a href="https://github.com/photonstorm/phaser" target="_blank" rel="noopener">phaser</a></p>
<h1 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h1><p><a href="https://github.com/josdejong/mathjs" target="_blank" rel="noopener">mathjs</a><br><a href="https://github.com/MikeMcl/big.js" target="_blank" rel="noopener">big.js</a><br><a href="https://github.com/arguiot/TheoremJS" target="_blank" rel="noopener">TheoremJS</a><br><a href="https://github.com/Khan/KaTeX" target="_blank" rel="noopener">数学公式库-KaTeX</a></p>
<h1 id="best-resume-ever"><a href="#best-resume-ever" class="headerlink" title="best-resume-ever"></a>best-resume-ever</h1><p>用Vue和LESS简单、快速建立许多漂亮的简历，并创建你最好的简历。<br><a href="https://github.com/salomonelli/best-resume-ever" target="_blank" rel="noopener">best-resume-ever</a></p>
<h1 id="css知识"><a href="#css知识" class="headerlink" title="css知识"></a>css知识</h1><p><a href="https://github.com/l-hammer/You-need-to-know-css" target="_blank" rel="noopener">You-need-to-know-css</a></p>
<h1 id="Web性能测试工具"><a href="#Web性能测试工具" class="headerlink" title="Web性能测试工具"></a>Web性能测试工具</h1><p><a href="https://github.com/pod4g/hiper" target="_blank" rel="noopener">hiper</a></p>
<h1 id="Web页面加载进度条"><a href="#Web页面加载进度条" class="headerlink" title="Web页面加载进度条"></a>Web页面加载进度条</h1><p><a href="https://github.com/rstacruz/nprogress/" target="_blank" rel="noopener">nprogress</a><br><a href="https://github.com/jacoborus/nanobar" target="_blank" rel="noopener">nanobar</a></p>
<h1 id="UI库"><a href="#UI库" class="headerlink" title="UI库"></a>UI库</h1><p><a href="https://github.com/yued-fe/lulu" target="_blank" rel="noopener">阅文-lulu（jQuery）</a></p>
<h1 id="常用的网址"><a href="#常用的网址" class="headerlink" title="常用的网址"></a>常用的网址</h1><p><a href="https://codepoints.net/" target="_blank" rel="noopener">码点查询大全</a>    </p>
<h1 id="CSS实现各种形状"><a href="#CSS实现各种形状" class="headerlink" title="CSS实现各种形状"></a>CSS实现各种形状</h1><p><a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="noopener">CSS实现各种形状</a></p>
<h1 id="屏幕录制"><a href="#屏幕录制" class="headerlink" title="屏幕录制"></a>屏幕录制</h1><p><a href="https://licecap.en.softonic.com/" target="_blank" rel="noopener">屏幕录制-LICEcap</a><br><a href="https://giphy.com/apps/giphycapture" target="_blank" rel="noopener">mac-屏幕录制giphy capture</a></p>
<h1 id="代码gitignore"><a href="#代码gitignore" class="headerlink" title="代码gitignore"></a>代码gitignore</h1><p><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">gitignore</a></p>
<h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><p><a href="https://github.com/moment/moment/" target="_blank" rel="noopener">moment</a><br><a href="https://github.com/date-fns/date-fns" target="_blank" rel="noopener">date-fns</a><br><a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">dayjs</a></p>
<h1 id="抓取工具"><a href="#抓取工具" class="headerlink" title="抓取工具"></a>抓取工具</h1><p>Wireshark、Fiddler、Charles、Postman</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>Navicat for mysql</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>优秀项目</tag>
      </tags>
  </entry>
  <entry>
    <title>面试杂项</title>
    <url>/2018/%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html</url>
    <content><![CDATA[<h1 id="防止网页被嵌入框架的代码"><a href="#防止网页被嵌入框架的代码" class="headerlink" title="防止网页被嵌入框架的代码"></a>防止网页被嵌入框架的代码</h1><h2 id="任何页面都不可嵌套"><a href="#任何页面都不可嵌套" class="headerlink" title="任何页面都不可嵌套"></a>任何页面都不可嵌套</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断当前的window对象是否对顶层top对象还可以使用window.top !== window.self</span><br><span class="line">if (window !== top) </span><br><span class="line">// 如果不是，将top对象的网址自动导向被嵌入网页的网址</span><br><span class="line">top.location.href = window.location.href;</span><br></pre></td></tr></table></figure>
<h2 id="本地域名可嵌套，其他域名不可"><a href="#本地域名可嵌套，其他域名不可" class="headerlink" title="本地域名可嵌套，其他域名不可"></a>本地域名可嵌套，其他域名不可</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">　　top.location.hostname;</span><br><span class="line">　　if (top.location.hostname !== window.location.hostname) &#123;</span><br><span class="line">　　　　top.location.href = window.location.href;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">　　top.location.href = window.location.href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：上面两种对于动态生产iframe标签和禁用js不会用效果。<br>别人可能这样禁用你的js<br><code>&lt;noscript&gt;&lt;iframe src=fillseo.html&gt;&lt;/iframe&gt;&lt;/noscript&gt;</code></p>
<h2 id="js如何判断是否在iframe中"><a href="#js如何判断是否在iframe中" class="headerlink" title="js如何判断是否在iframe中"></a>js如何判断是否在iframe中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方式一 </span><br><span class="line">if (self.frameElement &amp;&amp; self.frameElement.tagName == &quot;IFRAME&quot;) &#123; </span><br><span class="line">	alert(&apos;在iframe中&apos;); </span><br><span class="line">&#125; </span><br><span class="line">//方式二 </span><br><span class="line">if (window.frames.length != parent.frames.length) &#123; </span><br><span class="line">	alert(&apos;在iframe中&apos;); </span><br><span class="line">&#125; </span><br><span class="line">//方式三 </span><br><span class="line">if (self != top) &#123; </span><br><span class="line">	alert(&apos;在iframe中&apos;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较可靠的方式"><a href="#比较可靠的方式" class="headerlink" title="比较可靠的方式"></a>比较可靠的方式</h2><p>为了彻底防止别人用IFRAME框架嵌套调用自己的网页，如下方法是最可靠的.<br>这里赋值为空页面,也可赋值为你的页面的URL地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(top != self)&#123; </span><br><span class="line">	location.href = &quot;about:blank&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在meta中设置"><a href="#在meta中设置" class="headerlink" title="在meta中设置"></a>在meta中设置</h2><p><code>&lt;meta http-equiv=&quot;X-FRAME-OPTIONS&quot; content=&quot;DENY&quot;&gt;</code></p>
<h2 id="在http的header做手脚"><a href="#在http的header做手脚" class="headerlink" title="在http的header做手脚"></a>在http的header做手脚</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header(‘X-Frame-Options:Deny&apos;);</span><br><span class="line">header(&quot;X-XSS-Protection: 0&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="在Apache、IIS、Nginc主机中设置"><a href="#在Apache、IIS、Nginc主机中设置" class="headerlink" title="在Apache、IIS、Nginc主机中设置"></a>在Apache、IIS、Nginc主机中设置</h2><p><code>X-Frame-Options &quot;SAMEORIGIN&quot;;</code></p>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="BFC的定义"><a href="#BFC的定义" class="headerlink" title="BFC的定义"></a>BFC的定义</h2><p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域（可以理解为独立的布局作用域），也是浮动元素与其他元素的交互限定区域。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<h2 id="BFC的触发"><a href="#BFC的触发" class="headerlink" title="BFC的触发"></a>BFC的触发</h2><p>body 根元素或包含根元素的元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
<h2 id="BFC的运用"><a href="#BFC的运用" class="headerlink" title="BFC的运用"></a>BFC的运用</h2><p>同一个 BFC 下外边距会发生折叠<br>BFC 可以包含浮动的元素（清除浮动）（父容器设置为overflow: hidden;即可清除浮动）<br>BFC 可以阻止元素被浮动元素覆盖（为原本被覆盖的元素设置overflow: hidden;是该元素触发BFC解决问题）<br><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">10 分钟理解 BFC 原理</a></p>
<h1 id="Banner如何平滑的从最后一张过渡到第一张"><a href="#Banner如何平滑的从最后一张过渡到第一张" class="headerlink" title="Banner如何平滑的从最后一张过渡到第一张"></a>Banner如何平滑的从最后一张过渡到第一张</h1><p>1.如有1,2,3,4张banner需要轮播，对应图片顺序为：4,1,2,3,4,1<br>2.动画结束后改变left定位到前面的1，这个过程页面看不出变化。<br><a href="https://segmentfault.com/q/1010000002585081/a-1020000002585201" target="_blank" rel="noopener">图片轮播，第一张图片和最后一张图片怎么过渡？</a></p>
<h1 id="Event-Loop（浏览器环境）"><a href="#Event-Loop（浏览器环境）" class="headerlink" title="Event Loop（浏览器环境）"></a>Event Loop（浏览器环境）</h1><p>定义：为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。即事件循环，是JavaScript引擎处理异步任务的方式。为了让单线程的JavaScript通畅的跑起来，所有的异步操作都要被合适的处理，这个处理逻辑就叫做Event Loop。<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">HTML标准-Event loops</a></p>
<h2 id="堆、栈、队列"><a href="#堆、栈、队列" class="headerlink" title="堆、栈、队列"></a>堆、栈、队列</h2><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>堆（heap）是指程序运行时申请的动态内存，在JS运行时用来存放对象。</p>
<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>栈（stack）遵循的原则是“先进后出”，JS种的基本数据类型与指向对象的地址存放在栈内存中，此外还有一块栈内存用来执行JS主线程–执行栈（execution context stack），这里只考虑执行栈。</p>
<h3 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h3><p>队列（queue）遵循的原则是“先进先出”，JS中除了主线程之外还存在两个“任务队列”（微任务队列microTask和宏任务队列macroTask）。</p>
<h2 id="js中的两个队列"><a href="#js中的两个队列" class="headerlink" title="js中的两个队列"></a>js中的两个队列</h2><p>在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。<br>MicroTask: process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver<br>MacroTask: script(同步代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering（浏览器独有）<br>javascript执行：总的执行顺序为同步代码script—&gt;microTask—&gt;其他macroTask，在执行microTask、macroTask是产生新的异步操作，如此一来就形成了循环。<br>具体来说，浏览器会不断从task队列中按顺序取task执行，每执行完一个task都会检查microtask队列是否为空（执行完一个task的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去task队列中取下一个task执行，以此类推。</p>
<h2 id="Philip-Roberts的演讲《Help-I’m-stuck-in-an-event-loop》的event-loop-图"><a href="#Philip-Roberts的演讲《Help-I’m-stuck-in-an-event-loop》的event-loop-图" class="headerlink" title="Philip Roberts的演讲《Help, I’m stuck in an event-loop》的event-loop 图"></a>Philip Roberts的演讲《Help, I’m stuck in an event-loop》的event-loop 图</h2><p><img src="http://p677fntmi.bkt.clouddn.com/162385d14ae83726" alt="Philip Roberts的演讲《Help, I&#39;m stuck in an event-loop》"><br>PS：在执行MicroTask和MacroTask时，如果产生了新的MicroTask则会在本次Event Loop中执行，产生的MacroTask会在下个Event Loop中执行。（更新于2018-09-12）<br><a href="https://juejin.im/post/5b8f76675188255c7c653811" target="_blank" rel="noopener">带你彻底弄懂Event Loop</a></p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><blockquote>
<p>   当主线程运行的时候,JS会产生堆和栈(执行栈)<br>主线程中调用的webaip所产生的异步操作(dom事件、ajax回调、定时器等)只要产生结果，就把这个回调塞进“任务队列”中等待执行。<br>当主线程中的同步任务执行完毕，系统就会依次读取“任务队列”中的任务，将任务放进执行栈中执行。<br>执行任务时可能还会产生新的异步操作，会产生新的循环，整个过程是循环不断的。<br><a href="https://juejin.im/post/5aab2d896fb9a028b86dc2fd" target="_blank" rel="noopener">JavaScript 运行机制–Event Loop详解</a><br><a href="https://segmentfault.com/a/1190000013861128" target="_blank" rel="noopener">一篇文章教会你Event loop——浏览器和Node</a></p>
</blockquote>
<h1 id="Event-Loop（Node环境）"><a href="#Event-Loop（Node环境）" class="headerlink" title="Event Loop（Node环境）"></a>Event Loop（Node环境）</h1><p>Node使用了libuv库来实现Event loop。</p>
<h2 id="Event-Loop顺序"><a href="#Event-Loop顺序" class="headerlink" title="Event Loop顺序"></a>Event Loop顺序</h2><p>nodejs的event loop分为6个阶段，它们会按照顺序反复运行，分别如下：</p>
<ol>
<li>timers：执行setTimeout() 和 setInterval()中到期的callback。</li>
<li>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</li>
<li>idle, prepare：队列的移动，仅内部使用</li>
<li>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</li>
<li>check：执行setImmediate的callback</li>
<li>close callbacks：执行close事件的callback，例如socket.on(“close”,func)<br><img src="http://p677fntmi.bkt.clouddn.com/690666428-5ab0a22b5cbca_articlex.png" alt="Node-Event Loop"><br>不同于浏览器的是，在每个阶段完成后，而不是MacroTask任务完成后，microTask队列就会被执行。这就导致了同样的代码在不同的上下文环境下会出现不同的结果。<br>另外需要注意的是，如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。<br><a href="https://segmentfault.com/a/1190000013861128" target="_blank" rel="noopener">一篇文章教会你Event loop——浏览器和Node</a></li>
</ol>
<h1 id="RegExp相关知识点"><a href="#RegExp相关知识点" class="headerlink" title="RegExp相关知识点"></a>RegExp相关知识点</h1><p>RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配[2018-03-27]。</p>
<h2 id="正则flags的说明"><a href="#正则flags的说明" class="headerlink" title="正则flags的说明"></a>正则flags的说明</h2><p>g–全局匹配;找到所有匹配，而不是在第一个匹配后停止<br>i–忽略大小写<br>m–多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处<br>u–Unicode; 将模式视为Unicode序列点的序列<br>y–粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)</p>
<h2 id="正则表达式中特殊字符的含义"><a href="#正则表达式中特殊字符的含义" class="headerlink" title="正则表达式中特殊字符的含义"></a>正则表达式中特殊字符的含义</h2><h3 id="字符类别（Character-Classes）"><a href="#字符类别（Character-Classes）" class="headerlink" title="字符类别（Character Classes）"></a>字符类别（Character Classes）</h3><h4 id><a href="#" class="headerlink" title="."></a>.</h4><p>点号，小数点，匹配任意单个字符（但不包括行结束符\n \r等）。<br>例如，/.y/ 匹配 “yes make my day” 中的 “my” 和 “ay”，但是不匹配 “yes”。</p>
<h4 id="d"><a href="#d" class="headerlink" title="\d"></a>\d</h4><p>匹配任意阿拉伯数字。等价于[0-9]。<br>例如，/\d/ 或 /[0-9]/ 匹配 “B2 is the suite number.” 中的 ‘2’。 </p>
<h4 id="D"><a href="#D" class="headerlink" title="\D"></a>\D</h4><p>匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。<br>例如，/\D/ 或 /[^0-9]/ 匹配 “B2 is the suite number.” 中的 ‘B’。<br>PS：由于没有全局匹配，只能匹配到一个’B’就结束匹配。</p>
<h4 id="w"><a href="#w" class="headerlink" title="\w"></a>\w</h4><p>匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。<br>例如，/\w/ 匹配 “apple” 中的 ‘a’，”$5.28” 中的 ‘5’ 和 “3D” 中的 ‘3’。</p>
<h4 id="W"><a href="#W" class="headerlink" title="\W"></a>\W</h4><p>匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9_]。<br>例如，/\W/ 或 /[^A-Za-z0-9_]/ 匹配 “50%” 中的 ‘%’。</p>
<h4 id="s"><a href="#s" class="headerlink" title="\s"></a>\s</h4><p>匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。<br>例如 /\s\w*/ 匹配 “foo bar” 中的 ‘ bar’。</p>
<h4 id="S"><a href="#S" class="headerlink" title="\S"></a>\S</h4><p>匹配一个非空白符。<br>例如，/\S\w*/ 匹配 “foo bar” 中的 ‘foo’。<br>PS：经常使用[\s\S]来匹配所有字符。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>\t    匹配一个水平制表符（tab）<br>\r    匹配一个回车符（carriage return）<br>\n    匹配一个换行符（linefeed）<br>\v    匹配一个垂直制表符（vertical tab）<br>\f    匹配一个换页符（form-feed）<br>[\b]    匹配一个退格符（backspace）（不要与 \b 混淆）<br>\0    匹配一个 NUL 字符。不要在此后面跟小数点。<br>\xhh    匹配编码为 hh （两个十六进制数字）的字符。<br>\uhhhh    匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。<br>\      发生转义<br>例如，<em> 是一个特殊字符，表示匹配某个字符 0 或多次，如 /a</em>/ 意味着 0 或多个 “a”。 为了匹配字面意义上的 <em> ，在它前面加上一个反斜杠，例如，/a\</em>/匹配 ‘a*’。</p>
<h2 id="字符集合（Character-Sets）"><a href="#字符集合（Character-Sets）" class="headerlink" title="字符集合（Character Sets）"></a>字符集合（Character Sets）</h2><h3 id="xyz"><a href="#xyz" class="headerlink" title="[xyz]"></a>[xyz]</h3><p>匹配集合中的任意一个字符。你可以使用连字符’-‘指定一个范围。<br>例如，[abcd] 等价于 [a-d]，匹配”brisket”中的’b’和”chop”中的’c’。</p>
<h3 id="xyz-1"><a href="#xyz-1" class="headerlink" title="[^xyz]"></a>[^xyz]</h3><p>一个反义或补充字符集，也叫反义字符组。<br>例如，[^abc] 等价于 [^a-c]。 第一个匹配的是 “bacon” 中的’o’ 和 “chop” 中的 ‘h’。</p>
<h2 id="边界（Boundaries）"><a href="#边界（Boundaries）" class="headerlink" title="边界（Boundaries）"></a>边界（Boundaries）</h2><h3 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h3><p>匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。<br>例如，/^A/ 不匹配 “an A” 中的 “A”，但匹配 “An A” 中的 “A”。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h3><p>匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。<br>例如，/t$/ 不匹配 “eater” 中的 “t”，但匹配 “eat” 中的 “t”。</p>
<h3 id="b"><a href="#b" class="headerlink" title="\b"></a>\b</h3><p>如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪婪模式。所谓的惰性模式就是一旦匹配到合适的就结束，不在继续匹配下去了。</p>
<h2 id="分组（Grouping）与反向引用（back-references）"><a href="#分组（Grouping）与反向引用（back-references）" class="headerlink" title="分组（Grouping）与反向引用（back references）"></a>分组（Grouping）与反向引用（back references）</h2><h3 id="先行断言（lookahead）"><a href="#先行断言（lookahead）" class="headerlink" title="先行断言（lookahead）"></a>先行断言（lookahead）</h3><h4 id="先行肯定断言"><a href="#先行肯定断言" class="headerlink" title="先行肯定断言"></a>先行肯定断言</h4><p>x(?=y)<br>只有当 x 后面紧跟着 y 时，才匹配 x。<br>/Jack(?=Sprat|Frost)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 或 ‘Frost’ 时，才会匹配它。然而，’Sprat’ 或 ‘Frost’ 都不是匹配结果的一部分。</p>
<h4 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h4><p>x(?!y)<br>只有当 x 后面不是紧跟着 y 时，才匹配 x。<br>只有当 x 后面不是紧跟着 y 时，才匹配 x。例如，/\d+(?!.)/ 只有当一个数字后面没有紧跟着一个小数点时，才会匹配该数字。/\d+(?!.)/.exec(“3.141”) 匹配 141 而不是 3.141。</p>
<h3 id="后行断言（lookbehind）"><a href="#后行断言（lookbehind）" class="headerlink" title="后行断言（lookbehind）"></a>后行断言（lookbehind）</h3><p>这是ES2018新加的标准</p>
<h4 id="后行肯定断言"><a href="#后行肯定断言" class="headerlink" title="后行肯定断言"></a>后行肯定断言</h4><p>(?&lt;=y)x<br>只有当 x 前面紧跟 y 时，才匹配 x。<br>例如：/(?&lt;=\$)\d+/.exec(‘$1000’) // 1000</p>
<h4 id="后行否定断言"><a href="#后行否定断言" class="headerlink" title="后行否定断言"></a>后行否定断言</h4><p>(?&lt;!y)x<br>只有当 x 前面紧不是跟 y 时，才匹配 x。<br>例如：/(?&lt;!\$)\d+/.exec(‘$99¥1000’) // 99</p>
<h1 id="获取元素的尺寸"><a href="#获取元素的尺寸" class="headerlink" title="获取元素的尺寸"></a>获取元素的尺寸</h1><h2 id="window-getComputedStyle-element-pseudoElt"><a href="#window-getComputedStyle-element-pseudoElt" class="headerlink" title="window.getComputedStyle(element, [pseudoElt])"></a>window.getComputedStyle(element, [pseudoElt])</h2><p>定义：Window.getComputedStyle() 方法给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算。<br>参数：<br>element<br>    用于获取计算样式的Element<br>pseudoElt 可选<br>    指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。<br>返回：返回的样式是一个实时的 CSSStyleDeclaration 对象，当元素的样式更改时，它会自动更新本身。<br>兼容性处理：window.getComputedStyle ? window.getComputedStyle(ele, null) : ele.currentStyle<br>可以通过height属性和getPropertyValue(“height”)获取height值。</p>
<h2 id="elem-getBoundingClientRect"><a href="#elem-getBoundingClientRect" class="headerlink" title="elem.getBoundingClientRect()"></a>elem.getBoundingClientRect()</h2><p>定义：Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。<br>返回：top、right、bottom、left（相对于视口）width、right。</p>
<h2 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h2><p>content+padding：clientWidth\clientHeight<br>content+padding+border: offsetWidth\offsetHeight</p>
<h1 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h1><p>定义：埋点分析，是网站分析的一种常用的数据采集方法。数据埋点分为初级、中级、高级三种方式。数据埋点是一种良好的私有化部署数据采集方式。<br>实现步骤：埋点阶段 -&gt; 数据收集阶段 -&gt; 后端处理阶段</p>
<h2 id="买点分类"><a href="#买点分类" class="headerlink" title="买点分类"></a>买点分类</h2><h3 id="适合前端埋点"><a href="#适合前端埋点" class="headerlink" title="适合前端埋点"></a>适合前端埋点</h3><ol>
<li>运营初级阶段，产品功能相对简单（无明确业务数据、交易数据，仅通过UV、PV、点击量等基本指标分析即可满足需求）</li>
<li>需求分析与后端没有交互的前端行为（运营人员工作需要判断前端界面设计是否合理）<h3 id="适合后端埋点"><a href="#适合后端埋点" class="headerlink" title="适合后端埋点"></a>适合后端埋点</h3></li>
<li>追求精细化运营，需要进行多维度数据分析</li>
<li>包含用户资产、用户账户、风控辅助数据等重点业务数据</li>
<li>对数据安全性要求比较高</li>
<li>前端和后端都可以采集到的数据，应优先考虑后端埋点<h2 id="前端埋点（实现步骤）"><a href="#前端埋点（实现步骤）" class="headerlink" title="前端埋点（实现步骤）"></a>前端埋点（实现步骤）</h2><h3 id="埋点-1"><a href="#埋点-1" class="headerlink" title="埋点"></a>埋点</h3>以Google Analytics分析为例<br>在页面上插入一段js代码，被称为埋点代码。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    var _maq = _maq || []; // 全局的数组，放采集到的数据 </span><br><span class="line">    _maq.push([&apos;_setAccount&apos;, &apos;uuid&apos;]); // 默认放了_setAccount用于设置网站标识ID，这个标识ID是在注册GA时分配的。 </span><br><span class="line">    (function () &#123;  </span><br><span class="line">        var ma = document.createElement(&apos;script&apos;);  </span><br><span class="line">        ma.type = &apos;text/javascript&apos;;  </span><br><span class="line">        ma.async = true;  </span><br><span class="line">        ma.src = &quot;http://localhost:8091/data/js/ma.js&quot;;  </span><br><span class="line">        var s = document.getElementsByTagName(&apos;script&apos;)[0];  </span><br><span class="line">        s.parentNode.insertBefore(ma, s);  </span><br><span class="line">    &#125;)();  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：匿名函数，这段代码的主要目的就是引入一个外部的js文件（ga.js），方式是通过document.createElement方法创建一个script并根据协议（http或https）将src指向对应的ga.js，最后将这个element插入页面的dom树上。<br>注意ga.async = true的意思是异步调用外部js文件，即不阻塞浏览器的解析，待外部js下载完成后异步执行。这个属性是HTML5新引入的。</p>
<h3 id="数据采集（之前动态插入的ma-js）"><a href="#数据采集（之前动态插入的ma-js）" class="headerlink" title="数据采集（之前动态插入的ma.js）"></a>数据采集（之前动态插入的ma.js）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var params = &#123;&#125;;</span><br><span class="line">    //Document对象数据</span><br><span class="line">    if(document) &#123;</span><br><span class="line">        params.domain = document.domain || &apos;&apos;; </span><br><span class="line">        params.url = document.URL || &apos;&apos;; </span><br><span class="line">        params.title = document.title || &apos;&apos;; </span><br><span class="line">        params.referrer = document.referrer || &apos;&apos;; </span><br><span class="line">    &#125;   </span><br><span class="line">    //Window对象数据</span><br><span class="line">    if(window &amp;&amp; window.screen) &#123;</span><br><span class="line">        params.sh = window.screen.height || 0;</span><br><span class="line">        params.sw = window.screen.width || 0;</span><br><span class="line">        params.cd = window.screen.colorDepth || 0;</span><br><span class="line">    &#125;   </span><br><span class="line">    //navigator对象数据</span><br><span class="line">    if(navigator) &#123;</span><br><span class="line">        params.lang = navigator.language || &apos;&apos;; </span><br><span class="line">    &#125;   </span><br><span class="line">    //解析_maq配置</span><br><span class="line">    if(_maq) &#123;</span><br><span class="line">        for(var i in _maq) &#123;</span><br><span class="line">            switch(_maq[i][0]) &#123;</span><br><span class="line">                case &apos;_setAccount&apos;:</span><br><span class="line">                    params.account = _maq[i][1];</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    //拼接参数串</span><br><span class="line">    var args = &apos;&apos;; </span><br><span class="line">    for(var i in params) &#123;</span><br><span class="line">        if(args != &apos;&apos;) &#123;</span><br><span class="line">            args += &apos;&amp;&apos;;</span><br><span class="line">        &#125;   </span><br><span class="line">        args += i + &apos;=&apos; + encodeURIComponent(params[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    //通过Image对象请求后端脚本</span><br><span class="line">    var img = new Image(1, 1); </span><br><span class="line">    img.src = &apos;http://analytics.codinglabs.org/1.gif?&apos; + args;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>PS：为什么使用图片请求后端controller而不是ajax直接访问？原因在于ajax不能跨域请求，ma.js和后端分析的代码可能不在相同的域内，ajax做不到，而将image对象的src属性指向后端脚本并携带参数，就轻松实现了跨域请求。</p>
<h3 id="后端处理"><a href="#后端处理" class="headerlink" title="后端处理"></a>后端处理</h3><p>后端脚本一般做下面几件事：<br>（1）解析http请求参数的到信息。<br>（2）从服务器（WebServer）中获取一些客户端无法获取的信息，如访客ip等。<br>（3）将信息按格式写入log。<br>（4）生成一副1×1的空gif图片作为响应内容并将响应头的Content-type设为image/gif。<br>（5）在响应头中通过Set-cookie设置一些需要的cookie信息（作为跟踪唯一访客）。<br><a href="http://www.woshipm.com/data-analysis/665420.html" target="_blank" rel="noopener">前端埋点和后端埋点，哪个更科学？</a><br><a href="https://blog.csdn.net/hxyascx/article/details/53373916" target="_blank" rel="noopener">用户行为日志-js埋点（一）实现整体流程</a><br><a href="https://mixpanel.com/help/reference/javascript" target="_blank" rel="noopener">开源埋点库MixPanel</a></p>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>文件(File) 接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。</p>
<h2 id="files属性"><a href="#files属性" class="headerlink" title="files属性"></a>files属性</h2><p>用于获取当前文件数组相关的信息，每个元素有下列属性（均为只读属性）。<br>File.lastModified<br>File.name<br>File.size 单位为B。<br>File.webkitRelativePath<br>File.type 返回文件的 多用途互联网邮件扩展类型 </p>
<h2 id="FileReader-构造函数"><a href="#FileReader-构造函数" class="headerlink" title="FileReader() 构造函数"></a>FileReader() 构造函数</h2><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>FileReader.abort()<br>该方法可以取消 FileReader 的读取操作，触发之后 readyState 为已完成（DONE）。<br>FileReader.readAsArrayBuffer()<br>开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.<br>FileReader.readAsBinaryString()<br>开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。<br>FileReader.readAsBinaryString()<br>开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。<br>FileReader.readAsText()<br>开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。</p>
<h1 id="前端错误收集"><a href="#前端错误收集" class="headerlink" title="前端错误收集"></a>前端错误收集</h1><h2 id="window-onerror（大部分的错误）"><a href="#window-onerror（大部分的错误）" class="headerlink" title="window.onerror（大部分的错误）"></a>window.onerror（大部分的错误）</h2><p>window.onerror = function(message, source, lineno, colno, error) { … }<br>PS：</p>
<ol>
<li>由于网络请求异常事件不会冒泡，需要在捕获阶段进行处理</li>
<li>不能捕获promise的错误信息</li>
<li>跨域资源需要专门处理，需要在script标签加上crossorigin属性，服务器设置Access-Control-Allow-Origin</li>
<li>window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</li>
</ol>
<h2 id="promise的错误处理"><a href="#promise的错误处理" class="headerlink" title="promise的错误处理"></a>promise的错误处理</h2><p>promise除了使用catch方法来捕获错误，还可以使用window的unhandledrejection事件捕获异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function (event) &#123;</span><br><span class="line">  console.warn(&quot;WARNING: Unhandled promise rejection. Shame on you! Reason: &quot;</span><br><span class="line">               + event.reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><p>try catch只能捕获同步代码的异常，对回调，setTimeout，promise等无能为力</p>
<h2 id="上报错误"><a href="#上报错误" class="headerlink" title="上报错误"></a>上报错误</h2><ol>
<li>后端提供接口，前端ajax上传</li>
<li>创建一个新的图片，url参数带上错误信息（跨域）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function report(error) &#123;</span><br><span class="line">  var reportUrl = &apos;http://xxxx/report&apos;;</span><br><span class="line">  new Image().src = reportUrl + &apos;error=&apos; + error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.aliued.com/?p=4162" target="_blank" rel="noopener">阿里UED前端监控</a></p>
<h1 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h1><p>引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-cool-new-app</span><br></pre></td></tr></table></figure></p>
<p>这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。</p>
<h1 id="判断浏览器对某个css3是否支持"><a href="#判断浏览器对某个css3是否支持" class="headerlink" title="判断浏览器对某个css3是否支持"></a>判断浏览器对某个css3是否支持</h1><h2 id="‘样式属性名’-in-document-documentElement-style"><a href="#‘样式属性名’-in-document-documentElement-style" class="headerlink" title="‘样式属性名’ in document.documentElement.style"></a>‘样式属性名’ in document.documentElement.style</h2><p>‘transform’ in document.documentElement.style // true<br>PS：兼容性较好，ie6+</p>
<h2 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h2><p>此方法为css属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@supports (display: flex) &#123;</span><br><span class="line">	div &#123; display: flex; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@supports not (display: flex) &#123;</span><br><span class="line">	div &#123; float: left; &#125; /* 替换样式 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常关系链接符有 not、or、and等</p>
<h2 id="CSS-supports"><a href="#CSS-supports" class="headerlink" title="CSS.supports"></a>CSS.supports</h2><p>CSS.supports(propertyName, value) || CSS.supports(supportCondition)<br>CSS.supports() 静态方法返回一个Boolean值，用来校验浏览器是否支持一个给定的CSS特性。<br>该方法有两种参数形式：</p>
<ol>
<li>propertyName：属性名，value：属性值。</li>
<li>supportCondition：需要一个匹配@supports条件的参数。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = CSS.supports(&apos;(--foo: red)&apos;); // true第一种形式</span><br><span class="line">result = CSS.supports(&quot;( transform-origin: 5% 5% )&quot;); // true第二种形式</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者模式（Decorator Pattern）：在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象。<br>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。<br>装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//需要装饰的类（函数）</span><br><span class="line">function Macbook() &#123;</span><br><span class="line"> this.cost = function () &#123;</span><br><span class="line">  return 1000;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br><span class="line">//计算商品的包装费</span><br><span class="line">function PackagingFee(macbook) &#123;</span><br><span class="line"> this.cost = function () &#123;</span><br><span class="line">  return macbook.cost() + 75;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">//计算商品的运费</span><br><span class="line">function Freight(macbook) &#123;</span><br><span class="line"> this.cost = function () &#123;</span><br><span class="line">  return macbook.cost() + 300;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let money1 = new Macbook()  // 只包含mac 1000</span><br><span class="line">let money2 = new PackagingFee(new Macbook()) // 只包含mac + 包装费 1075 </span><br><span class="line">let money4 = new Freight(new Macbook()) // 只包含mac + 运费 1300</span><br><span class="line">let money3 = new Freight(new PackagingFee(new Macbook())) // 包含mac + 包装费 + 运费 1375</span><br></pre></td></tr></table></figure></p>
<h1 id="touchstart-和-click-的坑"><a href="#touchstart-和-click-的坑" class="headerlink" title="touchstart 和 click 的坑"></a>touchstart 和 click 的坑</h1><h2 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tap = &apos;ontouchstart&apos; in window ? &apos;touchstart&apos; : &apos;click&apos;;</span><br><span class="line">wrap.addEvenListener(tap, function()&#123;</span><br><span class="line">    signUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过上面代码简单为用户设置事件类型，但我们忽略了‘联想触控笔记本’，<span color="color: red">由于该笔记本支持‘touchstart’事件，但当用户使用鼠标时却不能触发‘touchstart’事件</span>，造成不能触发对应的事件处理函数。</p>
<ol>
<li>有些 PC 设备屏幕为触摸屏，同时支持touchstart和click事件；</li>
<li>用户触发touchstart事件，默认必然会导致触发click事件，但是触发click事件，不一定会导致touchstart事件被触发；</li>
<li>此类设备外接鼠标时，通过上面的绑定方式，会绑定touchstart事件，但是鼠标操作只能触发click，导致touchstart不触发；</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="均使用click事件（移动端存在300ms延迟）"><a href="#均使用click事件（移动端存在300ms延迟）" class="headerlink" title="均使用click事件（移动端存在300ms延迟）"></a>均使用click事件（移动端存在300ms延迟）</h3><h3 id="通过UA判断设备是否为移动端，再确认事件类型"><a href="#通过UA判断设备是否为移动端，再确认事件类型" class="headerlink" title="通过UA判断设备是否为移动端，再确认事件类型"></a>通过UA判断设备是否为移动端，再确认事件类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isMobile() &#123;</span><br><span class="line">    return navigator.userAgent.match(/(blackberry|configuration\/cldc|hp |hp-|htc |htc_|htc-|iemobile|kindle|midp|mmp|motorola|mobile|nokia|opera mini|opera |Googlebot-Mobile|YahooSeeker\/M1A1-R2D2|android|iphone|ipod|mobi|palm|palmos|pocket|portalmmm|ppc;|smartphone|sonyericsson|sqh|spv|symbian|treo|up.browser|up.link|vodafone|windows ce|xda |xda_)/i) ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"> var tap = isMobile() ? &apos;touchstart&apos; : &apos;click&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="全部使用click，通过FastClick解决300毫秒的延迟问题"><a href="#全部使用click，通过FastClick解决300毫秒的延迟问题" class="headerlink" title="全部使用click，通过FastClick解决300毫秒的延迟问题"></a>全部使用click，通过FastClick解决300毫秒的延迟问题</h3><h3 id="不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。"><a href="#不再绑定的时候进行判断，而是对touchstart-和-click-同时绑定，但是在-touchstart-触发的时候暂停取消后续-click-的响应。" class="headerlink" title="不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。"></a>不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。</h3><p>具体实现：</p>
<ol>
<li>在touchstart事件响应中调用preventDefault()方法，阻止后续click事件的触发（也会阻止多个事件绑定叠加和多人合作项目，导致以来 click 事件出现bug）</li>
<li>在touchstart事件中设置一些标记，或者取消click事件的绑定，使得click事件触发时不会触发我们绑定的逻辑，在一段时间（例如300-500ms）后再恢复</li>
<li>直接对事件处理函数进行节流（throttle），保证在一段时间内（300ms - 500ms），事件处理函数只触发一次</li>
</ol>
<h1 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h1><p>defer：载入 JavaScript 文件时不阻塞 HTML 的解析（并行），执行阶段被放到 HTML 标签解析完成之后（DOMContentLoaded之前）。<br>async：与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后，但一定在load触发之前执行。</p>
<h1 id="从输入url到页面渲染优化"><a href="#从输入url到页面渲染优化" class="headerlink" title="从输入url到页面渲染优化"></a>从输入url到页面渲染优化</h1><h2 id="大值步骤"><a href="#大值步骤" class="headerlink" title="大值步骤"></a>大值步骤</h2><p>DNS域名解析-&gt;建立TCP连接-&gt;下载资源-&gt;解析页面</p>
<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>将人们习惯使用的域名，映射为对应的ip，机器之间只能识别ip地址。<br>域名解析的步骤：以<a href="http://www.baidu.com为例" target="_blank" rel="noopener">www.baidu.com为例</a><br>1、浏览器缓存：浏览器会按照一定的频率缓存DNS记录。<br>2、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找（hosts文件）。<br>3、路由缓存：路由器也有DNS缓存(可能存在)。<br>4、ISP的DNS服务器：ISP是互联网服务提供商(Internet Service Provider)的简称，ISP有专门的DNS服务器应对DNS查询请求。<br>5、根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.域名服务器的IP地址，然后再问.com顶级域名服务器，依次类推）。<br>PS：以<a href="http://www.baidu.com为例说明根域名、顶级域名、一级域名等" target="_blank" rel="noopener">www.baidu.com为例说明根域名、顶级域名、一级域名等</a><br>根域名：为’.’,全球共13个ip地址（并不是13台机器）。<br>顶级域名(一级域名)：为<a href="http://www.baidu.com的顶级域名为baidu.com，主机名为www。" target="_blank" rel="noopener">www.baidu.com的顶级域名为baidu.com，主机名为www。</a><br>二级域名：a.<a href="http://www.baidu.com的二级域名为www.baidu.com，主机名为a。" target="_blank" rel="noopener">www.baidu.com的二级域名为www.baidu.com，主机名为a。</a><br>优化方案：域名预解析<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 告知浏览器, 当前页面要做DNS预解析</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br><span class="line">// 强制对DNS预解析（本网页需要跳转的页面，注意避免多页面重复DNS解析）</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><p>经过域名解析，浏览器拿到了服务器的IP。<br>TCP建立连接的三次握手：<br>客户端创建socket，向服务器目标端口发送连接建立请求，数据段包含位码SYN（建立联机标志位） = 1，随机数seq（顺序号码）= x，和其他TCP标志和选项。<br>服务器有一个专门处理连接请求的welcome socket，接收到连接建立请求，置位码SYN和ACK（确认标志位）为1，ack（确认号码）= x + 1，随机数seq = y，并返回。<br>客户端检查ack是否等于x + 1，等于时，将ACK置为1，SYN置为0，将ack置为y + 1发送至服务器端。<br>welcome socket检查ack等于y + 1和ACK等于1后，创建新的socket，此socket由源IP/源端口、目标IP/目标端口标识，之后客户端发送的数据都被引导向此新的socket，至此，TCP连接建立。<br>优化方案：<br>减少数据往返延迟（地理位置远近关系）可以使用CDN（客户端访问域名到距离最近的服务器）。<br>使用HTTP2（多路复用 (Multiplexing)）、header压缩（减少传输数据大小）、服务端推送（server push）（有时只需要服务器发送数据到客户端，不需要客户端-&gt;服务端—&gt;客户端这样一个来回）<br>减少cookie：每次请求都携带了本域的cookie<br>PS：虽然HTTP 1.1有长链接，但资源下载事串行的，所以推荐使用HTTP2的多了复用。</p>
<h2 id="下载资源（接收响应）"><a href="#下载资源（接收响应）" class="headerlink" title="下载资源（接收响应）"></a>下载资源（接收响应）</h2><p>避免不必要的重定向（非缓存重定向），重定向会导致浏览器再进行一次（DNS域名解析-&gt;建立TCP连接-&gt;下载资源-&gt;解析页面）。<br>避免超出并行连接阀值（浏览器会在同域名并行连接限制，一般为6个）</p>
<h2 id="解析页面（webkit工作原理）"><a href="#解析页面（webkit工作原理）" class="headerlink" title="解析页面（webkit工作原理）"></a>解析页面（webkit工作原理）</h2><p>处理HTML标记，构建DOM树。<br>处理CSS标记，构建CSSOM树。<br>将DOM树和CSSOM树融合成渲染树（会忽略不需要渲染的dom）。<br>根据渲染树来布局，计算每个节点的几何信息。<br>在屏幕上绘制各个节点。<br>中间遇到各种资源时，会进行资源的下载。<br>优化：<br>css放head中，js放body尾部，均以外链形式<br>压缩js、css等文件<br>使用CDN技术<br>使用图片精灵、webp、图片base64等<br>首屏优化（按需加载、首屏资源优先加载）<br>避免重排（开启复合层，如使用3d变换、opacity等<a href="http://div.io/topic/1348" target="_blank" rel="noopener">3d硬件加速的坑</a>），减少重绘<br>缓存技术：强缓存（Expires、Cache-Control：max-age=seconds）协商缓存（Last-Modified/If-Modified-Since、ETag/If-None-Match）</p>
<h1 id="CSS2Dtransform和Matrix的关系"><a href="#CSS2Dtransform和Matrix的关系" class="headerlink" title="CSS2Dtransform和Matrix的关系"></a>CSS2Dtransform和Matrix的关系</h1><p>这里transform包括：translate、scale、rotate、skew<br>没有任何变换时：matrix(1, 0, 0, 1, 0, 0)、matrix(a, b, c, d, e, f)<br>translate(30, 30) 等价于 matrix(1, 0, 0, 1, 30, 30)<br>ps：e、f分别表示x轴和y轴偏移距离<br>scale(2, 3) 等价于 matrix(2, 0, 3, 1, 0, 0)<br>ps：a、c分别表示x轴和y轴缩放比例<br>rotate(θ) 等价于 matrix(cosθ,sinθ,-sinθ,cosθ,0,0)<br>ps：a、b、c、d共同决定旋转角度θ<br>skew(θx, θy) 等价于 matrix(1,tan(θy),tan(θx),1,0,0)<br>ps：θx表示x轴倾斜的角度，θy表示y轴</p>
<h1 id="硬编码和非硬编码（软编码）的区别"><a href="#硬编码和非硬编码（软编码）的区别" class="headerlink" title="硬编码和非硬编码（软编码）的区别"></a>硬编码和非硬编码（软编码）的区别</h1><p>软编码可以在运行时确定，修改；而硬编码是不能够改变的。<br>硬编码是指将可变变量用一个固定值来代替的方法，使用这样方法，编译后，如果想更改词变量就变的非常困难。因此， 在大部分的程序语言中，可以将一个固定值定义为一个标记， 然后用这个特殊的标记来取代变量名称。 当标记名称发生改变时， 变量名不变。这样在程序进行编译时，所有的变量都不再是固定值 这样就更容易实现改变变量的目的。</p>
<h1 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h1><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>
<h1 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h1><p>2018-05-28添加<br>定义：IntersectionObserver构造函数为开发者提供了一种可以异步监听目标元素与其祖先或视窗(viewport)交叉状态的手段。祖先元素与视窗(viewport)被称为根(root)。<br>语法：<code>let io = new new IntersectionObserver(callback(entries), options)</code><br>用法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var intersectionObserver = new IntersectionObserver(function(entries) &#123;</span><br><span class="line">  // entries 时一个数组，每个成员都是一个[IntersectionObserverEntry对象](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)。</span><br><span class="line">  if (entries[0].intersectionRatio &lt;= 0) return;</span><br><span class="line">  </span><br><span class="line">  // 元素与祖先元素交叉状态发生改变时触发</span><br><span class="line">  loadItems(10);</span><br><span class="line">  console.log(&apos;Loaded new items&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// start observing</span><br><span class="line">intersectionObserver.observe(document.querySelector(&apos;.scrollerFooter&apos;));</span><br></pre></td></tr></table></figure></p>
<p>属性（options）：<br>root – 所监听对象的具体祖先元素(element)。如果未传入任何值或值为null，则默认使用viewport。<br>rootMargin – 计算交叉时添加到根(root)边界盒bounding box的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。<br>thresholds – 一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0.<br>方法：<br>observe(element) – 使IntersectionObserver开始监听一个目标元素。<br>unobserve(element) – 使IntersectionObserver停止监听特定目标元素。<br>takeRecords() – 为所有监听目标返回一个IntersectionObserverEntry对象数组并且停止监听这些目标。<br>disconnect() – 使IntersectionObserver对象停止监听工作。<br>应用：惰性加载（lazy load）、无限滚动等<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">MDN-Intersection Observer</a><br><a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a><br><a href="https://caniuse.com/#search=IntersectionObserver" target="_blank" rel="noopener">查看浏览器支持情况</a></p>
<h1 id="MutationObserver（异步的）"><a href="#MutationObserver（异步的）" class="headerlink" title="MutationObserver（异步的）"></a>MutationObserver（异步的）</h1><p>2018-05-28添加<br>定义：MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.<br>语法：<code>var observer = new MutationObserver(callback(mutations, observer));</code><br>PS：mutations 为DOM变动数组，observer 为观察器实例。<br>用法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var observer = new MutationObserver(function (mutations, observer) &#123;</span><br><span class="line">  mutations.forEach(function(mutation) &#123;</span><br><span class="line">    console.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var article = document.querySelector(&apos;article&apos;);</span><br><span class="line">var  options = &#123;</span><br><span class="line">  &apos;childList&apos;: true,</span><br><span class="line">  &apos;attributes&apos;:true</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">// start Observer</span><br><span class="line">observer.observe(article, options);</span><br></pre></td></tr></table></figure></p>
<p>方法：<br>observe(element, options) – 给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.<br>PS：target 为观察该节点是否会发生DOM变化.options 为一个MutationObserverInit对象,指定要观察的DOM变化类型.<br>disconnect() – 让该观察者对象停止观察指定目标的DOM变化.直到再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.<br>takeRecords() – 清空观察者对象的记录队列,并返回里面的内容.<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MDN-MutationObserver</a><br><a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="noopener">Mutation Observer API</a></p>
<blockquote>
<p> 参考文档：<br><a href="https://http2.github.io" target="_blank" rel="noopener">HTTP/2</a><br><a href="https://www.cnblogs.com/geaozhang/p/7010353.html" target="_blank" rel="noopener">DNS域名解析的过程</a><br><a href="https://juejin.im/post/5ad578ba6fb9a028cc61b89f" target="_blank" rel="noopener">从输入url开始能做哪些优化</a><br><a href="http://blog.chinaunix.net/uid-28216282-id-3757849.html" target="_blank" rel="noopener">DNS解析过程详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>网页劫持</title>
    <url>/2018/%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81.html</url>
    <content><![CDATA[<p>最近和朋友谈到网页劫持，之前对这个话题还不是很了解。但在我们访问网页是，突然就能被传送到不知所谓的页面，铺满各种“屠龙宝刀点击就送”、“充值XX元就可获得流量大礼包”之类的内容。就算不是页面跳转，网页也有可能被插入额外的广告，无论是去哪个网站都会有一个烦不胜烦的小窗无法消除。</p>
<h1 id="劫持分类"><a href="#劫持分类" class="headerlink" title="劫持分类"></a>劫持分类</h1><p>我们生活中常见的劫持有，DNS劫持（运营商作怪）、路由劫持、代理服务器劫持（这个好理解只提一下）、HTTP劫持、软件劫持。<br>随后我将介绍这些劫持和如何预防这些劫持。</p>
<h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>当用户输入URL直到网页显示，这个过程发生了以下事情，信息首先会通过浏览器发送，然后经路由中转，接着DNS将域名解析成IP，找到服务器后服务器会发送内容给用户，接着再由路由转发数据，最后浏览器将内容呈现给用户（视实际情况，这个过程中还可能存在更多关卡，比如说防火墙、代理服务器等）。<br>由此可见，无论浏览器、路由、DNS、服务器等任一环节中出了叛徒，用户请求的网页就可能惨遭删改。</p>
<h2 id="产生的缘由"><a href="#产生的缘由" class="headerlink" title="产生的缘由"></a>产生的缘由</h2><p>在用户输入URL后到专门的DNS服务器进行查询IP，后面的通信很多都依赖于这个IP地址，如果这个IP地址是错误的呢？<br>为什么说DNS劫持又是运营商劫持呢？运营商目前竞争比较激烈，为了进一步推广业务，或者进行额外的创收，一些管理不严的二线运营商或者运营商的分部，就会在DNS解析上动歪脑筋了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>选择可靠的DNS服务器，例如奇虎360、诺顿、Comodo、百度、阿里、Google等企业，都有提供DNS解析服务，你也可以选择<a href="https://welcome.opendns.com/oops/" target="_blank" rel="noopener">Open DNS</a>这样的老牌免费DNS服务。<br>还可以向运营商投诉，如果运营上不处理，可以直接向<a href="http://www.chinatcc.gov.cn/" target="_blank" rel="noopener">工信部投诉</a>。</p>
<h1 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>DNS劫持一般会替换调整个网页（返回的IP地址不对哒嘛），与DNS劫持不同的是网页劫持往往只是在页面上添加一个小窗，但这小窗并不属于网页本身的广告，有时候无论你访问什么网页，这小窗都不会消失，甚是烦人。</p>
<h2 id="产生的缘由-1"><a href="#产生的缘由-1" class="headerlink" title="产生的缘由"></a>产生的缘由</h2><p>HTTP劫持的原理就是在服务器和用户之间的信息传输之中添油加醋，这是由于信息没有被加密而造成的。用户请求了网站服务器，服务器返还网页给用户，在传输过程中就给了他人加料的机会。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>将网页升级为HTTPS的连接是最有效的方法，使用HTTPS之后，在传输数据过程中，数据是加密的，在传输过程中就很难被篡改了。<br>HTTPS不仅可以防止HTTP劫持，也能够较好地防止DNS劫持，这是由于HTTPS的安全是由SSL来保证的，需要正确的证书，连接才会成立。如果DNS把域名解析到了不对应的IP，是无法通过证书认证的，连接会被终止。</p>
<h1 id="路由劫持"><a href="#路由劫持" class="headerlink" title="路由劫持"></a>路由劫持</h1><p>在我们的发送request和接受response，都会经过路由，路由器其实也会进行网页劫持。例如小米路由器，就曾经做过劫持网页的事情。虽然性质不严重，没有张贴引人注目的广告，只是把404之类的页面替换成自家网页，但这总归是不对的。<br>这个解决办法，只能购买靠谱和权威厂家的路由了。</p>
<h1 id="软件劫持"><a href="#软件劫持" class="headerlink" title="软件劫持"></a>软件劫持</h1><p>有的同学可能使用过一些软件来全局的清除广告，但是，这是通过全局流量管控来实现的，电脑所有的网络流量都会经由去广告软件之手，因此软件要进行网页劫持，也是轻而易举的事情。例如，著名的去广告软件<a href="http://www.ad-safe.com/" target="_blank" rel="noopener">AD safe</a>，就干过劫持网页的事情。<br>由此可见，使用三方去广告软件也不是很靠谱，还请读者自我分辨。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作原理-webkit内核研究</title>
    <url>/2018/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</url>
    <content><![CDATA[<p>从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。<br>主要查阅了<a href="https://book.douban.com/subject/25910556/" target="_blank" rel="noopener">WebKit技术内幕</a>、<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a>、<a href="https://www.w3.org/" target="_blank" rel="noopener">W3C</a>等网站资料，下文中有若干图片摘自于《WebKit技术内幕》，在此表示感谢。<br>本文略长，如有不适，实属意外。如有不正确的地方，还望指正，毕竟传播真理才不会误导其他同学，共同进步才是目的。</p>
<h1 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h1><p>浏览器内核由渲染引擎和JS引擎组成，不同的浏览器、即使同一浏览器不同型号可能渲染引擎和JS引擎都不一样。</p>
<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>1)Trident渲染引擎 –&gt; 老版本IE系列浏览器<br>2)Edge渲染引擎 -&gt; Win10中IE浏览器<br>3)Gecko渲染引擎 –&gt; Mozilla Firefox<br>4)Presto渲染引擎 –&gt; Opera<br>5)KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome<br>6)Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器<br>7)Blink渲染引擎 -&gt; 新版本的Chromium浏览器Google项目</p>
<h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h2><p>1)JScript引擎 –&gt; IE系列浏览器<br>2)spiderMonkey引擎 –&gt; Mozilla Firefox<br>3)V8引擎 –&gt; Google Chrome<br>4)linear b/futhark引擎 –&gt; Opera</p>
<h2 id="浏览器渲染引擎的进度史"><a href="#浏览器渲染引擎的进度史" class="headerlink" title="浏览器渲染引擎的进度史"></a>浏览器渲染引擎的进度史</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" alt="浏览器渲染引擎的进度史"><br>为大家提供两个开发常用查询网站：<br><a href="http://html5test.com/" target="_blank" rel="noopener">该浏览器对html5的支持程度</a><br><a href="https://caniuse.com" target="_blank" rel="noopener">不同与Can I use</a></p>
<h1 id="浏览器的渲染引擎及依赖模块分析"><a href="#浏览器的渲染引擎及依赖模块分析" class="headerlink" title="浏览器的渲染引擎及依赖模块分析"></a>浏览器的渲染引擎及依赖模块分析</h1><p><img src="http://p4yvw0vpm.bkt.clouddn.com/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%9F%E8%83%BD.png" alt="渲染引擎的功能"><br>上图中虚线部分表示渲染引擎所提供的功能。<br>这里渲染引擎包含了JavaScript引擎，许多时候两者都不太区分。<br>下面的内容大部分都是基于这张图来分析的，我们将逐步解释从用户输入URL到页面展示给用户这个过程中都发生了什么？<br>我们先了解网页的基础知识。</p>
<h1 id="网页基础知识"><a href="#网页基础知识" class="headerlink" title="网页基础知识"></a>网页基础知识</h1><p>html – 结构<br>css – 样式<br>JavaScript – 行为<br>还需要一些静态资源：png、gif、webp、MP4、font、svg等等。<br>由上面几部分就构成我们的网页。</p>
<h2 id="输入URL到页面展示简图"><a href="#输入URL到页面展示简图" class="headerlink" title="输入URL到页面展示简图"></a>输入URL到页面展示简图</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/url%E5%88%B0dom%E6%A0%91.png" alt="URL到页面展示"><br>读者不要太关心上图所标的顺序，在某些时候可能会有出入。</p>
<h2 id="浏览器内核各部分解释"><a href="#浏览器内核各部分解释" class="headerlink" title="浏览器内核各部分解释"></a>浏览器内核各部分解释</h2><blockquote>
<p>   HTML解释器：解释HTML文本的解释器，主要作用是将HTML文本解释成DOM树，DOM是一种文档表示方法。<br>CSS解释器：级联样式表的解释器，它的作用是为DOM中的各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。<br>布局：在DOM创建之后，webkit需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部比偶表示模型。<br>JavaScript引擎：使用JavaScript代码可以修改网页的内容，也能修改CSS的信息，JavaScript引擎能过解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染结果。<br>绘图：使用图形库将布局计算后的各个网页的节点绘制成图像结果。</p>
</blockquote>
<p>PS：这些模块依赖许多其他基础模块，其中包括网络、存储、2D/3D图形、音频视频和图片解码器等。这里就不对基础模块做相应说明了。</p>
<p>下面，我就逐个过程进行分析，我这里省略一些非本文目的的过程，如DNS环节。</p>
<h1 id="HTML解释器"><a href="#HTML解释器" class="headerlink" title="HTML解释器"></a>HTML解释器</h1><p>先来看看HTML解释器工作原理<br><img src="http://p4yvw0vpm.bkt.clouddn.com/html%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="HTML解释器工作原理"><br>字节流（Bytes）–&gt; 字符流（Characters）–&gt; 词语（Tokens）–&gt; 节点 –&gt; DOM树</p>
<blockquote>
<p>   首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），时候经过分析器构建成节点，最后这些节点被组建成一棵DOM树。<br>词法分析：HTMLTokenizer 类（作用是词法分析，类似于状态机），输入的是字符串，输出的是一个个的词语。<br>XSSAuditor验证词语：XSSAuditor （验证词语流Token Stream）XSS指的是Cross Site Security，主要是针对安全方面的考虑。<br>词语到节点：webkit用来构建DOM节点，这一步骤由HTMLDocumentParser 类调用 HTMLTreeBuilder 类的 constructTree的函数来实现。<br>节点到DOM树：树中的元素节点创建属性节点等工作由HTMLConstructionSite类来完成，该类中包含一个 HTMLElementStack 作为保存元素节点的栈。<br>JavaScript的执行：webkit将DOM树创建过程中需要执行得我Javascript代码交由HTMLScriptRunner类来负责。<br>DOM的事件机制：webkit中用EventTarget类来表示DOM规范中Events部分定义的事件目标，Node 节点继承自 EventTarget类，所以Node拥有EventTarget类的相关的方法。</p>
</blockquote>
<p>这里需要提一下W3C新规范，影子（Shadow）DOM<br>Shadow DOM API的 ShadowRoot接口是一个DOM子树的根节点, 它与文档的主DOM树分开渲染。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ShadowRoot" target="_blank" rel="noopener">MDN-影子节点</a></p>
<h2 id="影子（Shadow）DOM"><a href="#影子（Shadow）DOM" class="headerlink" title="影子（Shadow）DOM"></a>影子（Shadow）DOM</h2><p>定义：Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。<br>ShadowRoot 类继承自 DocumentFragment 类。<br>PS：可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.</p>
<h1 id="CSS解释器和样式布局"><a href="#CSS解释器和样式布局" class="headerlink" title="CSS解释器和样式布局"></a>CSS解释器和样式布局</h1><p>先看看CSS怎么和DOM结合展示页面的呢？<br><img src="http://p4yvw0vpm.bkt.clouddn.com/css%E5%92%8Cdom%E6%A0%91%E5%88%B0%E7%BB%98%E5%88%B6%E7%BD%91%E9%A1%B5.png" alt="CSS+DOM形成简单页面"><br>css解释器和规则匹配处于DOM树建立之后，RenderObject树建立之前，css解释器解释后的结果会保存起来，然后RenderObject树基于该结果来进行规范匹配和布局计算。</p>
<h2 id="CSSOM（CSS-Object-Model）"><a href="#CSSOM（CSS-Object-Model）" class="headerlink" title="CSSOM（CSS Object Model）"></a>CSSOM（CSS Object Model）</h2><p>CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动。<br>document.styleSheets 可以查看当前页面的StyleSheetList对象，每个link、style都会产生 CSSStyleSheet 作为 StyleSheetList对象的value。</p>
<h2 id="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"><a href="#CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）" class="headerlink" title="CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）"></a>CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）</h2><p>DocumentStyleSheetCollection类（属于Document类），该类包含了所有CSS样式表，还包括了webkit的内部表示类CSSStyleSheet，它包含了CSS的href、类型、内容等信息。<br>CSS解释过程：css字符串经过css解释器处理后变成渲染引擎的内部规则的过程，使用CSSParser类来负责该过程。<br>在解释网页中自定义的CSS样式之前，实际上webkit渲染引擎会为每个网页设置一个默认样式，这也是我们为什么要重置浏览器样式的根本原因。<br>规则匹配：StyleResolver类为DOM的元素节点匹配样式，StyleResolver类根据元素的信息，例如标签名、类别等，从样式规则中查找最匹配的规则，然后将样式信息保存到新建的RenderStyle对象中。最后，这些RenderStyle对象被RenderObject类所管理和使用。<br>    其中，规则的匹配则是由ElementRuleCollector类来计算并获得，它根据元素的属性等信息，并从DocumentRuleSets类中获取规则集合，依次按照ID、CLASS、标签等选择器信息逐次匹配获得元素的样式。<br>    然后webkit对这些规则进行排序，对于该元素需要的样式属性，webkit选择从高优先级规则中选取，并将样式属性值返回。<br>这里，我引入一个不太相关的知识点，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">不太了解的同学，请异步MDN-BFC</a></p>
<h1 id="webkit布局"><a href="#webkit布局" class="headerlink" title="webkit布局"></a>webkit布局</h1><p>当webkit创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息的过程称为布局计算/排版。<br>    布局计算分类：第一类是对整个RenderObject树进行的计算；第二类是对RenderObject树中某个子树的计算，常见于文本元素或者overflow：auto块的计算。<br>    布局计算：布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。</p>
<h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>我们常说的reflow和repaint。涉及到元素的几何属性改变会造成reflow会降低性能（transform、opacity等属性不会造成reflow）。<br>扩展为什么说transform实现动画较直接设置几何属性性能较好？<br>1.webkit渲染过程：style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite，transform是位于’Composite（渲染层合并）‘，而width、left、margin等则是位于‘Layout（布局）’层，这必定导致reflow。<br>2.现代浏览器针对transform等开启GPU加速。<br>    style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite（transform发生在这个时候）<br>由这个过程我们可以看出，这也是为什么发生reflow必定会发生repaint的根本原因。<br><a href="https://www.w3cplus.com/animation/animation-performance.html" target="_blank" rel="noopener">CSS Animation性能优化</a><br><a href="https://segmentfault.com/a/1190000008650975" target="_blank" rel="noopener">从重绘重排角度讲解transform的动画性能</a></p>
<h1 id="渲染过程的一些理论"><a href="#渲染过程的一些理论" class="headerlink" title="渲染过程的一些理论"></a>渲染过程的一些理论</h1><p>RenderObject树同其他树（如RenderLayer树等），构成了webkit渲染的主要基础设施。</p>
<h2 id="RenderObject树（DOM树-gt-RenderObject树）"><a href="#RenderObject树（DOM树-gt-RenderObject树）" class="headerlink" title="RenderObject树（DOM树 -&gt; RenderObject树）"></a>RenderObject树（DOM树 -&gt; RenderObject树）</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/DOM%E5%88%B0RenderObject.png" alt="DOM到RenderObject"><br>一个RenderObject对象保存了为绘制DOM节点所需要的各种信息，例如样式布局信息，经过webkit的处理之后，RenderObject对象知道如何绘制自己。<br>下列情况会使DOM树节点创建一个RenderObject对象（DOM和RenderObject并非一一对应）。<br>1.DOM树的document节点。<br>2.DOM树种的可视节点，例如html、body、div等。而webkit不会为非可视化节点创建RenderObject节点，例如meta、script。<br>3.某些情况下webkit需要建立匿名的RenderObject节点，该节点不对应于DOM树种的任何节点，而是webkit处理上的需要，典型的例子例如匿名的RenderBlock节点。<br>在html组建页面结构时，webkit为了提升网页性能，会引入分层结构。</p>
<h2 id="网页层次结构（css也会对网页的分层策略产生重要影响）"><a href="#网页层次结构（css也会对网页的分层策略产生重要影响）" class="headerlink" title="网页层次结构（css也会对网页的分层策略产生重要影响）"></a>网页层次结构（css也会对网页的分层策略产生重要影响）</h2><p>对于一个html文件webkit会为某些元素和它的子节点建立新层，这样webkit可以单独对某层操作提升性能，下列情况会产生新层。<br>1.video标签 – webkit在新层中有效的处理视频解码器和浏览器之间的交互和渲染问题。<br>2.div、p等普通标签 – 涉及到3D变换时。<br>3.canvas标签 – 复杂的2D和3D绘图操作。</p>
<h2 id="RenderLayer树"><a href="#RenderLayer树" class="headerlink" title="RenderLayer树"></a>RenderLayer树</h2><p><img src="http://p4yvw0vpm.bkt.clouddn.com/RenderObject%E5%88%B0RenderLayer.png" alt="RenderObject到RenderLayer"><br>webkit会为网页的层次创建相应的RenderLayer对象。当某些类型RenderObject的节点或者某些css样式的RenderObject节点出现的时候，webkit就会为这些节点创建RenderLayer对象。<br>RenderLayer树是基于RenderObject树建立起来的一棵新树。RenderLayer节点和RenderObject节点不是一一对应关系，而是一对多的关系。<br>哪些情况下的RenderObject节点需要建立新的RenderLayer节点呢？<br>1.DOM树的Document节点对应的RenderView节点。<br>2.DOM树中的Document的子节点，也就是HTML节点对应RenderBlock节点。<br>3.显式的制定css位置的RenderObject节点。<br>4.有透明效果的RenderObject节点。<br>5.节点有溢出（overflow）、alpha或者反射效果的RenderObject节点。<br>6.使用Canvas 2D和3D（WebGL）技术的RenderObject节点。<br>7.Video节点对应的RenderObject节点。</p>
<h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><p>绘图上下文（绘图上下文可以分成两种类型）：<br>    第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）。<br>    第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）。<br>网页的三种渲染方式：<br>1.软件渲染（CPU内存）<br>2.使用软件绘图的合成化渲染（GPU内存）css3D、WebGL<br>3.硬件加速的合成化渲染（GPU内存）</p>
<h2 id="webkit软件渲染技术"><a href="#webkit软件渲染技术" class="headerlink" title="webkit软件渲染技术"></a>webkit软件渲染技术</h2><p>在不需要硬件加速内容的时候（包括但不限于css3 3D变形、css3 3D变换、WebGL和视频），webkit就可以使用软件渲染技术来完成页面绘制。<br>对于每个RenderObject对象，需要三个阶段绘制自己：<br>第一阶段是绘制该层中所有块的背景和边框。<br>第二阶段是绘制浮动内容。<br>第三阶段是前景（Foreground），也就是内容部分、轮廓、字体颜色、大小等（内嵌元素的背景、边框等发生在这一阶段）。</p>
<h2 id="硬件加速机制"><a href="#硬件加速机制" class="headerlink" title="硬件加速机制"></a>硬件加速机制</h2><p>硬件加速技术是指使用GPU的硬件能力来帮助渲染网页（GPU的作用主要是用来绘制3D图形并且性能特别好）。</p>
<h3 id="Chrome的硬件加速机制"><a href="#Chrome的硬件加速机制" class="headerlink" title="Chrome的硬件加速机制"></a>Chrome的硬件加速机制</h3><p>canvas开发，可以将画布分解为更小的画布，这样在更新时只需要更新小画布从而减少开销。<br>css3 3D变形技术，它能过让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果（只触发Composite而不用触发style -&gt; Layout(reflow发生在这) -&gt; Paint）。</p>
<h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><p>WebGL是Khronous组织提出的一套基于3D图形定义的javascript接口。<br>它基于canvas元素，跟canvas2D不同的是，Web开发者可以使用3D图形接口来绘制各种3D图形。</p>
<h3 id="css-3D变形"><a href="#css-3D变形" class="headerlink" title="css 3D变形"></a>css 3D变形</h3><p>这里包括3D变形和动画。<br>webkit会建立一个新层来处理，从而提升性能。</p>
<h1 id="JavaScript引擎-1"><a href="#JavaScript引擎-1" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h1><p>推动JavaScript运行速度提高的利器JIT（Just-In-Time）。<br>JIT：就是代码在目标平台上运行的时候，实时的把代码编译为目标机器上的机器码。<br>编译原理：<br>C++：源代码 –&gt; 抽象语法树 –&gt; 本地代码<br>Java：源代码 –&gt; 抽象语法树  –&gt; 字节码（跨平台） –&gt; JIT –&gt; 本地代码</p>
<h2 id="V8的一些特性（这里太多了，读者可以自己深究）"><a href="#V8的一些特性（这里太多了，读者可以自己深究）" class="headerlink" title="V8的一些特性（这里太多了，读者可以自己深究）"></a>V8的一些特性（这里太多了，读者可以自己深究）</h2><p>常用的javascript引擎有v8和JavaScriptCore<br>工作原理<br>在js中，基本数据类型Boolean、Number、String、Null、Undefined、Symbol，其他数据都是对象。</p>
<h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>在V8中，数据的表示分成两个部分<br>    第一部分是数据的实际内容，它们是变长的，而且内容的类型也不一样，如String、对象等。<br>    第二部分是数据的句柄，句柄的大小是固定的，句柄中包含指向数据的指针。</p>
<h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>Handle：句柄类，主要用来管理基础数据和对象，以便被垃圾回收器操作。<br>主要有两个类型，一个Local类（继承自Handle类），表示本地栈上的数据，所以比较轻量。<br>另一个是Persistent类（继承自Handle类）表示函数间的数据和对象访问。<br>对于整形数据，由Handle本身来存储，同时也为了快速访问。<br>其他的数据都是从堆中申请内存来存储它们，由于其他数据类型，受限于Handle的大小和变长等原因，都存储在堆中。<br>V8的延迟（deferred）特性：它使的许多javascript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销。<br><img src="http://p4yvw0vpm.bkt.clouddn.com/javascript%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81.png" alt="v8将源代码-本地代码"></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="常见的语言类型"><a href="#常见的语言类型" class="headerlink" title="常见的语言类型"></a>常见的语言类型</h3><p>机器语言（它是计算机唯一能直接执行的语言，电子计算机的机器指令是一列二进制数字。）<br>汇编语言 汇编指令是机器指令便于记忆的书写格式，但他需要进过编译器转换为机器语言，这样机器才能执行。</p>
<h3 id="使用setTimeout或setInterval较requestAnimationFrame的缺点？"><a href="#使用setTimeout或setInterval较requestAnimationFrame的缺点？" class="headerlink" title="使用setTimeout或setInterval较requestAnimationFrame的缺点？"></a>使用setTimeout或setInterval较requestAnimationFrame的缺点？</h3><p>时间间隔应该设置为多少才合适呢。<br>跟屏幕的分辨率有关吗（不同浏览器存在一个极小值）。<br>设置的时间会按照会准确执行吗。<br>动画会被平滑地显示效果吗。<br>回调函数时复杂的好还是简单的好呢。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame</a></p>
<h1 id="其他浏览器相关知识"><a href="#其他浏览器相关知识" class="headerlink" title="其他浏览器相关知识"></a>其他浏览器相关知识</h1><h2 id="插件和Javascript扩展"><a href="#插件和Javascript扩展" class="headerlink" title="插件和Javascript扩展"></a>插件和Javascript扩展</h2><p>在早期的浏览器能力十分有限，Web前端开发者们希望能够通过一些机制来扩展浏览器的能力（插件机制如flash插件）。</p>
<h3 id="NPAPI全称叫-Netscape-plugin-API"><a href="#NPAPI全称叫-Netscape-plugin-API" class="headerlink" title="NPAPI全称叫 Netscape plugin API"></a>NPAPI全称叫 Netscape plugin API</h3><p>NPAPI是当今最流行的插件架构，几乎所有浏览器都支持，不过存在很大的安全隐患，插件可以窃取系统底层权限，发起恶意攻击。</p>
<h3 id="PPAPI也就是Pepper-Plugin-API"><a href="#PPAPI也就是Pepper-Plugin-API" class="headerlink" title="PPAPI也就是Pepper Plugin API"></a>PPAPI也就是Pepper Plugin API</h3><p>2010年，Google开发了新的PPAPI，将外挂插件全部放到沙盒里运行，2012年Windows、Mac版本的Chrome浏览器先后升级了PPAPI Flash Player，并希望今年底之前彻底淘汰NPAPI。</p>
<h2 id="JavaScript引擎的扩展机制"><a href="#JavaScript引擎的扩展机制" class="headerlink" title="JavaScript引擎的扩展机制"></a>JavaScript引擎的扩展机制</h2><p>通过如下url参看当前chrome浏览器安装的extensions<br>chrome://extensions/ </p>
<h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><p>WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="noopener">MDN-WebRTC</a><br>最重要的方法：navigator.mediaDevices.getUserMedia(constraints)<br>还有Video、Audio等。</p>
<h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><p>第一部分是网页的安全，包括但是不限于网页数据安全传输、跨域访问、用户数据安全等。<br>第二部分是浏览器的安全，具体是指虽然网页或者Javascript代码有一些安全问题或者存在安全漏洞，浏览器也能够在运行它们的时候保证吱声的安全，不受到攻击从而泄漏数据或者使系统遭受破坏。</p>
<h3 id="网页安全模型"><a href="#网页安全模型" class="headerlink" title="网页安全模型"></a>网页安全模型</h3><p>安全模型基础：<br>域（Same Origin Policy）XMLHttpRequest、cookie的读写、DOM对象操作等。<br>XSS（Cross Site Scripting）执行跨域的js脚本代码。开发者可以将用户输入的数据进行字符转换来避免。webkit通过XSSAuditor对象帮我们过滤（默认开启）。<br>CSP （Content-Security-Policy）HTTP首部字段，内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。<br>CORS（Cross Origin Resource Sharing）跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。<br>    具体服务端代码设置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 请求头</span><br><span class="line">header(&apos;Access-Control-Allow-Origin: http://arunranga.com&apos;); // </span><br><span class="line">header(&apos;Access-Control-Allow-Methods: POST, GET, OPTIONS&apos;);</span><br><span class="line">header(&apos;Access-Control-Allow-Headers: X-PINGARUNER&apos;);</span><br><span class="line">// 响应头</span><br><span class="line">Access-Control-Allow-Origin、</span><br><span class="line">Access-Control-Allow-Credentials、</span><br><span class="line">Access-Control-Allow-Headers、</span><br><span class="line">Access-Control-Expose-Headers、</span><br><span class="line">Access-Control-Allow-Methods、</span><br><span class="line">Access-Control-Max-Age</span><br></pre></td></tr></table></figure></p>
<p>Cross Document Messaging 通过 window.postMessage 和 message 事件来通信。<br>HTTPS（安全传输协议）<br>SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。    SPDY核心思想为多路复用。<br>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。</p>
<h4 id="CSP和CORS的区别："><a href="#CSP和CORS的区别：" class="headerlink" title="CSP和CORS的区别："></a>CSP和CORS的区别：</h4><p>CSP定义了网页自身能够访问的某些域和资源。<br>CORS定义一个网页如何才能访问被同源策略禁止的跨域资源，并规定了两者交互的协议和方式。</p>
<h3 id="沙箱模型"><a href="#沙箱模型" class="headerlink" title="沙箱模型"></a>沙箱模型</h3><p>浏览器的沙箱模型是利用系统提供的安全技术，让网页在执行过程中不会修改操作系统或者是访问系统中的隐私数据，而需要访问系统资源或者说是系统调用的时候，通过一个代理机制来完成。</p>
<h1 id="chrome浏览其使用技巧（以实用性排列）"><a href="#chrome浏览其使用技巧（以实用性排列）" class="headerlink" title="chrome浏览其使用技巧（以实用性排列）"></a>chrome浏览其使用技巧（以实用性排列）</h1><p>一下url直接输入在浏览器中，enter即可</p>
<table>
<thead>
<tr>
<th>URL</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>chrome://inspect</td>
<td style="text-align:center">移动端网页调试</td>
</tr>
<tr>
<td>chrome://net-internals</td>
<td style="text-align:center">net-internals是一套工具集合，用于帮助诊断网络请求与访问方面的问题，它通过监听和搜集 DNS，Sockets，SPDY，Caches等事件与数据来向开发者反馈各种网络请求的过程、状态以及可能产生影响的因素。如，查看DNS主机解析缓存chrome://net-internals/#dns</td>
</tr>
<tr>
<td>chrome://view-http-cache/</td>
<td style="text-align:center">查看内部存储内容及其详情</td>
</tr>
<tr>
<td>chrome://downloads/</td>
<td style="text-align:center">下载内容管理，其快捷键是Ctrl+J</td>
</tr>
<tr>
<td>chrome://extensions/</td>
<td style="text-align:center">扩展管理</td>
</tr>
<tr>
<td>chrome://bookmarks/</td>
<td style="text-align:center">书签管理  </td>
</tr>
<tr>
<td>chrome://history</td>
<td style="text-align:center">访问历史管理  </td>
</tr>
<tr>
<td>chrome://restart</td>
<td style="text-align:center">重启chrome浏览器 </td>
</tr>
<tr>
<td>chrome://apps</td>
<td style="text-align:center">chrome网上应用店  </td>
</tr>
<tr>
<td>chrome://flags/</td>
<td style="text-align:center">新特性管理 </td>
</tr>
<tr>
<td>chrome://dns</td>
<td style="text-align:center">查看DNS预取命名（从超链接等处来预测）  </td>
</tr>
<tr>
<td>chrome://quota-internals</td>
<td style="text-align:center">查看浏览器所使用磁盘空间配额 </td>
</tr>
<tr>
<td>chrome://settings</td>
<td style="text-align:center">浏览器的设置</td>
</tr>
<tr>
<td>chrome://sync-internals</td>
<td style="text-align:center">查看chrome 的同步状态 </td>
</tr>
<tr>
<td>chrome://about/</td>
<td style="text-align:center">查看所有chrome命令 </td>
</tr>
</tbody>
</table>
<p><a href="https://fanerge.github.io">期望加入一个技术氛围nice的团队-成都</a></p>
]]></content>
      <categories>
        <category>webkit</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>一道CSS面试题</title>
    <url>/2020/%E4%B8%80%E9%81%93css%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天，我还是像往常一样，在公交车上刷<a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a>和查看关注的大佬的文章，一般我会大致浏览一遍，对自己不熟悉的知识点，我会仔细研究。在看一篇<a href="https://mp.weixin.qq.com/s/CFoTRNDXHbqenmW7jFVczg" target="_blank" rel="noopener"> 木易杨大佬，三年前端寒冬入大厂，收获蚂蚁、字节 offer 面经分享</a>的文章，其中一道字节跳动的CSS题目吸引了我（哈哈，因为我对这个知识点比较含糊，答不上来），下面我们大家就一起来看看这道题吧。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="求最终-left、right-的宽度（container-的-width-lt-left-的-width-right-的-width-的情况）"><a href="#求最终-left、right-的宽度（container-的-width-lt-left-的-width-right-的-width-的情况）" class="headerlink" title="求最终 left、right 的宽度（container 的 width &lt; left 的 width + right 的 width 的情况）"></a>求最终 left、right 的宽度（container 的 width &lt; left 的 width + right 的 width 的情况）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .container &#123;</span><br><span class="line">    width: 600px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    flex: 1 2 500px;</span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    flex: 2 1 400px;</span><br><span class="line">    background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="先补充下理论知识"><a href="#先补充下理论知识" class="headerlink" title="先补充下理论知识"></a>先补充下理论知识</h3><p>首先我们还是看一下，<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex" target="_blank" rel="noopener">flex属性的定义</a>吧!<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The flex CSS property sets how a flex item will grow or shrink to fit the space available in its flex container.</span><br><span class="line">It is a shorthand for flex-grow, flex-shrink, and flex-basis.</span><br></pre></td></tr></table></figure></p>
<p>flex属性其实是flex-grow（主轴空间多余时放大比例）、flex-shrink（主轴空间不足时缩小比例）、flex-basis（分配多余空间之前占据的主轴空间）这三个属性的简写。<br><br>flex虽说时前面提到的三个属性的简写，但在一些情况下是可以省略的。</p>
<blockquote>
<p>flex<br>单值语法: 值必须为以下其中之一:<br>一个无单位数(number): 它会被当作 flex-grow 的值。<br>一个有效的宽度(width)值: 它会被当作 flex-basis 的值。<br>关键字none，auto或initial.<br>双值语法: 第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。第二个值必须为以下之一：<br>一个无单位数：它会被当作 flex-shrink 的值。<br>一个有效的宽度值: 它会被当作 flex-basis 的值。<br>三值语法:<br>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。<br>第二个值必须为一个无单位数，并且它会被当作  flex-shrink 的值。<br>第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值。</p>
</blockquote>
<p>上面提到的有效的宽度值，其实就是 number + unit，如 3px、 5rem等。</p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>首先，left 的 flow-basis 为 500px，right 的 flow-basis 为 400px，两者之后大于 container 容器的宽度 600px，这时肯定会触发 left 和 right 的压缩来适应容器的宽度，但如何分配压缩比的呢？<br><br>left 的 width + right 的 width = container 的 width，这个公式肯定成立。<br><br>但为题是 left 的 width 和 right 的 width 如何表示呢？<br><br>用数学的用法来解答，假设缩放基数为 x。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500*(1-2/x) + 400*(1-1/x) = 600</span><br><span class="line">求解，x = 14/3</span><br></pre></td></tr></table></figure></p>
<p>现在答案出来了，left 的 width 约为 285.72px，right 的 width 约为 314.28px。<br><img src="../../images/2020/flex-1.png" alt></p>
<h3 id="这里顺便验证下-container-的-width-left-的-width-right-的-width"><a href="#这里顺便验证下-container-的-width-left-的-width-right-的-width" class="headerlink" title="这里顺便验证下 container 的 width = left 的 width + right 的 width"></a>这里顺便验证下 container 的 width = left 的 width + right 的 width</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .container &#123;</span><br><span class="line">    width: 900px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    flex: 1 2 500px;</span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    flex: 2 1 400px;</span><br><span class="line">    background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>结果符合预期，当container 的 width = left 的 width + right 的 width，直接按各个 flex item 的 flow-basis 展示就好。<br><img src="../../images/2020/flex-2.png" alt></p>
<h3 id="这里顺便验证下-container-的-width-gt-left-的-width-right-的-width"><a href="#这里顺便验证下-container-的-width-gt-left-的-width-right-的-width" class="headerlink" title="这里顺便验证下 container 的 width &gt; left 的 width + right 的 width"></a>这里顺便验证下 container 的 width &gt; left 的 width + right 的 width</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .container &#123;</span><br><span class="line">    width: 1000px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    flex: 1 2 500px;</span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    flex: 2 1 400px;</span><br><span class="line">    background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这种情况也比较简单，可以这样理解，left 和 right 按 flow-basis 分配，还剩下 100px，则将起分为 left 的 flex-grow + right 的 flex-grow 份，然后 left 占 自己的 flex-grow 份。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// left 的 width</span><br><span class="line">left的width = 500 + (1/3)*100 = 533.33px</span><br><span class="line">right的width = 400 + (2/3)*100 = 466.67px</span><br></pre></td></tr></table></figure></p>
<p><img src="../../images/2020/flex-3.png" alt></p>
<blockquote>
<p>参考文档<br><a href="https://mp.weixin.qq.com/s/CFoTRNDXHbqenmW7jFVczg" target="_blank" rel="noopener">三年前端寒冬入大厂，收获蚂蚁、字节 offer 面经分享</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex" target="_blank" rel="noopener">CSS flex 属性</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Generator函数的用法</title>
    <url>/2017/Generator%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h1><p>从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<h1 id="Generator函数的简单示例"><a href="#Generator函数的简单示例" class="headerlink" title="Generator函数的简单示例"></a>Generator函数的简单示例</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* g() &#123;</span><br><span class="line">  yield &apos;hello&apos;;</span><br><span class="line">  yield &apos;world&apos;;</span><br><span class="line">  return &apos;ending&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var demo = g();</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：上面代码定义了一个 Generator 函数g，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br><span style="color: red">返回的是，遍历器对象（Iterator Object）。例如这里，{ value: ‘hello’, done: false }</span></p>
<h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h1><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。<br>    （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。<br>    （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。<br>    （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。<br>    （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
<h1 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h1><pre><code>可以遍历 数组 和 实现了 Symbol.iterator 方法的对象。
</code></pre><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function *foo() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">  yield 5;</span><br><span class="line">  return 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure></p>
<h1 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a>Generator.prototype.next()</h1><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen() &#123; </span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(); // &quot;Generator &#123; &#125;&quot;</span><br><span class="line">g.next();      // &quot;Object &#123; value: 1, done: false &#125;&quot;</span><br><span class="line">g.next();      // &quot;Object &#123; value: 2, done: false &#125;&quot;</span><br><span class="line">g.next();      // &quot;Object &#123; value: 3, done: false &#125;&quot;</span><br><span class="line">g.next();      // &quot;Object &#123; value: undefined, done: true &#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h1><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。    </p>
<h1 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h1><p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        // &#123; value: 1, done: false &#125;</span><br><span class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;</span><br><span class="line">g.next()        // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。<br>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p>
<h1 id="比较一下多个异步操作的编码"><a href="#比较一下多个异步操作的编码" class="headerlink" title="比较一下多个异步操作的编码"></a>比较一下多个异步操作的编码</h1><p>step1完成才能做step2，step2完成才能做step3，step3完成才能做step4</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数("></a>回调函数(</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step1(function (value1) &#123;</span><br><span class="line">  step2(value1, function(value2) &#123;</span><br><span class="line">	step3(value2, function(value3) &#123;</span><br><span class="line">	  step4(value3, function(value4) &#123;</span><br><span class="line">		// Do something with value4</span><br><span class="line">	  &#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：层数多了就形成了回调地狱。</p>
<h2 id="Promise-组织代码"><a href="#Promise-组织代码" class="headerlink" title="Promise 组织代码"></a>Promise 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q.fcall(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4)</span><br><span class="line">  .then(function (value4) &#123;</span><br><span class="line">	// Do something with value4</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">	// Handle any error from step1 through step4</span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：是不是代码稍微要清晰一些了。</p>
<h2 id="Generator-组织代码"><a href="#Generator-组织代码" class="headerlink" title="Generator 组织代码"></a>Generator 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* longRunningTask() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">	var value1 = yield step1();</span><br><span class="line">	var value2 = yield step2(value1);</span><br><span class="line">	var value3 = yield step3(value2);</span><br><span class="line">	var value4 = yield step4(value3);</span><br><span class="line">	// Do something with value4</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">	// Handle any error from step1 through step4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function scheduler(task) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">	var taskObj = task.next(task.value);</span><br><span class="line">	// 如果Generator函数未结束，就继续调用</span><br><span class="line">	if (!taskObj.done) &#123;</span><br><span class="line">	  task.value = taskObj.value</span><br><span class="line">	  scheduler(task);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduler(longRunningTask());</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener">MDN-Generator</a><br>    <a href="http://blog.csdn.net/jiangbo_phd/article/details/51820642" target="_blank" rel="noopener">ES6 Generator 函数的使用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据结构与算法</title>
    <url>/2017/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="数组及矩阵（二维数组）和多维数组（a-b-均为数组）"><a href="#数组及矩阵（二维数组）和多维数组（a-b-均为数组）" class="headerlink" title="数组及矩阵（二维数组）和多维数组（a, b 均为数组）"></a>数组及矩阵（二维数组）和多维数组（a, b 均为数组）</h1><p>最好使用数组存储一系列同一种数据类型的值（与其它语言保持一致）。<br>数组的优点：可以直接访问数组的某一项（相对于链表）。<br>数组的缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管我们已经学过的JavaScript的 Array 类方法可以帮我们做这些事，但背后的情况同样是这样）。</p>
<h2 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h2><h3 id="模拟栈数据结构"><a href="#模拟栈数据结构" class="headerlink" title="模拟栈数据结构"></a>模拟栈数据结构</h3><p>a.pop()  删除数组的最后一个元素并返回删除的元素。<br>a.push(item1, item2, …, itemX)  向数组的末尾添加一个或更多元素，并返回新的长度。</p>
<h3 id="模拟队列数据结构"><a href="#模拟队列数据结构" class="headerlink" title="模拟队列数据结构"></a>模拟队列数据结构</h3><p>a.shift()  删除并返回数组的第一个元素。<br>a.unshift(item1,item2, …, itemX)  可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<h3 id="排序相关方法"><a href="#排序相关方法" class="headerlink" title="排序相关方法"></a>排序相关方法</h3><p>a.sort(sortfunction)  方法用于对数组的元素进行排序。<br>a.reverse()  用于颠倒数组中元素的顺序。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>a.splice(index,howmany,item1,…..,itemX)  用于插入、删除或替换数组的元素。<br>    参数说明：1.规定从何处添加/删除元素。2.删除多少元素。3.插入的项目。<br>    这里返回类型为数组!!!<br>a.copyWithin(target, start, end)  从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>    参数说明：1.复制到指定目标索引位置。2,3为复制的起始和结束位置。<br>a.fill(value, start, end)  将一个固定值替换数组的元素。</p>
<p style="color: red;">PS：删除元素的方法，返回被删除的元素。<br>    添加元素的方法，返回数组长度。</p>

<h2 id="不操作原数组方法"><a href="#不操作原数组方法" class="headerlink" title="不操作原数组方法"></a>不操作原数组方法</h2><h3 id="返回Boolean值的方法"><a href="#返回Boolean值的方法" class="headerlink" title="返回Boolean值的方法"></a>返回Boolean值的方法</h3><p>a.every(function(currentValue,index,arr), thisValue)  检测数值元素的每个元素是否都符合条件。<br>a.some(function(currentValue,index,arr),thisValue)  用于检测数组中的元素是否满足指定条件（函数提供）。<br>a.includes(searchElement, fromIndex) 判断该数组是否存在该数组中。</p>
<h3 id="返回新数组的方法"><a href="#返回新数组的方法" class="headerlink" title="返回新数组的方法"></a>返回新数组的方法</h3><p>a.concat(b)  连接两个或更多的数组，并返回连接后的数组。<br>a.filter(function(currentValue,index,arr), thisValue)  创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>a.slice(start, end)  可从已有的数组中返回选定的元素。<br>a.map(function(currentValue,index,arr), thisValue)   返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
<h3 id="返回数组中的某项索引值"><a href="#返回数组中的某项索引值" class="headerlink" title="返回数组中的某项索引值"></a>返回数组中的某项索引值</h3><p>a.findIndex(function(currentValue, index, arr), thisValue)  返回符合传入测试（函数）条件的数组元素索引。<br>a.indexOf(item,start)  返回某个指定的字符串值在字符串中首次出现的位置。<br>a.lastIndexOf(item,start)   返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p>
<h3 id="返回数组中的某项值"><a href="#返回数组中的某项值" class="headerlink" title="返回数组中的某项值"></a>返回数组中的某项值</h3><p>a.find(function(currentValue, index, arr),thisValue)  返回传入一个测试条件（函数）符合条件的数组第一个元素。</p>
<h3 id="输出为字符串的方法"><a href="#输出为字符串的方法" class="headerlink" title="输出为字符串的方法"></a>输出为字符串的方法</h3><p>a.join(separator)  用于把数组中的所有元素通过分隔符转换一个字符串。<br>a.toString()  返回已逗号分割元素的字符串。</p>
<h3 id="其它对数组进行操作"><a href="#其它对数组进行操作" class="headerlink" title="其它对数组进行操作"></a>其它对数组进行操作</h3><p>a.forEach(function(currentValue, index, arr), thisValue)  （not return a new array! &amp; no return value!）对数组的每个元素执行一次提供的函数。<br>a.reduce(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从左到右）。<br>a.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)  将数组元素计算为一个值（从右到左）。<br><a href="http://www.runoob.com/jsref/jsref-obj-array.html" target="_blank" rel="noopener">Array方法参考手册</a></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈，一种具有特殊行为的数组，具有后进先出（LIFO）原则的有序集合。<br>    （数组头部）栈底[]栈顶（数组尾部）</p>
<h2 id="栈应该具有的方法"><a href="#栈应该具有的方法" class="headerlink" title="栈应该具有的方法"></a>栈应该具有的方法</h2><p>push(element(s)) ：添加一个（或几个）新元素到栈顶。<br>pop() ：移除栈顶的元素，同时返回被移除的元素。<br>peek() ：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。<br>isEmpty() ：如果栈里没有任何元素就返回 true ，否则返回 false 。<br>clear() ：移除栈里的所有元素。<br>size() ：返回栈里的元素个数。这个方法和数组的 length 属性很类似。</p>
<h2 id="构建栈及相应的方法"><a href="#构建栈及相应的方法" class="headerlink" title="构建栈及相应的方法"></a>构建栈及相应的方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line"></span><br><span class="line">	// 使用数组来模拟栈</span><br><span class="line">	let items = [];</span><br><span class="line">	</span><br><span class="line">	// push方法</span><br><span class="line">	this.push = function(element)&#123;</span><br><span class="line">		items.push(element);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// pop方法</span><br><span class="line">	this.pop = function()&#123;</span><br><span class="line">		return items.pop();</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// peek方法</span><br><span class="line">	this.peek = function()&#123;</span><br><span class="line">		return items[items.length-1];</span><br><span class="line">		// return items.slice().pop();</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// isEmpty方法</span><br><span class="line">	this.isEmpty = function()&#123;</span><br><span class="line">		return items.length === 0;</span><br><span class="line">	&#125;;	</span><br><span class="line">	</span><br><span class="line">	// size方法</span><br><span class="line">	this.size = function()&#123;</span><br><span class="line">		return items.length;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// clear方法</span><br><span class="line">	this.clear = function()&#123;</span><br><span class="line">		items = [];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// print调试方法</span><br><span class="line">	this.print = function()&#123;</span><br><span class="line">		console.log(items.toString());</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">let stack1 = new Stack();</span><br><span class="line">stack1.print(); // &apos;&apos;</span><br><span class="line">stack1.push(1);</span><br><span class="line">stack1.print(); // &apos;1&apos;</span><br><span class="line">stack1.clear();  </span><br><span class="line">stack1.print(); // &apos;&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function divideBy2(decNumber)&#123;</span><br><span class="line">	let remStack = new Stack(),</span><br><span class="line">		rem,</span><br><span class="line">		binaryString = &apos;&apos;;</span><br><span class="line">		</span><br><span class="line">	while (decNumber &gt; 0)&#123; //&#123;1&#125;</span><br><span class="line">		rem = Math.floor(decNumber % 2); //&#123;2&#125;</span><br><span class="line">		remStack.push(rem); //&#123;3&#125;</span><br><span class="line">		decNumber = Math.floor(decNumber / 2); //&#123;4&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while (!remStack.isEmpty())&#123; //&#123;5&#125;</span><br><span class="line">		binaryString += remStack.pop().toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。</p>
<h2 id="队列需要的方法"><a href="#队列需要的方法" class="headerlink" title="队列需要的方法"></a>队列需要的方法</h2><p>enqueue(element(s)) ：向队列尾部添加一个（或多个）新的项。<br>dequeue() ：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。<br>front() ：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。<br>isEmpty() ：如果队列中不包含任何元素，返回 true ，否则返回 false 。<br>size() ：返回队列包含的元素个数，与数组的 length 属性类似。</p>
<h2 id="构建队列"><a href="#构建队列" class="headerlink" title="构建队列"></a>构建队列</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Queue() &#123;</span><br><span class="line">	</span><br><span class="line">	// 保存数据</span><br><span class="line">	let items = [];</span><br><span class="line">	</span><br><span class="line">	// enqueue方法</span><br><span class="line">	this.enqueue = function(element)&#123;</span><br><span class="line">		items.push(element);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	// dequeue 方法</span><br><span class="line">	this.dequeue = function()&#123;</span><br><span class="line">		return items.shift();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	// front 方法</span><br><span class="line">	this.front = function()&#123;</span><br><span class="line">		return items[0];</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	// isEmpty 方法</span><br><span class="line">	this.isEmpty = function()&#123;</span><br><span class="line">		return items.length === 0;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// size方法</span><br><span class="line">	this.size = function()&#123;</span><br><span class="line">		return items.length;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// print 调试方法</span><br><span class="line">	this.print = function()&#123;</span><br><span class="line">		console.log(items.toString());</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="可以设置优先级的队列"><a href="#可以设置优先级的队列" class="headerlink" title="可以设置优先级的队列"></a>可以设置优先级的队列</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function PriorityQueue() &#123;</span><br><span class="line">	let items = [];</span><br><span class="line">	</span><br><span class="line">	function QueueElement (element, priority)&#123; // &#123;1&#125;</span><br><span class="line">		this.element = element;</span><br><span class="line">		this.priority = priority;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	this.enqueue = function(element, priority)&#123;</span><br><span class="line">		var queueElement = new QueueElement(element, priority);</span><br><span class="line">		</span><br><span class="line">		if (this.isEmpty())&#123;</span><br><span class="line">			items.push(queueElement); // &#123;2&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			var added = false;</span><br><span class="line">			</span><br><span class="line">			for (var i=0; i&lt;items.length; i++)&#123;</span><br><span class="line">				if (queueElement.priority &lt; items[i].priority)&#123;</span><br><span class="line">					items.splice(i,0,queueElement); // &#123;3&#125;</span><br><span class="line">					added = true;</span><br><span class="line">					break; // &#123;4&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if (!added)&#123; //&#123;5&#125;</span><br><span class="line">				items.push(queueElement);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	//其他方法和默认的Queue实现相同</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试代码var priorityQueue = new PriorityQueue();</span><br><span class="line">priorityQueue.enqueue(&quot;John&quot;, 2);</span><br><span class="line">priorityQueue.enqueue(&quot;Jack&quot;, 1);</span><br><span class="line">priorityQueue.enqueue(&quot;Camila&quot;, 1);</span><br><span class="line">priorityQueue.print(); // Jack, Camila, John</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="循环队列–击鼓传花"><a href="#循环队列–击鼓传花" class="headerlink" title="循环队列–击鼓传花"></a>循环队列–击鼓传花</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hotPotato (nameList, num)&#123;</span><br><span class="line">	var queue = new Queue(); // &#123;1&#125;</span><br><span class="line">	</span><br><span class="line">	for (var i=0; i&lt;nameList.length; i++)&#123;</span><br><span class="line">		queue.enqueue(nameList[i]); // &#123;2&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	var eliminated = &apos;&apos;;</span><br><span class="line">	</span><br><span class="line">	while (queue.size() &gt; 1)&#123;</span><br><span class="line">		for (var i=0; i&lt;num; i++)&#123;</span><br><span class="line">			queue.enqueue(queue.dequeue()); // &#123;3&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		eliminated = queue.dequeue();// &#123;4&#125;</span><br><span class="line">		console.log(eliminated + &apos;在击鼓传花游戏中被淘汰。&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return queue.dequeue();// &#123;5&#125;</span><br><span class="line">&#125;</span><br><span class="line">var names = [&apos;John&apos;,&apos;Jack&apos;,&apos;Camila&apos;,&apos;Ingrid&apos;,&apos;Carl&apos;];</span><br><span class="line">var winner = hotPotato(names, 7);</span><br><span class="line">console.log(&apos;胜利者：&apos; + winner);</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。<br>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。<br>然而，链表需要使用指针，因此实现链表时需要额外注意。<br>数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。<br>链表的优点：相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。<br>链表的缺点：数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p>
<h2 id="创建一个链表"><a href="#创建一个链表" class="headerlink" title="创建一个链表"></a>创建一个链表</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function LinkedList() &#123;</span><br><span class="line">	</span><br><span class="line">	// 表示要加入列表的项</span><br><span class="line">	let Node = function(element)&#123; // &#123;1&#125;</span><br><span class="line">		this.element = element; // 填加到列表的值</span><br><span class="line">		this.next = null; // 列表中下一个节点项的引用</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	let length = 0; // &#123;2&#125;</span><br><span class="line">	</span><br><span class="line">	// 用于存在第一个节点的引用</span><br><span class="line">	let head = null; </span><br><span class="line">	</span><br><span class="line">	// 取得链表首元素</span><br><span class="line">	this.getHead = function()&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 向列表尾部添加一个新的项</span><br><span class="line">	this.append = function(element)&#123;</span><br><span class="line">		let node = new Node(element);</span><br><span class="line">		current;</span><br><span class="line">		</span><br><span class="line">		if (head === null) &#123; // 列表中第一节点</span><br><span class="line">			head = node;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			current = head; </span><br><span class="line">			</span><br><span class="line">			// 循环列表，直到找到最后一项</span><br><span class="line">			wihle(current.next)&#123;</span><br><span class="line">				current = current.next;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 找到最后一项，将其next赋值为node，建立链接</span><br><span class="line">			current.next = node;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		length++; // 链表长度加1</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 向列表的特定位置插入一个新的项</span><br><span class="line">	this.insert = function(position, element)&#123;</span><br><span class="line">	</span><br><span class="line">		//检查越界值</span><br><span class="line">		if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; //&#123;1&#125;</span><br><span class="line">			var node = new Node(element),</span><br><span class="line">				current = head,</span><br><span class="line">				previous,</span><br><span class="line">				index = 0;</span><br><span class="line">				</span><br><span class="line">			if (position === 0)&#123; //在第一个位置添加</span><br><span class="line">				node.next = current; //&#123;2&#125;</span><br><span class="line">				head = node;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			</span><br><span class="line">				while (index++ &lt; position)&#123; //&#123;3&#125;</span><br><span class="line">					previous = current;</span><br><span class="line">					current = current.next;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				node.next = current; //&#123;4&#125;</span><br><span class="line">				previous.next = node; //&#123;5&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			length++; //更新列表的长度</span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return false; //&#123;6&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 从列表的特定位置移除一项</span><br><span class="line">	this.removeAt = function(position)&#123;</span><br><span class="line">		//检查越界值</span><br><span class="line">		if (position &gt; -1 &amp;&amp; position &lt; length)&#123; // &#123;1&#125;</span><br><span class="line">			var current = head, // &#123;2&#125;</span><br><span class="line">			previous, // &#123;3&#125;</span><br><span class="line">			index = 0; // &#123;4&#125;</span><br><span class="line">			</span><br><span class="line">			//移除第一项</span><br><span class="line">			if (position === 0)&#123; // &#123;5&#125;</span><br><span class="line">				head = current.next;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				while (index++ &lt; position)&#123; // &#123;6&#125;</span><br><span class="line">					previous = current; // &#123;7&#125;</span><br><span class="line">					current = current.next; // &#123;8&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				//将previous与current的下一项链接起来：跳过current，从而移除它</span><br><span class="line">				previous.next = current.next; // &#123;9&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			length--; // &#123;10&#125;</span><br><span class="line">			return current.element;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null; // &#123;11&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 从列表中移除一项</span><br><span class="line">	this.remove = function(element)&#123;</span><br><span class="line">		var index = this.indexOf(element);</span><br><span class="line">		return this.removeAt(index);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 返回元素在列表中的索引</span><br><span class="line">	this.indexOf = function(element)&#123;</span><br><span class="line">		var current = head, //&#123;1&#125;</span><br><span class="line">			index = -1;</span><br><span class="line">		while (current) &#123; //&#123;2&#125;</span><br><span class="line">			if (element === current.element) &#123;</span><br><span class="line">				return index; //&#123;3&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			index++; //&#123;4&#125;</span><br><span class="line">			current = current.next; //&#123;5&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 如果链表中不包含任何元素，返回 true ，如果链表长度大于0则返回 false</span><br><span class="line">	this.isEmpty = function() &#123;</span><br><span class="line">		return length === 0;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 返回链表包含的元素个数。与数组的 length 属性类似</span><br><span class="line">	this.size = function() &#123;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 由于列表项使用了 Node 类，就需要重写继承自JavaScript对象默认的toString 方法，让其只输出元素的值</span><br><span class="line">	this.toString = function()&#123;</span><br><span class="line">		var current = head, //&#123;1&#125;</span><br><span class="line">		string = &apos;&apos;; //&#123;2&#125;</span><br><span class="line">		</span><br><span class="line">		while (current) &#123; //&#123;3&#125;</span><br><span class="line">			string = current.element; //&#123;4&#125;</span><br><span class="line">			current = current.next; //&#123;5&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return string; //&#123;6&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 调试方法</span><br><span class="line">	this.print = function()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表的特点：双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。<br>当我们访问链表项时，在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function  DoublyLinkedList()&#123;</span><br><span class="line">	var Node = function(element)&#123;</span><br><span class="line">		this.element = element;</span><br><span class="line">		this.next = null;</span><br><span class="line">		this.prev = null; //新增的</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	var length = 0;</span><br><span class="line">	var head = null;</span><br><span class="line">	var tail = null; //新增的</span><br><span class="line">	</span><br><span class="line">	this.insert = function(position, element)&#123;</span><br><span class="line">		//检查越界值</span><br><span class="line">		if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123;</span><br><span class="line">			var node = new Node(element),</span><br><span class="line">				current = head,</span><br><span class="line">				previous,</span><br><span class="line">				index = 0;</span><br><span class="line">			if (position === 0)&#123; //在第一个位置添加</span><br><span class="line">				if (!head)&#123; //新增的 &#123;1&#125;</span><br><span class="line">					head = node;</span><br><span class="line">					tail = node;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					node.next = current;</span><br><span class="line">					current.prev = node; //新增的 &#123;2&#125;</span><br><span class="line">					head = node;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if (position === length) &#123; //最后一项 //新增的</span><br><span class="line">				current = tail; // &#123;3&#125;</span><br><span class="line">				current.next = node;</span><br><span class="line">				node.prev = current;</span><br><span class="line">				tail = node;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				while (index++ &lt; position)&#123; //&#123;4&#125;</span><br><span class="line">				previous = current;</span><br><span class="line">				current = current.next;</span><br><span class="line">			&#125;</span><br><span class="line">			node.next = current; //&#123;5&#125;</span><br><span class="line">			previous.next = node;</span><br><span class="line">			current.prev = node; //新增的</span><br><span class="line">			node.prev = previous; //新增的</span><br><span class="line">			&#125;</span><br><span class="line">			length++; //更新列表的长度</span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.removeAt = function(position)&#123;</span><br><span class="line">		//检查越界值</span><br><span class="line">		if (position &gt; -1 &amp;&amp; position &lt; length)&#123;</span><br><span class="line">			var current = head,</span><br><span class="line">				previous,</span><br><span class="line">				index = 0;</span><br><span class="line">			//移除第一项</span><br><span class="line">			if (position === 0)&#123;</span><br><span class="line">				head = current.next; // &#123;1&#125;</span><br><span class="line">				//如果只有一项，更新tail //新增的</span><br><span class="line">				if (length === 1)&#123; // &#123;2&#125;</span><br><span class="line">					tail = null;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					head.prev = null; // &#123;3&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if (position === length-1)&#123; //最后一项 //新增的</span><br><span class="line">				current = tail; // &#123;4&#125;</span><br><span class="line">				tail = current.prev;</span><br><span class="line">				tail.next = null;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				while (index++ &lt; position)&#123; // &#123;5&#125;</span><br><span class="line">					previous = current;</span><br><span class="line">					current = current.next;</span><br><span class="line">				&#125;</span><br><span class="line">				//将previous与current的下一项链接起来——跳过current</span><br><span class="line">				previous.next = current.next; // &#123;6&#125;</span><br><span class="line">				current.next.prev = previous; //新增的</span><br><span class="line">			&#125;</span><br><span class="line">			length--;</span><br><span class="line">			return current.element;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单向循环链表的特点：循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用 null ，而是指向第一个元素（ head ）。<br>双向循环链表有指向 head 元素的 tail.next ，和指向 tail 元素的 head.prev 。</p>
<h1 id="集合（es6的Set）"><a href="#集合（es6的Set）" class="headerlink" title="集合（es6的Set）"></a>集合（es6的Set）</h1><p>集合的定义：集合是由一组无序且唯一（即不能重复）的项组成的。<br>集合的操作：集合也有并集、交集、差集等基本操作。</p>
<h2 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Set()&#123;</span><br><span class="line">	let items = &#123;&#125;; // js对象不允许两个不同的属性，保证集合元素的唯一性</span><br><span class="line"></span><br><span class="line">	this.has = function(value)&#123;</span><br><span class="line">		// 区别 in可以查找原型链而 hasOwnProperty方法只会查找自身</span><br><span class="line">		// return value in items;</span><br><span class="line">		return items.hasOwnProperty(value);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.add = function(value)&#123;</span><br><span class="line">		if (!this.has(value)) &#123;</span><br><span class="line">			items[value] = value;</span><br><span class="line">			return ture;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	this.remove = function(value)&#123;</span><br><span class="line">		if (this.has(value)) &#123;</span><br><span class="line">			delete items[value];</span><br><span class="line">			return ture;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.clear = function()&#123;</span><br><span class="line">		items = &#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.size = function()&#123;</span><br><span class="line">		return Object.keys(items).length;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	this.values = function()&#123;</span><br><span class="line">		return Object.keys(items);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。<br>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。<br>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。<br>子集：验证一个给定集合是否是另一集合的子集。<br>一下假设A、B为两个集合。</p>
<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>运算公式：A∪B = { x | x ∈ A∨x ∈ B }<br>为Set类的union方法<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 思路先将原集合和新集合循环添加到并集合中</span><br><span class="line">this.union = function(otherSet)&#123;</span><br><span class="line">	let unionSet = new Set();</span><br><span class="line">	let values = this.values();</span><br><span class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">		unionSet.add(values[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	values = otherSet.values();</span><br><span class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">		unionSet.add(values[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return unionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>运算公式：A∩B = { x | x ∈ A∧x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.intersection = function(otherSet)&#123;</span><br><span class="line">	let intersectionSet = new Set();</span><br><span class="line">	let values = this.values();</span><br><span class="line">	</span><br><span class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">		if (otherSet.has(values[i])) &#123;</span><br><span class="line">			intersectionSet.add(values[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return intersectionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>计算公式：AB = { x | x ∈ A ∧ x   B }<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.difference = function(otherSet)&#123;</span><br><span class="line">	let differenceSet = new Set();</span><br><span class="line">	let values = this.values();</span><br><span class="line">	</span><br><span class="line">	for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">		if (!otherSet.has(values[i])) &#123;</span><br><span class="line">			differenceSet.add(values[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return differenceSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>运算公式：∀x { x ∈ A → x ∈ B }<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.subset = function(otherSet)&#123;</span><br><span class="line">	if (this.size() &gt; otherSet.size()) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		values = this.values();</span><br><span class="line">		for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">			if (!otherSet.has(values[i])) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="字典（映射es6的Map）"><a href="#字典（映射es6的Map）" class="headerlink" title="字典（映射es6的Map）"></a>字典（映射es6的Map）</h1><p>字典和散列表是用来存储唯一值（不重复的值）的数据结构。<br>两者都是[键，值]的形式来存储数据    </p>
<h2 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function  Dictionary()&#123;</span><br><span class="line">	let items = &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	this.has = function(key)&#123;</span><br><span class="line">		return key in items;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.set = function(key, value)&#123;</span><br><span class="line">		items[key] = value;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.remove = function(key)&#123;</span><br><span class="line">		if (this.has(key)) &#123;</span><br><span class="line">			delete items[key];</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.get = function(key)&#123;</span><br><span class="line">		return this.has(key) ? items[key] : undefined;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.values = function()&#123;</span><br><span class="line">		let values = &#123;&#125;;</span><br><span class="line">		for (let k in items) &#123;</span><br><span class="line">			if (this.has(k)) &#123;</span><br><span class="line">				values.push(items[k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return values;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.clear = function()&#123;</span><br><span class="line">		items = &#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.getItems = function()&#123;</span><br><span class="line">		return items;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列算法的作用是尽可能快地在数据结构中找到一个值。<br>使用散列函数，就知道值的具体位置，因此能够快速检索到该值。<br>散列函数的作用是给定一个键值，然后返回值在表中的地址。</p>
<h2 id="创建一个散列表"><a href="#创建一个散列表" class="headerlink" title="创建一个散列表"></a>创建一个散列表</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function HashTable()&#123;</span><br><span class="line">	var table = [];</span><br><span class="line">	// 私有方法-散列函数</span><br><span class="line">	let loseloseHashCode = function(key)&#123;</span><br><span class="line">		let hash = 0;</span><br><span class="line">		for (let i = 0; i &lt; key.length; i++) &#123;</span><br><span class="line">			hash += key.charCodeAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		return hash % 37;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.put = function(key, value)&#123;</span><br><span class="line">		let position = loseloseHashCode(key);</span><br><span class="line">		console.log(position + &apos; - &apos; + key); //&#123;6&#125;</span><br><span class="line">		table[position] = value;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	this.get = function(key)&#123;</span><br><span class="line">		return table[loseloseHashCode(key)];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	this.remove = function(key)&#123;</span><br><span class="line">		table[loseloseHashCode(key)] = undefined;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="处理散列表的冲突（同名的地址覆盖）"><a href="#处理散列表的冲突（同名的地址覆盖）" class="headerlink" title="处理散列表的冲突（同名的地址覆盖）"></a>处理散列表的冲突（同名的地址覆盖）</h2><p>可以通过分离链接、线性探查和双散列法来解决冲突。</p>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>定义：包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>为了实现一个使用了分离链接的 HashTable 实例，我们需要一个新的辅助类来表示将要加入LinkedList 实例的元素。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ValuePair = function(key, value)&#123;</span><br><span class="line">	this.key = key;</span><br><span class="line">	this.value = value;</span><br><span class="line">	this.toString = function() &#123;</span><br><span class="line">		return &apos;[&apos; + this.key + &apos; - &apos; + this.value + &apos;]&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.put = function(key, value)&#123;</span><br><span class="line">	let position = loseloseHashCode(key);</span><br><span class="line">	if (table[position] == undefined) &#123;</span><br><span class="line">		table[position] = new LinkedList();</span><br><span class="line">	&#125;</span><br><span class="line">	table[position].append(new ValuePair(key, value));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.get = function(key)&#123;</span><br><span class="line">	let position = loseloseHashCode(key);</span><br><span class="line">	</span><br><span class="line">	if (table[position] !== undefined) &#123;</span><br><span class="line">		// 遍历链表来寻找键/值</span><br><span class="line">		let current = table[position].getHead();</span><br><span class="line">		while (current.next) &#123;</span><br><span class="line">			if (current.elment.key === key) &#123;</span><br><span class="line">				return current.element.value;</span><br><span class="line">			&#125;</span><br><span class="line">			current = current.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 检查元素在链表第一个或最后一个节点的情况</span><br><span class="line">		if (current.element.key === key)&#123; //&#123;9&#125;</span><br><span class="line">			return current.element.value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return undefined;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.remove = function(key)&#123;</span><br><span class="line">	var position = loseloseHashCode(key);</span><br><span class="line">	if (table[position] !== undefined)&#123;</span><br><span class="line">		var current = table[position].getHead();</span><br><span class="line">		while(current.next)&#123;</span><br><span class="line">			if (current.element.key === key)&#123; //&#123;11&#125;</span><br><span class="line">				table[position].remove(current.element); //&#123;12&#125;</span><br><span class="line">				if (table[position].isEmpty())&#123; //&#123;13&#125;</span><br><span class="line">					table[position] = undefined; //&#123;14&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return true; //&#123;15&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			current = current.next;</span><br><span class="line">		&#125;</span><br><span class="line">		// 检查是否为第一个或最后一个元素</span><br><span class="line">		if (current.element.key === key)&#123; //&#123;16&#125;</span><br><span class="line">			table[position].remove(current.element);</span><br><span class="line">			if (table[position].isEmpty())&#123;</span><br><span class="line">				table[position] = undefined;</span><br><span class="line">			&#125;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false; //&#123;17&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.put = function(key, value)&#123;</span><br><span class="line">	var position = loseloseHashCode(key); // &#123;1&#125;</span><br><span class="line">	if (table[position] == undefined) &#123; // &#123;2&#125;</span><br><span class="line">		table[position] = new ValuePair(key, value); // &#123;3&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		var index = ++position; // &#123;4&#125;</span><br><span class="line">		while (table[index] != undefined)&#123; // &#123;5&#125;</span><br><span class="line">			index++; // &#123;6&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		table[index] = new ValuePair(key, value); // &#123;7&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.get = function(key) &#123;</span><br><span class="line">	var position = loseloseHashCode(key);</span><br><span class="line">	if (table[position] !== undefined)&#123; //&#123;8&#125;</span><br><span class="line">		if (table[position].key === key) &#123; //&#123;9&#125;</span><br><span class="line">			return table[position].value; //&#123;10&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			var index = ++position;</span><br><span class="line">			while (table[index] === undefined || table[index].key !== key)&#123; //&#123;11&#125;</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (table[index].key === key) &#123; //&#123;12&#125;</span><br><span class="line">				return table[index].value; //&#123;13&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return undefined; //&#123;14&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建更好的散列函数"><a href="#创建更好的散列函数" class="headerlink" title="创建更好的散列函数"></a>创建更好的散列函数</h3><p>比较好的散列函数，不会产生太多的冲突。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var djb2HashCode = function (key) &#123;</span><br><span class="line">	var hash = 5381; //&#123;1&#125;</span><br><span class="line">	for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125;</span><br><span class="line">		hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return hash % 1013; //&#123;4&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树，它对于存储需要快速查找的数据非常有用。<br>树是一种分层数据的抽象模型。</p>
<h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p>位于树顶部的节点叫作根节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。<br>有关树的另一个术语是子树。子树由节点和它的后代构成。<br>树的高度取决于所有节点深度的最大值。</p>
<h2 id="二叉树和二叉搜索树（BST）"><a href="#二叉树和二叉搜索树（BST）" class="headerlink" title="二叉树和二叉搜索树（BST）"></a>二叉树和二叉搜索树（BST）</h2><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。<br>这些定义有助于我们写出更高效的向树中插入、查找和删除节点的算法。<br>二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。<br>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。<br>访问树的所有节点有三种方式：中序、先序和后序。<br>中序遍历 – 是以从最小到最大的顺序访问所有节点（第二层到第一层左中右）。<br>先序遍历 – 是以优先于后代节点的顺序访问每个节点的（第一层到第二层中左右）。<br>后序遍历 – 是先访问节点的后代节点，再访问节点本身（第二层到第一层左右中）。<br>中序遍历的一种应用就是对树进行排序操作。<br>先序遍历的一种应用是打印一个结构化的文档。<br>后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function BinarySearchTree() &#123;</span><br><span class="line">	let Node = function(key)&#123;</span><br><span class="line">		this.key = key;</span><br><span class="line">		this.left = null;</span><br><span class="line">		this.right = null;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 根节点</span><br><span class="line">	let root = null;</span><br><span class="line">	</span><br><span class="line">	// 插入节点，小的节点插入left，大的节点插入right</span><br><span class="line">	let insertNode = function(node, newNode)&#123;</span><br><span class="line">		if (newNode.key &lt; node.key) &#123;</span><br><span class="line">			if (node.left === null) &#123;</span><br><span class="line">				node.left = newNode;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				insertNode(node.left, newNode);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (node.right === null) &#123;</span><br><span class="line">				node.right = newNode;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				insertNode(node.right, newNode);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 向树中插入一个新的键</span><br><span class="line">	this.insert = function (key)&#123;</span><br><span class="line">		var newNode = new Node(key); //&#123;1&#125;</span><br><span class="line">		if (root === null)&#123; //&#123;2&#125;</span><br><span class="line">			root = newNode;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 递归</span><br><span class="line">			insertNode(root,newNode); //&#123;3&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 私有方法-中序遍历</span><br><span class="line">	let inOrderTraverseNode = function(node, callback)&#123;</span><br><span class="line">		if (node !== null) &#123;</span><br><span class="line">			inOrderTraverseNode(node.left, callback);</span><br><span class="line">			callback(node.key);</span><br><span class="line">			inOrderTraverseNode(node.right, callback);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 中序遍历（左中右）小到大</span><br><span class="line">	this.inOrderTraverse = function(callback)&#123;</span><br><span class="line">		inOrderTraverseNode(root, callback);</span><br><span class="line">	</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 私有方法-先序遍历</span><br><span class="line">	var preOrderTraverseNode = function (node, callback) &#123;</span><br><span class="line">		if (node !== null) &#123;</span><br><span class="line">			callback(node.key); //&#123;1&#125;</span><br><span class="line">			preOrderTraverseNode(node.left, callback); //&#123;2&#125;</span><br><span class="line">			preOrderTraverseNode(node.right, callback); //&#123;3&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 先序遍历（中左右）</span><br><span class="line">	this.preOrderTraverse = function(callback)&#123;</span><br><span class="line">		preOrderTraverseNode(root, callback);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 私有方法-后序遍历</span><br><span class="line">	var postOrderTraverseNode = function (node, callback) &#123;</span><br><span class="line">		if (node !== null) &#123;</span><br><span class="line">			postOrderTraverseNode(node.left, callback); //&#123;1&#125;</span><br><span class="line">			postOrderTraverseNode(node.right, callback); //&#123;2&#125;</span><br><span class="line">			callback(node.key); //&#123;3&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 后序遍历（左右中）</span><br><span class="line">	this.postOrderTraverse = function(callback)&#123;</span><br><span class="line">		postOrderTraverseNode(root, callback);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	// 私有方法-最小值</span><br><span class="line">	let minNode = function(node)&#123;</span><br><span class="line">		if (node) &#123;</span><br><span class="line">			while (node &amp;&amp; node.left !== null) &#123;</span><br><span class="line">				node = node.left</span><br><span class="line">			&#125;</span><br><span class="line">			return node.key;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 搜索最小值</span><br><span class="line">	this.min = function()&#123;</span><br><span class="line">		return minNode(node);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 私有方法-最大值</span><br><span class="line">	var maxNode = function (node) &#123;</span><br><span class="line">		if (node)&#123;</span><br><span class="line">			while (node &amp;&amp; node.right !== null) &#123; //&#123;5&#125;</span><br><span class="line">				node = node.right;</span><br><span class="line">			&#125;</span><br><span class="line">			return node.key;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 搜索最大值</span><br><span class="line">	this.max = function() &#123;</span><br><span class="line">		return maxNode(root);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 私有方法-搜索节点</span><br><span class="line">	var searchNode = function(node, key)&#123;</span><br><span class="line">		if (node === null)&#123; //&#123;2&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if (key &lt; node.key)&#123; //&#123;3&#125;</span><br><span class="line">			return searchNode(node.left, key); //&#123;4&#125;</span><br><span class="line">		&#125; else if (key &gt; node.key)&#123; //&#123;5&#125;</span><br><span class="line">			return searchNode(node.right, key); //&#123;6&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return true; //&#123;7&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 搜索节点</span><br><span class="line">	this.search = function(key)&#123;</span><br><span class="line">		return searchNode(root, key); //&#123;1&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	// 私有方法-移除节点</span><br><span class="line">	var removeNode = function(node, key)&#123;</span><br><span class="line">		if (node === null)&#123; //&#123;2&#125;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		if (key &lt; node.key)&#123; //&#123;3&#125;</span><br><span class="line">			node.left = removeNode(node.left, key); //&#123;4&#125;</span><br><span class="line">			return node; //&#123;5&#125;</span><br><span class="line">		&#125; else if (key &gt; node.key)&#123; //&#123;6&#125;</span><br><span class="line">			node.right = removeNode(node.right, key); //&#123;7&#125;</span><br><span class="line">			return node; //&#123;8&#125;</span><br><span class="line">		&#125; else &#123; //键等于node.key</span><br><span class="line">			//第一种情况——一个叶节点</span><br><span class="line">			if (node.left === null &amp;&amp; node.right === null)&#123; //&#123;9&#125;</span><br><span class="line">				node = null; //&#123;10&#125;</span><br><span class="line">				return node; //&#123;11&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//第二种情况——一个只有一个子节点的节点</span><br><span class="line">			if (node.left === null)&#123; //&#123;12&#125;</span><br><span class="line">				node = node.right; //&#123;13&#125;</span><br><span class="line">				return node; //&#123;14&#125;</span><br><span class="line">			&#125; else if (node.right === null)&#123; //&#123;15&#125;</span><br><span class="line">				node = node.left; //&#123;16&#125;</span><br><span class="line">				return node; //&#123;17&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//第三种情况——一个有两个子节点的节点</span><br><span class="line">			var aux = findMinNode(node.right); //&#123;18&#125;</span><br><span class="line">			node.key = aux.key; //&#123;19&#125;</span><br><span class="line">			node.right = removeNode(node.right, aux.key); //&#123;20&#125;</span><br><span class="line">			return node; //&#123;21&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 移除节点</span><br><span class="line">	this.remove = function(key)&#123;</span><br><span class="line">		root = removeNode(root, key); //&#123;1&#125;</span><br><span class="line">	&#125;;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更多关于二叉树的知识"><a href="#更多关于二叉树的知识" class="headerlink" title="更多关于二叉树的知识"></a>更多关于二叉树的知识</h2><p>BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深<br>    有一种树叫作阿德尔森-维尔斯和兰迪斯树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。<br>相关知识：红黑树、堆积树</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h2><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。<br>任何二元关系都可以用图来表示。<br>一个图G = (V, E)由以下元素组成。<br>    V：一组顶点<br>    E：一组边，连接V中的顶点<br>相邻顶点：由一条边连接在一起的顶点称为相邻顶点。<br>顶点的度：一个顶点的度是其相邻顶点的数量。<br>路径：路径是顶点v 1 , v 2 ,…,v k 的一个连续序列，其中v i 和v i+1 是相邻的。<br>图是无环：如果图中不存在环，则称该图是无环的。<br>图是连通：如果图中每两个顶点间都存在路径，则该图是连通的。<br>有向图和无向图：图可以是无向的（边没有方向）或是有向的（有向图）。<br>图是强连通：如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。<br>图是加权：图还可以是未加权的或是加权的。</p>
<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>每个节点都和一个整数相关联，该整数将作为数组的索引。<br>我们用一个二维数组来表示顶点之间的连接。<br>如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0<br>存在的问题：不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表由图中每个顶点的相邻顶点列表所组成。<br>存在好几种方式来表示这种数据结构。<br>我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。</p>
<h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><p>在关联矩阵中，矩阵的行表示顶点，列表示边。<br>我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。<br>    使用场景：关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p>
<h2 id="创建图类"><a href="#创建图类" class="headerlink" title="创建图类"></a>创建图类</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Graph()&#123;</span><br><span class="line">	let vertices = [];</span><br><span class="line">	let adjList = new Dictionary();</span><br><span class="line">	</span><br><span class="line">	// 添加顶点，参数为一个顶点</span><br><span class="line">	this.addVertex = function(v)&#123;</span><br><span class="line">		vertices.push(v);</span><br><span class="line">		adjList.set(v, []);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	// 添加顶点之间的边，参数为两个顶点</span><br><span class="line">	this.addEdge = function(v, w)&#123;</span><br><span class="line">		adjList.get(v).push(w);</span><br><span class="line">		adjList.get(w).push(v);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>字典将会使用顶点的名字作为键，邻接顶点列表作为值。<br>vertices数组和 adjList 字典两者都是我们 Graph 类的私有属性。</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。<br>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。<br>深度优先搜索  栈  通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻点就去访问<br>广度优先搜索  队列  通过将顶点存入队列中，最先入队列的顶点先被探索</p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。先宽后深地访问顶点。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var initializeColor = function()&#123;</span><br><span class="line">	var color = [];</span><br><span class="line">	for (var i=0; i&lt;vertices.length; i++)&#123;</span><br><span class="line">		color[vertices[i]] = &apos;white&apos;; //&#123;1&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return color;</span><br><span class="line">&#125;;</span><br><span class="line">this.bfs = function(v, callback)&#123;</span><br><span class="line">	var color = initializeColor(), //&#123;2&#125;</span><br><span class="line">		queue = new Queue(); //&#123;3&#125;</span><br><span class="line">	queue.enqueue(v); //&#123;4&#125;</span><br><span class="line">	while (!queue.isEmpty())&#123; //&#123;5&#125;</span><br><span class="line">		var u = queue.dequeue(), //&#123;6&#125;</span><br><span class="line">			neighbors = adjList.get(u); //&#123;7&#125;</span><br><span class="line">		color[u] = &apos;grey&apos;; // &#123;8&#125;</span><br><span class="line">		for (var i=0; i&lt;neighbors.length; i++)&#123; // &#123;9&#125;</span><br><span class="line">			var w = neighbors[i]; // &#123;10&#125;</span><br><span class="line">			if (color[w] === &apos;white&apos;)&#123; // &#123;11&#125;</span><br><span class="line">				color[w] = &apos;grey&apos;; // &#123;12&#125;</span><br><span class="line">				queue.enqueue(w); // &#123;13&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		color[u] = &apos;black&apos;; // &#123;14&#125;</span><br><span class="line">		if (callback) &#123; // &#123;15&#125;</span><br><span class="line">			callback(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>1.使用BFS寻找最短路径<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.BFS = function(v)&#123;</span><br><span class="line">	var color = initializeColor(),</span><br><span class="line">		queue = new Queue(),</span><br><span class="line">		d = [], //&#123;1&#125;</span><br><span class="line">		pred = []; //&#123;2&#125;</span><br><span class="line">		queue.enqueue(v);</span><br><span class="line">	for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;3&#125;</span><br><span class="line">		d[vertices[i]] = 0; //&#123;4&#125;</span><br><span class="line">		pred[vertices[i]] = null; //&#123;5&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while (!queue.isEmpty())&#123;</span><br><span class="line">		var u = queue.dequeue(),</span><br><span class="line">			neighbors = adjList.get(u);</span><br><span class="line">			color[u] = &apos;grey&apos;;</span><br><span class="line">		for (i=0; i&lt;neighbors.length; i++)&#123;</span><br><span class="line">			var w = neighbors[i];</span><br><span class="line">			if (color[w] === &apos;white&apos;)&#123;</span><br><span class="line">				color[w] = &apos;grey&apos;;</span><br><span class="line">				d[w] = d[u] + 1; //&#123;6&#125;</span><br><span class="line">				pred[w] = u; //&#123;7&#125;</span><br><span class="line">				queue.enqueue(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		color[u] = &apos;black&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123; //&#123;8&#125;</span><br><span class="line">	distances: d,</span><br><span class="line">	predecessors: pred</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.深入学习最短路径算法<br>    如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法）    </p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.dfs = function(callback)&#123;</span><br><span class="line">	var color = initializeColor(); //&#123;1&#125;</span><br><span class="line">	for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;2&#125;</span><br><span class="line">		if (color[vertices[i]] === &apos;white&apos;)&#123; //&#123;3&#125;</span><br><span class="line">			dfsVisit(vertices[i], color, callback); //&#123;4&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var dfsVisit = function(u, color, callback)&#123;</span><br><span class="line">	color[u] = &apos;grey&apos;; //&#123;5&#125;</span><br><span class="line">	if (callback) &#123; //&#123;6&#125;</span><br><span class="line">		callback(u);</span><br><span class="line">	&#125;</span><br><span class="line">	var neighbors = adjList.get(u); //&#123;7&#125;</span><br><span class="line">	for (var i=0; i&lt;neighbors.length; i++)&#123; //&#123;8&#125;</span><br><span class="line">		var w = neighbors[i]; //&#123;9&#125;</span><br><span class="line">		if (color[w] === &apos;white&apos;)&#123; //&#123;10&#125;</span><br><span class="line">			dfsVisit(w, color, callback); //&#123;11&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	color[u] = &apos;black&apos;; //&#123;12&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><p>1.探索深度优先算法<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var time = 0; //&#123;1&#125;</span><br><span class="line">this.DFS = function()&#123;</span><br><span class="line">	var color = initializeColor(), //&#123;2&#125;</span><br><span class="line">		d = [],</span><br><span class="line">		f = [],</span><br><span class="line">		p = [];</span><br><span class="line">		time = 0;</span><br><span class="line">	for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;3&#125;</span><br><span class="line">		f[vertices[i]] = 0;</span><br><span class="line">		d[vertices[i]] = 0;</span><br><span class="line">		p[vertices[i]] = null;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i=0; i&lt;vertices.length; i++)&#123;</span><br><span class="line">		if (color[vertices[i]] === &apos;white&apos;)&#123;</span><br><span class="line">			DFSVisit(vertices[i], color, d, f, p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123; //&#123;4&#125;</span><br><span class="line">			discovery: d,</span><br><span class="line">			finished: f,</span><br><span class="line">			predecessors: p</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var DFSVisit = function(u, color, d, f, p)&#123;</span><br><span class="line">	console.log(&apos;discovered &apos; + u);</span><br><span class="line">	color[u] = &apos;grey&apos;;</span><br><span class="line">	d[u] = ++time; //&#123;5&#125;</span><br><span class="line">	var neighbors = adjList.get(u);</span><br><span class="line">	for (var i=0; i&lt;neighbors.length; i++)&#123;</span><br><span class="line">		var w = neighbors[i];</span><br><span class="line">		if (color[w] === &apos;white&apos;)&#123;</span><br><span class="line">			p[w] = u; // &#123;6&#125;</span><br><span class="line">			DFSVisit(w,color, d, f, p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	color[u] = &apos;black&apos;;</span><br><span class="line">	f[u] = ++time; //&#123;7&#125;</span><br><span class="line">	console.log(&apos;explored &apos; + u);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.拓扑排序——使用深度优先搜索</p>
<h1 id="排序和搜索排序"><a href="#排序和搜索排序" class="headerlink" title="排序和搜索排序"></a>排序和搜索排序</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><pre><code>冒泡排序
选择排序
插入排序
归并排序
快速排序
</code></pre><p><a href>算法我这里就不再多讲了，如果感兴趣可以查看我之前的系列算法文章</a></p>
<h2 id="搜索排序"><a href="#搜索排序" class="headerlink" title="搜索排序"></a>搜索排序</h2><h3 id="顺序排序"><a href="#顺序排序" class="headerlink" title="顺序排序"></a>顺序排序</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.sequentialSearch = function(item)&#123;</span><br><span class="line">	for (var i=0; i&lt;array.length; i++)&#123; //&#123;1&#125;</span><br><span class="line">		if (item === array[i]) //&#123;2&#125;</span><br><span class="line">			return i; //&#123;3&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1; //&#123;4&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。<br>(4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.binarySearch = function(item)&#123;</span><br><span class="line">	this.quickSort(); //&#123;1&#125;</span><br><span class="line">	var low = 0, //&#123;2&#125;</span><br><span class="line">		high = array.length - 1, //&#123;3&#125;</span><br><span class="line">		mid, element;</span><br><span class="line">	while (low &lt;= high)&#123; //&#123;4&#125;</span><br><span class="line">		mid = Math.floor((low + high) / 2); //&#123;5&#125;</span><br><span class="line">		element = array[mid]; //&#123;6&#125;</span><br><span class="line">		if (element &lt; item) &#123; //&#123;7&#125;</span><br><span class="line">			low = mid + 1; //&#123;8&#125;</span><br><span class="line">		&#125; else if (element &gt; item) &#123; //&#123;9&#125;</span><br><span class="line">			high = mid - 1; //&#123;10&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return mid; //&#123;11&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1; //&#123;12&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="算法补充知识"><a href="#算法补充知识" class="headerlink" title="算法补充知识"></a>算法补充知识</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>每款浏览器的javascript调用栈大小的限制。<br>    ECMAScript 6有尾调用优化（tail call optimization），使递归变快了。<br>    斐波那契数列</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划那样计算更大的格局。</p>
<h2 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h2><p>时间复杂度O(n)的代码只有一层循环，而O(n 2 )的代码有双层嵌套循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很可能就是O(n 3 )。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="序列数据结构"><a href="#序列数据结构" class="headerlink" title="序列数据结构"></a>序列数据结构</h2><p>1.数组（列表）<br>2.栈<br>3.队列<br>&nbsp;&nbsp;普通队列<br>&nbsp;&nbsp;优先队列<br>&nbsp;&nbsp;循环队列<br>4.链表<br>&nbsp;&nbsp;单向链表<br>&nbsp;&nbsp;双向链表<br>&nbsp;&nbsp;循环单向链表<br>&nbsp;&nbsp;循环双向链表<br>5.集合 Set</p>
<h2 id="非序列数据结构"><a href="#非序列数据结构" class="headerlink" title="非序列数据结构"></a>非序列数据结构</h2><p>1.散列<br>2.字典 Map</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC学习</title>
    <url>/2017/MVC%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><pre><code>MVC的全名是Model View Controller，是模型（model）--视图（view）--控制器（controller）的缩写，是一种软件设计典范。
M（数据模型）：比如你设计一个User对象，包含username和password属性，它就是一个简单的M。
M是指业务模型，V是指用户界面，C则是控制器。
</code></pre><h3 id="在web开发中"><a href="#在web开发中" class="headerlink" title="在web开发中"></a>在web开发中</h3><pre><code>V--即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。
    MVC的好处之一在于它能为应用程序处理很多不同的视图。
    在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。
M--即Model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。
    被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，
    由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。
C--即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，
    控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，
    然后再确定用哪个视图来显示返回的数据。
它们三者的关系
</code></pre><p><img src="http://images2015.cnblogs.com/blog/811883/201704/811883-20170423150019101-1710764799.jpg" alt="mvc关系图"><br>    用户首先在界面中进行人机交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型，<br>    模型可以与数据库进行交互，进行增删改查操作，完成之后，根据业务的逻辑选择相应的视图进行显示，此时用户获得此次交互的反馈信息，<br>    用户可以进行下一步交互，如此循环。</p>
<h3 id="每层主要的功能"><a href="#每层主要的功能" class="headerlink" title="每层主要的功能"></a>每层主要的功能</h3><pre><code>视图（View）：用户界面
控制器（Controller）：业务逻辑
模型（Model）：数据保存
</code></pre><p><img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt="各部分之间的通信方式如下"></p>
<h3 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h3><pre><code>控制器（Controller）- 负责转发请求，对请求进行处理。
视图（View） - 界面设计人员进行图形界面设计。
模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。
</code></pre><p><img src="/images/ModelViewControllerDiagramZh.png" alt="图解MVC"></p>
<pre><code>将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。
模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。
“Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。
但是 Model 中数据的变化一般会通过一种刷新机制被公布。
为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比较：观察者模式（软件设计模式））
视图（View）能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。
为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。
控制器（Controller）起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。
“事件”包括用户的行为和数据 Model 上的改变。
</code></pre><h3 id="javscript的一个MVC示例"><a href="#javscript的一个MVC示例" class="headerlink" title="javscript的一个MVC示例"></a>javscript的一个MVC示例</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 模擬 Model, View, Controller */</span><br><span class="line">var M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/** Model 負責存放資料 */</span><br><span class="line">M.data = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">/** View 負責將資料輸出到螢幕上 */</span><br><span class="line">V.render = (M) =&gt; &#123; alert(M.data); &#125;</span><br><span class="line"></span><br><span class="line">/** Controller 作為一個 M 和 V 的橋樑 */</span><br><span class="line">C.handleOnload = () =&gt; &#123; V.render(M); &#125;</span><br><span class="line"></span><br><span class="line">/** 在網頁讀取的時候呼叫 Controller */</span><br><span class="line">window.onload = C.handleOnload;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/diyunfei/p/6752618.html" target="_blank" rel="noopener">MVC简介</a><br>    <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">阮一峰</a><br>    <a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">wiki-MVC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层与TCP/IP五层网络架构</title>
    <url>/2017/OSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.html</url>
    <content><![CDATA[<p>还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，<br>从参加工作一直做的WEB前端开发，对这方面知识也不是太需要。<br>但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol>
<li>OSI：开放系统互连参考模型 (Open System Interconnect 简称OSI）。</li>
<li>TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li>IP：网络之间互连的协议（IP）是Internet Protocol的外语缩写，中文缩写为“网协”。</li>
<li>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。</li>
<li>HTTPS：HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</li>
</ol>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><pre><code>OSI七层结构--每层的解释
</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E6%9E%84%E6%9E%B6%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.jpg" alt="OSI七层结构"><br>    OSI七层结构–每层结构的功能<br><img src="http://oxpnrlb4j.bkt.clouddn.com/osi%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="OSI七层结构"></p>
<h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><pre><code>OSI七层模型与TCP/IP五层模型的关系
</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.png" alt="TCP/IP五层模型"><br>    OSI七层模型–每层的设备<br><img src="http://oxpnrlb4j.bkt.clouddn.com/tcp%E5%92%8Cip%E8%AE%BE%E5%A4%87.jpg" alt="各层对应的设备"></p>
<h1 id="对各层的详细说明"><a href="#对各层的详细说明" class="headerlink" title="对各层的详细说明"></a>对各层的详细说明</h1><ol>
<li>第一层是物理层（PhysicalLayer)，<br>规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。<br>具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；<br>电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等；<br>功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；<br>规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。<br>在这一层，数据的单位称为比特（bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。</li>
<li>第二层是数据链路层<br>在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，<br>并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。<br>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br>在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</li>
<li>第三层是网络层<br>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。<br>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。<br>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。<br>如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。<br>IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。<br>地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。<br>网络层协议的代表包括：IP、IPX、RIP、OSPF等。</li>
<li>第四层是处理信息的传输层<br>第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，<br>TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。<br>这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。<br>第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。<br>所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。<br>传输层协议的代表包括：TCP、UDP、SPX等。</li>
<li>第五层是会话层<br>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，<br>而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。<br>如服务器验证用户登录便是由会话层完成的。</li>
<li>第六层是表示层<br>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，<br>转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。<br>数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li>
<li>第七层应用层<br>应用层为操作系统或网络应用程序提供访问网络服务的接口。<br>应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。</li>
</ol>
<blockquote>
<p>   参考文档<br>    <a href="https://www.2cto.com/net/201310/252965.html" target="_blank" rel="noopener">OSI七层与TCP/IP五层网络架构详解</a><br>    <a href="http://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="noopener">OSI七层模型与TCP/IP五层模型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Object的扩展、密密封、冻结</title>
    <url>/2017/Object%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%81%E5%AF%86%E5%AF%86%E5%B0%81%E3%80%81%E5%86%BB%E7%BB%93.html</url>
    <content><![CDATA[<h2 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h2><pre><code>Object.isExtensible(obj)
    判断一个对象是可扩展(是否能有新的属性添加到它)。
Object.preventExtensions(obj)
    可以对对象的属性进行修改和删除，不能向自身添加属性但可以向其原型添加属性。
示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Object.create(proto[, propertiesObject]);</span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 1,</span><br><span class="line">	b: 2</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Object.isExtensible(obj)); // true</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">console.log(Object.isExtensible(obj)); // false</span><br><span class="line">// obj.a = 3; // 可以修改原有属性</span><br><span class="line">// delete obj.a; // 可以删除原有属性</span><br><span class="line">// obj.c = 3; // 不能自身添加属性		</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h2><pre><code>Object.isSealed()
    判断一个对象是密封的。
Object.seal()
    密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。
    属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性。
    将所有现有的属性标记为不可配置。现在的属性的值仍然可以改变,只要它们是可写的。
示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  prop: function() &#123;&#125;,</span><br><span class="line">  foo: &apos;bar&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var o = Object.seal(obj);</span><br><span class="line">console.log(o === obj); // true</span><br><span class="line">Object.isSealed(obj); // === true</span><br><span class="line"></span><br><span class="line">obj.foo = &apos;quux&apos;; // 可以改变属性</span><br><span class="line"></span><br><span class="line">// 不能改变属性访问器，会抛出错误</span><br><span class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</span><br><span class="line">  get: function() &#123; return &apos;g&apos;; &#125;</span><br><span class="line">&#125;); // throws a TypeError</span><br><span class="line"></span><br><span class="line">// 不能添加新属性</span><br><span class="line">obj.quaxxor = &apos;the friendly duck&apos;;</span><br><span class="line"></span><br><span class="line">// 不能删除原有属性</span><br><span class="line">delete obj.foo;</span><br><span class="line"></span><br><span class="line">// 可以更改属性，只要它是可写的</span><br><span class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</span><br><span class="line">  value: &apos;eit&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h2><pre><code>Object.isFrozen()
Object.freeze()
    防止新的属性被添加到它;防止现有的属性被移除;
    和防止现有的属性,或他们的可数性,可配置性,或可写性,被改变了,它还可以防止原型被改变了。
    该方法返回对象处于冻结状态。
示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  prop: function() &#123;&#125;,</span><br><span class="line">  foo: &apos;bar&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 返回已被冻结的对象</span><br><span class="line">var o = Object.freeze(obj);</span><br><span class="line"></span><br><span class="line">// o === obj; // true</span><br><span class="line">Object.isFrozen(obj); // === true</span><br><span class="line"></span><br><span class="line">// 改变原有属性失败</span><br><span class="line">obj.foo = &apos;quux&apos;; // silently does nothing</span><br><span class="line">// 添加属性失败</span><br><span class="line">obj.quaxxor = &apos;the friendly duck&apos;;</span><br><span class="line">// 删除原有属性失败</span><br><span class="line">delete obj.foo; // throws a TypeError</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">// 重新配置原有属性失败</span><br><span class="line">Object.defineProperty(obj, &apos;ohai&apos;, &#123; value: 17 &#125;);</span><br><span class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;eit&apos; &#125;);</span><br><span class="line"></span><br><span class="line">// 向原型中添加属性失败</span><br><span class="line">Object.setPrototypeOf(obj, &#123; x: 20 &#125;)</span><br><span class="line">obj.__proto__ = &#123; x: 20 &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="浅冻结与深冻结"><a href="#浅冻结与深冻结" class="headerlink" title="浅冻结与深冻结"></a>浅冻结与深冻结</h2><pre><code>如该方法 MDN 的描述所述，倘若一个对象的属性是一个对象，
那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结，
若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">	obj = &#123;</span><br><span class="line">		internal :&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Object.freeze(obj);//浅冻结</span><br><span class="line">	obj.internal.a = &quot;aValue&quot;;</span><br><span class="line">	console.log(obj.internal.a);//&quot;aValue&quot;</span><br><span class="line"></span><br><span class="line">	//想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数.</span><br><span class="line">	function deepFreeze(o)&#123;</span><br><span class="line">		var prop,propKey;</span><br><span class="line">		Object.freeze(o);//首先冻结第一层对象</span><br><span class="line">		for(propKey in o)&#123;</span><br><span class="line">			prop = o[propKey];</span><br><span class="line">			if(!o.hasOwnProperty(propKey) || !(typeof prop === &quot;object&quot;) || Object.isFrozen(prop))&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			deepFreeze(prop);//递归</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	deepFreeze(obj);</span><br><span class="line">	obj.internal.b = &quot;bValue&quot;;//静默失败</span><br><span class="line">	console.log(obj.internal.b);//undefined</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000003894119" target="_blank" rel="noopener">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br>    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noopener">MDN</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>来几道Promise的题，看看你会几道?</title>
    <url>/2020/%E6%9D%A5%E5%87%A0%E9%81%93Promise%E7%9A%84%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E4%BC%9A%E5%87%A0%E9%81%93.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>本文将带你完成以下任务，相信你会更好掌握 Promise。
</code></pre><ol>
<li>JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个</li>
<li>实现Promise.all</li>
<li>实现Promise.any</li>
<li>实现Promise.race</li>
<li>Promise.allSettled</li>
<li>多个返回promise的函数串行执行</li>
<li>Promise 超时设计，利用Promise.race来实现</li>
</ol>
<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。<br>完整题目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// JS实现一个带并发限制的异步调度器Scheduler，</span><br><span class="line">// 保证同时运行的任务最多有两个。</span><br><span class="line">// 完善代码中Scheduler类，</span><br><span class="line">// 使得以下程序能正确输出</span><br><span class="line"></span><br><span class="line">class Scheduler &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		this.count = 2</span><br><span class="line">		this.queue = []</span><br><span class="line">		this.run = []</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	add(task) &#123;</span><br><span class="line">                 // ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const timeout = (time) =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line">	setTimeout(resolve, time)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const scheduler = new Scheduler()</span><br><span class="line">const addTask = (time, order) =&gt; &#123;</span><br><span class="line">	scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(1000, &apos;1&apos;)</span><br><span class="line">addTask(500, &apos;2&apos;)</span><br><span class="line">addTask(300, &apos;3&apos;)</span><br><span class="line">addTask(400, &apos;4&apos;)</span><br><span class="line">// output: 2 3 1 4</span><br><span class="line"></span><br><span class="line">// 一开始，1、2两个任务进入队列</span><br><span class="line">// 500ms时，2完成，输出2，任务3进队</span><br><span class="line">// 800ms时，3完成，输出3，任务4进队</span><br><span class="line">// 1000ms时，1完成，输出1</span><br><span class="line">// 1200ms时，4完成，输出4</span><br></pre></td></tr></table></figure></p>
<p>答案<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Scheduler &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.awatiArr = [];</span><br><span class="line">    this.count = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  async add(promiseCreator) &#123;</span><br><span class="line">    if (this.count &gt;= 2) &#123;</span><br><span class="line">      await new Promise((resolve) =&gt; &#123;</span><br><span class="line">        this.awatiArr.push(resolve);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.count++;</span><br><span class="line">    const res = await promiseCreator();</span><br><span class="line">    this.count--;</span><br><span class="line">    if (this.awatiArr.length) &#123;</span><br><span class="line">      // 前面promise的resolve</span><br><span class="line">      this.awatiArr.shift()();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const scheduler = new Scheduler();</span><br><span class="line">const timeout = (time) =&gt; &#123;</span><br><span class="line">  return new Promise(r =&gt; setTimeout(r, time))</span><br><span class="line">&#125;</span><br><span class="line">const addTask = (time, order) =&gt; &#123;</span><br><span class="line">  scheduler.add(() =&gt; timeout(time))</span><br><span class="line">    .then(() =&gt; console.log(order))</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">// addTask(1000, 1)</span><br><span class="line">// addTask(500, 2)</span><br><span class="line">// addTask(300, 3)</span><br><span class="line">// addTask(400, 4)</span><br></pre></td></tr></table></figure></p>
<p>解释</p>
<ol>
<li>当前执行并发大于等于2时，生成一个暂停的Promise，把resolve添到一个数组中，下面的代码被暂停执行</li>
<li>当前执行并发小于2, 立即执行异步操作并在该异步操作执行完毕后从数组中弹出最先push的resolve改变Promise的状态</li>
<li>由于Promise被resolve了，最初被暂停的代码可以继续执行</li>
<li>关键点为 Promise 没有被 resolve 或 reject 时后面代码会被暂停，Promise 的 resolve 或 reject 可以在Promise构造函数外执行<br><a href="http://blog.mapplat.com/public/javascript/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解释非常好的文章</a></li>
</ol>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>实现Promise.all()<br>// 结束条件：有一个 Promise rejected 或 所有 Promise resolved。 </p>
<ol>
<li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象</li>
<li>如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</li>
<li>如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</li>
<li>只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象</li>
<li>注意⚠️，不管是Promise.all、any、race还是allSettled，参数都是一个🉑️迭代对象及部署了[Symbol.iterator]方法（如array\string\map\set\有length属性的对象）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promiseAll(iterable) &#123;</span><br><span class="line">  let array = Array.from(iterable);</span><br><span class="line">  let resolveNum = 0;</span><br><span class="line">  let promiseNum = array.length;</span><br><span class="line">  let lists = new Array(promiseNum);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      Promise.resolve(array[i]).then(res =&gt; &#123;</span><br><span class="line">        lists[i] = res;</span><br><span class="line">        resolveNum++;</span><br><span class="line">        if (resolveNum === promiseNum) &#123;</span><br><span class="line">          return resolve(lists)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(reason =&gt; &#123;</span><br><span class="line">        return reject(reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// promiseAll([1, Promise.reject(12)]).then(res =&gt; &#123;</span><br><span class="line">//   console.log(res)</span><br><span class="line">// &#125;).catch(reason =&gt; &#123;</span><br><span class="line">//   console.log(reason)</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>实现Promise.any()</p>
<ol>
<li>结束条件：有一个 Promise resolved 或 所有 Promise rejected 就返回一个AggregateError类型的实例。</li>
<li>如果可迭代对象中没有一个 promise 成功（即所有的 promises 都拒绝），就返回一个失败的 promise 和AggregateError类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。<br>这里你有学习到了一个新的错误类型 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError" target="_blank" rel="noopener">AggregateError 快去看看吧</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promiseAny(iterable) &#123;</span><br><span class="line">  let array = Array.from(iterable);</span><br><span class="line">  let promiseNum = array.length;</span><br><span class="line">  let rejectNum = 0;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      Promise.resolve(array[i]).then(res =&gt; &#123;</span><br><span class="line">        return resolve(res);</span><br><span class="line">      &#125;).catch(error =&gt; &#123;</span><br><span class="line">        rejectNum++;</span><br><span class="line">        if (rejectNum === promiseNum) &#123;</span><br><span class="line">          return reject(new AggregateError(&quot;&quot;, &quot;All promises were rejected&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// var p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">//   setTimeout(reject, 500, &quot;one&quot;);</span><br><span class="line">// &#125;);</span><br><span class="line">// var p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">//   setTimeout(reject, 600, &quot;two&quot;);</span><br><span class="line">// &#125;);</span><br><span class="line">// promiseAny([p1, p2]).then(res =&gt; &#123;</span><br><span class="line">//   console.log(res)</span><br><span class="line">// &#125;).catch(error =&gt; &#123;</span><br><span class="line">//   console.log(error)</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>实现Promise.race()<br>结束条件：一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promiseRace(iterable) &#123;</span><br><span class="line">  let array = Array.from(iterable);</span><br><span class="line">  let promiseNum = array.length;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      Promise.resolve(array[i]).then(res =&gt; &#123;</span><br><span class="line">        return resolve(res);</span><br><span class="line">      &#125;).catch(error =&gt; &#123;</span><br><span class="line">        return reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// var p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">//   setTimeout(resolve, 500, &quot;one&quot;);</span><br><span class="line">// &#125;);</span><br><span class="line">// var p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">//   setTimeout(reject, 600, &quot;two&quot;);</span><br><span class="line">// &#125;);</span><br><span class="line">// promiseRace([p1, p2]).then(res =&gt; &#123;</span><br><span class="line">//   console.log(res)</span><br><span class="line">// &#125;).catch(error =&gt; &#123;</span><br><span class="line">//   console.log(error)</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>Promise.allSettled()</p>
<ol>
<li>结束条件：所有给定的promise都已经fulfilled或rejected后的promise。</li>
<li>对于 promise 为 resolved 时对象为 {status: ‘fulfilled’, value: promise的值}</li>
<li>对于 promise 为 rejected 时对象为 {status: ‘rejected’, reason: rejected的原因}</li>
</ol>
<p>目前是用在我们SSR项目中，一次性会在服务端发起多个请求，总不能一个请求挂掉都把成功的请求都丢弃吧，你可是试试这个方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promiseAllSettled(iterable) &#123;</span><br><span class="line">  let array = Array.from(iterable);</span><br><span class="line">  let promiseNum = array.length;</span><br><span class="line">  let num = 0;</span><br><span class="line">  let list = new Array(promiseNum);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      let obj = &#123;</span><br><span class="line">        status: &apos;&apos;</span><br><span class="line">      &#125;;</span><br><span class="line">      Promise.resolve(array[i]).then(res =&gt; &#123;</span><br><span class="line">        obj.status = &apos;fulfilled&apos;;</span><br><span class="line">        obj.value = res;</span><br><span class="line">      &#125;).catch(error =&gt; &#123;</span><br><span class="line">        obj.status = &apos;rejected&apos;;</span><br><span class="line">        obj.reason = error;</span><br><span class="line">      &#125;).finally(() =&gt; &#123;</span><br><span class="line">        num++;</span><br><span class="line">        list[i] = obj;</span><br><span class="line">        if (promiseNum === num) &#123;</span><br><span class="line">          return resolve(list);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// const promise1 = Promise.reject(3);</span><br><span class="line">// const promise2 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 100, &apos;foo&apos;));</span><br><span class="line">// promiseAllSettled([promise1, promise2]).then(res =&gt; &#123;</span><br><span class="line">//   console.log(res)</span><br><span class="line">// &#125;).catch(error =&gt; &#123;</span><br><span class="line">//   console.log(error)</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>多个返回promise的函数串行执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 实现一</span><br><span class="line">function promiseSerial(array) &#123;</span><br><span class="line">  if (array.length === 0) throw &apos;参数数组至少有一项&apos;</span><br><span class="line">  array.reduce((preP, nextP) =&gt; &#123;</span><br><span class="line">    return preP.then(() =&gt; nextP());</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现二</span><br><span class="line">async function promiseSerial1(array) &#123;</span><br><span class="line">  if (array.length === 0) throw &apos;参数数组至少有一项&apos;</span><br><span class="line">  for (let promise of array) &#123;</span><br><span class="line">    await promise();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const createPromise = (time, id) =&gt; () =&gt;</span><br><span class="line">  new Promise(solve =&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(Date.now() / 1000);</span><br><span class="line">      console.log(&quot;promise&quot;, id);</span><br><span class="line">      solve();</span><br><span class="line">    &#125;, time)</span><br><span class="line">  );</span><br><span class="line">// test</span><br><span class="line">// promiseSerial1([</span><br><span class="line">//   createPromise(1000, 1),</span><br><span class="line">//   createPromise(1000, 2),</span><br><span class="line">//   createPromise(1000, 3)</span><br><span class="line">// ])</span><br></pre></td></tr></table></figure></p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><p>Promise 超时设计，利用Promise.race来实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function resolveAfter(ms, value = undefined) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;timeout&apos;);</span><br><span class="line">      resolve(value || Promise.reject(new Error(&apos;Operation timed out&apos;)));</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function PromiseTimeout(ms, promise) &#123;</span><br><span class="line">  return Promise.race([</span><br><span class="line">    promise,</span><br><span class="line">    resolveAfter(ms)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">// var p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">//   setTimeout(() =&gt; &#123;</span><br><span class="line">//     console.log(&apos;p1&apos;);</span><br><span class="line">//     resolve(&apos;p1-resolved&apos;)</span><br><span class="line">//   &#125;, 1000);</span><br><span class="line">// &#125;)</span><br><span class="line">// PromiseTimeout(100, p1).then(res =&gt; &#123;</span><br><span class="line">//   console.log(res)</span><br><span class="line">// &#125;).catch(error =&gt; &#123;</span><br><span class="line">//   console.log(error)</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><pre><code>行文匆忙（主要是要哄👶睡觉了），本文主要是个人对 Promise 的一些理解，如有错误还望斧正。
</code></pre>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise的用法</title>
    <url>/2017/Promise%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<p>ES6出来了很久，Promise也一直在用，现在总结一下具体用法。</p>
<h1 id="Promise-定义"><a href="#Promise-定义" class="headerlink" title="Promise 定义"></a>Promise 定义</h1><p>Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="MDN"><br>    这里使用MDN的图片</p>
<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="创造了一个-Promise-实例"><a href="#创造了一个-Promise-实例" class="headerlink" title="创造了一个 Promise 实例"></a>创造了一个 Promise 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">	resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">	reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="对-Promise-实例成功-或-失败-做相应的处理"><a href="#对-Promise-实例成功-或-失败-做相应的处理" class="headerlink" title="对 Promise 实例成功 或 失败 做相应的处理"></a>对 Promise 实例成功 或 失败 做相应的处理</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<h2 id="分为三种调用形式（注意最后面需要带着错误处理函数）"><a href="#分为三种调用形式（注意最后面需要带着错误处理函数）" class="headerlink" title="分为三种调用形式（注意最后面需要带着错误处理函数）"></a>分为三种调用形式（注意最后面需要带着错误处理函数）</h2><ol>
<li>promise.then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li>
<li>promise.then((resolve) =&gt; { // 成功的处理函数 }).then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li>
<li>promise.then(null, (reject) =&gt; { // 错误的处理函数 })</li>
</ol>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个<span style="color: red">新的</span>Promise 对象，从而达到链式调用。</p>
<h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(resolve) &#123;</span><br><span class="line">  // 成功的处理函数</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p>
<p>PS：Promise.all方法接受一个数组或具有Iterator 接口的对象作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>（1）只有p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p>
<p>PS：Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</span><br></pre></td></tr></table></figure></p>
<p>PS：将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<h2 id="根据不同参数，返回结果情况"><a href="#根据不同参数，返回结果情况" class="headerlink" title="根据不同参数，返回结果情况"></a>根据不同参数，返回结果情况</h2><ol>
<li>参数是一个Promise实例<br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个thenable对象（thenable对象指的是具有then方法的对象）<br>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</li>
<li>参数不是具有then方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</li>
<li>不带有任何参数<br>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。</li>
</ol>
<h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br>下面两种形式一样：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p = Promise.reject(&apos;出错了&apos;);</span><br><span class="line">// 等同于</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</span><br><span class="line"></span><br><span class="line">p.then(null, function (s) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p>
<h1 id="自己部署有用的方法"><a href="#自己部署有用的方法" class="headerlink" title="自己部署有用的方法"></a>自己部署有用的方法</h1><h2 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<h3 id="部署-done-方法"><a href="#部署-done-方法" class="headerlink" title="部署 done 方法"></a>部署 done 方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.prototype.done = function (onFulfilled, onRejected) &#123;</span><br><span class="line">  this.then(onFulfilled, onRejected)</span><br><span class="line">	.catch(function (reason) &#123;</span><br><span class="line">	  // 抛出一个全局错误</span><br><span class="line">	  setTimeout(() =&gt; &#123; throw reason &#125;, 0);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asyncFunc()</span><br><span class="line">	.then(f1)</span><br><span class="line">	.catch(r1)</span><br><span class="line">	.then(f2)</span><br><span class="line">	.done();</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h2><h3 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<h3 id="部署finally方法"><a href="#部署finally方法" class="headerlink" title="部署finally方法"></a>部署finally方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">  let P = this.constructor;</span><br><span class="line">  return this.then(</span><br><span class="line">	value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">	reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.listen(0)</span><br><span class="line">	.then(function () &#123;</span><br><span class="line">	// run test</span><br><span class="line">	&#125;)</span><br><span class="line">	.finally(server.stop);</span><br></pre></td></tr></table></figure></p>
<h1 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h1><p><span style="color: red">目前还为提案，Promise 库Bluebird、Q和when，提供了这个方法。</span></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。    </p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.try(f) // 这里不需要管 f 是同步还是异步函数。</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const preloadImage = function (path) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">	const image = new Image();</span><br><span class="line">	image.onload  = resolve;</span><br><span class="line">	image.onerror = reject;</span><br><span class="line">	image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">preloadImage</span><br><span class="line">	.then((reslove) =&gt; &#123; console.log(&apos;图片加载成功了哦！&apos;) &#125;)</span><br><span class="line">	.catch((reject) =&gt; &#123; console.log(&apos;图片加载失败了哦！&apos;) &#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN–Promiese</a><br>    <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰–Promise</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy和Reflect的用法</title>
    <url>/2017/Proxy%E5%92%8CReflect%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h1><h2 id="Proxy-定义"><a href="#Proxy-定义" class="headerlink" title="Proxy 定义"></a>Proxy 定义</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<h2 id="Proxy-语法"><a href="#Proxy-语法" class="headerlink" title="Proxy 语法"></a>Proxy 语法</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 目标对象，需要被拦截 或 处理的对象，数组，函数甚至是其他的代理器</span><br><span class="line">let target = &#123;&#125;;</span><br><span class="line">// 拦截器对象</span><br><span class="line">let handler = &#123;</span><br><span class="line">	get(target, name)&#123;</span><br><span class="line">		// 这里如果 target 没有name属性的话，就设定一个默认值</span><br><span class="line">		return name in target ? target[name] : 27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">console.log(target.name); // undefined</span><br><span class="line">console.log(proxy.name); // 27</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<h2 id="Proxy-支持的拦截操作一览，一共13种"><a href="#Proxy-支持的拦截操作一览，一共13种" class="headerlink" title="Proxy 支持的拦截操作一览，一共13种"></a>Proxy 支持的拦截操作一览，一共13种</h2><ol>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<h2 id="Proxy-revocable-可撤销的代理"><a href="#Proxy-revocable-可撤销的代理" class="headerlink" title="Proxy.revocable() 可撤销的代理"></a>Proxy.revocable() 可撤销的代理</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let target = &#123;&#125;;</span><br><span class="line">let handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = 123;</span><br><span class="line">console.log(proxy.foo);</span><br><span class="line"></span><br><span class="line">revoke(); // 取消Proxy实例</span><br><span class="line">console.log(proxy.foo); // TypeError: Revoked</span><br></pre></td></tr></table></figure></p>
<p>PS：Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。<br>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-的问题"><a href="#this-的问题" class="headerlink" title="this 的问题"></a>this 的问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">  m: function () &#123;</span><br><span class="line">	console.log(this === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() // false</span><br><span class="line">proxy.m()  // true</span><br></pre></td></tr></table></figure></p>
<h2 id="Proxy-的应用"><a href="#Proxy-的应用" class="headerlink" title="Proxy 的应用"></a>Proxy 的应用</h2><h3 id="扩展数组的属性和方法"><a href="#扩展数组的属性和方法" class="headerlink" title="扩展数组的属性和方法"></a>扩展数组的属性和方法</h3><p>需求：对于数组对象，有时候我们只想要得到数组中对象的某个键值内容。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var AddSomeFunctionHandler=&#123;</span><br><span class="line">	get:function(obj,prop)&#123;</span><br><span class="line"></span><br><span class="line">		if(prop in obj)&#123;</span><br><span class="line">			return obj[prop]   // 按数组默认方式访问元素</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(prop === &apos;name&apos;)&#123;</span><br><span class="line">			return obj.map(o=&gt;o.name)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var PersonArray=[&#123;</span><br><span class="line">	name:&quot;Alice&quot;,age:23</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name:&quot;Bob&quot;,age:45</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name:&quot;Mike&quot;,age:27</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">var p= new Proxy(PersonArray,AddSomeFunctionHandler)</span><br><span class="line">console.log(p.name) // [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br></pre></td></tr></table></figure></p>
<h1 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h1><h2 id="Reflect-定义"><a href="#Reflect-定义" class="headerlink" title="Reflect 定义"></a>Reflect 定义</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。<br>Reflect对象的设计目的有这样几个：</p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li>
</ol>
<h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><p>Reflect对象一共有13个静态方法。</p>
<ol>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)<br>PS：上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</li>
</ol>
<h2 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h2><p>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2,</span><br><span class="line">  get baz() &#123;</span><br><span class="line">	return this.foo + this.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reflect.get(myObject, &apos;foo&apos;) // 1</span><br><span class="line">Reflect.get(myObject, &apos;bar&apos;) // 2</span><br><span class="line">Reflect.get(myObject, &apos;baz&apos;) // 3</span><br></pre></td></tr></table></figure></p>
<h2 id="实例–使用-Proxy-实现观察者模式"><a href="#实例–使用-Proxy-实现观察者模式" class="headerlink" title="实例–使用 Proxy 实现观察者模式"></a>实例–使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。<br>如果你还不懂<a href>观察者模式</a><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//添加观察者</span><br><span class="line">const queuedObservers = new Set();</span><br><span class="line">const observe = fn =&gt; queuedObservers.add(fn);</span><br><span class="line"></span><br><span class="line">//proxy 的set 方法</span><br><span class="line">function set(target, key, value, receiver) &#123;</span><br><span class="line">	const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">	queuedObservers.forEach(observer =&gt; observer());</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">//创建proxy代理</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</span><br><span class="line">//被观察的 对象</span><br><span class="line">const person = observable(&#123;</span><br><span class="line">	name: &apos;张三&apos;,</span><br><span class="line">	age: 20</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">console.log(person.name); // 张三</span><br><span class="line">person.name = &apos;李四&apos;;</span><br><span class="line">console.log(person.name); // 李四</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener">阮一峰-Reflect</a><br>    <a href="https://www.cnblogs.com/WhiteHorseIsNotHorse/p/7016010.html" target="_blank" rel="noopener">用es6 （proxy 和 reflect）轻松实现 观察者模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API 设计指南</title>
    <url>/2017/RESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97.html</url>
    <content><![CDATA[<h2 id="RESTful-API-的产生"><a href="#RESTful-API-的产生" class="headerlink" title="RESTful API 的产生"></a>RESTful API 的产生</h2><pre><code>当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。
因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信，在这种情况下RESTful API产生了。
</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><pre><code>HTTP、HTTPS 应用层协议。 
联网的设备 和 服务器之前的通信。
</code></pre><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ol>
<li>API专用域名<br><a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a></li>
<li>API放在主域名<br><a href="https://example.org/api/" target="_blank" rel="noopener">https://example.org/api/</a></li>
</ol>
<h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><pre><code>将API的版本放入URL中。
https://api.example.com/v1
</code></pre><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote>
<p>   路径又称”终点”（endpoint），表示API的具体网址。<br>    在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>    举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><pre><code>对于资源的具体操作类型，由HTTP动词表示。
常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
</code></pre><ol>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。    </li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）:从服务器删除资源。<br>不常用的两个动词</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的那些属性是客户端可以改变的。<br>动物园管理系统举例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /zoos: 列出所有动物园。</span><br><span class="line">POST /zoos: 新建一个动物园（动物园的信息的请求体中）。</span><br><span class="line">GET /zoos/ID: 获取某个动物园的信息。</span><br><span class="line">PUT /zoos/ID: 更新某个指定动物园的信息（提供该动物园的全部信息）。</span><br><span class="line">PATCH /zoos/ID: 更新某个动物园的信息（提供该动物园的部分信息）。</span><br><span class="line">DELETE /zoos/ID: 删除某个动物园。</span><br><span class="line">GET /zoos/ID/animals: 列出某个指定动物园的所有动物。</span><br><span class="line">DELETE /zoos/ID/animals/ID: 删除某个动物园的指定动物。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><pre><code>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure>

参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。
比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。
</code></pre><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote>
<p>   服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>状态码的完全列表参见[w3c](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
</code></pre><h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><pre><code>如果状态码是4xx，就应该向用户返回出错信息。
一般来说，返回的信息中将error作为键名，出错信息作为键值即可。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	error: &quot;Invalid API key&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote>
<p>   针对不同操作，服务器向用户返回的结果应该符合以下规范。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>（1）API的身份认证应该使用OAuth 2.0框架。
（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计</a></p>
</blockquote>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ramda库学习</title>
    <url>/2017/Ramda%E5%BA%93%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p><a href="https://github.com/fanerge/Ramda-study.git" target="_blank" rel="noopener">学习源代码</a><br>经过4个晚上的学习，了解了ramda库120多个api的用法，下一步继续深入学习函数式编程。<br>继续学习js函数式编程，这里贴出阮老师总结的Ramda的优点：</p>
<pre><code>1.    Ramda 的数据一律放在最后一个参数，理念是&quot;function first，data last&quot;。
2.    所有方法都支持柯里化。
</code></pre><h4 id="一、比较运算（gt、gte、lt、lte、eauals、eqBy）"><a href="#一、比较运算（gt、gte、lt、lte、eauals、eqBy）" class="headerlink" title="一、比较运算（gt、gte、lt、lte、eauals、eqBy）"></a>一、比较运算（gt、gte、lt、lte、eauals、eqBy）</h4><pre><code>gt：判断第一个参数是否大于第二个参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let gt1 = R.gt(2)(1);</span><br><span class="line">// console.log(gt1); true</span><br><span class="line">let gt2 = R.gt(&apos;a&apos;)(&apos;c&apos;);</span><br><span class="line">// console.log(gt2); false</span><br></pre></td></tr></table></figure>

gte：判断第一个参数是否大于等于第二个参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let gte1 = R.gte(2)(2);</span><br><span class="line">// console.log(gte1); true</span><br><span class="line">let gte2 = R.gte(&apos;a&apos;)(&apos;c&apos;);</span><br><span class="line">// console.log(gte2); false</span><br></pre></td></tr></table></figure>

lt：判断第一个参数是否小于第二个参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let lt1 = R.lt(2)(1);</span><br><span class="line">// console.log(lt1); false</span><br><span class="line">let lt2 = R.lt(&apos;a&apos;)(&apos;z&apos;);</span><br><span class="line">// console.log(lt2); true</span><br></pre></td></tr></table></figure>

lte：判断第一个参数是否小于等于第二个参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let lte1 = R.lte(1)(2);</span><br><span class="line">// console.log(lte1); true</span><br><span class="line">let lte2 = R.lte(&apos;a&apos;)(&apos;v&apos;);</span><br><span class="line">// console.log(lte2); true</span><br></pre></td></tr></table></figure>

eauals：比较两个值是否相等（支持对象的比较）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let equals1 = R.equals(1)(1);</span><br><span class="line">// console.log(equals1); true</span><br><span class="line">let equals2 = R.equals(1)(&apos;1&apos;);</span><br><span class="line">// console.log(equals2); false</span><br><span class="line">let equals3 = R.equals([1, 2])([1,2]);</span><br><span class="line">// console.log(equals3); // true</span><br><span class="line">let equals4 = R.equals(&#123;a:1&#125;)(&#123;a:2&#125;);</span><br><span class="line">// console.log(equals4); // false</span><br></pre></td></tr></table></figure>

eqBy：比较两个值传入指定函数的运算结果是否相等。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let eqBy1 = R.eqBy(Math.abs, 5, -5);</span><br><span class="line">console.log(eqBy1);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="二、数学运算（add、subtract、multiply、divide）"><a href="#二、数学运算（add、subtract、multiply、divide）" class="headerlink" title="二、数学运算（add、subtract、multiply、divide）"></a>二、数学运算（add、subtract、multiply、divide）</h4><pre><code>add：返回两个值的和。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add1 = R.add(1)(10);</span><br><span class="line">// console.log(add1); // 11</span><br></pre></td></tr></table></figure>

subtract：返回第一个参数减去第二个参数的差。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subtract1 = R.subtract(10)(2);</span><br><span class="line">//console.log(subtract1); // 8</span><br></pre></td></tr></table></figure>

multiply：返回两个值的积。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let multiply1 = R.multiply(5)(6);</span><br><span class="line">// console.log(multiply1); // 30</span><br></pre></td></tr></table></figure>

divide：返回第一个参数除以第二个参数的商。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let divide1 = R.divide(5)(10);</span><br><span class="line">// console.log(divide1); // 0.5</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="三、逻辑运算（either、both、allPass）"><a href="#三、逻辑运算（either、both、allPass）" class="headerlink" title="三、逻辑运算（either、both、allPass）"></a>三、逻辑运算（either、both、allPass）</h4><pre><code>either：接收两个参数，相当于 || 运算（或）。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let gt10 = x =&gt; x &gt; 10;</span><br><span class="line">let even = x =&gt; x % 2 === 0;</span><br><span class="line">let either1 = R.either(gt10)(even);</span><br><span class="line">let either2 = either1(18);</span><br><span class="line">let either3 = either1(3);</span><br><span class="line">// console.log(either2); // true</span><br><span class="line">//console.log(either3); // false</span><br></pre></td></tr></table></figure>

both：接收两个参数，相当于 &amp;&amp; 运算（且）。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gt10 = x =&gt; x &gt; 10;</span><br><span class="line">var even = x =&gt; x % 2 === 0;</span><br><span class="line">let both1 = R.both(gt10)(even);</span><br><span class="line">let both2 = both1(18);</span><br><span class="line">let both3 = both1(4);</span><br><span class="line">// console.log(both2); // true</span><br><span class="line">// console.log(both3); // false</span><br></pre></td></tr></table></figure>

allPass：接受一个函数数组作为参数，只有它们都返回true，才返回true，否则返回false。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gt10 = x =&gt; x &gt; 10;</span><br><span class="line">var lt20 = x =&gt; x &lt; 20;</span><br><span class="line">var even = x =&gt; x % 2 === 0;</span><br><span class="line">let allPass1 = R.allPass([gt10, even, lt20]);</span><br><span class="line">let allPass2 = allPass1(16);</span><br><span class="line">let allPass3 = both1(13);</span><br><span class="line">console.log(allPass2); // true</span><br><span class="line">console.log(allPass3); // false</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="四、字符串（split、test、match）"><a href="#四、字符串（split、test、match）" class="headerlink" title="四、字符串（split、test、match）"></a>四、字符串（split、test、match）</h4><pre><code>split：按照指定分隔符将字符串拆成一个数组。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let split1 = R.split(&apos;.&apos;)(&apos;a.b.c.fanerge&apos;);</span><br><span class="line">// console.log(split1); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;fanerge&quot;]</span><br></pre></td></tr></table></figure>

test：判断一个字符串是否匹配给定的正则表达式。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let test1 = R.test(/^f/)(&apos;fanerge&apos;);</span><br><span class="line">// console.log(test1); // true</span><br></pre></td></tr></table></figure>

match：返回一个字符串的匹配结果。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let match1 = R.match(/([a-z]a)/g)(&apos;bananas&apos;)</span><br><span class="line">// console.log(match1); // [&quot;ba&quot;, &quot;na&quot;, &quot;na&quot;]</span><br><span class="line">let match2 = R.match(/a/)(&apos;n&apos;);</span><br><span class="line">// console.log(match2); // []</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h4><h5 id="5-1-函数的合成（compose、pipe、converge）"><a href="#5-1-函数的合成（compose、pipe、converge）" class="headerlink" title="5.1 函数的合成（compose、pipe、converge）"></a>5.1 函数的合成（compose、pipe、converge）</h5><pre><code>compose：将多个函数合并成一个函数，从右到左执行
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let compose1 = R.compose(Math.abs, R.add(1), R.multiply(2))(4)</span><br><span class="line">console.log(compose1); // 9</span><br></pre></td></tr></table></figure>

pipe：将多个函数合并成一个函数，从左到右执行。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pipe1 = R.pipe(Math.abs, R.add(1), R.multiply(2))(4);</span><br><span class="line">console.log(pipe1); // 10</span><br></pre></td></tr></table></figure>

converge：接受两个参数，第一个参数是函数，第二个参数是函数数组。传入的值先使用第二个参数包含的函数分别处理以后，再用第一个参数处理前一步生成的结果。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sumOfArr = arr =&gt; &#123;</span><br><span class="line">	let sum = 0;</span><br><span class="line">	arr.forEach(i =&gt; sum += i);</span><br><span class="line">	return sum;</span><br><span class="line">&#125;;</span><br><span class="line">var lengthArr = arr =&gt; arr.length;</span><br><span class="line">var converge1 = R.converge(R.divide, [sumOfArr, lengthArr]);</span><br><span class="line">var converge2 = converge1([1, 2, 3, 4, 5]);</span><br><span class="line">// console.log(converge2); // 3</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="5-2-柯里化（curry、partial、partialRight、useWith、memoize、complement）"><a href="#5-2-柯里化（curry、partial、partialRight、useWith、memoize、complement）" class="headerlink" title="5.2 柯里化（curry、partial、partialRight、useWith、memoize、complement）"></a>5.2 柯里化（curry、partial、partialRight、useWith、memoize、complement）</h4><pre><code>curry：将多个参数的函数，转化成单参数的形式。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d;</span><br><span class="line">var curriedAddFourNumbers = R.curry(addFourNumbers);</span><br><span class="line">var f = curriedAddFourNumbers(1)(2)(3)(4);</span><br><span class="line">// console.log(f); // 10</span><br></pre></td></tr></table></figure>

partial：允许多参数的函数接受一个数组，指定最左边的部分参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var multiply2 = (a, b) =&gt; a * b;</span><br><span class="line">var double = R.partial(multiply2, [3]);</span><br><span class="line">// console.log(double(2)); // 6</span><br></pre></td></tr></table></figure>

partialRight：与partial类似，但数组指定的参数为最右边的参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var greet = (salutation, title, firstName, lastName) =&gt;</span><br><span class="line">  salutation + &apos;, &apos; + title + &apos; &apos; + firstName + &apos; &apos; + lastName + &apos;!&apos;;</span><br><span class="line">var greetMsJaneJones = R.partialRight(greet, [&apos;Ms.&apos;, &apos;Jane&apos;, &apos;Jones&apos;]);</span><br><span class="line">var dd = greetMsJaneJones(&apos;Hello&apos;); </span><br><span class="line">console.log(dd); // &apos;Hello, Ms. Jane Jones!&apos;</span><br></pre></td></tr></table></figure>

useWith：接受一个函数fn和一个函数数组fnList作为参数，返回fn的柯里化版本。该新函数的参数，先分别经过对应的fnList成员处理，再传入fn执行。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var decreaseOne = x =&gt; x - 1;</span><br><span class="line">var increaseOne = x =&gt; x + 1;</span><br><span class="line">var useWith1 = R.useWith(Math.pow, [decreaseOne, increaseOne])(3)(4);</span><br><span class="line">console.log(useWith1) // 2^5 32</span><br></pre></td></tr></table></figure>

memoize：返回一个函数，会缓存每一次的运行结果。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var productOfArr = arr =&gt; &#123;</span><br><span class="line">  var product = 1;</span><br><span class="line">  arr.forEach(i =&gt; product *= i);</span><br><span class="line">  return product;</span><br><span class="line">&#125;;</span><br><span class="line">var count = 0;</span><br><span class="line">var factorial = R.memoize(n =&gt; &#123;</span><br><span class="line">  count += 1;</span><br><span class="line">  return productOfArr(R.range(1, n + 1));</span><br><span class="line">&#125;);</span><br><span class="line">var memoize1 = factorial(5);</span><br><span class="line">console.log(memoize1, count); // 120, 1</span><br></pre></td></tr></table></figure>

complement：返回一个新函数，如果原函数返回true，该函数返回false；如果原函数返回false，该函数返回true。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gt10 = x =&gt; x &gt; 10;</span><br><span class="line">var lte10 = R.complement(gt10);</span><br><span class="line">var complement1 = lte10(11);</span><br><span class="line">// console.log(complement1); // false</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="5-3-函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）"><a href="#5-3-函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）" class="headerlink" title="5.3 函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）"></a>5.3 函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）</h4><pre><code>binary：参数函数执行时，只传入最前面两个参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var takesThreeArgs = function (a, b, c) &#123;</span><br><span class="line">	return [a, b, c];</span><br><span class="line">&#125;;</span><br><span class="line">var takesTwoArgs = R.binary(takesThreeArgs);</span><br><span class="line">var binary1 = takesTwoArgs(1, 2, 3);</span><br><span class="line">// console.log(binary1); // [1, 2, undefined]</span><br></pre></td></tr></table></figure>

tap：将一个值传入指定函数，并返回该值。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sayX = x =&gt; console.log(&apos;x is&apos; + x);</span><br><span class="line">var tap1 = R.tap(sayX)(100);</span><br><span class="line">// console.log(tap1); // x is100 100</span><br></pre></td></tr></table></figure>

zipWith：将两个数组对应位置的值，一起作为参数传入某个函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f = (x, y) =&gt; &#123;</span><br><span class="line">	return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">var zipWith1 = R.zipWith(f)([1, 2, 3])([4, 5, 6]);</span><br><span class="line">// console.log(zipWith1); // [5, 7, 9]</span><br></pre></td></tr></table></figure>

apply：将数组转成参数序列，传入指定函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums = [1, 2, 3, -99, 42, 6, 7];</span><br><span class="line">var apply1 = R.apply(Math.max)(nums);</span><br><span class="line">// console.log(apply1); // 42</span><br></pre></td></tr></table></figure>

applySpec：返回一个模板函数，该函数会将参数传入模板内的函数执行，然后将执行结果填充到模板。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getMetrics = R.applySpec(&#123;</span><br><span class="line">	sum: R.add,</span><br><span class="line">	nested: &#123;mul: R.multiply&#125;</span><br><span class="line">&#125;);</span><br><span class="line">var applySpec1 = getMetrics(2, 4);</span><br><span class="line">//console.log(applySpec1); // &#123; sum: 6, nested: &#123; mul: 8 &#125; &#125;</span><br></pre></td></tr></table></figure>

ascend：返回一个升序排列的比较函数，主要用于排序。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var byAge = R.ascend(R.prop(&apos;age&apos;));</span><br><span class="line">var people = [</span><br><span class="line">	&#123;name: &apos;fan&apos;, age: 11&#125;,</span><br><span class="line">	&#123;name: &apos;yu&apos;, age: 8&#125;,</span><br><span class="line">	&#123;name: &apos;zhen&apos;, age: 9&#125;</span><br><span class="line">];</span><br><span class="line">var ascend1 = R.sort(byAge)(people);</span><br><span class="line">// console.log(ascend1); // [ &#123;name: &apos;yu&apos;, age: 8&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;, name: &apos;fan&apos;, age: 11&#125;];</span><br></pre></td></tr></table></figure>

ascend：返回一个升序排列的比较函数，主要用于排序。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var byAge = R.descend(R.prop(&apos;age&apos;));</span><br><span class="line">var people = [</span><br><span class="line">	&#123;name: &apos;fan&apos;, age: 11&#125;,</span><br><span class="line">	&#123;name: &apos;yu&apos;, age: 8&#125;,</span><br><span class="line">	&#123;name: &apos;zhen&apos;, age: 9&#125;</span><br><span class="line">];</span><br><span class="line">var descend1 = R.sort(byAge)(people);</span><br><span class="line">// console.log(descend1); // [ &#123;name: &apos;fan&apos;, age: 11&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;, &#123;name: &apos;yu&apos;, age: 8&#125;];</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h4><h5 id="6-1-数组的特性判断（contains、all、any、none）"><a href="#6-1-数组的特性判断（contains、all、any、none）" class="headerlink" title="6.1 数组的特性判断（contains、all、any、none）"></a>6.1 数组的特性判断（contains、all、any、none）</h5><pre><code>contains：如果包含某个成员，返回true。        
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var contains1 = R.contains(3)([1,2]);</span><br><span class="line">// console.log(contains1); // false</span><br></pre></td></tr></table></figure>

contains：如果包含某个成员，返回true。        
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var contains1 = R.contains(3)([1,2]);</span><br><span class="line">var contains2 = R.contains(&#123;name: &apos;fan&apos;&#125;)([&#123;name: &apos;fan&apos;&#125;,2]);</span><br><span class="line">// console.log(contains1); // false</span><br><span class="line">// console.log(contains2); // true</span><br></pre></td></tr></table></figure>

all：所有成员都满足指定函数时，返回true，否则返回false        
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var equals3 = R.equals(3);</span><br><span class="line">var all1 = R.all(equals3)([3, 3]);</span><br><span class="line">// console.log(all1); // true</span><br></pre></td></tr></table></figure>

any：只要有一个成员满足条件，就返回true。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var lessThan0 = R.flip(R.lt)(0);</span><br><span class="line">var lessThan2 = R.flip(R.lt)(2);</span><br><span class="line">var any1 = R.any(lessThan0)([1, 2]);</span><br><span class="line">// console.log(any1); // false</span><br><span class="line">var any2 = R.any(lessThan2)([1, 2]);</span><br><span class="line">// console.log(any2); // true</span><br></pre></td></tr></table></figure>

none：没有成员满足条件时，返回true。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isEven = n =&gt; n % 2 === 0;</span><br><span class="line">var none1 = R.none(isEven)([1, 3, 5, 7, 9, 11]) // true</span><br><span class="line">var none2 = R.none(isEven)([1, 3, 5, 7, 8, 11]) // false</span><br><span class="line">console.log(none2); // true</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="6-2-数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）"><a href="#6-2-数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）" class="headerlink" title="6.2 数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）"></a>6.2 数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）</h5><pre><code>head：返回数组的第一个成员。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var head1 = R.head([1, 2, 3]);</span><br><span class="line">// console.log(head1); // 1</span><br></pre></td></tr></table></figure>

last：返回数组的最后一个成员。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var last1 = R.last(&apos;fan&apos;);</span><br><span class="line">console.log(last1); // n</span><br></pre></td></tr></table></figure>

tail：返回第一个成员以外的所有成员组成的新数组。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tail1 = R.tail([1, 2, 3]);</span><br><span class="line">// console.log(tail1);  // [2, 3]</span><br></pre></td></tr></table></figure>

init：返回最后一个成员以外的所有成员组成的新数组。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var init1 = R.init([1, 2, 3]);</span><br><span class="line">// console.log(init1);  // [1, 2]</span><br></pre></td></tr></table></figure>

nth：取出指定位置的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list = [1, 2, 3, 4];</span><br><span class="line">var nth1 = R.nth(0)(list);</span><br><span class="line">// console.log(nth1); // 1</span><br></pre></td></tr></table></figure>

take：取出前 n 个成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var take1 = R.take(3)([1, 2, 3, 4]);</span><br><span class="line">// console.log(take1); // [1, 2, 3]</span><br></pre></td></tr></table></figure>

takeLast：取出后 n 个成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var takeLast1 = R.takeLast(3)([1, 2, 3, 4]);</span><br><span class="line">// console.log(takeLast1); // [2, 3, 4]</span><br></pre></td></tr></table></figure>

slice：从起始位置（包括）开始，到结束位置（不包括）为止，从原数组截取出一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var slice1 = R.slice(1, 3)([1, 2, 3, 4]);</span><br><span class="line">// console.log(slice1); // [2, 3]</span><br></pre></td></tr></table></figure>

remove：移除开始位置后的n个成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var remove1 = R.remove(2, 3)([1, 2, 3, 4, 5, 6, 7, 8]);</span><br><span class="line">// console.log(remove1); // [1, 2, 6, 7, 8]</span><br></pre></td></tr></table></figure>

insert：在指定位置插入给定值。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var insert1 = R.insert(2, &apos;x&apos;)([1, 2, 3]);</span><br><span class="line">// console.log(insert1); // [1, 2, &quot;x&quot;, 3]</span><br></pre></td></tr></table></figure>

insertAll：在指定位置，插入另一个数组的所有成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var insertAll1 = R.insertAll(2, [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])([1, 2, 3, 4]);</span><br><span class="line">// console.log(insertAll1); // [1, 2, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, 3, 4]</span><br></pre></td></tr></table></figure>

prepend：在数组头部插入一个成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var prepend1 = R.prepend(&apos;fee&apos;)([&apos;ss&apos;, &apos;ee&apos;]);</span><br><span class="line">// console.log(prepend1); // [&quot;fee&quot;, &quot;ss&quot;, &quot;ee&quot;]</span><br></pre></td></tr></table></figure>

append：在数组尾部追加新的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var append1 = R.append(&apos;test&apos;)([&apos;ss&apos;]);</span><br><span class="line">// console.log(append1); // [&quot;ss&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure>

intersperse：在数组成员之间插入表示分隔的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var intersperse1 = R.intersperse(&apos;/&apos;)([&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;]);</span><br><span class="line">// console.log(intersperse1); // [&quot;aa&quot;, &quot;/&quot;, &quot;bb&quot;, &quot;/&quot;, &quot;cc&quot;]</span><br></pre></td></tr></table></figure>

join：将数组合并成一个字符串，并在成员之间插入分隔符。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var join1 = R.join(&apos;|&apos;)([1, 2, 3]);</span><br><span class="line">// console.log(join1); // 1|2|3</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="6-3-数组的过滤（filter、reject、takeWhile、dropWhile、without）"><a href="#6-3-数组的过滤（filter、reject、takeWhile、dropWhile、without）" class="headerlink" title="6.3 数组的过滤（filter、reject、takeWhile、dropWhile、without）"></a>6.3 数组的过滤（filter、reject、takeWhile、dropWhile、without）</h5><pre><code>filter：过滤出符合条件的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isEven = n =&gt; n % 2 === 0;</span><br><span class="line">var filter1 = R.filter(isEven)([1, 2, 3]);</span><br><span class="line">// console.log(filter1); // [2]</span><br></pre></td></tr></table></figure>

reject：过滤出所有不满足条件的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isEven = n =&gt; n % 2 === 0;</span><br><span class="line">var reject1 = R.reject(isEven)([1, 2, 3]);</span><br><span class="line">// console.log(reject1); // [1, 3]</span><br></pre></td></tr></table></figure>

takeWhile：一旦满足条件，取出前面的所有成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isNotFour = x =&gt; x !== 4;</span><br><span class="line">var takeWhile1 = R.takeWhile(isNotFour)([1, 2, 3, 4, 3])</span><br><span class="line">// console.log(takeWhile1); // [1, 2, 3]</span><br></pre></td></tr></table></figure>

dropWhile：一旦满足条件，取出剩余的所有成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var lteTwo = x =&gt; x &lt;= 2;</span><br><span class="line">var dropWhile1 = R.dropWhile(lteTwo)([1, 2, 3, 4, 3, 2, 1]);</span><br><span class="line">// console.log(dropWhile1); // [3, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

without：返回指定值以外的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var without1 = R.without([1, 2])([1, 2, 1, 3, 4]);</span><br><span class="line">// console.log(without1); // [3, 4]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="6-4-单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）"><a href="#6-4-单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）" class="headerlink" title="6.4 单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）"></a>6.4 单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）</h5><pre><code>countBy：对每个成员执行指定函数以后，返回一个对象，表示各种执行结果分别包含多少成员。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];</span><br><span class="line">var countBy1 = R.countBy(Math.floor)(numbers);</span><br><span class="line">// console.log(countBy1); // &#123;1: 3, 2: 2, 3: 1&#125;</span><br></pre></td></tr></table></figure>

splitAt：在给定位置，将原数组分成两个部分。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var splitAt1 = R.splitAt(1)([1, 2, 3]);</span><br><span class="line">// console.log(splitAt1); // [[1],[2, 3]]</span><br></pre></td></tr></table></figure>

splitEvery：按照指定的个数，将原数组分成多个部分。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var splitEvery1 = R.splitEvery(3)([1, 2, 3, 4, 5, 6, 7]);</span><br><span class="line">// console.log(splitEvery1); // [[1, 2, 3], [4, 5, 6], [7]]</span><br></pre></td></tr></table></figure>

splitWhen：以第一个满足指定函数的成员为界，将数组分成两个部分。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var splitEvery1 = R.splitEvery(3)([1, 2, 3, 4, 5, 6, 7]);</span><br><span class="line">// console.log(splitEvery1); // [[1, 2, 3], [4, 5, 6], [7]]</span><br></pre></td></tr></table></figure>

aperture：每个成员与其后给定数量的成员分成一组，这些组构成一个新的数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aperture1 = R.aperture(3)([1, 2, 3, 4, 5, 6, 7]);</span><br><span class="line">// console.log(aperture1); // [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]</span><br></pre></td></tr></table></figure>

partition：根据是否满足指定函数，将成员分区。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var partition1 = R.partition(R.contains(&apos;s&apos;))([&apos;aaa&apos;, &apos;bbb&apos;, &apos;sss&apos;]);</span><br><span class="line">// console.log(partition1); // [[&apos;sss&apos;], [&quot;aaa&quot;, &quot;bbb&quot;]]</span><br></pre></td></tr></table></figure>

indexOf：某个值在数组中第一次出现的位置。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var indexOf1 = R.indexOf(3)([1, 2, 3, 4]);</span><br><span class="line">// console.log(indexOf1); // 2</span><br></pre></td></tr></table></figure>

lastIndexOf：某个值在数组中最后一次出现的位置。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var lastIndexOf1 = R.lastIndexOf(3)([-1, 3, 3, 0, 1, 2, 3, 4]);</span><br><span class="line">// console.log(lastIndexOf1); // 6</span><br></pre></td></tr></table></figure>

map：数组的每个成员依次执行某个函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var double = x =&gt; x * 2;</span><br><span class="line">var map1 = R.map(double)([1, 2, 3]);</span><br><span class="line">// console.log(map1); // [2, 4, 6]</span><br></pre></td></tr></table></figure>

mapIndexed：与map类似，区别是遍历函数可以额外获得两个参数：索引位置和原数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mapIndexed = R.addIndex(R.map);</span><br><span class="line">var mapIndex1 = mapIndexed((val, idx) =&gt; idx + &apos;-&apos; + val, [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;, &apos;b&apos;, &apos;a&apos;, &apos;r&apos;]);</span><br><span class="line">// console.log(mapIndex1); // [&quot;0-f&quot;, &quot;1-o&quot;, &quot;2-o&quot;, &quot;3-b&quot;, &quot;4-a&quot;, &quot;5-r&quot;]</span><br></pre></td></tr></table></figure>

forEach：数组的每个成员依次执行某个函数，总是返回原数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var printXPlusFive = x =&gt; console.log(x + 5);</span><br><span class="line">var forEach1 = R.forEach(printXPlusFive, [1, 2, 3]); </span><br><span class="line">// console.log(forEach1); // [1, 2, 3]</span><br></pre></td></tr></table></figure>

reduce：数组成员依次执行指定函数，每一次的运算结果都会进入一个累积变量。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mySubtract = function (a, b) &#123;</span><br><span class="line">	return a - b;</span><br><span class="line">&#125;;</span><br><span class="line">var reduce1 = R.reduce(mySubtract, 0)([1, 2, 3, 4]);</span><br><span class="line">// console.log(reduce1); // -10</span><br></pre></td></tr></table></figure>

reduceRight：与reduce类似，区别是数组成员从左到右执行。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reduceRight1 = R.reduceRight(R.subtract, 0)([1, 2, 3, 4]);</span><br><span class="line">// console.log(reduceRight1); // -2</span><br></pre></td></tr></table></figure>

reduceWhile：与reduce类似，区别是有一个判断函数，一旦数组成员不符合条件，就停止累积。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isOdd = (acc, x) =&gt; x % 2 === 1;</span><br><span class="line">var ys = [2, 4, 6];</span><br><span class="line">var reduceWhile1 = R.reduceWhile(isOdd, R.add, 111)(ys);</span><br><span class="line">// console.log(reduceWhile1); // 111</span><br></pre></td></tr></table></figure>

sort：按照给定函数，对数组进行排序。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var diff = function (a, b) &#123; return a -b; &#125;;</span><br><span class="line">var sort1 = R.sort(diff)([4, 2, 7, 5]);</span><br><span class="line">// console.log(sort1); // [2, 4, 5, 7]</span><br></pre></td></tr></table></figure>

sortWith：按照给定的一组函数，进行多重排序。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var alice = &#123;</span><br><span class="line">	name: &apos;alice&apos;,</span><br><span class="line">	age: 40</span><br><span class="line">&#125;;</span><br><span class="line">var bob = &#123;</span><br><span class="line">	name: &apos;bob&apos;,</span><br><span class="line">	age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var clara = &#123;</span><br><span class="line">	name: &apos;clara&apos;,</span><br><span class="line">	age: 40</span><br><span class="line">&#125;;</span><br><span class="line">var people = [clara, bob, alice];</span><br><span class="line">var ageNameSort = R.sortWith([</span><br><span class="line">		// R.descend(R.prop(&apos;age&apos;)),</span><br><span class="line">		R.ascend(R.prop(&apos;name&apos;))</span><br><span class="line">	]);</span><br><span class="line">var sortWith1 = ageNameSort(people);</span><br><span class="line">console.log(sortWith1); // [&#123;name: &quot;alice&quot;, age: 40&#125;, &#123;name: &quot;bob&quot;, age: 30&#125;, &#123;name: &quot;clara&quot;, age: 40&#125;]</span><br></pre></td></tr></table></figure>

adjust：对指定位置的成员执行给定的函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var adjust1 = R.adjust(R.add(10) ,1)([1, 2, 3]);</span><br><span class="line">// console.log(adjust1); // [1, 12, 3]</span><br></pre></td></tr></table></figure>

ap：数组成员分别执行一组函数，将结果合成为一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ap1 = R.ap([R.multiply(2), R.add(3)])([1, 2, 3]);</span><br><span class="line">// console.log(ap1); // [2, 4, 6, 4, 5, 6]</span><br></pre></td></tr></table></figure>

flatten：将嵌套数组铺平。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var flatten1 = R.flatten([1, 2, [ 3, 4, 5, [6]]]);</span><br><span class="line">// console.log(flatten1); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

groupWith：将数组成员依次按照指定条件两两比较，并按照结果将所有成员放入子数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var groupWith1 = R.groupWith(R.equals)([0, 1, 1, 2, 3, 5, 8, 13, 21]);</span><br><span class="line">// console.log(groupWith1); // [[0], [1, 1], [2], [3], [5], [8], [13], [21]]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="6-5-双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）"><a href="#6-5-双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）" class="headerlink" title="6.5 双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）"></a>6.5 双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）</h5><pre><code>concat：将两个数组合并成一个数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var concat1 = R.concat([1, 2])([&apos;a&apos;, &apos;b&apos;]);</span><br><span class="line">console.log(concat1); // [1, 2, &quot;a&quot;, &quot;b&quot;]</span><br></pre></td></tr></table></figure>

zip：将两个数组指定位置的成员放在一起，生成一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var zip1 = R.zip([1, 2, 3])([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</span><br><span class="line">// console.log(zip1); // [[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]]</span><br></pre></td></tr></table></figure>

zipObj：将两个数组指定位置的成员分别作为键名和键值，生成一个新对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var zip1 = R.zip([1, 2, 3])([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</span><br><span class="line">// console.log(zip1); // [[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]]</span><br></pre></td></tr></table></figure>

xprod：将两个数组的成员两两混合，生成一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xprod1 = R.xprod([1, 2])([&apos;a&apos;, &apos;b&apos;]);</span><br><span class="line">// console.log(xprod1); // [[1, &quot;a&quot;], [1, &quot;b&quot;], [2, &quot;a&quot;], [2, &quot;b&quot;]]</span><br></pre></td></tr></table></figure>

intersection：返回两个数组相同的成员组成的新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var intersection1 = R.intersection([1, 2, 3, 4])([4, 3, 8]);</span><br><span class="line">// console.log(intersection1); // [4, 3]</span><br></pre></td></tr></table></figure>

intersectionWith：返回经过某种运算，有相同结果的两个成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var buffaloSpringfield = [</span><br><span class="line">  &#123;id: 824, name: &apos;Richie Furay&apos;&#125;,</span><br><span class="line">  &#123;id: 177, name: &apos;Neil Young&apos;&#125;</span><br><span class="line">];</span><br><span class="line">var csny = [</span><br><span class="line">  &#123;id: 204, name: &apos;David Crosby&apos;&#125;,</span><br><span class="line">  &#123;id: 177, name: &apos;Neil Young&apos;&#125;</span><br><span class="line">];</span><br><span class="line">var intersectionWith1 = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield)(csny);</span><br><span class="line">// console.log(intersectionWith1); // [&#123;id: 177, name: &quot;Neil Young&quot;&#125;]</span><br></pre></td></tr></table></figure>

difference：返回第一个数组不包含在第二个数组里面的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var difference1 = R.difference([1, 2, 3, 4])([7, 6, 5, 4, 3]);</span><br><span class="line">// console.log(difference1); // [1, 2]</span><br></pre></td></tr></table></figure>

differenceWith：返回执行指定函数后，第一个数组里面不符合条件的所有成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cmp = (x, y) =&gt; x.a === y.a;</span><br><span class="line">var l1 = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];</span><br><span class="line">var l2 = [&#123;a: 3&#125;, &#123;a: 4&#125;];</span><br><span class="line">var differenceWith1 = R.differenceWith(cmp, l1)(l2);</span><br><span class="line">console.log(differenceWith1); // [&#123;a: 1&#125;, &#123;a: 2&#125;]</span><br></pre></td></tr></table></figure>

symmetricDifference：返回两个数组的非共有成员所组成的一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var symmetricDifference1 = R.symmetricDifference([1, 2, 3, 4])([7, 6, 5, 4, 3]);</span><br><span class="line">// console.log(symmetricDifference1); // [1, 2, 7, 6, 5]</span><br></pre></td></tr></table></figure>

symmetricDifferenceWith：根据指定条件，返回两个数组所有运算结果不相等的成员所组成的新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var eqA = R.eqBy(R.prop(&apos;a&apos;));</span><br><span class="line">var l1 = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;, &#123;a: 4&#125;];</span><br><span class="line">var l2 = [&#123;a: 3&#125;, &#123;a: 4&#125;, &#123;a: 5&#125;, &#123;a: 6&#125;];</span><br><span class="line">var symmetricDifferenceWith1 = R.symmetricDifferenceWith(eqA, l1, l2);</span><br><span class="line">// console.log(symmetricDifferenceWith1); // [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 5&#125;, &#123;a: 6&#125;]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="6-6-复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）"><a href="#6-6-复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）" class="headerlink" title="6.6 复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）"></a>6.6 复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）</h5><pre><code>find：返回符合指定条件的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xs = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];</span><br><span class="line">var find1 = R.find(R.propEq(&apos;a&apos;, 2))(xs);</span><br><span class="line">// console.log(find1); // [&#123;a: 2&#125;]</span><br></pre></td></tr></table></figure>

findIndex：返回符合指定条件的成员的位置。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xs = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];</span><br><span class="line">var findIndex1 = R.findIndex(R.propEq(&apos;a&apos;, 2))(xs);</span><br><span class="line">// console.log(findIndex1); // 1</span><br></pre></td></tr></table></figure>

findLast：返回最后一个符合指定条件的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xs = [&#123;a: 1, b: 0&#125;, &#123;a:1, b: 1&#125;];</span><br><span class="line">var findLast1 = R.findLast(R.propEq(&apos;a&apos;, 1))(xs);</span><br><span class="line">// console.log(findLast1); // &#123;a: 1, b: 1&#125;</span><br></pre></td></tr></table></figure>

findLastIndex：返回最后一个符合指定条件的成员的位置。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xs = [&#123;a: 1, b: 0&#125;, &#123;a:1, b: 1&#125;];</span><br><span class="line">var findLastIndex1 = R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs);</span><br><span class="line">// console.log(findLastIndex1); // 1</span><br></pre></td></tr></table></figure>

pluck：取出数组成员的某个属性，组成一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pluck1 = R.pluck(&apos;a&apos;)([&#123;a: 1&#125;, &#123;a: 2&#125;]);</span><br><span class="line">// console.log(pluck1); // [1, 2]</span><br></pre></td></tr></table></figure>

project：取出数组成员的多个属性，组成一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var abby = &#123;name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2&#125;;</span><br><span class="line">var fred = &#123;name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7&#125;;</span><br><span class="line">var kids = [abby, fred];</span><br><span class="line">var project1 = R.project([&apos;name&apos;, &apos;grade&apos;])(kids);</span><br><span class="line">// console.log(project1); // [&#123;name: &apos;Abby&apos;, grade: 2&#125;, &#123;name: &apos;Fred&apos;, grade: 7&#125;]</span><br></pre></td></tr></table></figure>

transpose：将每个成员相同位置的值，组成一个新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var transpose1 = R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]);</span><br><span class="line">// console.log(transpose1); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br></pre></td></tr></table></figure>

mergeAll：将数组的成员合并成一个对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mergeAll1 = R.mergeAll([&#123;foo: 1&#125;, &#123;bar: 2&#125;, &#123;baz: 3&#125;]);</span><br><span class="line">// console.log(mergeAll1); // &#123;foo:1,bar:2,baz:3&#125;</span><br></pre></td></tr></table></figure>

fromPairs：将嵌套数组转为一个对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fromPairs1 = R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]])</span><br><span class="line">// console.log(fromPairs1); // &#123;a: 1, b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>

groupBy：将数组成员按照指定条件分组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var byGrade = R.groupBy(function (student) &#123;</span><br><span class="line">	let score = student.score;</span><br><span class="line">	return score &lt; 60 ? &apos;F&apos; :</span><br><span class="line">			score &lt; 70 ? &apos;D&apos; :</span><br><span class="line">			score &lt; 80 ? &apos;C&apos; :</span><br><span class="line">			score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">var students = [&#123;name: &apos;Abby&apos;, score: 84&#125;,</span><br><span class="line">				&#123;name: &apos;Eddy&apos;, score: 58&#125;,</span><br><span class="line">				&#123;name: &apos;Jack&apos;, score: 90&#125;];</span><br><span class="line">var groupBy1 = byGrade(students);</span><br><span class="line">// console.log(groupBy1); </span><br><span class="line">// &#123;</span><br><span class="line">//   &apos;A&apos;: [&#123;name: &apos;Jack&apos;, score: 90&#125;],</span><br><span class="line">//   &apos;B&apos;: [&#123;name: &apos;Abby&apos;, score: 84&#125;]</span><br><span class="line">//   &apos;F&apos;: [&#123;name: &apos;Eddy&apos;, score: 58&#125;]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

sortBy：根据成员的某个属性排序。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sortByFirstItem = R.sortBy(R.prop(0));</span><br><span class="line">var sortBy1 = sortByFirstItem([[-1, 1], [-2, 2], [-3, 3]])</span><br><span class="line">// console.log(sortBy1); // // [[-3, 3], [-2, 2], [-1, 1]]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="七、对象"><a href="#七、对象" class="headerlink" title="七、对象"></a>七、对象</h4><h5 id="7-1-对象的特征判断（has、hasIn、propEq、whereEq、where）"><a href="#7-1-对象的特征判断（has、hasIn、propEq、whereEq、where）" class="headerlink" title="7.1 对象的特征判断（has、hasIn、propEq、whereEq、where）"></a>7.1 对象的特征判断（has、hasIn、propEq、whereEq、where）</h5><pre><code>has: 返回一个布尔值，表示对象自身是否具有该属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hasName = R.has(&apos;name&apos;);</span><br><span class="line">var has1 = hasName(&#123;name: &apos;fan&apos;&#125;);</span><br><span class="line">// console.log(has1); // true</span><br></pre></td></tr></table></figure>

hasIn：返回一个布尔值，表示对象自身或原型链上是否具有某个属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Rectangle (width, height) &#123;</span><br><span class="line">	this.width = width;</span><br><span class="line">	this.height = height;</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.area = function () &#123;</span><br><span class="line">	return this.width * this.height;</span><br><span class="line">&#125;;</span><br><span class="line">var square = new Rectangle(2, 2);</span><br><span class="line">var hasIn1 = R.hasIn(&apos;width&apos;)(square); // 自身的</span><br><span class="line">var hasIn2 = R.hasIn(&apos;area&apos;)(square); // 原型的</span><br><span class="line">// console.log(hasIn1, hasIn2); // true true</span><br></pre></td></tr></table></figure>

propEq：如果单个属性等于给定值，返回true。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var abby = &#123;name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;&#125;;</span><br><span class="line">var fred = &#123;name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;&#125;;</span><br><span class="line">var rusty = &#123;name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;&#125;;</span><br><span class="line">var alois = &#123;name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;&#125;;</span><br><span class="line">var kids = [abby, fred, rusty, alois];</span><br><span class="line">var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;);</span><br><span class="line">var propEq1 = R.filter(hasBrownHair)(kids) // [fred, rusty]</span><br><span class="line">// console.log(propEq1); // // [fred, rusty]</span><br></pre></td></tr></table></figure>

whereEq：如果多个属性等于给定值，返回true。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pred = R.whereEq(&#123;a: 1, b: 2&#125;);</span><br><span class="line">var whereEq1 = pred(&#123;a: 1, b: 2&#125;);</span><br><span class="line">// console.log(whereEq1); // true</span><br></pre></td></tr></table></figure>

where：如果各个属性都符合指定条件，返回true。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pred = R.where(&#123;</span><br><span class="line">	a: R.equals(&apos;foo&apos;),</span><br><span class="line">	b: R.equals(&apos;bzr&apos;),</span><br><span class="line">	x: R.gt(10),</span><br><span class="line">	y: R.lt(20)</span><br><span class="line">&#125;);</span><br><span class="line">var where1 = pred(&#123;a: &apos;foo&apos;, b: &apos;bzr&apos;, x: 12, y: 15&#125;);</span><br><span class="line">console.log(where1); // true</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="7-2-对象的过滤（omit、filter、reject）"><a href="#7-2-对象的过滤（omit、filter、reject）" class="headerlink" title="7.2 对象的过滤（omit、filter、reject）"></a>7.2 对象的过滤（omit、filter、reject）</h5><pre><code>omit：过滤指定属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var omit1 = R.omit([&apos;a&apos;, &apos;b&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</span><br><span class="line">// console.log(omit1); // &#123;b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>

filter：返回所有满足条件的属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isEven = n =&gt; n % 2 === 0;</span><br><span class="line">var filter1 = R.filter(isEven)(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</span><br><span class="line">// console.log(filter1); // &#123;b: 2, d: 4&#125;</span><br></pre></td></tr></table></figure>

reject：返回所有不满足条件的属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isOdd = n =&gt; n % 2 === 1;</span><br><span class="line">var reject1 = R.reject(isOdd)(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</span><br><span class="line">// console.log(reject1); // &#123;b: 2, d: 4&#125;</span><br></pre></td></tr></table></figure>

reject：返回所有不满足条件的属性。
</code></pre><h5 id="7-3-对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）"><a href="#7-3-对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）" class="headerlink" title="7.3 对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）"></a>7.3 对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）</h5><pre><code>dissoc：过滤指定属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dissoc1 = R.dissoc(&apos;b&apos;)(&#123;a: 1, b: 2, c: 3&#125;);</span><br><span class="line">// console.log(dissoc1); // &#123;a: 1, c: 3&#125;</span><br></pre></td></tr></table></figure>

assoc：添加或改写某个属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var assoc1 = R.assoc(&apos;c&apos;, 3)(&#123;a: 1, b: 2&#125;);</span><br><span class="line">// console.log(assoc1); // &#123;a: 1, b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>

partition：根据属性值是否满足给定条件，将属性分区。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var partition1 = R.partition(R.contains(&apos;s&apos;))(&#123;a: &apos;ssss&apos;, b: &apos;ttt&apos;, foo: &apos;bars&apos;&#125;);</span><br><span class="line">// console.log(partition1); // [ &#123; a: &apos;sss&apos;, foo: &apos;bars&apos; &#125;, &#123; b: &apos;ttt&apos; &#125;  ]</span><br></pre></td></tr></table></figure>

pick：返回指定属性组成的新对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pick1 = R.pick([&apos;a&apos;, &apos;d&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</span><br><span class="line">// console.log(pick1); // &#123;a: 1, d: 4&#125;</span><br></pre></td></tr></table></figure>

pickAll：与pick类似，但会包括不存在的属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pickAll1 = R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;f&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);</span><br><span class="line">// console.log(pickAll1); // &#123;a: 1, d: 4, f: undefined&#125;</span><br></pre></td></tr></table></figure>

pickBy：返回符合条件的属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isUpperCase = (val, key) =&gt; key.toUpperCase() === key;</span><br><span class="line">var pickBy1 = R.pickBy(isUpperCase)(&#123;a: 1, b: 2, A: 3, B: 4&#125;);</span><br><span class="line">// console.log(pickBy1); // &#123;A: 3, B: 4&#125;</span><br></pre></td></tr></table></figure>

keys：返回对象自身属性的属性名组成的新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var keys1 = R.keys(&#123;a: 1, b: 2&#125;);</span><br><span class="line">// console.log(keys1); // [&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure>

keysIn：返回对象自身的和继承的属性的属性名组成的新数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var F = function () &#123;this.x = &apos;X&apos;&#125;;</span><br><span class="line">F.prototype.y = &apos;Y&apos;;</span><br><span class="line">var f = new F();</span><br><span class="line">var keysIn1 = R.keysIn(f);</span><br><span class="line">// console.log(keysIn1); // [&apos;x&apos;, &apos;y&apos;]</span><br></pre></td></tr></table></figure>

values：返回对象自身的属性的属性值组成的数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var values1 = R.values(&#123;a: 1, b: 2, c: 3&#125;);</span><br><span class="line">// console.log(values1); // [1, 2, 3]</span><br></pre></td></tr></table></figure>

valuesIn：返回对象自身的和继承的属性的属性值组成的数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var F = function() &#123; this.x = &apos;X&apos;; &#125;;</span><br><span class="line">F.prototype.y = &apos;Y&apos;;</span><br><span class="line">var f = new F();</span><br><span class="line">var valuesIn1 = R.valuesIn(f);</span><br><span class="line">// console.log(valuesIn1); // [&quot;X&quot;, &quot;Y&quot;]</span><br></pre></td></tr></table></figure>

invertObj：将属性值和属性名互换。如果多个属性的属性值相同，只返回最后一个属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var raceResultsByFirstName = &#123;</span><br><span class="line">  first: &apos;alice&apos;,</span><br><span class="line">  second: &apos;jake&apos;,</span><br><span class="line">  third: &apos;alice&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var invertObj1 = R.invertObj(raceResultsByFirstName);</span><br><span class="line">// console.log(invertObj1); // &#123;alice: &quot;third&quot;, jake: &quot;second&quot;&#125;</span><br></pre></td></tr></table></figure>

invert：将属性值和属性名互换，每个属性值对应一个数组。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var raceResultsByFirstName = &#123;</span><br><span class="line">  first: &apos;alice&apos;,</span><br><span class="line">  second: &apos;jake&apos;,</span><br><span class="line">  third: &apos;alice&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var invert1 = R.invert(raceResultsByFirstName);</span><br><span class="line">console.log(invert1); // // &#123; &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="7-4-对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）"><a href="#7-4-对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）" class="headerlink" title="7.4 对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）"></a>7.4 对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）</h5><pre><code>prop：返回对象的指定属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var prop1 = R.prop(&apos;x&apos;)(&#123;x: 100&#125;);</span><br><span class="line">// console.log(prop1); // 100</span><br></pre></td></tr></table></figure>

map：对象的所有属性依次执行某个函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var double = x =&gt; x * 2;</span><br><span class="line">var map1 = R.map(double)(&#123;x: 1, y: 2, z: 3&#125;);</span><br><span class="line">// console.log(map1); // &#123;x: 2, y: 4, z: 6&#125;</span><br></pre></td></tr></table></figure>

mapObjIndexed：与map类似，但是会额外传入属性名和整个对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var values = &#123;x: 1, y: 2, z: 3&#125;;</span><br><span class="line">var prependkeyAndDouble = (num, key, obj) =&gt; key + (num * 2);</span><br><span class="line">var mapObjIndexed1 = R.mapObjIndexed(prependkeyAndDouble)(values);</span><br><span class="line">// console.log(mapObjIndexed1); // &#123;x: &quot;x2&quot;, y: &quot;y4&quot;, z: &quot;z6&quot;&#125;</span><br></pre></td></tr></table></figure>

forEachObjIndexed：每个属性依次执行给定函数，给定函数的参数分别是属性值和属性名，返回原对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var printkeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value);</span><br><span class="line">var forEachObjIndexed1 = R.forEachObjIndexed(printkeyConcatValue)(&#123;x: 1,y: 2&#125;);</span><br><span class="line">// console.log(forEachObjIndexed1); // &#123;x: 1,y: 2&#125;</span><br></pre></td></tr></table></figure>

merge：合并两个对象，如果有同名属性，后面的值会覆盖掉前面的值。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var merge1 = R.merge(&#123;&apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10&#125;)(&#123;&apos;age&apos;: 40&#125;);</span><br><span class="line">// console.log(merge1); // &#123;name: &quot;fred&quot;, age: 40&#125;</span><br></pre></td></tr></table></figure>

mergeWith：合并两个对象，如果有同名属性，会使用指定的函数处理。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mergeWith1 = R.mergeWith(</span><br><span class="line">		R.concat,</span><br><span class="line">		&#123;a: true, values: [10, 20]&#125;,</span><br><span class="line">		&#123;b: true, values: [15, 35]&#125;</span><br><span class="line">	);</span><br><span class="line">// console.log(mergeWith1); // &#123; a: true, b: true, values: [10, 20, 15, 35] &#125;</span><br></pre></td></tr></table></figure>

eqProps：比较两个对象的指定属性是否相等。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o1 = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">var o2 = &#123;a: 10, b: 20, c: 3, d: 40&#125;;</span><br><span class="line">var eqProps1 = R.eqProps(&apos;c&apos;, o1)(o2);</span><br><span class="line">// console.log(eqProps1); //true</span><br></pre></td></tr></table></figure>

evolve：对象的属性分别经过一组函数的处理，返回一个新对象。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tomato = &#123;</span><br><span class="line">	firstName: &apos;Tomato&apos;,</span><br><span class="line">	data: &#123;elapsed: 100, remaining: 1400&#125;,</span><br><span class="line">	id: 123</span><br><span class="line">&#125;;</span><br><span class="line">var transformations = &#123;</span><br><span class="line">	firstName: R.trim,</span><br><span class="line">	lastName: R.trim,</span><br><span class="line">	data: &#123;elapsed: R.add(1), remaining: R.add(-1)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var evolve1 = R.evolve(transformations)(tomato);</span><br><span class="line">// console.log(evolve1);</span><br><span class="line">// &#123;</span><br><span class="line">//   firstName: &apos;Tomato&apos;,</span><br><span class="line">//   data: &#123;elapsed: 101, remaining: 1399&#125;,</span><br><span class="line">//   id: 123</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="7-5-复合对象（path、pathEq、assocPath）"><a href="#7-5-复合对象（path、pathEq、assocPath）" class="headerlink" title="7.5 复合对象（path、pathEq、assocPath）"></a>7.5 复合对象（path、pathEq、assocPath）</h5><pre><code>path：取出数组中指定路径的值。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path1 = R.path([&apos;a&apos;, &apos;b&apos;], &#123;a: &#123;b: 2&#125;&#125;);</span><br><span class="line">// console.log(path1); // 2</span><br></pre></td></tr></table></figure>

pathEq：返回指定路径的值符合条件的成员。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user1 = &#123;address: &#123;zipCode: 11111&#125;&#125;;</span><br><span class="line">var user2 = &#123;address: &#123;zipCode: 22222&#125;&#125;;</span><br><span class="line">var user3 = &#123;address: &#123;zipCode: 33333&#125;&#125;;</span><br><span class="line">var users = [user1, user2, user3];</span><br><span class="line">var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 11111);</span><br><span class="line">var pathEq1 = R.filter(isFamous)(users);</span><br><span class="line">// console.log(pathEq1); // [user1]</span><br></pre></td></tr></table></figure>

assocPath：添加或改写指定路径的属性的值。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var assocPath1 = R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42)(&#123;a: &#123;b: &#123;c: 0&#125;&#125;&#125;);</span><br><span class="line">// console.log(assocPath1); // &#123;a: &#123;b: &#123;c: 42&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br><a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="noopener">阮老师–Ramda 函数库参考教程</a><br><a href="http://ramda.cn/" target="_blank" rel="noopener">Ramda 中文</a>        </p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA-1</title>
    <url>/2017/PWA-1.html</url>
    <content><![CDATA[<h2 id="Lavas-–-基于-Vue-的-PWA-解决方案，帮助开发者快速搭建-PWA-应用，解决接入-PWA-的各种问题"><a href="#Lavas-–-基于-Vue-的-PWA-解决方案，帮助开发者快速搭建-PWA-应用，解决接入-PWA-的各种问题" class="headerlink" title="Lavas – 基于 Vue 的 PWA 解决方案，帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题"></a>Lavas – 基于 Vue 的 PWA 解决方案，帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><ol>
<li>Lavas 介绍<br>Lavas 是什么？<pre><code>Lavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。
</code></pre>Lavas 做什么？<pre><code>站点 PWA 化需要做什么，Lavas 就做什么。
PWA (Progressive Web Apps) 是一种 Web App 新模型：
1.站点可添加至主屏幕
2.全屏方式运行
3.支持离线缓存
4.消息推送 ...
</code></pre></li>
<li>探索PWA<br>什么是PWA？<br>  PWA 工程的解决方案中借助了 service worker 的离线存储能力，消息推送能力以及系统的添加桌面能力，从而形成一个完善的 Web App 解决方案，帮助我们在 Web 端低成本的开发和维护一个逐步类 Native App 化的 Web App。<br>什么站点适合改造成 PWA？<br>  除了对系统强依赖的 App, 以及游戏类的 App 等, 所有的 Native App 都可以改造成 PWA 应用。<br>PWA 的效果？<br>  1.https 环境部署。<br>  2.响应式设计，一次部署，可以在移动设备和 PC 设备上运行。<br>  3.在不同浏览器下可正常访问。<br>  4.浏览器离线和弱网环境可极速访问。<br>  5.可以把 App Icon 入口添加到桌面。<br>  6.点击 Icon 入口有类似 Native App 的动画效果。<br>  7.灵活的热更新。<br>离线缓存<br>  HTML5 新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">service worker API</a>，提供的离线缓存能力<br>SPA (Single Page Apps)<br>基于 Vue 架构的 PWA 工程<br>App Shell<br>  App Shell 架构是构建 PWA 工程的一种方式，这种应用能可靠且即时地加载到您的用户屏幕上，与本地应用相似。</li>
<li>快速开始 PWA 工程<br>依赖工具<br>  $ npm install -g lavas<br>初始化工程<br>  $ lavas init<br>运行<br>  cd projectName<br>  npm install<br>  npm run dev</li>
<li><p>开发一个页面（以NotFound页面为例）<br>添加路由    </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const NotFound = () =&gt; import(&apos;@/pages/NotFound.vue&apos;);</span><br><span class="line"></span><br><span class="line">routes: [</span><br><span class="line">	// 省略其他路由对象</span><br><span class="line">	&#123;</span><br><span class="line">		path: &apos;*&apos;,</span><br><span class="line">		name: &apos;notFound&apos;,</span><br><span class="line">		component: NotFound</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>页面组织结构<br>  标准.vue单文件<br>与app shell 的交互<br>  vuex<br>监听全局事件    </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import EventBus from &apos;@/event-bus&apos;;</span><br><span class="line"></span><br><span class="line">// 在 activated 钩子中注册</span><br><span class="line">EventBus.$on(`app-header:click-action`, (&#123;actionIdx&#125;) =&gt; &#123;</span><br><span class="line">	// 处理点击按钮事件</span><br><span class="line">	// ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>组件开发<br>  <a href="https://vuetifyjs.com/" target="_blank" rel="noopener">vuetify</a><br>异步请求数据<br>   <a href>axios</a></p>
</li>
<li>调试工程<br>webpack dev-server<br>chrome 调试    </li>
<li>构建部署工程<br>生产环境构建<br>部署到服务器</li>
</ol>
<h3 id="进阶教程"><a href="#进阶教程" class="headerlink" title="进阶教程"></a>进阶教程</h3><ol>
<li>维护 service-worker.js 文件<br>service-worker.js<br>  service-worker.js 文件作为缓存管理的重要文件<br>如何配置缓存内容<br>  通过 config/sw-precache.js 文件进行缓存配置，根据配置为用户缓存网站静态与动态资源，并截获用户的所有网络请求，决定是从缓存还是网络获取相应资源，限制缓存大小等。</li>
<li>Service Worker 与页面通信<br>如何使用 postMessage 方法发送信息<br>  在 sw.js 中向接管页面发信息，可以采用 client.postMessage() 方法<br>  在主页面给 Service Worker 发消息，可以采用 navigator.serviceWorker.controller.postMessage() 方法<br>如何接收 postMessage 发送的信息<br>  在 sw.js 中接收主页面发来的信息，示例代码如下，通过 event.data 来读取数据<br>  在页面中接收 sw.js 发来的信息，示例代码如下，通过 event.data 来读取数据</li>
<li>App Shell 调整及扩展<br>App Shell 模型<br>调整及扩展 App Shell<br>  状态管理<br>  与路由组件通信<br>  扩展 Shell</li>
<li>App Skeleton 介绍<br>Lavas 的 Skeleton 支持<br>默认 Skeleton</li>
<li>页面切换动画效果<br>具体实现</li>
<li>修改项目主题<br>配置文件<br>  主题相关的配置文件在 config/theme.js 中<br>  使用预定义的颜色变量<br>  使用主题变量</li>
<li>在项目中使用图标<br>字体文件<br>自定义 SVG</li>
<li>使用 Material Design UI 开发<br>muse-ui、vue-material、vuetify</li>
<li>HTTPS 环境部署</li>
<li>服务器端渲染</li>
</ol>
<p>参考：</p>
<blockquote>
<p><a href="https://lavas.baidu.com/" target="_blank" rel="noopener">lavas-百度PWA解决方案</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>有趣的</tag>
      </tags>
  </entry>
  <entry>
    <title>React-组件书写方式</title>
    <url>/2017/React-%E7%BB%84%E4%BB%B6%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="createClass"><a href="#createClass" class="headerlink" title="createClass"></a>createClass</h1><pre><code>ES5 定义组件只能使用 createClass    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const React = require(react);</span><br><span class="line">const Greeting = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">	// 属性校验 </span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		name: React.PropTypes.string </span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	// 默认属性</span><br><span class="line">	getDefaultProps: function() &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			name: &apos;fanerge&apos; </span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	// 初始化state</span><br><span class="line">	getInitialState: function() &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			count: this.props.initialCount</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;, </span><br><span class="line">	</span><br><span class="line">	// 事件函数</span><br><span class="line">	handleClick: function() &#123;  &#125;,</span><br><span class="line">	</span><br><span class="line">	render: function() &#123;</span><br><span class="line">		return &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&#123;&#123;this.props.name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = Greeting;</span><br></pre></td></tr></table></figure>

PS：使用createClass，React对属性中的所有函数都进行了this绑定，也就是如上面的hanleClick其实相当于handleClick.bind(this) 。
</code></pre><h1 id="component"><a href="#component" class="headerlink" title="component"></a>component</h1><pre><code>ES6 的类（语法糖）对原型继承机制进行了封装
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">class Greeting extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		// 设置初始值</span><br><span class="line">		this.state = &#123;count: props.initialCount&#125;;</span><br><span class="line">		// 为函数绑定 this</span><br><span class="line">		this.handleClick = this.handleClick.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 定义props方式1</span><br><span class="line">	static defaultProps = &#123;</span><br><span class="line">		name: &apos;Mary&apos; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// props验证方式1</span><br><span class="line">	static propTypes = &#123;</span><br><span class="line">		name: React.PropTypes.string</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 事件函数</span><br><span class="line">	handleClick() &#123;  &#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// props验证方式2</span><br><span class="line">Greeting.propTypes = &#123;</span><br><span class="line">	name: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义props方式2</span><br><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">	name: &apos;Mary&apos; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Greeting;</span><br></pre></td></tr></table></figure>

PS：可以看到Greeting继承自React.component,在构造函数中，通过super()来调用父类的构造函数。
</code></pre><h1 id="PureComponet"><a href="#PureComponet" class="headerlink" title="PureComponet"></a>PureComponet</h1><pre><code>作用：当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CounterButton extends React.PureComponent &#123;</span><br><span class="line">	</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state = &#123;count: 1&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return(</span><br><span class="line">			&lt;button</span><br><span class="line">				color=&#123;this.props.color&#125;</span><br><span class="line">				onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</span><br><span class="line">				Count: &#123;this.state.count&#125;</span><br><span class="line">			&lt;/button&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

PS：这种情况下，PureComponent只会对this.props.words进行一次浅比较，虽然数组里面新增了元素，
    但是this.props.words与nextProps.words指向的仍是同一个数组，因此this.props.words !== nextProps.words 
    返回的便是flase，从而导致ListOfWords组件没有重新渲染。
最简单避免上述情况的方式，就是避免使用可变对象作为props和state，取而代之的是每次返回一个全新的对象,如下通过concat来返回新的数组：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  this.setState(prevState =&gt; (&#123;</span><br><span class="line">	words: prevState.words.concat([&apos;marklar&apos;])</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

你还可以考虑使用Immutable.js来创建不可变对象，通过它来简化对象比较，提高性能。
</code></pre><h1 id="Stateless-Functional-Component"><a href="#Stateless-Functional-Component" class="headerlink" title="Stateless Functional Component"></a>Stateless Functional Component</h1><pre><code>作用：数据都是通过props传入的时候，我们便可以使用Stateless Functional Component来快速创建组件。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">const Button = (&#123;</span><br><span class="line">	day, </span><br><span class="line">	increment</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;button onClick=&#123;increment&#125;&gt;Today is &#123;day&#125;&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Button.propTypes = &#123;</span><br><span class="line">	day: PropTypes.string.isRequired,</span><br><span class="line">	increment: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h1><pre><code>class IndexPage extends PureComponent {
  state = {
    stripeObj : {
      number: 6,
      color: &apos;rgba(16, 142, 233, 1)&apos;,
      show: true
    },
    ellipsisObj: {
      fontSize : &apos;40px&apos;,
      color: &apos;red&apos;,
      show: true
    }
  }

  // 事件方法，自动绑定 this
  stripeColorChange = (e) =&gt; {
    alert(&apos;sds&apos;);
  }

  render (){
    return (&lt;div onClick={this.stripeColorChange}&gt;&lt;/div&gt;);
  }
}

IndexPage.propTypes = {
};
</code></pre><h1 id="如何选择（优先级降低）"><a href="#如何选择（优先级降低）" class="headerlink" title="如何选择（优先级降低）"></a>如何选择（优先级降低）</h1><ol>
<li>Stateless Functional Component（无状态、无生命周期）</li>
<li>PureComponent （不可变对象，最好配合Immutable.js使用）</li>
<li>Component</li>
<li>createClass</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000008402834" target="_blank" rel="noopener">谈一谈创建React Component的几种方式</a><br>    <a href="http://www.cnblogs.com/wonyun/p/5930333.html" target="_blank" rel="noopener">React创建组件的三种方式及其区别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-routerV4总结</title>
    <url>/2017/React-routerV4%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h1><pre><code>作用：
    &lt;Router&gt; 使用 HTML5 提供的 history API (pushState, replaceState 和 popstate 事件) 来保持 UI 和 URL 的同步。
属性：
    basename: string
        当前位置的基准 URL。如果你的页面部署在服务器的二级（子）目录，你需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。
    getUserConfirmation: func
        当导航需要确认时执行的函数。默认使用 window.confirm。
    forceRefresh: bool
        当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true。
    keyLength: number
        location.key 的长度。默认是 6。
    children: node
        渲染单一子组件（元素）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;</span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&quot;/calendar&quot;</span><br><span class="line">  forceRefresh=&quot;false&quot;</span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  keyLength=&quot;10&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;Link to=&quot;/today&quot; /&gt; // 渲染为 &lt;a href=&quot;/calendar/today&quot;&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h1><pre><code>作用：
    HashRouter 是一种特定的 &lt;Router&gt;， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步。
属性：
    basename: string
        当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。
    getUserConfirmation: func
        当导航需要确认时执行的函数。默认使用 window.confirm。
    hashType: string
        window.location.hash 使用的 hash 类型。有如下几种：
        &quot;slash&quot; - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops
        &quot;noslash&quot; - 后面没有斜杠，例如 # 和 #sunshine/lollipops
        &quot;hashbang&quot; - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops
        默认为 &quot;slash&quot;。
    children: node
        渲染单一子组件（元素）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; HashRouter &#125; from &apos;react-router-dom&apos;</span><br><span class="line"></span><br><span class="line">&lt;HashRouter&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;/HashRouter&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><pre><code>作用：
    为您的应用提供声明式的、无障碍导航。        
属性：    
    to: string/object
        需要跳转到的路径(pathname)或地址（location）。
        需要跳转到的地址（location）。
    replace: bool
        当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。
        当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。    
</code></pre><pre><code>&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;
&lt;Link to={{
  pathname: '/courses',
  search: '?sort=name',
  hash: '#the-hash',
  state: { fromDashboard: true }
}}/&gt;
</code></pre><h1 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h1><pre><code>作用：    
    为当前 URL 添加 class 和 style。
属性：
    activeClassName: string
        选中 URL 是添加的class。
    activeStyle：object
        选中 URL 是添加的style。
    exact: bool    
        如果为 true，path 为 &apos;/one&apos; 的路由将不能匹配 &apos;/one/two&apos;，反之，亦然。    
    strict: bool
        对路径末尾斜杠的匹配。如果为 true。path 为 &apos;/one/&apos; 将不能匹配 &apos;/one&apos; 但可以匹配 &apos;/one/two&apos;。
    isActive: func    
        为URL匹配添加更严谨的逻辑函数。    
</code></pre><h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><pre><code>作用：    
    当用户离开当前页面前做出一些提示。
属性：
    message: string/func
        当用户离开当前页面时，设置的提示信息。
        当用户离开当前页面时，设置的回掉函数
    when: bool
        通过设置一定条件要决定是否启用 Prompt
</code></pre><h1 id="MemoryRouter"><a href="#MemoryRouter" class="headerlink" title="MemoryRouter"></a>MemoryRouter</h1><pre><code>作用：
    无 DOM 的环境。

属性：
    initialEntries: array
        一个 history 堆栈的数组。
    initialIndex: number
        在 initialEntries 数组中的初始index。
    getUserConfirmation: func
    keyLength: number
    children: node
</code></pre><h1 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h1><pre><code>作用：
    重定向将替代当前的location 中的 history。
属性：
    to: string/object
        重定向string
        重定向object
    push: bool
        当为 true 时，替换掉整个history，而不是当前这一条。
    from: string    
        重定向的路径名。
</code></pre><h1 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h1><pre><code>作用：
    它最基本的职责就是当页面的访问地址与 Route 上的 path 匹配时，就渲染出对应的 UI 界面。
属性：
    component: func
        只有当访问地址和路由匹配时，一个 React component 才会被渲染，此时此组件接受 route props (match, location, history)。
    render: func    
        此方法适用于内联渲染，而且不会产生上文说的重复装载问题。
    children: func
        有时候你可能只想知道访问地址是否被匹配，然后改变下别的东西，而不仅仅是对应的页面。
    path: string
    exact: bool
    strict: bool
</code></pre><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><pre><code>作用：底层路由接口组件，使用封装后的组件代替。    
    &lt;BrowserRouter&gt;
    &lt;HashRouter&gt;
    &lt;MemoryRouter&gt;
    &lt;NativeRouter&gt;
    &lt;StaticRouter&gt;
属性：
    history：object
        导航的history对象
    children: node
</code></pre><h1 id="StaticRouter"><a href="#StaticRouter" class="headerlink" title="StaticRouter"></a>StaticRouter</h1><pre><code>定义：
    不会更改location的 &lt;Router&gt;，服务端渲染。
属性：
    basename: string
    location: string    
    context: object    
    children: node    
</code></pre><h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><pre><code>定义：
    只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;。
    我们只想渲染出第一个匹配的路由就可以了，于是 &lt;Switch&gt; 应运而生！
属性：
    children: node
</code></pre><h1 id="对象和方法"><a href="#对象和方法" class="headerlink" title="对象和方法"></a>对象和方法</h1><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><h3 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h3><pre><code>1.browser history -- HTML5 history API
2.hash history    -- 低版本浏览器
3.memory history  -- 无DOM环境（RN 和 Node）
</code></pre><h3 id="histoty对象详解"><a href="#histoty对象详解" class="headerlink" title="histoty对象详解"></a>histoty对象详解</h3><pre><code>length -- number 浏览历史堆栈中的条目数。        
action -- string 路由跳转到当前执行页面的动作，分为 PUSH、REPLACE、POP。
location -- object 当前访问地址信息组成的对象
    （pathname、search、hash、state）

push(path, [state]) 在历史堆栈信息里加入一个新条目。
replace(path, [state]) 在历史堆栈信息里替换掉当前的条目
go(n) 将 history 堆栈中的指针向前移动 n。
goBack() 等同于 go(-1)
goForward 等同于 go(1)
block(prompt) 阻止跳转
</code></pre><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><pre><code>location 是指你当前的位置，将要去的位置，或是之前所在的位置
在以下情境中可以获取 location 对象:
    1.在 Route component 中，以 this.props.location 获取
    2.在 Route render 中，以 ({location}) =&gt; () 方式获取
    3.在 Route children 中，以 ({location}) =&gt; () 方式获取
    4.在 withRouter 中，以 this.props.location 的方式获取
可以在不同情境中使用 location：
    1.&lt;Link to={location} /&gt;
    2.&lt;NaviveLink to={location} /&gt;
    3.&lt;Redirect to={location /&gt;
    4.history.push(location)
    5.history.replace(location)
</code></pre><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><pre><code>match 对象包含了 &lt;Route path&gt; 如何与 URL 匹配的信息，具有以下属性：
    1.params: object 路径参数，通过解析 URL 中的动态部分获得键值对
    2.isExact: bool 为 true 时，整个 URL 都需要匹配
    3.path: string 用来匹配的路径模式，用于创建嵌套的 &lt;Route&gt;
    4.url: string URL 匹配的部分，用于嵌套的 &lt;Link&gt;
在以下情境中可以获取 match 对象
    1.在 Route component 中，以 this.props.match获取
    2.在 Route render 中，以 ({match}) =&gt; () 方式获取
    3.在 Route children 中，以 ({match}) =&gt; () 方式获取
    4.在 withRouter 中，以 this.props.match的方式获取
    5.matchPath 的返回值
注：当一个 Route 没有 path 时，它会匹配一切路径。
</code></pre><h2 id="matchPath"><a href="#matchPath" class="headerlink" title="matchPath"></a>matchPath</h2><pre><code>pathname
props
</code></pre><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" rel="noopener">MDN-history</a><br>    <a href="http://blog.csdn.net/sinat_17775997/article/details/69218382" target="_blank" rel="noopener">初探 React Router 4.0</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux总结</title>
    <url>/2017/Redux%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h1><h2 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h2><pre><code>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。
</code></pre><h2 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h2><pre><code>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。
</code></pre><h2 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h2><pre><code>为了描述 action 如何改变 state tree ，你需要编写 reducers。
</code></pre><p>Immutable 是一个可实现持久数据结构的 JavaScript 库。</p>
<h1 id="Redux-基本概念"><a href="#Redux-基本概念" class="headerlink" title="Redux 基本概念"></a>Redux 基本概念</h1><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ADD_TODO = &apos;ADD_TODO&apos;</span><br><span class="line">&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text: &apos;Build my first Redux app&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。
一般来说你会通过 store.dispatch() 将 action 传到 store。    
Action 本质上是 JavaScript 普通对象。
我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。
</code></pre><h3 id="Action-创建函数"><a href="#Action-创建函数" class="headerlink" title="Action 创建函数"></a>Action 创建函数</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addTodo(text) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">	type: ADD_TODO,</span><br><span class="line">	text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Action 创建函数 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。
</code></pre><h3 id="分发-Action（此时就新建了一条-todo）"><a href="#分发-Action（此时就新建了一条-todo）" class="headerlink" title="分发 Action（此时就新建了一条 todo）"></a>分发 Action（此时就新建了一条 todo）</h3><pre><code>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch(addTodo(&apos;新建的todo&apos;))</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><pre><code>Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。
而这正是 reducer 要做的事情。
</code></pre><h3 id="设计-State-结构"><a href="#设计-State-结构" class="headerlink" title="设计 State 结构"></a>设计 State 结构</h3><pre><code>在 Redux 应用中，所有的 state 都被保存在一个单一对象中。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  visibilityFilter: &apos;SHOW_ALL&apos;,</span><br><span class="line">  todos: [</span><br><span class="line">	&#123;</span><br><span class="line">	  text: &apos;Consider using Redux&apos;,</span><br><span class="line">	  completed: true,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">	  text: &apos;Keep all state in a single tree&apos;,</span><br><span class="line">	  completed: false</span><br><span class="line">	&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Action-处理（reducer-纯函数）"><a href="#Action-处理（reducer-纯函数）" class="headerlink" title="Action 处理（reducer 纯函数）"></a>Action 处理（reducer 纯函数）</h3><pre><code>reducer 模版（不再reducer中执行有副作用的操作，如 API 请求和路由跳转）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 模版(previousState, action) =&gt; newState</span><br><span class="line"></span><br><span class="line">function todoApp(state = initialState, action) &#123;</span><br><span class="line">  // 这里暂不处理任何 action，</span><br><span class="line">  // 仅返回传入的 state。</span><br><span class="line">  return state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="处理多个-action"><a href="#处理多个-action" class="headerlink" title="处理多个 action"></a>处理多个 action</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function todoApp(state = initialState, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">	case SET_VISIBILITY_FILTER:</span><br><span class="line">	  return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">		visibilityFilter: action.filter</span><br><span class="line">	  &#125;)</span><br><span class="line">	case ADD_TODO:</span><br><span class="line">	  return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">		todos: [</span><br><span class="line">		  ...state.todos,</span><br><span class="line">		  &#123;</span><br><span class="line">			text: action.text,</span><br><span class="line">			completed: false</span><br><span class="line">		  &#125;</span><br><span class="line">		]</span><br><span class="line">	  &#125;)</span><br><span class="line">	default:</span><br><span class="line">	  return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 Reducer</h3><pre><code>注意每个 reducer 只负责管理全局 state 中它负责的一部分。
每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。
</code></pre><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><pre><code>总结，action 和 reducers。
action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。
Store的作用：
1.维持应用的 state
2.提供 getState() 方法获取 state    
3.提供 dispatch(action) 方法更新 state
4.通过 subscribe(listener) 注册监听器
5.通过 subscribe(listener) 返回的函数注销监听器
</code></pre><h3 id="发起-Actions"><a href="#发起-Actions" class="headerlink" title="发起 Actions"></a>发起 Actions</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 订阅 state 更改</span><br><span class="line">// 注意 subscribe() 返回一个函数用来注销监听器</span><br><span class="line">let unsubscribe = store.subscribe(() =&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">)</span><br><span class="line">// 发起 action</span><br><span class="line">store.dispatch(reducers)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="数据流动"><a href="#数据流动" class="headerlink" title="数据流动"></a>数据流动</h2><pre><code>Redux 应用中数据的生命周期
1.调用 store.dispatch(action)
    你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。
2.Redux store 调用传入的 reducer 函数
    Store 会把两个参数传入 reducer： 当前的 state 树和 action。
    let nextState = todoApp(previousState, action);
3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。    
    combineReducers() 来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。
4.Redux store 保存了根 reducer 返回的完整 state 树。    
</code></pre><h1 id="Redux-高级"><a href="#Redux-高级" class="headerlink" title="Redux 高级"></a>Redux 高级</h1><h2 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a>异步 Action</h2><pre><code>Action
    每个 API 请求都需要 dispatch 至少三种 action：    
    1.一种通知 reducer 请求开始的 action。    
    2.一种通知 reducer 请求成功结束的 action。    
    3.一种通知 reducer 请求失败的 action。    
同步 Action Creator    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const SELECT_SUBREDDIT = &apos;SELECT_SUBREDDIT&apos;</span><br><span class="line"></span><br><span class="line">export function selectSubreddit(subreddit) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">	type: SELECT_SUBREDDIT,</span><br><span class="line">	subreddit</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="设计-state-结构"><a href="#设计-state-结构" class="headerlink" title="设计 state 结构"></a>设计 state 结构</h3><h3 id="处理-Action（reducer）"><a href="#处理-Action（reducer）" class="headerlink" title="处理 Action（reducer）"></a>处理 Action（reducer）</h3><pre><code>处理异步 action：redux-thunk、redux-promise、redux-promise-middleware
</code></pre><h3 id="异步-Action-Creator"><a href="#异步-Action-Creator" class="headerlink" title="异步 Action Creator"></a>异步 Action Creator</h3><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><pre><code>你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。        
问题: 记录日志    
问题: 崩溃报告    
</code></pre><h2 id="搭配-React-Router"><a href="#搭配-React-Router" class="headerlink" title="搭配 React Router"></a>搭配 React Router</h2><pre><code>Redux 和 React Router 将分别成为你数据和 URL 的事实来源。    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.redux.org.cn/docs/introduction/Motivation.html" target="_blank" rel="noopener">Redux 中文文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React-API</title>
    <url>/2017/React-API.html</url>
    <content><![CDATA[<h1 id="React-高阶-API"><a href="#React-高阶-API" class="headerlink" title="React 高阶 API"></a>React 高阶 API</h1><pre><code>Creating React Elements
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐使用 JSX</span><br><span class="line">createElement() -- 根据给定的类型创建并返回新的 React element。</span><br><span class="line">createFactory() -- 根据给定的类型返回一个创建React元素的函数。</span><br></pre></td></tr></table></figure>

Transforming Elements
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloneElement() -- 以 element 作为起点，克隆并返回一个新的 React Element。</span><br><span class="line">isValidElement() -- 验证对象是否是一个React元素。返回 true 或 false 。</span><br><span class="line">React.Children() -- React.Children 提供了处理 this.props.children 这个不透明数据结构的工具。</span><br><span class="line">	React.Children.map(children, function[(thisArg)]) -- 返回数组</span><br><span class="line">	React.Children.forEach(children, function[(thisArg)]) -- 对数组每项进行操作</span><br><span class="line">	React.Children.count(children) -- 返回组件总数</span><br><span class="line">	React.Children.only(children) -- 返回仅有的子级</span><br><span class="line">	React.Children.toArray(children) -- 返回扁平数组</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h1><pre><code>React 组件可以让你把UI分割为独立、可复用的片段，并将每一片段视为相互独立的部分。
React组件可以通过继承 React.Component 或 React.PureComponent 来定义。
</code></pre><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Greeting extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">	return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

组件生命周期
    装配 -- 这些方法会在组件实例被创建和插入DOM中时被调用
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor()</span><br><span class="line">componentWillMount()</span><br><span class="line">render()</span><br><span class="line">componentDidMount()</span><br></pre></td></tr></table></figure>

    更新 -- 属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillReceiveProps()</span><br><span class="line">shouldComponentUpdate()</span><br><span class="line">componentWillUpdate()</span><br><span class="line">render()</span><br><span class="line">componentDidUpdate()</span><br></pre></td></tr></table></figure>

    卸载 -- 当一个组件被从DOM中移除时，该方法被调用
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure>

其他API
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setState() 参数为对象或函数</span><br><span class="line">forceUpdate()</span><br></pre></td></tr></table></figure>

类属性
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaultProps</span><br><span class="line">	defaultProps可以被定义为组件类的一个属性，用以为类设置默认的属性。</span><br><span class="line">displayName</span><br><span class="line">	displayName被用在调试信息中。</span><br></pre></td></tr></table></figure>

实例属性
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props</span><br><span class="line">	this.props包含了组件该调用者定义的属性。</span><br><span class="line">state</span><br><span class="line">	状态是该组件的特定数据，其可能改变多次。</span><br></pre></td></tr></table></figure>

参考
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render()</span><br><span class="line">	可以返回：React元素、字符串和数字、Portals、null、布尔值（null和布尔值什么都不渲染）</span><br><span class="line">constructor(props)</span><br><span class="line">	super(props) 有两个作用：</span><br><span class="line">		this 指向（子类的实例）</span><br><span class="line">		在构造函数中使用 this.props  </span><br><span class="line">componentWillMount()		</span><br><span class="line">	在装配发生前被立刻调用。</span><br><span class="line">	其在render()之前被调用。</span><br><span class="line">componentDidMount()	</span><br><span class="line">	在组件被装配后立即调用。	</span><br><span class="line">	初始化使得DOM节点应该进行到这里。ajax 和 定时器</span><br><span class="line">componentWillReceiveProps(nextProps)	</span><br><span class="line">	在装配了的组件接收到新属性前调用。</span><br><span class="line">shouldComponentUpdate(nextProps, nextState)	</span><br><span class="line">	使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出。</span><br><span class="line">componentWillUpdate(nextProps, nextState)	</span><br><span class="line">	当接收到新属性或状态时，componentWillUpdate()为在渲染前被立即调用。</span><br><span class="line">componentDidUpdate(prevProps, prevState)	</span><br><span class="line">	在更新发生后立即被调用。该方法并不会在初始化渲染时调用。</span><br><span class="line">componentWillUnmount()	</span><br><span class="line">	在组件被卸载和销毁之前立刻调用。	</span><br><span class="line">	可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素。</span><br><span class="line">setState(updater, [callback])</span><br><span class="line">	参数为对象 &#123;name: &apos;fanerge&apos;&#125;</span><br><span class="line">	参数为函数(prevState, props) =&gt; stateChange</span><br><span class="line">component.forceUpdate(callback)	</span><br><span class="line">	调用forceUpdate()将会导致组件的 render()方法被调用，并忽略shouldComponentUpdate()。</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h2><pre><code>浅对比继承该类来对 prop 和 state 进行比较，并调用 shouldComponentUpate()。 
深对比使用 forceUpdate() 和 不可变对象 来促进嵌套数据的快速比较。        
</code></pre><h1 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-dom这个软件包提供了针对DOM的方法，可以在你应用的顶级域中调用，也可以在有需要的情况下用作跳出React模型的出口。</span><br><span class="line">render()</span><br><span class="line">	渲染一个React元素，添加到位于提供的container里的DOM元素中，并返回这个组件的一个引用 (或者对于无状态组件返回null).</span><br></pre></td></tr></table></figure>

    ReactDOM.render(
      element,
      container,
      [callback]
    )
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReactDOM.unmountComponentAtNode(container)</span><br><span class="line">	从DOM元素中移除已挂载的React组件，清除它的事件处理器和state。</span><br><span class="line">	有组件被卸载的时候返回true，没有组件可供卸载时返回 false。</span><br><span class="line">ReactDOM.findDOMNode(component)</span><br><span class="line">	如果这个组件已经被挂载到DOM中，函数会返回对应的浏览器中生成的DOM元素 。</span><br><span class="line">	大多数情况下，你可以添加一个指向DOM节点的引用，从而完全避免使用 findDOMNode 这个函数.</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="ReactDOMServer"><a href="#ReactDOMServer" class="headerlink" title="ReactDOMServer"></a>ReactDOMServer</h1><pre><code>ReactDOMServer 类可以让你在服务端渲染你的组件。
</code></pre><h2 id="ReactDOMServer-renderToString-element"><a href="#ReactDOMServer-renderToString-element" class="headerlink" title="ReactDOMServer.renderToString(element)"></a>ReactDOMServer.renderToString(element)</h2><pre><code>把一个React元素渲染为原始的HTML。
你可以用这个方法在服务端生成HTML，并根据初始请求发送标记来加快页面的加载速度，
同时让搜索引擎可以抓取你的页面来达到优化SEO的目的。    
</code></pre><h2 id="ReactDOMServer-renderToStaticMarkup-element"><a href="#ReactDOMServer-renderToStaticMarkup-element" class="headerlink" title="ReactDOMServer.renderToStaticMarkup(element)"></a>ReactDOMServer.renderToStaticMarkup(element)</h2><pre><code>类似 renderToString，但是不会创建额外的DOM属性，例如 data-reactid 这些仅在React内部使用的属性。
如果你希望把React当作一个简单的静态页面生成器来使用，这很有用，因为去掉
</code></pre><h1 id="DOM-Elements"><a href="#DOM-Elements" class="headerlink" title="DOM Elements"></a>DOM Elements</h1><h2 id="React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。"><a href="#React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。" class="headerlink" title="React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。"></a>React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class -- className</span><br><span class="line">for -- htmlFor</span><br><span class="line">tabindex -- tabIndex</span><br><span class="line">aria-* （对于残障人士更易使用的各种机制）小写字母命名 </span><br><span class="line">data-* （自定义属性）小写字母命名</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="React和HTML-DOM属性的区别"><a href="#React和HTML-DOM属性的区别" class="headerlink" title="React和HTML DOM属性的区别"></a>React和HTML DOM属性的区别</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checked属性</span><br><span class="line">	受控组件 -- &lt;input&gt;标签type属性值为checkbox或radio时，支持checked属性。</span><br><span class="line">	非受控组件 -- defaultChecked这是非受控组件的属性</span><br><span class="line">类名属性</span><br><span class="line">	class -- className</span><br><span class="line">dangerouslySetInnerHTML函数</span><br><span class="line">	处理Cross-site scripting (XSS) </span><br><span class="line">	dangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。</span><br><span class="line">htmlFor</span><br><span class="line">	for -- htmlFor</span><br><span class="line">绑定事件</span><br><span class="line">	onchange -- onChange</span><br><span class="line">selected</span><br><span class="line">	受控组件 -- 使用selected属性，设定组件是否选中的状态。</span><br><span class="line">style属性</span><br><span class="line">	&lt;Hello style=&#123;&#123;color: &apos;blue&apos;&#125;&#125; /&gt;</span><br><span class="line">	浏览器后缀除了ms以外，都应该以大写字母开头。</span><br><span class="line">	这就是为什么WebkitTransition有一个大写字母W。</span><br><span class="line">suppressContentEditableWarning</span><br><span class="line">	contentEditable 该属性少使用。</span><br><span class="line">value</span><br><span class="line">	受控组件 -- &lt;input&gt; 和 &lt;textarea&gt; 组件都支持value属性。</span><br><span class="line">	非受控组件 -- defaultValue属性对应的是非受控组件的属性，用来设置组件第一次加载时的值。</span><br><span class="line">支持所有的HTMl属性</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="SyntheticEvent"><a href="#SyntheticEvent" class="headerlink" title="SyntheticEvent"></a>SyntheticEvent</h1><h2 id="您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。"><a href="#您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。" class="headerlink" title="您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。"></a>您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean bubbles</span><br><span class="line">boolean cancelable</span><br><span class="line">DOMEventTarget currentTarget</span><br><span class="line">boolean defaultPrevented</span><br><span class="line">number eventPhase</span><br><span class="line">boolean isTrusted</span><br><span class="line">DOMEvent nativeEvent</span><br><span class="line">void preventDefault()</span><br><span class="line">boolean isDefaultPrevented()</span><br><span class="line">void stopPropagation()</span><br><span class="line">boolean isPropagationStopped()</span><br><span class="line">DOMEventTarget target</span><br><span class="line">number timeStamp</span><br><span class="line">string type</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="事件池"><a href="#事件池" class="headerlink" title="事件池"></a>事件池</h2><pre><code>SyntheticEvent是共享的。那就意味着在调用事件回调之后，SyntheticEvent对象将会被重用，并且所有属性会被置空。
</code></pre><h2 id="支持的事件"><a href="#支持的事件" class="headerlink" title="支持的事件"></a>支持的事件</h2><pre><code>在事件名后面加Capture就能在事件捕获阶段注册事件处理函数。
你可以使用onClickCapture代替onClick在事件捕获阶段来处理点击事件。
[查看所有支持的事件](https://doc.react-china.org/docs/events.html)
</code></pre><h1 id="Test-Utilities"><a href="#Test-Utilities" class="headerlink" title="Test Utilities"></a>Test Utilities</h1><pre><code>导入 -- import ReactTestUtils from &apos;react-dom/test-utils&apos;;
[单元测试](https://doc.react-china.org/docs/test-utils.html)
</code></pre><h1 id="浅层渲染"><a href="#浅层渲染" class="headerlink" title="浅层渲染"></a>浅层渲染</h1><pre><code>[浅层渲染](https://doc.react-china.org/docs/shallow-renderer.html)
</code></pre><h1 id="Test-Renderer"><a href="#Test-Renderer" class="headerlink" title="Test Renderer"></a>Test Renderer</h1><pre><code>[Test Renderer](https://doc.react-china.org/docs/test-renderer.html)        
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://doc.react-china.org/docs/react-api.html" target="_blank" rel="noopener">React官方API</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux-API整理</title>
    <url>/2017/Redux-API%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<p>Redux 定义了一系列的约定（contract）来让你来实现（例如 reducers），同时提供少量辅助函数来把这些约定整合到一起。<br>Redux 只关心如何管理 state。在实际的项目中，你还需要使用 UI 绑定库如 react-redux。</p>
<h1 id="redux相关API"><a href="#redux相关API" class="headerlink" title="redux相关API"></a>redux相关API</h1><h2 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h2><p>createStore(reducers, [preloadedState], enhancer)</p>
<h2 id="合并-reducers-函数"><a href="#合并-reducers-函数" class="headerlink" title="合并 reducers 函数"></a>合并 reducers 函数</h2><p>该函数返回结果将作为 createStore 的第一个参数。<br>随着应用变得越来越复杂，可以考虑将 reducer 函数 拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分。<br>combineReducers(reducers)</p>
<h2 id="添加中间件"><a href="#添加中间件" class="headerlink" title="添加中间件"></a>添加中间件</h2><p>该函数返回结果将作为 createStore 的第三个参数。<br>我们可以在 action - reducer 中间加入，中间件如 redux-saga 等。<br>applyMiddleware(…middlewares)</p>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>bindActionCreators(actionCreators, dispatch)<br>compose(…functions)</p>
<h2 id="Store-API"><a href="#Store-API" class="headerlink" title="Store API"></a>Store API</h2><p>getState() // 返回应用当前的 state 树。<br>dispatch(action) // 分发 action。这是触发 state 变化的惟一途径。<br>subscribe(listener) // 添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化时触发监听函数。<br>replaceReducer(nextReducer) // 替换 store 当前用来计算 state 的 reducer。</p>
<h1 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h1><p>作用：Redux 官方提供的 React 绑定库。<br>本库深受分离容器组件和展示组件思想启发。<br>在应用中，只有最顶层组件是对 Redux 可知（例如路由处理）这是很好的。<br>所有它们的子组件都应该是“笨拙”的，并且是通过 props 获取数据。<br>对比 容器组件 和 展示组件</p>
<table>
<thead>
<tr>
<th>组件类型</th>
<th style="text-align:center">容器组件</th>
<th style="text-align:center">展示组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置</td>
<td style="text-align:center">最顶层，路由处理</td>
<td style="text-align:center">中间和子组件</td>
</tr>
<tr>
<td>使用 Redux</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>读取数据</td>
<td style="text-align:center">从 Redux 获取 state</td>
<td style="text-align:center">从 props 获取数据</td>
</tr>
<tr>
<td>修改数据</td>
<td style="text-align:center">向 Redux 发起 actions</td>
<td style="text-align:center">从 props 调用回调函数</td>
</tr>
</tbody>
</table>
<h2 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h2><p>作用：<br>Provider 使组件层级中的 connect() 方法都能够获得 Redux store。<br>正常情况下，你的根组件应该嵌套在 Provider 中才能使用 connect() 方法。<br>属性：<br>store (Redux Store): 应用程序中唯一的 Redux store 对象<br>children (ReactElement) 组件层级的根组件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">	&lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  targetEl</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h3><p>作用：<br>    连接 React 组件与 Redux store。<br>    连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。<br>参数：<br>1.[mapStateToProps(state, [ownProps]): stateProps] (Function):<br>    如果定义该参数，组件将会监听 Redux store 的变化。<br>2.[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function):<br>    如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，<br>    而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。<br>3.[mergeProps(stateProps, dispatchProps, ownProps): props] (Function):<br>    如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的<br>    props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。<br>4.[options] (Object) 如果指定这个参数，可以定制 connector 的行为。</p>
<p>返回值：<br>    根据配置信息，返回一个注入了 state 和 action creator 的 React 组件。<br>静态属性：<br>    WrappedComponent (Component): 传递到 connect() 函数的原始组件类。<br>静态方法：<br>    组件原来的静态方法都被提升到被包装的 React 组件。<br>实例方法：<br>    getWrappedInstance(): ReactComponent<br>    仅当 connect() 函数的第四个参数 options 设置了 { withRef: true } 才返回被包装的组件实例。</p>
<blockquote>
<p>   参考文档：<br><a href="https://github.com/react-guide/redux-tutorial-cn" target="_blank" rel="noopener">redux 官方文档</a><br><a href="http://www.redux.org.cn/docs/api/createStore.html" target="_blank" rel="noopener">redux</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol总结</title>
    <url>/2017/Symbol%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="Symbol-基础"><a href="#Symbol-基础" class="headerlink" title="Symbol 基础"></a>Symbol 基础</h1><h2 id="Symbol-引入的原因"><a href="#Symbol-引入的原因" class="headerlink" title="Symbol 引入的原因"></a>Symbol 引入的原因</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。<br>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>语法：Symbol([description])<br>参数：description – 可选的，字符串。symbol的description可以用于调试，但无法访问到symbol本身。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol();</span><br><span class="line">let s2 = Symbol();</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这里作为对象的属性使用，独一无二</span><br><span class="line">let s1 = Symbol();</span><br><span class="line">let a = &#123;</span><br><span class="line">	[s1]: &apos;我是Symbol类型的&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a[s1]);</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。<br><span style="color: red;">它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</span><br>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<h1 id="Symbol-for-key-，Symbol-keyFor-key"><a href="#Symbol-for-key-，Symbol-keyFor-key" class="headerlink" title="Symbol.for(key)，Symbol.keyFor(key)"></a>Symbol.for(key)，Symbol.keyFor(key)</h1><h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p>我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol.for(&apos;foo&apos;);</span><br><span class="line">let s2 = Symbol.for(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">s1 === s2 // true</span><br></pre></td></tr></table></figure></p>
<pre><code>PS：上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。
    Symbol.for(key)与Symbol(desc)这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
</code></pre><h2 id="Symbol-keyFor-key"><a href="#Symbol-keyFor-key" class="headerlink" title="Symbol.keyFor(key)"></a>Symbol.keyFor(key)</h2><pre><code>Symbol.keyFor方法返回一个（全局）已登记的 Symbol 类型值的key。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol.for(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s1) // &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">let s2 = Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure>

PS：上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。
</code></pre><h1 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h1><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h2 id="迭代-symbols"><a href="#迭代-symbols" class="headerlink" title="迭代 symbols"></a>迭代 symbols</h2><ol>
<li>Symbol.iterator<br>  一个返回一个对象默认迭代器的方法。使用 for…of。</li>
<li>Symbol.asyncIterator（实验性API）<br>  一个返回对象默认的异步迭代器的方法。使用 for await of。</li>
</ol>
<h2 id="正则表达式-symbols"><a href="#正则表达式-symbols" class="headerlink" title="正则表达式 symbols"></a>正则表达式 symbols</h2><ol>
<li>Symbol.match<br>  一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match().</li>
<li>Symbol.replace<br>  一个替换匹配字符串的子串的方法. 使用 String.prototype.replace().</li>
<li>Symbol.search<br>  一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search().</li>
<li>Symbol.split<br>  一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split().</li>
</ol>
<h2 id="其他-symbols"><a href="#其他-symbols" class="headerlink" title="其他 symbols"></a>其他 symbols</h2><ol>
<li>Symbol.hasInstance<br>  一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof.</li>
<li>Symbol.isConcatSpreadable<br>  一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat().</li>
<li>Symbol.unscopables<br>  拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</li>
<li>Symbol.species<br>  一个用于创建派生对象的构造器函数。</li>
<li>Symbol.toPrimitive<br>  一个将对象转化为基本数据类型的方法。</li>
<li>Symbol.toStringTag<br>  用于对象的默认描述的字符串值。使用Object.prototype.toString().</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">阮一峰-Symbol</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">MDN-Symbol</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass学习</title>
    <url>/2017/Sass%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>Sass是在CSS语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。</p>
<h2 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h2><pre><code>在命令行中运行 Sass
    sass input.scss output.css
监视单个 Sass 文件，每次修改并保存时自动编译
    sass --watch input.scss:output.css
监视整个文件夹
    sass --watch app/scss:public/stylesheets
开启debug信息
    sass --watch input.scss:output.css --debug-info
选择编译格式并添加调试map
    sass --watch input.scss:output.css --style expanded --sourcemap
编译添加调试map
    sass --watch input.scss:output.css --sourcemap
编译格式
    sass --watch input.scss:output.css --style compact
</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><pre><code>sass让人们受益的一个重要特性就是它为css引入了变量。你可以把反复使用的css属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。
sass使用$符号来标识变量，如比如$highlight-color和$sidebar-width。
</code></pre><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ol>
<li>声明单个属性值<br>$higlight-color: #f90;</li>
<li>声明多个属性值<br>$basic-border: 1px solid black;</li>
<li>逗号分割多个属性值<br>$plain-font: “Myriad Pro”,Myriad,”Helvetica Neue”,Helvetica,”Liberation Sans”,Arial,sans-serif,sans-serif;</li>
<li><p>变量的作用域<br>当变量定义在css规则块内，那么该变量只能在此规则块内使用。<br>如果它们出现在任何形式的{…}块中（如@media或者@font-face块）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nav-color: #F90; // 全局声明</span><br><span class="line">nav &#123;</span><br><span class="line">  $width: 100px; // 局部声明</span><br><span class="line">  width: $width; // 100px</span><br><span class="line">  color: $nav-color; // #f90</span><br><span class="line">&#125;</span><br><span class="line">// 这意味着是你可以在样式表的其他地方定义和使用$width变量，不会对这里造成影响。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在声明变量时，变量值也可以引用其他变量。<br>$highlight-color: #F90;<br>$highlight-border: 1px solid $highlight-color;</p>
<h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明变量</span><br><span class="line">$highlight-color: #F90;</span><br><span class="line">$highlight-border: 1px solid $highlight-color;</span><br><span class="line">.selected &#123;</span><br><span class="line">  border: $highlight-border; // 引用变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ol>
<li>变量名用中划线还是下划线分隔<br>用中划线声明的变量可以使用下划线的方式引用，反之亦然。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$link-color: blue; // 中划线声明</span><br><span class="line">a &#123;</span><br><span class="line">  color: $link_color; // 下划线引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="将局部变量升级为全局变量"><a href="#将局部变量升级为全局变量" class="headerlink" title="将局部变量升级为全局变量"></a>将局部变量升级为全局变量</h3><pre><code>编译前
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  $width: 5em !global;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123; </span><br><span class="line">	width: 5em; </span><br><span class="line">&#125;</span><br><span class="line">#sidebar &#123; </span><br><span class="line">	width: 5em; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型 (Data Types)"></a>数据类型 (Data Types)</h3><pre><code>Interactive Shell
    color: #777 + #777; // color: #eeeeee;
如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  $font-size: 12px;</span><br><span class="line">  $line-height: 30px;</span><br><span class="line">  font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

数字，1, 2, 13, 10px
字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &apos;bar&apos;, baz
颜色，blue, #04a3f9, rgba(255,0,0,0.5)
布尔型，true, false
空值，null
数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)
</code></pre><h2 id="嵌套CSS-规则"><a href="#嵌套CSS-规则" class="headerlink" title="嵌套CSS 规则"></a>嵌套CSS 规则</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">#content &#123;</span><br><span class="line">  article &#123;</span><br><span class="line">	h1 &#123; color: #333 &#125;</span><br><span class="line">	p &#123; margin-bottom: 1.4em &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  aside &#123; background-color: #EEE &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">#content article h1 &#123; color: #333 &#125;</span><br><span class="line">#content article p &#123; margin-bottom: 1.4em &#125;</span><br><span class="line">#content aside &#123; background-color: #EEE &#125;</span><br></pre></td></tr></table></figure>

当你同时要为一个容器元素及其子元素编写特定样式时，这种能力就非常有用了。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">#content &#123;</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">  aside &#123; background-color: #eee &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">#content &#123; background-color: #f5f5f5 &#125;</span><br><span class="line">#content aside &#123; background-color: #eee &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;"></a>父选择器的标识符&amp;</h3><pre><code>作用于伪类:hover、:after等等
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">article a &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  &amp;:hover &#123; color: red &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">article a &#123; color: blue &#125;</span><br><span class="line">article a:hover &#123; color: red &#125;</span><br></pre></td></tr></table></figure>

父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。
举例来说，当用户在使用IE浏览器时，你会通过JavaScript在&lt;body&gt;标签上添加一个ie的类名，为这种情况编写特殊的样式如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">#content aside &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  body.ie &amp; &#123; color: green &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">#content aside &#123;color: red&#125;;</span><br><span class="line">body.ie #content aside &#123; color: green &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">nav, aside &#123;</span><br><span class="line">  a &#123;color: blue&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">nav a, </span><br><span class="line">aside a &#123;</span><br><span class="line">	color: blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~"></a>子组合选择器和同层组合选择器：&gt;、+和~</h3><pre><code>上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。    
可以把它们放在外层选择器后边，或里层选择器前边。
&gt;  直接后代选择器
+  紧接的相邻兄弟选择器
~  同层全体组合选择器
</code></pre><h3 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h3><pre><code>除了CSS选择器，属性也可以进行嵌套。
嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。
</code></pre><ol>
<li><p>属性的嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">nav &#123;</span><br><span class="line">  border: &#123;</span><br><span class="line">  style: solid;</span><br><span class="line">  width: 1px;</span><br><span class="line">  color: #ccc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">nav &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 1px;</span><br><span class="line">  border-color: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于属性的缩写形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">nav &#123;</span><br><span class="line">  border: 1px solid #ccc &#123;</span><br><span class="line">  left: 0px;</span><br><span class="line">  right: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">nav &#123;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">  border-left: 0px;</span><br><span class="line">  border-right: 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件"></a>导入SASS文件</h2><pre><code>css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。
使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀。
@import &quot;sidebar&quot;;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。
</code></pre><h3 id="使用SASS部分文件"><a href="#使用SASS部分文件" class="headerlink" title="使用SASS部分文件"></a>使用SASS部分文件</h3><pre><code>sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你想导入themes/_night-sky.scss这个局部文件里的变量，</span><br><span class="line">你只需在样式表中写@import &quot;themes/night-sky&quot;;。</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值"></a>默认变量值</h3><pre><code>你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。
如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。    
使用sass的!default标签可以实现这个目的。
对于通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值，非常有用。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$fancybox-width: 400px !default;</span><br><span class="line">.fancybox &#123;</span><br><span class="line">	width: $fancybox-width; // 400px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h3><pre><code>跟原生的css不同，sass允许@import命令写在css规则内。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// _blue-theme.scss</span><br><span class="line">aside &#123;</span><br><span class="line">  background: blue;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br><span class="line">// 在主scss文件中index.scss</span><br><span class="line">.blue-theme &#123;@import &quot;blue-theme&quot;&#125;	</span><br><span class="line">// 类似于编译前</span><br><span class="line">.blue-theme &#123;</span><br><span class="line">	aside &#123;</span><br><span class="line">		background: blue;</span><br><span class="line">		color: #fff;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">.blue-theme aside &#123;</span><br><span class="line">	background: blue;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入"></a>原生的CSS导入</h3><pre><code>下列3种情况使用原生CSS@import，浏览器解析css时的额外下载。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">被导入文件的名字以.css结尾；</span><br><span class="line">被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</span><br><span class="line">被导入文件的名字是CSS的url()值。</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释"></a>静默注释</h2><pre><code>sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，
即静默注释，其内容不会出现在生成的css文件中。
将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  color: #333; // 这种注释内容不会出现在生成的css文件中(静默注释)</span><br><span class="line">  padding: 0; /* 这种注释内容会出现在生成的css文件中 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

当注释出现在原生css不允许的地方，如在css属性或选择器中，sass将不知如何将其生成到对应css文件中的相应位置，于是这些注释被抹掉。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  color /* 这块注释内容不会出现在生成的css中 */: #333;</span><br><span class="line">  padding: 1; /* 这块注释内容也不会出现在生成的css中 */ 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><pre><code>混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。
你可以通过sass的混合器实现大段样式的重用。
混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明混合器</span><br><span class="line">@mixin rounded-corners &#123;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line">// 使用混合器</span><br><span class="line">div p &#123;</span><br><span class="line">	color: red;</span><br><span class="line">	@include rounded-corners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="何时使用混合器"><a href="#何时使用混合器" class="headerlink" title="何时使用混合器"></a>何时使用混合器</h3><pre><code>一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-cornersfancy-font或者no-bullets，那么往往能够构造一个合适的混合器。
如果你找不到，这时候构造一个混合器可能并不合适。
</code></pre><h3 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则"></a>混合器中的CSS规则</h3><pre><code>混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义一个嵌套css混合</span><br><span class="line">@mixin no-bullets &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  li &#123;</span><br><span class="line">	list-style-image: none;</span><br><span class="line">	list-style-type: none;</span><br><span class="line">	margin-left: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用混合</span><br><span class="line">ul.plain &#123;</span><br><span class="line">  color: #444;</span><br><span class="line">  @include no-bullets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ul.plain &#123;</span><br><span class="line">  color: #444;</span><br><span class="line">  list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">ul.plain li &#123;</span><br><span class="line">  list-style-image: none;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  margin-left: 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参"></a>给混合器传参</h3><pre><code>可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。
// 声明带参数的混合
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@mixin link-colors($normal, $hover, $visited) &#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover &#123; color: $hover; &#125;</span><br><span class="line">  &amp;:visited &#123; color: $visited; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

// 使用带参数的混合
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用1</span><br><span class="line">p a &#123;</span><br><span class="line">	@include link-colors(red, blue, white);</span><br><span class="line">&#125;</span><br><span class="line">// 使用2（好处是表明每个参数的意思和顺序）</span><br><span class="line">a &#123;</span><br><span class="line">	@include link-colors(</span><br><span class="line">	  $normal: blue,</span><br><span class="line">	  $visited: green,</span><br><span class="line">	  $hover: red</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p a &#123; color: blue; &#125;</span><br><span class="line">p a:hover &#123; color: red; &#125;</span><br><span class="line">p a:visited &#123; color: green; &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认都使用$normal的值</span><br><span class="line">@mixin link-colors(</span><br><span class="line">	$normal,</span><br><span class="line">	$hover: $normal,</span><br><span class="line">	$visited: $normal</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover &#123; color: $hover; &#125;</span><br><span class="line">  &amp;:visited &#123; color: $visited; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用混合
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@include link-colors(red)</span><br><span class="line">编译后</span><br><span class="line">p a &#123;</span><br><span class="line">	color: red; </span><br><span class="line">&#125;</span><br><span class="line">p a:hover &#123;</span><br><span class="line">	color: red; </span><br><span class="line">&#125;</span><br><span class="line">p a:visited &#123;</span><br><span class="line">	color: red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用混合
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@include link-colors(red, blue, white)</span><br><span class="line">编译后</span><br><span class="line">p a &#123;</span><br><span class="line">	color: red; </span><br><span class="line">&#125;</span><br><span class="line">p a:hover &#123;</span><br><span class="line">	color: blue; </span><br><span class="line">&#125;</span><br><span class="line">p a:visited &#123;</span><br><span class="line">	color: white; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用选择器继承来精简CSS"><a href="#使用选择器继承来精简CSS" class="headerlink" title="使用选择器继承来精简CSS"></a>使用选择器继承来精简CSS</h2><pre><code>继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。
</code></pre><ol>
<li><p>选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现。<br>编译前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//通过选择器继承继承样式</span><br><span class="line">.error &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.error, .seriousError &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd; </span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  border-width: 3px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>.seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//.seriousError从.error继承样式</span><br><span class="line">.error a&#123;  //应用到.seriousError a</span><br><span class="line">  color: red;</span><br><span class="line">  font-weight: 100;</span><br><span class="line">&#125;</span><br><span class="line">h1.error &#123; //应用到hl.seriousError</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="何时使用继承"><a href="#何时使用继承" class="headerlink" title="何时使用继承"></a>何时使用继承</h3><pre><code>混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。
当一个元素拥有的类（比如说.seriousError）表明它属于另一个类（比如说.error），这时使用继承再合适不过了。
综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。
更重要的是无论你在样式表的哪里使用.error.seriousError都会继承其中的样式。
</code></pre><h3 id="继承的高级用法"><a href="#继承的高级用法" class="headerlink" title="继承的高级用法"></a>继承的高级用法</h3><pre><code>接下来的这段代码定义了一个名为disabled的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现
编译前
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">	background: #fff;</span><br><span class="line">&#125;</span><br><span class="line">.disabled &#123;</span><br><span class="line">  color: gray;</span><br><span class="line">  @extend a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

编译后
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a, .disabled &#123;</span><br><span class="line">  background: #fff; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.disabled &#123;</span><br><span class="line">  color: gray; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="继承的工作细节"><a href="#继承的工作细节" class="headerlink" title="继承的工作细节"></a>继承的工作细节</h3><pre><code>@extend背后最基本的想法是，如果.seriousError @extend .error， 那么样式表中的任何一处.error都用.error.seriousError这一选择器组进行替换。
@extend的优点
    跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。
    继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。
</code></pre><h3 id="使用继承的最佳实践"><a href="#使用继承的最佳实践" class="headerlink" title="使用继承的最佳实践"></a>使用继承的最佳实践</h3><pre><code>通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。
避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。
</code></pre><h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><ol>
<li>占位符选择器 %foo (Placeholder Selectors: %foo)</li>
<li>字符串 (Strings)<br>  有引号字符串 与 无引号字符串 (unquoted strings)</li>
<li>数组 (Lists)<br>  nth 函数可以直接访问数组中的某一项；<br>  join 函数可以将多个数组连接在一起；<br>  append 函数可以在数组中添加新值；<br>  @each 指令能够遍历数组中的每一项。</li>
<li>Maps<br>  $map: (key1: value1, key2: value2, key3: value3);</li>
<li>颜色 (Colors)</li>
<li><p>运算 (Operations)<br>所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。<br>SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。<br>字符串运算 (String Operations)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  cursor: e + -resize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔运算 (Boolean Operations)<br>SassScript 支持布尔型的 and or 以及 not 运算。</p>
</li>
<li>圆括号 (Parentheses)<br>  width: 1em + (2em * 3);</li>
<li>插值语句 #{} (Interpolation: #{})<br>  $attr: border;<br>  #{$attr}-color: blue;</li>
<li>&amp; in SassScript<br> 父选择器标识符</li>
<li>变量定义 !default (Variable Defaults: !default)</li>
<li>@import 并可以嵌套<br> 导入其他scss文件</li>
<li>@extend</li>
<li><p>控制指令 (Control Directives)<br>@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。<br> @if 1 + 1 == 2 { border: 1px solid; }<br> @if 5 &lt; 3 { border: 2px dotted; }<br>@for</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@for $i from 1 through 3 &#123;</span><br><span class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@each</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@each $animal in puma, sea-slug, egret, salamander &#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon &#123;</span><br><span class="line">	background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@while</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$i: 6;</span><br><span class="line">@while $i &gt; 0 &#123;</span><br><span class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class="line">  $i: $i - 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>变量（声明及使用）：
    可以声明全局和局部变量。声明方法：$var-name
嵌套CSS规则：
    article a {
      color: blue;
      &amp;:hover { color: red } // 父选择器的标识符&amp;，此时代表 a 元素
    }
导入SASS文件：
    在一个scss文件同导入其他scss文件。导入方法：@import &quot;sidebar&quot;;
静默注释：
    在scss文件中有注释，编译之后注释被抹掉。注释方法为：// 
混合器：
    混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。
    定义混合器使用@mixin标识符。
    使用混合器@include。        
使用选择器继承来精简CSS：
    继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。
    这个通过@extend语法实现。    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://www.sass.hk" target="_blank" rel="noopener">Sass中文网</a></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>Sass</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>css加强（水中倒影、工具提示tooltip）</title>
    <url>/2017/css%E5%8A%A0%E5%BC%BA-1.html</url>
    <content><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="noopener">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="水中倒影"><a href="#水中倒影" class="headerlink" title="水中倒影"></a>水中倒影</h4><pre><code>要实现倒影，有两种方式：box-reflect方式和transform方式。
</code></pre><p>box-reflect效果<br>    <img src="/images/box_reflect.png" alt="box-reflect方式"></p>
<h5 id="box-reflect方式（存在兼容性）"><a href="#box-reflect方式（存在兼容性）" class="headerlink" title="box-reflect方式（存在兼容性）"></a>box-reflect方式（存在兼容性）</h5><h6 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h6><pre><code>box-reflect: &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?
参数说明：
</code></pre><ol>
<li>表示倒影的方向，可能值：above、below、left、right（上下左右）；</li>
<li>表示倒影与元素之间的间隔；</li>
<li>表示遮罩图像，可为url地址、渐变<h6 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;./img/demo.png&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h6><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">       -webkit-box-reflect: below 0 -webkit-linear-gradient(top, rgba(250, 250, 250, 0), rgba(250, 250, 250, .1) 20%, rgba(250, 250, 250, .3));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="transform方式"><a href="#transform方式" class="headerlink" title="transform方式"></a>transform方式</h5><pre><code>这种方式其实就是复制图片，然后翻转，最后同样是使用渐变来充当遮罩层，覆盖在翻转的图片之上。
</code></pre><p>transform效果<br>    <img src="/images/transform_reflect.png" alt="transform方式"></p>
<h6 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h6><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box-reflect&quot;&gt;</span><br><span class="line">       &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h6><pre><code>使用伪类元素将我们需要将图片克隆一份，然后翻转过来，before存放背景图片，after达到渐变效果，这样after的z-index在before大，就达到了我们想要的效果。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box-reflect &#123;</span><br><span class="line">       position: relative;</span><br><span class="line">       width: 150px;</span><br><span class="line">       float: left;</span><br><span class="line">       margin-right: 40px;</span><br><span class="line">   &#125;</span><br><span class="line">   .box-reflect img &#123;</span><br><span class="line">       width: 100%;</span><br><span class="line">       height: 100%;</span><br><span class="line">   &#125;</span><br><span class="line">   .box-reflect:before &#123;</span><br><span class="line">       background: url(img/demo.png) no-repeat;</span><br><span class="line">       background-size: 100% 100%;</span><br><span class="line">       transform: scaleY(-1);</span><br><span class="line">       /*添加半透明是为了更真实*/</span><br><span class="line">       opacity: 0.5;</span><br><span class="line">       filter: alpha(opacity=&apos;50&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">   .box-reflect:before, .box-reflect:after &#123;</span><br><span class="line">       position: absolute;</span><br><span class="line">       width: 100%;</span><br><span class="line">       height: 100%;</span><br><span class="line">       top: 100%;</span><br><span class="line">       left: 0;</span><br><span class="line">       content: &quot;&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   .box-reflect:after &#123;</span><br><span class="line">       background-image: -webkit-linear-gradient(bottom,rgb(0,0,0) 20%,rgba(0,0,0,0) 90%);</span><br><span class="line">       filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColor=0, EndColorStr=#000000);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="工具提示（tooltip）"><a href="#工具提示（tooltip）" class="headerlink" title="工具提示（tooltip）"></a>工具提示（tooltip）</h4><p>css3设计的tooltip工具<br>    <img src="/images/tooltip.png" alt="tooltip"></p>
<h5 id="创建模版-2"><a href="#创建模版-2" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;toop-group&quot;&gt;</span><br><span class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在上方&quot; data-direction=&quot;up&quot;&gt;</span><br><span class="line">           在上方</span><br><span class="line">       &lt;/button&gt;</span><br><span class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在右方&quot; data-direction=&quot;right&quot;&gt;</span><br><span class="line">           在右方</span><br><span class="line">       &lt;/button&gt;</span><br><span class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在下方&quot; data-direction=&quot;down&quot;&gt;</span><br><span class="line">           在下方</span><br><span class="line">       &lt;/button&gt;</span><br><span class="line">       &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在左方&quot; data-direction=&quot;left&quot;&gt;</span><br><span class="line">           在左方</span><br><span class="line">       &lt;/button&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="设置样式-2"><a href="#设置样式-2" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code>总体思路：
</code></pre><ol>
<li>利用伪类before生成提示工具的三角形border来形成。</li>
<li>利用伪类after生成提示内容（长方形）以及获取提示文本content(attr(data-tooltip)),来获取自身的自定义属性data-tooltip。</li>
<li>利用hover效果让其展现，在加入一些css3动画将表现的更好。</li>
<li>使用了calc用于动态计算长度值，使我们的组件更通用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.tooltip</span><br><span class="line">&#123;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.tooltip:before</span><br><span class="line">&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	border: 5px solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">.tooltip:after</span><br><span class="line">&#123;</span><br><span class="line">	font-size: 14px;</span><br><span class="line">	line-height: normal;</span><br><span class="line"></span><br><span class="line">	position: absolute;</span><br><span class="line"></span><br><span class="line">	padding: 5px 10px;</span><br><span class="line">	content: attr(data-tooltip);</span><br><span class="line">	white-space: nowrap;</span><br><span class="line"></span><br><span class="line">	color: #fff;</span><br><span class="line">	border-radius: 3px;</span><br><span class="line">	background: #383838;</span><br><span class="line">&#125;</span><br><span class="line">.tooltip:before,</span><br><span class="line">.tooltip:after</span><br><span class="line">&#123;</span><br><span class="line">	z-index: 1000000;</span><br><span class="line"></span><br><span class="line">	visibility: hidden;</span><br><span class="line"></span><br><span class="line">	-webkit-transition: .3s ease;</span><br><span class="line">	   -moz-transition: .3s ease;</span><br><span class="line">			transition: .3s ease;</span><br><span class="line">	-webkit-transition-delay: 0ms;</span><br><span class="line">	   -moz-transition-delay: 0ms;</span><br><span class="line">			transition-delay: 0ms;</span><br><span class="line">	pointer-events: none;</span><br><span class="line"></span><br><span class="line">	opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.tooltip:hover:before,</span><br><span class="line">.tooltip:hover:after</span><br><span class="line">&#123;</span><br><span class="line">	visibility: visible;</span><br><span class="line"></span><br><span class="line">	opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;down&apos;]:before</span><br><span class="line">&#123;</span><br><span class="line">	top: -webkit-calc(100% - 5px);</span><br><span class="line">	top:    -moz-calc(100% - 5px);</span><br><span class="line">	top:         calc(100% - 5px);</span><br><span class="line"></span><br><span class="line">	border-bottom-color: #383838;</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;down&apos;]:after</span><br><span class="line">&#123;</span><br><span class="line">	top: -webkit-calc(100% + 5px);</span><br><span class="line">	top:    -moz-calc(100% + 5px);</span><br><span class="line">	top:         calc(100% + 5px);</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;down&apos;]:before,</span><br><span class="line">[data-direction=&apos;down&apos;]:after,</span><br><span class="line">[data-direction=&apos;up&apos;]:before,</span><br><span class="line">[data-direction=&apos;up&apos;]:after</span><br><span class="line">&#123;</span><br><span class="line">	left: 50%;</span><br><span class="line">	-webkit-transform: translate3d(-50%,0,0);</span><br><span class="line">	   -moz-transform: translate3d(-50%,0,0);</span><br><span class="line">			transform: translate3d(-50%,0,0);</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;up&apos;]:before</span><br><span class="line">&#123;</span><br><span class="line">	bottom: -webkit-calc(100% - 5px);</span><br><span class="line">	bottom:    -moz-calc(100% - 5px);</span><br><span class="line">	bottom:         calc(100% - 5px);</span><br><span class="line"></span><br><span class="line">	border-top-color: #383838;</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;up&apos;]:after</span><br><span class="line">&#123;</span><br><span class="line">	bottom: -webkit-calc(100% + 5px);</span><br><span class="line">	bottom:    -moz-calc(100% + 5px);</span><br><span class="line">	bottom:         calc(100% + 5px);</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;left&apos;]:before,</span><br><span class="line">[data-direction=&apos;left&apos;]:after,</span><br><span class="line">[data-direction=&apos;right&apos;]:before,</span><br><span class="line">[data-direction=&apos;right&apos;]:after</span><br><span class="line">&#123;</span><br><span class="line">	top: 50%;</span><br><span class="line">	-webkit-transform: translate3d(0,-50%,0);</span><br><span class="line">	   -moz-transform: translate3d(0,-50%,0);</span><br><span class="line">			transform: translate3d(0,-50%,0);</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;left&apos;]:before</span><br><span class="line">&#123;</span><br><span class="line">	left: -5px;</span><br><span class="line">	border-left-color: #383838;</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;left&apos;]:after</span><br><span class="line">&#123;</span><br><span class="line">	right: -webkit-calc(100% + 5px);</span><br><span class="line">	right:    -moz-calc(100% + 5px);</span><br><span class="line">	right:         calc(100% + 5px);</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;right&apos;]:before</span><br><span class="line">&#123;</span><br><span class="line">	left: -webkit-calc(100% - 5px);</span><br><span class="line">	left:    -moz-calc(100% - 5px);</span><br><span class="line">	left:         calc(100% - 5px);</span><br><span class="line"></span><br><span class="line">	border-right-color: #383838;</span><br><span class="line">&#125;</span><br><span class="line">[data-direction=&apos;right&apos;]:after</span><br><span class="line">&#123;</span><br><span class="line">	left: -webkit-calc(100% + 5px);</span><br><span class="line">	left:    -moz-calc(100% + 5px);</span><br><span class="line">	left:         calc(100% + 5px);</span><br><span class="line">&#125;</span><br><span class="line">.toop-group &#123;</span><br><span class="line">	padding-top: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>   参考文档：</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261476" target="_blank" rel="noopener">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-box-reflect" target="_blank" rel="noopener">MDN box-reflect</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="noopener">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Set和Map的用法</title>
    <url>/2017/Set%E5%92%8CMap%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="Set-详解"><a href="#Set-详解" class="headerlink" title="Set 详解"></a>Set 详解</h1><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>语法：new Set([iterable]);<br>参数：如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。<br>返回值：一个新的Set对象。</p>
<h2 id="来个简单实例"><a href="#来个简单实例" class="headerlink" title="来个简单实例"></a>来个简单实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set = new Set([1, 2, 3, 3]);</span><br><span class="line">console.log(set) // Set(3) &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol>
<li>Set.prototype<br>表示Set构造器的原型，允许向所有Set对象添加新的属性。</li>
<li>Set.prototype.constructor<br>返回实例的构造函数。默认情况下是Set。</li>
<li>Set.prototype.size<br>返回Set对象的值的个数。</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</li>
<li>Set.prototype.clear()<br>移除Set对象内的所有元素。</li>
<li>Set.prototype.delete(value)<br>移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</li>
<li>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</li>
<li>Set.prototype.keys()<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</li>
<li>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</li>
<li>Set.prototype<a href>@@iterator</a><br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值</li>
</ol>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-基础"><a href="#WeakSet-基础" class="headerlink" title="WeakSet 基础"></a>WeakSet 基础</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<h3 id="WeakSet-具有的方法"><a href="#WeakSet-具有的方法" class="headerlink" title="WeakSet 具有的方法"></a>WeakSet 具有的方法</h3>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws = new WeakSet();</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(window);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(window); // true</span><br><span class="line"></span><br><span class="line">ws.delete(window);</span><br><span class="line">ws.has(window);    // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-出现的背景"><a href="#Map-出现的背景" class="headerlink" title="Map 出现的背景"></a>Map 出现的背景</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<h2 id="基础特性-1"><a href="#基础特性-1" class="headerlink" title="基础特性"></a>基础特性</h2><p>语法：new Map([iterable])<br>参数：iterable<br>    Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>
<h2 id="简单的Map-实例"><a href="#简单的Map-实例" class="headerlink" title="简单的Map 实例"></a>简单的Map 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(true, 1);</span><br><span class="line">map.set(&apos;true&apos;, 2);</span><br><span class="line">map.get(true) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ol>
<li>Map.prototype<br>表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。</li>
<li>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</li>
<li>Map.prototype.size<br>返回Map对象的键/值对的数量。</li>
</ol>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</li>
<li>Map.prototype.delete(key)<br>移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。</li>
<li>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</li>
<li>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</li>
<li>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</li>
<li>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</li>
<li>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</li>
<li>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li>
<li>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</li>
<li>Map.prototype<a href>@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li>
</ol>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的基础"><a href="#WeakMap-的基础" class="headerlink" title="WeakMap 的基础"></a>WeakMap 的基础</h3><pre><code>WeakMap结构与Map结构类似，也是用于生成键值对的集合。
WeakMap与Map的区别有两点：
</code></pre><ol>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<h3 id="WeakMap-的方法"><a href="#WeakMap-的方法" class="headerlink" title="WeakMap 的方法"></a>WeakMap 的方法</h3><ol>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>delete()</li>
</ol>
<h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>WeakMap 应用的典型场合就是 DOM 节点作为键名。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myElement = document.getElementById(&apos;logo&apos;);</span><br><span class="line">let myWeakmap = new WeakMap();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  let logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure></p>
<p>PS：上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">MDN-Set</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">MDN-Map</a><br>    <a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰-Set和Map</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>css加强（单选复选Switch、Loading）</title>
    <url>/2017/css%E5%8A%A0%E5%BC%BA-2.html</url>
    <content><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="noopener">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="单选复选Switch"><a href="#单选复选Switch" class="headerlink" title="单选复选Switch"></a>单选复选Switch</h4><p>switch组件是常用组件，默认的单选复选框都很丑，是这里使用CSS3美化switch。<br>    <img src="/images/switch.png" alt="效果图"><br>本问重点将一下整体思路（以单选为例）</p>
<h5 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;</span><br><span class="line">       &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &lt;div class=&quot;fan-check-inner&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;fan-check-title&quot;&gt;男&lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line">   &lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &lt;div class=&quot;fan-check-inner&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;fan-check-title&quot;&gt;女&lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/label&gt;</span><br></pre></td></tr></table></figure>

这里讲解一下DOM结构用义：
</code></pre><ol>
<li>label包含整个组件，并且是label绑定与input的关系。</li>
<li>主要前端效果通过<div class="fan-check-media"></div>节点及其伪类完成</li>
<li><p>通过input:checked 和 兄弟选择器 + 控制类fan-check-media元素的样式</p>
<h5 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">.fan-check-radio&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	padding: 5px 0;</span><br><span class="line">	cursor: pointer;</span><br><span class="line">	justify-content: center;</span><br><span class="line">	align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.fan-check-radio&gt;input&#123;</span><br><span class="line">	display: none;</span><br><span class="line">&#125;</span><br><span class="line">.fan-check-radio:hover .fan-check-media &#123;</span><br><span class="line">	border-color: red!important;</span><br><span class="line">&#125;</span><br><span class="line">.fan-check-inner,.fan-check-media</span><br><span class="line">&#123;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line"> .fan-check-radio .fan-check-media &#123;</span><br><span class="line">	line-height: 20px;</span><br><span class="line">	width: 22px;</span><br><span class="line">	height: 22px;</span><br><span class="line">	margin-right: 5px;</span><br><span class="line">	text-align: center;</span><br><span class="line">	color: #fff;</span><br><span class="line">	border: 1px solid #d9d9d9;</span><br><span class="line">	border-radius: 11px;</span><br><span class="line">&#125;</span><br><span class="line"> .fan-check-checkbox .fan-check-media &#123;</span><br><span class="line">	line-height: 20px;</span><br><span class="line">	width: 22px;</span><br><span class="line">	height: 22px;</span><br><span class="line">	margin-right: 5px;</span><br><span class="line">	text-align: center;</span><br><span class="line">	color: #fff;</span><br><span class="line">	border: 1px solid #d9d9d9;</span><br><span class="line">	border-radius: 2px;</span><br><span class="line">&#125;</span><br><span class="line">.fan-check-radio&gt;input:checked + .fan-check-media &#123;</span><br><span class="line">	border: 1px solid #1aa500;</span><br><span class="line">&#125;</span><br><span class="line">.fan-check-radio&gt;input:checked + .fan-check-media:after &#123;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	position: absolute;</span><br><span class="line">	animation: radiozoom .1s linear forwards;</span><br><span class="line">	border-radius: 6px;</span><br><span class="line">	background: #1aa500; </span><br><span class="line">&#125;</span><br><span class="line">@keyframes radiozoom &#123;</span><br><span class="line">	from &#123;</span><br><span class="line">		top: 8px;</span><br><span class="line">		left:8px;</span><br><span class="line">		width: 2px;</span><br><span class="line">		height: 2px;</span><br><span class="line">	&#125;</span><br><span class="line">	to &#123;</span><br><span class="line">		top: 4px;</span><br><span class="line">		left:4px;    </span><br><span class="line">		width: 12px;</span><br><span class="line">		height: 12px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：<br>我们需要隐藏radio默认的样式，来做我们自己的UI：.fan-check-radio&gt;input{ display: none; }<br>然后在就只这个<div class="fan-check-media"></div>节点及其伪类上下功夫了。<br>.fan-check-media这个节点需要使用相对定位，其伪类上使用绝对定位。<br>先设定input未选中时的样式，也是通过.fan-check-media及其伪类来控制。<br>在设置input选中时的样式，通过属性选择其[type=’radio’]:checked来控制radio被选中的样式。<br>具体操作请参考，下面的代码库</p>
</li>
</ol>
<h4 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h4><p>先来看下效果<br>    <img src="/images/loading.png" alt="loading"><br>    讲解一下大体思路：</p>
<ol>
<li>构建外层包裹div（相对定位），内部8个span分别占据一周（使它们绕中心一周）通过绝对定位。</li>
<li>创建一个动画，并为每个span添加动画及动画延迟。（需要满足动画周期 === 8* animation-delay ）</li>
</ol>
<h5 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code>我们创意个正方形的div，里面放置8个子元素。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;loader circle-line small&quot;&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code>通过定位和css的转换来移动每一个span的位置。
设置容器的基本样式和span的基本样式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.loader &#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	width: 5rem;</span><br><span class="line">	height: 5rem;</span><br><span class="line">&#125;</span><br><span class="line">.loader.circle-line span &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	display: inline-block;</span><br><span class="line">	width: 1.5rem;</span><br><span class="line">	height: .5rem;</span><br><span class="line">	border-top-left-radius: .25rem;</span><br><span class="line">	border-bottom-left-radius: .25rem;</span><br><span class="line">	background: #1aa500;</span><br><span class="line">	opacity: .05;</span><br><span class="line">	-webkit-animation: circle-line 1s ease infinite;</span><br><span class="line">	animation: circle-line 1s ease infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

通过css3-transform得到loading图案
当然这哥定位还是很复杂，我直接参考[web开始实战](https://www.kancloud.cn/dennis/javascriptmethod/261478)的源代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.loader.circle-line span:nth-child(1) &#123;</span><br><span class="line">	top: 50%;</span><br><span class="line">	left: 0;</span><br><span class="line">	margin-top: -.25rem;</span><br><span class="line">	animation-delay: .13s;</span><br><span class="line">&#125;</span><br><span class="line">.loader.circle-line span:nth-child(2) &#123;</span><br><span class="line">	top: 1rem;</span><br><span class="line">	left: .5rem;</span><br><span class="line">	-webkit-transform: rotate(45deg);</span><br><span class="line">	transform: rotate(45deg);</span><br><span class="line">	animation-delay: .26s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader.circle-line span:nth-child(3) &#123;</span><br><span class="line">	left: 50%;</span><br><span class="line">	top: .5rem;</span><br><span class="line">	margin-left: -.75rem;</span><br><span class="line">	-webkit-transform: rotate(90deg);</span><br><span class="line">	transform: rotate(90deg);</span><br><span class="line">	animation-delay: .39s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader.circle-line span:nth-child(4) &#123;</span><br><span class="line">	right: .5rem;</span><br><span class="line">	top: 1rem;</span><br><span class="line">	-webkit-transform: rotate(145deg);</span><br><span class="line">	transform: rotate(145deg);</span><br><span class="line">	animation-delay: .52s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader.circle-line span:nth-child(5) &#123;</span><br><span class="line">	left: 3.5rem;</span><br><span class="line">	top: 50%;</span><br><span class="line">	margin-top: -.25rem;</span><br><span class="line">	-webkit-transform: rotate(180deg);</span><br><span class="line">	transform: rotate(180deg);</span><br><span class="line">	animation-delay: .65s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader.circle-line span:nth-child(6) &#123;</span><br><span class="line">	bottom: 1rem;</span><br><span class="line">	right: .5rem;</span><br><span class="line">	-webkit-transform: rotate(-145deg);</span><br><span class="line">	transform: rotate(-145deg);</span><br><span class="line">	animation-delay: .78s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader.circle-line span:nth-child(7) &#123;</span><br><span class="line">	left: 50%;</span><br><span class="line">	bottom: .5rem;</span><br><span class="line">	margin-left: -15px;</span><br><span class="line">	-webkit-transform: rotate(-90deg);</span><br><span class="line">	transform: rotate(-90deg);</span><br><span class="line">	animation-delay: 0.91s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.loader.circle-line span:nth-child(8) &#123;</span><br><span class="line">	bottom: 1rem;</span><br><span class="line">	left: .5rem;</span><br><span class="line">	-webkit-transform: rotate(-45deg);</span><br><span class="line">	transform: rotate(-45deg);</span><br><span class="line">	animation-delay: 1.04s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意：上面动画的周期必须要无限接近于最后一个span元素的动画延迟（动画延迟是平均分配的哦）。

动画，这是使用Opcity动画。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes circle-line &#123;</span><br><span class="line">	0% &#123;</span><br><span class="line">		opacity: .05;</span><br><span class="line">	&#125;</span><br><span class="line">	100% &#123;</span><br><span class="line">		opacity: .7;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="noopener">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="noopener">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="noopener">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css加强（进度条和遮罩条和切角）</title>
    <url>/2017/css%E5%8A%A0%E5%BC%BA-3.html</url>
    <content><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="noopener">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。<br>进度条<br>    <img src="./images/progress.png" alt="进度条"></p>
<h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><h5 id="创建进度条"><a href="#创建进度条" class="headerlink" title="创建进度条"></a>创建进度条</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&lt;div class=&quot;fan-progress fan-striped fan-active&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;fan-progress-bar&quot; style=&quot;width: 40%;&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	```	</span><br><span class="line">	解释：</span><br><span class="line">	1.	fan-progress为定义进度条的整体样式（背景）</span><br><span class="line">	2.	fan-striped为定义斑纹样式（背景）</span><br><span class="line">	3. 	fan-active为定义动态进度条样式（背景）</span><br><span class="line">	4.	fan-progress-bar为定义当前行进到样式</span><br><span class="line">#####	设置样式</span><br></pre></td></tr></table></figure>

* {
    box-sizing: border-box;
}
fan-progress {
    box-sizing: border-box;
    height: 20px;
    line-height: 20px;
    background: #f7f7f7;
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .08), inset 0 2px 2px rgba(0, 0, 0, .08);
    border-radius: 4px;
}
fan-progress-bar {
    width: 0;
    height: 100%;
    background: #009dd8;
    float: left;
    transition: width .6s ease;
    font-size: 12px;
    color: #fff;
    text-align: center;
    background-image: linear-gradient(to bottom, #oob4f5, #008dc5);
    box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .3), inset 0 0 0 1px rgba(0, 0, 0, .1);
    text-shadow: 0 -1px 0 rgba(0,0,0,.2);
}
/*条纹*/
.fan-progress-striped .fan-progress-bar {
    background-image:linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);
    background-size:30px 30px;
}
/*动态*/
.fan-progress-striped.fan-active .fan-progress-bar {
    animation: fan-progress-active 2s linear infinite;
}
@keyframes fan-progress-active {
    0% {
        background-position: 0 0;
    }
    100% {
        background-position: 30px 0;
    }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">####	遮罩条</span><br><span class="line">	设计思路：</span><br><span class="line">1.	用一个DOM容器包图片</span><br><span class="line">2. 	遮罩条主要以容器的伪类来创建</span><br><span class="line">3.	通过hover效果和css3的transition和transform完成相应动画</span><br><span class="line">#####	创建DOM节点</span><br></pre></td></tr></table></figure>

&lt;div class=&quot;mask&quot; data-title=&quot;遮罩条&quot;&gt;
    &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot;&gt;
&lt;/div&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####	设置样式</span><br></pre></td></tr></table></figure>

.mask {
    position: relative;
    width: 150px;
    height: 150px;
    overflow: hidden;
}   
.mask:before {
    content: attr(data-title);
    position: absolute;
    top: 100%;
    left: 0;
    padding: .7em 0;
    width: 100%;
    text-align: center;
    color: #fff;
    background: rgba(0,0,0,.5);
    transform: translate(0, 100%);
    transition: all .3s ease-in-out;
    opacity: 0;
}  
.mask:hover:before {
    top: 80%;
    transform: translate(0, 0);
    opacity: 1;
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">####	切角</span><br><span class="line">#####	创建DOM节点</span><br></pre></td></tr></table></figure>

&lt;div class=&quot;box corner&quot;&gt;单个切角&lt;/div&gt;
&lt;div class=&quot;box corner1&quot;&gt;多个切角&lt;/div&gt;
&lt;div class=&quot;box corner2&quot;&gt;多个园角&lt;/div&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####	设置样式</span><br></pre></td></tr></table></figure>

.corner {
    background: linear-gradient(-45deg, transparent 15px, #58a 15px);
}
.corner1 {
    background: linear-gradient(135deg, transparent 15px, #58a 0) top left, 
        linear-gradient(-135deg, transparent 15px, #58a 0) top right, 
        linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,
        linear-gradient(45deg, transparent 15px, #58a 0) bottom left;
    background-size: 50% 50%;
    background-repeat: no-repeat;
}
.corner2 {
    background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, 
        radial-gradient(circle at top right, transparent 15px, #58a 0) top right, 
        radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, 
        radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;
    background-size: 50% 50%;
    background-repeat: no-repeat;
}
```
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="noopener">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="noopener">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="noopener">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css加强（多形状图像和心跳灯和竖着排的文字和面包屑导航）</title>
    <url>/2017/css%E5%8A%A0%E5%BC%BA-5.html</url>
    <content><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="noopener">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="多形状图像"><a href="#多形状图像" class="headerlink" title="多形状图像"></a>多形状图像</h4><pre><code>可以实现多形状图像
border-radius: top right bottom left;
</code></pre><h4 id="心跳灯"><a href="#心跳灯" class="headerlink" title="心跳灯"></a>心跳灯</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.heartbeat &#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 100px;</span><br><span class="line">	background: red;</span><br><span class="line">	animation: heartbeat .83s ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes heartbeat &#123;</span><br><span class="line">	from &#123;</span><br><span class="line">		opacity:0.1;</span><br><span class="line">	&#125;</span><br><span class="line">	50% &#123;</span><br><span class="line">		opacity:1;</span><br><span class="line">	&#125;</span><br><span class="line">	to &#123;</span><br><span class="line">		opacity:0.1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="竖着排的文字"><a href="#竖着排的文字" class="headerlink" title="竖着排的文字"></a>竖着排的文字</h4><pre><code>writing-mode: horizontal-tb | vertical-lr | vertical-rl;
    horizontal-tb表示水平方向自上而下的书写方式。
    vertical-rl表示垂直方向自右向左的书写方式
    vertical-lr表示垂直方向自左向右的书写方式
IE
writing-mode: lr-tb | tb-rl;
    lr-tb水平方向自左向右的书写方式
    tb-rl垂直方向自上而下的书写方式。
</code></pre><h4 id="首字母下沉"><a href="#首字母下沉" class="headerlink" title="首字母下沉"></a>首字母下沉</h4><pre><code>::first-letter伪元素选择器用于选取指定选择器的首字母。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p::first-letter &#123;</span><br><span class="line">	color:#c69c6d;</span><br><span class="line">	float:left;</span><br><span class="line">	font-size:5em;</span><br><span class="line">	margin:0 .2em 0 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="noopener">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="noopener">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="noopener">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css加强（表单和文本样式和动态边框和上传组件美化）</title>
    <url>/2017/css%E5%8A%A0%E5%BC%BA-4.html</url>
    <content><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="noopener">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="表单input"><a href="#表单input" class="headerlink" title="表单input"></a>表单input</h4><p>主要添加了过渡下border和验证提示<br><img src="/images/form.png" alt="表单中的input"></p>
<h5 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;input-field&quot;&gt;</span><br><span class="line">	&lt;input id=&quot;last-name&quot; type=&quot;text&quot; placeholder=&quot;name&quot;&gt;&lt;/input&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--带验证的--&gt;</span><br><span class="line">&lt;div class=&quot;input-field error input-field-icon&quot;&gt;</span><br><span class="line">	&lt;input id=&quot;last_name&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;&gt;</span><br><span class="line">	&lt;span class=&quot;gradient&quot;&gt;&lt;/span&gt;</span><br><span class="line">	&lt;i class=&quot;ion-android-close&quot;&gt;</span><br><span class="line">	&lt;/i&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

解释：
.input-field成为容器层，input和span并列排列。
让span来充当input的下border，然后在通过为类选择器:focus和兄弟选择器和伪类元素span:after来完成
</code></pre><h5 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> *&#123;</span><br><span class="line">	box-sizing:border-box;</span><br><span class="line">&#125;</span><br><span class="line">.input-field &#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	width: 200px;</span><br><span class="line">	margin: 20px 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.input-field input &#123;</span><br><span class="line">	background-color: transparent;</span><br><span class="line">	border: none;</span><br><span class="line">	border-radius: 0;</span><br><span class="line">	height: 35px;</span><br><span class="line">	width: 100%;</span><br><span class="line">	padding: 0;</span><br><span class="line">	box-shadow: none;</span><br><span class="line">	outline: none;</span><br><span class="line">	transition: all 0.3s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.input-field input+span &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	top: 100%;</span><br><span class="line">	left: 0;</span><br><span class="line">	display: inline-block;</span><br><span class="line">	max-width: 100%;</span><br><span class="line">	z-index: 0;</span><br><span class="line">	width: 100%;</span><br><span class="line">	height: 1px;</span><br><span class="line">	border-bottom: 1px solid #d9d9d9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.input-field span:after &#123;</span><br><span class="line">	content: &quot;&quot;;</span><br><span class="line">	position: absolute;</span><br><span class="line">	bottom: 0;</span><br><span class="line">	left: 0;</span><br><span class="line">	width: 100%;</span><br><span class="line">	height: 2px;</span><br><span class="line">	background: #2196f3;</span><br><span class="line">	transform: scale(0);</span><br><span class="line">	transition: all .2s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">.input-field input:focus+span:after &#123;</span><br><span class="line">	transform: scale(1);</span><br><span class="line">&#125;</span><br><span class="line">.input-field.input-field-icon i&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	right:0;</span><br><span class="line">	top:50%;</span><br><span class="line">	padding:0 5px;</span><br><span class="line">	font-size:1.5em;</span><br><span class="line">	-webkit-transform: translate(0, -50%);</span><br><span class="line">	transform: translate(0, -50%);</span><br><span class="line">&#125;</span><br><span class="line">.input-field.input-field-icon input&#123;</span><br><span class="line">	padding-right:30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这里有个小技巧：要是验证图标垂直居中，达到居中效果。
top: 50%; 相对于父元素的高度
transform: translate(0, -50%); 相对于自身元素的高度。
</code></pre><h4 id="自定义选择文本样式"><a href="#自定义选择文本样式" class="headerlink" title="自定义选择文本样式"></a>自定义选择文本样式</h4><pre><code>使用::selection伪类选择器，我们可以实现与众不同的选择文本样式。
注意：只能设置背景色和文字颜色，同时不支持渐变色。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::selection &#123;</span><br><span class="line">	background: #009a61;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">	background: #009a61;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-selection &#123;</span><br><span class="line">	background: #009a61;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="动态的边框"><a href="#动态的边框" class="headerlink" title="动态的边框"></a>动态的边框</h4><h5 id="创建模版-1"><a href="#创建模版-1" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;dynamic-border dynamic-border-2&quot;&gt;</span><br><span class="line">	&lt;span&gt;</span><br><span class="line">	&lt;/span&gt;</span><br><span class="line">	&lt;img src=&quot;images/girl.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

整体思路：
创建一个容器，容器自身两个伪类元素，span又包含两个伪类元素，可以动态生成容器的4个边框（相对+绝对定位）。
在加上过渡效果就OK了。第二个动态边框只要按不同时间延迟组合就好了。
</code></pre><h5 id="设置样式-1"><a href="#设置样式-1" class="headerlink" title="设置样式"></a>设置样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> *&#123;</span><br><span class="line">	box-sizing:border-box;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-border &#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:200px;</span><br><span class="line">	height:200px;</span><br><span class="line">	background:gray;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-border:before,</span><br><span class="line">.dynamic-border:after,</span><br><span class="line">.dynamic-border span:first-child:before,</span><br><span class="line">.dynamic-border span:first-child:after &#123;</span><br><span class="line">	content:&quot;&quot;;</span><br><span class="line">	position:absolute;</span><br><span class="line">	background:red;</span><br><span class="line">	-webkit-transition:all .2s ease;</span><br><span class="line">	transition:all .2s ease;</span><br><span class="line">&#125;</span><br><span class="line">/*上边边框*/</span><br><span class="line">.dynamic-border:before &#123;</span><br><span class="line">	width:0; </span><br><span class="line">	top:-2px;</span><br><span class="line">	right:0;</span><br><span class="line">	height:2px;</span><br><span class="line">&#125;</span><br><span class="line">/*右边边框*/</span><br><span class="line">.dynamic-border:after &#123;</span><br><span class="line">	width:2px;</span><br><span class="line">	height:0;  </span><br><span class="line">	right:-2px;</span><br><span class="line">	bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">/*下边边框*/</span><br><span class="line">.dynamic-border span:first-child:before &#123;</span><br><span class="line">	width:0;  </span><br><span class="line">	height:2px;</span><br><span class="line">	bottom:-2px;</span><br><span class="line">	left:0;</span><br><span class="line">&#125;</span><br><span class="line">/*左边边框*/</span><br><span class="line">.dynamic-border span:first-child:after &#123;</span><br><span class="line">	width:2px;</span><br><span class="line">	height:0;  </span><br><span class="line">	top:0;</span><br><span class="line">	left:-2px;</span><br><span class="line">&#125;</span><br><span class="line">/*鼠标移动上去时*/</span><br><span class="line">.dynamic-border:hover:before,</span><br><span class="line">.dynamic-border:hover span:first-child:before &#123;</span><br><span class="line">	width:calc(100% + 2px);</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-border:hover:after,</span><br><span class="line">.dynamic-border:hover span:first-child:after &#123;</span><br><span class="line">	height:calc(100% + 2px);</span><br><span class="line">&#125;</span><br><span class="line">/*添加过渡延迟时间*/</span><br><span class="line">.dynamic-border-1:hover:before,</span><br><span class="line">.dynamic-border-1:hover span:first-child:before &#123;</span><br><span class="line">	-webkit-transition-delay:.2s;</span><br><span class="line">	transition-delay:.2s;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-border-2:hover span:first-child:before &#123;</span><br><span class="line">	-webkit-transition-delay:.2s;</span><br><span class="line">	transition-delay:.2s;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-border-2:hover:after &#123;</span><br><span class="line">	-webkit-transition-delay:.4s;</span><br><span class="line">	transition-delay:.4s;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-border-2:hover:before &#123;</span><br><span class="line">	-webkit-transition-delay:.6s;</span><br><span class="line">	transition-delay:.6s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="上传组件美化"><a href="#上传组件美化" class="headerlink" title="上传组件美化"></a>上传组件美化</h4><h5 id="创建模版-2"><a href="#创建模版-2" class="headerlink" title="创建模版"></a>创建模版</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;file file-input&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;file-inner&quot;&gt;</span><br><span class="line">		选择文件</span><br><span class="line">		&lt;button class=&quot;btn btn-primary file-inner-btn&quot;&gt;</span><br><span class="line">			文件上传</span><br><span class="line">			&lt;i class=&quot;ion-ios-cloud-upload-outline&quot;&gt;</span><br><span class="line">			&lt;/i&gt;</span><br><span class="line">		&lt;/button&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;input type=&quot;file&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="设置CSS样式"><a href="#设置CSS样式" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.file &#123;</span><br><span class="line">	position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.file input &#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:0;</span><br><span class="line">	left:0;</span><br><span class="line">	opacity:0;</span><br><span class="line">	width:100%;</span><br><span class="line">	height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.file-inner &#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:250px;</span><br><span class="line">	height:35px;</span><br><span class="line">	border:1px solid #d9d9d9;</span><br><span class="line">	border-radius:5px;</span><br><span class="line">	padding-left:10px;</span><br><span class="line">	line-height:35px;</span><br><span class="line">&#125;</span><br><span class="line">.file-inner .file-inner-btn &#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	right:0;</span><br><span class="line">	top:0;</span><br><span class="line">	height:100%;</span><br><span class="line">	box-shadow:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

解释；
这里就用了一个技巧，把input设置为opacity: 0;然后在绝对定位并设置宽高100%，这样就会是整个区域都触发file的input默认事件。
</code></pre><blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="noopener">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient3.    [transform](http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="noopener">linear-gradient</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="noopener">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css-加强（白光划过效果、3D立方体）</title>
    <url>/2017/css%E5%8A%A0%E5%BC%BA.html</url>
    <content><![CDATA[<p>在接下来的一段时间学习看云上购买的一本<a href="https://www.kancloud.cn/dennis/javascriptmethod/261472" target="_blank" rel="noopener">Web开发实战</a>书籍，来提升自己的软实力。<br>本部分为css实战部分。</p>
<h4 id="白光划过效果"><a href="#白光划过效果" class="headerlink" title="白光划过效果"></a>白光划过效果</h4><h5 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h5><p>我们要放置一张图片，用一个div包裹起来：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;highlight-box&quot;&gt;</span><br><span class="line">	&lt;img src=&quot;./img/demo.png&quot; width=&quot;296&quot; height=&quot;374&quot; alt=&quot;s&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="设置CSS样式"><a href="#设置CSS样式" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><p>定义初始样式:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.highlight-box &#123;</span><br><span class="line">       /**这里用于before、after伪类定位**/</span><br><span class="line">       position: relative; </span><br><span class="line">       width: 296px;</span><br><span class="line">       height: 374px;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着让我们来制作白光，我们不需多余的元素，只需使用:before选择器.position为伪类定位：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.highlight-box:before &#123;</span><br><span class="line">       position: absolute;</span><br><span class="line">       /* 注意这里top和left，让白光移动到图片左上角，后续的划过动画也是依靠这两个属性 */</span><br><span class="line">       top: -200%;</span><br><span class="line">       left: -100%;</span><br><span class="line">       z-index: 2;</span><br><span class="line">       display: block;</span><br><span class="line">       content: &apos;&apos;;</span><br><span class="line">       /* 定义白光的高宽，hight为300%是为了防止在移动过程中白光不够用 */</span><br><span class="line">       width: 50%;</span><br><span class="line">       height: 300%;</span><br><span class="line">       /* 使用线性渐变来实现白光 */</span><br><span class="line">       background: linear-gradient(to left top, rgba(255, 255, 255, .05) 20%, rgba(255, 255, 255, .6) 65% , rgba(255, 255, 255, .05) 100%);</span><br><span class="line">       /* background: rgba(255, 255, 255, .5); */</span><br><span class="line">       transform: rotate(45deg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用渐变（linear-gradient）来实现白光效果，同时为了斜向划过，使用transform: rotate(45deg)将其旋转45度。<br>上面的height、width、top和left，你也可以使用具体的像素值，不过建议采用百分比，这样可以重复使用，而不需手动改变太多值。<br>触发白光(hover伪类和css3动画)：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.highlight-box:hover:before &#123;</span><br><span class="line">       /* 这里省略了私有前缀代码 */</span><br><span class="line">       animation: crossed .5s linear;</span><br><span class="line">   &#125;</span><br><span class="line">   @keyframes crossed &#123;</span><br><span class="line">       0% &#123;</span><br><span class="line">           top: -200%;</span><br><span class="line">           left: -100%;</span><br><span class="line">       &#125;</span><br><span class="line">       100% &#123;</span><br><span class="line">           top: -50px;</span><br><span class="line">           left: 100%;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>截图效果(鼠标划入时的效果)<br>        <img src="/images/css_white_light.jpg" alt="白光划过"></p>
<h4 id="3D立方体"><a href="#3D立方体" class="headerlink" title="3D立方体"></a>3D立方体</h4><p>随着CSS3的出现，实现3D效果已经不是难事，这一节就来看看3D立方体是如何实现的。</p>
<h5 id="创建模板-1"><a href="#创建模板-1" class="headerlink" title="创建模板"></a>创建模板</h5><p>首先来放置一个父div.cude，然后在其里面放置6个div，分别表示立方体的6个面。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;cude&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;front surface&quot;&gt;</span><br><span class="line">		正面</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;surface left&quot;&gt;</span><br><span class="line">		左面</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;surface right&quot;&gt;</span><br><span class="line">		右面</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;surface bottom&quot;&gt;</span><br><span class="line">		底面</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;surface top&quot;&gt;</span><br><span class="line">		顶面</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;surface back&quot;&gt;</span><br><span class="line">		背面</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="设置CSS样式-1"><a href="#设置CSS样式-1" class="headerlink" title="设置CSS样式"></a>设置CSS样式</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.cude &#123;</span><br><span class="line">	width:300px;</span><br><span class="line">	height:300px;</span><br><span class="line">	position:relative;</span><br><span class="line">	margin:100px auto;</span><br><span class="line">	transform-style:preserve-3d;</span><br><span class="line">	-webkit-transform-style:preserve-3d;</span><br><span class="line">&#125;</span><br><span class="line">.surface &#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:0;</span><br><span class="line">	left:0;</span><br><span class="line">	width:300px;</span><br><span class="line">	height:300px;</span><br><span class="line">	background:#666;</span><br><span class="line">	opacity:0.8;</span><br><span class="line">	font-size:60px;</span><br><span class="line">	text-align:center;</span><br><span class="line">	line-height:300px;</span><br><span class="line">	font-weight:bold;</span><br><span class="line">	color:#fff;</span><br><span class="line">	border:1px solid #fff;</span><br><span class="line">	-webkit-transition:all .3s;</span><br><span class="line">	transition:all .3s;</span><br><span class="line">&#125;</span><br><span class="line">.surface img &#123;</span><br><span class="line">	width:100%;</span><br><span class="line">&#125;</span><br><span class="line">.front &#123;</span><br><span class="line">	transform:rotateY(0) translateZ(150px);</span><br><span class="line">&#125;</span><br><span class="line">.back &#123;</span><br><span class="line">	transform:translateZ(-150px) rotateY(180deg);</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">	transform:rotateY(-90deg) translateZ(150px);</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">	transform:rotateY(90deg) translateZ(150px);</span><br><span class="line">&#125;</span><br><span class="line">.top &#123;</span><br><span class="line">	transform:rotateX(90deg) translateZ(150px);</span><br><span class="line">&#125;</span><br><span class="line">.bottom &#123;</span><br><span class="line">	transform:rotateX(90deg) translateZ(-150px);</span><br><span class="line">&#125;</span><br><span class="line">@-webkit-keyframes rotate &#123;</span><br><span class="line">	from &#123;</span><br><span class="line">		transform: rotateX(0deg) rotateY(0deg);</span><br><span class="line">	&#125;</span><br><span class="line">	to &#123;</span><br><span class="line">		transform: rotateX(360deg) rotateY(360deg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>总结：</p>
<ol>
<li>使用了before和after伪类</li>
<li>linear-gradient-api的使用</li>
<li>animation</li>
<li>transform(分为2D转换和3D转换)</li>
<li>2d转换：translate(x,y)、translateX(x)、translateY(y)、scale(x,y)、scaleX(x)、scaleY(y)、rotate(angle)、skew(x-angle,y-angle)、skewX(angle)</li>
<li>3d转换：translate3d(x,y,z)、translateZ(z)、scale3d(x,y,z)、scaleZ(z)、rotate3d(x,y,z,angle)、rotateX(angle)、rotateY(angle)、rotateZ(angle)</li>
</ol>
<blockquote>
<p>   参考文档</p>
<ol>
<li><a href="https://www.kancloud.cn/dennis/javascriptmethod/261473" target="_blank" rel="noopener">web开发实战</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient" target="_blank" rel="noopener">linear-gradient</a></li>
<li><a href="http://www.runoob.com/cssref/css3-pr-transform.html" target="_blank" rel="noopener">transform</a><br><a href="https://github.com/fanerge/web-/tree/master" target="_blank" rel="noopener">代码仓库</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>grid布局</title>
    <url>/2017/grid%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<h4 id="设置在网格容器上的属性"><a href="#设置在网格容器上的属性" class="headerlink" title="设置在网格容器上的属性"></a>设置在网格容器上的属性</h4><pre><code>display: grid | inline-grid | subgrid;
grid-template-columns
grid-template-rows
grid-template-areas
grid-column-gap
grid-row-gap
grid-gap
justify-items
align-items
align-content
grid-auto-columns
grid-auto-rows
grid-auto-flow
grid
</code></pre><h4 id="设置在网格项上的属性"><a href="#设置在网格项上的属性" class="headerlink" title="设置在网格项上的属性"></a>设置在网格项上的属性</h4><pre><code>grid-column-start
grid-column-end
grid-row-start
grid-row-end
grid-column
grid-row
grid-area
justify-self
align-self
</code></pre><h4 id="显式的网格"><a href="#显式的网格" class="headerlink" title="显式的网格"></a>显式的网格</h4><h5 id="html"><a href="#html" class="headerlink" title="html"></a>html</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class=&quot;grid&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.grid &#123;</span><br><span class="line">	display: grid; </span><br><span class="line">	grid-template-columns: 1fr 2fr 3fr; // 指定3个列，分别指定每个列的宽度（1/6, 2/6, 3/6）。</span><br><span class="line">	grid-template-rows: 100px 100px; // 指定2行，分别指定每个行的宽度</span><br><span class="line">	grid-gap: 20px 10px; // 指定行间距和列间距（若只有一个参数是行和类间距取相同值）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="重复轨道"><a href="#重复轨道" class="headerlink" title="重复轨道"></a>重复轨道</h4><h5 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.grid &#123;</span><br><span class="line">	display: grid;</span><br><span class="line">	grid-template-columns: repeat(3, 1fr 2fr); // 第一个参数指定的是重复次数，第二个参数是每次重复的轨道列表（共3*2=6列）。</span><br><span class="line">	grid-template-rows: 100px 100px;</span><br><span class="line">	grid-gap: 20px 1px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="自动重复轨道"><a href="#自动重复轨道" class="headerlink" title="自动重复轨道"></a>自动重复轨道</h4><h5 id="css-2"><a href="#css-2" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.grid &#123;</span><br><span class="line">	display: grid;</span><br><span class="line">	grid-template-columns: repeat(auto-fill, 100px); // auto-fill关键词创建了许多与网格容器相匹配的轨道，而不会导致网格溢出。</span><br><span class="line">	grid-template-rows: 100px 100px;</span><br><span class="line">	grid-gap: 20px 10px;</span><br><span class="line">&#125;</span><br><span class="line">.grid &#123;</span><br><span class="line">	display: grid;</span><br><span class="line">	grid-template-columns: repeat(auto-fit, 100px); // auto-fit关键词与auto-fill有点类似，只是在网格项放置之后，它只会在需要时创建尽可能多的轨道，而重复的空轨道会堆叠在一起（合并）。</span><br><span class="line">	grid-template-rows: 100px 100px;</span><br><span class="line">	grid-gap: 20px 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="隐式网格"><a href="#隐式网格" class="headerlink" title="隐式网格"></a>隐式网格</h4><pre><code>如果网格中有更多的网格项，或者网格项被放置在显式网格之外，网格容器就会通过向网格中添加网格线来自动生成网格轨道。
显式网格和这些额外的隐式轨道和网格线构成了所谓的隐式网格。
</code></pre><h5 id="css-3"><a href="#css-3" class="headerlink" title="css"></a>css</h5><pre><code>对于子项目
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item:first-child &#123;</span><br><span class="line">	grid-column-start: -1;</span><br><span class="line">&#125;</span><br><span class="line">.item:nth-child(2) &#123;</span><br><span class="line">	grid-row-start: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="隐式轨道尺寸"><a href="#隐式轨道尺寸" class="headerlink" title="隐式轨道尺寸"></a>隐式轨道尺寸</h4><h5 id="css-4"><a href="#css-4" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.grid &#123; </span><br><span class="line">	display: grid; </span><br><span class="line">	grid-template-columns: repeat(4, 1fr); </span><br><span class="line">	grid-template-rows: 100px 100px; </span><br><span class="line">	grid-gap: 20px; </span><br><span class="line">	grid-auto-columns: 200px; </span><br><span class="line">	grid-auto-rows: 60px; </span><br><span class="line">	grid-auto-columns: minmax(200px, auto); // 隐藏轨道现在最小宽度是200px</span><br><span class="line">	grid-auto-rows: minmax(auto, 300px); // 隐藏轨道现在最大高度度是300px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="将网格扩展到开始"><a href="#将网格扩展到开始" class="headerlink" title="将网格扩展到开始"></a>将网格扩展到开始</h4><h5 id="css-5"><a href="#css-5" class="headerlink" title="css"></a>css</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item:first-child &#123;</span><br><span class="line">  grid-row-end: 1;</span><br><span class="line">  grid-row-start: span 3; // 开始跨越3个单元格</span><br><span class="line">&#125;</span><br><span class="line">.item:nth-child(2) &#123;</span><br><span class="line">  grid-column-end: 2;</span><br><span class="line">  grid-column-start: span 2; // 开始跨越2个单元格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="自动放置"><a href="#自动放置" class="headerlink" title="自动放置"></a>自动放置</h4><h5 id="css-6"><a href="#css-6" class="headerlink" title="css"></a>css</h5><p>我们可以通过使用grid-auto-flow属性来指定如何把网格项目自动放置到网格容器。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.grid2 &#123;</span><br><span class="line">	grid-auto-flow: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="未定义显式网格"><a href="#未定义显式网格" class="headerlink" title="未定义显式网格"></a>未定义显式网格</h4><p>使用grid-auto-rows和grid-auto-columns可以自动地调整单元格大小，因此不需要定义显式网格。</p>
<blockquote>
<p>   参考文档</p>
<ol>
<li><a href="http://www.w3cplus.com/css3/difference-explicit-implicit-grids.html" target="_blank" rel="noopener">显式网格和隐式网格的区别 </a>    </li>
<li><a href="http://www.jianshu.com/p/d183265a8dad" target="_blank" rel="noopener">Grid布局指南</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>http缓存相关的知识</title>
    <url>/2017/http%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h4 id="http缓存整理"><a href="#http缓存整理" class="headerlink" title="http缓存整理"></a>http缓存整理</h4><h5 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h5><pre><code>当一个用户发送一个静态资源请求通过下面几步获取资源：
</code></pre><ol>
<li>当第一次发送请求时，http返回200的状态码。</li>
<li>在没有关闭缓存请求的时候，则返回header中返回包含last-Modified以及Etag和Expires的字段，然后将文件保存在Cache目录下。</li>
<li>后续请求该文件时，先本地查找该资源。如果本地缓存存在该资源，但不知道是否过期，则发送一个http请求到服务器，然后服务器来判断。<br>如果该文件没有改动，则返回304，继续使用本地资源。<br>如果该文件发生改动，服务器返回该资源并返回200。<br>如果服务器没有这个资源，则返回404。<h5 id="http头部缓存相关key"><a href="#http头部缓存相关key" class="headerlink" title="http头部缓存相关key"></a>http头部缓存相关key</h5><h6 id="request-header缓存相关"><a href="#request-header缓存相关" class="headerlink" title="request header缓存相关"></a>request header缓存相关</h6>cache-control：<br>  其缓存指令对于前端常用的有如下no-cache、no-store、max-age这几个值；<br>if-none-match：<br>  该字段与响应中的eTag一起使用，表示检查实体是否有更新改变;客户端第一次发送请求时候响应报文会包含字段Etag，表示资源状态，当资源改变后该值也会改变（客户端不必关心该值怎么生成）<br>  然后缓存保存下该字段，第二次已经有该缓存时候在浏览本地缓存时候会将该值赋给if-none-match字段发送给服务器，服务器将发送的值与当前的状态进行对比，<br>  如果值一样的话则答复304去使用缓存数据，如果值改变了则发送最新数据给客户端替代现有缓存数据，并且返回状态200;<br>if-modified-since:<br>  该字段与last-modified配合使用，跟上述原理差不多，都是响应端先返回一个last-modified时间字段，再次请求时候 request头部会将缓存中的last-modified字段拿出来赋给if-modified-since，<br>  发送给服务器，服务器去判断时间是否过期，如未过期则返回304，告诉客户使用缓存数据，如果过期则重新返回一个last-modified并且返回200；<h6 id="response-header缓存相关："><a href="#response-header缓存相关：" class="headerlink" title="response header缓存相关："></a>response header缓存相关：</h6>Etag：<br>  刚才也说过 是跟if-none-match配合去使用，它根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。<br>  使用Etag主要是为了解决根据时间无法解决的问题：比如文件修改频繁（秒之内修改），导致根据时间无法判断是否更新；以及修改时间变了，但是内容没变（我们应该认为该文件是没变的）<br>expires：<br>  表示缓存过期时间例如:expires:Mon Dec 30 2011 11:01:19 GMT，跟cache-control中的max-age作用一样，不过在碰见max-age之后，该值会被覆盖从而被max-age替代;<br>last-modified:<br>  表示文件最后修改时间；</li>
</ol>
<h5 id="实现有关前端对于缓存的操作"><a href="#实现有关前端对于缓存的操作" class="headerlink" title="实现有关前端对于缓存的操作"></a>实现有关前端对于缓存的操作</h5><h6 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h6><pre><code>方法一：
在服务器进行配置其max-age或者expires使其设置一个过期值为当前一年之后。这样每次进行检验时候都会使用缓存中文件。
例如在.htaccess中
&lt;IfModule mod_headers.c&gt;
 &lt;FilesMatch &quot;.(gif|jpg|jpeg|png|ico)$&quot;&gt;
Header set Cache-Control &quot;max-age=604800&quot;
 &lt;/FilesMatch&gt;
方法二：
前端设置if-modified-since去设置一个上次修改时间大于当前日期，
方法三：
服务器端根据etag去判断是否匹配来根据实际业务来使用缓存；
后面两个方法属于弱缓存数据头，需要浪费http连接，所以建议使用第一种方式;
</code></pre><h6 id="禁用缓存"><a href="#禁用缓存" class="headerlink" title="禁用缓存"></a>禁用缓存</h6><pre><code>方法一：
可以在meta标签标明
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 
方法二：
也可以动态去setRequestHeader，强制不用缓存设置组合如下：
cache-control=&apos;no-cache,no-store&apos;
pragma=&apos;no-cache&apos;
if-modified-since=0;
方法三：
请求端设置if-modified-since为已经过期的某个时间，可以是几年前或者几十年前。
方法四：
服务端设置Expires为过期某个时间，例如PHP中header(&quot;Expires: Mon, 26 Jul 1997 05:00:00 GMT&quot;);
实际开发中如果需要一致性检测则尽量去配合Etag以及last-Modified去进行比较然后返回使用缓存还是新数据;这个有点偏服务器端了，不再赘述
方法五：
url后面加随机数或者时间戳url += “&amp;random=” + Math.random()这个方法js以及PHP经常用，原理就是每个请求的url都不一样这样一来缓存中找不到对应数据，就自动去服务器寻找最新资源;
</code></pre>]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现水平和垂直居中方案总结</title>
    <url>/2017/css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="已知宽高元素水平和垂直居中"><a href="#已知宽高元素水平和垂直居中" class="headerlink" title="已知宽高元素水平和垂直居中"></a>已知宽高元素水平和垂直居中</h1><h2 id="position-absolute、top和left50-和margin-height-2px-0-0-width-2px"><a href="#position-absolute、top和left50-和margin-height-2px-0-0-width-2px" class="headerlink" title="position:absolute、top和left50%和margin:-height/2px 0 0 -width/2px;"></a>position:absolute、top和left50%和margin:-height/2px 0 0 -width/2px;</h2><h3 id="html-代码"><a href="#html-代码" class="headerlink" title="html 代码"></a>html 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"> 123</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="css-代码"><a href="#css-代码" class="headerlink" title="css 代码"></a>css 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   position:absolute;</span><br><span class="line">   top:50%;</span><br><span class="line">   left:50%;</span><br><span class="line">   margin:-25px 0 0 -50px;</span><br><span class="line">   width: 100px;</span><br><span class="line">   height: 50px;</span><br><span class="line">   font-size: 40px;</span><br><span class="line">   color: #fff;</span><br><span class="line">   background-color: rgba(0,0,0,.8)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="position-fixed、top和right和bottom和left0和margin-auto"><a href="#position-fixed、top和right和bottom和left0和margin-auto" class="headerlink" title="position:fixed、top和right和bottom和left0和margin:auto;"></a>position:fixed、top和right和bottom和left0和margin:auto;</h2><h3 id="html-代码-1"><a href="#html-代码-1" class="headerlink" title="html 代码"></a>html 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"> 123</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="css代码"><a href="#css代码" class="headerlink" title="css代码"></a>css代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   position:fixed;</span><br><span class="line">   top:0;</span><br><span class="line">   right:0;</span><br><span class="line">   bottom:0;</span><br><span class="line">   left:0;</span><br><span class="line">   margin:auto;</span><br><span class="line">   width: 100px;</span><br><span class="line">   height: 50px;</span><br><span class="line">   font-size: 40px;</span><br><span class="line">   color: #fff;</span><br><span class="line">   background-color: rgba(0,0,0,.8)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="未知宽高元素水平和垂直居中"><a href="#未知宽高元素水平和垂直居中" class="headerlink" title="未知宽高元素水平和垂直居中"></a>未知宽高元素水平和垂直居中</h1><pre><code>总结一些常用的不定高宽元素居中的方式，以备使用。
以下代码均不考虑兼容性，如需使用，请自行处理浏览器兼容性。
</code></pre><h2 id="display-为-table-布局（父容器为display-table-子元素为display-table-cell-）"><a href="#display-为-table-布局（父容器为display-table-子元素为display-table-cell-）" class="headerlink" title="display 为 table 布局（父容器为display: table; 子元素为display: table-cell;）"></a>display 为 table 布局（父容器为display: table; 子元素为display: table-cell;）</h2><h3 id="html-代码-2"><a href="#html-代码-2" class="headerlink" title="html 代码"></a>html 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;  </span><br><span class="line">     &lt;span id=&quot;inner&quot;&gt;  </span><br><span class="line">      123123</span><br><span class="line">     &lt;/span&gt;  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="css-代码-1"><a href="#css-代码-1" class="headerlink" title="css 代码"></a>css 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#container&#123;  </span><br><span class="line">	display: table;  </span><br><span class="line">	padding: 60% 30%;</span><br><span class="line">	width: 100vw;</span><br><span class="line">	height: 100vh;</span><br><span class="line">	text-align: center;  </span><br><span class="line">&#125;  </span><br><span class="line">#inner&#123;  </span><br><span class="line">	display: table-cell;  </span><br><span class="line">	vertical-align: middle; </span><br><span class="line">	font-size: 40px;</span><br><span class="line">	color: #fff;</span><br><span class="line">	background-color: rgba(0, 0, 0, .8); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

PS：
水平居中一般采用两种方式:
    1.块级元素：定宽 + margin:0 auto;（由于是不定宽高，所以这里不适用）；
    2.行内元素：作用于父级元素 text-algin：center；（可以内联化，视情况而定）    
垂直方向居中：
    使用display:table-cell;vertical-algin:middle;
</code></pre><h2 id="flex-布局实现"><a href="#flex-布局实现" class="headerlink" title="flex 布局实现"></a>flex 布局实现</h2><pre><code>注意：flex 方法兼容 IE10及以上版本
</code></pre><h3 id="html-代码-3"><a href="#html-代码-3" class="headerlink" title="html 代码"></a>html 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">	&lt;span class=&quot;toast&quot;&gt;上传成功&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="css-代码-2"><a href="#css-代码-2" class="headerlink" title="css 代码"></a>css 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父容器*/</span><br><span class="line">.container &#123;</span><br><span class="line">	position: fixed;</span><br><span class="line">	width: 100vw;</span><br><span class="line">	height: 100vh;</span><br><span class="line">	display: flex;</span><br><span class="line">	justify-content: center;</span><br><span class="line">	align-items: center;</span><br><span class="line">&#125; </span><br><span class="line">/*子项目*/</span><br><span class="line">.toast &#123;</span><br><span class="line">	padding: 20px;</span><br><span class="line">	font-size: 40px;</span><br><span class="line">	color: #fff;</span><br><span class="line">	background-color: rgba(0, 0, 0, .8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

PS：display: flex; // 为父容器使用 flex 布局
    justify-content: center; // 决定子项目在主轴的对齐方式
    align-items: center; // 决定子项目在交叉轴轴的对齐方式
</code></pre><h2 id="position-transform-方法实现"><a href="#position-transform-方法实现" class="headerlink" title="position + transform 方法实现"></a>position + transform 方法实现</h2><pre><code>注意：flex 方法兼容 IE9及以上版本
</code></pre><h3 id="html-代码-4"><a href="#html-代码-4" class="headerlink" title="html 代码"></a>html 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class=&quot;toast&quot;&gt;上传成功&lt;/span&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="css-代码-3"><a href="#css-代码-3" class="headerlink" title="css 代码"></a>css 代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.toast &#123;</span><br><span class="line">	position: fixed;</span><br><span class="line">	top: 50%; // 50vh</span><br><span class="line">	left: 50%; // 50vw</span><br><span class="line">	transform: translate(-50%, -50%);</span><br><span class="line">	padding: 20px;</span><br><span class="line">	font-size: 40px;</span><br><span class="line">	color: #fff;</span><br><span class="line">	background-color: rgba(0, 0, 0, .8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

PS：对于position: fixed; 之后的 top和left都为50%，这个50%为浏览器窗口宽高的50%，
    对于transform中translate(-50%, -50%)，这个50%为自身元素的宽高的50%。
    或许上面改写成top: 50vh; left: 50vw; 更容易理解。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.tangshuang.net/3197.html" target="_blank" rel="noopener">不定元素宽高用css实现内容水平和垂直都居中</a><br>    <a href="http://jcao54.iteye.com/blog/2256953" target="_blank" rel="noopener">不定宽高div水平垂直居中</a><br>    <a href="http://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">flex 布局</a><br>    <a href="https://juejin.im/post/586b94e5ac502e12d62d4ab6" target="_blank" rel="noopener">滴滴出行-再谈自适应垂直居中</a></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDoc学习-常用示例</title>
    <url>/2017/jsDoc%E5%AD%A6%E4%B9%A0-1.html</url>
    <content><![CDATA[<h2 id="jsDoc-示例"><a href="#jsDoc-示例" class="headerlink" title="jsDoc 示例"></a>jsDoc 示例</h2><h3 id="ES-2015-Classes"><a href="#ES-2015-Classes" class="headerlink" title="ES 2015 Classes"></a>ES 2015 Classes</h3><pre><code>Documenting a simple class（文档化一个简单的类）    
    演示了如何通过一个构造函数，两个实例方法和一个静态方法文档化一个简单的类
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数</span><br><span class="line">	 * @param x</span><br><span class="line">	 * @param y</span><br><span class="line">	 */</span><br><span class="line">	constructor (x, y) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 实例方法</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getX () &#123;</span><br><span class="line">		return this.x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 实例方法</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getY () &#123;</span><br><span class="line">		return this.y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 静态方法</span><br><span class="line">	 * @param str</span><br><span class="line">	 */</span><br><span class="line">	static fromString (str) &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var de = new Point(&apos;1&apos;,&apos;2&apos;);</span><br><span class="line">console.log(de.getX()); // &apos;1&apos;</span><br></pre></td></tr></table></figure>

Extending classes（扩展类）
    当您使用 extends关键字来扩展一个现有的类的时候，你还需要告诉JSDoc哪个类是你要扩展的。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Class representing a point. */</span><br><span class="line">class Point &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数</span><br><span class="line">	 * @param x</span><br><span class="line">	 * @param y</span><br><span class="line">	 */</span><br><span class="line">	constructor (x, y) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 实例方法</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getX () &#123;</span><br><span class="line">		return this.x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 实例方法</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getY () &#123;</span><br><span class="line">		return this.y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 静态方法</span><br><span class="line">	 * @param str</span><br><span class="line">	 */</span><br><span class="line">	static fromString (str) &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/** Class representing a point</span><br><span class="line"> * @extends Point</span><br><span class="line"> */</span><br><span class="line">class Dot extends  Point &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 构造函数</span><br><span class="line">	 * @param x</span><br><span class="line">	 * @param y</span><br><span class="line">	 * @param width</span><br><span class="line">	 */</span><br><span class="line">	constructor (x, y, width) &#123;</span><br><span class="line">		super(x,y);</span><br><span class="line">		this.width = width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 实例方法</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getWidth () &#123;</span><br><span class="line">		return this.width;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dd = new Dot(1, 2, 3);</span><br><span class="line">console.log(dd.getX()); // 1</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="ES-2015-Modules"><a href="#ES-2015-Modules" class="headerlink" title="ES 2015 Modules"></a>ES 2015 Modules</h3><pre><code>Module identifiers（模块标识符）
    当你描述一个 ES 2015 module（模块）时，您将使用@module 标签来描述模块的标识符。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @module my/shirt</span><br><span class="line"> */</span><br><span class="line">import * as myShirt from &apos;my/shirt&apos;;</span><br></pre></td></tr></table></figure>

    当您使用一个 JSDoc namepath（名称路径）从另一个JSDoc注释中引用一个模块，您必须添加前缀module:。
    例如，如果你想模块my/pants的文档 连接到模块my/shirt，您可以使用@see 标签来描述my/pants。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Pants module.</span><br><span class="line"> * @module my/pants</span><br><span class="line"> * @see module:my/shirt</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

    同样，模块中每个成员的namepath （名称路径）将以module: 开始，后面跟模块名字。
    例如，如果你的my/pants模块输出一个Jeans类，并且Jeans 有一个名为hem的实例方法，
    那么这个实例方法longname（长名称）是module:my/pants.Jeans#hem。
Exported values （导出值）
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** The name of the module. */</span><br><span class="line">export const name = &apos;mixer&apos;;</span><br><span class="line"></span><br><span class="line">/** The most recent blended color. */</span><br><span class="line">export var lastColor = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Blend two colors together.</span><br><span class="line"> * @param &#123;string&#125; color1 - The first color, in hexidecimal format.</span><br><span class="line"> * @param &#123;string&#125; color2 - The second color, in hexidecimal format.</span><br><span class="line"> * @return &#123;string&#125; The blended color.</span><br><span class="line"> */</span><br><span class="line">export function blend(color1, color2) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// convert color to array of RGB values (0-255)</span><br><span class="line">function rgbify(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * Get the red, green, and blue values of a color.</span><br><span class="line">	 * @function</span><br><span class="line">	 * @param &#123;string&#125; color - A color, in hexidecimal format.</span><br><span class="line">	 * @returns &#123;Array.&lt;number&gt;&#125; An array of the red, green, and blue values,</span><br><span class="line">	 * each ranging from 0 to 255.</span><br><span class="line">	 */</span><br><span class="line">	rgbify as toRgb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="CommonJS-Modules"><a href="#CommonJS-Modules" class="headerlink" title="CommonJS Modules"></a>CommonJS Modules</h3><pre><code>Module identifiers（模块标识符）    
    例如，如果你想模块my/pants的文档 连接到模块my/shirt，您可以使用@see 标签来描述my/pants。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Pants module.</span><br><span class="line"> * @module my/pants</span><br><span class="line"> * @see module:my/shirt</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

Properties of the &apos;exports&apos; object（&apos;exports&apos;对象的属性）
    例如，方法添加到导出对象。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Shirt module.</span><br><span class="line"> * @module my/shirt</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/** Button the shirt. */</span><br><span class="line">exports.button = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Unbutton the shirt. */</span><br><span class="line">exports.unbutton = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

Values assigned to local variables （值分配给局部变量）
    例如，longname（长名称）定义在 @alias 标签中。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Shirt module.</span><br><span class="line"> * @module my/shirt</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wash the shirt.</span><br><span class="line"> * @alias module:my/shirt.wash</span><br><span class="line"> */</span><br><span class="line">var wash = exports.wash = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    例如，JSDoc注释放在exports.wash之前。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Shirt module.</span><br><span class="line"> * @module my/shirt</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var wash =</span><br><span class="line">/** Wash the shirt. */</span><br><span class="line">exports.wash = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

Values assigned to &apos;module.exports&apos; （值分配给&apos;module.exports&apos;）
    Object literal assigned to &apos;module.exports&apos;（对象字面量分配给&apos;module.exports&apos;）
    例如：对象字面量分配给&apos;module.exports&apos;。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Color mixer.</span><br><span class="line"> * @module color/mixer</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">	/** Blend two colors together. */</span><br><span class="line">	blend: function(color1, color2) &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	/** Darken a color by the given percentage. */</span><br><span class="line">	darken: function(color, percent) &#123;</span><br><span class="line">		// ..</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    例如，通过属性定义，分配给module.exports。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Color mixer.</span><br><span class="line"> * @module color/mixer</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">	/** Blend two colors together. */</span><br><span class="line">	blend: function(color1, color2) &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Darken a color by the given percentage. */</span><br><span class="line">module.exports.darken = function(color, percent) &#123;</span><br><span class="line">	// ..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    Function assigned to &apos;module.exports&apos;（函数分配给&apos;module.exports&apos;）
    例如，函数分配给&apos;module.exports&apos;。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Color mixer.</span><br><span class="line"> * @module color/mixer</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/** Blend two colors together. */</span><br><span class="line">module.exports = function(color1, color2) &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    例如，构造函数分配给&apos;module.exports&apos;。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Color mixer.</span><br><span class="line"> * @module color/mixer</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/** Create a color mixer. */</span><br><span class="line">module.exports = function ColorMixer() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    String, number, or boolean assigned to &apos;module.exports&apos;（字符串，数字，或布尔值分配给&apos;module.exports&apos;）
    例如，字符串分配给&apos;module.exports&apos;。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Module representing the word of the day.</span><br><span class="line"> * @module wotd</span><br><span class="line"> * @type &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = &apos;perniciousness&apos;;</span><br></pre></td></tr></table></figure>

    Values assigned to &apos;module.exports&apos; and local variables （值分配给&apos;module.exports&apos;和局部变量）
    例如，对象字面量分配给一个局部变量和module.export。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Color mixer.</span><br><span class="line"> * @exports color/mixer</span><br><span class="line"> */</span><br><span class="line">var mixer = module.exports = &#123;</span><br><span class="line">	/** Blend two colors together. */</span><br><span class="line">	blend: function(color1, color2) &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    Properties added to &apos;this&apos;（属性添加到&apos;this&apos;）
    例如，属性添加到一个模块的&apos;this&apos;对象。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @module bookshelf */</span><br><span class="line"></span><br><span class="line">/** @class */</span><br><span class="line">this.Book = function(title) &#123;</span><br><span class="line">	/** The title of the book. */</span><br><span class="line">	this.title = title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="AMD-Modules"><a href="#AMD-Modules" class="headerlink" title="AMD Modules"></a>AMD Modules</h3><pre><code>Module identifiers（模块标识符）
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Pants module.</span><br><span class="line"> * @module my/pants</span><br><span class="line"> * @see module:my/shirt</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

Function that returns an object literal（函数返回一个对象字面量）
    例如，函数返回一个对象字面量。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&apos;my/shirt&apos;, function() &#123;</span><br><span class="line">   /**</span><br><span class="line">	* A module representing a shirt.</span><br><span class="line">	* @exports my/shirt</span><br><span class="line">	*/</span><br><span class="line">	var shirt = &#123;</span><br><span class="line">		/** The module&apos;s `color` property. */</span><br><span class="line">		color: &apos;black&apos;,</span><br><span class="line"></span><br><span class="line">		/** @constructor */</span><br><span class="line">		Turtleneck: function(size) &#123;</span><br><span class="line">			/** The class&apos; `size` property. */</span><br><span class="line">			this.size = size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	return shirt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

Function that returns another function（函数返回另一个函数）
    例如，函数返回另一个函数。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A module representing a jacket.</span><br><span class="line"> * @module my/jacket</span><br><span class="line"> */</span><br><span class="line">define(&apos;my/jacket&apos;, function() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @constructor</span><br><span class="line">	 * @alias module:my/jacket</span><br><span class="line">	 */</span><br><span class="line">	var Jacket = function() &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/** Zip up the jacket. */</span><br><span class="line">	Jacket.prototype.zip = function() &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	return Jacket;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

Module declared in a return statement （模块声明在return语句中）
    例如，模块声明在return语句中。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Module representing a shirt.</span><br><span class="line"> * @module my/shirt</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">define(&apos;my/shirt&apos;, function() &#123;</span><br><span class="line">	// Do setup work here.</span><br><span class="line"></span><br><span class="line">	return /** @alias module:my/shirt */ &#123;</span><br><span class="line">		/** Color. */</span><br><span class="line">		color: &apos;black&apos;,</span><br><span class="line">		/** Size. */</span><br><span class="line">		size: &apos;unisize&apos;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

Module object passed to a function（模块对象传递给一个函数）
    例如，模块对象传递给一个函数。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&apos;my/jacket&apos;, function(</span><br><span class="line">	/**</span><br><span class="line">	 * Utility functions for jackets.</span><br><span class="line">	 * @exports my/jacket</span><br><span class="line">	 */</span><br><span class="line">	module) &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Zip up a jacket.</span><br><span class="line">	 * @param &#123;Jacket&#125; jacket - The jacket to zip up.</span><br><span class="line">	 */</span><br><span class="line">	module.zip = function(jacket) &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

Multiple modules defined in one file（多模块定义在一个文件中）
    例如，多模块定义在一个文件中。
    ```
    // one module
    define(&apos;html/utils&apos;, function() {
        /**
         * Utility functions to ease working with DOM elements.
         * @exports html/utils
         */
        var utils = {
            /** Get the value of a property on an element. */
            getStyleProperty: function(element, propertyName) { }
        };

        /** Determine if an element is in the document head. */
        utils.isInHead = function(element) { }

        return utils;
        }
    );

    // another module
    define(&apos;tag&apos;, function() {
        /** @exports tag */
        var tag = {
            /** @class */
            Tag: function(tagName) {
                // ...
            }
        };

        return tag;
    });
    ```        
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="noopener">jsDoc文档</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础知识学习</title>
    <url>/2017/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="常用指令介绍"><a href="#常用指令介绍" class="headerlink" title="常用指令介绍"></a>常用指令介绍</h1><p>javac HelloWorld.java – 该命令用于将 java 源文件编译为 class 字节码文件，如： javac HelloWorld.java。如果成功编译没有错误的话，会出现一个 HelloWorld.class 的文件。<br>java HelloWorld – java 后面跟着的是java文件中的类名,例如 HelloWorld 就是类名，如: java HelloWorld。</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>JAVA_HOME：JDK安装在C:\jdk1.6.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串<br>path 变量：path 变量使得我们能够在系统中的任何地方运行java应用程序，比如 javac、java、javah 等等,这就要找到我们安装 JDK 的目录，假设我们的JDK安装在 C:\jdk1.6.0 目录下,那么在 C:\jdk1.6.0\bin 目录下就是我们常用的 java 应用程序,我们就需要把 C:\jdk1.6.0\bin 这个目录加到 path 环境变量里面。<br>classpath 变量：classpath 环境变量，是当我们在开发java程序时需要引用别人写好的类时，要让 java 解释器知道到哪里去找这个类。通常，sun 为我们提供了一些额外的丰富的类包，一个是 dt.jar，一个是 tools.jar，这两个 jar 包都位于 C:\jdk1.6.0\lib 目录下，所以通常我们都会把这两个 jar 包加到我们的 classpath 环境变量中 set classpath=.;C:\jdk1.6.0\lib\tools.jar;C:\jdk1.6.0\lib\dt.jar。    </p>
<h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><p>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>类：类是一个模板，它描述一类对象的行为和状态。<br>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。<br>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。<br>类名：对于所有的类来说，都使用大驼峰。<br>方法名：所有的方法名都应该使用小驼峰。<br>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。<br>主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。</p>
<h2 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h2><p>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。<br>跟其他语言类似。</p>
<h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><p>Java可以使用修饰符来修饰类中方法和属性。<br>访问控制修饰符 : default, public , protected, private<br>非访问控制修饰符 : final, abstract, strictfp</p>
<h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><p>局部变量<br>类变量（静态变量）<br>成员变量（非静态变量）</p>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>数组是储存在堆上的对象，可以保存多个同类型变量。<br>这里有别于js的数组，同类型限制。</p>
<h2 id="Java枚举"><a href="#Java枚举" class="headerlink" title="Java枚举"></a>Java枚举</h2><p>枚举限制变量只能是预先设定好的值。<br>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p>
<h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>这些保留字不能用于常量、变量、和任何标识符的名称。<br>跟其他语言类似。</p>
<h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><p>单行 //<br>多行 /**/</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。<br>被继承的类称为超类（super class），派生类称为子类（subclass）。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Java中，接口可理解为对象间相互通信的协议。<br>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h1 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h1><p>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br>类：类是一个模板，它描述一类对象的行为和状态。</p>
<h2 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Dog&#123;</span><br><span class="line">  String breed; // 成员变量</span><br><span class="line">  int age;</span><br><span class="line">  String color;</span><br><span class="line">  </span><br><span class="line">  // 构造方法</span><br><span class="line">  public Dog(String name)&#123;</span><br><span class="line">       // 这个构造器仅有一个参数：name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 入口函数</span><br><span class="line">  public static void main(String []args)&#123;</span><br><span class="line">	// 下面的语句将创建一个Dog对象</span><br><span class="line">	Dog myDog = new Dog( &quot;tommy&quot; );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Static demo; // 类变量</span><br><span class="line">  void barking()&#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  void hungry()&#123;</span><br><span class="line">	String dd; // 局部变量</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  void sleeping()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。<br>成员变量：成员变量是定义在类中，方法体之外的变量。<br>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的名称必须与类同名，一个类可以有多个构造方法。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Dog(String name)&#123;</span><br><span class="line">     // 这个构造器仅有一个参数：name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">muDog = new Dog();</span><br><span class="line">/* 访问类中的变量 */</span><br><span class="line">muDog.breed;</span><br><span class="line">/* 访问类中的方法 */</span><br><span class="line">muDog.hungry();</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h2><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。<br>    一个源文件中只能有一个public类<br>    一个源文件可以有多个非public类<br>    源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。<br>    如果一个类定义在某个包中，那么package语句应该在源文件的首行。<br>    如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。<br>    import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>
<h2 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h2><p>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>
<h2 id="Import语句"><a href="#Import语句" class="headerlink" title="Import语句"></a>Import语句</h2><p>Import语句用来提供一个合理的路径，使得编译器可以找到某个类。<br>例如，下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类 import java.io.*;</p>
<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。<br>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。<br>Java 的两大数据类型:<br>    内置数据类型<br>    引用数据类型</p>
<h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>    范围：-128（-2^7） 到 127（2^7-1）；<br>    byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>    例子：byte a = 100，byte b = -50。</p>
<h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>    范围：-32768（-2^15） 到 32767（2^15 - 1）；<br>    Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>    例子：short s = 1000，short r = -20000。</p>
<h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>    范围：-2,147,483,648（-2^31） 到 2,147,483,647（2^31 - 1）；<br>    一般地整型变量默认为 int 类型；<br>    例子：int a = 100000, int b = -200000。</p>
<h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>    范围：-9,223,372,036,854,775,808（-2^63） 到 9,223,372,036,854,775,807（2^63 -1）；<br>    这种类型主要使用在需要比较大整数的系统上；<br>    例子： long a = 100000L，Long b = -200000L。</p>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>    float 在储存大型浮点数组的时候可节省内存空间；<br>    浮点数不能用来表示精确的值，如货币；<br>    例子：float f1 = 234.5f。</p>
<h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>    浮点数的默认类型为double类型；<br>    double类型同样不能表示精确的值，如货币；<br>    例子：double d1 = 123.4d 或者 123.4。</p>
<h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>boolean数据类型表示一位的信息；<br>    只有两个取值：true 和 false；<br>    默认值是 false；<br>    例子：boolean one = true。</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>char类型是一个单一的 16 位 Unicode 字符；<br>    范围：\u0000（即为0） 到 \uffff（即为65,535）；<br>    char 数据类型可以储存任何字符；<br>    例子：char letter = ‘A’;。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><pre><code>对象、数组都是引用数据类型。
所有引用类型的默认值都是null。
一个引用变量可以用来引用任何与之兼容的类型。
例子：Site site = new Site(&quot;Runoob&quot;)。
</code></pre><h2 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h2><p>常量在程序运行时是不能被修改的。<br>    在 Java 中使用 final 关键字来修饰常量。<br>    final double PI = 3.1415927;</p>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>转换从低级到高级。<br>低  ————————————&gt;  高<br>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double     </p>
<h2 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。<br>强制类型转换</p>
<pre><code>1. 条件是转换的数据类型必须是兼容的。
2. 格式：(type)value type是要强制类型转换后的数据类型。        
</code></pre><p>隐含强制类型转换    </p>
<pre><code>1. 整数的默认类型是 int。
2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。
</code></pre><h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的变量在使用前必须声明。<br>    声明格式：type identifier [ = value][, identifier [= value] …] ;<br>Java语言支持的变量类型有：<br>    类变量：独立于方法之外的变量，用 static 修饰。<br>    实例变量：独立于方法之外的变量，不过没有 static 修饰。<br>    局部变量：类的方法中的变量。</p>
<h2 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h2><pre><code>局部变量声明在方法、构造方法或者语句块中；
局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
访问修饰符不能用于局部变量；
局部变量只在声明它的方法、构造方法或者语句块中可见；
局部变量是在栈上分配的。
局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。
</code></pre><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p>实例变量声明在一个类中，但在方法、构造方法和语句块之外；<br>当一个对象被实例化之后，每个实例变量的值就跟着确定；<br>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；<br>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；<br>实例变量可以声明在使用前或者使用后；<br>访问修饰符可以修饰实例变量；<br>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；<br>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；<br>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这个实例变量对子类可见</span><br><span class="line">public String name;</span><br><span class="line">// 私有变量，仅在该类可见</span><br><span class="line">private double salary;</span><br></pre></td></tr></table></figure></p>
<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。<br>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。<br>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。<br>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。<br>静态变量在程序开始时创建，在程序结束时销毁。<br>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。<br>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。<br>静态变量可以通过：ClassName.VariableName的方式访问。<br>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</p>
<h1 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h1><p>Java语言提供了很多修饰符，主要分为以下两类：<br>    访问修饰符<br>    非访问修饰符</p>
<h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Javav支持 4 种不同的访问权限。<br>    权限有4中：当前类、同一包内、子孙类、其他包<br>    public : 对所有类可见。使用对象：类、接口、变量、方法。<br>    protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>    default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>    private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>访问控制和继承<br>    父类中声明为 public 的方法在子类中也必须为 public。<br>    父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。<br>    父类中声明为 private 的方法，不能够被继承。</p>
<h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>static 修饰符，用来修饰类方法和类变量。<br>final final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>    类中的 final 方法可以被子类继承，但是不能被子类修改。<br>abstract 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>    抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>synchronized 关键字声明的方法同一时间只能被一个线程访问。<br>transient 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>volatile volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><pre><code>算术运算符
关系运算符
位运算符
逻辑运算符
赋值运算符
其他运算符
instanceof 运算符
    该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。
    ( Object reference variable ) instanceof  (class/interface type)
类别    操作符    关联性
后缀    () [] . (点操作符)    左到右
一元    ++ -- ！~    从右到左
乘性     * /％    左到右
加性     + -    左到右
移位     &gt;&gt; &gt;&gt;&gt;  &lt;&lt;     左到右
关系     &gt;&gt; = &lt;&lt; =     左到右
相等     ==  !=    左到右
按位与    ＆    左到右
按位异或    ^    左到右
按位或    |    左到右
逻辑与    &amp;&amp;    左到右
逻辑或    | |    左到右
条件    ？：    从右到左
赋值    = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =    从右到左
逗号    ，    左到右
</code></pre><p>注：只有一元、条件（三目）、赋值运算符关联性为从右向左，其余全是从左向右    </p>
<h1 id="Java-循环结构"><a href="#Java-循环结构" class="headerlink" title="Java 循环结构"></a>Java 循环结构</h1><pre><code>while 循环
do…while 循环
    对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。
    do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。
for 循环
Java 增强 for 循环（对于数组）
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(声明语句 : 表达式)</span><br><span class="line">&#123;</span><br><span class="line">   //代码句子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

break 关键字
    break 主要用在循环语句或者 switch 语句中。
    break 在循环语句中作用是跳出本层（并非本次）的循环。
    break 在switch语句中作用是跳出该switch语句体。
continue 关键字
    continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。
    在 for 循环中，continue 语句使程序立即跳转到更新语句i++。
    在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。
return 关键字
    返回数据给函数的调用者。
    函数一旦执行到了return关键字，那么该函数马上结束。 (能结束一个函数)
</code></pre><h1 id="Java-分支结构"><a href="#Java-分支结构" class="headerlink" title="Java 分支结构"></a>Java 分支结构</h1><pre><code>if 语句
switch 语句
</code></pre><h1 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h1><p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。<br>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。    </p>
<h2 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。<br>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。<br>    <a href="http://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">Number &amp; Math 类方法</a></p>
<h1 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h1><p>Character 类用于对单个字符进行操作。<br>Character 类在对象中包装一个基本类型 char 的值    </p>
<h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。<br>    <a href="http://www.runoob.com/java/java-character.html" target="_blank" rel="noopener">Character 类方法</a></p>
<h1 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h1><p>字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。<br>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。<br>如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</p>
<h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><pre><code>String greeting = &quot;fanerge&quot;;
</code></pre><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><pre><code>int len = greeting.length();
</code></pre><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p>string1.concat(string2);<br>    <a href="http://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">String 类方法</a></p>
<h1 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h1><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。<br>    <a href="http://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">StringBuffer 和 StringBuilder 类方法</a></p>
<h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>格式：dataType[] arrayRefVar;   // 首选的方法<br>    dataType arrayRefVar[];  // 效果相同，但不是首选方法<br>实例：double[] myList; // 声明一个为double类型的数组    </p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><pre><code>arrayRefVar = new dataType[arraySize];
</code></pre><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：<br>    dataType[] arrayRefVar = new dataType[arraySize];</p>
<h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>循环处理 for<br>foreach 循环<br>    <a href="http://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">Array类方法</a>    </p>
<h1 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h1><p>Date 类<br>    <a href="http://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">Date类方法</a><br>    Calendar类<br>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。<br>    GregorianCalendar类<br>    Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p>
<h1 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h1><p>java正则在java.util.regex包中<br>Pattern 类：<br>    pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。<br>Matcher 类：<br>    Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。<br>PatternSyntaxException：<br>    PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。    </p>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><pre><code>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。    
</code></pre><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">正则方法</a></p>
<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><pre><code>修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
</code></pre><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><pre><code>注：main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。    
</code></pre><p>void 关键字<br>方法的重载<br>    创建另一个有相同名字但参数不同的方法 – 方法的重载<br>    就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。<br>变量作用域<br>    变量的范围是程序中该变量可以被引用的部分。<br>    方法的参数范围涵盖整个方法。参数实际上是一个局部变量。<br>    for循环的初始化部分声明的变量，其作用范围在整个循环。<br>    但循环体内声明的变量其适用范围是从它声明到循环体结束。<br>命令行参数的使用<br>构造方法<br>    构造方法和它所在类的名字相同，但构造方法没有返回值。（可不写）<br>可变参数<br>    语法：typeName… parameterName<br>finalize() 方法<br>    Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。<br>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p>
<h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><pre><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int read( ) throws IOException
</code></pre><h2 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h2><pre><code>String readLine( ) throws IOException
</code></pre><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。<br>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>FileInputStream<br>    该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>FileOutputStream<br>    该类用来创建一个文件并向文件中写数据。    </p>
<h2 id="文件和I-O"><a href="#文件和I-O" class="headerlink" title="文件和I/O"></a>文件和I/O</h2><pre><code>File Class(类)
FileReader Class(类)
FileWriter Class(类)
</code></pre><h2 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h2><p>创建目录：<br>    mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。<br>    mkdirs()方法创建一个文件夹和它的所有父文件夹。<br>读取目录：<br>    一个目录其实就是一个 File 对象，它包含其他文件和文件夹。<br>删除目录或文件<br>    删除文件可以使用 java.io.File.delete() 方法。</p>
<h1 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h1><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。<br>    通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据<br>next() 与 nextLine() 区别<br>next():<br>    1、一定要读取到有效字符后才可以结束输入。<br>    2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>    3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。<br>nextLine()：<br>    1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>    2、可以获得空白。</p>
<h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>异常发生的原因有很多，通常包含以下几大类：<br>    用户输入了非法数据。<br>    要打开的文件不存在。<br>    网络通信时连接中断，或者JVM内存溢出。<br>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：<br>    检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。<br>    运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。<br>    错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p>
<h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><pre><code>异常类有两个主要的子类：IOException 类和 RuntimeException 类。
</code></pre><h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h2 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h2><h2 id="throws-throw-关键字"><a href="#throws-throw-关键字" class="headerlink" title="throws/throw 关键字"></a>throws/throw 关键字</h2><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><h2 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><p>子类拥有父类非private的属性，方法。<br>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。<br>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。<br>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</p>
<h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object</p>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class C implements A,B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><pre><code>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
this关键字：指向自己的引用。
</code></pre><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><pre><code>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：
声明类：
    final class 类名 {//类体}
声明方法：
    修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}
</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。</p>
<h1 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h1><h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h2><pre><code>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。
</code></pre><h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><p>参数列表必须完全与被重写方法的相同；<br>返回类型必须完全与被重写方法的返回类型相同；<br>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。<br>父类的成员方法只能被它的子类重写。<br>声明为final的方法不能被重写。<br>声明为static的方法不能被重写，但是能够被再次声明。<br>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。<br>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。<br>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。<br>构造方法不能被重写。<br>如果不能继承一个方法，则不能重写这个方法。</p>
<h3 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h3><pre><code>当需要在子类中调用父类的被重写方法时，要使用super关键字。
</code></pre><h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<h1 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h1><p>多态是同一个行为具有多个不同表现形式或形态的能力。    </p>
<h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><pre><code>继承
重写
父类引用指向子类对象
    Parent p = new Child();
</code></pre><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><pre><code>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。
要想调用父类中被重写的方法，则必须使用关键字super。
</code></pre><h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><p>方式一：重写：<br>    这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。<br>方式二：接口</p>
<ol>
<li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li>
<li><p>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。<br>方式三：抽象类和抽象方法<br> 详情请看 Java抽象类 章节。</p>
<h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p> 在Java语言中使用abstract class来定义抽象类。</p>
<h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p> 尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从 Employee 类继承7个成员方法，且通过该方法可以设置或获取三个成员变量。</p>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p> 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。<br> Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br> 声明抽象方法会造成以下两个结果：</p>
<pre><code>如果一个类包含抽象方法，那么该类必须是抽象类。
任何子类必须重写父类的抽象方法，或者声明自身为抽象类。
</code></pre><h1 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a>Java 封装</h1><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。<br>要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。<br>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<h2 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h2><p>.     修改属性的可见性来限制对属性的访问（一般限制为private）<br>.     对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问getter和setter方法<br>.    采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p>
<h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>[可见度] interface 接口名称 [extends 其他的类名] {</p>
<pre><code>// 声明变量
// 抽象方法
</code></pre><p> }</p>
<h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p> class Cat implements 接口名称[, 其他接口, 其他接口…, …] …</p>
<h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p> 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>
<h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p> public interface Hockey extends Sports, Event</p>
<h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p> 最常用的继承接口是没有包含任何方法的接口。<br> 标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br> 标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<h1 id="Java-包-package"><a href="#Java-包-package" class="headerlink" title="Java 包(package)"></a>Java 包(package)</h1><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。<br>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。<br>语法：package pkg1[．pkg2[．pkg3…]];<br> 例如,一个Something.java 文件它的内容<br> package net.java.util<br> public class Something{</p>
<pre><code>...
</code></pre><p> }<br> 那么它的路径应该是 net/java/util/Something.java 这样保存的。</p>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p> 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。<br> 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。<br> 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p>
<h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p> 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。<br> 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条<br>语法：import package1[.package2…].(classname|<em>);<br> 用 import 关键字引入，使用通配符 “</em>“  import payroll.*;</p>
<h2 id="package-的目录结构"><a href="#package-的目录结构" class="headerlink" title="package 的目录结构"></a>package 的目录结构</h2><p> 1.创建 vehicle 目录<br> 2.在目录中新建 Car.java</p>
<pre><code>// 文件名 :  Car.java
package vehicle;

public class Car {
   // 类实现  
}
</code></pre><h2 id="设置-CLASSPATH-系统变量"><a href="#设置-CLASSPATH-系统变量" class="headerlink" title="设置 CLASSPATH 系统变量"></a>设置 CLASSPATH 系统变量</h2><p> 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。<br>用下面的命令显示当前的CLASSPATH变量：<br> Windows 平台（DOS 命令行下）：C:> set CLASSPATH<br> UNIX 平台（Bourne shell 下）：# echo $CLASSPATH<br>删除当前CLASSPATH变量内容：<br> Windows 平台（DOS 命令行下）：C:> set CLASSPATH=<br> UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH<br>设置CLASSPATH变量:<br> Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes<br> UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDoc学习-标签1</title>
    <url>/2017/jsDoc%E5%AD%A6%E4%B9%A0-2.html</url>
    <content><![CDATA[<p>块标签（Block Tags）</p>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="@abstract"></a>@abstract</h3><pre><code>该成员（一般指父类的方法）必须在继承的子类中实现（或重写）。
别名：@virtual
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 奶制品</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function DairyProduct () &#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * 检查奶制品的状态</span><br><span class="line"> * @abstract</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">DairyProduct.prototype.isSolid = function () &#123;</span><br><span class="line">  throw new Error(&apos;must be implemented by subclass!&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 牛奶</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function Milk () &#123;&#125;</span><br><span class="line">Milk.prototype = new DairyProduct();</span><br><span class="line">// 这里重写了父类的isSolid方法</span><br><span class="line">Milk.prototype.isSolid = function () &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;;</span><br><span class="line">var dd = new Milk();</span><br><span class="line">console.log(dd.isSolid()); // false</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="access"><a href="#access" class="headerlink" title="@access"></a>@access</h3><pre><code>指定该成员的访问级别（私有 private，公共 public，或保护 protected）
语法：@access &lt;private|protected|public&gt;
    @access private 等价于 @private;
    @access protected 等价于 @protected;
    @access public 等价于 @public;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function Thingy () &#123;</span><br><span class="line">	/** @access private */</span><br><span class="line">	var foo = 0;</span><br><span class="line">	/** @access protected */</span><br><span class="line">	this._bar = 1;</span><br><span class="line">	/** @access public */</span><br><span class="line">	this.pez = 2;</span><br><span class="line">&#125;</span><br><span class="line">OR</span><br><span class="line">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function Thingy () &#123;</span><br><span class="line">	/** @private */</span><br><span class="line">	var foo = 0;</span><br><span class="line">	/** @protected */</span><br><span class="line">	this._bar = 1;</span><br><span class="line">	/** @public */</span><br><span class="line">	this.pez = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><pre><code>标记成员有一个别名
语法：@alias &lt;aliasNamepath&gt;
例如，匿名的构造函数使用@alias。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Klass(&apos;trackr.CookieManager&apos;,</span><br><span class="line">	/**</span><br><span class="line">	 * 匿名函数</span><br><span class="line">	 * @alias trackr.CookieManager</span><br><span class="line">	 * @param kv</span><br><span class="line">	 */</span><br><span class="line">	function (kv) &#123;</span><br><span class="line">		/** trackr.CookieManager＃value */</span><br><span class="line">		this.value = kv;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

您也可以在一个立即调用的函数表达式（IIFE）中创建的成员中使用@alias标签。
@alias标签告诉JSDoc，这些成员都暴露在IIFE作用域之外的。
例如，命名空间的静态方法使用@alias。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @namespace */</span><br><span class="line">var Apple = &#123;&#125;;</span><br><span class="line">(function (ns) &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @namespace</span><br><span class="line">	 * @alias Apple.Core</span><br><span class="line">	 */</span><br><span class="line">	var core = &#123;&#125;;</span><br><span class="line">	/** Documented as Apple.Core.seed */</span><br><span class="line">	core.speed = function () &#123;&#125;;</span><br><span class="line">	ns.Core = core;</span><br><span class="line">&#125;)(Apple);</span><br></pre></td></tr></table></figure>

对于那些对象字面量中定义的成员，可以使用@alias标签替代的@lends标记。
例如，对象常量使用@alias。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Documenting objectA with @alias</span><br><span class="line">var objectA = (function() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * Documented as objectA</span><br><span class="line">	 * @alias objectA</span><br><span class="line">	 * @namespace</span><br><span class="line">	 */</span><br><span class="line">	 /** @lends objectA */</span><br><span class="line">	var x = &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * Documented as objectA.myProperty</span><br><span class="line">		 * @member</span><br><span class="line">		 */</span><br><span class="line">		myProperty: &apos;foo&apos;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	return x;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="auguments"><a href="#auguments" class="headerlink" title="@auguments"></a>@auguments</h3><pre><code>@augments or@extends标签指明标识符继承自哪个父类，后面需要加父类名。
你可以使用这个标签来记录基于类和并基于原型的继承。
别名：@extends
语法：@auguments &lt;namepath&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动物</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function Animal () &#123;</span><br><span class="line">	this.alive = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 鸭子</span><br><span class="line"> * @constructor</span><br><span class="line"> * @auguments Animal</span><br><span class="line"> */</span><br><span class="line">function Duck () &#123;&#125;</span><br><span class="line">Duck.prototype = new Animal();</span><br><span class="line">Duck.prototype.speak = function () &#123;</span><br><span class="line">	if (this.alive) &#123;</span><br><span class="line">		alert(&apos;Quack!&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var d = new Duck();</span><br><span class="line">d.speak();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="author"><a href="#author" class="headerlink" title="@author"></a>@author</h3><pre><code>@author标签标识一个项目的作者。
语法：@author &lt;name&gt; [&lt;emailAddress&gt;]
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author fanerge &lt;fanerge@qq.com&gt;</span><br><span class="line">*/</span><br><span class="line">function MyClass () &#123;&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="borrows"><a href="#borrows" class="headerlink" title="@borrows"></a>@borrows</h3><pre><code>@borrows标签允许您将另一个标识符的描述添加到你的当前描述。
语法：@borrows &lt;that namepath&gt; as &lt;this namepath&gt;
在这个例子中，&quot;trstr&quot;函数存在文档，但&quot;util.trim&quot;只是使用不同的名称引用相同的功能。
例如，复制trstr的文档描述给util.trim。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @namespace</span><br><span class="line"> * @borrows trstr as trim</span><br><span class="line"> */</span><br><span class="line">var util = &#123;</span><br><span class="line">	trim: trstr</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Remove whitespace from around a string.</span><br><span class="line"> * @param &#123;string&#125; str</span><br><span class="line"> */</span><br><span class="line">function trstr(str) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="callback"><a href="#callback" class="headerlink" title="@callback"></a>@callback</h3><pre><code>描述一个回调函数。@Callback标签提供回调函数（可传递给其他函数）的描述，包括回调的参数和返回值。
你可以包涵任何一个你能提供给@method标签。
语法：@callback &lt;namepath&gt;
例如,描述一个指定类回调。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @class</span><br><span class="line"> */</span><br><span class="line">function Requester() &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Send a request.</span><br><span class="line"> * @param &#123;Requester~requestCallback&#125; cb - The callback that handles the response.</span><br><span class="line"> */</span><br><span class="line">Requester.prototype.send = function(cb) &#123;</span><br><span class="line">	// code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This callback is displayed as part of the Requester class.</span><br><span class="line"> * @callback Requester~requestCallback</span><br><span class="line"> * @param &#123;number&#125; responseCode</span><br><span class="line"> * @param &#123;string&#125; responseMessage</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h3><pre><code>@class标签标明函数是一个构造器函数，意味着需要使用 new 关键字来返回一个实例，即使用 new 关键字实例化。
别名：@constructor
语法：@class [&lt;type&gt; &lt;name&gt;]
例如，一个函数构建一个Person实例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建一个人</span><br><span class="line"> * @class</span><br><span class="line"> */</span><br><span class="line">function Person () &#123;&#125;</span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="classdesc"><a href="#classdesc" class="headerlink" title="@classdesc"></a>@classdesc</h3><pre><code>@classdesc标签用于为类提供一个描述，这样和构造函数的描述区分开来。
@classdesc标签应该与 @class (或 @constructor)标签结合使用。
语法：@classdesc &lt;some description&gt;
如下所示，一个类有两个添加描述的地方，一个适用于函数本身，而另一个一般适用于类。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This is a description of the MyClass constructor function.</span><br><span class="line"> * @class</span><br><span class="line"> * @classdesc This is a description of the MyClass class.</span><br><span class="line"> */</span><br><span class="line">function MyClass() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="constant"><a href="#constant" class="headerlink" title="@constant"></a>@constant</h3><pre><code>@constant 标签指明这个对象是一个常量。
语法：@constant [&lt;type&gt; &lt;name&gt;]    
例如，一个字符串常量表示红色。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @constant</span><br><span class="line">	@type &#123;string&#125;</span><br><span class="line">	@default</span><br><span class="line">*/</span><br><span class="line">const RED = &apos;FF0000&apos;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="constructs"><a href="#constructs" class="headerlink" title="@constructs"></a>@constructs</h3><pre><code>当使用对象字面量形式定义类（例如使用@lends标签）时，可使用@constructs标签标明这个函数用来作为类的构造实例。
语法：＠constructs [name]
例如， @constructs 和 @lends 结合使用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person = makeClass(</span><br><span class="line">   /** @lends Person.prototype */</span><br><span class="line">   &#123;</span><br><span class="line">       /**</span><br><span class="line">        * @constructs</span><br><span class="line">        * @param name</span><br><span class="line">        */</span><br><span class="line">       initialize: function (name) &#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">       &#125;,</span><br><span class="line">       /**</span><br><span class="line">        * @param msg</span><br><span class="line">        * @returns &#123;*&#125;</span><br><span class="line">        */</span><br><span class="line">       say: function (msg) &#123;</span><br><span class="line">           return `$&#123;this.name&#125;says:$&#123;msg&#125;`;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="copyright"><a href="#copyright" class="headerlink" title="@copyright"></a>@copyright</h3><pre><code>@copyright标签是用来描述一个文件的版权信息。一般和@file 标签结合使用。
语法：@copyright &lt;some copyright text&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @file this is javascript</span><br><span class="line">* @copyright fanerge 2017</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="default"><a href="#default" class="headerlink" title="@default"></a>@default</h3><pre><code>@default标签可以让你记录标识的赋值。
可以在标签后面跟上他的值，或者当值是一个唯一被分配的简单值(可以是：一个字符串，数字，布尔值或null)的时候，你可以让JSDoc从源代码中获取值，自动记录 。
别名：defaultvalue
语法：@default [&lt;some value&gt;]
在本实例中,一个常量被记录。该常数的值为0xff0000。通过添加@default标签，这个值将自动添加到文档。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @constant</span><br><span class="line">* @default</span><br><span class="line">*/</span><br><span class="line">const RED = &apos;0xff0000&apos;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="deprecated"><a href="#deprecated" class="headerlink" title="@deprecated"></a>@deprecated</h3><pre><code>@deprecated 标签指明一个标识在你代码中已经被弃用。
语法：@deprecated [&lt;some text&gt;]
例如，描述一个old函数从2.0版本开始已经被弃用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @deprecated since version 2.0</span><br><span class="line">*/</span><br><span class="line">function old () &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="description"><a href="#description" class="headerlink" title="@description"></a>@description</h3><pre><code>@description标签允许您提供一般描述。
该说明可能包括HTML标签。如果Markdown 插件启用的话，它也可包括Markdown格式。
别名：@desc
语法：@description &lt;some description&gt;
例如，不用@description标签描述一个标识
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add two numbers.</span><br><span class="line"> * @param &#123;number&#125; a</span><br><span class="line"> * @param &#123;number&#125; b</span><br><span class="line"> * @returns &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

例如，用@description标签描述一个标识
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; a</span><br><span class="line"> * @param &#123;number&#125; b</span><br><span class="line"> * @returns &#123;number&#125;</span><br><span class="line"> * @description Add two numbers.</span><br><span class="line"> */</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="enum"><a href="#enum" class="headerlink" title="@enum"></a>@enum</h3><pre><code>@enum标签描述一个静态属性值的全部相同的集合。
枚举类似一个属性的集合，除了枚举自己的描述注释之外，属性都记录在容器内部的注释中。
通常这种标签是与@ReadOnly结合使用，作为一个枚举通常表示常量的集合。
语法：@enum [&lt;type&gt;]
例如，一个数字枚举，表示的3种状态
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Enum for tri-state values.</span><br><span class="line"> * @readonly</span><br><span class="line"> * @enum &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var triState = &#123;</span><br><span class="line">	/** The true value */</span><br><span class="line">	TRUE: 1,</span><br><span class="line">	FALSE: -1,</span><br><span class="line">	/** @type &#123;boolean&#125; */</span><br><span class="line">	MAYBE: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="event"><a href="#event" class="headerlink" title="@event"></a>@event</h3><pre><code>描述一个事件。@event标签允许您描述一个可触发的事件，一个典型的事件是由对象定义的一组属性来表示。
标签来定义事件的具体类型，您可以使用@fires标记，以表明这个种方法可以触发该事件。
你还可以使用@listens标签，以指示表明用这个表示来侦听该事件。    
语法：@event &lt;className&gt;#[event:]&lt;eventName&gt;
例如，描述一个作为事件的行数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Throw a snowball.</span><br><span class="line"> *</span><br><span class="line"> * @fires Hurl#snowball</span><br><span class="line"> */</span><br><span class="line">Hurl.prototype.snowball = function() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * Snowball event.</span><br><span class="line">	 *</span><br><span class="line">	 * @event Hurl#snowball</span><br><span class="line">	 * @type &#123;object&#125;</span><br><span class="line">	 * @property &#123;boolean&#125; isPacked - Indicates whether the snowball is tightly packed.</span><br><span class="line">	 */</span><br><span class="line">	this.emit(&apos;snowball&apos;, &#123;</span><br><span class="line">		isPacked: this._snowball.isPacked</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="example"><a href="#example" class="headerlink" title="@example"></a>@example</h3><pre><code>提供一个如何使用描述项的例子。跟随此标签的文字将显示为高亮代码。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Solves equations of the form a * x = b</span><br><span class="line"> * @example</span><br><span class="line"> * // returns 2</span><br><span class="line"> * globalNS.method1(5, 10);</span><br><span class="line"> * @example</span><br><span class="line"> * // returns 3</span><br><span class="line"> * globalNS.method(5, 15);</span><br><span class="line"> * @returns &#123;Number&#125; Returns the value of x for the equation.</span><br><span class="line"> */</span><br><span class="line">globalNS.method1 = function (a, b) &#123;</span><br><span class="line">	return b / a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="exports"><a href="#exports" class="headerlink" title="@exports"></a>@exports</h3><pre><code>@exports标签描述由JavaScript模块的exports或module.exports属性导出的任何内容。
语法：@exports &lt;moduleName&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A module that says hello!</span><br><span class="line"> * @module hello/world</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/** Say hello. */</span><br><span class="line">exports.sayHello = function() &#123;</span><br><span class="line">	return &apos;Hello world&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="external"><a href="#external" class="headerlink" title="@external"></a>@external</h3><pre><code>@external标签用来标识一个在当前包外部定义的类，命名空间，或模块。
通过使用这个标签，你可以描述你的包的外部标识的扩展，或者您也可以提供关于 外部标识的相关信息给你的包的使用者。
你也可以在任何其他JSDoc标签中引用外部标识的namepath（名称路径）。
外部标识引用的路径名 始终需要使用external:前缀：（例如{@link external:Foo}或@augments external:Foo）。 但是，你可以省略@external标记的这个前缀。
别名：@host
下面的示例演示如何描述内置的String对象作为external，新的实例方法external:String#rot13
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The built in string object.</span><br><span class="line"> * @external String</span><br><span class="line"> * @see &#123;@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Create a ROT13-encoded version of the string. Added by the `foo` package.</span><br><span class="line"> * @function external:String#rot13</span><br><span class="line"> * @example</span><br><span class="line"> * var greeting = new String(&apos;hello world&apos;);</span><br><span class="line"> * console.log( greeting.rot13() ); // uryyb jbeyq</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="noopener">jsDoc文档</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDoc学习-标签2</title>
    <url>/2017/jsDoc%E5%AD%A6%E4%B9%A0-3.html</url>
    <content><![CDATA[<h3 id="file"><a href="#file" class="headerlink" title="@file"></a>@file</h3><pre><code>@file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。
别名：@fileoverview  @overview
例如，文件描述
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file 这是正则js文件</span><br><span class="line"> * @author fanerge &lt;fanerge@example.com&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="fires"><a href="#fires" class="headerlink" title="@fires"></a>@fires</h3><pre><code>@fires标签标明当一个方法被调用时将触发一个指定类型的事件，使用@event 标签来描述事件的内容。
别名：@emits
语法：@fires &lt;className&gt;#[event:]&lt;eventName&gt;
例如，方法将触发&quot;drain&quot;事件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Drink the milkshake.</span><br><span class="line"> * @fires Milkshake#drain</span><br><span class="line"> */</span><br><span class="line">Milkshake.prototype.drink = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="function"><a href="#function" class="headerlink" title="@function"></a>@function</h3><pre><code>标记一个对象作为一个函数，即使它可能不会出现在解析器中。它设置doclet的@kind为&apos;function&apos;。
别名：@func  @method
语法：@function [&lt;FunctionName&gt;]
例如，使用@function标记为一个函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @function */</span><br><span class="line">var paginate = paginateFactory(pages);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><pre><code>@global标签指定一个在文档的标识是为全局性的标识。
JSDoc忽略这个标识在源文件中的实际作用范围。这个标记是在本地所定义标识时特别有用。
例如，文档中的内部变量作为一个全局变量
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">	/** @global */</span><br><span class="line">	var foo = &apos;hello foo&apos;;</span><br><span class="line"></span><br><span class="line">	this.foo = foo;</span><br><span class="line">&#125;).apply(window);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="ignore"><a href="#ignore" class="headerlink" title="@ignore"></a>@ignore</h3><pre><code>@ignore标签表示在你的代码中的注释不应该出现在文档中，注释会被直接忽略。这个标签优先于所有其他标签。
在下面的例子中，@ignore标签， Jacket 和 Jacket#color 将不会出现在文档中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @class</span><br><span class="line"> * @ignore</span><br><span class="line"> */</span><br><span class="line">function Jacket() &#123;</span><br><span class="line">	/** The jacket&apos;s color. */</span><br><span class="line">	this.color = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="implements"><a href="#implements" class="headerlink" title="@implements"></a>@implements</h3><pre><code>@implements标签指示一个标识实现一个接口。
语法：@implements {typeExpression}
在下面的例子中，TransparentColor类实现Color接口，并添加了TransparentColor#rgba方法。
</code></pre><h3 id="inheritdoc"><a href="#inheritdoc" class="headerlink" title="@inheritdoc"></a>@inheritdoc</h3><pre><code>@inheritdoc标签指示该标识应继承其父类的文档。在你的JSDoc注释中的任何其它标签都将被忽略。
下面的例子显示了一个类的描述如何从它的父类继承文档。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @classdesc Abstract class representing a network connection.</span><br><span class="line"> * @class</span><br><span class="line"> */</span><br><span class="line">function Connection() &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Open the connection.</span><br><span class="line"> */</span><br><span class="line">Connection.prototype.open = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @classdesc Class representing a socket connection.</span><br><span class="line"> * @class</span><br><span class="line"> * @augments Connection</span><br><span class="line"> */</span><br><span class="line">function Socket() &#123;&#125;</span><br><span class="line"></span><br><span class="line">/** @inheritdoc */</span><br><span class="line">Socket.prototype.open = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="inner"><a href="#inner" class="headerlink" title="@inner"></a>@inner</h3><pre><code>使用@inner标签将标明该标识符作为它父标识符的内部成员。这意味着它可以通过 &quot;Parent~Child&quot; 被引用。
在下面的例子中，我们使用@inner迫使一个命名空间的成员被描述作为内部成员（默认情况下，这是一个静态成员）。
这意味着，foo现在有了MyNamespace~foo新名字，而不是MyNamespace.foo。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @namespace */</span><br><span class="line">var MyNamespace = &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * foo is now MyNamespace~foo rather than MyNamespace.foo.</span><br><span class="line">	 * @inner</span><br><span class="line">	 */</span><br><span class="line">	foo: 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="instance"><a href="#instance" class="headerlink" title="@instance"></a>@instance</h3><pre><code>使用@instance标签标明该标识符作为它父标识符的实例成员。
这意味着它可以通过&quot;Parent#Child&quot;被引用。
例如，使用@instance确定一个实例成员
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @namespace */</span><br><span class="line">var BaseObject = &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * foo is now BaseObject#foo rather than BaseObject.foo.</span><br><span class="line">	 * @instance</span><br><span class="line">	 */</span><br><span class="line">	foo: null</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Generates BaseObject instances. */</span><br><span class="line">function fooFactory(fooValue) &#123;</span><br><span class="line">	var props = &#123; foo: fooValue &#125;;</span><br><span class="line">	return Object.create(BaseObject, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h3><pre><code>@interface标签使一个标识符作为其他标识符的一个实现接口。 例如，你的代码可能定义一个父类，它的方法和属性被去掉。
您可以将@interface标签添加到父类，以指明子类必须实现父类的方法和属性。
语法：@interface [&lt;name&gt;]
在下面的例子中，Color函数表示其它类可以实现的接口。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface for classes that represent a color.</span><br><span class="line"> * @interface</span><br><span class="line"> */</span><br><span class="line">function Color() &#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * Get the color as an array of red, green, and blue values, represented as</span><br><span class="line"> * decimal numbers between 0 and 1.</span><br><span class="line"> * @returns &#123;Array&amp;lt;number&gt;&#125; An array containing the red, green, and blue values,</span><br><span class="line"> * in that order.</span><br><span class="line"> */</span><br><span class="line">Color.prototype.rgb = function() &#123;</span><br><span class="line">	throw new Error(&apos;not implemented&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="kind"><a href="#kind" class="headerlink" title="@kind"></a>@kind</h3><pre><code>@kind标签是用来指明什么样的标识符被描述（例如，一类或模块）。标识符kind 不同于标识符type（例如，字符串或布尔）。
语法：@kind &lt;kindName&gt;
    kindName取值：class constant event external file function member mixin module namespace typedef
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A constant.</span><br><span class="line"> * @kind constant</span><br><span class="line"> */</span><br><span class="line">const asdf = 1;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="lends"><a href="#lends" class="headerlink" title="@lends"></a>@lends</h3><pre><code>@lends标签允许你将一个字面量对象的所有成员标记为某个标识符（类或模块）的成员，就像他们是给定名称的标识符成员。
你可能想这样做，如果你传递一个对象字面量给一个函数，创建一个成员为对象字面量的命名类。
语法：@lends &lt;namepath&gt;
实例，@lends标签告诉JSDoc，这一对象字面量的所有成员都会被“借”给&quot;Person&quot;类。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @class */</span><br><span class="line">var Person = makeClass(</span><br><span class="line">	/** @lends Person */</span><br><span class="line">	&#123;</span><br><span class="line">		initialize: function(name) &#123;</span><br><span class="line">			this.name = name;</span><br><span class="line">		&#125;,</span><br><span class="line">		say: function(message) &#123;</span><br><span class="line">			return this.name + &quot; says: &quot; + message;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="license"><a href="#license" class="headerlink" title="@license"></a>@license</h3><pre><code>@license标签标识你的代码采用何种软件许可协议。
语法：@license &lt;identifier&gt;
例如，这是在Apache 2.0 许可下分发的模块
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Utility functions for the foo package.</span><br><span class="line"> * @module foo/util</span><br><span class="line"> * @license Apache-2.0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="listens"><a href="#listens" class="headerlink" title="@listens"></a>@listens</h3><pre><code>@listens 标签指示一个标识监听指定的事件。使用@event 标签来记录事件的内容。
语法：@listens &lt;eventName&gt;
下面的示例演示了如何记录名为module:hurler~event:snowball的事件，还有一个方法命名为module:playground/monitor.reportThrowage来监听事件。
</code></pre><h3 id="member"><a href="#member" class="headerlink" title="@member"></a>@member</h3><pre><code>@member标签记录成员基本种类（kind），比如&quot;class&quot;, &quot;function&quot;, 或者 &quot;constant&quot;。
一个成员可以任选地具有一个类型以及名称。
别名：@var
语法：@member [&lt;type&gt;] [&lt;name&gt;]
例如，Data#point上使用@member：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @class */</span><br><span class="line">function Data() &#123;</span><br><span class="line">	/** @member &#123;Object&#125; */</span><br><span class="line">	this.point = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="memberof"><a href="#memberof" class="headerlink" title="@memberof"></a>@memberof</h3><pre><code>@memberof标签标明成员隶属于哪一个父级标识符。
语法：@memberof &lt;parentNamepath&gt;
      @memberof! &lt;parentNamepath&gt;
事实上，它就是一个全局性的函数，但同事它也是Tools命名空间的一个成员，而这才是你想描述的。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @namespace */</span><br><span class="line">var Tools = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/** @memberof Tools */</span><br><span class="line">var hammer = function() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tools.hammer = hammer;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="mixes"><a href="#mixes" class="headerlink" title="@mixes"></a>@mixes</h3><pre><code>@mixes标签指示当前对象混入了OtherObjectPath对象的所有成员,被混入的对象就是一个@mixin。    
语法：@mixes &lt;OtherObjectPath&gt;
</code></pre><h3 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h3><pre><code>您可以使用@mixin标签标识该对象是一个mixin（混入），旨在表明该对象的属性和方法混入到其他对象。
然后，可以将@mixes标签 添加到使用了该 mixin（混入）的对象上。
语法：@mixin [&lt;MixinName&gt;]
</code></pre><h3 id="module"><a href="#module" class="headerlink" title="@module"></a>@module</h3><pre><code>@module可以将当前文件标注为一个模块，默认情况下文件内的所有标识符都隶属于此模块，除非文档另有说明。
@module [[{&lt;type&gt;}] &lt;moduleName&gt;]
下面的示例演示了在一个模块中用于标识的namepaths。第一个标识符是模块私有的，或“内部”变量 - 它只能在模块内访问。第二个标识符是由模块导出一个静态函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @module myModule */</span><br><span class="line"></span><br><span class="line">/** will be module:myModule~foo */</span><br><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">/** will be module:myModule.bar */</span><br><span class="line">var bar = function() &#123;&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="name"><a href="#name" class="headerlink" title="@name"></a>@name</h3><pre><code>@name标签强制JSDoc使用这个给定的名称，而忽略实际代码里的名称。
这个标签最好用于&quot;虚拟注释&quot;，而不是在代码中随时可见的标签，如在运行时期间产生的方法。
语法：@name &lt;namePath&gt;
下面的例子演示了如何使用@name标签描述一个函数，JSDoc通常不会识别。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name highlightSearchTerm</span><br><span class="line"> * @function</span><br><span class="line"> * @global</span><br><span class="line"> * @param &#123;string&#125; term - The search term to highlight.</span><br><span class="line"> */</span><br><span class="line">eval(&quot;window.highlightSearchTerm = function(term) &#123;&#125;;&quot;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="namespace"><a href="#namespace" class="headerlink" title="@namespace"></a>@namespace</h3><pre><code>@namespace标签指明对象是一个命名空间。你也可以书写一个虚拟JSDoc注释，通过使用代码来定义命名空间。
语法：@namespace [{&lt;type&gt;}] &lt;SomeName&gt;]
例如，对象上使用 @namespace 标签：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * My namespace.</span><br><span class="line"> * @namespace</span><br><span class="line"> */</span><br><span class="line">var MyNamespace = &#123;</span><br><span class="line">	/** documented as MyNamespace.foo */</span><br><span class="line">	foo: function() &#123;&#125;,</span><br><span class="line">	/** documented as MyNamespace.bar */</span><br><span class="line">	bar: 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="noopener">jsDoc文档</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDoc学习-标签总结</title>
    <url>/2017/jsDoc%E5%AD%A6%E4%B9%A0-5.html</url>
    <content><![CDATA[<h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><pre><code>@class -- 此函数旨在需要使用”new”关键字调用（构造函数）或ES6中class。
    @constructor
@classdesc -- 使用的后面的蚊子来描述整个类。
@abstract -- 这个成员必须在继承的子类中重写。
    @virtual
@static -- 记录一个静态成员。
@access -- 指定该成员的访问级别（私有private、保护protected、公共public）。
    @access private 等价于 @private
    @access protected 等价于 @protected
    @access public 等价于 @public
@alias -- 标记成员有一个别名。
@extends -- 指名这个子类继承至哪个父类，后面需要加父类名。
    @augments
@instance -- 记录一个实例成员。
@interface -- 这是别人可以实现的一个接口。
</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre><code>@borrows -- 这个对象使用另一个对象的某些东西。
@lends -- 将一个字面量对象的所有属性标记为某个标识符（类或模块）的成员。
@mixes -- 此对象混入了另一个对象中的所有成员。
@mixin -- 记录一个mixin（混入）对象。
@name  -- 记录一个对象的名称。
@namespace -- 记录一个命名空间对象。
@property -- 记录一个对象的属性。
    @prop
@typedef -- 记录一个自定义的类型。
@type -- 记录一个对象的类型。
@variation -- 区分具有相同名称的不同的对象。
</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>@callback -- 描述一个回调函数。
@function -- 描述一个函数或方法。
    @func
    @method
@returns -- 记录一个函数的返回值。
    @return
@this -- this关键字的指向。
</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>@author -- 指定项目的作者。
@constant -- 记录一个对象作为一个常量。
    @const
@default -- 记录默认值。
    @defaultvalue
@copyright -- 描述一些版权信息。
@since -- 该方法添加于该版本，建议使用。
@deprecated -- 该方法已弃用，不建议使用。
@description -- 描述一个标识。
    @desc
@enum -- 描述一个相关属性的集合。
@example -- 提供一个如何使用描述项的例子。
@external -- 标识一个外部的类，命名空间，或模块。
@file -- 描述一个文件。
    @fileoverview
    @overview
@global -- 记录一个全局对象。
@ignore -- 忽略文档中的一个标识。
@implements -- 这个表示实现一个接口。
@inheritdoc -- 指明这个标识应继承其父类的文档。
@inner -- 描述一个内部对象。
@kind -- 表示的类型。
@license -- 表示你的代码采用何种软件许可协议。
@member -- 记录一个成员。
    @var
@memberof -- 标明这个标识属于哪个父级标识。
@override -- 指明一个标识符覆盖其父类同名的标识符。
@param -- 记录传递给一个函数的参数。
    @arg 
    @argument
@readonly -- 标记为只读的。
@see -- 更多详细参阅其他一些文档。
@summary -- 完整描述的一个简写版本。
@throws -- 说明可能会被抛出什么样的错误。
@todo -- 记录一个将要完成的任务。
@tutorial -- 插入一个连接到包含教程文件。
@version -- 记录版本信息。
</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>@event -- 描述一个事件。
@listens -- 列出一个标识的监听事件。
@fires -- 描述事件这个方法可能会触发。
    @emits
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>@exports -- 表示一个由javascript模块导出的成员。
@module -- 记录一个javascript模块。
@requires -- 这个文件需要一个javascript模块。
</code></pre><h2 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a>内联标签</h2><pre><code>@link -- 连接到文档中的另一个项目。
    @linkcode
    @linkplain
@tutorial -- 链接到一个教程。
</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>安装jsdoc3<br>npm install -g jsdoc</li>
<li>在cmd 中 (此时会在test.js的同级目录产出out目录，存放生成的API文档)<br>jsdoc test.js<br>  默认配置情况下out目录中产出：<pre><code>fonts、scripts、styles目录顾名思义。
index.html -- API文档首页
global.html -- 全局的（成员和方法）
index.js.html -- 源代码页面
</code></pre></li>
<li><p>相关配置<br>启用jsdoc有两种方式：命令行参数 和 conf.json配置<br>JSDoc命令行参数<br>  JSDoc命令行几个常用参数有以下几个：<br>  -c, –configure 指定configuration file<br>  -d, –destination 指定输出路径，默认./out<br>  -e, –encoding 设定encoding，默认utf8<br>  -p, –private 将private注释输出到文档，默认不输出<br>  -P, –package 指定package.json file<br>  -r, –recurse 查询子目录<br>  -t, –template 指定输出文档template<br>  -u, –tutorials 指定教程路径，默认无<br>  例如：jsdoc -T –match tag –verbose<br>JSDoc配置文件<br>  默认的配置文件：conf.json.EXAMPLE</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;tags&quot;: &#123;</span><br><span class="line">		&quot;allowUnknownTags&quot;: true, // 允许使用自定义tag</span><br><span class="line">		&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;] // 定义tag集</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;, // 将以.js, .jsdoc结尾的文件作为源文件</span><br><span class="line">		&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot; // 忽略以_开头的文件夹及文件</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;plugins&quot;: [],</span><br><span class="line">	&quot;templates&quot;: &#123;</span><br><span class="line">		&quot;cleverLinks&quot;: false,</span><br><span class="line">		&quot;monospaceLinks&quot;: false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：jsdoc -c /path/to/conf.json</p>
</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/inline-tags.html" target="_blank" rel="noopener">jsdoc</a><br>    <a href="https://github.com/jsdoc3/jsdoc" target="_blank" rel="noopener">jsdoc3</a><br>    <a href="http://www.moodpo.com/archives/jsdoc3-tutorial.html" target="_blank" rel="noopener">使用 JSDoc 3 自动生成 JavaScript API 文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>js代码规范</title>
    <url>/2017/js%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html</url>
    <content><![CDATA[<p>Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol>
<li>基本类型：直接存取基本类型。<br>String 字符串<br>Number 数值<br>Boolean 布尔类型<br>null<br>undefined</li>
<li>复制类型：通过引用的方式存取复杂类型。<br>Object 对象<br>Array 数组<br>Function 函数<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2></li>
<li>对不可变的引用使用 const 避免使用 var。<br>  const 声明的变量不可以重新赋值，而 var 可以。</li>
<li>对可变的引用使用 let 避免使用 var。</li>
<li>注意 let 和 const 都是块级作用域。<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li>
<li>使用字面值创建对象。</li>
<li>如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。</li>
<li>使用同义词替换需要使用的保留字。</li>
<li><p>创建有动态属性名的对象时，使用可被计算的属性名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getKey(k) &#123;</span><br><span class="line">	return `a key named $&#123;k&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">const obj = &#123;</span><br><span class="line">	id: 5,</span><br><span class="line">	name: &apos;San Francisco&apos;,</span><br><span class="line">	[getKey(&apos;enabled&apos;)]: true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象方法的简写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const atom = &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  // 方法简写</span><br><span class="line">  addValue(value) &#123;</span><br><span class="line">	return atom.value + value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象属性值的简写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const lukeSkywalker = &apos;Luke Skywalker111&apos;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">	lukeSkywalker,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.lukeSkywalker); // &apos;Luke Skywalker111&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对象属性声明前把简写的属性分组（也就是说把简写属性放在一起）。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li>
<li>使用字面值创建数组。</li>
<li><p>向数组添加元素时使用 Arrary#push 替代直接赋值。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	const someStack = [];</span><br><span class="line"></span><br><span class="line">	// bad</span><br><span class="line">	someStack[someStack.length] = &apos;abracadabra&apos;;</span><br><span class="line"></span><br><span class="line">	// good</span><br><span class="line">	someStack.push(&apos;abracadabra&apos;);</span><br><span class="line">	```	</span><br><span class="line">3.	使用拓展运算符 ... 复制数组。</span><br></pre></td></tr></table></figure>
<p>let array = [‘1’,’2’];<br>console.log([…array]);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.	使用 Array#from 把一个类数组对象转换成数组。</span><br></pre></td></tr></table></figure>
<p>const foo = document.querySelectorAll(‘.foo’);<br>const nodes = Array.from(foo);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##	解构</span><br><span class="line">1.	使用解构存取和使用多属性对象。</span><br></pre></td></tr></table></figure>
<p>// good<br>function getFullName(obj) {<br>  const { firstName, lastName } = obj;<br>  return <code>${firstName} ${lastName}</code>;<br>}</p>
<p>// best<br>  function getFullName({ firstName, lastName }) {<br>  return <code>${firstName} ${lastName}</code>;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.	对数组使用解构赋值。</span><br></pre></td></tr></table></figure>
<p>const arr = [1, 2, 3, 4];<br>const [first, second] = arr;<br>console.log(first, second); // 1, 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.	需要回传多个值时，使用对象解构，而不是数组解构。</span><br></pre></td></tr></table></figure>
<p>function processInput(input) {<br>  // then a miracle occurs<br>  return { left, right, top, bottom };<br>}</p>
<p>// 调用时只选择需要的数据<br>const { left, right } = processInput(input);</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li>
<li>字符串使用单引号 ‘’。 </li>
<li>字符串超过 80 个字节应该使用字符串连接号换行。\    </li>
<li>过度使用字串连接符号可能会对性能造成影响。可换用 +     </li>
<li>程序化生成字符串时，使用模板字符串代替字符串连接。<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li>
<li>使用函数声明代替函数表达式。    </li>
<li><p>立即调用的函数表达式 (IIFE)    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p>永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。<br>浏览器允许你这么做，但它们的解析表现不一致。<br>可以这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let test;</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  test = () =&gt; &#123;</span><br><span class="line">	console.log(&apos;Yup.&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。</p>
</li>
<li>不要使用 arguments。可以选择 rest 语法 … 替代。</li>
<li><p>直接给函数的参数指定默认值，不要使用一个变化的函数参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handleThings(opts = &#123;&#125;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接给函数参数赋值时需要避免副作用。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2></li>
<li><p>当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].map((x) =&gt; &#123;</span><br><span class="line">	return x * x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。<br>如果不是，那就不要省略。</p>
<h2 id="Classes-和-Constructors"><a href="#Classes-和-Constructors" class="headerlink" title="Classes 和 Constructors"></a>Classes 和 Constructors</h2></li>
<li><p>总是使用 class。避免直接操作 prototype 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line">class Queue &#123;</span><br><span class="line">	constructor(contents = []) &#123;</span><br><span class="line">	  this._queue = [...contents];</span><br><span class="line">	&#125;</span><br><span class="line">	pop() &#123;</span><br><span class="line">	  const value = this._queue[0];</span><br><span class="line">	  this._queue.splice(0, 1);</span><br><span class="line">	  return value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var demo = new Queue([1, 2, 3]);</span><br><span class="line">console.log(demo.pop()); // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 extends 继承。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PeekableQueue extends Queue &#123;</span><br><span class="line">	constructor (args) &#123;</span><br><span class="line">		super(args);</span><br><span class="line">	&#125;</span><br><span class="line">	peek() &#123;</span><br><span class="line">		return this._queue[0];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法可以返回 this 来帮助链式调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Jedi &#123;</span><br><span class="line">	jump() &#123;</span><br><span class="line">		this.jumping = true;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	setHeight(height) &#123;</span><br><span class="line">		this.height = height;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const luke = new Jedi();</span><br><span class="line">luke.jump()</span><br><span class="line">	.setHeight(20);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Jedi &#123;</span><br><span class="line">	constructor(options = &#123;&#125;) &#123;</span><br><span class="line">		this.name = options.name || &apos;no name&apos;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getName() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	toString() &#123;</span><br><span class="line">		return `Jedi - $&#123;this.getName()&#125;`;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li><p>总是使用模组 (import/export) 而不是其他非标准模块系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ok</span><br><span class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default AirbnbStyleGuide.es6;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用通配符 import。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要从 import 中直接 export。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Iterators-amp-Generators"><a href="#Iterators-amp-Generators" class="headerlink" title="Iterators &amp; Generators"></a>Iterators &amp; Generators</h2><ol>
<li>不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">let sum = 0;</span><br><span class="line">numbers.forEach((num) =&gt; sum += num);</span><br><span class="line"></span><br><span class="line">// best (use the functional force)</span><br><span class="line">const sum = numbers.reduce((total, num) =&gt; total + num, 0);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li>普通属性使用 . 来访问对象的属性。    </li>
<li>当通过变量访问属性时使用中括号 []。<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li>
<li>一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。</li>
<li><p>单独声明每一个变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const items = getItems();</span><br><span class="line">const goSportsTeam = true;</span><br><span class="line">const dragonball = &apos;z&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有的 const 和 let 分组。</p>
</li>
<li>在你需要的地方给变量赋值，但请把它们放在一个合理的位置。<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2></li>
<li>var 声明会被提升至该作用域的顶部，但它们赋值不会提升。<br>let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。</li>
<li>匿名函数表达式的变量名会被提升，但函数内容并不会。</li>
<li>命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。</li>
<li>函数声明的名称和函数体都会被提升。<h2 id="比较运算符-amp-等号"><a href="#比较运算符-amp-等号" class="headerlink" title="比较运算符 &amp; 等号"></a>比较运算符 &amp; 等号</h2></li>
<li>优先使用 === 和 !== 而不是 == 和 !=。</li>
<li>条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则<br>对象 被计算为 true<br>Undefined 被计算为 false<br>Null 被计算为 false<br>布尔值 被计算为 布尔的值<br>数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true<br>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</li>
<li>使用简写。<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2></li>
<li>使用大括号包裹所有的多行代码块。</li>
<li>如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li>
<li>使用 /*<em> … </em>/ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。<br>配合 JSDoc 完美</li>
<li>使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。<br>在注释前插入空行。</li>
<li>给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。<br>这将有别于常见的注释，因为它们是可操作的。<br>使用FIXME – need to figure this out 或者 TODO – need to implement。</li>
<li><p>使用 // FIXME: 标注问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		// FIXME: shouldn&apos;t use a global here</span><br><span class="line">		total = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 // TODO: 标注问题的解决方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">	// TODO: total should be configurable by an options param</span><br><span class="line">	this.total = 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ol>
<li>使用 2 个空格作为缩进。</li>
<li>在花括号前放一个空格。</li>
<li>在控制语句（if、while 等）的小括号前放一个空格。<br>在函数调用及声明中，不在函数的参数列表前加空格。</li>
<li>使用空格把运算符隔开。</li>
<li>在文件末尾插入一个空行。</li>
<li>在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。</li>
<li>在块末和新语句前插入空行。<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2></li>
<li>行首不要加逗号。</li>
<li>增加结尾的逗号: 需要。<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2></li>
<li>每个语句都使用分号。</li>
<li>IIFE 函数前添加分号。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// good (防止函数在两个 IIFE 合并时被当成一个参数)</span><br><span class="line">;(() =&gt; &#123;</span><br><span class="line">  const name = &apos;Skywalker&apos;;</span><br><span class="line">  return name;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>在语句开始时执行类型转换。</li>
<li>显式转换字符串。<br>const reviewScore = 9;<br>const totalScore = String(reviewScore);</li>
<li><p>对数字使用 parseInt 转换，并带上类型转换的基数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const val = Number(inputValue);</span><br><span class="line"></span><br><span class="line">const val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</p>
</li>
<li>小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数。<br>位操作处理大于 32 位的整数值时还会导致意料之外的行为。</li>
<li>转换为buer。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const age = 0;</span><br><span class="line">const hasAge = Boolean(age);</span><br><span class="line">const hasAge = !!age;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li>避免单字母命名。命名应具备描述性。</li>
<li>使用驼峰式命名对象、函数和实例。</li>
<li>使用帕斯卡（大驼峰）式命名构造函数或类。</li>
<li>使用下划线 _ 开头命名私有属性。</li>
<li><p>别保存 this 的引用。使用箭头函数或 Function#bind。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">	console.log(this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		console.log(this);</span><br><span class="line">	&#125;.bind(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// file contents</span><br><span class="line">class CheckBox &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">export default CheckBox;</span><br><span class="line"></span><br><span class="line">import CheckBox from &apos;./CheckBox&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当你导出默认的函数时使用驼峰式命名。<br>你的文件名必须和函数名完全保持一致。</p>
</li>
<li>当你导出单例、函数库、空对象时使用帕斯卡式命名。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const AirbnbStyleGuide = &#123;</span><br><span class="line">  es6: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default AirbnbStyleGuide;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><ol>
<li>属性的存取函数不是必须的。    </li>
<li><p>如果你需要存取函数时使用 getVal() 和 setVal(‘hello’)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dragon.getAge();</span><br><span class="line">dragon.setAge(25);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是布尔值，使用 isVal() 或 hasVal()。</p>
</li>
<li>创建 get() 和 set() 函数是可以的，但要保持一致。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Jedi &#123;</span><br><span class="line">  constructor(options = &#123;&#125;) &#123;</span><br><span class="line">	const lightsaber = options.lightsaber || &apos;blue&apos;;</span><br><span class="line">	this.set(&apos;lightsaber&apos;, lightsaber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123;</span><br><span class="line">	this[key] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">	return this[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol>
<li>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。<br>这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(this).trigger(&apos;listingUpdated&apos;, &#123; listingId : listing.id &#125;);</span><br><span class="line"></span><br><span class="line">$(this).on(&apos;listingUpdated&apos;, function(e, data) &#123;</span><br><span class="line">  // do something with data.listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><ol>
<li>使用 $ 作为存储 jQuery 对象的变量名前缀。<br>const $sidebar = $(‘.sidebar’);</li>
<li><p>缓存 jQuery 查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setSidebar() &#123;</span><br><span class="line">  const $sidebar = $(&apos;.sidebar&apos;);</span><br><span class="line">  $sidebar.hide();</span><br><span class="line"></span><br><span class="line">  $sidebar.css(&#123;</span><br><span class="line">	&apos;background-color&apos;: &apos;pink&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对 DOM 查询使用层叠 $(‘.sidebar ul’) 或 父元素 &gt; 子元素 $(‘.sidebar &gt; ul’)。</p>
</li>
<li>对有作用域的 jQuery 对象查询使用 find。<blockquote>
<p>   参考文档：<br><a href="https://www.kancloud.cn/kancloud/javascript-style-guide/43153" target="_blank" rel="noopener">Airbnb JavaScript 代码规范（ES6）</a><br><a href="https://github.com/airbnb/javascript#airbnb-javascript-style-guide-" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDoc学习-标签3</title>
    <url>/2017/jsDoc%E5%AD%A6%E4%B9%A0-4.html</url>
    <content><![CDATA[<h3 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h3><pre><code>@override标签指明一个标识符覆盖其父类同名的标识符。
下面的例子说明一个方法如何重写父类的方法。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @classdesc Abstract class representing a network connection.</span><br><span class="line"> * @class</span><br><span class="line"> */</span><br><span class="line">function Connection() &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Open the connection.</span><br><span class="line"> */</span><br><span class="line">Connection.prototype.open = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @classdesc Class representing a socket connection.</span><br><span class="line"> * @class</span><br><span class="line"> * @augments Connection</span><br><span class="line"> */</span><br><span class="line">function Socket() &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Open the socket.</span><br><span class="line"> * @override</span><br><span class="line"> */</span><br><span class="line">Socket.prototype.open = function() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h3><pre><code>@param标签提供了对某个函数的参数的各项说明，包括参数名、参数数据类型、描述等。
别名：@arg @argument
下面的示例演示如何在 @param标签中包含名称，类型，和说明。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param somebody</span><br><span class="line"> */</span><br><span class="line">function sayHello(somebody) &#123;</span><br><span class="line">	alert(&apos;Hello &apos; + somebody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="private"><a href="#private" class="headerlink" title="@private"></a>@private</h3><pre><code>@private标签标记标识符为私有，或者不做一般用途使用。
私有成员不会在生成文档中输出任何内容，除非JSDoc使用 -p/--private 命令行选项运行。
语法：@private
在下面的例子中，Documents和Documents.Newspaper会被输出到生成的文档中，但是Documents.Diary不会。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @namespace */</span><br><span class="line">var Documents = &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * An ordinary newspaper.</span><br><span class="line">	 */</span><br><span class="line">	Newspaper: 1,</span><br><span class="line">	/**</span><br><span class="line">	 * My diary.</span><br><span class="line">	 * @private</span><br><span class="line">	 */</span><br><span class="line">	Diary: 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><pre><code>@property标签很容易描述类，命名空间或其它对象的静态属性列表。
别名：@prop
例如，描述命名空间的默认属性及嵌套属性：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @namespace</span><br><span class="line"> * @property &#123;object&#125;  defaults               - The default values for parties.</span><br><span class="line"> * @property &#123;number&#125;  defaults.players       - The default number of players.</span><br><span class="line"> * @property &#123;string&#125;  defaults.level         - The default level for the party.</span><br><span class="line"> * @property &#123;object&#125;  defaults.treasure      - The default treasure.</span><br><span class="line"> * @property &#123;number&#125;  defaults.treasure.gold - How much gold the party starts with.</span><br><span class="line"> */</span><br><span class="line">var config = &#123;</span><br><span class="line">	defaults: &#123;</span><br><span class="line">		players: 1,</span><br><span class="line">		level:   &apos;beginner&apos;,</span><br><span class="line">		treasure: &#123;</span><br><span class="line">			gold: 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="protected"><a href="#protected" class="headerlink" title="@protected"></a>@protected</h3><pre><code>@protected标签标记标识符为受保护的，通常情况下，受保护的成员只能在被继承的子类中或在模块内部可以访问。
语法：@protected [{typeExpression}]
在下面的例子中，该实例成员Thingy#_bar会被导出到生成的文档中，但使用注释说明它是被保护的。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @constructor */</span><br><span class="line">function Thingy() &#123;</span><br><span class="line">	/** @protected */</span><br><span class="line">	this._bar = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="public"><a href="#public" class="headerlink" title="@public"></a>@public</h3><pre><code>@public标签标记标识符为公开的。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The Thingy class is available to all.</span><br><span class="line"> * @public</span><br><span class="line"> * @class</span><br><span class="line"> */</span><br><span class="line">function Thingy() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * The Thingy~foo member. Note that &apos;foo&apos; is still an inner member</span><br><span class="line">	 * of &apos;Thingy&apos;, in spite of the @public tag.</span><br><span class="line">	 * @public</span><br><span class="line">	 */</span><br><span class="line">	var foo = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h3><pre><code>标记一个标识符为只读。jsdoc不会检查某个代码是否真是只读的，只要标上@readonly，在文档中就体现为只读的。
例如，给getter标记为只读
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Options for ordering a delicious slice of pie.</span><br><span class="line"> * @namespace</span><br><span class="line"> */</span><br><span class="line">var pieOptions = &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * A la mode.</span><br><span class="line">	 * @readonly</span><br><span class="line">	 */</span><br><span class="line">	get aLaMode() &#123;</span><br><span class="line">		return this.plain + &apos; with ice cream&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="requires"><a href="#requires" class="headerlink" title="@requires"></a>@requires</h3><pre><code>@requires标签可以记录一个模块需要的依赖项。一个JSDoc注释块可以有多个@require标签。
模块名可以被指定为 &quot;moduleName&quot; 或者 &quot;module:moduleName&quot;;这两种形式将被解析为模块。
语法：@requires &lt;someModuleName&gt;
例如，使用@requires 标签
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This class requires the modules &#123;@link module:xyzcorp/helper&#125; and</span><br><span class="line"> * &#123;@link module:xyzcorp/helper.ShinyWidget#polish&#125;.</span><br><span class="line"> * @class</span><br><span class="line"> * @requires module:xyzcorp/helper</span><br><span class="line"> * @requires xyzcorp/helper.ShinyWidget#polish</span><br><span class="line"> */</span><br><span class="line">function Widgetizer() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="returns"><a href="#returns" class="headerlink" title="@returns"></a>@returns</h3><pre><code>@returns 标签描述一个函数的返回值。语法和@param类似。
别名：@return
返回值的类型
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the sum of a and b</span><br><span class="line"> * @param &#123;Number&#125; a</span><br><span class="line"> * @param &#123;Number&#125; b</span><br><span class="line"> * @returns &#123;Number&#125;</span><br><span class="line"> */</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h3><pre><code>@see标签表示可以参考另一个标识符的说明文档，或者一个外部资源。
语法：@see &lt;namepath&gt;
      @see &lt;text&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Both of these will link to the bar function.</span><br><span class="line"> * @see &#123;@link bar&#125;</span><br><span class="line"> * @see bar</span><br><span class="line"> */</span><br><span class="line">function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="since"><a href="#since" class="headerlink" title="@since"></a>@since</h3><pre><code>@since标签标明一个类，方法，或其它标识符是在哪个特定版本开始添加进来的。
语法：@since &lt;versionDescription&gt;
例如，使用@since标签：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Provides access to user information.</span><br><span class="line"> * @since 1.0.1</span><br><span class="line"> */</span><br><span class="line">function UserRecord() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="static"><a href="#static" class="headerlink" title="@static"></a>@static</h3><pre><code>@static标签标明一个在父类中的标识符不需实例即可使用。
例如，在一个虚拟注释中使用@static    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @namespace MyNamespace */</span><br><span class="line">/**</span><br><span class="line"> * @function myFunction</span><br><span class="line"> * @memberof MyNamespace</span><br><span class="line"> * @static</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="summary"><a href="#summary" class="headerlink" title="@summary"></a>@summary</h3><pre><code>@summary标签是完整描述的一个简写版本。它可以被添加到任何的doclet。
语法：@summary Summary goes here.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological,</span><br><span class="line"> * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate,</span><br><span class="line"> * loquacious, garrulous, chatty, extended, babbling description.</span><br><span class="line"> * @summary A concise summary.</span><br><span class="line"> */</span><br><span class="line">function bloviate() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="this"><a href="#this" class="headerlink" title="@this"></a>@this</h3><pre><code>@this标签指明this关键字的指向。
语法：@this &lt;namePath&gt;
在下面的例子中，@this标签迫使&quot;this.name&quot;被描述为&quot;Greeter#name&quot;，而不是全局变量&quot;name&quot;。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @constructor */</span><br><span class="line">function Greeter(name) &#123;</span><br><span class="line">	setName.apply(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** @this Greeter */</span><br><span class="line">function setName(name) &#123;</span><br><span class="line">	/** document me */</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="throws"><a href="#throws" class="headerlink" title="@throws"></a>@throws</h3><pre><code>@throws标签可以让你描述函数可能会抛出的错误。在一个JSDoc注释块中您可以包含多个@throws标签。
语法：@throws free-form description
      @throws {&lt;type&gt;}
      @throws {&lt;type&gt;} free-form description
例如，在type中使用@throws标签:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @throws &#123;InvalidArgumentException&#125;</span><br><span class="line"> */</span><br><span class="line">function foo(x) &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="todo"><a href="#todo" class="headerlink" title="@todo"></a>@todo</h3><pre><code>@todo标签可以让你记录要完成的任务。在一个JSDoc注释块中您可以包含多个@todo标签。
语法：@todo text describing thing to do.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @todo Write the documentation.</span><br><span class="line"> * @todo Implement this function.</span><br><span class="line"> */</span><br><span class="line">function foo() &#123;</span><br><span class="line">	// write me</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="tutorial"><a href="#tutorial" class="headerlink" title="@tutorial"></a>@tutorial</h3><pre><code>@tutorial 标签插入一个指向向导教程的链接，作为文档的一部分。
语法：@tutorial &lt;tutorialID&gt;
在下面的例子中，MyClass的文档将链接到tutorial-1 和 tutorial-2标识符的教程。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description</span><br><span class="line"> * @class</span><br><span class="line"> * @tutorial tutorial-1</span><br><span class="line"> * @tutorial tutorial-2</span><br><span class="line"> */</span><br><span class="line">function MyClass() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><pre><code>@type标签允许你提供一个表达式，用于标识一个标识符可能包含的值的类型，或由函数返回值的类型。
语法：@type {typeName1 | typeName2}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @type &#123;(string|Array.&lt;string&gt;)&#125; */</span><br><span class="line">var foo;</span><br><span class="line">/** @type &#123;number&#125; */</span><br><span class="line">var bar = 1;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="typedef"><a href="#typedef" class="headerlink" title="@typedef"></a>@typedef</h3><pre><code>@typedef标签在描述自定义类型时是很有用的，特别是如果你要反复引用它们的时候。
语法：@typedef [&lt;type&gt;] &lt;namepath&gt;
这个例子定义了一个联合类型的参数，表示可以包含数字或字符串。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A number, or a string containing a number.</span><br><span class="line"> * @typedef &#123;(number|string)&#125; NumberLike</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="variation"><a href="#variation" class="headerlink" title="@variation"></a>@variation</h3><pre><code>描述: 区分具有相同名称的不同的对象。
语法：@variation &lt;variationNumber&gt;
</code></pre><h3 id="version"><a href="#version" class="headerlink" title="@version"></a>@version</h3><pre><code>@version标签后面的文本将被用于表示该项的版本。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @version 1.2.3</span><br><span class="line"> * @tutorial solver</span><br><span class="line"> */</span><br><span class="line">function solver(a, b) &#123;</span><br><span class="line">	return b / a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="内联标签（inline-Tags）"><a href="#内联标签（inline-Tags）" class="headerlink" title="内联标签（inline Tags）"></a>内联标签（inline Tags）</h3><pre><code>{@link}内联标签创建一个链接到您指定的namepath或URL。当您使用{@link}标签，还可以提供几种不同的格式的链接文本。
如果你不提供任何链接文本，JSDoc使用namepath或URL作为链接文字。
别名：@linkcode  @linkplain
语法：{@link namepathOrURL}
      [link text]{@link namepathOrURL}
      {@link namepathOrURL|link text}
      {@link namepathOrURL link text (after the first space)}
下面的例子显示了提供给{@link} 标签链接文本的所有方式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * See &#123;@link MyClass&#125; and [MyClass&apos;s foo property]&#123;@link MyClass#foo&#125;.</span><br><span class="line"> * Also, check out &#123;@link http://www.google.com|Google&#125; and</span><br><span class="line"> * &#123;@link https://github.com GitHub&#125;.</span><br><span class="line"> */</span><br><span class="line">function myFunction() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="tutorial-1"><a href="#tutorial-1" class="headerlink" title="@tutorial"></a>@tutorial</h3><pre><code>{@tutorial}行内标签创建一个链接到您指定的教程标识符。当您使用{@tutorial}标签，您也可以提供几种不同的格式的链接文本。
如果你不提供任何链接文本，JSDoc使用本教程的标题作为链接文字。
语法：{@tutorial tutorialID}
      [link text]{@tutorial tutorialID}
      {@tutorial tutorialID|link text}
      {@tutorial tutorialID link text (after the first space)}
下面的例子显示了提供给{@tutorial}标签链接文本的所有方式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * See &#123;@tutorial gettingstarted&#125; and [Configuring the Dashboard]&#123;@tutorial dashboard&#125;.</span><br><span class="line"> * For more information, see &#123;@tutorial create|Creating a Widget&#125; and</span><br><span class="line"> * &#123;@tutorial destroy Destroying a Widget&#125;.</span><br><span class="line"> */</span><br><span class="line">function myFunction() &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="noopener">jsDoc文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>jsDoc学习-入门知识</title>
    <url>/2017/jsDoc%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h2 id="jsDoc介绍"><a href="#jsDoc介绍" class="headerlink" title="jsDoc介绍"></a>jsDoc介绍</h2><p>定义：JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。<br>jsDoc注释：是以 /** 来作为jsDoc注释的开始，其它如 /* 和 /*** 的注释都会被jsDoc解析器忽略。<br>    在webstorm中自动生成jsDoc注释<br>    示例：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Book类，代表一本书</span><br><span class="line"> * @param title</span><br><span class="line"> * @param anthor</span><br><span class="line"> * @param pageNum</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">function Book (title, anthor, pageNum ) &#123;</span><br><span class="line">	// 实例属性</span><br><span class="line">	this.title = title;</span><br><span class="line">	this.anthor = anthor;</span><br><span class="line">	this.pageNum = pageNum || 0;</span><br><span class="line">&#125;</span><br><span class="line">Book.prototype = &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 获取书本的标题</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getTitle : function () &#123;</span><br><span class="line">		return this.title;</span><br><span class="line">	&#125;,</span><br><span class="line">	/**</span><br><span class="line">	 * 获取书本的作者</span><br><span class="line">	 * @returns &#123;*&#125;</span><br><span class="line">	 */</span><br><span class="line">	getAnthor: function  () &#123;</span><br><span class="line">		return this.anthor;</span><br><span class="line">	&#125;,</span><br><span class="line">	/**</span><br><span class="line">	 * 设置书本的页码</span><br><span class="line">	 * @param pageNum</span><br><span class="line">	 */</span><br><span class="line">	setPageNum: function (pageNum) &#123;</span><br><span class="line">		this.pageNum = pageNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Namepaths-in-JSDoc-3（JSDoc-3中的名称路径）"><a href="#Namepaths-in-JSDoc-3（JSDoc-3中的名称路径）" class="headerlink" title="Namepaths in JSDoc 3（JSDoc 3中的名称路径）"></a>Namepaths in JSDoc 3（JSDoc 3中的名称路径）</h3><pre><code>如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。
名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。
jsDoc中名称路径的基本语法示例：
</code></pre><ol>
<li>myFunction</li>
<li>MyConstructor</li>
<li>MyConstructor#instanceMember（实例成员）</li>
<li>MyConstructor.staticMember（静态成员）</li>
<li><p>MyConstructor~innerMember（内部成员）<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Person类，一个人</span><br><span class="line"> * @param name</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">const  Person = function (name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	/**</span><br><span class="line">	 * 这是一个实例成员</span><br><span class="line">	 * @returns &#123;string&#125;</span><br><span class="line">	 */</span><br><span class="line">	this.say = () =&gt; &#123;</span><br><span class="line">		return &apos;I\&apos;am an instance.&apos;;</span><br><span class="line">	&#125;;</span><br><span class="line">	/**</span><br><span class="line">	 * 这是一个内部成员</span><br><span class="line">	 * @returns &#123;string&#125;</span><br><span class="line">	 */</span><br><span class="line">	function say () &#123;</span><br><span class="line">		return &apos;I\&apos; am an inner.&apos;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 这是一个静态成员</span><br><span class="line"> * @returns &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">Person.say = function () &#123;</span><br><span class="line">	return &apos;I\&apos;am an static.&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 实例化一个人</span><br><span class="line"> * @type &#123;Person&#125;</span><br><span class="line"> */</span><br><span class="line">const person1 = new Person(&apos;fanerge&apos;);</span><br><span class="line">// Person#say 使用实例方法</span><br><span class="line">person1.say();</span><br><span class="line">// Person.say 使用静态方法</span><br><span class="line">Person.say();</span><br><span class="line">// Person~say 使用内部方法，但这里不能访问到</span><br></pre></td></tr></table></figure>
<p>使用名称路径也有一些特殊的情况：@module名称由”module:”前缀，<br>@external 名称由”external:”前缀，@event名称由”event:”前缀。</p>
<h3 id="JSDoc中的命令行参数"><a href="#JSDoc中的命令行参数" class="headerlink" title="JSDoc中的命令行参数"></a>JSDoc中的命令行参数</h3><p>使用JSDoc最基本的，像这样使用：<br><code>/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...</code><br>其中…是生成文档文件的路径。<br>JSDoc支持大量的命令行选项，其中许多选项有长和短两种形式。<br>选项    描述<br>-a <value>, –access <value>    只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。<br>-c <value>, –configure <value>    JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。<br>-d <value>, –destination <value>    输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。<br>–debug    打印日志信息，可以帮助调试JSDoc本身的问题。<br>-e <value>, –encoding <value>    当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。<br>-h, –help    显示JSDoc的命令行选项的信息，然后退出。<br>–match <value>    只有运行测试，其名称中包含value。<br>–nocolor    当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。<br>-p, –private    将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。<br>-P, –package    包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。<br>–pedantic    将错误视为致命错误，将警告视为错误。默认为false。<br>-q <value>, –query <value>    一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&amp;baz=true。<br>-r, –recurse    扫描源文件和导览时递归到子目录。<br>-R, –readme    用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。<br>-t <value>, –template <value>    用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。<br>-T, –test    运行JSDoc的测试套件，并把结果打印到控制台。<br>-u <value>, –tutorials <value>    导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。<br>-v, –version    显示JSDoc的版本号，然后退出。<br>–verbose    日志的详细信息到控制台JSDoc运行。默认为false。<br>-X, –explain    以JSON格式转储所有的doclet到控制台，然后退出。</value></value></value></value></value></value></value></value></value></value></value></value></value></value></value></p>
<p>示例：<br>使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中：<br>  /path/to/jsdoc src -r -c /path/to/my/conf.json -d docs<br>运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息：<br>  /path/to/jsdoc -T –match tag –verbose</p>
<h3 id="用conf-json配置JSDoc"><a href="#用conf-json配置JSDoc" class="headerlink" title="用conf.json配置JSDoc"></a>用conf.json配置JSDoc</h3><p>Configuration File(配置文件)<br>  要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json。<br>  默认的jsDoc配置文件conf.json.EXAMPLE</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;tags&quot;: &#123;</span><br><span class="line">		&quot;allowUnknownTags&quot;: true,</span><br><span class="line">		&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;,</span><br><span class="line">		&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;plugins&quot;: [],</span><br><span class="line">	&quot;templates&quot;: &#123;</span><br><span class="line">		&quot;cleverLinks&quot;: false,</span><br><span class="line">		&quot;monospaceLinks&quot;: false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Specifying input files(指定输入文件)<br>  source选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档。 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;source&quot;: &#123;</span><br><span class="line">	&quot;include&quot;: [ /* array of paths to files to generate documentation for */ ],</span><br><span class="line">	&quot;exclude&quot;: [ /* array of paths to exclude */ ],</span><br><span class="line">	&quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;,</span><br><span class="line">	&quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Incorporating command-line options into the configuration file(合并命令行选项到配置文件)<br>  它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。<br>  要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;opts&quot;: &#123;</span><br><span class="line">	&quot;template&quot;: &quot;templates/default&quot;,  // same as -t templates/default</span><br><span class="line">	&quot;encoding&quot;: &quot;utf8&quot;,               // same as -e utf8</span><br><span class="line">	&quot;destination&quot;: &quot;./out/&quot;,          // same as -d ./out/</span><br><span class="line">	&quot;recurse&quot;: true,                  // same as -r</span><br><span class="line">	&quot;tutorials&quot;: &quot;path/to/tutorials&quot;, // same as -u path/to/tutorials</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Plugins（插件）<br>  要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。<br>  示例：<br>  例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">	&quot;plugins/markdown&quot;,</span><br><span class="line">	&quot;plugins/summarize&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Tags and tag dictionaries(标签和标签字典)<br>  tags选项控制哪些JSDoc标签允许被使用和解析。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;tags&quot;: &#123;</span><br><span class="line">	&quot;allowUnknownTags&quot;: true,</span><br><span class="line">	&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置JSDoc的默认模板"><a href="#配置JSDoc的默认模板" class="headerlink" title="配置JSDoc的默认模板"></a>配置JSDoc的默认模板</h3><pre><code>JSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。
要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。

Generating pretty-printed source files（生成适合打印的文档）
    默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。
    要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。
    使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。
Copying static files to the output directory(复制静态文件到输出目录)
    SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。
    在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。
    例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。
Showing the current date in the page footer（在页脚显示当前日期）
    默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。
    在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。
Showing longnames in the navigation column（在导航栏中显示长文件名）
    默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。
    例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。
    此选项在JSDoc3.4.0及更高版本中可用。
Overriding the default template&apos;s layout file（重写默认模板的布局文件）
    默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。
    特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。
    要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。
    路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。
</code></pre><h3 id="块标签和内联标签"><a href="#块标签和内联标签" class="headerlink" title="块标签和内联标签"></a>块标签和内联标签</h3><pre><code>JSDoc支持两种不同类型的标签：
</code></pre><ol>
<li>块标签, 这是在一个JSDoc注释的最高级别。</li>
<li>内联标签, 块标签文本中的标签或说明。<br>块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。<br>块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。<br>内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（<a>）。<br>内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。<br>如果你的标签文本中包含右花括号（}），则必须用反斜线（ \ ）进行转义。<br>在内联标签后,你并不需要使用一个换行符。<br>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Shoe类，一双鞋子</span><br><span class="line"> * @param color</span><br><span class="line"> * @param size</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">const Shoe = function (color, size)&#123;</span><br><span class="line">	this.color = color;</span><br><span class="line">	this.size = size;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * Set shoe&apos;s color. Use &#123;@link Shoe#setSize&#125; to set the shoe size</span><br><span class="line"> * @param color</span><br><span class="line"> */</span><br><span class="line">Shoe.prototype.setColor = function (color) &#123;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 设置鞋子的尺寸</span><br><span class="line"> * @param size</span><br><span class="line"> */</span><br><span class="line">Shoe.prototype.setSize = function (size) &#123;</span><br><span class="line">	this.size = size;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 设置花边的颜色和样式</span><br><span class="line"> * @param color</span><br><span class="line"> * @param type</span><br><span class="line"> */</span><br><span class="line">Shoe.prototype.setLaceType = function (color, type) &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br><span class="line">var shoe1 = new Shoe(&apos;red&apos;, 12);</span><br></pre></td></tr></table></figure>
</a></li>
</ol>
<h3 id="关于JSDoc插件"><a href="#关于JSDoc插件" class="headerlink" title="关于JSDoc插件"></a>关于JSDoc插件</h3><pre><code>Creating and Enabling a Plugin（创建并启用插件）
    创建并启用新JSDoc插件,需要两个步骤：
        创建一个包含你的插件代码的JavaScript模块.
        将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。
        如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。
Authoring JSDoc 3 Plugins（创建JSDoc3插件）
    JSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果：
</code></pre><ol>
<li>定义事件处理程序</li>
<li>定义标签</li>
<li><p>定义一个抽象语法树节点的访问者<br>Event Handlers（事件处理程序）<br>事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。<br>事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。<br>事件: beforeParse – beforeParse事件在解析开始之前被触发。<br>事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。<br>事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。<br>事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。<br>事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。<br>事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。<br>事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。<br>Tag Definitions （标签定义）<br>添加标签到标签字典是影响文档生成的一个中级方式。<br>在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。<br>当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。<br>The Dictionary（字典）<br>Node Visitors（节点访问者）<br>Reporting Errors(报告错误)</p>
<h3 id="使用Markdown插件"><a href="#使用Markdown插件" class="headerlink" title="使用Markdown插件"></a>使用Markdown插件</h3><p>Enabling the Markdown plugin(启用markdown插件)<br>要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。<br>Converting Markdown in additional JSDoc tags（在额外的JSDoc标签中转换Markdown）<br>默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。<br>您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。<br>Excluding the default tags from Markdown processing（剔除markdown默认处理的标签）<br>为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。<br>Hard-wrapping text at line breaks （用换行符换行文本）<br>默认情况下，Markdown插件不处理换行符换行的文本。<br>Adding ID attributes to headings（添加ID属性到标题标签）<br>默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。</p>
<h3 id="Tutorials-教程"><a href="#Tutorials-教程" class="headerlink" title="Tutorials 教程"></a>Tutorials 教程</h3><p>JSDoc允许你的API文档的页面旁边包含教程。<br>您可以使用此功能来为您的API提供详细的使用说明，如“入门”指南或实现一个功能的一步一步的过程。</p>
<p>Adding tutorials（添加教程）<br>添加教程到您的API文档，可以通过–tutorials 或 -u 选项运行JSDoc，并提供JSDoc要搜索的教程目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsdoc -u path/to/tutorials path/to/js/files</span><br></pre></td></tr></table></figure>
<p>Configuring titles, order, and hierarchy （配置标题，顺序和层次结构）<br>默认情况下，JSDoc使用的文件名作为教程标题，并且所有的教程都在同一层次。<br>您可以使用JSON文件为每个教程提供标题并指示文档中的教程应如何排序和分组。<br>Linking to tutorials from API documentation（从API文档链接到教程）<br>@tutorial 块标签<br>{@tutorial} 内联标签</p>
<h3 id="包含Package（包）文件"><a href="#包含Package（包）文件" class="headerlink" title="包含Package（包）文件"></a>包含Package（包）文件</h3><p>包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。<br>当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。<br>示例，默认的模板在文档中显示项目的名称和版本号。<br>在源路径中包含一个包文件:<br>  jsdoc path/to/js path/to/package/package.json<br>使用 -P/–package 选项：<br>  jsdoc –package path/to/package/package-docs.json path/to/js    </p>
<h3 id="包含-README-文件"><a href="#包含-README-文件" class="headerlink" title="包含 README 文件"></a>包含 README 文件</h3><p>有两种方法可以将 README 文件中的信息合并到您的文档：<br>在源路径中包含一个 README 文件:<br>jsdoc path/to/js path/to/readme/README.md<br>使用 -R/–readme 选项：<br>jsdoc –readme path/to/readme/README path/to/js</p>
<blockquote>
<p>   参考文档：<br><a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="noopener">jsDoc文档</a>    </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数传参方式--按值传递</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<p>一直以为js函数传参方式–按引用传递，原来我一直错了。通过查阅资料彻底了解js函数传参是按值传递的。<br><strong>要搞清楚js函数传参方式，我们先需要具备一些基础知识。</strong></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><pre><code>基本类型值: Undefined,Null,Boolean,Number,String。
引用类型值: Object,Array,Function,Date等。
</code></pre><h1 id="变量的复制"><a href="#变量的复制" class="headerlink" title="变量的复制"></a>变量的复制</h1><h2 id="基本类型的复制"><a href="#基本类型的复制" class="headerlink" title="基本类型的复制"></a>基本类型的复制</h2><pre><code>    众所周知，js中变量的基本类型和引用类型保存方式是不同的，这也就导致变量复制时也就不同了。
如果从一个变量向另一个变量复制基本类型的值时，会将前者的值克隆一个，然后将克隆的值赋值到后者，
因此这两个值是完全独立的，只是他们的value相同而已。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num1 = 10;</span><br><span class="line">var num2 = num1;</span><br><span class="line">console.log(num2);//10</span><br></pre></td></tr></table></figure>

    上面的num1中被保存的值为10，当把num1的值赋值给num2时，num2的值也为10。
但是这两个10是完全独立的，num2中的10只是被克隆出来的，相当于我写了一个word文档，
把它放到了num1的文件夹中，然后我再复制这个word文档，就叫word副本吧，然后把这个副本放到num2的文件夹下，
这两个word文档是完全一样的，修改任何一个都不会影响另一个。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num2 += 1;</span><br><span class="line">console.log(num1); //10</span><br><span class="line">console.log(num2); //11</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="引用类型的复制"><a href="#引用类型的复制" class="headerlink" title="引用类型的复制"></a>引用类型的复制</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  name : &quot;111&quot;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">console.log(obj2.name); //111</span><br><span class="line">obj2.name = &quot;222&quot;;</span><br><span class="line">console.log(obj1.name); //222</span><br></pre></td></tr></table></figure>

    第一次打印出的结果为“111”，这个我们很容易理解，但是第二次打印出来的是“222”，有点莫名其妙了。
这就是引用类型和基本类型的不同之处了。复制对象时并不会在堆内存中新生成一个一模一样的对象，
只是多了一个保存指向这个对象指针的变量罢了。将obj1的值复制给obj2，而这个值的副本实际上是一个指针，
这个指针指向存储在堆中的一个对象，也就是说创建了一个新的内存地址传给了obj2，obj1和obj2两个变量同时指向了同一个Object，
当去改变这个对象时，他们的值都会改变，也就是说他们中任何一个作出的改变都会反映在另一个身上。
下面的简易图可能更明了些。
</code></pre><p><img src="http://oxpnrlb4j.bkt.clouddn.com/%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6.png" alt="引用复制"></p>
<h1 id="函数参数的传递（按值传递）"><a href="#函数参数的传递（按值传递）" class="headerlink" title="函数参数的传递（按值传递）"></a>函数参数的传递（按值传递）</h1><h2 id="基本类型传递参数（）"><a href="#基本类型传递参数（）" class="headerlink" title="基本类型传递参数（）"></a>基本类型传递参数（）</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count = 10;</span><br><span class="line">function num(num1)&#123;</span><br><span class="line">   num1 = 1;</span><br><span class="line">   return num1;</span><br><span class="line">&#125;</span><br><span class="line">var result = num(count);</span><br><span class="line">console.log(result); //1</span><br><span class="line">console.log(count); //10，并未变成1</span><br></pre></td></tr></table></figure>

    这个例子很容易理解，实际就是创建了一个count的副本，然后把count的副本的值传入参数中，
因为函数中定义了参数的值，所以1就将10覆盖了，最后的result返回1，而count并未发生变化。
</code></pre><h2 id="引用类型传递参数（按值传递）"><a href="#引用类型传递参数（按值传递）" class="headerlink" title="引用类型传递参数（按值传递）"></a>引用类型传递参数（按值传递）</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person  = &#123;</span><br><span class="line">	name : &quot;Tom&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function obj(peo)&#123;</span><br><span class="line">	// PS：这里 peo 对象和 person 对象的内存地址一模一样，所以后面两个才会同时改变</span><br><span class="line">	peo.name = &quot;Jerry&quot;;</span><br><span class="line">	return peo;</span><br><span class="line">&#125;</span><br><span class="line">var result = obj(person);</span><br><span class="line">console.log(result.name); // Jerry</span><br><span class="line">console.log(person.name); // Jerry</span><br></pre></td></tr></table></figure>

    在上面的例子中，把person复制传入obj()中，peo和person指向了同一个对象，而在peo中修改了name属性，
其实修改了它们共同指向的对象的name属性，相对应的外部person所引用的name属性也就改变了，
所以打印出来的为Jerry。其实这个乍一看，感觉引用类型的参数是按照引用传递的，
这就是我最初犯得错误。
再来看一个例子。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">	name : &quot;Tom&quot;</span><br><span class="line">&#125;; </span><br><span class="line">function obj(peo)&#123;</span><br><span class="line">	// PS：这里在函数里面新建了一个对象 peo，其内存地址和 person 对象内存地址不一样，所以两个对象不相干涉 </span><br><span class="line">	peo = &#123;</span><br><span class="line">	   name : &quot;Jerry&quot;</span><br><span class="line">	&#125;;</span><br><span class="line">	return peo;</span><br><span class="line">&#125;</span><br><span class="line">var result = obj(person);</span><br><span class="line">console.log(result.name);// Jerry</span><br><span class="line">console.log(person.name);// Tom</span><br></pre></td></tr></table></figure>

    上面的例子中，在函数中重新定义了一个对象，也就是现在堆内存中有两个对象，
外部的person指向的是老的对象，被传入参数后指向的是新定义的对象，所以调用后返回的值是新定义的对象的值。
如果是参数是按引用传递的，那么person.name打印出来的结果为Jerry，从这点可以得出参数是按值传递的（有的地方叫做按共享传递）。
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>JavaScript中的函数不存在按引用传递，所有参数都是按值传递！<br>    引用类型的变量本就是一个引用，它的值是堆内存中Object的地址，<br>    当使用按值传递时传递的值本就是一个地址，所以在函数中对参数进行操作会影响到函数外对应的变量。</strong></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/dgjamin/p/4337677.html" target="_blank" rel="noopener">JavaScript中函数参数的按值传递与按引用传递（即按地址传递）</a><br>    <a href="http://blog.csdn.net/allenliu6/article/details/52516605" target="_blank" rel="noopener">JS函数参数都是按值传递的！</a><br>    <a href="http://www.cnblogs.com/open-wang/p/5208606.html" target="_blank" rel="noopener">js函数中参数的传递</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-1.html</url>
    <content><![CDATA[<h2 id="刚下班回家，最近打算利用空余时间撸函数式编程"><a href="#刚下班回家，最近打算利用空余时间撸函数式编程" class="headerlink" title="刚下班回家，最近打算利用空余时间撸函数式编程"></a>刚下班回家，最近打算利用空余时间撸函数式编程</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="一等公民的函数"><a href="#一等公民的函数" class="headerlink" title="一等公民的函数"></a>一等公民的函数</h3><ol>
<li>与其他数据类型一样，可以把函数存在数组里，当作参数传递，赋值给变量…等等。</li>
</ol>
<h3 id="纯函数的理解"><a href="#纯函数的理解" class="headerlink" title="纯函数的理解"></a>纯函数的理解</h3><ol>
<li><p>定义：纯函数的定义是因为对相同的输入它保证能返回相同的输出。    </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xs = [1,2,3,4,5];</span><br><span class="line">// 纯的</span><br><span class="line">xs.slice(0,3);</span><br><span class="line">//=&gt; [1,2,3]</span><br><span class="line">xs.slice(0,3);</span><br><span class="line">//=&gt; [1,2,3]</span><br><span class="line"></span><br><span class="line">// 不纯的</span><br><span class="line">xs.splice(0,3);</span><br><span class="line">//=&gt; [1,2,3]</span><br><span class="line">xs.splice(0,3);</span><br><span class="line">//=&gt; [4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>纯函数中的副作用<br> 副作用的定义：只要是跟函数外部环境发生的交互就都是副作用（更改文件系统、往数据库插入记录）</p>
</li>
<li>纯函数的特点<br> 可缓存性（Cacheable）<br> 可移植性／自文档化（Portable / Self-Documenting）<br> 可测试性（Testable）<br> 合理性（Reasonable）<br> 合理性（Reasonable）</li>
</ol>
<h3 id="柯里化（curry）"><a href="#柯里化（curry）" class="headerlink" title="柯里化（curry）"></a>柯里化（curry）</h3><ol>
<li><p>定义：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var add = function (x) &#123;</span><br><span class="line">	return function (y) &#123;</span><br><span class="line">		return x + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var addTen = add(10)</span><br><span class="line">console.log(addTen(1)) // 11</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var curry = require(&apos;lodash&apos;).curry; // lodash.js是一个工具函数库</span><br><span class="line">var match = curry(function (what, str) &#123;</span><br><span class="line">	return str.match(what)</span><br><span class="line">&#125;)</span><br><span class="line">// 使用</span><br><span class="line">**match(/\s+/g, &apos;hello world&apos;) // [&apos; &apos;]**</span><br><span class="line">**match(/\s+/g)(&apos;hello world&apos;) // [&apos; &apos;]**</span><br><span class="line">var hasSpaces = match(/\s+/g) // function (x) &#123; return x.match(/\s+/g) &#125;</span><br><span class="line">hasSpaces(&apos;hello world&apos;) // [&apos; &apos;]</span><br><span class="line"></span><br><span class="line">// 再来一个列子</span><br><span class="line">var curry = require(&apos;lodash&apos;).curry; // lodash.js是一个工具函数库</span><br><span class="line">var replace = curry(function(what, replacement, str) &#123;</span><br><span class="line">  return str.replace(what, replacement);</span><br><span class="line">&#125;)</span><br><span class="line">var noVowels = replace(/[aeiou]/ig) (传入第一个参数)// function (replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;</span><br><span class="line">var censored = noVowels(&apos;*&apos;) (传入第二个参数)// function (x) &#123; return x.replace(/[aeiou]/ig, &apos;*&apos;) &#125;</span><br><span class="line">var end = censored(&apos;Chocolate Rain&apos;) (传入第三个参数)// &apos;Ch*c*l*t* R**n&apos;</span><br></pre></td></tr></table></figure>
<p> 通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。<br> 只传给函数一部分参数通常也叫做局部调用（partial application）</p>
<p> <strong>高阶函数：参数或返回值为函数的函数（higher order function）</strong></p>
<p> 当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。<br> curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。<br> <em>记于2017-07-19 23:14</em></p>
<blockquote>
<p>参考<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#总结" target="_blank" rel="noopener">JS函数式编程指南</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-2</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-2.html</url>
    <content><![CDATA[<h2 id="代码组合（compose）"><a href="#代码组合（compose）" class="headerlink" title="代码组合（compose）"></a>代码组合（compose）</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="先上手一个组合函数的例子"><a href="#先上手一个组合函数的例子" class="headerlink" title="先上手一个组合函数的例子"></a>先上手一个组合函数的例子</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compose = function (f, g) &#123; // 执行顺序为从右到左</span><br><span class="line">	return function (x) &#123;</span><br><span class="line">		return f(g(x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// f 和 g 都是函数，x 是在它们之间通过“管道”传输的值。</span><br><span class="line">var toUppercase = function (x) &#123; return x.toUpperCase() &#125;;</span><br><span class="line">var exclaim = function (x) &#123; return `$&#123;x&#125;!` &#125;;</span><br><span class="line">var shout = compose(exclaim, toUppercase);</span><br><span class="line">var test = shout(&apos;I am fanerge&apos;)</span><br><span class="line">console.log(test) // I AM FANERGE!</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="组合的特性"><a href="#组合的特性" class="headerlink" title="组合的特性"></a>组合的特性</h3><pre><code>1. 结合律（associativity）    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var associative = compose(f, compose(g, h)) === compose(compose(f, g), h)</span><br><span class="line">// 必须满足相同的执行顺序及h-g-f（从右到左）</span><br><span class="line">var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);</span><br><span class="line">// 或</span><br><span class="line">var last = compose(head, reverse);</span><br><span class="line">var loudLastUpper = compose(exclaim, toUpperCase, last);</span><br><span class="line">// 或</span><br><span class="line">var last = compose(head, reverse);</span><br><span class="line">var angry = compose(exclaim, toUpperCase);</span><br><span class="line">var loudLastUpper = compose(angry, last);</span><br></pre></td></tr></table></figure>

**其实只要把握好（从右向左执行的顺序即可）**
2. pointfree模式
定义：永远不必说出你的数据，函数无须提及将要操作的数据是什么样的。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//非 pointfree，因为提到了数据：word</span><br><span class="line">var snakeCase = function (word) &#123;</span><br><span class="line">	return word.toLowerCase().replace(/\s+/ig, &apos;_&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// pointfree</span><br><span class="line">var snakeCase = compose(replace(/\s+/ig, &apos;_&apos;), toLowerCase)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	// 正确做法：每个函数都接受一个实际的参数</span><br><span class="line">	var latin = compose(map(angry), reverse) // angry = compose(exclaim, toUpperCase)</span><br><span class="line">	latin([&quot;frog&quot;, &quot;eyes&quot;]) // [&apos;EYES!&apos;,&apos;FROG!&apos;]</span><br><span class="line"></span><br><span class="line">	// 不纯的 trace 函数来追踪代码的执行情况。</span><br><span class="line">	var trace = curry(function(tag, x)&#123;</span><br><span class="line">	  console.log(tag, x);</span><br><span class="line">	  return x;</span><br><span class="line">	&#125;);</span><br><span class="line">	// 使用</span><br><span class="line">	var dasherize = compose(join(&apos;-&apos;), toLower, trace(&quot;after split&quot;), split(&apos; &apos;), replace(/\s&#123;2,&#125;/ig, &apos; &apos;));</span><br><span class="line">	// after split [ &apos;The&apos;, &apos;world&apos;, &apos;is&apos;, &apos;a&apos;, &apos;vampire&apos; ]</span><br><span class="line"></span><br><span class="line">### 组合背后的理论 --- 范畴学（category theory）</span><br><span class="line">	作用：范畴学主要处理对象（object）、态射（morphism）和变化式（transformation）</span><br><span class="line">	**对象的搜集**</span><br><span class="line">	对象就是数据类型，例如 String、Boolean、Number 和 Object 等等。</span><br><span class="line">	通常我们把数据类型视作所有可能的值的一个集合（set）。</span><br><span class="line">	**态射的搜集**</span><br><span class="line">	态射是标准的、普通的纯函数。</span><br><span class="line">	**态射的组合**</span><br><span class="line">	var g = function(x)&#123; return x.length; &#125;;</span><br><span class="line">	var f = function(x)&#123; return x === 4; &#125;;</span><br><span class="line">	var isFourLetterWord = compose(f, g);</span><br><span class="line">	var test = isFourLetterWord(&apos;fanerge&apos;) // false</span><br><span class="line">	**identity 这个独特的态射**</span><br><span class="line">	identity 这个独特的态射</span><br></pre></td></tr></table></figure>

// id 的实用函数
var id = function (x) { return x };
// 结论成立
compose(id, f) === compose(f, id) === f;
总结：组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出

```
</code></pre><p>参考：</p>
<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#自由定理" target="_blank" rel="noopener">js函数式编程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-4</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4.html</url>
    <content><![CDATA[<h2 id="特百惠"><a href="#特百惠" class="headerlink" title="特百惠"></a>特百惠</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="强大的容器"><a href="#强大的容器" class="headerlink" title="强大的容器"></a>强大的容器</h3><pre><code>函数式的程序：即通过管道把数据在一系列纯函数间传递的程序。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.	// 先创建一个容器（container），这个容器必须能够装载任意类型的值，一个存放宝贵的数据的特殊盒子。</span><br><span class="line">	var Container = function (x) &#123;</span><br><span class="line">		this._value = x;</span><br><span class="line">	&#125;;	</span><br><span class="line">	// 作用容器的构造器（constructor）</span><br><span class="line">	Container.of = function (x) &#123;</span><br><span class="line">		return new Container(x);</span><br><span class="line">	&#125;;</span><br><span class="line">	// 测试容器</span><br><span class="line">	var test = Container.of(Container.of(&#123;name: &apos;fanerge&apos;&#125;))	</span><br><span class="line">	console.log(test)</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p>第一个functor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 操作容器中的值</span><br><span class="line">// (a -&gt; b) -&gt; Container a -&gt; Container b</span><br><span class="line">Container.prototype.map = function (f) &#123;</span><br><span class="line">	return Container.of(f(this._value))</span><br><span class="line">&#125;;	</span><br><span class="line">// 使用map方法</span><br><span class="line">Container.of(3).map(function (two) &#123;</span><br><span class="line">	return two + 2;</span><br><span class="line">&#125;);</span><br><span class="line">// Container(5)</span><br><span class="line">Container.of(&apos;fanerge&apos;).map(function (str) &#123; </span><br><span class="line">	return str.toUpperCase()</span><br><span class="line">&#125;);</span><br><span class="line">// Container(&apos;FANERGE&apos;)</span><br><span class="line">// 因为我们能够在不离开 Container 的情况下操作容器里面的值。这是非常了不起的一件事情。Container 里的值传递给 map 函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的 Container。这样做的结果是，我们能连续地调用 map，运行任何我们想运行的函数。</span><br></pre></td></tr></table></figure>
<p><strong>functor 是实现了 map 函数并遵守一些特定规则的容器类型。</strong><br>把值装进一个容器，而且只能使用 map 来处理它，让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。</p>
</li>
<li><p>薛定谔的Maybe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Maybe = function (x) &#123;</span><br><span class="line">	this._value = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.of = function (x) &#123;</span><br><span class="line">	return new Maybe(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.isNoting = function () &#123;</span><br><span class="line">	return (this._value == null || this._value === undefined)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.map = function (f) &#123;</span><br><span class="line">	return this.isNoting() ? Maybe.of(null) : Maybe.of(f(this._value));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.of(&apos;Malkovich Malkovich&apos;).map(_.match(/a/ig)) // Maybe([&apos;a&apos;, &apos;a&apos;]</span><br><span class="line">// map 完全有能力以 curry 函数的方式来“代理”任何 functor</span><br><span class="line">var map = curry(function (f, any_functor_at_all) &#123;</span><br><span class="line">	return any_functor_at_all.map(f);</span><br><span class="line">&#125;);</span><br><span class="line">// safeHead :: [a] -&gt; Maybe(a)</span><br><span class="line">var safeHead = function (xs) &#123;</span><br><span class="line">	return Maybe.of(xs[0]);</span><br><span class="line">&#125;;</span><br><span class="line">var streetName = _.compose(map(_.prop(&apos;street&apos;)), safeHead, _.prop(&apos;address&apos;));</span><br><span class="line">streetName(&#123;addresses: [&#123;street: &quot;Shady Ln.&quot;, number: 4201&#125;]&#125;); // Maybe(&quot;Shady Ln.&quot;)</span><br></pre></td></tr></table></figure>
<p><em>购物的例子</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// withdraw :: Number -&gt; Account -&gt; Maybe(Account)</span><br><span class="line">var withdraw = curry(function (amount, account) &#123;</span><br><span class="line">	return account.balance &gt;= amount ?</span><br><span class="line">		Maybe.of(&#123;balance: acount.balance - amount&#125;) :</span><br><span class="line">		Maybe.of(null);</span><br><span class="line">&#125;)</span><br><span class="line">// finishTransaction :: Account -&gt; String</span><br><span class="line">var finishTransaction = compose(remainingBalance, updateLedger); //// &lt;- 假定这两个函数已经在别处定义好了</span><br><span class="line">// getTwenty :: Account -&gt; Maybe(String)</span><br><span class="line">var getTwenty = compose(map(finishTransaction), withdraw(20));</span><br><span class="line">getTwenty(&#123;balance: 200.00&#125;); // Maybe(&quot;Your balance is $180.00&quot;)</span><br><span class="line">getTwenty(&#123; balance: 10.00&#125;); // Maybe(null)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b	</span><br><span class="line">var may = curry(function (x, f, m) &#123;</span><br><span class="line">	return m.isNoting() ? x : f(m._value);</span><br><span class="line">&#125;);</span><br><span class="line">// getTwenty :: Account -&gt; String</span><br><span class="line">var getTwenty = compose(</span><br><span class="line">	maybe(&quot;You&apos;re broke!&quot;, finishTransaction), withdraw(20)</span><br><span class="line">);	</span><br><span class="line">getTwenty(&#123; balance: 200.00&#125;); // &quot;Your balance is $180.00&quot;</span><br><span class="line">getTwenty(&#123; balance: 10.00&#125;); // &quot;You&apos;re broke!&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="“纯”错误处理"><a href="#“纯”错误处理" class="headerlink" title="“纯”错误处理"></a>“纯”错误处理</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Left 和 Right 是我们称之为 Either 的抽象类型的两个子类。</span><br><span class="line">var Left = function(x) &#123;</span><br><span class="line">  this.__value = x;</span><br><span class="line">&#125;</span><br><span class="line">Left.of = function(x) &#123;</span><br><span class="line">  return new Left(x);</span><br><span class="line">&#125;</span><br><span class="line">Left.prototype.map = function(f) &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Right = function(x) &#123;</span><br><span class="line">  this.__value = x;</span><br><span class="line">&#125;</span><br><span class="line">Right.of = function(x) &#123;</span><br><span class="line">  return new Right(x);</span><br><span class="line">&#125;</span><br><span class="line">Right.prototype.map = function(f) &#123;</span><br><span class="line">  return Right.of(f(this.__value));</span><br><span class="line">&#125;</span><br><span class="line">// 就像 Maybe 可以有个 maybe 一样，Either 也可以有一个 either。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。</span><br><span class="line">//  either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c</span><br><span class="line">var either = curry(function(f, g, e) &#123;</span><br><span class="line">  switch(e.constructor) &#123;</span><br><span class="line">	case Left: return f(e.__value);</span><br><span class="line">	case Right: return g(e.__value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//  zoltar :: User -&gt; _</span><br><span class="line">var zoltar = compose(console.log, either(id, fortune), getAge(moment()));</span><br><span class="line"></span><br><span class="line">zoltar(&#123;birthdate: &apos;2005-12-12&apos;&#125;);</span><br><span class="line">// &quot;If you survive, you will be 10&quot;</span><br><span class="line">// undefined</span><br><span class="line"></span><br><span class="line">zoltar(&#123;birthdate: &apos;balloons!&apos;&#125;);</span><br><span class="line">// &quot;Birth date could not be parsed&quot;</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

**取到容器里的东西**
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var IO = function (f) &#123;</span><br><span class="line">	this.__value = f;</span><br><span class="line">&#125;;</span><br><span class="line">IO.of = function (x) &#123;</span><br><span class="line">	return new IO(function () &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">IO.prototype.map = function (f) &#123;</span><br><span class="line">	return new IO(_.compose(f, this.__value));</span><br><span class="line">&#125;;</span><br><span class="line">// io_window_ :: IO Window</span><br><span class="line">var io_window = new IO(function () &#123; return window;&#125;)</span><br><span class="line">io_window.map(function (win) &#123; return win.innerWidth &#125;) // IO(1430)</span><br><span class="line">io_window.map(_.prop(&apos;location&apos;)).map(_.prop(&apos;href&apos;)).map(split(&apos;/&apos;)); // IO([&quot;http:&quot;, &quot;&quot;, &quot;localhost:8000&quot;, &quot;blog&quot;, &quot;posts&quot;])</span><br><span class="line">// $ :: String -&gt; IO [DOM]</span><br><span class="line">var $ = function(selector) &#123;</span><br><span class="line">  return new IO(function()&#123; return document.querySelectorAll(selector); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">$(&apos;#myDiv&apos;).map(head).map(function(div)&#123; return div.innerHTML; &#125;); // IO(&apos;I am some inner html&apos;)</span><br></pre></td></tr></table></figure>

**解析url参数**
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">纯代码库: lib/params.js</span><br><span class="line">var url = new IO(function () &#123; return window.location.href; &#125;);</span><br><span class="line">// toPairs = String -&gt; [[String]]</span><br><span class="line">var toPairs = compose(map(split(&apos;=&apos;), split(&apos;&amp;&apos;));</span><br><span class="line">// params :: String -&gt; [[String]]</span><br><span class="line">var params = conmpose(toPairs, last, split(&apos;?&apos;));</span><br><span class="line">// findParam = String -&gt; Io Maybe [String]</span><br><span class="line">var findParam = function (key) &#123;</span><br><span class="line">	return map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);</span><br><span class="line">&#125;;</span><br><span class="line">// 调用 __value() 来运行它！</span><br><span class="line">findParam(&apos;searchTerm&apos;).__value();</span><br><span class="line">// Maybe([&apos;searchTerm&apos;, &apos;wafflehouse&apos;])</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Postgres.connect :: Url -&gt; IO DbConnection</span><br><span class="line">// runQuery :: DbConnection -&gt; ResultSet</span><br><span class="line">// readFile :: String -&gt; Task Error String</span><br><span class="line">// Pure application</span><br><span class="line">//=====================</span><br><span class="line">//  dbUrl :: Config -&gt; Either Error Url</span><br><span class="line">var dbUrl = function(c) &#123;</span><br><span class="line">  return (c.uname &amp;&amp; c.pass &amp;&amp; c.host &amp;&amp; c.db)</span><br><span class="line">	? Right.of(&quot;db:pg://&quot;+c.uname+&quot;:&quot;+c.pass+&quot;@&quot;+c.host+&quot;5432/&quot;+c.db)</span><br><span class="line">	: Left.of(Error(&quot;Invalid config!&quot;));</span><br><span class="line">&#125;</span><br><span class="line">//  connectDb :: Config -&gt; Either Error (IO DbConnection)</span><br><span class="line">var connectDb = compose(map(Postgres.connect), dbUrl);</span><br><span class="line">//  getConfig :: Filename -&gt; Task Error (Either Error (IO DbConnection))</span><br><span class="line">var getConfig = compose(map(compose(connectDB, JSON.parse)), readFile);</span><br><span class="line">// Impure calling code</span><br><span class="line">//=====================</span><br><span class="line">getConfig(&quot;db.json&quot;).fork(</span><br><span class="line">  logErr(&quot;couldn&apos;t read file&quot;), either(console.log, map(runQuery))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="一些理论"><a href="#一些理论" class="headerlink" title="一些理论"></a>一些理论</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// identity</span><br><span class="line">map(id) === id;</span><br><span class="line">// composition</span><br><span class="line">compose(map(f), map(g)) === map(compose(f, g));</span><br></pre></td></tr></table></figure>
</code></pre><p>参考：</p>
<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#自由定理" target="_blank" rel="noopener">js函数式编程</a>    </p>
</blockquote>
<p>参考：</p>
<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#自由定理" target="_blank" rel="noopener">js函数式编程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-3</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-3.html</url>
    <content><![CDATA[<h2 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="声明式代码"><a href="#声明式代码" class="headerlink" title="声明式代码"></a>声明式代码</h3><ol>
<li><p>理解命令式与声明式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 命令式</span><br><span class="line">var makes = [];</span><br><span class="line">for (let i, len = cars.length; i++) &#123;</span><br><span class="line">	makes.push(cars[i]make)	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明式</span><br><span class="line">var makes = cars.map((car) =&gt; &#123; return car.make; &#125;)</span><br><span class="line">总结：</span><br><span class="line">命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来...实在是直白得有些露骨。</span><br><span class="line">何收集，都有很大的自由度。它指明的是做什么，不是怎么做。因此，它是正儿八经的声明式代码。</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 命令式 --- 硬编码了那种一步接一步的执行方式。</span><br><span class="line">var authenticate = function (form) &#123;</span><br><span class="line">	var user = toUser(form);</span><br><span class="line">	return logIn(user);</span><br><span class="line">&#125;</span><br><span class="line">// 声明式 --- 用户验证是 toUser 和 logIn 两个行为的组合。</span><br><span class="line">var authenticate = compose(logIn, toUser)</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例<a href="https://github.com/fanerge/Functional-Programming" target="_blank" rel="noopener">函数式编程demo</a><br> 1.根据特定搜索关键字构造 url<br> 2.向 flickr 发送 api 请求 （不纯）<br> 3.把返回的 json 转为 html 图片<br> 4.把图片放到屏幕上 （不纯）</p>
</li>
<li>有原则的重构<br> // map 的组合律<br> var law = compose(map(f), map(g)) === map(compose(f, g))</li>
</ol>
<h3 id="Hindley-Milner-类型签名"><a href="#Hindley-Milner-类型签名" class="headerlink" title="Hindley-Milner 类型签名"></a>Hindley-Milner 类型签名</h3><ol>
<li>初始类型<br> 类型签名作用：短短一行，就能暴露函数的行为和目的，可以用类型签名生成文档，也可以用注释来达到区分类型的目的。</li>
<li><p>Hindley-Milner 系统</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// capitalize :: String -&gt; String （表示输入为string，输出也为string）</span><br><span class="line">var capitalize = function (s) &#123;</span><br><span class="line">	return toUpperCase(head(s)) + toLowerCase(tail(s));</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">capitalize(&apos;fanerge&apos;) // &apos;Fanerge&apos;</span><br><span class="line"></span><br><span class="line">//  id :: a -&gt; a （同一类型的）</span><br><span class="line">var id = function(x)&#123; return x; &#125;</span><br><span class="line"></span><br><span class="line">//  map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line">var map = curry(function(f, xs)&#123;</span><br><span class="line">  return xs.map(f);</span><br><span class="line">&#125;);</span><br><span class="line">// 说明</span><br><span class="line">给定一个从 a 到 b 的函数和一个 a 类型的数组作为参数，它就能返回一个 b 类型的数组。</span><br></pre></td></tr></table></figure>
</li>
<li><p>缩小可能性范围（parametricity）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// head :: [a] -&gt; a</span><br><span class="line">它接受 [a] 返回 a,参数是个数组</span><br></pre></td></tr></table></figure>
</li>
<li><p>自由定理（free theorems）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// head :: [a] -&gt; a</span><br><span class="line">compose(f, head) == compose(head, map(f));</span><br><span class="line">等式左边说的是，先获取数组的头部（译者注：即第一个元素），然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：</p>
<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#自由定理" target="_blank" rel="noopener">js函数式编程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-5</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-5.html</url>
    <content><![CDATA[<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="pointed-functor"><a href="#pointed-functor" class="headerlink" title="pointed functor"></a>pointed functor</h3><pre><code>of 方法不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。
</code></pre><blockquote>
<p>  pointed functor 是实现了 of 方法的 functor。</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里的关键是把任意值丢到容器里然后开始到处使用 map 的能力。</span><br><span class="line">IO.of(&quot;tetris&quot;).map(concat(&quot; master&quot;)); // IO(&quot;tetris master&quot;)</span><br><span class="line">Maybe.of(1336).map(add(1)); // Maybe(1337)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="混合比喻"><a href="#混合比喻" class="headerlink" title="混合比喻"></a>混合比喻</h3><ol>
<li><p>例子</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//  readFile :: String -&gt; IO String</span><br><span class="line">var readFile = function(filename) &#123;</span><br><span class="line">  return new IO(function() &#123;</span><br><span class="line">	return fs.readFileSync(filename, &apos;utf-8&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  print :: String -&gt; IO String</span><br><span class="line">var print = function(x) &#123;</span><br><span class="line">  return new IO(function() &#123;</span><br><span class="line">	console.log(x);</span><br><span class="line">	return x;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  cat :: IO (IO String)</span><br><span class="line">var cat = compose(map(print), readFile);</span><br><span class="line"></span><br><span class="line">cat(&quot;.git/config&quot;)</span><br><span class="line">// IO(IO(&quot;[core]\nrepositoryformatversion = 0\n&quot;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>剥开洋葱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我说过 monad 像洋葱，可以使用一个叫作 join 的方法，来剥开。</span><br><span class="line">var mmo = Maybe.of(Maybe.of(&quot;nunchucks&quot;));</span><br><span class="line">// Maybe(Maybe(&quot;nunchucks&quot;))</span><br><span class="line">mmo.join();</span><br><span class="line">// Maybe(&quot;nunchucks&quot;)</span><br><span class="line"></span><br><span class="line">var ttt = Task.of(Task.of(Task.of(&quot;sewers&quot;)));</span><br><span class="line">// Task(Task(Task(&quot;sewers&quot;)));</span><br><span class="line">ttt.join()</span><br><span class="line">// Task(Task(&quot;sewers&quot;))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>   monad 是可以变扁（flatten）的 pointed functor。<br>    一个 functor，只要它定义个了一个 join 方法和一个 of 方法，并遵守一些定律，那么它就是一个 monad。</p>
</blockquote>
<pre><code>为Maybe实现join方法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Maybe.prototype.join = function () &#123;</span><br><span class="line">	return this.isNothing() ? Maybe.of(null) : this.__value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">//  join :: Monad m =&gt; m (m a) -&gt; m a</span><br><span class="line">var join = function(mma)&#123; return mma.join(); &#125;</span><br><span class="line"></span><br><span class="line">//  firstAddressStreet :: User -&gt; Maybe Street</span><br><span class="line">var firstAddressStreet = compose(</span><br><span class="line">  join, map(safeProp(&apos;street&apos;)), join, map(safeHead), safeProp(&apos;addresses&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">firstAddressStreet(</span><br><span class="line">  &#123;addresses: [&#123;street: &#123;name: &apos;Mulburry&apos;, number: 8402&#125;, postcode: &quot;WC2N&quot; &#125;]&#125;</span><br><span class="line">);</span><br><span class="line">// Maybe(&#123;name: &apos;Mulburry&apos;, number: 8402&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="chain-函数"><a href="#chain-函数" class="headerlink" title="chain 函数"></a>chain 函数</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用 chain封装（map的后面调用join）</span><br><span class="line">//  chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</span><br><span class="line">var chain = curry(function(f, m)&#123;</span><br><span class="line">  return m.map(f).join(); // 或者 compose(join, map(f))(m)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// map/join</span><br><span class="line">var firstAddressStreet = compose(</span><br><span class="line">  join, map(safeProp(&apos;street&apos;)), join, map(safeHead), safeProp(&apos;addresses&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// chain</span><br><span class="line">var firstAddressStreet = compose(</span><br><span class="line">  chain(safeProp(&apos;street&apos;)), chain(safeHead), safeProp(&apos;addresses&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Maybe.of(3).chain(function(three) &#123;</span><br><span class="line">  return Maybe.of(2).map(add(three));</span><br><span class="line">&#125;);</span><br><span class="line">// Maybe(5);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // 结合律</span><br><span class="line">compose(join, map(join)) == compose(join, join)</span><br></pre></td></tr></table></figure>

总结：monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。
monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。
</code></pre>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-6</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-6.html</url>
    <content><![CDATA[<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="应用-applicative-functor"><a href="#应用-applicative-functor" class="headerlink" title="应用 applicative functor"></a>应用 applicative functor</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container.of(2).chain(function(two) &#123;</span><br><span class="line">  return Container.of(3).map(add(two));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="瓶中之船"><a href="#瓶中之船" class="headerlink" title="瓶中之船"></a>瓶中之船</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ap 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。</span><br><span class="line">Container.prototype.ap = function(other_container) &#123;</span><br><span class="line">  return other_container.map(this.__value);</span><br><span class="line">&#125;</span><br><span class="line">Container.of(add(2)).ap(Container.of(3)); // Container(5)</span><br><span class="line"></span><br><span class="line">// all together now</span><br><span class="line">Container.of(2).map(add).ap(Container.of(3)); // Container(5</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="协调与激励"><a href="#协调与激励" class="headerlink" title="协调与激励"></a>协调与激励</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 帮助函数：</span><br><span class="line">//  $ :: String -&gt; IO DOM</span><br><span class="line">var $ = function(selector) &#123;</span><br><span class="line">  return new IO(function()&#123; return document.querySelector(selector) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  getVal :: String -&gt; IO String</span><br><span class="line">var getVal = compose(map(_.prop(&apos;value&apos;)), $);</span><br><span class="line"></span><br><span class="line">// Example:</span><br><span class="line">//  signIn :: String -&gt; String -&gt; Bool -&gt; User</span><br><span class="line">var signIn = curry(function(username, password, remember_me)&#123; /* signing in */  &#125;)</span><br><span class="line"></span><br><span class="line">IO.of(signIn).ap(getVal(&apos;#email&apos;)).ap(getVal(&apos;#password&apos;)).ap(IO.of(false));</span><br><span class="line">// IO(&#123;id: 3, email: &quot;gg@allin.com&quot;&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同一律（identity）</span><br><span class="line">	A.of(id).ap(v) == v</span><br><span class="line">	var v = Identity.of(&quot;Pillow Pets&quot;);</span><br><span class="line">	Identity.of(id).ap(v) == v</span><br><span class="line">同态（homomorphism）</span><br><span class="line">	A.of(f).ap(A.of(x)) == A.of(f(x))</span><br><span class="line">	Either.of(_.toUpper).ap(Either.of(&quot;oreos&quot;)) == Either.of(_.toUpper(&quot;oreos&quot;))</span><br><span class="line">互换（interchange）</span><br><span class="line">	v.ap(A.of(x)) == A.of(function(f) &#123; return f(x) &#125;).ap(v)</span><br><span class="line">	var v = Task.of(_.reverse);</span><br><span class="line">	var x = &apos;Sparklehorse&apos;;</span><br><span class="line">	v.ap(Task.of(x)) == Task.of(function(f) &#123; return f(x) &#125;).ap(v)</span><br><span class="line">组合（composition）</span><br><span class="line">	A.of(compose).ap(u).ap(v).ap(w) == u.ap(v.ap(w));</span><br><span class="line">	var u = IO.of(_.toUpper);</span><br><span class="line">	var v = IO.of(_.concat(&quot;&amp; beyond&quot;));</span><br><span class="line">	var w = IO.of(&quot;blood bath &quot;);</span><br><span class="line">	IO.of(_.compose).ap(u).ap(v).ap(w) == u.ap(v.ap(w))</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#自由定理" target="_blank" rel="noopener">js函数式编程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-一等函数与Applicative编程</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="一等函数与Applicative编程"><a href="#一等函数与Applicative编程" class="headerlink" title="一等函数与Applicative编程"></a>一等函数与Applicative编程</h3><h4 id="函数式一等公民"><a href="#函数式一等公民" class="headerlink" title="函数式一等公民"></a>函数式一等公民</h4><pre><code>函数式编程语言应该是促进创造和使用函数的。
函数式一等公民：函数可以作为数组的成员、对象的方法、存储为变量等等。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例如存储为数组的成员</span><br><span class="line">var fortytwos = [42, function () &#123; return 42 &#125;]</span><br></pre></td></tr></table></figure>

高阶函数的定义：以函数作为参数或者返回函数。
多种javascript编程方式
    命令式编程 -- 通过详细描述行为的编程方式。
    基于原型的面向对象编程 -- 基于原型对象及其实例的编程方式。
    元编程 -- 对JavaScript执行模型数据进行编写和操作的编程方式。    
</code></pre><h3 id="Applicative编程"><a href="#Applicative编程" class="headerlink" title="Applicative编程"></a>Applicative编程</h3><pre><code>定义：函数A作为参数提供给函数B。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">*map* 遍历集合并对其每一个值调用一个函数，返回结果的集合。</span><br><span class="line">function doubleAll(array) &#123;</span><br><span class="line">	return _.map(array, function (n) &#123;</span><br><span class="line">		return n*2;	</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(doubleAll(nums)) // [2, 4, 6, 8, 10]</span><br><span class="line"></span><br><span class="line">*reduce* 利用函数将值的集合合并成一个值，该函数接收一个累积值和本次处理的值</span><br><span class="line">function average (array) &#123;</span><br><span class="line">	let sum = _.reduce(array, function (a, b)&#123;</span><br><span class="line">		return a + b;</span><br><span class="line">	&#125;)</span><br><span class="line">	return sum / array.length;</span><br><span class="line">&#125;</span><br><span class="line">console.log(average(nums)) // 3</span><br><span class="line"></span><br><span class="line">*filter* 对集合每一个值调用函数，若返回为true并添加到新集合中去，并返回新集合</span><br><span class="line">function onlyEven(array) &#123;</span><br><span class="line">	return _.filter(array, function (n)&#123;</span><br><span class="line">		return n%2 === 0	</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(onlyEven(nums))</span><br><span class="line"></span><br><span class="line">集合中心编程</span><br><span class="line">var test = _.map(&#123;a: 1, b: 2&#125;, function (v, k) &#123;</span><br><span class="line">	return [k, v];</span><br><span class="line">&#125;)</span><br><span class="line">console.dir(test) // [[&apos;a&apos;, 1], [&apos;b&apos;, 2]]</span><br><span class="line"></span><br><span class="line">Applicative编程的其他实例</span><br><span class="line"></span><br><span class="line">*reduceRight*（从右到左）</span><br><span class="line">var nums = [100, 2, 25];</span><br><span class="line">function div(x, y) &#123;</span><br><span class="line">	return x/y;</span><br><span class="line">&#125;</span><br><span class="line">var test = _.reduceRight(nums, div);</span><br><span class="line">console.log(test) // 0.125</span><br><span class="line"></span><br><span class="line">*find* 它接收一个集合和一个谓词函数，并返回该谓词为true时的第一个元素。</span><br><span class="line">// 其中谓词函数为：_.isEqual、_.isEmpty、_.isElement...</span><br><span class="line">var dd = _.find([&apos;a&apos;, &apos;b&apos;, &apos;3&apos;, 4], _.isNumber);</span><br><span class="line">console.log(dd) // 4</span><br><span class="line"></span><br><span class="line">*reject* 本质为_.filter的逆命题</span><br><span class="line">var dd = _.reject([&apos;a&apos;, &apos;b&apos;, &apos;3&apos;, 4], _.isNumber);</span><br><span class="line">console.log(dd) // [&apos;a&apos;, &apos;b&apos;, &apos;3&apos;]</span><br><span class="line">// 另一种实现</span><br><span class="line">function complement(pred) &#123;</span><br><span class="line">	return function () &#123;</span><br><span class="line">		return !pred.apply(null, _.toArray(arguments));</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var d1 = _.filter([&apos;a&apos;, &apos;b&apos;, &apos;3&apos;, 4], complement(_.isNumber))</span><br><span class="line">console.log(d1) // [&apos;a&apos;, &apos;b&apos;, &apos;3&apos;]</span><br><span class="line"></span><br><span class="line">*all* 当对于集合中所有元素都满足谓词时返回true，否则返回false</span><br><span class="line">var dd = _.all([1, 2, 3, &apos;4&apos;], _.isNumber)</span><br><span class="line">console.log(dd) // false</span><br><span class="line"></span><br><span class="line">*any* 当对于集合中有满足谓词时返回true，否则返回false</span><br><span class="line">var dd = _.any([1, 2, 3, &apos;4&apos;], _.isNumber)</span><br><span class="line">console.log(dd) // true</span><br><span class="line"></span><br><span class="line">*sortBy* 接收一个集合和函数来对该集合排序</span><br><span class="line">var people = [&#123;name: &apos;Rick&apos;, age: 30&#125;,&#123;name: &apos;Jaka&apos;, age: 24&#125;];</span><br><span class="line">var list = _.sortBy(people, function (p) &#123;</span><br><span class="line">	return p.name</span><br><span class="line">&#125;)</span><br><span class="line">console.log(list) // [&#123;name: &apos;Jaka&apos;, age: 24&#125;, &#123;name: &apos;Rick&apos;, age: 30&#125;]</span><br><span class="line"></span><br><span class="line">*groupBy* 接收一个集合和一个条件函数，并返回一个对象，k为传入的条件，v为对应的元素</span><br><span class="line">var albums = [</span><br><span class="line">	&#123;title: &apos;sabba&apos;, genre: &apos;metal&apos;&#125;,</span><br><span class="line">	&#123;title: &apos;scientist&apos;, genre: &apos;dub&apos;&#125;,</span><br><span class="line">	&#123;title: &apos;undertow&apos;, genre: &apos;metal&apos;&#125;,</span><br><span class="line">]</span><br><span class="line">var list = _.groupBy(albums, function (a) &#123;</span><br><span class="line">	return a.genre;</span><br><span class="line">&#125;)</span><br><span class="line">console.dir(list)</span><br><span class="line"></span><br><span class="line">*countBy* 接收一个集合和一个条件函数，并返回一个对象，k为传入的条件，v为对应的元素的个数</span><br><span class="line">var albums = [</span><br><span class="line">	&#123;title: &apos;sabba&apos;, genre: &apos;metal&apos;&#125;,</span><br><span class="line">	&#123;title: &apos;scientist&apos;, genre: &apos;dub&apos;&#125;,</span><br><span class="line">	&#123;title: &apos;undertow&apos;, genre: &apos;metal&apos;&#125;,</span><br><span class="line">]</span><br><span class="line">var list = _.countBy(albums, function (a) &#123;</span><br><span class="line">	return a.genre;</span><br><span class="line">&#125;)</span><br><span class="line">console.dir(list) // &#123;metal: 2, dub: 1&#125;</span><br></pre></td></tr></table></figure>


定义几个Applicative函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*cat* 合并数组</span><br><span class="line">function cat() &#123;</span><br><span class="line">	let head = _.first(arguments);</span><br><span class="line">	if (existy(head)) &#123;</span><br><span class="line">		return head.concat.apply(head, _.rest(arguments));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return [];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cat([1, 2, 3], [4, 5]) // [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">*construct* 将元素放置在数组前方</span><br><span class="line">function construct(head, tail) &#123;</span><br><span class="line">	return cat([head], _.toArray(tail));</span><br><span class="line">&#125;</span><br><span class="line">construct(42, [1, 2, 3]) // [42, 1, 2, 3]</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="数据思考"><a href="#数据思考" class="headerlink" title="数据思考"></a>数据思考</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*keys* 以数组的形式返回对象的key</span><br><span class="line">var zombie = &#123;name: &apos;bub&apos;, film: &apos;day&apos;&#125;</span><br><span class="line">console.log(_.keys(zombie)) // [&apos;name&apos;, &apos;film&apos;]</span><br><span class="line">*values* 以数组的形式返回对象的value</span><br><span class="line">console.log(_.keys(zombie)) // [&apos;bub&apos;, &apos;day&apos;]</span><br><span class="line"></span><br><span class="line">*pluck* 接收一个对象数组和一个字符串，并返回在给定的键数组中对应对象的值</span><br><span class="line">var authorList = _.pluck([</span><br><span class="line">	&#123;title: &apos;chthon&apos;, author: &apos;anthony&apos;&#125;,</span><br><span class="line">	&#123;title: &apos;grendel&apos;, author: &apos;grendel&apos;&#125;,</span><br><span class="line">	&#123;title: &apos;after&apos;&#125;</span><br><span class="line">], &apos;author&apos;);</span><br><span class="line"></span><br><span class="line">*pairs* 接收一个对象，并把它变成这个嵌套数组</span><br><span class="line">var demo = _.pairs(&#123;title: &apos;chthon&apos;, author: &apos;anthony&apos;&#125;)</span><br><span class="line">console.log(demo) // [[&apos;title&apos;, &apos;chthon&apos;],[&apos;author&apos;, &apos;anthony&apos;]]</span><br><span class="line"></span><br><span class="line">*object* 将其重新组合成一个新的对象</span><br><span class="line">var zombie = &#123;name: &apos;bub&apos;, film: &apos;day&apos;&#125;</span><br><span class="line">var dd = _.object(_.map(_.pairs(zombie), function (pair) &#123;</span><br><span class="line">	return [pair[0].toUpperCase(), pair[1]]</span><br><span class="line">&#125;))</span><br><span class="line">console.log(dd)	// &#123;NAME: &quot;bub&quot;, FILM: &quot;day&quot;&#125;</span><br><span class="line"></span><br><span class="line">*invert* 翻转key和value</span><br><span class="line">var zombie = &#123;name: &apos;bub&apos;, film: &apos;day&apos;&#125;</span><br><span class="line">var dd = _.invert(zombie);</span><br><span class="line">console.log(dd) // &#123;bub: &quot;name&quot;, day: &quot;film&quot;&#125;</span><br><span class="line"></span><br><span class="line">*defaults* 用于扩充传入的对象，如为某个属性添加默认值</span><br><span class="line">var dd = _.pluck(_.map([</span><br><span class="line">		&#123;title: &apos;chthon&apos;, author: &apos;anthony&apos;&#125;,</span><br><span class="line">		&#123;title: &apos;grendel&apos;, author: &apos;gardner&apos;&#125;,</span><br><span class="line">		&#123;title: &apos;after&apos;&#125;,</span><br><span class="line">	], function (obj) &#123;</span><br><span class="line">		return _.defaults(obj, &#123;author: &apos;Unknown&apos;&#125;)</span><br><span class="line">	&#125;),</span><br><span class="line">&apos;author&apos;);</span><br><span class="line">console.log(dd)	// [&quot;anthony&quot;, &quot;gardner&quot;, &quot;Unknown&quot;]</span><br><span class="line"></span><br><span class="line">*pick* 根据参数筛选对象</span><br><span class="line">*omit* 根据参数筛选对象</span><br><span class="line">var person = &#123;</span><br><span class="line">	name: &apos;romy&apos;,</span><br><span class="line">	token: &apos;j3900&apos;,</span><br><span class="line">	password: &apos;3333&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var info = _.pick(person, &apos;token&apos;, &apos;password&apos;)</span><br><span class="line">var other = _.omit(person, &apos;token&apos;, &apos;password&apos;)</span><br><span class="line">console.log(info) // &#123;token: &quot;j3900&quot;, password: &quot;3333&quot;&#125;</span><br><span class="line">console.log(other) // &#123;name: &apos;romy&apos;&#125;</span><br><span class="line"></span><br><span class="line">*findWhere* 接收一个对象数组，返回第一个与参数给出的条件匹配的对象</span><br><span class="line">var library = [</span><br><span class="line">	&#123;title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1&#125;,</span><br><span class="line">	&#123;title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2&#125;,</span><br><span class="line">	&#123;title: &apos;joy&apos;, isbn: &apos;0236&apos;, ed: 1&#125;,</span><br><span class="line">];</span><br><span class="line">var dd = _.findWhere(library, &#123;title: &apos;sicp&apos;, ed: 2&#125;)</span><br><span class="line">console.log(dd) // &#123;title: &quot;sicp&quot;, isbn: &quot;0235&quot;, ed: 2&#125; 	</span><br><span class="line"></span><br><span class="line">*where* 接收一个对象数组，返回所有条件匹配的对象</span><br><span class="line">var library = [</span><br><span class="line">	&#123;title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1&#125;,</span><br><span class="line">	&#123;title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2&#125;,</span><br><span class="line">	&#123;title: &apos;joy&apos;, isbn: &apos;0236&apos;, ed: 1&#125;,</span><br><span class="line">];</span><br><span class="line">var dd = _.where(library, &#123;title: &apos;sicp&apos;&#125;)</span><br><span class="line">console.log(dd) // &#123;&#123;title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1&#125;, &#123;title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2&#125;&#125;</span><br></pre></td></tr></table></figure>


表状（Tabel-Like）数据    
```
function project(table, keys){
    return _.map(table, function (obj){
        return _.pick.apply(null, construct(obj, keys));
    });
}
var editionResults = project(library, [&apos;title&apos;, &apos;isbn&apos;])
// [
    {title: &apos;sicp&apos;, isbn: &apos;0234&apos;},
    {title: &apos;sicp&apos;, isbn: &apos;0235&apos;},
    {title: &apos;joy&apos;, isbn: &apos;0236&apos;},
]

*rename* 为对象属性设置别名
function rename(obj, newNames){
    return _.reduce(newNames, function(o, nu, old){
        if (_.has(obj, okd)) {
            o[nu] = obj[old];
            return o;
        } else {
            return o;
        }
    },
    _.omit.apply(null, construct(obj, _.keys(newNames))));
}
var dd = {a: 1, b: 2}
console.log(rename(dd, {&apos;a&apos;: &apos;A&apos;})) // {b: 2, A: 1}

*as* 类似于SQL语句 SELECT ed as edition FROM library
function as(table, newNames){
    return _.map(table, function(obj){
        return rename(obj, newNames);
    });
}
var library = [
        {title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1},
        {title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2},
        {title: &apos;joy&apos;, isbn: &apos;0236&apos;, ed: 1},
    ];
var dd = as(library, {ed: &apos;edition&apos;})
console.log(dd)
// [
        {title: &apos;sicp&apos;, isbn: &apos;0234&apos;, edition: 1},
        {title: &apos;sicp&apos;, isbn: &apos;0235&apos;, edition: 2},
        {title: &apos;joy&apos;, isbn: &apos;0236&apos;, edition: 1},
    ]

*where* 类似于SQL的where语句
//接收一个函数，作为对表中的每个对象的谓词。每当谓词返回false是，该对象不会出现在新表中
function restrict(table, pred){
    return _.reduce(table, function(newTable, obj){
        if (truthy(pred(obj))) {
            return newTable;
        } else {
            return _.without(newTable, obj)
        }
    }, table)
}

var dd = restrict(library, function (book){
    return book.ed &gt; 1;
})
console.log(dd) // [{title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2}]
```    
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>1. 一等函数    
    可以存储在变量中
    可以存储在数组中的插槽中
    可以存储在对象的字段中
    ...
2. applicative编程
    _.map
    _.reduce
    _.filter
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-变量的作用域和闭包</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="变量的作用域和闭包"><a href="#变量的作用域和闭包" class="headerlink" title="变量的作用域和闭包"></a>变量的作用域和闭包</h3><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><pre><code>动态作用域 -- this（函数调用时确定的）
静态作用域（词法作用域）-- 函数声明时确定的
</code></pre><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><pre><code>定义：所谓的词法作用域其实是指作用域在词法解析阶段既确定了,不会改变。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aVariable = &apos;outer&apos;;</span><br><span class="line">function afunc()&#123;</span><br><span class="line">	let aVariable = &apos;middle&apos;;</span><br><span class="line">	return _.map([1, 2, 3], function (e)&#123;</span><br><span class="line">		let aVariable = &apos;in&apos;; // 使用最内层的aVariable</span><br><span class="line">		return [aVariable,e].join(&apos; &apos;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(afunc()) // [&quot;in 1&quot;, &quot;in 2&quot;, &quot;in 3&quot;]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var globals = &#123;&#125;;</span><br><span class="line">function makeBindFun(resolver)&#123;</span><br><span class="line">	return function(k, v)&#123;</span><br><span class="line">		let stack = globals[k] || [];</span><br><span class="line">		globals[k] = resolver(stack, v);</span><br><span class="line">		return globals;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var stackBinder = makeBindFun(function(stack, v)&#123;</span><br><span class="line">	stack.push(v);</span><br><span class="line">	return stack;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var stackUnBinder = makeBindFun(function(stack, v)&#123;</span><br><span class="line">	stack.pop(v);</span><br><span class="line">	return stack;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var dd = stackBinder(&apos;sd&apos;, &apos;dd&apos;)</span><br><span class="line">console.log(dd) //&#123;sd: [&apos;dd&apos;]&#125;</span><br></pre></td></tr></table></figure>


javascript的动态作用域（对this引用的讨论）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*bind* 锁定this使其不被更改</span><br><span class="line">function globalThis() &#123;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line">var nopeThis = _.bind(globalThis, &apos;nope&apos;);</span><br><span class="line">nopeThis.call(&apos;wat&apos;) // &apos;nope&apos;;</span><br><span class="line"></span><br><span class="line">*bindAll* 锁定this引用到对应的命名函数</span><br><span class="line">var target = &#123;</span><br><span class="line">	name: &apos;the right value&apos;,</span><br><span class="line">	aux: function () &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var dd = _.bindAll(target, &apos;aux&apos;)</span><br><span class="line">console.log(target.aux.call(&apos;wat&apos;)) // the right value</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*clone* 克隆一个对象</span><br><span class="line">function f()&#123;</span><br><span class="line">	this[&apos;a&apos;] = 200;</span><br><span class="line">	return this[&apos;a&apos;] + this[&apos;b&apos;];</span><br><span class="line">&#125;</span><br><span class="line">var globals = &#123;&apos;b&apos;: 2&#125;;</span><br><span class="line">var dd = f.call(_.clone(globals))</span><br><span class="line">console.log(dd) // 202</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>模拟闭包
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function whatWasTheLocal() &#123;</span><br><span class="line">	let CAPTURED = &quot;Oh hai&quot;;</span><br><span class="line">	return function () &#123;</span><br><span class="line">		return &quot;The local was:&quot; + CAPTURED;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var dd = whatWasTheLocal();</span><br><span class="line">console.log(dd()) // The local was:Oh hai</span><br><span class="line"></span><br><span class="line">function createWeirdScaleFunction(FACTOR) &#123;</span><br><span class="line">	return function (v) &#123;</span><br><span class="line">		this[&apos;FACTOR&apos;] = FACTOR;</span><br><span class="line">		let captures = this;</span><br><span class="line">		return _.map(v, _.bind(function (n) &#123;</span><br><span class="line">			return (n * this[&apos;FACTOR&apos;]);	</span><br><span class="line">		&#125;, captures));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let scale10 = createWeirdScaleFunction(10);</span><br><span class="line">let dd = scale10.call(&#123;&#125;, [3, 4, 5])</span><br><span class="line">console.log(dd)</span><br></pre></td></tr></table></figure>

遮蔽
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var shadowed = 220;</span><br><span class="line">function argShadow(shadowed) &#123;</span><br><span class="line">	return [&apos;value is&apos;, shadowed].join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dd = argShadow()</span><br><span class="line">console.log(dd)</span><br></pre></td></tr></table></figure>

使用闭包
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pingpong = (function () &#123;</span><br><span class="line">	let PRIVATE = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		inc: function (n) &#123;</span><br><span class="line">			return PRIVATE += n;</span><br><span class="line">		&#125;,</span><br><span class="line">		dec: function (n) &#123;</span><br><span class="line">			return PRIVATE -= n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let dd = pingpong.inc(10);</span><br><span class="line">console.log(dd) // 10</span><br></pre></td></tr></table></figure>

闭包的抽象
```
function plucker (FIELD) {
    return function (obj) {
        return (obj &amp;&amp; obj[FIELD])
    }
}
let best = {title: &apos;infinite jest&apos;, author: &apos;dfw&apos;}
let getTitle = plucker(&apos;title&apos;)
let dd = getTitle(best);
console.log(dd) // infinite jest
```    
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-由函数构建函数</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="由函数构建函数"><a href="#由函数构建函数" class="headerlink" title="由函数构建函数"></a>由函数构建函数</h3><h4 id="函数式组合的精华"><a href="#函数式组合的精华" class="headerlink" title="函数式组合的精华"></a>函数式组合的精华</h4><pre><code>函数组合的精华：使用现有的零部件来建立新的行为，这些新行为同样也成为了已有的零部件。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dispatch() &#123;</span><br><span class="line">	let funs = _.toArray(arguments);</span><br><span class="line">	let size = funs.length;</span><br><span class="line">	return function (target) &#123;</span><br><span class="line">		let ret = undefined;</span><br><span class="line">		let args = _.rest(arguments);</span><br><span class="line">		for(let funIndex = 0; funIndex &lt; size; funIndex++)&#123;</span><br><span class="line">			let fun = funs[funIndex];</span><br><span class="line">			ret = fun.apply(fun, construct(target, args));</span><br><span class="line">			if (existy(ret)) return ret;	</span><br><span class="line">		&#125;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = dispatch(invoker(&apos;toString&apos;, Array.prototype.toString),</span><br><span class="line">	invoker(&apos;toString&apos;, String.prototype.toString)</span><br><span class="line">	)</span><br><span class="line">let dd = str(&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">console.log(dd) // &apos;a&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function rightAwayInvoker() &#123;</span><br><span class="line">	let args = _.toArray(arguments);</span><br><span class="line">	let method = args.shift();</span><br><span class="line">	let target = args.shift();</span><br><span class="line">	return method.apply(target, args);</span><br><span class="line">&#125;</span><br><span class="line">let dd = rightAwayInvoker(Array.prototype.reverse, [1, 2, 3]);</span><br><span class="line">console.log(dd) // [3, 2, 1]</span><br></pre></td></tr></table></figure>

柯里化的方向（默认向右）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function rigthCurryDiv(d) &#123;</span><br><span class="line">	return function (n) &#123;</span><br><span class="line">		return n/d;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let divideBy10 = rigthCurryDiv(10); // 被除数</span><br><span class="line">let dd = divideBy10(2); // 除数</span><br><span class="line">var d1 = rigthCurryDiv(10)(2)</span><br><span class="line">console.log(d1); // 0.2</span><br><span class="line"></span><br><span class="line">// 柯里化一个参数</span><br><span class="line">function curry(fun) &#123;</span><br><span class="line">	return function(arg) &#123;</span><br><span class="line">		return fun(arg);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let dd = [&apos;11&apos;, &apos;11&apos;, &apos;11&apos; ,&apos;11&apos;].map(curry(parseInt))</span><br><span class="line">console.log(dd) // [&apos;11&apos;, &apos;11&apos;, &apos;11&apos; ,&apos;11&apos;]</span><br><span class="line"></span><br><span class="line">// 柯里化两个参数</span><br><span class="line">function curry2(fun) &#123;</span><br><span class="line">	return function(secondArg) &#123;</span><br><span class="line">		return function(firstArg) &#123;</span><br><span class="line">			return fun(firstArg, secondArg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function div(n, d) &#123;</span><br><span class="line">	return n / d;</span><br><span class="line">&#125;</span><br><span class="line">let dd = curry2(div)(10)(50);</span><br><span class="line">console.log(dd) // 5</span><br><span class="line"></span><br><span class="line">function toHex(n) &#123;</span><br><span class="line">	let hex = n.toString(16);</span><br><span class="line">	return (hex.length &lt; 2) ? [0, hex].join(&apos;&apos;) : hex;</span><br><span class="line">&#125;</span><br><span class="line">function rgbToHexString(r, g, b) &#123;</span><br><span class="line">	return [&apos;#&apos;, toHex(r), toHex(g), toHex(b)].join(&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">let dd = rgbToHexString(255, 255, 255);</span><br><span class="line">console.log(dd) // #ffffff</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="部分应用"><a href="#部分应用" class="headerlink" title="部分应用"></a>部分应用</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function partial (fun) &#123;</span><br><span class="line">	let pargs = _.rest(arguments);</span><br><span class="line">	return function () &#123;</span><br><span class="line">		let args = cat(pargs, _.toArray(arguments));</span><br><span class="line">		return fun.apply(fun, args);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var div10by2by4by5000partial = partial(div, 10, 2, 4, 5000);</span><br><span class="line">console.log(div10by2by4by5000partial()) // 5</span><br><span class="line"></span><br><span class="line">// 局部应用实战：前置条件</span><br><span class="line">function condition1() &#123;</span><br><span class="line">	let validators = _.toArray(arguments);</span><br><span class="line">	return function (fun, arg) &#123;</span><br><span class="line">		let errors = mapcat(function(isValid)&#123;</span><br><span class="line">			return isValid(arg) ? [] : [isValid.message];</span><br><span class="line">		&#125;, validators);</span><br><span class="line">		if (!_.isEmpty(errors)) &#123;</span><br><span class="line">			throw new Error(error.join(&apos;,&apos;));</span><br><span class="line">		&#125;</span><br><span class="line">		return fun(arg);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let sqrPre = condition1(validator(&apos;arg must not be zero&apos;, complement(zero)),</span><br><span class="line">	validator(&apos;arg must be a number&apos;, _.isNumber));</span><br><span class="line">let dd = sqrPre(_.identity, 10);</span><br><span class="line">console.log(dd)</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="通过组合端至端的拼接函数"><a href="#通过组合端至端的拼接函数" class="headerlink" title="通过组合端至端的拼接函数"></a>通过组合端至端的拼接函数</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isntString = _.compose(function (x) &#123; return !x; &#125;, _.isString);</span><br><span class="line">let dd = isntString([]);</span><br><span class="line">console.log(dd)	// true</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-递归</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="自吸收函数（调用自己的函数）"><a href="#自吸收函数（调用自己的函数）" class="headerlink" title="自吸收函数（调用自己的函数）"></a>自吸收函数（调用自己的函数）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myLength (ary) &#123;</span><br><span class="line">	if (_.isEmpty(ary)) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return 1 + myLength(_.rest(ary));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = myLength([1, 2, 3]);</span><br><span class="line">console.log(dd); // 3</span><br><span class="line"></span><br><span class="line">function cycle(times, ary) &#123;</span><br><span class="line">	if (times &lt;= 0) &#123;</span><br><span class="line">		return [];</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return cat(ary, cycle(times -1, ary));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = cycle(2, [1, 2, 3]);</span><br><span class="line">console.log(dd); // [1, 2, 3, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">*_.zip*</span><br><span class="line">function cycle(times, ary) &#123;</span><br><span class="line">	if (times &lt;= 0) &#123;</span><br><span class="line">		return [];</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return cat(ary, cycle(times -1, ary));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = _.zip([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]);</span><br><span class="line">console.dir(dd); // [[&apos;a&apos;, 1],[&apos;b&apos;, 2], [&apos;c&apos;, 3]]</span><br></pre></td></tr></table></figure>

// 深度优先自递归搜索
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*andify 组合函数*</span><br><span class="line">function andify () &#123;</span><br><span class="line">	let preds = _.toArray(arguments);</span><br><span class="line">	return function () &#123;</span><br><span class="line">		let args = _.toArray(arguments);</span><br><span class="line">		let everything = function (ps, truth) &#123;</span><br><span class="line">			if (_.isEmpty(ps)) &#123;</span><br><span class="line">				return truth;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return _.every(args, _.first(ps))</span><br><span class="line">						&amp;&amp; everything(_.rest(ps), truth);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		return everything(preds, true);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let evenNums = andify(_.isNumber, isEven);</span><br><span class="line">console.log(evenNums(4, 2)); // true</span><br><span class="line"></span><br><span class="line">*andify 组合函数*</span><br><span class="line">function orify () &#123;</span><br><span class="line">	let preds = _.toArray(arguments);</span><br><span class="line">	return function () &#123;</span><br><span class="line">		let args = _.toArray(arguments);</span><br><span class="line">		let something = function (ps, truth) &#123;</span><br><span class="line">			if (_.isEmpty(ps)) &#123;</span><br><span class="line">				return truth;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return _.some(args, _.first(ps))</span><br><span class="line">						|| something(_.rest(ps), truth);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		return something(preds, true);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let evenNums = orify(_.isNumber, isEven);</span><br><span class="line">console.log(evenNums(1, 2)); // true</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="相互关联函数（函数调用其他会再调用回他的函数）"><a href="#相互关联函数（函数调用其他会再调用回他的函数）" class="headerlink" title="相互关联函数（函数调用其他会再调用回他的函数）"></a>相互关联函数（函数调用其他会再调用回他的函数）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function evenSteven(n) &#123;</span><br><span class="line">	if (n === 0) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return oddJohn(Math.abs(n) - 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function oddJohn(n) &#123;</span><br><span class="line">	if (n === 0) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return evenSteven(Math.abs(n) - 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = evenSteven(3);</span><br><span class="line">console.log(dd); // false</span><br><span class="line"></span><br><span class="line">*flat 展开嵌套数组*</span><br><span class="line">function flat(array) &#123;</span><br><span class="line">	if (_.isArray(array)) &#123;</span><br><span class="line">		return cat.apply(cat, _.map(array, flat));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return [array];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = flat([[1, 2], [3, 4]]);</span><br><span class="line">console.log(dd) // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">*clone 浅clone*</span><br><span class="line">let x = [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;]</span><br><span class="line">let y = _.clone(x);</span><br><span class="line">console.log(y) // [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;]	</span><br><span class="line"></span><br><span class="line">*deepClone 深clone*</span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">	if (!existy(obj) || !_.isObject(obj)) &#123;</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;</span><br><span class="line">	let temp = new obj.constructor();</span><br><span class="line">	for (let key in obj) &#123;</span><br><span class="line">		if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">			temp[key] = deepClone(obj[key]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">let x = [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;]</span><br><span class="line">let y = deepClone(x);</span><br><span class="line">x[1][&apos;c&apos;][&apos;d&apos;] = 100;</span><br><span class="line">console.log(_.isEqual(x, y)); // false</span><br><span class="line"></span><br><span class="line">// 遍历嵌套数组的数组</span><br><span class="line">function visit(mapFun, resultFun, array) &#123;</span><br><span class="line">	if (_.isArray(array)) &#123;</span><br><span class="line">		return resultFun(_.map(array, mapFun));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return resultFun(array);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = visit(_.identity, _.isNumber, 42);</span><br><span class="line">console.log(dd); // true</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="太多递归了"><a href="#太多递归了" class="headerlink" title="太多递归了"></a>太多递归了</h4><h4 id="递归是一个底层操作"><a href="#递归是一个底层操作" class="headerlink" title="递归是一个底层操作"></a>递归是一个底层操作</h4><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-纯度、不变性和更改政策</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="纯度、不变性和更改政策"><a href="#纯度、不变性和更改政策" class="headerlink" title="纯度、不变性和更改政策"></a>纯度、不变性和更改政策</h3><h4 id="纯度"><a href="#纯度" class="headerlink" title="纯度"></a>纯度</h4><pre><code>纯函数
1.其结果只能从它的参数的值来计算
2.不能依赖于能被外部操作改变的数据
3.不能改变外部状态
</code></pre><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不变性</span><br><span class="line">function summ (array) &#123;</span><br><span class="line">	let result = 0;</span><br><span class="line">	let sz = array.length;</span><br><span class="line">	for (let i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">		result += array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">let dd = summ(_.range(1, 11));</span><br><span class="line">console.log(dd); // 55</span><br><span class="line"></span><br><span class="line">// 递归</span><br><span class="line">function summRec (array, seed) &#123;</span><br><span class="line">	if (_.isEmpty(array))&#123;</span><br><span class="line">		return seed;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return summRec(_.rest(array), _.first(array) + seed)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dd = summRec(_.range(1, 11), 0);</span><br><span class="line">console.log(dd); // 55</span><br><span class="line"></span><br><span class="line">// 冻结和克隆</span><br><span class="line">Object.freeze(a) // 浅冻结</span><br><span class="line">// 深冻结</span><br><span class="line">function deepFreeze(obj) &#123;</span><br><span class="line">	if (!Object.isFrozen(obj)) &#123;</span><br><span class="line">		Object.freeze(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	for (let key in obj) &#123;</span><br><span class="line">		if (!obj.hasOwnProperty(key) || !_.isObject(obj[key])) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		deepFreeze(obj[key]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let x = [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;];</span><br><span class="line">deepFreeze(x);</span><br><span class="line">x[0] = null;</span><br><span class="line">console.dir(x); // [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="控制变化的政策"><a href="#控制变化的政策" class="headerlink" title="控制变化的政策"></a>控制变化的政策</h4><pre><code>用容器封装数据，不能直接更改数据。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Container (init) &#123;</span><br><span class="line">	this._value = init;</span><br><span class="line">&#125;</span><br><span class="line">Container.prototype = &#123;</span><br><span class="line">	update: function (fun) &#123;</span><br><span class="line">		let args = _.rest(arguments);</span><br><span class="line">		let oldValue = this._value;</span><br><span class="line"></span><br><span class="line">		this._value = fun.apply(this, constructor(oldValue, args));</span><br><span class="line">		return this._value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let aNumber = new Container(42);</span><br><span class="line">let dd = aNumber.update(function (n) &#123; return n + 1; &#125;);</span><br><span class="line">console.log(dd) // 43</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-javascript函数式编程的简介</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="javascript函数式编程的简介"><a href="#javascript函数式编程的简介" class="headerlink" title="javascript函数式编程的简介"></a>javascript函数式编程的简介</h3><h4 id="javascript案列"><a href="#javascript案列" class="headerlink" title="javascript案列"></a>javascript案列</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript函数式编程初试</span><br><span class="line">function splt (fn)　&#123;</span><br><span class="line">	return function (array) &#123;</span><br><span class="line">		return fn.apply(null, array)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// example</span><br><span class="line">var addArrayElements = splt(function (x, y) &#123;</span><br><span class="line">	return x + y;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(addArrayElements([1,2])) // 3</span><br><span class="line"></span><br><span class="line">function unsplat (fun) &#123;</span><br><span class="line">	return function () &#123;</span><br><span class="line">		return fun.call(null, _.toArray(arguments))</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let joinElments = unsplat(function (array) &#123;</span><br><span class="line">	return array.join(&apos; &apos;)</span><br><span class="line">&#125;)</span><br><span class="line">// example</span><br><span class="line">console.log(joinElments(&apos;@&apos;, &apos;$&apos;, &apos;*&apos;)) // @ $ *</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="开始函数式编程"><a href="#开始函数式编程" class="headerlink" title="开始函数式编程"></a>开始函数式编程</h4><pre><code>直白的定义：函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。
以函数为抽象单元
例子：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseAge (age) &#123;</span><br><span class="line">	if (!_.isString(age)) &#123;</span><br><span class="line">		throw new Error(&apos;expecting a string&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	let a;</span><br><span class="line">	console.log(&apos;attempting to parse an age&apos;)</span><br><span class="line">	a = parseInt(age, 10);</span><br><span class="line">	if (_.isNaN(a)) &#123;</span><br><span class="line">		console.log([&quot;could not parse age:&quot;, age].join(&apos; &apos;));</span><br><span class="line">		a = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">// example</span><br><span class="line">console.log(parseAge(34)) // throw Error</span><br><span class="line"></span><br><span class="line">// 如果我们想修改输出错误、信息和警告呈现的方式，较好的</span><br><span class="line">方式是将错误、信息和警告的概念抽象成不同的函数</span><br><span class="line">function fail(thing) &#123;</span><br><span class="line">	throw new Error(thing);</span><br><span class="line">&#125;</span><br><span class="line">function warn(thing) &#123;</span><br><span class="line">	console.log([&apos;WARNING:&apos;, thing].join(&apos; &apos;));</span><br><span class="line">&#125;</span><br><span class="line">function note(thing) &#123;</span><br><span class="line">	console.log([&apos;NOTE:&apos;, thing].join(&apos; &apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parseAge (age) &#123;</span><br><span class="line">	if (!_.isString(age)) &#123;</span><br><span class="line">		fail(&apos;Expecting a string&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	let a;</span><br><span class="line">	note(&apos;Attempting to parse an age&apos;)</span><br><span class="line">	a = parseInt(age, 10);</span><br><span class="line">	if (_.isNaN(a)) &#123;</span><br><span class="line">		warn([&apos;Could not parse age:&apos;, age].join(&apos; &apos;));</span><br><span class="line">		a = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">// example</span><br><span class="line">console.log(parseAge(&apos;df&apos;)) // throw Error</span><br></pre></td></tr></table></figure>

封装和隐藏（闭包）
以函数为行为单位
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function nativeNth(a, index) &#123;</span><br><span class="line">	return a[index];</span><br><span class="line">&#125;</span><br><span class="line">var letters = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">// example</span><br><span class="line">console.log(nativeNth(letters, 0)) // a</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">function nth(a, index) &#123;</span><br><span class="line">	if (!_.isNumber(index)) &#123;</span><br><span class="line">		fail(&apos;Expected a number as the index&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!isIndexed(a)) &#123;</span><br><span class="line">		fail(&apos;Not supported on non-indexed type&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	if ((index &lt; 0) || (index &gt; a.length -1)) &#123;</span><br><span class="line">		fail(&apos;Index value is out of bounds&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	return a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var letters = [&apos;1&apos;, &apos;2&apos;]</span><br><span class="line">console.log(nth(letters, 1))</span><br></pre></td></tr></table></figure>

数据抽象
    Javascript的对象原型模型是一个丰富且基础的数据方案。
函数式javascript初试
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// existy 定义事物的存在（js中null和undefined表示不存在）</span><br><span class="line">function existy(x) &#123; return x != null &#125;</span><br><span class="line">// example</span><br><span class="line">existy(null) // false</span><br><span class="line"></span><br><span class="line">truthy 用来判断一个对象是否应该被认为是true的同义词</span><br><span class="line">// js的原始真类型</span><br><span class="line">function truthy(x) &#123;</span><br><span class="line">	return (x !== false) &amp;&amp; existy(x)</span><br><span class="line">&#125;</span><br><span class="line">console.log(truthy(&apos;&apos;)) // true</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="Underscore示例"><a href="#Underscore示例" class="headerlink" title="Underscore示例"></a>Underscore示例</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>一种用于构建Javascript应用程序的技术称为“函数式编程”        
    1.确定抽象，并为其构建函数。
    2.利用已有的函数来构建更为复杂的抽象。
    3.通过将现有的函数传给其他的函数来构建更加复杂的抽象。
</code></pre><blockquote>
<p>   书籍【javascript函数式编程】</p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-读书笔记</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="基于流的编程-or-无类编程"><a href="#基于流的编程-or-无类编程" class="headerlink" title="基于流的编程 or 无类编程"></a>基于流的编程 or 无类编程</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createPerson () &#123;</span><br><span class="line">	let firstName = &apos;&apos;;</span><br><span class="line">	let lastName = &apos;&apos;;</span><br><span class="line">	let age = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		setFirstName: function (fn) &#123;</span><br><span class="line">			firstName = fn;</span><br><span class="line">			return this;	</span><br><span class="line">		&#125;,</span><br><span class="line">		setLastName: function (fn) &#123;</span><br><span class="line">			lastName = fn;</span><br><span class="line">			return this;	</span><br><span class="line">		&#125;,</span><br><span class="line">		setAge: function (fn) &#123;</span><br><span class="line">			age = fn;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;,</span><br><span class="line">		toString: function () &#123;</span><br><span class="line">			return [firstName, lastName, age].join(&apos; &apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let dd = createPerson()</span><br><span class="line">		.setFirstName(&apos;yu&apos;)</span><br><span class="line">		.setLastName(&apos;fan&apos;)</span><br><span class="line">		.setAge(11)</span><br><span class="line">		.toString();</span><br><span class="line">console.log(dd) // yu fan 11</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><pre><code>pipeline(a, _.compact, _.initial, _.rest, rev) // 对数据a进行一系列的操作
</code></pre><h4 id="数据流与控制流"><a href="#数据流与控制流" class="headerlink" title="数据流与控制流"></a>数据流与控制流</h4><h3 id="无类编程"><a href="#无类编程" class="headerlink" title="无类编程"></a>无类编程</h3><h4 id><a href="#" class="headerlink" title=" "></a> </h4><h4 id="数据导向"><a href="#数据导向" class="headerlink" title="数据导向"></a>数据导向</h4><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类层次结构</span><br><span class="line">function ContainerClass () &#123;&#125;</span><br><span class="line">function ObservedContainerClass () &#123;&#125;</span><br><span class="line">function HoleClass () &#123;&#125;</span><br><span class="line">function CASClass () &#123;&#125;</span><br><span class="line">function TableBaseClass () &#123;&#125;</span><br><span class="line"></span><br><span class="line">ObservedContainerClass.prototype = new ContainerClass();</span><br><span class="line">HoleClass.prototype = new ObservedContainerClass();</span><br><span class="line">CASClass.prototype = new HoleClass();</span><br><span class="line">TableBaseClass.prototype = new HoleClass();</span><br><span class="line"></span><br><span class="line">// 用Mixin扁平化层级结构</span><br><span class="line">function Container (val) &#123;</span><br><span class="line">	this._value = val;</span><br><span class="line">	this.init(val);</span><br><span class="line">&#125;</span><br><span class="line">Container.prototype.init = _.identity;</span><br><span class="line">let Hole = function (val) &#123;</span><br><span class="line">	Container.call(this, val);</span><br><span class="line">&#125;</span><br><span class="line">let HoleMixin = &#123;</span><br><span class="line">	setValue: function (newValue) &#123;</span><br><span class="line">		let oldVal = this._value;</span><br><span class="line">		this.validate(newValue);</span><br><span class="line">		this._value = newValue;</span><br><span class="line">		this.notify(oldVal, newValue);</span><br><span class="line">		return this._value;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let ObserverMixin = (function () &#123;</span><br><span class="line">	let _watchers = [];</span><br><span class="line">	return &#123;</span><br><span class="line">		watch: function (fun) &#123;</span><br><span class="line">			_watchers.push(fun);</span><br><span class="line">			return _.size(_watchers);</span><br><span class="line">		&#125;,</span><br><span class="line">		notify: function (oldVal, newVal) &#123;</span><br><span class="line">			_.each(_._watchers, function (watcher) &#123;</span><br><span class="line">				watcher.call(this, oldVal, newVal);</span><br><span class="line">			&#125;);</span><br><span class="line">			return _.size(_watchers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">let ValidateMixin = &#123;</span><br><span class="line">	addValidator: function (fun) &#123;</span><br><span class="line">		this._validator = fun;</span><br><span class="line">	&#125;,</span><br><span class="line">	init: function (val) &#123;</span><br><span class="line">		this.validate(val);</span><br><span class="line">	&#125;,</span><br><span class="line">	validate: function (val) &#123;</span><br><span class="line">		if (existy(this._validator) &amp;&amp;</span><br><span class="line">			!this._validator(val)) &#123;</span><br><span class="line">			fail(&apos;Attrmpted to set invalid value&apos; + polyToString(val));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">_.extend(Hole.prototype, HoleMixin, ValidateMixin, ObserverMixin); // 同级继承</span><br><span class="line">let h = new Hole(43);</span><br><span class="line">h.addValidator(always(false));</span><br><span class="line">console.log(h); // 43</span><br><span class="line"></span><br><span class="line">let SwapMixin = &#123;</span><br><span class="line">	swap: function (fun) &#123;</span><br><span class="line">		let args = _.rest(arguemnts);</span><br><span class="line">		let newValue = fun.apply(this, _.identity);</span><br><span class="line">		return this.setValue(newValue);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let o = &#123;_value: 0, setValue: _.identity&#125;</span><br><span class="line">_.extend(o, SwapMixin);</span><br><span class="line">o.swap(construct, [1, 2, 3]); //[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a></p>
</blockquote>
<pre><code>```
</code></pre>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程基本概念</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>满足下列条件之一则为高阶函数：</p>
<ol>
<li>接受一个或多个函数作为输入。</li>
<li>输出一个函数。</li>
</ol>
<h1 id="函数的合成（Compose）"><a href="#函数的合成（Compose）" class="headerlink" title="函数的合成（Compose）"></a>函数的合成（Compose）</h1><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br>通用 compose 函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let compose = function(...args) &#123;</span><br><span class="line">	let len = args.length,</span><br><span class="line">		count = len - 1,</span><br><span class="line">		result;</span><br><span class="line">	return function f1(...args1) &#123;</span><br><span class="line">		result = args[count].apply(this, args1);</span><br><span class="line">		if (count &lt;= 0) &#123;</span><br><span class="line">			count = len - 1;</span><br><span class="line">			return result;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			count--;</span><br><span class="line">			return f1.call(null, result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：具有以下特点</p>
<ol>
<li>第一函数接受参数, 其他函数接受的上一个函数的返回值</li>
<li>第一个函数的参数是多元的, 其他函数的一元的</li>
<li>自右向左执行</li>
</ol>
<h1 id="函数柯里化（curry）"><a href="#函数柯里化（curry）" class="headerlink" title="函数柯里化（curry）"></a>函数柯里化（curry）</h1><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数的函数或者计算结果（参数足够的情况）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let curry = function(fn) &#123;</span><br><span class="line">	let limit = fn.length;</span><br><span class="line">	return function judgeCurry (...args) &#123;</span><br><span class="line">		if (args.length &gt;= limit) &#123;</span><br><span class="line">			return fn.apply(null, args);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return function(...args2) &#123;</span><br><span class="line">				return judgeCurry.apply(null, args.concat(args2));                                     </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：具有以下特点</p>
<ol>
<li>当传入参数少于原本需要的参数个数就返回一个函数</li>
<li>当传入参数等于原本需要的参数个数就返回计算结果</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>输入输出数据流全是显式(函数与外界交换数据只有一个唯一渠道——参数和返回值)的。<br>非纯函数的操作读取全局变量/修改全局变量</p>
<h2 id="函数副作用"><a href="#函数副作用" class="headerlink" title="函数副作用"></a>函数副作用</h2><p>函数副作用是指函数在正常工作任务之外对外部环境所施加的影响（修改外部全局变量）。</p>
<h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>函数组合，单一职责原则<br>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。</p>
<h2 id="pointfree"><a href="#pointfree" class="headerlink" title="pointfree"></a>pointfree</h2><p>无参编程，函数无须提及将要操作的数据是什么样的，结合curry和compose。<br>就是使用一些通用的函数，组合出各种复杂运算。<br><code>var snakeCase = compose(replace(/\s+/ig, &#39;_&#39;), toLowerCase);</code></p>
<h2 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h2><p>函数柯里化，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>所谓偏函数，就是固定一个函数的一个或者多个参数，返回一个新的函数，这个函数用于接受剩余的参数。</p>
<h2 id="高阶函数-1"><a href="#高阶函数-1" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>一个函数的参数或者返回值里有函数。</p>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数式编程-高阶函数</title>
    <url>/2017/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3.html</url>
    <content><![CDATA[<p>最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸<strong>函数式编程</strong>。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="以其他函数为参数的函数"><a href="#以其他函数为参数的函数" class="headerlink" title="以其他函数为参数的函数"></a>以其他函数为参数的函数</h4><pre><code>如：_.map、_.reduce、_.filter等函数
关于传递函数的思考：max、finder、best
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*max 集合中选择最大值的项*</span><br><span class="line">var dd = _.max([1, 2, 3, 4, 5])</span><br><span class="line">console.log(dd) // 5</span><br><span class="line">var people = [&#123;name: &apos;fed&apos;, age: 45&#125;, &#123;name: &apos;fan&apos;, age: 25&#125;];</span><br><span class="line">var dd = _.max(people, function (item) &#123;</span><br><span class="line">	return item.age;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(dd) // &#123;name: &quot;fed&quot;, age: 45&#125;</span><br><span class="line"></span><br><span class="line">*finder *</span><br><span class="line">function finder(valueFun, bestFun, coll) &#123;</span><br><span class="line">	return _.reduce(coll, function (best, current) &#123;</span><br><span class="line">		var bestValue = valueFun(best);</span><br><span class="line">		var currentValue = valueFun(current);</span><br><span class="line">		return (bestValue === bestFun(bestValue, currentValue)) ? best : current; </span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">var dd = finder(_.identity, Math.max, [1, 2, 3, 4, 5]);</span><br><span class="line">console.log(dd) // 5</span><br><span class="line"></span><br><span class="line">*best *</span><br><span class="line">function best(fun, coll)&#123;</span><br><span class="line">	return _.reduce(coll, function (x, y) &#123;</span><br><span class="line">		return fun(x, y) ? x : y;	</span><br><span class="line">	&#125;);	</span><br><span class="line">&#125;</span><br><span class="line">var dd = best(function (x, y) &#123;</span><br><span class="line">	return x &gt; y;</span><br><span class="line">&#125;, [1, 2, 3, 4]);</span><br><span class="line">console.log(dd)// 4</span><br></pre></td></tr></table></figure>

关于传递函数的更多思考：重复、反复和条件迭代
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function repeat(times, VALUE) &#123;</span><br><span class="line">	return _.map(_.range(times), function () &#123; return VALUE; &#125;)</span><br><span class="line">&#125;</span><br><span class="line">var dd = repeat(4, &apos;Major&apos;);</span><br><span class="line">console.log(dd) // [&apos;Major&apos;,&apos;Major&apos;,&apos;Major&apos;,&apos;Major&apos;]</span><br><span class="line"></span><br><span class="line">// 使用函数，而不是值</span><br><span class="line">function repeatedly(times, fun) &#123;</span><br><span class="line">	return _.map(_.range(times), fun);</span><br><span class="line">&#125;</span><br><span class="line">var dd = repeatedly(4, function () &#123;</span><br><span class="line">	return Math.floor((Math.random()*10) + 1)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(dd)</span><br><span class="line"></span><br><span class="line">// 再次强调，&quot;使用函数，而不是值&quot;</span><br><span class="line">function iterateUntil(fun, check, init) &#123;</span><br><span class="line">	let ret = [];</span><br><span class="line">	let result = fun(init);</span><br><span class="line"></span><br><span class="line">	while (check(result))&#123;</span><br><span class="line">		ret.push(result);</span><br><span class="line">		result = fun(result);</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dd = iterateUntil(function (n)&#123; return n+n&#125;, function (n) &#123; return n &lt;= 1024&#125;, 1)</span><br><span class="line">console.log(dd) // [2, 4, 8, 16, ...]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="返回其他函数的函数"><a href="#返回其他函数的函数" class="headerlink" title="返回其他函数的函数"></a>返回其他函数的函数</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function always(VALUE)&#123;</span><br><span class="line">	return function ()&#123;</span><br><span class="line">		return VALUE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = always(function () &#123;&#125;)</span><br><span class="line">var g = always(function () &#123;&#125;)</span><br><span class="line">console.log(f() === g()) // false</span><br><span class="line"></span><br><span class="line">function invoker(NAME, METHOD)&#123;</span><br><span class="line">	return function(target)&#123;</span><br><span class="line">		if (!existy(target)) fail(&quot;Must provide a target&quot;);</span><br><span class="line">		let targetMethod = target[NAME];</span><br><span class="line">		let args = _.rest(arguments);</span><br><span class="line">		return doWhen((existy(targetMethod) &amp;&amp; METHOD === targetMethod), function () &#123;</span><br><span class="line">			return targetMethod.apply(target, args);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let rev = invoker(&apos;reverse&apos;, Array.prototype.reverse);</span><br><span class="line">console.log(_.map([[1, 2, 3]], rev))</span><br><span class="line"></span><br><span class="line">// 捕获增量值</span><br><span class="line">function makeUniqueStringFunction(start) &#123;</span><br><span class="line">	let COUNTER = start;</span><br><span class="line">	return function(prefix) &#123;</span><br><span class="line">		return [prefix, COUNTER++].join(&apos;&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let dd = makeUniqueStringFunction(0);</span><br><span class="line">let d1 = dd(&apos;fanerge&apos;)</span><br><span class="line">let d2 = dd(&apos;fanerge&apos;)</span><br><span class="line">console.log(d1, d2); // fanerge0 fanerge1</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="整合：对象校验器"><a href="#整合：对象校验器" class="headerlink" title="整合：对象校验器"></a>整合：对象校验器</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function aMap(obj) &#123;</span><br><span class="line">	return _.isObject(obj);</span><br><span class="line">&#125;</span><br><span class="line">function hasKeys() &#123;</span><br><span class="line">	let KEYS = _.toArray(arguments);</span><br><span class="line">	let fun = function(obj)&#123;</span><br><span class="line">		return _.every(KEYS, function (k)&#123;</span><br><span class="line">			return _.has(obj, k);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">	fun.message = cat([&apos;Must have values for keys:&apos;], KEYS).join(&quot; &quot;);</span><br><span class="line">	return fun;</span><br><span class="line">&#125;</span><br><span class="line">let checkCommand = checker(validator(&quot;Must be a map&quot;, aMap), hasKeys(&apos;msg&apos;, &apos;type&apos;));</span><br><span class="line">console.log(checkCommand(&#123;msg: &apos;blah&apos;, type: &apos;display&apos;&#125;)); //[]</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   源代码仓库<br>    <a href="https://github.com/fanerge/Functional-reading-notes" target="_blank" rel="noopener">函数式编程-读书笔记</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-中介者模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，<br>所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，<br>只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。<br>中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：<br>    手机购买页面（颜色、数量、内存、价格）<br>    MVC模式（控制层便是位于表现层与模型层之间的中介者。）</p>
<h1 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h1><p>我们应该很熟悉 MVC 三层模型实体模型（Model）、视图表现层（View）还有控制层（Control/Mediator）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 模擬 Model, View, Controller */</span><br><span class="line">var M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/** Model 負責存放資料 */</span><br><span class="line">M.data = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">/** View 負責將資料輸出到螢幕上 */</span><br><span class="line">V.render = (M) =&gt; &#123; alert(M.data); &#125;</span><br><span class="line"></span><br><span class="line">/** Controller 作為一個 M 和 V 的橋樑 */</span><br><span class="line">C.handleOnload = () =&gt; &#123; V.render(M); &#125;</span><br><span class="line"></span><br><span class="line">/** 在網頁讀取的時候呼叫 Controller */</span><br><span class="line">window.onload = C.handleOnload;</span><br></pre></td></tr></table></figure></p>
<p>MVC 模式中的Control/Mediator 层，就是本设计模式的中介者 (它必须拿到 View 和 Model 的引用)。</p>
<h1 id="手机购买页面"><a href="#手机购买页面" class="headerlink" title="手机购买页面"></a>手机购买页面</h1><h2 id="HTML-部分"><a href="#HTML-部分" class="headerlink" title="HTML 部分"></a>HTML 部分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	选择颜色: </span><br><span class="line">	&lt;select id=&quot;colorSelect&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	选择内存: </span><br><span class="line">	&lt;select id=&quot;memorySelect&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;32G&quot;&gt;32G&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;16G&quot;&gt;16G&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	输入购买数量: &lt;input type=&quot;text&quot; id=&quot;numberInput&quot;/&gt;&lt;br/&gt;</span><br><span class="line">	&lt;!--输入部分结束--&gt;</span><br><span class="line">	</span><br><span class="line">	您选择了颜色: &lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">	您选择了内存: &lt;div id=&quot;memoryInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">	您输入了数量: &lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">	&lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和购买数量&lt;/button&gt;</span><br><span class="line">&lt;body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 各种手机库存（通常来自于后端，这里前端进行模拟）</span><br><span class="line">var goods = &#123; </span><br><span class="line">	&quot;red|32G&quot;: 3,</span><br><span class="line">	&quot;red|16G&quot;: 0,</span><br><span class="line">	&quot;blue|32G&quot;: 1,</span><br><span class="line">	&quot;blue|16G&quot;: 6</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 中介者</span><br><span class="line">var mediator = (function()&#123;</span><br><span class="line">	// 获得所有节点的引用，以便对其进行操作（中介者必许获得对其他对象的引用）</span><br><span class="line">	var colorSelect = document.getElementById( &apos;colorSelect&apos; ),</span><br><span class="line">		memorySelect = document.getElementById( &apos;memorySelect&apos; ),</span><br><span class="line">		numberInput = document.getElementById( &apos;numberInput&apos; ),</span><br><span class="line">		colorInfo = document.getElementById( &apos;colorInfo&apos; ),</span><br><span class="line">		memoryInfo = document.getElementById( &apos;memoryInfo&apos; ),</span><br><span class="line">		numberInfo = document.getElementById( &apos;numberInfo&apos; ),</span><br><span class="line">		nextBtn = document.getElementById( &apos;nextBtn&apos; );</span><br><span class="line">	return &#123;</span><br><span class="line">		changed( obj )&#123;</span><br><span class="line">			var color = colorSelect.value, // 颜色</span><br><span class="line">				memory = memorySelect.value,// 内存</span><br><span class="line">				number = numberInput.value, // 数量</span><br><span class="line">				stock = goods[ color + &apos;|&apos; + memory ]; // 颜色和内存对应的手机库存数量</span><br><span class="line">			if ( obj === colorSelect )&#123; // 如果改变的是选择颜色下拉框</span><br><span class="line">				colorInfo.innerHTML = color;</span><br><span class="line">			&#125;else if ( obj === memorySelect )&#123;</span><br><span class="line">				memoryInfo.innerHTML = memory;</span><br><span class="line">			&#125;else if ( obj === numberInput )&#123;</span><br><span class="line">				numberInfo.innerHTML = number;</span><br><span class="line">			&#125;</span><br><span class="line">			if ( !color )&#123;</span><br><span class="line">				nextBtn.disabled = true;</span><br><span class="line">				nextBtn.innerHTML = &apos;请选择手机颜色&apos;;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			if ( !memory )&#123;</span><br><span class="line">				nextBtn.disabled = true;</span><br><span class="line">				nextBtn.innerHTML = &apos;请选择内存大小&apos;;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			if ( ( ( number - 0 ) | 0 ) !== number - 0 )&#123; // 输入购买数量是否为正整数</span><br><span class="line">				nextBtn.disabled = true;</span><br><span class="line">				nextBtn.innerHTML = &apos;请输入正确的购买数量&apos;;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			nextBtn.disabled = false;</span><br><span class="line">			nextBtn.innerHTML = &apos;放入购物车&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 与中介者联系起来，事件函数</span><br><span class="line">colorSelect.onchange = function()&#123;</span><br><span class="line">	mediator.changed( this );</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.onchange = function()&#123;</span><br><span class="line">	mediator.changed( this );</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.oninput = function()&#123;</span><br><span class="line">	mediator.changed( this );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS：代码来源于–腾讯.曾探《JavaScript设计模式与开发实践》，但能很好的说明中介者模式在js实际项目中的应用。<br>PS：这里共有手机颜色、手机内存、手机数量的选择和展示共6个对象，和一个中介者对象。<br>    中介者必须获得这6个对象的应用，当每个对象发生变化时都需要通知中介者，中介者再来执行具体操作。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/linhongyong/article/details/53439723" target="_blank" rel="noopener">js之中介模式</a><br>    <a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">wiki-MVC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-代理模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。<br>    代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例：<br>    图片预加载、图片懒加载、<br>    合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、<br>    惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、<br>    缓存代理（缓存请求结果、计算结果）</p>
<h1 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 先实现具体的两个算法</span><br><span class="line">const mult = function() &#123;</span><br><span class="line">	let a = 1;</span><br><span class="line">	for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">		a *= arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;;</span><br><span class="line">const plus = function() &#123;</span><br><span class="line">	let a = 0;</span><br><span class="line">	for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">		a += arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建缓存代理</span><br><span class="line">const createProxyFactory = function(fn) &#123;</span><br><span class="line">	let cache = &#123;&#125;; // 保存计算的结果</span><br><span class="line">	// 使用闭包在内存中保留对cache的引用</span><br><span class="line">	return function() &#123;</span><br><span class="line">		let args = Array.from(arguments).join(&apos;,&apos;); // 将所有参数转化为字符串作为缓存的 key</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return cache[args] = fn.apply(this, arguments);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用代理对象</span><br><span class="line">const proxyMult = createProxyFactory(mult);</span><br><span class="line">const proxyPlus = createProxyFactory(plus);</span><br><span class="line">console.log(proxyMult(1,2,3,4)); // 24</span><br><span class="line">console.log(proxyPlus(1,2,3,4)); // 10</span><br></pre></td></tr></table></figure>
<p>PS：这里每次进行同类的计算时（乘法和加法两类），先判断缓存对象cache中是否存在该参数连接成的字符串作为key的属性。<br>如果有，则直接从cache中读取，否则就进行计算并保存其结果。</p>
<h1 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h1><p>虚拟代理：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建<br>例：使用虚拟代理实现图片懒加载<br>下面以虚拟代理来说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 本体对象</span><br><span class="line">const imgFunc = (function() &#123;</span><br><span class="line">	const imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">	document.body.appendChild(imgNode);</span><br><span class="line">	return &#123;</span><br><span class="line">		setSrc(src)&#123;</span><br><span class="line">			imgNode.src = src;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 代理对象</span><br><span class="line">const proxyImage = (function() &#123;</span><br><span class="line">	const img = new Image();</span><br><span class="line">	img.onload = function() &#123;</span><br><span class="line">		imgFunc.setSrc(this.src);</span><br><span class="line">	&#125;;</span><br><span class="line">	return &#123;</span><br><span class="line">		setSrc(src)&#123;</span><br><span class="line">			imgFunc.setSrc(&apos;./loading.gif&apos;);</span><br><span class="line">			img.src = src;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 使用代理对象</span><br><span class="line">proxyImage.setSrc(&apos;./reality.png&apos;);</span><br></pre></td></tr></table></figure></p>
<p>PS：图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。<br>这里讲述一下代理对象做了那些事：<br>1.创建了一个 Image 对象，并为其绑定了 onload 事件。<br>2.将 imgNode 先设置为 ‘./loading.gif’ 加载的菊花图。<br>3.当 Image 对象加载完真实的图片，也就是上文的 ‘./reality.png’ ,将 imgNode 设置为 ‘./reality.png’。 </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/shamoguying1140/p/3169206.html" target="_blank" rel="noopener">js设计模式（9）—代理模式</a><br>    <a href="https://juejin.im/post/59df4f74f265da430f311909" target="_blank" rel="noopener">JavaScript设计模式</a><br>    <a href="http://blog.csdn.net/hi_xiexialing/article/details/54605065" target="_blank" rel="noopener"> js用高阶函数动态创建缓存代理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-享元模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="享元模式的基础"><a href="#享元模式的基础" class="headerlink" title="享元模式的基础"></a>享元模式的基础</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。<br>使用场景：第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄。<br>作用：Flyweight中有两个重要概念–内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。</p>
<h1 id="内衣厂展示许多商品"><a href="#内衣厂展示许多商品" class="headerlink" title="内衣厂展示许多商品"></a>内衣厂展示许多商品</h1><p>需求：假设有个内衣工厂，目前的产品有50种男士内衣与50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上它们的内衣拍成内衣广告。这里很显然适合使用 <span style="color: red;">享元模式</span> 来组织代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义塑料模特的构造函数</span><br><span class="line">var Model = function (sex) &#123;</span><br><span class="line">	this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">// 为模特拍照</span><br><span class="line">Model.prototype.takePhoto = function () &#123;</span><br><span class="line">	console.log(&apos;sex=&apos; + this.sex + &apos;underwear=&apos; + this.underwear )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化一个男模特 和 一个女模特</span><br><span class="line">var maleModel = new Model(&apos;male&apos;),</span><br><span class="line">	female    = new Model(&apos;female&apos;);    </span><br><span class="line">for (var i = 1; i &lt;=50; i++)&#123;</span><br><span class="line">	// 分别为模特换上 50 件内衣 以及 照相</span><br><span class="line">	maleModel.underwear = &apos;underwear&apos; + i;</span><br><span class="line">	maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line">for (var i = 1; i &lt;=50; i++)&#123;</span><br><span class="line">	// 分别为模特换上 50 件内衣 以及 照相</span><br><span class="line">	female.underwear = &apos;underwear&apos; + i;</span><br><span class="line">	femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：很显然，这里只需要两个对象便完成这个需求。</p>
<h1 id="地图应用（对象池）"><a href="#地图应用（对象池）" class="headerlink" title="地图应用（对象池）"></a>地图应用（对象池）</h1><p>说明：对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取对象。如果对象池里没有空闲对象则创建一个新的对象，当获取的对象完成他的职责之后，再进入池子等待被下次获取。<br>需求：假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip 。当第一次搜索A地点时假设出现了2个小气泡，第二次搜索A附近的B地点的时候页面出现了6个小气泡，按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。这样第二次搜索结果页面里，我们只需要再创建4个小气泡而不是6个。</p>
<h2 id="定义个气泡工厂"><a href="#定义个气泡工厂" class="headerlink" title="定义个气泡工厂"></a>定义个气泡工厂</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var toolTipFactory = (function () &#123;</span><br><span class="line">	var toolTipPool  = [];   // toolTip 对象池</span><br><span class="line">	return &#123;</span><br><span class="line">		create : function () &#123;</span><br><span class="line">			if(toolTipPool.length === 0)&#123;</span><br><span class="line">			   var div = document.createElement(&apos;div&apos;);</span><br><span class="line">			   document.body.appendChild(div);</span><br><span class="line">			   return div;</span><br><span class="line">			&#125; else&#123;</span><br><span class="line">			   return toolTipPool.shift(); //shift a dom</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		recover : function (tooltipDom) &#123;</span><br><span class="line">			return toolTipPool.push(tooltipDom);  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>PS：气泡工厂的对象池为数组是私有属性被包含在工厂闭包里，这个工厂又两个暴露对外的方法，create表示获取一个div节点，recover表示回收一个div节点。</p>
<h2 id="第一次搜索（2个气泡）"><a href="#第一次搜索（2个气泡）" class="headerlink" title="第一次搜索（2个气泡）"></a>第一次搜索（2个气泡）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ary = [];</span><br><span class="line">for(var i = 0, str; str = [&apos;A&apos;,&apos;B&apos;][i++])&#123;  // get ary elem</span><br><span class="line">	var toolTip = toolTipFactory.create();</span><br><span class="line">	toolTip.innerHTML = str;</span><br><span class="line">	ary.push(toolTip)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS：现在重新回到第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们。</p>
<h2 id="现在开始回收节点"><a href="#现在开始回收节点" class="headerlink" title="现在开始回收节点"></a>现在开始回收节点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i = 0 , toolTip ; toolTip = ary[i++])&#123;</span><br><span class="line">	toolTip.recover(toolTip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二次搜索（6个气泡）"><a href="#第二次搜索（6个气泡）" class="headerlink" title="第二次搜索（6个气泡）"></a>第二次搜索（6个气泡）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i =0 , str; str = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;][i++]; )&#123;</span><br><span class="line">	var toolTip = toolTipFactory.create();</span><br><span class="line">	toolTip.innerHTML(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：现在页面中已经出现了6个节点，上一次创建好的节点被共享给了下一次操作。</p>
<blockquote>
<p>   参考文档：<br><a href="http://www.jianshu.com/p/a158478c95b5" target="_blank" rel="noopener">三分钟教会你JS设计模式之享元模式</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/04/09/2379774.html" target="_blank" rel="noopener">深入理解JavaScript系列（37）：设计模式之享元模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-单例模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。<br>    在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：模态框、登录控件、注销控件<br>下面均以登录模态框做说明</p>
<h1 id="引入代理实现单例模式"><a href="#引入代理实现单例模式" class="headerlink" title="引入代理实现单例模式"></a>引入代理实现单例模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var CreateDiv = function(html) &#123;</span><br><span class="line">	this.html = html;</span><br><span class="line">	this.init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = function() &#123;</span><br><span class="line">	var div = document.createElement(&apos;div&apos;);</span><br><span class="line">	div.innerHTML = this.html;</span><br><span class="line">	document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ProxySingletonCreateDiv = (function() &#123;</span><br><span class="line">	var instance;</span><br><span class="line">	return function(html) &#123;</span><br><span class="line">		if (!instance) &#123;</span><br><span class="line">			instance = new CreateDiv(html);</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;seven1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;seven2&apos;);</span><br><span class="line"></span><br><span class="line">console.log(a === b); // true</span><br></pre></td></tr></table></figure>
<p>PS：我们负责管理单例的逻辑移到了代理类ProxySingletonCreateDiv中。<br>这样一来，CreateDiv就变成了一个普通的类，他跟ProxySingletonCreateDiv组合起来可以达到单例模式的效果。</p>
<h1 id="通用的单例模式"><a href="#通用的单例模式" class="headerlink" title="通用的单例模式"></a>通用的单例模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通用的单例验证方法</span><br><span class="line">const getSingle = function (fn)&#123;</span><br><span class="line">	let result;</span><br><span class="line">	return function ()&#123;</span><br><span class="line">		return result || (result = fn.apply(this, arguments));</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建登录模态框</span><br><span class="line">const createLoginLayer = function ()&#123;</span><br><span class="line">	const div = document.createElement(&apos;div&apos;);</span><br><span class="line">	div.innerHTML = &apos;我是登录模态框&apos;;</span><br><span class="line">	document.body.appendChild(div);</span><br><span class="line">	return div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 为登录模态框使用单例模式</span><br><span class="line">const createSingleLoginLoyer = getSingle(createLoginLayer);</span><br><span class="line">const loginLayer1 = createSingleLoginLoyer(); // 第一个登录模态框</span><br><span class="line">const loginLayer2 = createSingleLoginLoyer(); // 还是第一个登录模态框</span><br><span class="line"></span><br><span class="line">console.log(loginLayer1 === loginLayer2); // true</span><br></pre></td></tr></table></figure>
<p>这时不管你执行多少次 createSingleLoginLoyer() 方法，都只会生产一个 div 节点。<br>我们的通用单例模式就完成了。    </p>
<h1 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h1><p>定义：惰性单例指的是在需要的时候才创建对象的实例。<br>以创建登录模态框为例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const createLoginLayer = (function ()&#123;</span><br><span class="line">	let div;</span><br><span class="line">	return function ()&#123;</span><br><span class="line">		if (!div) &#123;</span><br><span class="line">			div = document.createElement(&apos;div&apos;);</span><br><span class="line">			div.innerHTML = &apos;我是登录模态框&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		return div;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 在点击按钮时才创建节点（惰性）</span><br><span class="line">document.getElementById(&apos;login-btn&apos;).onclick = function ()&#123;</span><br><span class="line">	var loginLayer = createLoginLayer();</span><br><span class="line">	loginLayer.style.display = &apos;block&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的对惰性单例的实现主要是只有单例了网页上的登录按钮，才会去创建，登录框的dom节点，并且只是创建一次。</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000006049548" target="_blank" rel="noopener">JavaScript设计模式—-单例模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html" target="_blank" rel="noopener">设计模式之单例模式</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-发布订阅模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="发布-订阅模式（观察者模式）"><a href="#发布-订阅模式（观察者模式）" class="headerlink" title="发布-订阅模式（观察者模式）"></a>发布-订阅模式（观察者模式）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>
<h1 id="现实生活中的发布-订阅模式"><a href="#现实生活中的发布-订阅模式" class="headerlink" title="现实生活中的发布-订阅模式"></a>现实生活中的发布-订阅模式</h1><p>比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们。在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息。</p>
<h1 id="实现发布-订阅模式的步骤"><a href="#实现发布-订阅模式的步骤" class="headerlink" title="实现发布-订阅模式的步骤"></a>实现发布-订阅模式的步骤</h1><p>1.首先要想好谁是发布者(比如上面的卖家)。<br>2.然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。<br>3.最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</p>
<h1 id="发布-订阅模式的代码封装"><a href="#发布-订阅模式的代码封装" class="headerlink" title="发布-订阅模式的代码封装"></a>发布-订阅模式的代码封装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Event = (function()&#123;</span><br><span class="line">	var list = &#123;&#125;, // 缓存列表</span><br><span class="line">		  listen, // 监听函数</span><br><span class="line">		  trigger, // 触发监听</span><br><span class="line">		  remove; // 移除监听函数</span><br><span class="line">		  listen = function(key,fn)&#123;</span><br><span class="line">			if(!list[key]) &#123;</span><br><span class="line">				list[key] = [];</span><br><span class="line">			&#125;</span><br><span class="line">			list[key].push(fn);</span><br><span class="line">		&#125;;</span><br><span class="line">		trigger = function()&#123;</span><br><span class="line">			var key = Array.prototype.shift.call(arguments),</span><br><span class="line">				 fns = list[key];</span><br><span class="line">			if(!fns || fns.length === 0) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			for(var i = 0, fn; fn = fns[i++];) &#123;</span><br><span class="line">				fn.apply(this,arguments);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		remove = function(key,fn)&#123;</span><br><span class="line">			var fns = list[key];</span><br><span class="line">			if(!fns) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			if(!fn) &#123;</span><br><span class="line">				fns &amp;&amp; (fns.length = 0);</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				for(var i = fns.length - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">					var _fn = fns[i];</span><br><span class="line">					if(_fn === fn) &#123;</span><br><span class="line">						fns.splice(i,1);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		return &#123;</span><br><span class="line">			listen: listen,</span><br><span class="line">			trigger: trigger,</span><br><span class="line">			remove: remove</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">function d1() &#123;</span><br><span class="line">	console.log(&apos;我是第二个color监听的函数!&apos;); </span><br><span class="line">&#125;</span><br><span class="line">function d2() &#123;</span><br><span class="line">	console.log(&apos;我是第二个color监听的函数!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 测试代码</span><br><span class="line">Event.listen(&quot;color&quot;, d1); // 在 list[&apos;color&apos;] 中绑定 d1 函数</span><br><span class="line">Event.listen(&quot;color&quot;, d2); // 在 list[&apos;color&apos;] 中绑定 d2 函数</span><br><span class="line">Event.remove(&apos;color&apos;, d1); // 在 list[&apos;color&apos;] 中移除 d1 函数</span><br><span class="line">Event.trigger(&quot;color&quot;); // 我是第二个color监听的函数!</span><br></pre></td></tr></table></figure>
<p>PS：此处代码来源于网络。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4687947.html" target="_blank" rel="noopener">Javascript中理解发布–订阅模式</a><br>    <a href="http://www.cnblogs.com/weebly/p/5279952.html" target="_blank" rel="noopener">学习笔记-js发布/订阅模式的简单实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-桥接模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="桥接模式基础"><a href="#桥接模式基础" class="headerlink" title="桥接模式基础"></a>桥接模式基础</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>使用场景：事件回调函数、请求接口之间进行桥接、用于连接公开的API代码和私用实现的代码<br>根据javascript语言的特点，我们将其简化成2个角色：<br>（1）扩充抽象类<br>（2）具体实现类</p>
<h1 id="最简单的桥接模式"><a href="#最简单的桥接模式" class="headerlink" title="最简单的桥接模式"></a>最简单的桥接模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var each = function (arr, fn) &#123;</span><br><span class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		var val = arr[i];</span><br><span class="line">		if (fn.call(val, i, val, arr)) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">each(arr, function (i, v) &#123;</span><br><span class="line">	arr[i] = v * 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>PS：在这个例子中，抽象部分是each函数，也就是上面说的扩充抽象类，实现部分是fn，即具体实现类。抽象部分和实现部分可以独立的进行变化。这个例子虽然简单，但就是一个典型的桥接模式的应用。</p>
<h1 id="事件监控"><a href="#事件监控" class="headerlink" title="事件监控"></a>事件监控</h1><p>抽象类 click 事件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addEvent(element, &apos;click&apos;, getBeerByIdBridge);</span><br><span class="line">// 提供一个桥梁 将 抽象类和实现类链接起来</span><br><span class="line">// 作为桥梁</span><br><span class="line">function getBeerByIdBridge (e) &#123;</span><br><span class="line">　　getBeerById(this.id, function(beer) &#123;</span><br><span class="line">　　　　console.log(&apos;Requested Beer: &apos;+beer);</span><br><span class="line">　　&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getBeerById(id, callback) &#123;</span><br><span class="line">	// 通过ID发送请求，然后返回数据</span><br><span class="line">	asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</span><br><span class="line">		// callback response</span><br><span class="line">		callback(resp.responseText);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：这里的getBeerByIdBridge就是我们定义的桥，用于将抽象的click事件和getBeerById连接起来，同时将事件源的ID，以及自定义的call函数（console.log输出）作为参数传入到getBeerById函数里。</p>
<h1 id="用于连接公开的API代码和私用实现的代码"><a href="#用于连接公开的API代码和私用实现的代码" class="headerlink" title="用于连接公开的API代码和私用实现的代码"></a>用于连接公开的API代码和私用实现的代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Public=function()&#123;</span><br><span class="line">	// 定义的私有变量</span><br><span class="line">	var secret = 3;</span><br><span class="line">	// 该函数返回了私有变量，外界可以通过该方法访问该私有变量</span><br><span class="line">	this.privilegedGetter = function()&#123;</span><br><span class="line">		 return secret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var o = new Public();</span><br><span class="line">var data =o.privilegedGetter();</span><br></pre></td></tr></table></figure>
<p>PS：如果一个公用的接口抽象了一些也许应该属于私用性的较复杂的任务，那么可以使用桥接模式来收集某些私用性的信息。可以用一些具有特殊权利的方法作为桥梁以便访问私用变量空间。这一特例中的桥接性函数又称特权函数。</p>
<h1 id="用桥接模式联结多个类"><a href="#用桥接模式联结多个类" class="headerlink" title="用桥接模式联结多个类"></a>用桥接模式联结多个类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Class1 =function(a,b,c)&#123;</span><br><span class="line">	this.a =a;</span><br><span class="line">	this.b = b;</span><br><span class="line">	this.c = c;</span><br><span class="line">&#125;</span><br><span class="line">var Class2 =function(d)&#123;</span><br><span class="line">	this.d = d;</span><br><span class="line">&#125;</span><br><span class="line">var BridgeClass =function(a,b,c,d)&#123;</span><br><span class="line">	   this.one = new Class1(a,b,c);</span><br><span class="line">	   this.two = new Class2(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：这看起来很像是—-适配器，的确如此。但要注意到本例中实际上并没有客户系统要求提供数据。它只不过是用来接纳大量数据并将其发送给责任方的一种辅助性手段。此外，BridgeClass也不是一个客户系统已经实现的现有接口。引入这个类的目的只不过是要桥接一些类而已。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/pigpigpig4587/article/details/25993191" target="_blank" rel="noopener">深入理解JavaScript系列（44）：设计模式之桥接模式</a><br>    <a href="http://www.cnblogs.com/lrzw32/p/4957643.html" target="_blank" rel="noopener">Javascript设计模式理论与实战：桥接模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-工厂模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<p>从事前端开发已经有几年了，也经常使用一些设计模式，但是对一些设计模式并不能很好的说出名字以及使用场景。<br>现利用周末闲暇时间来好好整理一下JS中常用的设计模式,如有不正确的地方，还望指出，谢谢！</p>
<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些类通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）<br>    自行车售卖（山地、公路）<br>    饮料机（咖啡、牛奶、水）<br>    RPG中职业（战士、法师、射手）<br>这里就以RPG中职业（战士、法师、射手）来做说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 先创建各个角色的构造函数</span><br><span class="line">function  Warrior() &#123;</span><br><span class="line">	this.skill = &apos;回血&apos;;</span><br><span class="line">	this.blood = 150; // 初始化生命值</span><br><span class="line">	this.hit = 8; // 普通攻击伤害</span><br><span class="line">	// 其他特有属性和方法比如生命值</span><br><span class="line">	console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">function  Mage() &#123;</span><br><span class="line">	this.skill = &apos;冰冻&apos;;</span><br><span class="line">	this.blood = 120; // 初始化生命值</span><br><span class="line">	this.hit = 3; // 普通攻击伤害</span><br><span class="line">	// 其他特有属性和方法</span><br><span class="line">	console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">function  Archer() &#123;</span><br><span class="line">	this.skill = &apos;消耗&apos;;</span><br><span class="line">	this.blood = 110; // 初始化生命值</span><br><span class="line">	this.hit = 10; // 普通攻击伤害</span><br><span class="line">	// 其他特有属性和方法</span><br><span class="line">	console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂对象 可以是普通对象是的方法 和 构造函数，这里使用前者</span><br><span class="line">const RoleFactory = &#123;</span><br><span class="line">	createRole (role) &#123;</span><br><span class="line">		let roler;</span><br><span class="line">		switch (role) &#123;</span><br><span class="line">			case &apos;战士&apos;:</span><br><span class="line">				roler = new Warrior();</span><br><span class="line">				break;</span><br><span class="line">			case &apos;法师&apos;:</span><br><span class="line">				roler = new Mage();</span><br><span class="line">				break;</span><br><span class="line">			case &apos;射手&apos;:</span><br><span class="line">				roler = new Archer();</span><br><span class="line">				break;</span><br><span class="line">			// 后续扩展角色直接追加选择语句和添加角色构造函数</span><br><span class="line">			defaulr: </span><br><span class="line">				roler = new Warrior();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(RoleFactory); // 冻结该对象，防止他人操作</span><br><span class="line"></span><br><span class="line">// 创建各个角色的实例</span><br><span class="line">var warrior1 = RoleFactory.createRole(&apos;战士&apos;); // 创建一个战士</span><br><span class="line">var mage1 = RoleFactory.createRole(&apos;法师&apos;); // 创建一个法师</span><br><span class="line">var arche1 = RoleFactory.createRole(&apos;射手&apos;); // 创建一个射手</span><br></pre></td></tr></table></figure>
<p>其实我们还可以这样设计工厂处理函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const RoleFactory = function (role) &#123;</span><br><span class="line">	return new role ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var warrior1 = RoleFactory(Warrior); // 创建一个战士</span><br><span class="line">var mage1 = RoleFactory(Mage); // 创建一个法师</span><br><span class="line">var arche1 = RoleFactory(Archer); // 创建一个射手</span><br></pre></td></tr></table></figure></p>
<p>上面输出的结果<br><img src="http://oxpnrlb4j.bkt.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%BE%93%E5%87%BA.png" alt="输出结果"></p>
<h1 id="什么时候使用工厂模式"><a href="#什么时候使用工厂模式" class="headerlink" title="什么时候使用工厂模式"></a>什么时候使用工厂模式</h1><ol>
<li>对象的构建十分复杂</li>
<li>需要依赖具体环境创建不同实例</li>
<li>处理大量具有相同属性的小对象<blockquote>
<p>   参考文档：<br><a href="http://www.cnblogs.com/coiorz/p/4806550.html" target="_blank" rel="noopener">JS设计模式之工厂模式</a><br><a href="http://www.cnblogs.com/myzy/p/5240457.html" target="_blank" rel="noopener">js之简单工厂模式</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-外观模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="外观模式基础"><a href="#外观模式基础" class="headerlink" title="外观模式基础"></a>外观模式基础</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。<br>外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。<br>外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。</p>
<h1 id="兼容浏览器事件绑定"><a href="#兼容浏览器事件绑定" class="headerlink" title="兼容浏览器事件绑定"></a>兼容浏览器事件绑定</h1><p>下面是一段未优化过的代码，我们使用了外观模式通过检测浏览器特性的方式来创建一个跨浏览器的使用方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const addEvent = function(el, ev, fn) &#123;</span><br><span class="line">	if (el.addEventListener) &#123;</span><br><span class="line">		el.addEventListener(ev, fn, false);</span><br><span class="line">	&#125; else if (el.attachEvent) &#123;</span><br><span class="line">		el.attachEvent(`on$&#123;ev&#125;`, fn);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		el.[`on$&#123;ev&#125;`] = fn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>PS：这里有一个问题，我们每调用一次 addEvent 函数就是执行一次 if-else 判断。</p>
<h1 id="兼容浏览器阻止冒泡、默认事件"><a href="#兼容浏览器阻止冒泡、默认事件" class="headerlink" title="兼容浏览器阻止冒泡、默认事件"></a>兼容浏览器阻止冒泡、默认事件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let N = window.N || &#123;&#125;;</span><br><span class="line">N.tools = &#123;</span><br><span class="line">	stopPropagation(e) &#123;</span><br><span class="line">		if (e.stopPropagation) &#123;</span><br><span class="line">			e.stopPropagation();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			e.cancelBubble = true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	preventDefault(e) &#123;</span><br><span class="line">		if (e.preventDefault) &#123;</span><br><span class="line">			e.preventDefault();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			e.returnValue = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	stopEvent (e) &#123;</span><br><span class="line">		this.stopPropagation(e);</span><br><span class="line">		this.preventDefault(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/02/28/2353448.html" target="_blank" rel="noopener">深入理解JavaScript系列（30）：设计模式之外观模式</a><br>    <a href="http://www.cnblogs.com/linda586586/p/4237093.html" target="_blank" rel="noopener">javascript设计模式-外观模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-备忘录模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="备忘录模式的基础"><a href="#备忘录模式的基础" class="headerlink" title="备忘录模式的基础"></a>备忘录模式的基础</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态<br>作用：在我们的开发中偶尔会遇到这样一种情况，需要对用户的行为进行撤销。要想实现撤销，首先需要保存软件系统的历史状态，当用户执行撤销时用之前的状态覆盖当前状态。本节介绍的备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便的回到一个特定的历史步骤。备忘录模式在js中经常用于数据缓存。<br>使用场景：分页控件、撤销组件    </p>
<h1 id="分页控件"><a href="#分页控件" class="headerlink" title="分页控件"></a>分页控件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Page = function()&#123;</span><br><span class="line">	let page = 1,</span><br><span class="line">		cache = &#123;&#125;,</span><br><span class="line">		data;</span><br><span class="line">	return function( page )&#123;</span><br><span class="line">		if ( cache[ page ] )&#123;</span><br><span class="line">				data =  cache[ page ];</span><br><span class="line">				render( data );</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">				Ajax.send( &apos;cgi.xx.com/xxx&apos;, function( data )&#123;</span><br><span class="line">				   cache[ page ] = data;</span><br><span class="line">				   render( data );</span><br><span class="line">				&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>PS：分页控件, 从服务器获得某一页的数据后可以存入缓存。以后再翻回这一页的时候，可以直接使用缓存里的数据而无需再次请求服务器。    </p>
<blockquote>
<p>   参考文档：<br><a href="http://www.isjs.cn/?p=998" target="_blank" rel="noopener">《javascript设计模式 – 备忘录模式》</a><br><a href="http://www.alloyteam.com/2012/10/commonly-javascript-design-patterns-memorandum-mode/" target="_blank" rel="noopener">【Javascript设计模式14】-备忘录模式</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-状态模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="状态模式的基础"><a href="#状态模式的基础" class="headerlink" title="状态模式的基础"></a>状态模式的基础</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。<br>状态模式是一个非常常用的设计模式，它主要有两个角色组成：<br>（1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。<br>（2）状态类：表示一种状态，包含其相应的处理方法<br>作用：状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以让代码更加清晰，提高应用程序的维护性和扩展性。<br>使用场景：文件下载（开始、暂停、完成、失败等）、红绿灯</p>
<h1 id="红绿灯（红绿黄灯）"><a href="#红绿灯（红绿黄灯）" class="headerlink" title="红绿灯（红绿黄灯）"></a>红绿灯（红绿黄灯）</h1><p>说明：我们简单地通过一个红绿灯的例子来说明状态模式，红绿灯拥有一个状态：哪一种颜色的灯亮了，<br>每一种颜色的灯亮了之后又各自的动作，一共有红绿黄三种颜色的灯，也就是有三种状态。</p>
<h2 id="定义环境类（红绿灯对象）"><a href="#定义环境类（红绿灯对象）" class="headerlink" title="定义环境类（红绿灯对象）"></a>定义环境类（红绿灯对象）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var trafficLight = (function () &#123;</span><br><span class="line">	var currentLight = null;</span><br><span class="line">	return &#123;</span><br><span class="line">		change: function (light) &#123;</span><br><span class="line">			currentLight = light;</span><br><span class="line">			currentLight.go();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>PS：上面的代码中，trafficLight是一个红绿灯对象，它有一个局部变量currentLight表示当前亮灯的对象，同时返回一个方法，这个方法用来改变红绿灯的状态，并触发相应的处理程序。</p>
<h2 id="定义状态类（三种不同颜色的灯）"><a href="#定义状态类（三种不同颜色的灯）" class="headerlink" title="定义状态类（三种不同颜色的灯）"></a>定义状态类（三种不同颜色的灯）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 红灯</span><br><span class="line">function RedLight() &#123; &#125;</span><br><span class="line">RedLight.prototype.go = function () &#123;</span><br><span class="line">	console.log(&quot;this is red light&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 绿灯</span><br><span class="line">function GreenLight() &#123; &#125;</span><br><span class="line">GreenLight.prototype.go = function () &#123;</span><br><span class="line">	console.log(&quot;this is green light&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 黄灯</span><br><span class="line">function YellowLight() &#123; &#125;</span><br><span class="line">YellowLight.prototype.go = function () &#123;</span><br><span class="line">	console.log(&quot;this is yellow light&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：这段代码分别定义了红绿黄三种颜色的灯对象，每一个对象都包含一个go方法作为亮灯之后的处理程序。</p>
<h2 id="客户端切换不同颜色的灯"><a href="#客户端切换不同颜色的灯" class="headerlink" title="客户端切换不同颜色的灯"></a>客户端切换不同颜色的灯</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trafficLight.change(new RedLight()); // this is red light</span><br><span class="line">trafficLight.change(new YellowLight()); // this is yellow light</span><br></pre></td></tr></table></figure>
<p>PS：通过传入灯对象到change方法中，从而改变红绿灯的状态，触发其相应的处理程序，这就是一个典型的状态模式的应用。</p>
<h1 id="菜单组件（JS组件开发中的状态模式）"><a href="#菜单组件（JS组件开发中的状态模式）" class="headerlink" title="菜单组件（JS组件开发中的状态模式）"></a>菜单组件（JS组件开发中的状态模式）</h1><p>说明：状态模式在开发JS组件时非常有用，我们平时开发组件时很多时候要切换组件的状态，<br>每种状态有不同的处理方式，这个时候就可以使用状态模式进行开发。比如我们要开发一个菜单组件，<br>菜单拥有最基本的两种状态：显示和隐藏，相应的显示或隐藏可能会有各自的其他操作。</p>
<h2 id="定义一个环境类（菜单对象）"><a href="#定义一个环境类（菜单对象）" class="headerlink" title="定义一个环境类（菜单对象）"></a>定义一个环境类（菜单对象）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Menu() &#123; &#125;</span><br><span class="line">Menu.prototype.toggle = function (state) &#123;</span><br><span class="line">	state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：这个菜单类有一个toggle方法用来切换状态，然后调用相应的处理方法。</p>
<h2 id="定义状态类（切换菜单）"><a href="#定义状态类（切换菜单）" class="headerlink" title="定义状态类（切换菜单）"></a>定义状态类（切换菜单）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var menuStates = &#123;</span><br><span class="line">	&quot;show&quot;: function () &#123;</span><br><span class="line">		console.log(&quot;the menu is showing&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;hide&quot;: function () &#123;</span><br><span class="line">		console.log(&quot;the menu is hiding&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS：通过一个对象menuStates来定义menu的状态，这里有两种状态show和hide，然后拥有相应的处理方法。</p>
<h2 id="客户端切换菜单状态"><a href="#客户端切换菜单状态" class="headerlink" title="客户端切换菜单状态"></a>客户端切换菜单状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var menu = new Menu();</span><br><span class="line">menu.toggle(menuStates.show);</span><br><span class="line">menu.toggle(menuStates.hide);</span><br></pre></td></tr></table></figure>
<p>PS：这段代码实例化了一个Menu对象，然后分别切换了显示和隐藏两种状态，如果有第三种状态，我们只需要menuStates添加相应的状态和处理程序即可。</p>
<blockquote>
<p>   参考文档：<br><a href="http://www.cnblogs.com/TomXu/archive/2012/04/18/2437099.html" target="_blank" rel="noopener">深入理解JavaScript系列（43）：设计模式之状态模式</a><br><a href="http://www.cnblogs.com/lrzw32/p/4994817.htm" target="_blank" rel="noopener">Javascript设计模式理论与实战：状态模式</a><br><a href="http://luopq.com/2015/11/25/design-pattern-state/" target="_blank" rel="noopener">Javascript设计模式理论与实战：状态模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-模版方法模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>使用场景：（主要用于步骤相似的事情）</p>
<ol>
<li>泡饮品（茶 和 coffee）</li>
<li>公司面试（百度面试 和 阿里面试）</li>
</ol>
<h1 id="IT公司面试"><a href="#IT公司面试" class="headerlink" title="IT公司面试"></a>IT公司面试</h1><p>下面就以IT公司面试作为父类，百度面试作为子类来实现面试流程模版方法。<br>（1.笔试 &gt;&gt; 2.技术面试 &gt;&gt; 3.领导面试 &gt;&gt; 4.等offer）</p>
<h2 id="定义父类"><a href="#定义父类" class="headerlink" title="定义父类"></a>定义父类</h2><p><code>let ITInterview = function(){};</code></p>
<h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 笔试</span><br><span class="line">ITInterview.prototype.writtenTest = function()&#123;</span><br><span class="line">	console.log(&quot;某公司笔试测试&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 技术面试</span><br><span class="line">ITInterview.prototype.technicalInterview = function()&#123;</span><br><span class="line">	console.log(&quot;某公司技术面试测试&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="领导面试"><a href="#领导面试" class="headerlink" title="领导面试"></a>领导面试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 领导面试</span><br><span class="line">ITInterview.prototype.leader = function()&#123;</span><br><span class="line">	console.log(&quot;某公司leader来面试了&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="等offer"><a href="#等offer" class="headerlink" title="等offer"></a>等offer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 等通知</span><br><span class="line">ITInterview.prototype.waitNotice = function()&#123;</span><br><span class="line">	console.log(&quot;某公司的offer到了&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定义模版方法"><a href="#定义模版方法" class="headerlink" title="定义模版方法"></a>定义模版方法</h3><p>作用：封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当然，这是一切顺利的流程......</span><br><span class="line">ITInterview.prototype.init = function()&#123;</span><br><span class="line">	this.writtenTest();</span><br><span class="line">	this.technicalInterview();</span><br><span class="line">	this.leader();</span><br><span class="line">	this.waitNotice();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义子类（百度面试）"><a href="#定义子类（百度面试）" class="headerlink" title="定义子类（百度面试）"></a>定义子类（百度面试）</h2><p>首先子类需要重父类哪里继承所有的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let BaiDuInterview = function()&#123;&#125;;</span><br><span class="line">BaiDuInterview.prototype = new ITInterview();</span><br></pre></td></tr></table></figure></p>
<h3 id="百度笔试"><a href="#百度笔试" class="headerlink" title="百度笔试"></a>百度笔试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 笔试</span><br><span class="line">BaiDuInterview.prototype.writtenTest = function()&#123;</span><br><span class="line">	console.log(&quot;百度公司笔试测试&quot;); // 无非就是面试题不一样呗</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="百度技术面试"><a href="#百度技术面试" class="headerlink" title="百度技术面试"></a>百度技术面试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 技术面试</span><br><span class="line">BaiDuInterview.prototype.technicalInterview = function()&#123;</span><br><span class="line">	console.log(&quot;百度公司技术面试测试&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="百度领导面试"><a href="#百度领导面试" class="headerlink" title="百度领导面试"></a>百度领导面试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 领导面试</span><br><span class="line">BaiDuInterview.prototype.leader = function()&#123;</span><br><span class="line">	console.log(&quot;百度公司leader来面试了&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="等offer-1"><a href="#等offer-1" class="headerlink" title="等offer"></a>等offer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 等通知</span><br><span class="line">BaiDuInterview.prototype.waitNotice = function()&#123;</span><br><span class="line">	console.log(&quot;百度公司的offer到了&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><p>let baiduInterview = new BaiDuInterview();<br>baiduInterview.init(); // 子类还可以重写父类的init方法，这样各个公司面试的流程就不一样了。<br>依次输出：<br>百度公司笔试测试<br>百度公司技术面试测试<br>百度公司leader来面试了<br>百度公司的offer到了</p>
<blockquote>
<p>   参考文档：<br><a href="http://blog.csdn.net/xu_ya_fei/article/details/51628310" target="_blank" rel="noopener">JS设计模式之模板方法</a><br><a href="https://www.2cto.com/kf/201507/420128.html" target="_blank" rel="noopener">JavaScript：设计模式之模板方法</a><br><a href="http://www.cnblogs.com/tugenhua0707/p/4780227.html" target="_blank" rel="noopener">javascript模板方法模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-策略模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）<br>    计算年终奖（工资、效绩）<br>下面以年终将做说明：<br>比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，<br>绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 一组策略类封装具体的算法</span><br><span class="line">const Bouns = &#123;</span><br><span class="line">	A (salary)&#123;</span><br><span class="line">		return salary * 4;</span><br><span class="line">	&#125;,</span><br><span class="line">	B (salary)&#123;</span><br><span class="line">		return salary * 3;</span><br><span class="line">	&#125;,</span><br><span class="line">	C (salary)&#123;</span><br><span class="line">		return salary * 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(Bouns);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 计算年终奖 环境类Context</span><br><span class="line">* @param &#123;String&#125; A 效绩等级</span><br><span class="line">* @param &#123;Number&#125; 10000 每月工资</span><br><span class="line">* @returns &#123;Number&#125; 40000 年终奖</span><br><span class="line">*/</span><br><span class="line">const calculateBouns = function (type, salary)&#123;</span><br><span class="line">	return Bouns[type](salary);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 测试年终奖计算方式</span><br><span class="line">const demo1 = calculateBouns(&apos;A&apos;, 10000);</span><br><span class="line">const demo2 = calculateBouns(&apos;B&apos;, 80000);</span><br><span class="line">console.log(demo1, demo2); // 40000, 240000</span><br></pre></td></tr></table></figure></p>
<p>PS：<br>策略模式指的是定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，<br>实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，<br>而算法的实现是根据绩效对应不同的绩效规则；<br>一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，<br>并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，<br>随后把请求委托给某一个策略类。<br>复合开放-封闭原则，可变的部分为策略类（一组算法），不变的部分为执行具体算法的方式。</p>
<h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这里我们实现一组策略类封装具体的验证规则</span><br><span class="line">const strategy = &#123;</span><br><span class="line">	// 是否为空</span><br><span class="line">	isNotEmpty (value, errorMsg)&#123;</span><br><span class="line">		if (value === &apos;&apos;) &#123;</span><br><span class="line">			return errorMsg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	// 最小长度</span><br><span class="line">	minLength (value, errorMsg, length)&#123;</span><br><span class="line">		if (value.length &lt; length) &#123;</span><br><span class="line">			return errorMsg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	// 手机号码格式</span><br><span class="line">	mobileFormat (value,errorMsg)&#123;</span><br><span class="line">		if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;</span><br><span class="line">			return errorMsg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(strategy);</span><br><span class="line"></span><br><span class="line">var Validator = function()&#123;</span><br><span class="line">	this.cache = [];  // 保存效验规则</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add = function(dom,rules) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	for(var i = 0, rule; rule = rules[i++]; )&#123;</span><br><span class="line">		(function(rule)&#123;</span><br><span class="line">			var strategyAry = rule.strategy.split(&quot;:&quot;);</span><br><span class="line">			var errorMsg = rule.errorMsg;</span><br><span class="line">			self.cache.push(function()&#123;</span><br><span class="line">				var strategy = strategyAry.shift();</span><br><span class="line">				strategyAry.unshift(dom.value);</span><br><span class="line">				strategyAry.push(errorMsg);</span><br><span class="line">				return strategys[strategy].apply(dom,strategyAry);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;)(rule);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start = function()&#123;</span><br><span class="line">	for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;</span><br><span class="line">	var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息</span><br><span class="line">	if(msg) &#123;</span><br><span class="line">		return msg;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 代码调用</span><br><span class="line">var registerForm = document.getElementById(&quot;registerForm&quot;);</span><br><span class="line">var validateFunc = function()&#123;</span><br><span class="line">	var validator = new Validator(); // 创建一个Validator对象</span><br><span class="line">	/* 添加一些效验规则 */</span><br><span class="line">	validator.add(registerForm.userName,[</span><br><span class="line">		&#123;strategy: &apos;isNotEmpty&apos;,errorMsg:&apos;用户名不能为空&apos;&#125;,</span><br><span class="line">		&#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;用户名长度不能小于6位&apos;&#125;</span><br><span class="line">	]);</span><br><span class="line">	validator.add(registerForm.password,[</span><br><span class="line">		&#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;密码长度不能小于6位&apos;&#125;,</span><br><span class="line">	]);</span><br><span class="line">	validator.add(registerForm.phoneNumber,[</span><br><span class="line">		&#123;strategy: &apos;mobileFormat&apos;,errorMsg:&apos;手机号格式不正确&apos;&#125;,</span><br><span class="line">	]);</span><br><span class="line">	var errorMsg = validator.start(); // 获得效验结果</span><br><span class="line">	return errorMsg; // 返回效验结果</span><br><span class="line">&#125;;</span><br><span class="line">// 点击确定提交</span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">	var errorMsg = validateFunc();</span><br><span class="line">	if(errorMsg)&#123;</span><br><span class="line">		alert(errorMsg);</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：此处代码来源于–腾讯.曾探的《javascript设计模式》，这能很好的说明策略模式的用途。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4722696.html" target="_blank" rel="noopener">理解javascript中的策略模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-组合模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="组合模式的基础"><a href="#组合模式的基础" class="headerlink" title="组合模式的基础"></a>组合模式的基础</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>作用：组合模式让你可以优化处理递归或分级数据结构。<br>使用场景：系统目录结构、网站导航结构、文件扫描、DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。<br>该模式由两部分构成：<br>1.子对象（Leaf）：组成组合对象的最基本对象。<br>2.组合对象（Composite）：由子对象组合起来的复杂对象。</p>
<h1 id="组合模式的例子"><a href="#组合模式的例子" class="headerlink" title="组合模式的例子"></a>组合模式的例子</h1><p>文件扫描<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义组合对象（文件夹）</span><br><span class="line">let Folder = function( name )&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.files = [];</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.add = function( file )&#123;</span><br><span class="line">	this.files.push( file );</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.scan = function()&#123;</span><br><span class="line">	console.log(&apos;开始文件扫描:&apos; + this.name);</span><br><span class="line">	for( let i = 0, file, files = this.files; file = files[i++]; )&#123;</span><br><span class="line">		file.scan();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//定义叶子对象（文件）</span><br><span class="line">let File = function( name )&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">File.prototype.add = function()&#123;</span><br><span class="line">	throw new Error(&apos;文件下面不能再添加文件&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">File.prototype.scan = function()&#123;</span><br><span class="line">	console.log(&apos;开始扫瞄：&apos; + this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let folder = new Folder(&apos;前端学习&apos;);</span><br><span class="line">let folder1 = new Folder(&apos;JS学习&apos;);</span><br><span class="line">let folder2 = new Folder(&apos;JQ学习&apos;);</span><br><span class="line"></span><br><span class="line">let file1 = new File(&apos;JS设计模式&apos;);</span><br><span class="line">let file2 = new File(&apos;JQ实战&apos;);</span><br><span class="line">let file3 = new File(&apos;前端性能&apos;);</span><br><span class="line"></span><br><span class="line">folder1.add(file1);</span><br><span class="line">folder2.add(file2);</span><br><span class="line">folder.add(folder1);</span><br><span class="line">folder.add(folder2);</span><br><span class="line">folder.add(file3);</span><br><span class="line">folder.scan();</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">开始文件扫描：前端学习</span><br><span class="line">开始文件扫描：JS学习</span><br><span class="line">开始扫瞄：JS设计模式</span><br><span class="line">开始文件扫描：JQ学习</span><br><span class="line">开始扫瞄：JQ实战</span><br><span class="line">开始扫瞄：前端性能</span><br></pre></td></tr></table></figure></p>
<p>PS：父类和子类必须具有相同的接口（方法），只不过它们相同的方法具有的功能不相同，例如父类的实例具有 add 方法作用是，可以添加文件夹 或者 文件。子类的实例具有 add 方法则不能添加文件夹 或者 文件，却抛出一个错误（子类重写父类的方法）。 </p>
<blockquote>
<p>   参考文档：<br><a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9B%86%E5%90%88/0521%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.txt" target="_blank" rel="noopener">0521组合模式</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/04/12/2435530.html" target="_blank" rel="noopener">深入理解JavaScript系列（40）：设计模式之组合模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-装饰者模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。<br>    装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。<br>    与继承相比，装饰者是一种更轻便灵活的做法。<br><img src="http://oxpnrlb4j.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E8%80%85%E5%8C%85%E8%A3%85%E6%B5%81%E7%A8%8B.png" alt="图解装饰者模式"><br>普通对象被装饰者包裹起来，就形成了装饰者模式。<br>举例：<br>    雷霆战机（吃道具的例子）</p>
<h1 id="雷霆战机（吃道具的例子）"><a href="#雷霆战机（吃道具的例子）" class="headerlink" title="雷霆战机（吃道具的例子）"></a>雷霆战机（吃道具的例子）</h1><p>介绍：现在我们假设正在开发一个小游戏–雷霆战机，<br>    最开始我们使用最渣的飞机，只能发射普通子弹；<br>    吃一颗星，可以发射普通子弹和发射散弹 ；<br>    再吃一颗，可以发射普通子弹和散弹和跟踪导弹。<br>// 一级飞机<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var plane = &#123;</span><br><span class="line">	fire: function()&#123;</span><br><span class="line">		console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">plane.fire(); // &apos;发射普通子弹&apos;</span><br></pre></td></tr></table></figure></p>
<p>// 二级飞机<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fire1 = plane.fire;</span><br><span class="line">var shot = function() &#123;</span><br><span class="line">	console.log(&apos;发射散弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">plane.fire = function () &#123;</span><br><span class="line">	fire1();</span><br><span class="line">	shot();</span><br><span class="line">&#125;;</span><br><span class="line">plane.fire(); // &apos;发射普通子弹&apos; &apos;发射散弹&apos;</span><br></pre></td></tr></table></figure></p>
<p>// 三级飞机<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fire2 = plane.fire;</span><br><span class="line">var track = function() &#123;</span><br><span class="line">	console.log(&apos;发射跟踪导弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">plane.fire = function () &#123;</span><br><span class="line">	fire2();</span><br><span class="line">	track();</span><br><span class="line">&#125;;</span><br><span class="line">plane.fire(); // &apos;发射普通子弹&apos; &apos;发射散弹&apos; &apos;发射跟踪导弹&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oxpnrlb4j.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E8%80%85%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="装饰者执行过程"><br>PS：这样给对象动态的增加职责的方式就没有改变对象自身，一个对象放入另一个对象就形成了一条装饰链（一个聚合对象）， 而上面的shot和track也就是装饰者、装饰函数 ，当函数执行时，会把请求转给链中的下一个对象。        </p>
<h1 id="在-FUNCTION-原型上封装通用的装饰函数"><a href="#在-FUNCTION-原型上封装通用的装饰函数" class="headerlink" title="在 FUNCTION 原型上封装通用的装饰函数"></a>在 FUNCTION 原型上封装通用的装饰函数</h1><p>// 在原函数之前执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.before=function(beforefn) &#123;</span><br><span class="line">	var _this = this; // 保存旧函数的引用</span><br><span class="line">	return function() &#123; // 返回包含旧函数和新函数的“代理”函数</span><br><span class="line">		beforefn.apply(this,arguments); // 执行新函数,且保证this不被劫持,新函数接受的参数						   </span><br><span class="line">		return _this.apply(this,arguments); // 也会被原封不动的传入旧函数,新函数在旧函数之前执行</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>// 在原函数之后执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.after = function(afterfn) &#123;</span><br><span class="line">	var _this = this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var ret = _this.apply(this,arguments);</span><br><span class="line">		afterfn.apply(this,arguments);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="封装成单独函数（不污染原型）"><a href="#封装成单独函数（不污染原型）" class="headerlink" title="封装成单独函数（不污染原型）"></a>封装成单独函数（不污染原型）</h1><p>// 在原函数之前执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var before = function(fn, before) &#123;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		before.apply(this, arguments);</span><br><span class="line">		return fn.apply(this, arguments);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">before(func1, func2);</span><br></pre></td></tr></table></figure></p>
<p>// 在原函数之后执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var after = function(fn, after) &#123;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var ret = fn.apply(this,arguments);</span><br><span class="line">		after.apply(this,arguments);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">after(func1, func2);</span><br></pre></td></tr></table></figure></p>
<p>PS：代码来源于–腾讯.曾探《JavaScript设计模式与开发实践》，但能很好的说明装饰者模式在js实际项目中的应用。<br>上面封装的函数可以直接在项目中使用。</p>
<blockquote>
<p>   参考文档：<br><a href="http://blog.csdn.net/yisuowushinian/article/details/51934008" target="_blank" rel="noopener">JavaScript设计模式—-装饰者模式</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/02/24/2353434.html" target="_blank" rel="noopener">深入理解JavaScript系列（29）：设计模式之装饰者模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-职责链模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="职责链模式的基础"><a href="#职责链模式的基础" class="headerlink" title="职责链模式的基础"></a>职责链模式的基础</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。职责链模式的名字非常形象，一系列可能会处理请求的对象被该连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象成为链中的节点。<br>优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。<br>使用场景：挤公交车递钱（只有售票员可以收钱）、交押金预定手机</p>
<h1 id="交押金预定手机"><a href="#交押金预定手机" class="headerlink" title="交押金预定手机"></a>交押金预定手机</h1><blockquote>
<p>   假设一个电视购物网站对于某部新上市的手机经过了2轮缴纳500元定金与200元定金的预定，现在已经到了正式购买的阶段。<br>支付了500元定金的用户在购买阶段可以使用100元优惠券，200元定金可以使用50元优惠券，普通用户没有优惠且当库存不足不一定能买到。<br>约定：<br>orderType: 表示订单类型(定金或者普通用户),code的值为1时候是500元定金用户，为2是200元定金用户，为3则是普通用户。<br>pay : 表示用户是否支付定金，用户虽然下过500元定金的订单但是如果他一直没有支付定金，那么只能降级为普通用户。<br>stock : 仅用户普通用户的库存数量，定金用户不受限制。<br>首先定义三种预定的客户的订单并且让每种客户订单有满足当前预定条件和不满足当前预定条件（需后面继续处理）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 500 元客户订单</span><br><span class="line">var order500 = function (orderType,pay,stock) &#123;</span><br><span class="line">	if(orderType === 1 &amp;&amp; pay)&#123;</span><br><span class="line">		 console.log(&apos;500 rmb deposit, get 100 coupon &apos;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return &apos;nextSuccessor&apos;  // unknow the next node but always pass to next.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 200 元客户订单</span><br><span class="line">var order200 = function (orderType,pay,stock) &#123;</span><br><span class="line">	if(orderType === 2 &amp;&amp; pay)&#123;</span><br><span class="line">		console.log(&apos;200 rmb deposit , get 50 coupon&apos;)</span><br><span class="line">	&#125; else&#123;</span><br><span class="line">		 return &apos;nextSuccessor&apos;; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 无预约客户订单</span><br><span class="line">var orderNormal = function (orderType,pay,stock) &#123;</span><br><span class="line">	if(stock &gt; 0)&#123;</span><br><span class="line">		 console.log(&apos;normal buy no coupon&apos;)</span><br><span class="line">	&#125; else&#123;</span><br><span class="line">		 console.log(&apos;the stock lack&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定制职责链对象（作用是形成订单职责链）</span><br><span class="line">var Chain = function (fn) &#123;</span><br><span class="line">	this.fn = fn;</span><br><span class="line">	this.successor = null;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置职责链</span><br><span class="line">Chain.prototype.setNextSuccessor = function (successor) &#123;</span><br><span class="line">	return this.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置每个节点的调用方式</span><br><span class="line">Chain.prototype.passRequest = function () &#123;</span><br><span class="line">	var ret = this.fn.apply(this.arguments);</span><br><span class="line">	if(ret === &apos;nextSuccessor&apos;)&#123;</span><br><span class="line">		return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments)</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 现在我们把3个订单函数分别包装成职责链的节点</span><br><span class="line">var chainOrder500 = new Chain(order500);</span><br><span class="line">var chainOrder200 = new Chain(order200);</span><br><span class="line">var chainOrderNormal = new Chain(orderNormal);</span><br><span class="line"></span><br><span class="line">// 这里我们把上面封装的节点连成一条线，依次判断执行</span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200)</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal)</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">chainOrder500.passRequest(1,true,6); // 500 rmb deposit, get 100 coupon</span><br><span class="line">chainOrder500.passRequest(2,true,4); // 200 rmb deposit , get 50 coupon</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>假如我们又想支持，300元定金购买，那我们就在改链中增加一个节点即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var order300 = function () &#123;</span><br><span class="line">// todo</span><br><span class="line">&#125;;</span><br><span class="line">chainOrder300 = new Chain(chainOrder300)</span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder300)</span><br><span class="line">chainOrder300.setNextSuccessor(chainOrder200)</span><br></pre></td></tr></table></figure></p>
<p>我们可以自由灵活的增加移除和链中的节点顺序，这样就很简单能满足瞬息万变的需求了。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.jianshu.com/p/19b0033423be" target="_blank" rel="noopener">三分钟教会你JS设计模式之职责链模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/10/2435381.html" target="_blank" rel="noopener">深入理解JavaScript系列（38）：设计模式之职责链模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-迭代器模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="迭代器模式介绍"><a href="#迭代器模式介绍" class="headerlink" title="迭代器模式介绍"></a>迭代器模式介绍</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>使用的好处：迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。<br>先看一个 jquery 迭代器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.each(array, function (i, n) &#123;</span><br><span class="line">	console.log(`当前为第$&#123;i&#125;项，值为$&#123;n&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="封装迭代器"><a href="#封装迭代器" class="headerlink" title="封装迭代器"></a>封装迭代器</h1><h2 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h2><p>定义：迭代函数内部已经定义好了迭代原则，它完全接手整个迭代过程，外部只需要一次初始调用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const each = function(array, callback) &#123;</span><br><span class="line">	for (let i = 0, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">		callback.call(array[i], array[i], i); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>PS：这里设计each函数时参考了[].forEach函数，callback第一个参数为 value，第二个参数为 index。<br>使用内部迭代器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">each([1,2,3,4], function (val, ind) &#123;</span><br><span class="line">	console.log( val + &quot; - &quot; + ind ); // 输出数组值和下标</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>PS：现在 ES5 已经实现了内部迭代器 [].foreEach(callback(currentValue, index, array)[, this]);<br>详细的使用说明请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">MDN-Array.prototype.forEach()</a></p>
<h2 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h2><p>定义：外部迭代器必须显式地请求迭代下一个元素，外部迭代器增加了一些调用的复杂度，但相对的也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 var Iterator = function (obj) &#123;</span><br><span class="line">	var current = 0;</span><br><span class="line"></span><br><span class="line">	var next = function()&#123;</span><br><span class="line">		current += 1;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	var isDone = function()&#123;</span><br><span class="line">		return current &gt;= obj.length;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	var getCurrItem = function()&#123;</span><br><span class="line">		return obj[ current ];</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	return &#123;</span><br><span class="line">		next: next,</span><br><span class="line">		isDone: isDone,</span><br><span class="line">		getCurrItem: getCurrItem</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：判断两个数组是不是相等<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compare = function( iterator1, iterator2 )&#123;</span><br><span class="line">	while( iterator1.isDone() &amp;&amp; iterator2.isDone() )&#123;</span><br><span class="line">		if( iterator1.getCurrItem() !== iterator2.getCurrItem() )&#123;</span><br><span class="line">			throw new Error( &quot;iterator1 和 iterator2不相等&quot; );</span><br><span class="line">		&#125;</span><br><span class="line">		iterator1.next();</span><br><span class="line">		iterator2.next();</span><br><span class="line">	&#125;</span><br><span class="line">	console.log( &quot;iterator1 和 iterator2相等&quot; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iterator1 = Iterator( [1,2,3,4] );</span><br><span class="line">var iterator2 = Iterator( [1,2,3,4] );</span><br><span class="line"></span><br><span class="line">compare(iterator1,iterator2);</span><br></pre></td></tr></table></figure></p>
<h2 id="中止迭代器"><a href="#中止迭代器" class="headerlink" title="中止迭代器"></a>中止迭代器</h2><p>定义：在迭代过程，通过判断是否退出迭代器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var each = function( arry, callback )&#123;</span><br><span class="line">	for( var i = 0, l = arry.length; i &lt; l; i++ )&#123;</span><br><span class="line">		// callback 的执行结果返回false，提前中止迭代</span><br><span class="line">		if( callback( arry[i], i ) === false )&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">each( [1,2,3,4,5], function ( n, i ) &#123;</span><br><span class="line">	if( n&gt;3 )&#123; // n 大于3的时候中止循环</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(n); // 输出 1 2 3</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="迭代器应用示例"><a href="#迭代器应用示例" class="headerlink" title="迭代器应用示例"></a>迭代器应用示例</h1><p>需求：根据不同的浏览器获取相应的上传组件对象，将不同的上传对象封装到各自的函数里; 如果函数可用，则返回该对象，否则返回false，提示迭代器继续向下迭代。<br>定义上传组件方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将不同的上传对象封装到各自的函数里; 如果函数可用，则返回该对象，否则返回false，提示迭代器继续</span><br><span class="line">var getActiveUploadObj = function()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		return new ActiceXObject( &quot;TXFTNActiveX.FTNUpload&quot; ); // IE 上传控件</span><br><span class="line">	&#125;catch(e)&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var getFlashUploadObj = function()&#123;</span><br><span class="line">	if( supportFlash() )&#123;</span><br><span class="line">		var str = &quot;&lt;object type=&apos;application/x-shockwave-flash&apos;&gt;&lt;/object&gt;&quot;;</span><br><span class="line">		return $( str).appendTo( $(&quot;body&quot;) );</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;;</span><br><span class="line">var getFormUpl0adObj = function()&#123;</span><br><span class="line">	var str = &quot;&lt;input type=&apos;file&apos; type=&apos;file&apos; class=&apos;ui-file&apos; /&gt;&quot;; // 表单上传</span><br><span class="line">	return $( str).appendTo( $(&quot;body&quot;) );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实现迭代器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//迭代器代码</span><br><span class="line">var iteratorUploadObj = function()&#123;</span><br><span class="line">	for( var i = 0, fn; fn = arguments[ i++ ]; )&#123;</span><br><span class="line">		var uploadObj = fn();</span><br><span class="line">		if( uploadObj !== false )&#123;</span><br><span class="line">			return uploadObj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpl0adObj );</span><br></pre></td></tr></table></figure></p>
<p>PS：这里说明一下，如果前面的上传方案可以使用就使用，否则就使用后面的上传方案（但是要保证至少一种方式所有浏览器都能实现）。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.alloyteam.com/2012/10/commonly-javascript-design-patterns-iterator-mode/" target="_blank" rel="noopener">【Javascript设计模式12】-迭代器模式</a><br>    <a href="http://www.cnblogs.com/Medeor/p/5017879.html" target="_blank" rel="noopener">JavaScript设计模式 - 迭代器模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-访问者模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="在访问者模式中，主要包括以下几个角色"><a href="#在访问者模式中，主要包括以下几个角色" class="headerlink" title="在访问者模式中，主要包括以下几个角色"></a>在访问者模式中，主要包括以下几个角色</h1><ol>
<li>抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</li>
<li>访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</li>
<li>抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</li>
<li>元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</li>
<li>结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 访问者  </span><br><span class="line">function Visitor() &#123;  </span><br><span class="line">  this.visit = function( concreteElement ) &#123;  </span><br><span class="line">    concreteElement.doSomething();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 元素类  </span><br><span class="line">function ConceteElement() &#123;  </span><br><span class="line">  this.doSomething = function() &#123;  </span><br><span class="line">    console.log(&quot;这是一个具体元素&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  this.accept = function( visitor ) &#123;  </span><br><span class="line">    visitor.visit(this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// Client  </span><br><span class="line">var ele = new ConceteElement();  </span><br><span class="line">var v = new Visitor();  </span><br><span class="line">ele.accept( v );</span><br></pre></td></tr></table></figure>
<h1 id="访问者模式的适用场景"><a href="#访问者模式的适用场景" class="headerlink" title="访问者模式的适用场景"></a>访问者模式的适用场景</h1><ol>
<li>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</li>
<li>假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</li>
</ol>
<h1 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h1><ol>
<li>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</li>
<li>扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/itpinpai/article/details/51644922" target="_blank" rel="noopener">【JS设计模式】访问者模式的代码示例</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式-适配器模式</title>
    <url>/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="适配器模式介绍"><a href="#适配器模式介绍" class="headerlink" title="适配器模式介绍"></a>适配器模式介绍</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），<br>    适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>使用场景：比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，<br>    因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。<br>    因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题。    </p>
<h1 id="适配两个库"><a href="#适配两个库" class="headerlink" title="适配两个库"></a>适配两个库</h1><ol>
<li>下面我们来实现从Prototype库的$函数到YUI的get方法的转换。<br>这两个函数的功能比较相似，不过先看看她们在接口方面的差别：<br>Prototype库的$函数    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function $()&#123;</span><br><span class="line">	var elments = new Array();</span><br><span class="line">	for(var i=0; i&lt;arguments.length; i++)&#123;</span><br><span class="line">		var element = arguments[i];</span><br><span class="line">		if(typeof element == &apos;string&apos;)&#123;</span><br><span class="line">			element = document.getElementById(element);</span><br><span class="line">		&#125;</span><br><span class="line">		if(arguments.length == 1)&#123;</span><br><span class="line">			return element;</span><br><span class="line">		&#125;</span><br><span class="line">		elments.push(element);</span><br><span class="line">	&#125;</span><br><span class="line">	return elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>YUI的get方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YAHOO.util.Dom.get = function(el)&#123;</span><br><span class="line">	if(YAHOO.lang.isString(el))&#123;</span><br><span class="line">		return document.getElementById(el);</span><br><span class="line">	&#125;</span><br><span class="line">	if(YAHOO.lang.isArray(el))&#123;</span><br><span class="line">		var c = [];</span><br><span class="line">		for(var i= 0, len=el.length; i&lt;len; i++)&#123;</span><br><span class="line">			c[c.length] = YAHOO.util.Dom.get(el[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		return c;</span><br><span class="line">	&#125;</span><br><span class="line">	if(el)&#123;</span><br><span class="line">		return el;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>分析二者的区别：get具有一个参数，这个参数可以是一个HTML元素、字符串或者由字符串或HTML元素组成的数组，<br>与此不同，$函数没有正式列出参数，而是允许客户传入任意数目的参数，不管是字符串还是HTML元素都行。</li>
<li>这里两种转换的适配器就应该这样写<br>$ –&gt; get<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function $2getAdapter()&#123;</span><br><span class="line">	return YAHOO.util.Dom.get(arguments);</span><br><span class="line">&#125;</span><br><span class="line">对于从Prototype改投YUI的人应该如下使用</span><br><span class="line">$ = $2getAdapter;</span><br><span class="line">这样就可以继续使用 $ 方法了。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>get –&gt; $<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function get2$Adapter(el)&#123;</span><br><span class="line">	return $.apply(window, el instanceof Array ?el: [el]);</span><br><span class="line">&#125;</span><br><span class="line">对于从YUI改投Prototype的人应该如下使用</span><br><span class="line">YAHOO.util.Dom.get = get2$Adapter;</span><br><span class="line">这样就可以继续使用 YAHOO.util.Dom.get 方法了。</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>    注意：适配器模式尽量少使用，就类似于在衣服上打补丁。特别是在接口还没有确定的时候使用，因为这样后期不利于维护，相反，这个时候我们应该重新思考我们的接口设计是否合理。 
</strong><br>那合适使用适配器模式好呢？如果有以下情况出现时，建议使用：</p>
<ol>
<li>使用一个已经存在的对象，但其方法或属性接口不符合你的要求；</li>
<li>你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作；</li>
<li>想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。</li>
</ol>
<p>另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别：</p>
<ol>
<li>适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。</li>
<li>装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的。</li>
<li>代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理。        </li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.alloyteam.com/2012/10/commonly-javascript-design-patterns-adapter-mode/" target="_blank" rel="noopener">腾讯-曽探</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/11/2435452.html" target="_blank" rel="noopener">深入理解JavaScript系列（39）：设计模式之适配器模式</a><br>    <a href="http://www.cnblogs.com/JChen666/p/3658551.html" target="_blank" rel="noopener">JS设计模式——11.适配器模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象编程-构造函数的继承</title>
    <url>/2017/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-1.html</url>
    <content><![CDATA[<p>重新复习 – js面向对象编程知识，本文介绍-对象之间的”继承”的五种方法。</p>
<h4 id="先来两个构造函数（父类和子类）"><a href="#先来两个构造函数（父类和子类）" class="headerlink" title="先来两个构造函数（父类和子类）"></a>先来两个构造函数（父类和子类）</h4><pre><code>现有一个&quot;动物&quot;对象的构造函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal () &#123;</span><br><span class="line">	this.species = &quot;动物&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

再来一只&quot;猫&quot;对象的构造函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="一、构造函数绑定"><a href="#一、构造函数绑定" class="headerlink" title="一、构造函数绑定"></a>一、构造函数绑定</h4><pre><code>使用call或apply方法，将父对象的构造函数绑定在子对象上。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	Animal.call(this, arguments); // 构造函数绑定-继承</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</span><br><span class="line">console.log(cat1); // &#123;species: &quot;动物&quot;, name: &quot;小白&quot;, color: &quot;红色&quot;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="二、prototype模式"><a href="#二、prototype模式" class="headerlink" title="二、prototype模式"></a>二、prototype模式</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal () &#123;</span><br><span class="line">	this.species = &quot;动物&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = new Animal(); // prototype模式-继承</span><br><span class="line">Cat.prototype.constructor = Cat; // 重新将constructor指向Cat</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</span><br><span class="line">console.log(cat1.species); // 动物</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="三、直接继承prototype"><a href="#三、直接继承prototype" class="headerlink" title="三、直接继承prototype"></a>三、直接继承prototype</h4><pre><code>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal () &#123; &#125;</span><br><span class="line">Animal.prototype.species = &apos;动物&apos;;</span><br><span class="line"></span><br><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Cat.prototype = Animal.prototype; // 直接继承prototype</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</span><br><span class="line">console.log(cat1.species); // 动物</span><br></pre></td></tr></table></figure>

与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。
console.log(Animal.prototype.constructor); // Cat
</code></pre><h4 id="四、利用空对象作为中介"><a href="#四、利用空对象作为中介" class="headerlink" title="四、利用空对象作为中介"></a>四、利用空对象作为中介</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal () &#123; &#125;</span><br><span class="line">Animal.prototype.species = &apos;动物&apos;;</span><br><span class="line"></span><br><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 空对象作为中介</span><br><span class="line">let F = function () &#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new F(); </span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</span><br><span class="line">console.log(cat1.species); // 动物</span><br></pre></td></tr></table></figure>

还可以单独封装成方法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let extend = function (child, parent) &#123;</span><br><span class="line">	let F = function () &#123;&#125;;</span><br><span class="line">	F.prototype = parent.prototype;</span><br><span class="line">	child.prototype = new F();</span><br><span class="line">	child.prototype.constructor = child;</span><br><span class="line">&#125;;</span><br><span class="line">extend(Cat, Animal);</span><br><span class="line">let cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</span><br><span class="line">console.log(cat1.species); // 动物</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="五、拷贝继承"><a href="#五、拷贝继承" class="headerlink" title="五、拷贝继承"></a>五、拷贝继承</h4><pre><code>简单说，如果把父对象的所有属性和方法，拷贝进子对象。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal () &#123; &#125;</span><br><span class="line">Animal.prototype.species = &apos;动物&apos;;</span><br><span class="line"></span><br><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝继承</span><br><span class="line">function extend2 (child, parent) &#123;</span><br><span class="line">	let p = parent.prototype;</span><br><span class="line">	let c = child.prototype;</span><br><span class="line">	for (let i in p) &#123;</span><br><span class="line">		c[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">extend2(Cat, Animal);</span><br><span class="line">let cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);</span><br><span class="line">console.log(cat1.species) // 动物</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考：<br>    <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">阮老师-Javascript面向对象编程（二）：构造函数的继承</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象编程-非构造函数的继承</title>
    <url>/2017/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-2.html</url>
    <content><![CDATA[<p>重新复习 – js面向对象编程知识，本文介绍-对象之间的非构造函数实现”继承”。</p>
<h4 id="先来两个对象（父类和子类）"><a href="#先来两个对象（父类和子类）" class="headerlink" title="先来两个对象（父类和子类）"></a>先来两个对象（父类和子类）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Chinese = &#123;</span><br><span class="line">	nation: &apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let Doctor = &#123;</span><br><span class="line">	career: &apos;医生&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="一、object-方法"><a href="#一、object-方法" class="headerlink" title="一、object()方法"></a>一、object()方法</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Chinese = &#123;</span><br><span class="line">	nation: &apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function object (o) &#123;</span><br><span class="line">	function F () &#123;&#125;;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Doctor = object(Chinese);</span><br><span class="line">Doctor.career = &apos;医生&apos;;</span><br><span class="line">console.log(Doctor.nation) // 中国</span><br></pre></td></tr></table></figure>

这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。
</code></pre><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code>把父对象的属性，全部拷贝给子对象，也能实现继承。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Chinese = &#123;</span><br><span class="line">	nation: &apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function extendCopy (p) &#123;</span><br><span class="line">	let c = &#123;&#125;;</span><br><span class="line">	for (let i in p) &#123;</span><br><span class="line">		c[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br><span class="line">let Doctor = extendCopy(Chinese);</span><br><span class="line">Doctor.career = &apos;医生&apos;;</span><br><span class="line">console.log(Doctor.nation) // 中国</span><br></pre></td></tr></table></figure>

存在问题：只拷贝基本类型，对于引用类型拷贝内存地址，存在父对象别篡改的可能。
</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><pre><code>所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Chinese = &#123;</span><br><span class="line">	nation: &apos;中国&apos;,</span><br><span class="line">	cities: [&apos;成都&apos;, &apos;北京&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">function deepCopy(p, c) &#123;</span><br><span class="line">	var c = c || &#123;&#125;;</span><br><span class="line">	for (let i in p) &#123;</span><br><span class="line">		if (typeof p[i] === &apos;object&apos;) &#123;</span><br><span class="line">			c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">			deepCopy(p[i], c[i]);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			c[i] = p[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125; </span><br><span class="line">let Doctor = deepCopy(Chinese);</span><br><span class="line">Doctor.career = &apos;医生&apos;;</span><br><span class="line">console.log(Doctor.cities)  // [&quot;成都&quot;, &quot;北京&quot;]</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考：<br>    <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="noopener">阮老师-Javascript面向对象编程（三）：非构造函数的继承</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-cookie/session</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-cookie-session.html</url>
    <content><![CDATA[<h3 id="koa2使用cookie"><a href="#koa2使用cookie" class="headerlink" title="koa2使用cookie"></a>koa2使用cookie</h3><pre><code>koa提供了从上下文直接读取、写入cookie的方法
</code></pre><ol>
<li>ctx.cookies.get(name, [options]) 读取上下文请求中的cookie</li>
<li>ctx.cookies.set(name, value, [options]) 在上下文写入cookie<br>关键代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cookies = require(&apos;cookies&apos;);</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	if (ctx.url === &apos;/&apos;) &#123;</span><br><span class="line">		// 设置cookies</span><br><span class="line">		ctx.cookies.set(&apos;username&apos;, &apos;fanerge222&apos;, &#123;</span><br><span class="line">			domain: &apos;localhost&apos;, // 写cookie所在的域名</span><br><span class="line">			path: &apos;/&apos;, // 写cookie所在的路径</span><br><span class="line">			maxAge: 10 * 60 * 1000, // cookie有效时长</span><br><span class="line">			expires: new Date(&apos;2017-08-18&apos;), // cookie失效时间</span><br><span class="line">			httpOnly: false, // 是否只用于http请求中获取</span><br><span class="line">			overwrite: false // 是否允许重写</span><br><span class="line">		&#125;);</span><br><span class="line">		ctx.body = &apos;cookies写入成功&apos;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 获取cookie</span><br><span class="line">		const cookie = ctx.cookies.get(&apos;username&apos;); // &apos;fanerge222&apos;</span><br><span class="line">		ctx.body = cookie   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="koa2实现session"><a href="#koa2实现session" class="headerlink" title="koa2实现session"></a>koa2实现session</h3><pre><code>koa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。
在koa2中实现session的方案有以下几种
</code></pre><ol>
<li>如果session数据量很小，可以直接存在内存中</li>
<li>如果session数据量很大，则需要存储介质存放session数据<br>数据库存储方案</li>
<li>将session存放在MySQL数据库中</li>
<li>需要用到中间件<br>koa-session-minimal 适用于koa2 的session中间件，提供存储介质的读写接口 。<br>koa-mysql-session 为koa-session-minimal中间件提供MySQL数据库的session数据读写操作。</li>
<li>将sessionId和对应的数据存到数据库</li>
<li>将数据库的存储的sessionId存到页面的cookie中</li>
<li>根据cookie的sessionId去获取对于的session信息<br>关键代码：    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const session = require(&apos;koa-session-minimal&apos;)</span><br><span class="line">const MysqlSession = require(&apos;koa-mysql-session&apos;)</span><br><span class="line"></span><br><span class="line">// 配置存储session信息的mysql</span><br><span class="line">let store = new MysqlSession(&#123;</span><br><span class="line">  user: &apos;root&apos;,</span><br><span class="line">  password: &apos;root&apos;,</span><br><span class="line">  database: &apos;koa_demo&apos;,</span><br><span class="line">  host: &apos;127.0.0.1&apos;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 存放SESSION_ID的cookie配置</span><br><span class="line">let cookie = &#123;</span><br><span class="line">  maxAge: &apos;&apos;, // cookie有效时长</span><br><span class="line">  expires: &apos;&apos;,  // cookie失效时间</span><br><span class="line">  path: &apos;&apos;, // 写cookie所在的路径</span><br><span class="line">  domain: &apos;&apos;, // 写cookie所在的域名</span><br><span class="line">  httpOnly: &apos;&apos;, // 是否只用于http请求中获取</span><br><span class="line">  overwrite: &apos;&apos;,  // 是否允许重写</span><br><span class="line">  secure: &apos;&apos;,</span><br><span class="line">  sameSite: &apos;&apos;,</span><br><span class="line">  signed: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用session中间件</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  key: &apos;SESSION_ID&apos;,</span><br><span class="line">  store: store, // 使用数据库来存储</span><br><span class="line">  cookie: cookie // 将SESSION_ID存在cookie中</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use( async ( ctx ) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 设置session</span><br><span class="line">  if ( ctx.url === &apos;/set&apos; ) &#123;</span><br><span class="line">	ctx.session = &#123;</span><br><span class="line">	  user_id: Math.random().toString(36).substr(2),</span><br><span class="line">	  count: 0</span><br><span class="line">	&#125;</span><br><span class="line">	ctx.body = ctx.session</span><br><span class="line">  &#125; else if ( ctx.url === &apos;/&apos; ) &#123;</span><br><span class="line"></span><br><span class="line">	// 读取session信息</span><br><span class="line">	ctx.session.count = ctx.session.count + 1</span><br><span class="line">	ctx.body = ctx.session</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-static" target="_blank" rel="noopener">koa-static</a><br>    <a href="https://www.npmjs.com/package/koa-session-minimal" target="_blank" rel="noopener">koa-session-minimal</a><br>    <a href="https://www.npmjs.com/package/koa-mysql-session" target="_blank" rel="noopener">koa-mysql-session</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象编程-&quot;封装&quot;（Encapsulation）</title>
    <url>/2017/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[<p>重新复习 – js面向对象编程知识</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Cat (name, color) &#123;</span><br><span class="line">	this.name = name; // 使用动态作用域this</span><br><span class="line">	this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.type = &apos;猫科动物&apos;;</span><br><span class="line">Cat.prototype.eat = function () &#123;</span><br><span class="line">	console.log(&apos;吃老鼠&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let cat1 =new Cat(&apos;大毛&apos;, &apos;黄色&apos;);</span><br><span class="line">let cat2 =new Cat(&apos;小毛&apos;, &apos;黑色&apos;);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="constructor-—-每个实例都有一个constructor属性，指向它们的构造函数"><a href="#constructor-—-每个实例都有一个constructor属性，指向它们的构造函数" class="headerlink" title="constructor — 每个实例都有一个constructor属性，指向它们的构造函数"></a>constructor — 每个实例都有一个constructor属性，指向它们的构造函数</h4><pre><code>// console.log(cat1.constructor == Cat) true
</code></pre><h4 id="instanceof-—-验证原型对象与实例之间的关系"><a href="#instanceof-—-验证原型对象与实例之间的关系" class="headerlink" title="instanceof — 验证原型对象与实例之间的关系"></a>instanceof — 验证原型对象与实例之间的关系</h4><pre><code>// console.log(cat1 instanceof Cat) true
// console.log(cat1.type); 猫科动物
// console.log(cat1.type === cat2.type) true 都从原型中获得
// cat1.eat() 吃老鼠
</code></pre><h5 id="isPrototypeOf-—-某个proptotype对象和某个实例之间的关系。"><a href="#isPrototypeOf-—-某个proptotype对象和某个实例之间的关系。" class="headerlink" title="isPrototypeOf() — 某个proptotype对象和某个实例之间的关系。"></a>isPrototypeOf() — 某个proptotype对象和某个实例之间的关系。</h5><pre><code>// console.log(Cat.prototype.isPrototypeOf(cat1)) true
</code></pre><h5 id="hasOwnProperty-—-每个实例对象都有一个hasOwnProperty-方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。"><a href="#hasOwnProperty-—-每个实例对象都有一个hasOwnProperty-方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。" class="headerlink" title="hasOwnProperty() — 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。"></a>hasOwnProperty() — 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</h5><pre><code>// console.log(cat1.hasOwnProperty(&apos;name&apos;)); true
// console.log(cat1.hasOwnProperty(&apos;eat&apos;)); false
</code></pre><h5 id="in运算符-—-某个实例是否含有某个属性，不管是不是本地属性"><a href="#in运算符-—-某个实例是否含有某个属性，不管是不是本地属性" class="headerlink" title="in运算符 — 某个实例是否含有某个属性，不管是不是本地属性"></a>in运算符 — 某个实例是否含有某个属性，不管是不是本地属性</h5><pre><code>// console.log(&apos;name&apos; in cat1); true
// console.log(&apos;eat&apos; in cat1); true
</code></pre><h4 id="总结对象属性的遍历"><a href="#总结对象属性的遍历" class="headerlink" title="总结对象属性的遍历"></a>总结对象属性的遍历</h4><pre><code>1.    in --- 遍历**可枚举的自身属性和继承属性**
2.    Object.getOwnPropertyNames() --- 遍历所有的自身属性
3.    Object.keys(obj) --- 遍历**可枚举的自身属性**，返回一个属性数组
</code></pre><blockquote>
<p>   参考：<br>    <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noopener">阮老师-Javascript面向对象编程（一）：封装</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-debug</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-debug.html</url>
    <content><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><pre><code>node环境 8.x +
chrome 60+
index.js
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use( async ( ctx ) =&gt; &#123;</span><br><span class="line">  ctx.body = &apos;hello koa2&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;[demo] start-quick is starting at port 3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="进行调试"><a href="#进行调试" class="headerlink" title="进行调试"></a>进行调试</h3><pre><code>node --inspect index.js
在控制台上点击node调试，会弹出新窗口，此时就可以进入调试--如打断点。
</code></pre><blockquote>
<p>   参考文档：<br>        <a href="https://chenshenhai.github.io/koa2-note/note/debug/info.html" target="_blank" rel="noopener">debug</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-jsonp实现</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-jsonp%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h3 id="原生koa2实现jsonp"><a href="#原生koa2实现jsonp" class="headerlink" title="原生koa2实现jsonp"></a>原生koa2实现jsonp</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const koa = require(&apos;koa&apos;);</span><br><span class="line"></span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	// 判断是否为jsonp的请求</span><br><span class="line">	if (ctx.method === &apos;GET&apos; &amp;&amp; ctx.url.split(&apos;?&apos;)[0] === &apos;/getData.jsonp&apos;) &#123;</span><br><span class="line">		// 获取jsonp的callback</span><br><span class="line">		let callbackName = ctx.query.callback || &apos;callback&apos;;</span><br><span class="line">		let returnData = &#123;</span><br><span class="line">			success: true,</span><br><span class="line">			data: &#123;</span><br><span class="line">				text: &apos;this is a jsonp api&apos;,</span><br><span class="line">				time: new Date().getTime()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		// jsonp的script字符串</span><br><span class="line">		let jsonpStr = `;$&#123;callbackName&#125;($&#123;JSON.stringify(returnData)&#125;)`;      </span><br><span class="line">		// 用text/javascript，让请求支持跨域获取</span><br><span class="line">		ctx.type = &apos;text/javascript&apos;;</span><br><span class="line">		// 输出jsonp字符串</span><br><span class="line">		ctx.body = jsonpStr</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ctx.body = &apos;hello jsonp&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3004, () =&gt; &#123;</span><br><span class="line">	console.log(&apos;[demo] jsonp is starting at port 3004&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="koa-jsonp中间件实现"><a href="#koa-jsonp中间件实现" class="headerlink" title="koa-jsonp中间件实现"></a>koa-jsonp中间件实现</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const koa = require(&apos;koa&apos;);</span><br><span class="line">const jsonp = require(&apos;koa-jsonp&apos;);</span><br><span class="line"></span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">app.use(jsonp());</span><br><span class="line"></span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	let returnData = &#123;</span><br><span class="line">		success: true,</span><br><span class="line">		data: &#123;</span><br><span class="line">			text: &apos;this is a jsonp api&apos;,</span><br><span class="line">			time: new Date().getTime(),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	// 直接输出json</span><br><span class="line">	ctx.body = returnData;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3004, () =&gt; &#123;</span><br><span class="line">	console.log(&apos;[demo] jsonp is starting at port 3004&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-jsonp" target="_blank" rel="noopener">koa-jsonp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-中间件和路由</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1.html</url>
    <content><![CDATA[<h2 id="koa中间件的制作和使用"><a href="#koa中间件的制作和使用" class="headerlink" title="koa中间件的制作和使用"></a>koa中间件的制作和使用</h2><h3 id="koa模版"><a href="#koa模版" class="headerlink" title="koa模版"></a>koa模版</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new koa();</span><br><span class="line">// 中间件</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	ctx.body = &apos;hello koa2&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getSyncTime () &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			let startTime = new Date().getTime();</span><br><span class="line">			setTimeout(() =&gt; &#123;</span><br><span class="line">				let endTime = new Date().getTime();</span><br><span class="line">				let data = endTime - startTime;</span><br><span class="line">				resolve(data);</span><br><span class="line">			&#125;, 500);</span><br><span class="line">		&#125; catch (e) &#123;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getSyncData () &#123;</span><br><span class="line">	let time = await getSyncTime();</span><br><span class="line">	let data = `endTime - startTime = $&#123;time&#125;`;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">getSyncData();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="koa2简析结构"><a href="#koa2简析结构" class="headerlink" title="koa2简析结构"></a>koa2简析结构</h3><pre><code>源码文件：
├── lib
│   ├── application.js
│   ├── context.js
│   ├── request.js
│   └── response.js
└── package.json
文件说明：
application.js 是整个koa2 的入口文件，封装了context，request，response，以及最核心的中间件处理流程。
context.js 处理应用上下文，里面直接封装部分request.js和response.js的方法
request.js 处理http请求
response.js 处理http响应
</code></pre><h3 id="koa中间件开发和使用"><a href="#koa中间件开发和使用" class="headerlink" title="koa中间件开发和使用"></a>koa中间件开发和使用</h3><pre><code>以日志中间件为例
middleware/logger-async.js
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log (ctx) &#123;</span><br><span class="line">	console.log(`请求方法：$&#123;ctx.method&#125;, host：$&#123;ctx.header.host&#125;, url：$&#123;ctx.url&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function () &#123;</span><br><span class="line">	return async function (ctx, next)&#123;</span><br><span class="line">		log(ctx);</span><br><span class="line">		await next();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

使用该中间件logger
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const loggerAsync  = require(&apos;./middleware/logger-async&apos;);</span><br><span class="line">// 使用日志中间件</span><br><span class="line">app.use(loggerAsync());</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="koa路由中间件"><a href="#koa路由中间件" class="headerlink" title="koa路由中间件"></a>koa路由中间件</h2><h3 id="koa2原生路由实现"><a href="#koa2原生路由实现" class="headerlink" title="koa2原生路由实现"></a>koa2原生路由实现</h3><pre><code>获取url：ctx.request.url
后端路由：根据前端get请求的url地址，后端返回对应的view页面达到。
</code></pre><h3 id="koa-router中间件"><a href="#koa-router中间件" class="headerlink" title="koa-router中间件"></a>koa-router中间件</h3><pre><code>安装koa-router中间件
    npm install --save koa-router
使用koa-router
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 子路由1</span><br><span class="line">let home = new Router();</span><br><span class="line">home.get(&apos;/&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">	let html = `</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;&lt;a href=&quot;/&quot;&gt;/&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;&lt;a href=&quot;/page&quot;&gt;/page&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;&lt;a href=&quot;/page/helloword&quot;&gt;/page/helloword&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;&lt;a href=&quot;/page/chengdu&quot;&gt;/page/chengdu&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;&lt;a href=&quot;/page/ss&quot;&gt;not found&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">	`;</span><br><span class="line">	ctx.body = html;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 子路由2</span><br><span class="line">let page = new Router();</span><br><span class="line">page.get(&apos;/&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">	ctx.body = &apos;page主页&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">.get(&apos;/chengdu&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">	ctx.body = &apos;欢迎来到成都&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">.get(&apos;/helloword&apos;, (ctx) =&gt; &#123;</span><br><span class="line">	ctx.body = &apos;helloword page&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 子路由3-Not found</span><br><span class="line">let notFound = new Router();</span><br><span class="line">notFound.get(&apos;*&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">	ctx.body = &apos;没有找到！&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 装载所有的子路由</span><br><span class="line">let router = new Router();</span><br><span class="line">router.use(&apos;/&apos;, home.routes(), home.allowedMethods());</span><br><span class="line">router.use(&apos;/page&apos;, page.routes(), page.allowedMethods());</span><br><span class="line">router.use(&apos;*&apos;, notFound.routes(), notFound.allowedMethods());</span><br><span class="line"></span><br><span class="line">// 加载路由中间件</span><br><span class="line">app.use(router.routes())</span><br><span class="line">.use(router.allowedMethods());</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/get.html" target="_blank" rel="noopener">koa2-note</a><br>    <a href="https://www.npmjs.com/package/koa-router" target="_blank" rel="noopener">koa-router官方文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-总结</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h2 id="一个koa示例"><a href="#一个koa示例" class="headerlink" title="一个koa示例"></a>一个koa示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">// 使用中间件</span><br><span class="line">app.use(); // @param function</span><br><span class="line">// 监听端口，开启服务</span><br><span class="line">app.listen(1314, () =&gt; &#123;</span><br><span class="line">	console.log(&apos;success&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Context-对象"><a href="#Context-对象" class="headerlink" title="Context 对象"></a>Context 对象</h2><pre><code>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。
koa 通过 ctx.request.accepts 设置期望返回的类型内容，默认为 text/plain。        
koa 通过 ctx.response.type 指定返回类型。
示例：常用的格式xml、json、html、text等。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	app.use((ctx) =&gt; &#123;</span><br><span class="line">		if (ctx.request.accepts(&apos;xml&apos;)) &#123;</span><br><span class="line">			ctx.response.type = &apos;xml&apos;;</span><br><span class="line">			ctx.response.body = &apos;&lt;data&gt;我是xml&lt;/data&gt;&apos;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctx.response.type = &apos;text&apos;;</span><br><span class="line">			ctx.response.body = &apos;我是text&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	```	</span><br><span class="line">示例：实际开发（网页模板）</span><br><span class="line">	直接返回template.html</span><br></pre></td></tr></table></figure>

    app.use(ctx =&gt; {
      ctx.response.type = &apos;html&apos;;
      ctx.response.body = fs.createReadStream(&apos;./views/template.html&apos;);
    });
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##	路由</span><br><span class="line">	通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。</span><br><span class="line">###	原生路由</span><br></pre></td></tr></table></figure>

    const main = ctx =&gt; {
        ctx.response.type = &apos;html&apos;;
      if (ctx.request.path === &apos;/&apos;) {
        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;
      } else if (ctx.request.path === &apos;/get&apos;) {
        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Get Page&lt;/a&gt;&apos;;
      } else {
        ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;other Page&lt;/a&gt;&apos;;
      }
    };
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	koa-route 模块</span><br></pre></td></tr></table></figure>

const Koa = require(&apos;koa&apos;);
const route = require(&apos;koa-route&apos;);
const app = new Koa();

const about = ctx =&gt; {
    ctx.response.type = &apos;html&apos;;
    ctx.response.body = &apos;&lt;p&gt;about page&lt;/p&gt;&apos;
};

const user = ctx =&gt; {
    ctx.response.type = &apos;html&apos;;
    ctx.response.body = &apos;&lt;p&gt;user page&lt;/p&gt;&apos;
};

const main = ctx =&gt; {
    ctx.response.type = &apos;html&apos;;
    ctx.response.body = &apos;hello world&apos;
};

app.use(route.get(&apos;/&apos;, main)); // 主页
app.use(route.get(&apos;/about&apos;, about)); // about页面
app.use(route.get(&apos;/user&apos;, user)); // user页面

// app.use(main);
app.listen(3000);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##	静态资源 和 重定向</span><br><span class="line">###	静态资源</span><br><span class="line">	如果网站提供静态资源（图片、字体、样式表、脚本......）。</span><br><span class="line">	koa-static 模块封装了这部分的请求。</span><br><span class="line">	示例：请求本地12.js</span><br></pre></td></tr></table></figure>

const Koa = require(&apos;koa&apos;);
const app = new Koa();
const path = require(&apos;path&apos;);
const serve = require(&apos;koa-static&apos;);

const main = serve(path.join(__dirname));

app.use(main);
app.listen(3000);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	说明：__dirname 表示 node.js 执行环境路径。</span><br><span class="line">	请求资源： http://127.0.0.1:3000/12.js</span><br><span class="line">###	重定向</span><br><span class="line">	有些场合，服务器需要重定向（redirect）访问请求。</span><br><span class="line">	比如，用户登陆以后，将他重定向到登陆前的页面。</span><br><span class="line">	ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。</span><br></pre></td></tr></table></figure>

const redirect = ctx =&gt; {
  ctx.response.redirect(&apos;/&apos;);
};

const main = ctx =&gt; {
  ctx.response.body = &apos;Hello World&apos;;
};

app.use(route.get(&apos;/&apos;, main));
app.use(route.get(&apos;/redirect&apos;, redirect)); // 当请求路径为 /redirect 时，执行 redirect 方法，进行重定向
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。</span><br><span class="line">##	中间件</span><br><span class="line">###	设计中间件</span><br><span class="line">	Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。</span><br><span class="line">	示例：自己设计一个logger中间件。</span><br></pre></td></tr></table></figure>

/**
* 定义日志中间件 logger
* @param ctx {object} 上下文对象 
* @param next {function} 下一个中间件执行权
*/
const logger = (ctx, next) =&gt; {
    console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);
    next(); // 只要调用next函数，就可以把执行权转交给下一个中间件。
};
// 使用中间件
app.use(logger);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	中间件特性</span><br><span class="line">	多个中间件会形成一个栈结构（middle stack），以&quot;先进后出&quot;（first-in-last-out）的顺序执行。</span><br></pre></td></tr></table></figure>

const one = (ctx, next) =&gt; {
  console.log(&apos;&gt;&gt; one&apos;);
  next();
  console.log(&apos;&lt;&lt; one&apos;);
}

const two = (ctx, next) =&gt; {
  console.log(&apos;&gt;&gt; two&apos;);
  next(); 
  console.log(&apos;&lt;&lt; two&apos;);
}

const three = (ctx, next) =&gt; {
  console.log(&apos;&gt;&gt; three&apos;);
  next();
  console.log(&apos;&lt;&lt; three&apos;);
}

app.use(one);
app.use(two);
app.use(three);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	输出：</span><br><span class="line">	&gt;&gt; one   // one中间件进栈</span><br><span class="line">	&gt;&gt; two   // two中间件进栈</span><br><span class="line">	&gt;&gt; three // three中间件进栈</span><br><span class="line">	&lt;&lt; three // three中间件 出栈</span><br><span class="line">	&lt;&lt; two   // two中间件 出栈</span><br><span class="line">	&lt;&lt; one	 // one中间件 出栈	</span><br><span class="line">###	异步中间件</span><br><span class="line">	如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。</span><br><span class="line">	实例：异步 main 中间件</span><br></pre></td></tr></table></figure>

const fs = require(&apos;fs.promised&apos;);

const main = async function (ctx, next) {
  ctx.response.type = &apos;html&apos;;
  ctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;);
};
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	fs.readFile是一个异步操作，必须写成异步中间件。</span><br><span class="line">###	koa-compose模块可以将多个中间件合成为一个。</span><br><span class="line">	示例：合并 logger 和 main 中间件。</span><br></pre></td></tr></table></figure>

const compose = require(&apos;koa-compose&apos;);

const middlewares = compose([logger, main]);
app.use(middlewares);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##	错误处理</span><br><span class="line">	如果代码运行过程中发生错误，我们需要把错误信息返回给用户。</span><br><span class="line">###	500错误</span><br><span class="line">	HTTP 协定约定这时要返回500状态码。</span><br><span class="line">	Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误。</span><br></pre></td></tr></table></figure>

const main = ctx =&gt; {
    ctx.throw(500);
};
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	404错误</span><br><span class="line">	如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。</span><br></pre></td></tr></table></figure>

const main = ctx =&gt; {
  ctx.response.status = 404; // ctx.throw(404);
  ctx.response.body = &apos;Page Not Found&apos;;
};
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	处理错误的中间件	</span><br><span class="line">	为了方便处理错误，最好使用try...catch将其捕获。</span><br><span class="line">	但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。</span><br></pre></td></tr></table></figure>

// 最外层中间件
const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.body = {
      message: err.message
    };
  }
};
// 内层中间件
const main = ctx =&gt; {
  ctx.throw(404);
};
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	error 事件的监听</span><br><span class="line">	运行过程中一旦出错，Koa 会触发一个error事件。</span><br><span class="line">	监听这个事件，也可以处理错误。</span><br></pre></td></tr></table></figure>

const main = ctx =&gt; {
    ctx.throw(500); // 直接触发错误
};
// 监听错误
app.on(&apos;error&apos;, (err, ctx) =&gt; {
    console.error(&apos;server error&apos;, err);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	释放 error 事件	</span><br><span class="line">	需要注意的是，如果错误被try...catch捕获，就不会触发error事件。</span><br><span class="line">	这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。</span><br></pre></td></tr></table></figure>

const handler = async (ctx, next) =&gt; {
    try {
        await next();
    } catch (err) {
        ctx.response.status = err.statusCode || err.status || 500;
        ctx.response.type = &apos;html&apos;;
        ctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;;
        ctx.app.emit(&apos;error&apos;, err, ctx);
    }
};

const main = ctx =&gt; {
    ctx.throw(500);
};

app.on(&apos;error&apos;, function(err) {
    console.log(&apos;logging error &apos;, err.message);
    console.log(err);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	main函数抛出错误，被handler函数捕获。</span><br><span class="line">	catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。</span><br><span class="line">##	Web App 的功能</span><br><span class="line">###	Cookies</span><br><span class="line">	ctx.cookies 用来读写 Cookie。</span><br></pre></td></tr></table></figure>

const main = function(ctx) {
    const n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1;
    ctx.cookies.set(&apos;view&apos;, n);
    ctx.response.body = n + &apos; views&apos;;
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	表单</span><br><span class="line">	Web 应用离不开处理表单。</span><br><span class="line">	表单就是 POST 方法发送到服务器的键值对。</span><br><span class="line">	koa-body模块可以用来从 POST 请求的数据体里面提取键值对。</span><br></pre></td></tr></table></figure>

const koaBody = require(&apos;koa-body&apos;);

const main = async function (ctx) {
    const body = ctx.request.body;
    if (!body.name) ctx.throw(400, &apos;.name required&apos;);
    ctx.body = { name: body.name };
};

app.use(koaBody());
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	文件上传</span><br><span class="line">	koa-body模块还可以用来处理文件上传。</span><br></pre></td></tr></table></figure>

const os = require(&apos;os&apos;);
const path = require(&apos;path&apos;);
const koaBody = require(&apos;koa-body&apos;);

const main = async function(ctx) {
    const tmpdir = os.tmpdir();
    const filePaths = [];
    const files = ctx.request.body.files || {};

    for (let key in files) {
        const file = files[key];
        const filePath = path.join(tmpdir, file.name);
        const reader = fs.createReadStream(file.path);
        const writer = fs.createWriteStream(filePath);
        reader.pipe(writer);
        filePaths.push(filePath);
    }

    ctx.body = filePaths;
};

app.use(koaBody({ multipart: true }));
```
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="noopener">阮一峰老师的koa教程</a><br>    <a href="https://www.npmjs.com/package/koa-router" target="_blank" rel="noopener">koa-router官方文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-搭建项目</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE.html</url>
    <content><![CDATA[<blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="noopener">cookies</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-数据库mysql</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93mysql.html</url>
    <content><![CDATA[<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mysql = require(&apos;mysql&apos;);</span><br><span class="line">// 数据库的配置信息</span><br><span class="line">const connection = mysql.createConnection(&#123;</span><br><span class="line">	host: &apos;localhost&apos;,</span><br><span class="line">	port: 3306,</span><br><span class="line">	user: &apos;root&apos;,</span><br><span class="line">	password: &apos;root&apos;,</span><br><span class="line">	database: &apos;sql&apos;</span><br><span class="line">&#125;);</span><br><span class="line">// 连接数据库</span><br><span class="line">connection.connect();</span><br><span class="line">// 进行数据库操作</span><br><span class="line">connection.query(&apos;SELECT * FROM apps&apos;, (err, result) =&gt; &#123;</span><br><span class="line">	if (err)  throw err;</span><br><span class="line">	console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line">// 关闭连接</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="创建数据连接池"><a href="#创建数据连接池" class="headerlink" title="创建数据连接池"></a>创建数据连接池</h3><pre><code>一般情况下操作数据库是很复杂的读写过程，不只是一个会话，如果直接用会话操作，就需要每次会话都要配置连接参数。
所以这时候就需要连接池管理会话。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mysql = require(&apos;mysql&apos;);</span><br><span class="line">const pool = mysql.createPool(&#123;</span><br><span class="line">	host: &apos;localhost&apos;,</span><br><span class="line">	port: 3306,</span><br><span class="line">	user: &apos;root&apos;,</span><br><span class="line">	password: &apos;root&apos;,</span><br><span class="line">	database: &apos;sql&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在数据池中进行会话操作</span><br><span class="line">pool.getConnection((err, connection) =&gt; &#123;</span><br><span class="line">	connection.query(&apos;SELECT * FROM apps&apos;, (err, result) =&gt; &#123;</span><br><span class="line">		console.log(result);</span><br><span class="line">		// 连接完成，连接将返回连接池</span><br><span class="line">		connection.release();</span><br><span class="line">		if (err) throw err;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="使用promise和async-await来封装"><a href="#使用promise和async-await来封装" class="headerlink" title="使用promise和async-await来封装"></a>使用promise和async-await来封装</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// promise.js</span><br><span class="line">const mysql = require(&apos;mysql&apos;);</span><br><span class="line">const pool = mysql.createPool(&#123;</span><br><span class="line">	host     :  &apos;127.0.0.1&apos;,</span><br><span class="line">	user     :  &apos;root&apos;,</span><br><span class="line">	password :  &apos;root&apos;,</span><br><span class="line">	database :  &apos;sql&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let query = function (sql) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		pool.getConnection((err, connection) =&gt; &#123;</span><br><span class="line">			if (err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				connection.query(sql, (err, rows) =&gt; &#123;</span><br><span class="line">					if (err) &#123;</span><br><span class="line">						reject(err)</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						resolve(rows);</span><br><span class="line">					&#125;</span><br><span class="line">				connection.release();   </span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = query;</span><br><span class="line"></span><br><span class="line">// async.js</span><br><span class="line">const query = require(&apos;./promise&apos;);</span><br><span class="line"></span><br><span class="line">async function getData (sql) &#123;</span><br><span class="line">	let dataList = await query(sql);</span><br><span class="line">	console.log(dataList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(&apos;SELECT * FROM sql&apos;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="建表初始化"><a href="#建表初始化" class="headerlink" title="建表初始化"></a>建表初始化</h3><pre><code>+----------+  遍历sql  +---+ 解析所有sql +---+  执行sql  +------------&gt;
       |   |  目录下的  |   |  文件脚本  |   |   脚本     |   |
+----------+  sql文件   +---+   内容    +---+           +------------&gt;

[详细代码见]()
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="noopener">cookies</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-文件上传</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</url>
    <content><![CDATA[<h3 id="busboy模块"><a href="#busboy模块" class="headerlink" title="busboy模块"></a>busboy模块</h3><pre><code>模块是用来解析POST请求，node原生req中的文件流。
busboy 是用来解析出请求中文件流。
</code></pre><h3 id="封装上传文件到写入服务的方法"><a href="#封装上传文件到写入服务的方法" class="headerlink" title="封装上传文件到写入服务的方法"></a>封装上传文件到写入服务的方法</h3><pre><code>创建上传模块upload.js
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const inspect = require(&apos;util&apos;).inspect;</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const os = require(&apos;os&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const Busboy = require(&apos;busboy&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 同步创建文件目录</span><br><span class="line">* @param &#123;string&#125; dirname 目录绝对地址</span><br><span class="line">* @return &#123;boolean&#125; 创建目录结果</span><br><span class="line">*/</span><br><span class="line">function mkdirsSync (dirname) &#123;</span><br><span class="line">	if (fs.existsSync(dirname)) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (mkdirsSync(path.dirname(dirname))) &#123;</span><br><span class="line">			fs.mkdirSync(dirname);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 获取上传文件的后缀名</span><br><span class="line">* @param &#123;string&#125; fileName 获取上传文件的后缀名</span><br><span class="line">* @return &#123;string&#125; 文件后缀名</span><br><span class="line">*/</span><br><span class="line">function getSuffixName (fileName) &#123;</span><br><span class="line">	/*let nameList = fileName.split(&apos;.&apos;);</span><br><span class="line">	return nameList[nameList.length-1]*/</span><br><span class="line">	return path.extname(fileName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 上传文件</span><br><span class="line">* @param &#123;object&#125; ctx koa上下文</span><br><span class="line">* @param &#123;object&#125; options 文件上传参数 fileType文件类型， path文件存放路径</span><br><span class="line">* @return &#123;promise&#125;</span><br><span class="line">*/</span><br><span class="line">function uploadFile (ctx, options) &#123;</span><br><span class="line">	let req = ctx.req;</span><br><span class="line">	let res = ctx.res;</span><br><span class="line">	let busboy = new Busboy(&#123;headers: req.headers&#125;);</span><br><span class="line"></span><br><span class="line">	// 获取类型</span><br><span class="line">	let fileType = options.fileType || &apos;common&apos;;</span><br><span class="line">	let filePath = path.join(options.path, fileType);</span><br><span class="line">	let mkdirResult = mkdirsSync(filePath);</span><br><span class="line"></span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		console.log(&apos;文件上传中...&apos;);</span><br><span class="line">		let result = &#123;</span><br><span class="line">			success: false,</span><br><span class="line">			formData: &#123;&#125;,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		// 解析请求文件事件</span><br><span class="line">		busboy.on(&apos;file&apos;, function(fieldname, file, filename, encoding, mimetype) &#123;</span><br><span class="line">		  let fileName = Math.random().toString(16).substr(2) + &apos;.&apos; + getSuffixName(filename)</span><br><span class="line">		  let _uploadFilePath = path.join( filePath, fileName )</span><br><span class="line">		  let saveTo = path.join(_uploadFilePath)</span><br><span class="line"></span><br><span class="line">		  // 文件保存到制定路径</span><br><span class="line">		  file.pipe(fs.createWriteStream(saveTo))</span><br><span class="line"></span><br><span class="line">		  // 文件写入事件结束</span><br><span class="line">		  file.on(&apos;end&apos;, function() &#123;</span><br><span class="line">			result.success = true</span><br><span class="line">			result.message = &apos;文件上传成功&apos;</span><br><span class="line"></span><br><span class="line">			console.log(&apos;文件上传成功！&apos;)</span><br><span class="line">			resolve(result)</span><br><span class="line">		  &#125;)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		// 解析表单中其他字段信息</span><br><span class="line">		busboy.on(&apos;field&apos;, function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) &#123;</span><br><span class="line">		  console.log(&apos;表单字段数据 [&apos; + fieldname + &apos;]: value: &apos; + inspect(val));</span><br><span class="line">		  result.formData[fieldname] = inspect(val);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		// 解析结束事件</span><br><span class="line">		busboy.on(&apos;finish&apos;, function( ) &#123;</span><br><span class="line">		  console.log(&apos;文件上结束&apos;)</span><br><span class="line">		  resolve(result)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		// 解析错误事件</span><br><span class="line">		busboy.on(&apos;error&apos;, function(err) &#123;</span><br><span class="line">		  console.log(&apos;文件上出错&apos;)</span><br><span class="line">		  reject(result)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		req.pipe(busboy)</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports =  &#123;</span><br><span class="line">  uploadFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

入口文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">// const bodyParser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line"></span><br><span class="line">const &#123; uploadFile &#125; = require(&apos;./util/upload&apos;)</span><br><span class="line"></span><br><span class="line">// app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">app.use( async ( ctx ) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if ( ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos; ) &#123;</span><br><span class="line">	// 当GET请求时候返回表单页面</span><br><span class="line">	let html = `</span><br><span class="line">	  &lt;h1&gt;koa2 upload demo&lt;/h1&gt;</span><br><span class="line">	  &lt;form method=&quot;POST&quot; action=&quot;/upload.json&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">		&lt;p&gt;file upload&lt;/p&gt;</span><br><span class="line">		&lt;span&gt;picName:&lt;/span&gt;&lt;input name=&quot;picName&quot; type=&quot;text&quot; /&gt;&lt;br/&gt;</span><br><span class="line">		&lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">		&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">	  &lt;/form&gt;</span><br><span class="line">	`</span><br><span class="line">	ctx.body = html</span><br><span class="line"></span><br><span class="line">  &#125; else if ( ctx.url === &apos;/upload.json&apos; &amp;&amp; ctx.method === &apos;POST&apos; ) &#123;</span><br><span class="line">	// 上传文件请求处理</span><br><span class="line">	let result = &#123; success: false &#125;</span><br><span class="line">	let serverFilePath = path.join( __dirname, &apos;upload-files&apos; )</span><br><span class="line"></span><br><span class="line">	// 上传文件事件</span><br><span class="line">	result = await uploadFile( ctx, &#123;</span><br><span class="line">	  fileType: &apos;album&apos;, // common or album</span><br><span class="line">	  path: serverFilePath</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	ctx.body = result</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">	// 其他请求显示404</span><br><span class="line">	ctx.body = &apos;&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3004, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;[demo] upload-simple is starting at port 3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/cookies" target="_blank" rel="noopener">cookies</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-模版引擎</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E.html</url>
    <content><![CDATA[<h3 id="koa2加载模板引擎"><a href="#koa2加载模板引擎" class="headerlink" title="koa2加载模板引擎"></a>koa2加载模板引擎</h3><pre><code>koa-views - 为koa模版渲染中间件
ejs - 模版引擎
关键代码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">app.use(views(path.join(__dirname, &apos;./view&apos;), &#123;</span><br><span class="line">	extension: &apos;ejs&apos;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	if (ctx.url === &apos;/&apos;) &#123;</span><br><span class="line">	   let title = &apos;hello koa2&apos;;</span><br><span class="line">		await ctx.render(&apos;index&apos;, &#123;</span><br><span class="line">			title,</span><br><span class="line">		&#125;);     </span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		let title = &apos;other&apos;;</span><br><span class="line">		await ctx.render(&apos;index&apos;, &#123;</span><br><span class="line">			title,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="ejs模板引擎"><a href="#ejs模板引擎" class="headerlink" title="ejs模板引擎"></a>ejs模板引擎</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-views" target="_blank" rel="noopener">koa-views</a><br>    <a href="https://www.npmjs.com/package/ejs" target="_blank" rel="noopener">ejs</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-测试</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E6%B5%8B%E8%AF%95.html</url>
    <content><![CDATA[<p>mocha 模块是测试框架<br>chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2<br>supertest 模块是http请求测试库，用来请求API接口</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code>所需测试demo
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">const server = async (ctx, next) =&gt; &#123;</span><br><span class="line">	let result = &#123;</span><br><span class="line">		success: true,</span><br><span class="line">		data: null</span><br><span class="line">	&#125;;</span><br><span class="line">	if (ctx.method === &apos;GET&apos;) &#123;</span><br><span class="line">		if (ctx.url === &apos;/getString.json&apos;) &#123;</span><br><span class="line">			result.data = &apos;this is string data&apos;;</span><br><span class="line">		&#125; else if (ctx.url === &apos;/getNumber.json&apos;)&#123;</span><br><span class="line">			result.data = 123456;    </span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			result.success = false;</span><br><span class="line">		&#125;</span><br><span class="line">		ctx.body = result;</span><br><span class="line">		next &amp;&amp; next();</span><br><span class="line">	&#125; else if (ctx.method === &apos;POST&apos;) &#123;</span><br><span class="line">		if (ctx.url === &apos;/postData.json&apos;) &#123;</span><br><span class="line">			result.data = &apos;ok&apos;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			result.success = false;</span><br><span class="line">		&#125;</span><br><span class="line">		ctx.body = result;</span><br><span class="line">		next &amp;&amp; next();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ctx.body = &apos;hello world&apos;;</span><br><span class="line">		next &amp;&amp; next();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(server);</span><br><span class="line"></span><br><span class="line">module.exports = app;</span><br><span class="line"></span><br><span class="line">app.listen(3004, () =&gt; &#123;</span><br><span class="line">	console.log(&apos;[demo] test-unit is starting at port 3004&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const supertest = require(&apos;supertest&apos;)</span><br><span class="line">const chai = require(&apos;chai&apos;)</span><br><span class="line">const app = require(&apos;./../index&apos;)</span><br><span class="line"></span><br><span class="line">const expect = chai.expect</span><br><span class="line">const request = supertest( app.listen() )</span><br><span class="line"></span><br><span class="line">// 测试套件/组</span><br><span class="line">describe( &apos;开始测试demo的GET请求&apos;, ( ) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 测试用例</span><br><span class="line">  it(&apos;测试/getString.json请求&apos;, ( done ) =&gt; &#123;</span><br><span class="line">	  request</span><br><span class="line">		.get(&apos;/getString.json&apos;)</span><br><span class="line">		.expect(200)</span><br><span class="line">		.end(( err, res ) =&gt; &#123;</span><br><span class="line">			// 断言判断结果是否为object类型</span><br><span class="line">			expect(res.body).to.be.an(&apos;object&apos;)</span><br><span class="line">			expect(res.body.success).to.be.an(&apos;boolean&apos;)</span><br><span class="line">			expect(res.body.data).to.be.an(&apos;string&apos;)</span><br><span class="line">			done()</span><br><span class="line">		&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-jsonp" target="_blank" rel="noopener">koa-jsonp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-请求数据获取</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96.html</url>
    <content><![CDATA[<h3 id="GET请求数据获取"><a href="#GET请求数据获取" class="headerlink" title="GET请求数据获取"></a>GET请求数据获取</h3><pre><code>获取GET请求数据源头是koa中request对象中的query方法或querystring方法，
query返回是格式化好的参数对象，querystring返回的是请求字符串。    
由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。
</code></pre><ol>
<li>是从上下文中直接获取<br>  请求对象ctx.query，返回如 { a:1, b:2 }<br>  请求字符串 ctx.querystring，返回如 a=1&amp;b=2</li>
<li><p>是从上下文的request对象中获取<br>  请求对象ctx.request.query，返回如 { a:1, b:2 }<br>  请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2<br>关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	let url = ctx.url;</span><br><span class="line">	let request = ctx.request;</span><br><span class="line">	// 使用ctx.request对象获取</span><br><span class="line">	let req_query = request.query;</span><br><span class="line">	let req_querystring = request.querystring;</span><br><span class="line">	// 使用ctx对其request属性的引用获取</span><br><span class="line">	let ctx_query = ctx.query;</span><br><span class="line">	let ctx_querystring = ctx.querystring;</span><br><span class="line">	ctx.body = &#123;</span><br><span class="line">		url,</span><br><span class="line">		req_query,</span><br><span class="line">		req_querystring,</span><br><span class="line">		ctx_query,</span><br><span class="line">		ctx_querystring</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出：<br>测试url：<a href="http://localhost:3000/?name=fanerge&amp;age=323" target="_blank" rel="noopener">http://localhost:3000/?name=fanerge&amp;age=323</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	url: &quot;/?name=fanerge&amp;age=323&quot;,</span><br><span class="line">	req_query: &#123;</span><br><span class="line">		name: &quot;fanerge&quot;,</span><br><span class="line">		age: &quot;323&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	req_querystring: &quot;name=fanerge&amp;age=323&quot;,</span><br><span class="line">	ctx_query: &#123;</span><br><span class="line">		name: &quot;fanerge&quot;,</span><br><span class="line">		age: &quot;323&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	ctx_querystring: &quot;name=fanerge&amp;age=323&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="POST请求参数获取"><a href="#POST请求参数获取" class="headerlink" title="POST请求参数获取"></a>POST请求参数获取</h3><pre><code>解析出POST请求上下文中的表单数据
新建一个工具函数库：./util/index.js
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseQueryStr (queryStr) &#123;</span><br><span class="line">	let queryData = &#123;&#125;;</span><br><span class="line">	let queryStrList = queryStr.split(&apos;&amp;&apos;);</span><br><span class="line">	console.log(queryStrList);</span><br><span class="line">	for (let [index, queryStr] of queryStrList.entries()) &#123;</span><br><span class="line">		let itemList = queryStr.split(&apos;=&apos;);</span><br><span class="line">		queryData[itemList[0]] = decodeURIComponent(itemList[1]);</span><br><span class="line">	&#125;</span><br><span class="line">	return queryData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parsePostData (ctx) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			let postData = &quot;&quot;;</span><br><span class="line">			ctx.req.addListener(&apos;data&apos;, (data) =&gt; &#123;</span><br><span class="line">				postData += data;</span><br><span class="line">			&#125;);</span><br><span class="line">			ctx.req.addListener(&apos;end&apos;, ()=&gt; &#123;</span><br><span class="line">				let parseData = parseQueryStr(postData);</span><br><span class="line">				resolve(parseData);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125; catch (e) &#123;</span><br><span class="line">			conole.error(e);</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports= &#123;</span><br><span class="line">	parsePostData,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

post.js关键代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;parsePostData&#125; = require(&apos;./util/index&apos;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123;</span><br><span class="line">		// 当get请求是返回表单页面</span><br><span class="line">		let html = `</span><br><span class="line">			&lt;h1&gt;koa2 request post demo&lt;/h1&gt;</span><br><span class="line">		  &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;</span><br><span class="line">			&lt;p&gt;userName&lt;/p&gt;</span><br><span class="line">			&lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">			&lt;p&gt;nickName&lt;/p&gt;</span><br><span class="line">			&lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">			&lt;p&gt;email&lt;/p&gt;</span><br><span class="line">			&lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;</span><br><span class="line">			&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">		  &lt;/form&gt;</span><br><span class="line">		`;</span><br><span class="line">		ctx.body = html;</span><br><span class="line">	&#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123;</span><br><span class="line">		let postData = await parsePostData(ctx);</span><br><span class="line">		ctx.body = postData;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ctx.body = &apos;没找到&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

提交表单的数据
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	userName: &quot;67&quot;,</span><br><span class="line">	nickName: &quot;89&quot;,</span><br><span class="line">	email: &quot;0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="koa-bodyparser中间件"><a href="#koa-bodyparser中间件" class="headerlink" title="koa-bodyparser中间件"></a>koa-bodyparser中间件</h3><pre><code>对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中
关键代码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bodyParser = require(&apos;koa-bodyparser&apos;); // 引入该模块</span><br><span class="line">app.use(bodyParser()); // 使用ctx.body解析中间件</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">	if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123;</span><br><span class="line">		// 当GET请求时候返回表单页面</span><br><span class="line">		let html = `</span><br><span class="line">		  &lt;h1&gt;koa2 request post demo&lt;/h1&gt;</span><br><span class="line">		  &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;</span><br><span class="line">			&lt;p&gt;userName&lt;/p&gt;</span><br><span class="line">			&lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">			&lt;p&gt;nickName&lt;/p&gt;</span><br><span class="line">			&lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">			&lt;p&gt;email&lt;/p&gt;</span><br><span class="line">			&lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;</span><br><span class="line">			&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">		  &lt;/form&gt;</span><br><span class="line">		`</span><br><span class="line">		ctx.body = html</span><br><span class="line">	&#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123;</span><br><span class="line">		// 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来</span><br><span class="line">		let postData = ctx.request.body;</span><br><span class="line">		ctx.body = postData;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ctx.body = &apos;没找到404&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br>    <a href="https://www.npmjs.com/package/koa-bodyparser" target="_blank" rel="noopener">koa-bodyparser</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>koa学习-静态资源加载</title>
    <url>/2017/koa%E5%AD%A6%E4%B9%A0-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html</url>
    <content><![CDATA[<h3 id="原生koa2实现静态资源服务器"><a href="#原生koa2实现静态资源服务器" class="headerlink" title="原生koa2实现静态资源服务器"></a>原生koa2实现静态资源服务器</h3><pre><code>一个http请求访问web服务静态资源，一般响应结果有三种情况
</code></pre><ol>
<li>访问文本，例如html，js，css，png，jpg，gif</li>
<li>访问静态目录</li>
<li>找不到资源，抛出404错误<br>这里由于代码量过多，请查看源代码<br><a href>这里由于代码量过多，请查看源代码</a><h3 id="koa-static中间件使用"><a href="#koa-static中间件使用" class="headerlink" title="koa-static中间件使用"></a>koa-static中间件使用</h3>koa-static作为koaweb框架的静态服务器中间件<br>使用关键代码:<pre><code>// 导入koa-static模块
const static = require(&apos;koa-static&apos;);
// 设置静态资源的更目录
const staticPath = &apos;./static&apos;;
// 使用静态资源中间件
app.use(static(path.join(__dirname, staticPath)));
</code></pre><blockquote>
<p>   参考文档：<br><a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html" target="_blank" rel="noopener">koa-note</a><br><a href="https://www.npmjs.com/package/cookies" target="_blank" rel="noopener">cookies</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习（上部分）</title>
    <url>/2017/musql%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>基础构架：database –&gt; table –&gt; row 和 col（数据块）</p>
<h3 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h3><ol>
<li>数据库: 数据库是一些关联表的集合。.</li>
<li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>
<li>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>外键：外键用于关联两个表。</li>
<li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ol>
<h3 id="MySQL-创建数据库"><a href="#MySQL-创建数据库" class="headerlink" title="MySQL 创建数据库"></a>MySQL 创建数据库</h3><h4 id="使用-mysqladmin-创建数据库"><a href="#使用-mysqladmin-创建数据库" class="headerlink" title="使用 mysqladmin 创建数据库"></a>使用 mysqladmin 创建数据库</h4><pre><code>以下实例会创建一个 RUNOOB 数据库
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host]# mysqladmin -u root -p create RUNOOB</span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="SQL语句创建数据库-RUNOOB"><a href="#SQL语句创建数据库-RUNOOB" class="headerlink" title="SQL语句创建数据库 RUNOOB"></a>SQL语句创建数据库 RUNOOB</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;CREATE DATABASE RUNOOB&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-删除数据库"><a href="#MySQL-删除数据库" class="headerlink" title="MySQL 删除数据库"></a>MySQL 删除数据库</h3><h4 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host]# mysqladmin -u root -p drop RUNOOB</span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="SQL语句删除数据库-RUNOOB"><a href="#SQL语句删除数据库-RUNOOB" class="headerlink" title="SQL语句删除数据库 RUNOOB"></a>SQL语句删除数据库 RUNOOB</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;DROP DATABASE RUNOOB&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-选择数据库"><a href="#MySQL-选择数据库" class="headerlink" title="MySQL 选择数据库"></a>MySQL 选择数据库</h3><h4 id="从命令提示窗口中选择MySQL数据库"><a href="#从命令提示窗口中选择MySQL数据库" class="headerlink" title="从命令提示窗口中选择MySQL数据库"></a>从命令提示窗口中选择MySQL数据库</h4><pre><code>使用 RUNOOB 数据库
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host]# mysql -u root -p</span><br><span class="line">Enter password:******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="使用-NODE-js-选择数据库"><a href="#使用-NODE-js-选择数据库" class="headerlink" title="使用 NODE.js 选择数据库"></a>使用 NODE.js 选择数据库</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mysql = require(&apos;mysql&apos;);</span><br><span class="line">var connection = mysql.createConnetion(&#123;</span><br><span class="line">	host: &apos;localhost&apos;,</span><br><span class="line">	prot: 3306,</span><br><span class="line">	user: &apos;root&apos;,</span><br><span class="line">	password: &apos;****&apos;,</span><br><span class="line">	database: &apos;RUNOOB&apos;</span><br><span class="line">&#125;);</span><br><span class="line">connection.connect(); // 连接数据库</span><br><span class="line">connection.query(&apos;SQL命令&apos;, function (err, result) &#123; // 数据库相应的 CURD &#125;)	</span><br><span class="line">connection.end(); // 断开连接</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h3><pre><code>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。
</code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><img src="/images/mysql_int.png" alt="mysql_int"></p>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><pre><code>每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。
</code></pre><p><img src="/images/mysql_time.png" alt="mysql_time"></p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><pre><code>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。
</code></pre><p><img src="/images/mysql_string.png" alt="mysql_string"></p>
<h3 id="MySQL-创建数据表"><a href="#MySQL-创建数据表" class="headerlink" title="MySQL 创建数据表"></a>MySQL 创建数据表</h3><pre><code>创建数据表需要：表名、表字段名、定义每个表字段
</code></pre><h4 id="SQL命令"><a href="#SQL命令" class="headerlink" title="SQL命令"></a>SQL命令</h4><pre><code>语法：
    CREATE TABLE table_name (column_name column_type)
    CREATE TABLE IF NOT EXISTS table_name (column_name column_type) // 判断是否存在
实例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `runoob_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `runoob_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">1.如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL</span><br><span class="line">2.AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</span><br><span class="line">3.PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="在命令提示窗口中创建数据表"><a href="#在命令提示窗口中创建数据表" class="headerlink" title="在命令提示窗口中创建数据表"></a>在命令提示窗口中创建数据表</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@host# mysql -u root -p</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">mysql&gt; CREATE TABLE runoob_tbl(</span><br><span class="line">   -&gt; runoob_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   -&gt; runoob_title VARCHAR(100) NOT NULL,</span><br><span class="line">   -&gt; runoob_author VARCHAR(40) NOT NULL,</span><br><span class="line">   -&gt; submission_date DATE,</span><br><span class="line">   -&gt; PRIMARY KEY ( runoob_id )</span><br><span class="line">   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="node-js中创建表"><a href="#node-js中创建表" class="headerlink" title="node.js中创建表"></a>node.js中创建表</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&quot;CREATE TABLE person(id int,user varchar(255),password varchar(255))&quot;, function(err,result)&#123;</span><br><span class="line">	if(err)&#123;throw err&#125;</span><br><span class="line">	console.log(&quot;创建表成功&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-删除数据表"><a href="#MySQL-删除数据表" class="headerlink" title="MySQL 删除数据表"></a>MySQL 删除数据表</h3><pre><code>语法：
    DROP TABLE table_name
</code></pre><h4 id="在命令提示窗口中删除数据表"><a href="#在命令提示窗口中删除数据表" class="headerlink" title="在命令提示窗口中删除数据表"></a>在命令提示窗口中删除数据表</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@host# mysql -u root -p</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">mysql&gt; DROP TABLE runoob_tbl</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="node-js中删除表"><a href="#node-js中删除表" class="headerlink" title="node.js中删除表"></a>node.js中删除表</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;DROP TABLE runoob_tbl&apos;, function (err, result) &#123;</span><br><span class="line">	if (err) throw err;</span><br><span class="line">	console.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-插入数据"><a href="#MySQL-插入数据" class="headerlink" title="MySQL 插入数据"></a>MySQL 插入数据</h3><pre><code>语法：    
    INSERT INTO table_name (field1, field2, ...filedN) VALUES (value1, value2, value3);
</code></pre><h4 id="通过命令提示窗口插入数据"><a href="#通过命令提示窗口插入数据" class="headerlink" title="通过命令提示窗口插入数据"></a>通过命令提示窗口插入数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@host# mysql -u root -p password;</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">mysql&gt; INSERT INTO runoob_tbl </span><br><span class="line">	-&gt; (runoob_title, runoob_author, submission_date)</span><br><span class="line">	-&gt; VALUES</span><br><span class="line">	-&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());</span><br></pre></td></tr></table></figure>

读取某张表 -- select * from runoob_tbl;
</code></pre><h4 id="node-js插入数据"><a href="#node-js插入数据" class="headerlink" title="node.js插入数据"></a>node.js插入数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;INSERT INTO websites(id, name, url, alexa, country) VALUES (0, &quot;fanerge&quot;, &quot;23213&quot;, &quot;234&quot;, &quot;成都&quot;)&apos;, function (err, result) &#123;</span><br><span class="line">	console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line">// 占位符的形式</span><br><span class="line">connection.query(&apos;INSERT INTO websites(id, name, url, alexa, country) VALUES (0, ?, ?, ?)&apos;, [&quot;fanerge12&quot;, &quot;23213&quot;, &quot;234&quot;, &quot;成都&quot;], function (err, result) &#123;</span><br><span class="line">	console.log(&apos;DELETE affectedRows:&apos;, result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-查询数据"><a href="#MySQL-查询数据" class="headerlink" title="MySQL 查询数据"></a>MySQL 查询数据</h3><pre><code>语法：
    SELECT column_name, column_name 
    FROM table_name // 可以查询多张表以,分隔
    [WHERE clause] // 查询条件
    [OFFSET M][LIMIT N] // 偏移量 和 限制条数
</code></pre><h4 id="通过命令提示符获取数据"><a href="#通过命令提示符获取数据" class="headerlink" title="通过命令提示符获取数据"></a>通过命令提示符获取数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from runoob_tbl</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="node-js查询数据"><a href="#node-js查询数据" class="headerlink" title="node.js查询数据"></a>node.js查询数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;SELECT name, url FROM websites&apos;, function (err, result) &#123;</span><br><span class="line">	console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-WHERE-子句"><a href="#MySQL-WHERE-子句" class="headerlink" title="MySQL WHERE 子句"></a>MySQL WHERE 子句</h3><pre><code>可以用在：SELECT 和 DELETE 和 UPDATE 命令中。
默认where语句不区分大小写，使用BINARY开启区分大小写。
语法：
    SELECT field1, field2, ...filedN
    FROM table_name1, table_name2
    [WHERE confition1 [AND [OR]]] condition2
</code></pre><p><img src="/images/mysql_where.png" alt="mysql_where">    </p>
<h4 id="从命令提示符中读取数据"><a href="#从命令提示符中读取数据" class="headerlink" title="从命令提示符中读取数据"></a>从命令提示符中读取数据</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	SELECT name, url FROM user WHERE name=&quot;fanerge&quot; AND url=&quot;fanerge&quot;</span><br><span class="line">	```	</span><br><span class="line">####	node.js读取数据</span><br></pre></td></tr></table></figure>

connection.query(&apos;SELECT name, url FROM user WHERE name=&quot;fanerge&quot; AND url=&quot;fanerge&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###		MySQL UPDATE 查询	</span><br><span class="line">	语法：	</span><br><span class="line">		UPDATE table_name SET field1=new-value1, field1=new-value2</span><br><span class="line">		[WHERE clause]</span><br><span class="line">####	通过命令提示符更新数据</span><br></pre></td></tr></table></figure>

UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	node.js更新数据</span><br></pre></td></tr></table></figure>

connection.query(&apos;UPDATE user SET url=&quot;zhongguo&quot; WHERE name=&quot;1name&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">###		MySQL DELETE 语句	</span><br><span class="line">	语法：	</span><br><span class="line">		DELETE FROM table_name [WHERE clause]</span><br><span class="line">####	从命令行中删除数据</span><br></pre></td></tr></table></figure>

use RUNOOB;
mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	node.js删除数据</span><br></pre></td></tr></table></figure>

connection.query(&apos;DELETE FROM user WHERE name=&quot;1name&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">###	MySQL LIKE 子句</span><br><span class="line">	我们需要获取 runoob_author 字段含有 &quot;COM&quot; 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。	</span><br><span class="line">	如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。	</span><br><span class="line">	语法：</span><br><span class="line">		SELECT field1, field2, ...filedN</span><br><span class="line">		FROM table_name</span><br><span class="line">		WHERE field1 LIKE confition1 [AND [OR]] field2 = &apos;somevalue&apos;</span><br><span class="line">####	在命令提示符中使用 LIKE 子句</span><br><span class="line">	以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录：</span><br></pre></td></tr></table></figure>

use RUNOOB
SELECT * from runoob_tl WHERE runoob_author LIKE &apos;%COM&apos;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	node.js中使用 LIKE 子句</span><br></pre></td></tr></table></figure>

connection.query(&apos;SELECT * FROM websites WHERE BINARY name LIKE &quot;f%&quot;&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">###	MySQL UNION 操作符</span><br><span class="line">	MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。</span><br><span class="line">	多个 SELECT 语句会删除重复的数据。</span><br><span class="line">	UNION [ALL | DISTINCT]	// DISTINCT: 可选，删除结果集中重复的数据。ALL: 可选，返回所有结果集，包含重复数据。</span><br><span class="line">	语法：</span><br><span class="line">		SELECT column1, column2, ... columnN</span><br><span class="line">		FROM tables</span><br><span class="line">		[WHERE conditions]</span><br><span class="line">		UNION [ALL | DISTINCT]</span><br><span class="line">		SELECT column1, column2, ... columnN</span><br><span class="line">		FROM tables</span><br><span class="line">		[WHERE conditions];</span><br><span class="line">####	node.js 中使用 UNION</span><br></pre></td></tr></table></figure>

connection.query(&apos;SELECT country FROM websites UNION ALL SELECT country FROM apps ORDER BY country&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	带有 WHERE 的 SQL UNION ALL</span><br></pre></td></tr></table></figure>

connection.query(&apos;SELECT country, name FROM websites WHERE country LIKE &quot;C%&quot; UNION ALL SELECT country, app_name FROM apps WHERE country=&quot;CN&quot; ORDER BY country&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">###	MySQL 排序	</span><br><span class="line">	语法：</span><br><span class="line">		SELECT field1, field2, ...filedN table_name1, table_name2</span><br><span class="line">		ORDER BY field1, [field2] [ASC [DESC]] </span><br><span class="line">####	在命令提示符中使用 ORDER BY 子句</span><br></pre></td></tr></table></figure>

use RUNOOB;
mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date ASC;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	node.js 中 ORDER BY [ASC DESC]</span><br></pre></td></tr></table></figure>

connection.query(&apos;SELECT * FROM websites ORDER BY id DESC&apos;, function (err, result) {
    console.log(result);
});
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">###	MySQL GROUP BY 语句</span><br><span class="line">	语法：	</span><br><span class="line">		SELECT column_name, function(column_name)</span><br><span class="line">		FROM table_name</span><br><span class="line">		WHERE column_name operator value</span><br><span class="line">		GROUP BY column_name;</span><br><span class="line">####	我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录</span><br></pre></td></tr></table></figure>

SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	使用 WITH ROLLUP</span><br><span class="line">	WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</span><br><span class="line">	coalesce函数说明：name !== null ? name : &apos;总数&apos;。</span><br></pre></td></tr></table></figure>

SELECT coalesce(name, &quot;总数&quot;), SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###	Mysql 连接的使用</span><br><span class="line">	从多个数据表中读取数据。</span><br><span class="line">	你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</span><br><span class="line">	JOIN 按照功能大致分为如下三类：</span><br><span class="line">	1.	INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。(类似于交集)</span><br><span class="line">	2.	LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</span><br><span class="line">	3.	RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。	</span><br><span class="line">####	在命令提示符中使用 INNER JOIN(相当于交集)</span><br></pre></td></tr></table></figure>

SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	MySQL LEFT JOIN</span><br><span class="line">	MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</span><br></pre></td></tr></table></figure>

SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####	MySQL RIGHT JOIN</span><br><span class="line">	MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</span><br></pre></td></tr></table></figure>

SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###	MySQL NULL 值处理</span><br><span class="line">	IS NULL: 当列的值是 NULL,此运算符返回 true。</span><br><span class="line">	IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。</span><br><span class="line">	&lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</span><br><span class="line">####	在命令提示符中使用 NULL 值</span><br><span class="line">	SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;</span><br><span class="line">	SELECT * FROM runoob_test_tbl WHERE runoob_count IS NOT NULL;</span><br><span class="line"></span><br><span class="line">###	MySQL 正则表达式</span><br><span class="line">![mysql_regexp](/images/mysql_regexp1.png)</span><br></pre></td></tr></table></figure>

SELECT name FROM websites WHERE BINARY name REGEXP &apos;^F&apos;
SELECT name FROM person_tbl WHERE name REGEXP &apos;ok$&apos;;
```
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MYSQL</a></p>
</blockquote>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js 和 mysql 结合使用</title>
    <url>/2017/node-mysql.html</url>
    <content><![CDATA[<p>可视化工具：navicat for MySQL</p>
<h3 id="node和mysql的配合"><a href="#node和mysql的配合" class="headerlink" title="node和mysql的配合"></a>node和mysql的配合</h3><h4 id="mysql和node-js的连接"><a href="#mysql和node-js的连接" class="headerlink" title="mysql和node.js的连接"></a>mysql和node.js的连接</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mysql      = require(&apos;mysql&apos;);</span><br><span class="line">var connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : &apos;localhost&apos;, // 数据库的ip</span><br><span class="line">  port	   : 3306, // 数据库起服务的端口</span><br><span class="line">  user     : &apos;root&apos;, </span><br><span class="line">  password : &apos;123456&apos;,</span><br><span class="line">  database : &apos;test&apos; // 数据库名称</span><br><span class="line">&#125;);</span><br><span class="line">// 链接数据库 </span><br><span class="line">connection.connect();</span><br><span class="line">// 推荐使用下面的链接方式</span><br><span class="line">connection.connect(function(err) &#123;    </span><br><span class="line">	if (err) &#123;      </span><br><span class="line">		console.error(&apos;error connecting: &apos; + err.stack);      </span><br><span class="line">		return;    </span><br><span class="line">	&#125;    </span><br><span class="line">	console.log(&apos;connected as id &apos; + connection.threadId);  // 线程id</span><br><span class="line">&#125;);</span><br><span class="line">// 测试数据库是否连接成功 </span><br><span class="line">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(&apos;The solution is: &apos;, results[0].solution);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&quot;CREATE TABLE person(id int,user varchar(255),password varchar(255))&quot;, function(err,result)&#123;</span><br><span class="line">	if(err)&#123;throw err&#125;</span><br><span class="line">	console.log(&quot;创建表成功&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="连接池连接"><a href="#连接池连接" class="headerlink" title="连接池连接"></a>连接池连接</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pool  = mysql.createPool(&#123;    </span><br><span class="line">	connectionLimit : 10,    </span><br><span class="line">	host            : &apos;example.org&apos;,    </span><br><span class="line">	user            : &apos;bob&apos;,    </span><br><span class="line">	password        : &apos;secret&apos;,    </span><br><span class="line">	database        : &apos;my_db&apos;  </span><br><span class="line">&#125;);	</span><br><span class="line">// 测试数据库是否连接成功 </span><br><span class="line">pool.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(&apos;The solution is: &apos;, results[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line">// 使用连接池连接可以更容易地共享某个连接，也可以管理多个连接。</span><br><span class="line">pool.getConnection(function(err, connection) &#123; // 使用连接        </span><br><span class="line">	connection.query( &apos;SELECT something FROM sometable&apos;, function(err, rows) &#123; </span><br><span class="line">		// 使用连接执行查询       </span><br><span class="line">		connection.release(); //连接不再使用，返回到连接池</span><br><span class="line">		connection.destroy(); // 如果你想关闭连接并从连接池中删除它，在下次需要时连接池会再创建一个新的连接。			</span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="连接池的事件"><a href="#连接池的事件" class="headerlink" title="连接池的事件"></a>连接池的事件</h4><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool.on(&apos;connection&apos;, function (connection) &#123;    </span><br><span class="line">	connection.query(&apos;SET SESSION auto_increment_increment=1&apos;)  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool.on(&apos;enqueue&apos;, function () &#123;    </span><br><span class="line">	console.log(&apos;Waiting for available connection slot&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="在连接池中关闭所有连接"><a href="#在连接池中关闭所有连接" class="headerlink" title="在连接池中关闭所有连接"></a>在连接池中关闭所有连接</h5><pre><code>如不再需要连接池时，你必须关闭所有连接。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool.end(function (err) &#123;    </span><br><span class="line">	// all connections in the pool have ended  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="集群连接池"><a href="#集群连接池" class="headerlink" title="集群连接池"></a>集群连接池</h5><pre><code>集群连接池提供多主机连接.(分组&amp;重试&amp;选择器)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// create  </span><br><span class="line">var poolCluster = mysql.createPoolCluster();  </span><br><span class="line">// add configurations (the config is a pool config object)  </span><br><span class="line">poolCluster.add(config); </span><br><span class="line">// add configuration with automatic name  </span><br><span class="line">poolCluster.add(&apos;MASTER&apos;, masterConfig); </span><br><span class="line">// add a named configuration  </span><br><span class="line">poolCluster.add(&apos;SLAVE1&apos;, slave1Config);  </span><br><span class="line">poolCluster.add(&apos;SLAVE2&apos;, slave2Config);  </span><br><span class="line">// remove configurations  </span><br><span class="line">poolCluster.remove(&apos;SLAVE2&apos;); </span><br><span class="line">// By nodeId  poolCluster.remove(&apos;SLAVE*&apos;); </span><br><span class="line">// By target group : SLAVE1-2  </span><br><span class="line">// Target Group : ALL(anonymous, MASTER, SLAVE1-2), Selector : round-robin(default)  </span><br><span class="line">poolCluster.getConnection(function (err, connection) &#123;&#125;);  </span><br><span class="line">// Target Group : MASTER, Selector : round-robin  </span><br><span class="line">poolCluster.getConnection(&apos;MASTER&apos;, function (err, connection) &#123;&#125;);  </span><br><span class="line">// Target Group : SLAVE1-2, Selector : order  </span><br><span class="line">// If can&apos;t connect to SLAVE1, return SLAVE2. (remove SLAVE1 in the cluster)  </span><br><span class="line">poolCluster.on(&apos;remove&apos;, function (nodeId) &#123;    console.log(&apos;REMOVED NODE : &apos; + nodeId); </span><br><span class="line">// nodeId = SLAVE1   &#125;);  </span><br><span class="line">poolCluster.getConnection(&apos;SLAVE*&apos;, &apos;ORDER&apos;, function (err, connection) &#123;&#125;);  </span><br><span class="line">// of namespace : of(pattern, selector)  </span><br><span class="line">poolCluster.of(&apos;*&apos;).getConnection(function (err, connection) &#123;&#125;);  </span><br><span class="line">var pool = poolCluster.of(&apos;SLAVE*&apos;, &apos;RANDOM&apos;);  </span><br><span class="line">pool.getConnection(function (err, connection) &#123;&#125;);  </span><br><span class="line">pool.getConnection(function (err, connection) &#123;&#125;);  </span><br><span class="line">// close all connections  </span><br><span class="line">poolCluster.end(function (err) &#123;    // all connections in the pool cluster have ended  &#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="更换用户并且改变连接状态"><a href="#更换用户并且改变连接状态" class="headerlink" title="更换用户并且改变连接状态"></a>更换用户并且改变连接状态</h5><pre><code>该命令允许你在不关闭下列socket的情况下，改变当前用户和连接的其余部分.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.changeUser(&#123;user : &apos;john&apos;&#125;, function(err) &#123;    </span><br><span class="line">	if (err) throw err;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="数据库操作（CURD）"><a href="#数据库操作（CURD）" class="headerlink" title="数据库操作（CURD）"></a>数据库操作（CURD）</h3><pre><code>代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。
</code></pre><h4 id="查询数据（Retrieve）"><a href="#查询数据（Retrieve）" class="headerlink" title="查询数据（Retrieve）"></a>查询数据（Retrieve）</h4><h5 id="query-sqlString-callback"><a href="#query-sqlString-callback" class="headerlink" title="query(sqlString, callback)"></a>query(sqlString, callback)</h5><pre><code>第一个参数是一条SQL字符串，第二个参数是回调
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;SELECT * FROM `books` WHERE `author` = &quot;David&quot;&apos;, function (error, results, fields) &#123;    </span><br><span class="line">	if (error) &#123;</span><br><span class="line">		console.log(error.message);</span><br><span class="line">	&#125;</span><br><span class="line">	// 查询之后的操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="query-sqlString-values-callback"><a href="#query-sqlString-values-callback" class="headerlink" title="query(sqlString, values, callback)"></a>query(sqlString, values, callback)</h5><pre><code>带有值的占位符 (查看转义查询值)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;SELECT * FROM `books` WHERE `author` = ?&apos;, [&apos;David&apos;], function (error, results, fields) &#123;    </span><br><span class="line">	if (error) &#123;</span><br><span class="line">		console.log(error.message);</span><br><span class="line">	&#125;</span><br><span class="line">	// 查询之后的操作</span><br><span class="line">&#125;);</span><br><span class="line">connection.end(); // 断开数据库连接</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="query-options-callback"><a href="#query-options-callback" class="headerlink" title="query(options, callback)"></a>query(options, callback)</h5><pre><code>在查询时带有大量的高级可选项
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&#123;</span><br><span class="line">	sql: &apos;SELECT * FROM `books` WHERE `author` = ?&apos;,    </span><br><span class="line">	timeout: 40000,   </span><br><span class="line">	values: [&apos;David&apos;]  </span><br><span class="line">&#125;, function (error, results, fields) &#123;    </span><br><span class="line">	if (error) &#123;</span><br><span class="line">		console.log(error.message);</span><br><span class="line">	&#125;</span><br><span class="line">	// 查询之后的操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="查询值转义"><a href="#查询值转义" class="headerlink" title="查询值转义"></a>查询值转义</h5><pre><code>为了防止SQL注入，每当需要在SQL查询中使用用户数据时，你都应当提前对这些值进行转义。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一种，转义可以通过 mysql.escape(), connection.escape() 或 pool.escape() 方法实现。</span><br><span class="line">var userId = &apos;some user provided value&apos;;  </span><br><span class="line">var sql    = &apos;SELECT * FROM users WHERE id = &apos; + connection.escape(userId);  </span><br><span class="line">connection.query(sql, function(err, results) &#123;    </span><br><span class="line">	// ...  </span><br><span class="line">&#125;);</span><br><span class="line">// 第二种，使用 ? 作为查询字符串中的占位符，替代你想要转义的值。</span><br><span class="line">connection.query(&apos;SELECT * FROM users WHERE id = ?&apos;, [userId], function(err, results) &#123;    </span><br><span class="line">	// ...  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="查询标识符转义"><a href="#查询标识符转义" class="headerlink" title="查询标识符转义"></a>查询标识符转义</h5><pre><code>如果用户提供了不可信的查询标识符（数据库名、表名、列名），
你应该用 mysql.escapeId(identifier), connection.escapeId(identifier) 或 pool.escapeId(identifier) 方法对它进行转义。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sorter = &apos;date&apos;;  </span><br><span class="line">var sql    = &apos;SELECT * FROM posts ORDER BY &apos; + connection.escapeId(sorter);  </span><br><span class="line">connection.query(sql, function(err, results) &#123;    </span><br><span class="line">	// ...  </span><br><span class="line">&#125;);</span><br><span class="line">var userId = 1;  </span><br><span class="line">var columns = [&apos;username&apos;, &apos;email&apos;];  </span><br><span class="line">var query = connection.query(&apos;SELECT ?? FROM ?? WHERE id = ?&apos;, [columns, &apos;users&apos;, userId], function(err, results) &#123;    </span><br><span class="line">	// SELECT `username`, `email` FROM `users` WHERE id = 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="预查询"><a href="#预查询" class="headerlink" title="预查询"></a>预查询</h5><pre><code>你可以使用 mysql.format 来创建一个多插入点的查询语句，对id和值可以使用适当的转义处理 。
这样你就获得了一个有效并且安全的查询语句，然后可以把它发送给 数据库。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sql = &quot;SELECT * FROM ?? WHERE ?? = ?&quot;;  </span><br><span class="line">var inserts = [&apos;users&apos;, &apos;id&apos;, userId];  </span><br><span class="line">sql = mysql.format(sql, inserts);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="插入数据（Insert）"><a href="#插入数据（Insert）" class="headerlink" title="插入数据（Insert）"></a>插入数据（Insert）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var addSql = &apos;INSERT INTO websites(Id, name, url, alexa, country) VALUES(0, ?, ?, ?, ?)&apos;;</span><br><span class="line">var addSqlParams = [&apos;余真帆的博客&apos;, &apos;fanerge.githut.io&apos;, &apos;333325&apos;, &apos;CN&apos;];</span><br><span class="line">connection.query(addSql, addSqlParams, function (err, result) &#123;</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		console.log(&apos;[SELECT ERROR] - &apos;, err.message);</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&apos;-------INSERT--------&apos;);</span><br><span class="line">	console.log(&apos;INSERT ID:&apos;, result);</span><br><span class="line">	console.log(&apos;-------END--------&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="更新数据（Update）"><a href="#更新数据（Update）" class="headerlink" title="更新数据（Update）"></a>更新数据（Update）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var modSql = &apos;UPDATE websites SET name = ?, url = ?, alexa = ? WHERE Id = ?&apos;;</span><br><span class="line">var modSqlParams = [&apos;余真帆的网站&apos;, &apos;https://fanerge.github.io&apos;, 23, 6]</span><br><span class="line">connection.query(modSql, modSqlParams, function (err, result) &#123;</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		console.log(&apos;[UPDATE ERROR] - &apos;, err.message);</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&apos;-------UPDATE--------&apos;);</span><br><span class="line">	console.log(&apos;UPDATE affectedRows:&apos;, result.affectedRows);</span><br><span class="line">	console.log(&apos;-------END--------&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="删除数据（Delete）"><a href="#删除数据（Delete）" class="headerlink" title="删除数据（Delete）"></a>删除数据（Delete）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var delSql = &apos;DELETE FROM websites WHERE name = &quot;余真帆的博客&quot;&apos;;</span><br><span class="line">connection.query(delSql, function (err, result) &#123;</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		console.log(&apos;[DELETE ERROR] - &apos;, err.message);</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&apos;-------DELETE--------&apos;);</span><br><span class="line">	console.log(&apos;DELETE affectedRows:&apos;, result.affectedRows);</span><br><span class="line">	console.log(&apos;-------END--------&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="获取插入行的id"><a href="#获取插入行的id" class="headerlink" title="获取插入行的id"></a>获取插入行的id</h4><pre><code>如果你把一行插入到一个有自增主键的表中，可以这样获得插入的ID
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;INSERT INTO posts SET ?&apos;, &#123;title: &apos;test&apos;&#125;, function(err, result) &#123;    </span><br><span class="line">	if (err) throw err;    console.log(result.insertId);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="取得受影响的行数"><a href="#取得受影响的行数" class="headerlink" title="取得受影响的行数"></a>取得受影响的行数</h4><pre><code>你可以从 insert，update 或者 delete 子句中取得受影响的行数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;DELETE FROM posts WHERE title = &quot;wrong&quot;&apos;, function (err, result) &#123;    </span><br><span class="line">	if (err) throw err;    </span><br><span class="line">	console.log(&apos;deleted &apos; + result.affectedRows + &apos; rows&apos;);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="取得被改变的行数"><a href="#取得被改变的行数" class="headerlink" title="取得被改变的行数"></a>取得被改变的行数</h4><pre><code>你可以从 update 子句取得被改变的行数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;UPDATE posts SET ...&apos;, function (err, result) &#123;    </span><br><span class="line">	if (err) throw err;    </span><br><span class="line">	console.log(&apos;changed &apos; + result.changedRows + &apos; rows&apos;);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="获取连接ID"><a href="#获取连接ID" class="headerlink" title="获取连接ID"></a>获取连接ID</h4><pre><code>你可以取得MySQL的连接ID（“线程ID”），这是一个给定的连接，使用的是线程ID属性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.connect(function(err) &#123;    </span><br><span class="line">	if (err) throw err;    </span><br><span class="line">	console.log(&apos;connected as id &apos; + connection.threadId);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="并行执行查询"><a href="#并行执行查询" class="headerlink" title="并行执行查询"></a>并行执行查询</h4><pre><code>MySQL协议是顺序的，这意味着你需要多次连接执行并行查询。
你可以使用池来管理连接，一个简单的办法是每传入一个http请求，就创建一个连接。
</code></pre><h4 id="流式查询行"><a href="#流式查询行" class="headerlink" title="流式查询行"></a>流式查询行</h4><pre><code>有的时候可能需要查询大量的数据行，然后在接收到这些数据行的时候一行行的处理它们。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var query = connection.query(&apos;SELECT * FROM posts&apos;);  </span><br><span class="line">query.on(&apos;error&apos;, function(err) &#123;      </span><br><span class="line">	// 处理错误，这之后会触发 &apos;end&apos; 事件    </span><br><span class="line">&#125;)    </span><br><span class="line">.on(&apos;fields&apos;, function(fields) &#123;      </span><br><span class="line">	// 字段信息    </span><br><span class="line">&#125;)</span><br><span class="line">.on(&apos;result&apos;, function(row) &#123;      </span><br><span class="line">	// 暂停连接。如果你的处理过程涉及到 I/O 操作，这会很有用。      </span><br><span class="line">	connection.pause();     </span><br><span class="line">	processRow(row, function() &#123;        </span><br><span class="line">		connection.resume();      </span><br><span class="line">	&#125;);    </span><br><span class="line">&#125;)</span><br><span class="line">.on(&apos;end&apos;, function() &#123;      </span><br><span class="line">	// 所有数据行都已经接收完毕    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="通过-Streams2-管道输出"><a href="#通过-Streams2-管道输出" class="headerlink" title="通过 Streams2 管道输出"></a>通过 Streams2 管道输出</h4><pre><code>通过管道将查询结果输出到另一个流（最大缓冲 5 个对象）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&apos;SELECT * FROM posts&apos;)    </span><br><span class="line">.stream(&#123;highWaterMark: 5&#125;)    </span><br><span class="line">.pipe(...);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="多语句查询"><a href="#多语句查询" class="headerlink" title="多语句查询"></a>多语句查询</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 开启多语句查询</span><br><span class="line">var connection = mysql.createConnection(&#123;multipleStatements: true&#125;);</span><br><span class="line">connection.query(&apos;SELECT 1; SELECT 2&apos;, function(err, results) &#123;    </span><br><span class="line">	if (err) throw err;    </span><br><span class="line">	// `results` is an array with one element for every statement in the query:     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>先使用var connection = mysql.createConnection方法一个数据库连接的配置项</li>
<li>使用connection.connect方法连接数据库</li>
<li>使用sql语句对数据库进行CURD操作</li>
<li>操作完成后需使用connection.end方法断开数据库连接<br>connection.end(function (err) { … }); // 支持回调<br>connection.destroy(); // 该方法会立即终止底层套接字（underlying socket）。另外，destroy()不会触发更多的事件和回调函数。<blockquote>
<p>参考文档：<br><a href="http://www.runoob.com/nodejs/nodejs-mysql.html" target="_blank" rel="noopener">Node.js 连接 MySQL</a><br><a href="http://www.techug.com/post/node-mysql-node-js.html" target="_blank" rel="noopener">如何在node.js里连接和使用mysql</a><br><a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener">mysqljs</a><br><a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">mysql</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP模块</title>
    <url>/2017/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-HTTP.html</url>
    <content><![CDATA[<h3 id="要使用-HTTP-服务器与客户端，需要-require-‘http’-。"><a href="#要使用-HTTP-服务器与客户端，需要-require-‘http’-。" class="headerlink" title="要使用 HTTP 服务器与客户端，需要 require(‘http’)。"></a>要使用 HTTP 服务器与客户端，需要 require(‘http’)。</h3><pre><code>Node.js 中的 HTTP 接口被设计成支持协议的许多特性。 比如，大块编码的消息。 这些接口不缓冲完整的请求或响应，用户能够以流的形式处理数据。
</code></pre><h3 id="http-Agent-类"><a href="#http-Agent-类" class="headerlink" title="http.Agent 类"></a>http.Agent 类</h3><pre><code>Agent 负责为 HTTP 客户端管理连接的持续与复用。 它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket 连接直到队列为空，此时 socket 会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 keepAlive 选项。
</code></pre><ol>
<li>new Agent([options])<br>  作用：实例化一个代理 代理的配置选项。<br>  var agent = new Agent([options]);</li>
<li>agent.createConnection(options[, callback])<br>  作用：创建一个用于 HTTP 请求的 socket 或流。</li>
<li>agent.keepSocketAlive(socket)<br>  作用：在 socket 被请求分离的时候调用, 可能被代理持续使用。</li>
<li>agent.reuseSocket(socket, request)<br>  作用：由于 keep-alive 选项被保持持久化, 在 socket 附加到 request 时调用。</li>
<li>agent.destroy()<br>  作用：销毁当前正被代理使用的任何 socket。</li>
<li>agent.freeSockets<br>  作用：返回一个对象，包含当前正在等待被启用了 keepAlive 的代理使用的 socket 数组。 不要修改该属性。</li>
<li>agent.getName(options)<br>  作用：为请求选项的集合获取一个唯一的名称，用来判断一个连接是否可以被复用。</li>
<li>agent.maxFreeSockets<br>  作用：默认为 256。 对于已启用 keepAlive 的代理，该属性可设置要保留的空闲 socket 的最大数量。</li>
<li>agent.maxSockets<br>  作用：默认为不限制。 该属性可设置代理为每个来源打开的并发 socket 的最大数量。</li>
<li>agent.requests<br> 作用：返回一个对象，包含还未被分配到 socket 的请求队列。 不要修改。</li>
<li>agent.sockets<br> 作用：返回一个对象，包含当前正被代理使用的 socket 数组。 不要修改。<h3 id="http-ClientRequest-类"><a href="#http-ClientRequest-类" class="headerlink" title="http.ClientRequest 类"></a>http.ClientRequest 类</h3>该对象在 http.request() 内部被创建并返回。 它表示着一个正在处理的请求，其请求头已进入队列。 请求头仍可使用 setHeader(name, value)、getHeader(name) 和 removeHeader(name) API 进行修改。</li>
<li>abort事件<br>当请求已被客户端终止时触发。 该事件仅在首次调用 abort() 时触发。</li>
<li>aborted事件<br>当请求已被服务器终止且网络 socket 已关闭时触发。</li>
<li>connect事件<br>每当服务器响应 CONNECT 请求时触发。</li>
<li>continue事件<br>当服务器发送了一个 100 Continue 的 HTTP 响应时触发，通常是因为请求包含 Expect: 100-continue。 这是客户端将要发送请求主体的指令。</li>
<li>response事件<br>当请求的响应被接收到时触发。 该事件只触发一次。</li>
<li>socket事件<br>当 socket 被分配到请求后触发。</li>
<li>upgrade事件<br>每当服务器响应 upgrade 请求时触发。 </li>
<li>request.abort()<br>标记请求为终止。 调用该方法将使响应中剩余的数据被丢弃且 socket 被销毁。</li>
<li>request.aborted<br>如果请求已被终止，则该属性的值为请求被终止的时间，从 1 January 1970 00:00:00 UTC 到现在的毫秒数。</li>
<li>request.connection</li>
<li>request.end([data[, encoding]][, callback])<br>结束发送请求。</li>
<li>request.flushHeaders()<br>刷新请求头。</li>
<li>request.setNoDelay([noDelay])<br>一旦 socket 被分配给请求且已连接，socket.setNoDelay() 会被调用。</li>
<li>request.setSocketKeepAlive([enable][, initialDelay])<br>一旦 socket 被分配给请求且已连接，socket.setKeepAlive() 会被调用。</li>
<li>request.setTimeout(timeout[, callback])<br>一旦 socket 被分配给请求且已连接，socket.setTimeout() 会被调用。</li>
<li>request.socket<br>引用底层socket。</li>
<li>request.write(chunk[, encoding][, callback])<br>发送请求主体的一个数据块。<h3 id="http-Server-类"><a href="#http-Server-类" class="headerlink" title="http.Server 类"></a>http.Server 类</h3>该类继承自 net.Server，且具有以下额外的事件</li>
<li>checkContinue 事件<br>每当接收到一个带有 HTTP Expect: 100-continue 请求头的请求时触发。</li>
<li>checkExpectation 事件<br>每当接收到一个带有 HTTP Expect 请求头（值不为 100-continue）的请求时触发。 </li>
<li>clientError 事件<br>如果客户端触发了一个 ‘error’ 事件，则它会被传递到这里。</li>
<li>close事件<br>当服务器关闭时触发。</li>
<li>connect事件<br>每当客户端发送 HTTP CONNECT 请求时触发。</li>
<li>connection事件<br>当一个新的 TCP 流被建立时触发。 </li>
<li>request事件<br>每次接收到一个请求时触发。 </li>
<li>upgrade事件<br>每当客户端发送 HTTP upgrade 请求时触发。</li>
<li>server.close([callback])<br>停止服务端接收新的连接。</li>
<li>server.listen(handle[, callback])<br>handle 对象可以被设为一个服务器或 socket（任何带有一个 _handle 成员的对象）、或一个 {fd: <n>} 对象。</n></li>
<li>server.listen(path[, callback])<br>启动一个 UNIX socket 服务器，并在给定的 path 上监听连接。</li>
<li>server.listen([port][, hostname][, backlog][, callback])<br>开始在指定的 port 和 hostname 上接受连接。</li>
<li>server.listening<br>返回一个布尔值，表示服务器是否正在监听连接。</li>
<li>server.maxHeadersCount<br>限制请求头的最大数量，默认为 2000。 如果设为 0，则没有限制。</li>
<li>server.setTimeout([msecs][, callback])<br>设置 socket 的超时时间。</li>
<li>server.timeout<br>socket 被认定为超时的空闲毫秒数。</li>
<li>server.keepAliveTimeout<br>服务器完成最后的响应之后需要等待的额外的传入数据的活跃毫秒数, socket 才能被销毁。<h3 id="http-ServerResponse-类"><a href="#http-ServerResponse-类" class="headerlink" title="http.ServerResponse 类"></a>http.ServerResponse 类</h3>该对象在 HTTP 服务器内部被创建。 它作为第二个参数被传入 ‘request’ 事件。</li>
<li>close事件<br>当底层连接在 response.end() 被调用或能够刷新之前被终止时触发。</li>
<li>finish事件<br>当响应已被发送时触发。 </li>
<li>response.addTrailers(headers)<br>该方法会添加 HTTP 尾部响应头（一种在消息尾部的响应头）到响应。</li>
<li>response.connection</li>
<li>response.end([data][, encoding][, callback])<br>该方法会通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。 </li>
<li>response.finished<br>返回一个布尔值，表示响应是否已完成。</li>
<li>response.getHeader(name)<br>读取一个已入队列但尚未发送到客户端的响应头。</li>
<li>response.getHeaderNames()<br>返回一个包含当前响应唯一名称的 http 头信息名称数组. 名称均为小写。</li>
<li>response.getHeaders()<br>返回当前响应头文件的浅拷贝。</li>
<li>response.hasHeader(name)<br>如果响应头当前有设置 name 头部，返回 true。</li>
<li>response.headersSent<br>返回一个布尔值（只读）。 </li>
<li>response.removeHeader(name)<br>从隐式发送的队列中移除一个响应头。</li>
<li>response.sendDate<br>当为 true 时，如果响应头里没有日期响应头，则日期响应头会被自动生成并发送。</li>
<li>response.setHeader(name, value)<br>为一个隐式的响应头设置值。</li>
<li>response.setTimeout(msecs[, callback])<br>设置 socket 的超时时间为 msecs。</li>
<li>response.socket<br>引用底层socket。 </li>
<li>response.statusCode<br>当使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态码。</li>
<li>response.statusMessage<br>使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态信息。</li>
<li>response.write(chunk[, encoding][, callback])<br>如果该方法被调用且 response.writeHead() 没有被调用，则它会切换到隐式响应头模式并刷新隐式响应头。</li>
<li>response.writeContinue()<br>发送一个 HTTP/1.1 100 Continue 消息到客户端，表示请求主体可以开始发送。 参阅 Server 的 ‘checkContinue’ 事件。</li>
<li>response.writeHead(statusCode[, statusMessage][, headers])<br>发送一个响应头给请求。 <h3 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h3>IncomingMessage 对象由 http.Server 或 http.ClientRequest 创建，并作为第一个参数分别递给 ‘request’ 和 ‘response’ 事件。 它可以用来访问响应状态、消息头、以及数据。<blockquote>
<p>   参考文档：<br><a href="http://nodejs.cn/api/http.html" target="_blank" rel="noopener">HTTP参考-api</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>node-学习（七天学会NodeJs）</title>
    <url>/2017/node-%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h4 id="NodeJs基础"><a href="#NodeJs基础" class="headerlink" title="NodeJs基础"></a>NodeJs基础</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><pre><code>在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。
</code></pre><h6 id="require"><a href="#require" class="headerlink" title="require"></a>require</h6><pre><code>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo1 = require(&apos;./foo&apos;);</span><br><span class="line">var foo2 = require(&apos;./foo.js&apos;);</span><br><span class="line">var foo3 = require(&apos;/home/user/foo&apos;);</span><br><span class="line">var foo4 = require(&apos;/home/user/foo.js&apos;);</span><br><span class="line">// foo1至foo4中保存的是同一个模块的导出对象。</span><br></pre></td></tr></table></figure>

还可以加载使用JSON文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data = require(&apos;./data.json&apos;);</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h6><pre><code>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。
以下例子中导出了一个公有方法。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.hello = function () &#123;</span><br><span class="line">	console.log(&apos;fanerge&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="module"><a href="#module" class="headerlink" title="module"></a>module</h6><pre><code>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。
例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = function () &#123;</span><br><span class="line">	console.log(&apos;fanerge&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h4><h5 id="模块路径的解析规则（先后顺序）"><a href="#模块路径的解析规则（先后顺序）" class="headerlink" title="模块路径的解析规则（先后顺序）"></a>模块路径的解析规则（先后顺序）</h5><ol>
<li>内置模块<br>如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(‘fs’)。</li>
<li><p>node_modules目录（第三方包）<br>NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/user/node_modules/foo/bar</span><br><span class="line">/home/node_modules/foo/bar</span><br><span class="line">/node_modules/foo/bar</span><br></pre></td></tr></table></figure>
</li>
<li><p>NODE_PATH环境变量<br>与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_PATH=/home/user/lib:/home/lib</span><br></pre></td></tr></table></figure>
<p>当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/user/lib/foo/bar</span><br><span class="line">/home/lib/foo/bar</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h5><pre><code>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。
示例一个标准包：
-cat:
    doc -- 包说明文档
    -lib -- 包具体代码
        head.js
        body.js
        index.js -- 入口文件
    tests -- 测试用例
    package.json -- 包的说明及依赖关系
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js具体代码</span><br><span class="line">var head = require(&apos;./head&apos;);</span><br><span class="line">var body = require(&apos;./body&apos;);</span><br><span class="line">exports.create = function (name) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		name: name,</span><br><span class="line">		head: head.create(),</span><br><span class="line">		body: body.create()</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">// package.json具体代码</span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;cat&quot;,</span><br><span class="line">	&quot;main&quot;: &quot;./lib/index.js&quot; // 入口模块位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h5><pre><code>一个标准的工程目录
/home/user/workspace/node-echo/ # 工程目录
    -bin/                       # 存放命令行相关代码
        node-echo
    +doc/                       # 存放文档
    -lib/                       # 存放API相关代码
        echo.js
    -node_modules/              # 存放第三方包
        babel
    +tests/                     # 存放测试用例
    package.json                # 元数据文件
    README.md                    # 说明文件
</code></pre><h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><pre><code>安装第三方包
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install argv</span><br></pre></td></tr></table></figure>

安装第三方包（特定版本）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install argv@0.0.1</span><br></pre></td></tr></table></figure>

批量安装
还可以在package.json中dependencies字段中写入所有依赖包
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">       &quot;argv&quot;: &quot;0.0.2&quot;,</span><br><span class="line">	...</span><br><span class="line">   &#125;</span><br><span class="line">// 在使用指令批量安装</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

更新包
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update &lt;package&gt;</span><br></pre></td></tr></table></figure>

清除NPM本地缓存
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm cache clear（用于对付使用相同版本号发布新版本代码的人）</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="文件拷贝练手"><a href="#文件拷贝练手" class="headerlink" title="文件拷贝练手"></a>文件拷贝练手</h5><pre><code>// copy.js
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">function copy(src, dst) &#123;</span><br><span class="line">	fs.writeFileSync(dst, fs.readFileSync(src));</span><br><span class="line">&#125;</span><br><span class="line">function main(argv) &#123;</span><br><span class="line">	copy(argv[0], argv[1]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(0, 2));</span><br><span class="line">// 进行拷贝</span><br><span class="line">node copy.js</span><br></pre></td></tr></table></figure>

以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。
process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径
</code></pre><h5 id="文件操作有关的API"><a href="#文件操作有关的API" class="headerlink" title="文件操作有关的API"></a>文件操作有关的API</h5><h6 id="Buffer（数据块）"><a href="#Buffer（数据块）" class="headerlink" title="Buffer（数据块）"></a>Buffer（数据块）</h6><pre><code>NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 构造一个Buffer实例</span><br><span class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</span><br><span class="line">// Buffer实例具有length属性和bin[index]</span><br><span class="line">bin[0]; // =&gt; 0x68;</span><br><span class="line">// Buffer实例转化指定编码的字符串</span><br><span class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</span><br><span class="line">// 将字符串转化为指定编码的二进制数据</span><br><span class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span><br><span class="line">// Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。</span><br><span class="line">// 至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。</span><br></pre></td></tr></table></figure>

Buffer拷贝的例子
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。</span><br><span class="line">// 这个类似于申请一块新的内存，并把已有内存中的数据复制过去。</span><br><span class="line">var bin = new Buffer([0x68, 0x65, 0x6c, 0x6c, 0x6f]);</span><br><span class="line">var dup = new Buffer(bin.length);</span><br><span class="line">bin.copy(dup);</span><br><span class="line">dup[0] =0x46;</span><br><span class="line">console.log(bin, dup);</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="Stream（数据流）"><a href="#Stream（数据流）" class="headerlink" title="Stream（数据流）"></a>Stream（数据流）</h6><pre><code>Stream的使用场景：
</code></pre><ol>
<li>当内存中无法一次装下需要处理的数据时。</li>
<li>一边读取一边处理更加高效时，我们就需要用到数据流。<br>实例–将a.js拷贝到b.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var rs = fs.createReadStream(process.argv[1].slice(0, -7) + &apos;a.js&apos;);</span><br><span class="line">var ws = fs.createWriteStream(process.argv[1].slice(0, -7) + &apos;b.js&apos;);</span><br><span class="line"></span><br><span class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">	// 传入的数据是否写入目标</span><br><span class="line">	if (ws.write(chunk) === false) &#123;</span><br><span class="line">			rs.pause();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(&apos;end&apos;, function () &#123;</span><br><span class="line">	ws.end();</span><br><span class="line">&#125;);</span><br><span class="line">// 判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了</span><br><span class="line">ws.on(&apos;drain&apos;, function () &#123;</span><br><span class="line">	rs.resume();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="File-System（文件系统）"><a href="#File-System（文件系统）" class="headerlink" title="File System（文件系统）"></a>File System（文件系统）</h6><pre><code>NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：
</code></pre><ol>
<li>文件属性读写。<br>其中常用的有fs.stat、fs.chmod、fs.chown等等。</li>
<li>文件内容读写。<br>其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。</li>
<li><p>底层文件操作。<br>其中常用的有fs.open、fs.read、fs.write、fs.close等等<br>同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。<br>// 异步处理文件及异常处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">fs.readFile(process.argv[1].slice(0, -7) + &apos;a.js&apos;, function (error, data) &#123;</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		console.error(error);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>// 同步处理文件及异常处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">try&#123;</span><br><span class="line">	var data = fs.readFileSync(process.argv[1].slice(0, -7) + &apos;a.js&apos;);</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;catch(err)&#123;</span><br><span class="line">	console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="Path（路径）"><a href="#Path（路径）" class="headerlink" title="Path（路径）"></a>Path（路径）</h6><pre><code>NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。
path.normalize(str)
    将传入的路径转换为标准路径，除了解析路径中的.与..外，还能去掉多余的斜杠。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var cache = &#123;&#125;;</span><br><span class="line">function store (key, value) &#123;</span><br><span class="line">	cache[path.normalize(key)] = value;</span><br><span class="line">	console.dir(cache);</span><br><span class="line">&#125;</span><br><span class="line">store(&apos;/home&apos;, 1);</span><br><span class="line">store(&apos;/home/user&apos;, 44);</span><br><span class="line">// 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &apos;/&apos;)再替换一下标准路径。</span><br></pre></td></tr></table></figure>

path.join()
将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</span><br></pre></td></tr></table></figure>

path.extname()
当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h5><pre><code>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。
</code></pre><h6 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h6><pre><code>计算N的阶乘
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function factorial (n) &#123;</span><br><span class="line">	if (n === 1) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return n * factorial(n-1);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h6><pre><code>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。
同步遍历
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function travel (dir, callback) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		fs.readdirSync(dir).forEach(function (file) &#123;</span><br><span class="line">			var pathname = path.join(dir, file);</span><br><span class="line">			if (fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">				travel(pathname, callback);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				callback(pathname);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;catch(e)&#123;</span><br><span class="line">		console.error(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

异步遍历（有点复杂）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function travel(dir, callback, finish) &#123;</span><br><span class="line">	fs.readdir(dir, function (err, files) &#123;</span><br><span class="line">		(function next(i) &#123;</span><br><span class="line">			if (i &lt; files.length) &#123;</span><br><span class="line">				var pathname = path.join(dir, files[i]);</span><br><span class="line"></span><br><span class="line">				fs.stat(pathname, function (err, stats) &#123;</span><br><span class="line">					if (stats.isDirectory()) &#123;</span><br><span class="line">						travel(pathname, callback, function () &#123;</span><br><span class="line">							next(i + 1);</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						callback(pathname, function () &#123;</span><br><span class="line">							next(i + 1);</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				finish &amp;&amp; finish();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(0));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h5><p>我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。</p>
<h6 id="BOM的移除"><a href="#BOM的移除" class="headerlink" title="BOM的移除"></a>BOM的移除</h6><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function readText (pathname) &#123;</span><br><span class="line">	var bin = fs.readFileAync(pathname);</span><br><span class="line">	if (bin[0] === 0xFF &amp;&amp; bin[1] === oxBB &amp;&amp; bin[2] === 0xBF) &#123;</span><br><span class="line">		bin = bin.slice(3);</span><br><span class="line">	&#125;</span><br><span class="line">	return bin.toString(&apos;utf-8&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="GBK转UTF8"><a href="#GBK转UTF8" class="headerlink" title="GBK转UTF8"></a>GBK转UTF8</h6><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第三方包转换编码</span><br><span class="line">var iconv = require(&apos;iconv-lite&apos;); </span><br><span class="line">function readGBKText(pathname) &#123;</span><br><span class="line">	var bin = fs.readFileSync(pathname);</span><br><span class="line">	return iconv.decode(bin, &apos;gbk&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h6><pre><code>不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function replace(pathname) &#123;</span><br><span class="line">	var str = fs.readFileSync(pathname, &apos;binary&apos;);</span><br><span class="line">	str = str.replace(&apos;foo&apos;, &apos;bar&apos;);</span><br><span class="line">	fs.writeFileSync(pathname, str, &apos;binary&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h4><h5 id="例子开启一个服务"><a href="#例子开启一个服务" class="headerlink" title="例子开启一个服务"></a>例子开启一个服务</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">	response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text-plain&apos;&#125;);</span><br><span class="line">	response.end(&apos;Hello world\n&apos;);</span><br><span class="line">&#125;).listen(8734);</span><br><span class="line">// 以上程序创建了一个HTTP服务器并监听8734端口，打开浏览器访问该端口http://127.0.0.1:8124/就能够看到效果。</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="网络相关的API"><a href="#网络相关的API" class="headerlink" title="网络相关的API"></a>网络相关的API</h5><h6 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h6><pre><code>&apos;http&apos;模块提供两种使用方式：
</code></pre><ol>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。<br>在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。<br>除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">	var body = [];</span><br><span class="line">	console.log(request.method);</span><br><span class="line">	console.log(request.headers);</span><br><span class="line">	request.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">		body.push(chunk);</span><br><span class="line">	&#125;);</span><br><span class="line">	request.on(&apos;end&apos;, function () &#123;</span><br><span class="line">		body = Buffer.concat(body);</span><br><span class="line">		console.log(body.toString());</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;).listen(8734);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h6><pre><code>https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。
创建一个HTTPS服务器
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">       key: fs.readFileSync(&apos;./ssl/default.key&apos;),</span><br><span class="line">       cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</span><br><span class="line">   &#125;;</span><br><span class="line">var server = https.createServer(options, function (request, response) &#123;</span><br><span class="line">		// ...</span><br><span class="line">&#125;);</span><br><span class="line">// 与创建HTTP服务器相比，多了一个options对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。</span><br></pre></td></tr></table></figure>

另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.addContext(&apos;foo.com&apos;, &#123;</span><br><span class="line">	key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;),</span><br><span class="line">	cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h6><pre><code>处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。
</code></pre><ol>
<li><p>url.parse()<br>将一个URL字符串转换为URL对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var url = require(&apos;url&apos;, [boolean], [boolean]);</span><br><span class="line">console.log(url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;));</span><br><span class="line">第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。</span><br><span class="line">第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如//www.example.com/foo/bar。</span><br></pre></td></tr></table></figure>
</li>
<li><p>url.format()<br>允许将一个URL对象转换为URL字符串</p>
</li>
<li>url.resolve()<br>可以用于拼接URL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dd = url.resolve(&apos;http://www.baidu.com/yzf/age/sex&apos;, &apos;../va&apos;);</span><br><span class="line">// http://www.baidu.com/yzf/va</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="Query-String"><a href="#Query-String" class="headerlink" title="Query String"></a>Query String</h6><pre><code>querystring模块用于实现URL参数字符串与参数对象的互相转换.
querystring.parse()
    将字符串参数转化为对象URL参数
querystring.stringify()
    将参数对象转化为URL参数字符串
</code></pre><h6 id="Zlib"><a href="#Zlib" class="headerlink" title="Zlib"></a>Zlib</h6><pre><code>zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。
例子：使用zlib模块压缩HTTP响应体数据。
这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据。
zlib.gzip()
    数据压缩
zlib.gunzip()
    数据解压
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">	let i = 1024,</span><br><span class="line">		data = &apos;&apos;;</span><br><span class="line">	while (i--) &#123;</span><br><span class="line">		data += &apos;x&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	if (request.headers[&apos;accept-encoding&apos;].includes(&apos;gzip&apos;)) &#123;</span><br><span class="line">		zlib.gzip(data, function (err, data) &#123;</span><br><span class="line">			response.writeHead(200, &#123;</span><br><span class="line">				&apos;Content-Type&apos;: &apos;text/plain&apos;,</span><br><span class="line">				&apos;Content-Encoding&apos;: &apos;gzip&apos;</span><br><span class="line">			&#125;);</span><br><span class="line">			response.end(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		response.writeHead(200, &#123;</span><br><span class="line">			&apos;Content-Type&apos;: &apos;text/plain&apos;</span><br><span class="line">		&#125;);</span><br><span class="line">		response.end(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h6><pre><code>net模块可用于创建Socket服务器或Socket客户端。
使用Socket搭建一个HTTP服务器的例子。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.createServer(function (conn) &#123;</span><br><span class="line">	conn.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">		conn.write([</span><br><span class="line">			&apos;HTTP/1.1 200 OK&apos;,</span><br><span class="line">			&apos;Content-Type: text/plain&apos;,</span><br><span class="line">			&apos;Content-Length: 12&apos;,</span><br><span class="line">			&apos;&apos;,</span><br><span class="line">			&apos;Hello World&apos;</span><br><span class="line">		].join(&apos;\n&apos;));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><pre><code>NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。
node.js调用终端简化目录拷贝
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var child_process = require(&apos;child_process&apos;);</span><br><span class="line">var util = require(&apos;util&apos;);</span><br><span class="line">function copy(source, target, callback) &#123;</span><br><span class="line">	child_process.exec(</span><br><span class="line">		util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</span><br><span class="line">&#125;</span><br><span class="line">copy(process.argv[1].slice(0, -7) + &apos;copy1&apos;, process.argv[1].slice(0, -7) + &apos;copy2&apos;, function (err, data) &#123;</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		console.log(err)</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h5><pre><code>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。
另外需要注意的是，process不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。
</code></pre><h5 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h5><pre><code>使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。
</code></pre><h5 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h5><pre><code>cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。
</code></pre><p>应用场景</p>
<ol>
<li>如何获取命令行参数<br>  在NodeJS中可以通过process.argv获取命令行参数。<br>  但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。<br>  一般这样获取：process.argv.slice(2)</li>
<li><p>如何退出程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">	// ...</span><br><span class="line">	process.exit(1); // 返回特定的状态码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何控制输入输出<br>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr，<br>第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。</p>
</li>
<li><p>如何降权<br>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.createServer(callback).listen(80, function () &#123;</span><br><span class="line">	var env = process.env,</span><br><span class="line">		uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</span><br><span class="line">		gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</span><br><span class="line">	process.setgid(gid);</span><br><span class="line">	process.setuid(uid);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何创建子进程<br>创建NodeJS子进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;a.js&apos; ]);</span><br><span class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">	console.log(&apos;stdout: &apos; + data);</span><br><span class="line">&#125;);</span><br><span class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">	console.log(&apos;stderr: &apos; + data);</span><br><span class="line">&#125;);</span><br><span class="line">child.on(&apos;close&apos;, function (code) &#123;</span><br><span class="line">	console.log(&apos;child process exited with code &apos; + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>进程间如何通讯    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* parent.js */</span><br><span class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</span><br><span class="line"></span><br><span class="line">child.kill(&apos;SIGTERM&apos;);</span><br><span class="line"></span><br><span class="line">/* child.js */</span><br><span class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</span><br><span class="line">	cleanUp();</span><br><span class="line">	process.exit(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>进程间如何通讯<br>如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* parent.js */</span><br><span class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</span><br><span class="line">		stdio: [ 0, 1, 2, &apos;ipc&apos; ]</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">child.on(&apos;message&apos;, function (msg) &#123;</span><br><span class="line">	console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</span><br><span class="line"></span><br><span class="line">/* child.js */</span><br><span class="line">process.on(&apos;message&apos;, function (msg) &#123;</span><br><span class="line">	msg.hello = msg.hello.toUpperCase();</span><br><span class="line">	process.send(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何守护子进程<br>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function spawn(mainModule) &#123;</span><br><span class="line">	var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</span><br><span class="line">	worker.on(&apos;exit&apos;, function (code) &#123;</span><br><span class="line">		if (code !== 0) &#123;</span><br><span class="line">			spawn(mainModule);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">spawn(&apos;worker.js&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><pre><code>NodeJS最大的卖点——事件机制和异步IO。
</code></pre><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><pre><code>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">	console.log(&apos;我是setTimeout&apos;)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(&apos;hello&apos;);</span><br></pre></td></tr></table></figure>

理解js中如何实现异步
    JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的
    事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。
    我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。
    也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。
</code></pre><h5 id="代码设计模式"><a href="#代码设计模式" class="headerlink" title="代码设计模式"></a>代码设计模式</h5><h6 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h6><pre><code>使用一个函数的输出作为另一个函数的输入是很常见的需求。
同步方式编写代码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var output = fn1(fn2(&apos;input&apos;));</span><br></pre></td></tr></table></figure>

异步方式编写代码：
由于函数执行结果不是通过返回值，而是通过回调函数传递。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn2(&apos;input&apos;, function (output2) &#123;</span><br><span class="line">	fn1(output2, function (output1) &#123;</span><br><span class="line">		// do something</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h6><pre><code>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。
同步方式编写代码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var len = arr.length;</span><br><span class="line">for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">	arr[i] = sync(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 所有的数组项处理完，打算做的事</span><br></pre></td></tr></table></figure>

异步方式编写代码(异步串行遍历)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((function next (i, len, callback) &#123;</span><br><span class="line">	if (i &lt; len) &#123;</span><br><span class="line">		async(arr[i], function (value) &#123;</span><br><span class="line">			arr[i] = value;</span><br><span class="line">			next(i + 1, len, callback);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		callback();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)(0, arr.length, function () &#123;</span><br><span class="line">	// 所有的数组项处理完，打算做的事</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

异步方式编写代码(异步并行遍历)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((function (i, len, count, callback) &#123;</span><br><span class="line">	for (; i &lt; len; i++) &#123;</span><br><span class="line">		(function (i) &#123;</span><br><span class="line">			async(arr[i], function (value) &#123;</span><br><span class="line">				arr[i] = value;</span><br><span class="line">				if (++count === len) &#123;</span><br><span class="line">					callback();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)(0, arr.length, 0, function () &#123;</span><br><span class="line">	// 所有的数组项处理完，打算做的事</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h6><pre><code>JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。
同步异常处理：
因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sync(fn) &#123;</span><br><span class="line">	return fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">	sync(null);</span><br><span class="line">	// Do something.</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">	console.log(&apos;Error: %s&apos;, err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

异步异常处理：
但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。
因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。
</code></pre><h5 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h5><pre><code>NodeJS提供了domain模块，可以简化异步代码的异常处理。
一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">	console.log(&apos;Error: %s&apos;, err.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function (fn) &#123;</span><br><span class="line">	fn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

使用domain模块创建一个子域（JS子运行环境）。
在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的error事件统一捕获。
我们使用.create方法创建了一个子域对象，并通过.run方法进入需要在子域中运行的代码的入口点。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function async(request, callback) &#123;</span><br><span class="line">	// Do something.</span><br><span class="line">	asyncA(request, function (data) &#123;</span><br><span class="line">		// Do something</span><br><span class="line">		asyncB(request, function (data) &#123;</span><br><span class="line">			// Do something</span><br><span class="line">			asyncC(request, function (data) &#123;</span><br><span class="line">				// Do something</span><br><span class="line">				callback(data);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line">	var d = domain.create(); // 创建子域</span><br><span class="line"></span><br><span class="line">	d.on(&apos;error&apos;, function () &#123;</span><br><span class="line">		response.writeHead(500);</span><br><span class="line">		response.end();</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	d.run(function () &#123; // 子域运行入口</span><br><span class="line">		async(request, function (data) &#123;</span><br><span class="line">			response.writeHead(200);</span><br><span class="line">			response.end(data);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><pre><code>无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。    
</code></pre><p>参考书籍：<br>    <a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">七天学会NodeJs</a><br>    <a href="http://nodejs.cn/api/" target="_blank" rel="noopener">node中文</a><br>代码仓库：<a href="https://github.com/fanerge/7day-NodeJs.git" target="_blank" rel="noopener">node学习源代码</a></p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>url模块-网址</title>
    <url>/2017/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-url.html</url>
    <content><![CDATA[<h3 id="url-模块提供了一些实用函数，用于-URL-处理与解析。"><a href="#url-模块提供了一些实用函数，用于-URL-处理与解析。" class="headerlink" title="url 模块提供了一些实用函数，用于 URL 处理与解析。"></a>url 模块提供了一些实用函数，用于 URL 处理与解析。</h3><h3 id="URL-字符串与-URL-对象"><a href="#URL-字符串与-URL-对象" class="headerlink" title="URL 字符串与 URL 对象"></a>URL 字符串与 URL 对象</h3><pre><code>一个 URL 字符串是一个结构化的字符串，它包含多个有意义的组成部分。 当被解析时，会返回一个 URL 对象，它包含每个组成部分作为属性。
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
&quot;  https:   //    user   :   pass   @ sub.host.com : 8080   /p/a/t/h  ?  query=string   #hash &quot;
│          │  │          │          │   hostname   │ port │          │                │       │
│          │  │          │          ├──────── ──────┴──────┤          │                │       │
│ protocol │  │ username │ password │        host         │          │                │       │
├──────────┴──┼──────────┴──────────┼─────────────────────┤          │                │       │
│   origin    │                     │       origin        │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴─────────────────────┴──────────┴────────────────┴───────┤
│                                            href                                             │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre><h3 id="Constructor-new-URL-input-base"><a href="#Constructor-new-URL-input-base" class="headerlink" title="Constructor: new URL(input[, base])"></a>Constructor: new URL(input[, base])</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; URL &#125; = require(&apos;url&apos;);</span><br><span class="line">const myURL = new URL(&apos;/foo&apos;, &apos;https://example.org/&apos;);</span><br><span class="line">// https://example.org/foo</span><br></pre></td></tr></table></figure>
</code></pre><p>一下实例均以：var myURL = new URL(‘<a href="https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39;)" target="_blank" rel="noopener">https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39;)</a>;</p>
<h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url.hash"></a>url.hash</h3><pre><code>作用：获取及设置URL的分段(hash)部分。
    myURL.hash; // #hash
</code></pre><h3 id="url-host"><a href="#url-host" class="headerlink" title="url.host"></a>url.host</h3><pre><code>作用：获取及设置URL的主机(host)部分。
    myURL.host; // user:pass@sub.host.com:8080
</code></pre><h3 id="url-hostname"><a href="#url-hostname" class="headerlink" title="url.hostname"></a>url.hostname</h3><pre><code>作用：获取及设置URL的主机名(hostname)部分。 url.host和url.hostname之间的区别是url.hostname不 包含端口。
    myURL.hostname; // user:pass@sub.host.com
</code></pre><h3 id="url-href"><a href="#url-href" class="headerlink" title="url.href"></a>url.href</h3><pre><code>作用：获取及设置序列化的URL。
    myURL.href; // https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash
</code></pre><h3 id="url-origin"><a href="#url-origin" class="headerlink" title="url.origin"></a>url.origin</h3><pre><code>作用：获取只读序列化的URL orgin部分。
    myURL.origin; // https://user:pass@sub.host.com:8080
</code></pre><h3 id="url-password"><a href="#url-password" class="headerlink" title="url.password"></a>url.password</h3><pre><code>作用：获取及设置URL的密码(password)部分。
    myURL.password; // pass
</code></pre><h3 id="url-pathname"><a href="#url-pathname" class="headerlink" title="url.pathname"></a>url.pathname</h3><pre><code>作用：获取及设置URL的路径(path)部分。
    myURL.pathname; // /p/a/t/h
</code></pre><h3 id="url-port"><a href="#url-port" class="headerlink" title="url.port"></a>url.port</h3><pre><code>作用：获取及设置URL的端口(port)部分。
    myURL.port; 8080
</code></pre><h3 id="url-protocol"><a href="#url-protocol" class="headerlink" title="url.protocol"></a>url.protocol</h3><pre><code>作用：获取及设置URL的协议(protocol)部分。
    myURL.protocol; // https
</code></pre><h3 id="url-search"><a href="#url-search" class="headerlink" title="url.search"></a>url.search</h3><pre><code>作用：获取及设置URL的序列化查询(query)部分部分。
    myURL.search; // ?query=string
</code></pre><h3 id="url-searchParams"><a href="#url-searchParams" class="headerlink" title="url.searchParams"></a>url.searchParams</h3><pre><code>作用：获取表示URL查询参数的URLSearchParams对象。该属性是只读的；
    myURL.searchParams; // 
</code></pre><h3 id="url-username"><a href="#url-username" class="headerlink" title="url.username"></a>url.username</h3><pre><code>作用：获取及设置URL的用户名(username)部分。
    myURL.username; // user
</code></pre><h3 id="url-toString"><a href="#url-toString" class="headerlink" title="url.toString()"></a>url.toString()</h3><pre><code>作用：在URL对象上调用toString()方法将返回序列化的URL。返回值与url.href和url.toJSON()的相同。
    如果需要更大灵活性，require(&apos;url&apos;).format()可能更合适。
</code></pre><h3 id="url-toJSON"><a href="#url-toJSON" class="headerlink" title="url.toJSON()"></a>url.toJSON()</h3><pre><code>在URL对象上调用toJSON()方法将返回序列化的URL。
</code></pre><h3 id="Constructor-new-URLSearchParams-obj"><a href="#Constructor-new-URLSearchParams-obj" class="headerlink" title="Constructor: new URLSearchParams(obj)"></a>Constructor: new URLSearchParams(obj)</h3><pre><code>通过使用查询哈希映射实例化一个新的URLSearchParams对象，obj的每一个属性的键和值将被强制转换为字符串。
urlSearchParams.append(name, value)
    在查询字符串中附加一个新的键值对。
urlSearchParams.entries()
    返回: &lt;Iterator&gt; 在查询中的每个键值对上返回一个ES6迭代器。
urlSearchParams.forEach(fn[, thisArg])
    在查询字符串中迭代每个键值对，并调用给定的函数。
urlSearchParams.get(name)
    返回键是name的第一个键值对的值。如果没有对应的键值对，则返回null。
urlSearchParams.getAll(name)
    返回键是name的所有键值对的值，如果没有满足条件的键值对，则返回一个空的数组。
urlSearchParams.has(name)
    如果存在至少一对键是name的键值对则返回 true。
urlSearchParams.keys()
    在每一个键值对上返回一个键的ES6迭代器。
urlSearchParams.set(name, value)
    将URLSearchParams对象中与name相对应的值设置为value。
urlSearchParams.sort()    
    按现有名称就地排列所有的名称-值对。    
urlSearchParams.toString()    
    返回查询参数序列化后的字符串，必要时存在百分号编码字符。
urlSearchParams.values()
    在每一个键值对上返回一个值的ES6迭代器。
urlSearchParams[@@iterator]()    
    返回在查询字符串中每一个键值对的ES6迭代器。
url.domainToASCII(domain)    
    返回Punycode ASCII序列化的domain. 如果domain是无效域名，将返回空字符串。
url.domainToUnicode(domain)    
    返回Unicode序列化的domain. 如果domain是无效域名，将返回空字符串。
url.format(URL[, options])    
    返回一个WHATWG URL对象的可自定义序列化的URL字符串表达。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/url.html" target="_blank" rel="noopener">url参考-api</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习（下部分）</title>
    <url>/2017/mysql%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h3 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h3><pre><code>MySQL 事务主要用于处理操作量大，复杂度高的数据。
在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息。
事务用来管理 insert,update,delete 语句。
事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）。
</code></pre><h4 id="事物控制语句"><a href="#事物控制语句" class="headerlink" title="事物控制语句"></a>事物控制语句</h4><pre><code>BEGIN或START TRANSACTION；显式地开启一个事务；
COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；
ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；
RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
ROLLBACK TO identifier；把事务回滚到标记点；
SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。
</code></pre><h4 id="MYSQL-事务处理主要有两种方法"><a href="#MYSQL-事务处理主要有两种方法" class="headerlink" title="MYSQL 事务处理主要有两种方法"></a>MYSQL 事务处理主要有两种方法</h4><pre><code>1、用 BEGIN, ROLLBACK, COMMIT来实现
    BEGIN 开始一个事务
    ROLLBACK 事务回滚
    COMMIT 事务确认
2、直接用 SET 来改变 MySQL 的自动提交模式:
    SET AUTOCOMMIT=0 禁止自动提交
    SET AUTOCOMMIT=1 开启自动提交
</code></pre><h4 id="事务测试"><a href="#事务测试" class="headerlink" title="事务测试"></a>事务测试</h4><pre><code>CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表
mysql&gt; select * from runoob_transaction_test; 
mysql&gt; begin;  # 开始事务
mysql&gt; insert into runoob_transaction_test value(5); 
mysql&gt; insert into runoob_transaction_test value(6); 
mysql&gt; commit; # 提交事务 
mysql&gt;  select * from runoob_transaction_test;
+------+
| id   |
+------+
| 5    |
| 6    |
+------+ 
mysql&gt; begin;    # 开始事务
mysql&gt;  insert into runoob_transaction_test values(7);
mysql&gt; rollback;   # 回滚
mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入
</code></pre><h3 id="MySQL-ALTER命令"><a href="#MySQL-ALTER命令" class="headerlink" title="MySQL ALTER命令"></a>MySQL ALTER命令</h3><pre><code>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。
</code></pre><h4 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h4><pre><code>// 删除一列（不能是最后一列）
ALTER TABLE table_name DROP column_name;
// 添加一列
ALTER TABLE table_name ADD column_name INT;
// 查看列数据类型
SHOW COLUMNS FROM table_name;
// MySQL提供的关键字 FIRST (设定位第一列)
ALTER TABLE table_name ADD column_name INT FIRST;
// AFTER 字段名（设定位于某个字段之后）
ALTER TABLE table_name ADD column_name INT AFTER c;
</code></pre><h4 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h4><pre><code>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。    
// 更改列的类型
ALTER TABLE table_name MODIFY column_name CHAR(10);
ALTER TABLE table_name CHANGE i j INT;
</code></pre><h4 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h4><pre><code>// 指定字段 column_name 为 NOT NULL 且默认值为100 。
ALTER TABLE table_name MODIFY column_name BIGINT NOT NULL DEFAULT 100;    
</code></pre><h4 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h4><pre><code>// ALTER 来修改字段的默认值
ALTER TABLE table_name ALTER column_name SET DEFAULT 1000;
// ALTER 命令及 DROP子句来删除字段的默认值
ALTER TABLE table_name ALTER column_name DROP DEFAULT;
</code></pre><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><pre><code>ALTER TABLE table_name RENAME TO table_name1;
</code></pre><h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><pre><code>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。
索引分单列索引和组合索引。
单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
组合索引，即一个索引包含多个列。
实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。
</code></pre><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><pre><code>CREATE INDEX indexName ON mytable(username(length)); 
// 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。
</code></pre><h5 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h5><pre><code>ALTER table tableName ADD INDEX indexName(columnName)
</code></pre><h5 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h5><pre><code>CREATE TABLE mytable(  
    ID INT NOT NULL,   
    username VARCHAR(16) NOT NULL,  
    INDEX [indexName] (username(length))  
);  
</code></pre><h5 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h5><pre><code>DROP INDEX [indexName] ON mytable;
</code></pre><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><pre><code>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
</code></pre><h5 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h5><pre><code>CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
</code></pre><h5 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h5><pre><code>ALTER table mytable ADD UNIQUE [indexName] (username(length))
</code></pre><h5 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h5><pre><code>CREATE TABLE mytable(  
    ID INT NOT NULL,   
    username VARCHAR(16) NOT NULL,  
    UNIQUE [indexName] (username(length))  
); 
</code></pre><h4 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h4><pre><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。
// 为在表中添加索引。
ALTER TABLE testalter_tbl ADD INDEX (c);
// 可以在 ALTER 命令中使用 DROP 子句来删除索引。
ALTER TABLE testalter_tbl DROP INDEX c;
</code></pre><h4 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h4><pre><code>// 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。
ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
// 使用 ALTER 命令删除主键，删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。
ALTER TABLE testalter_tbl DROP PRIMARY KEY;
</code></pre><h4 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h4><pre><code>// 使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。
SHOW INDEX FROM table_name; \G
</code></pre><h3 id="MySQL-临时表"><a href="#MySQL-临时表" class="headerlink" title="MySQL 临时表"></a>MySQL 临时表</h3><pre><code>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。
// 创建临时表
CREATE TEMPORARY TABLE SalesSummary (
    product_name VARCHAR(50) NOT NULL, 
    total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00, 
    avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00, 
    total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
// 临时表插入数据
INSERT INTO SalesSummary
(product_name, total_sales, avg_unit_price, total_units_sold)
VALUES
(&apos;cucumber&apos;, 100.25, 90, 2);
</code></pre><h4 id="删除MySQL-临时表"><a href="#删除MySQL-临时表" class="headerlink" title="删除MySQL 临时表"></a>删除MySQL 临时表</h4><pre><code>DROP TABLE SalesSummary;
</code></pre><h3 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h3><pre><code>使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。
复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。
如果你想复制表的内容，你就可以使用 INSERT INTO ... SELECT 语句来实现。
</code></pre><h3 id="MySQL-元数据"><a href="#MySQL-元数据" class="headerlink" title="MySQL 元数据"></a>MySQL 元数据</h3><pre><code>查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数。
数据库和数据表的信息： 包含了数据库及数据表的结构信息。
MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。
</code></pre><h4 id="获取服务器元数据"><a href="#获取服务器元数据" class="headerlink" title="获取服务器元数据"></a>获取服务器元数据</h4><pre><code>SELECT VERSION( )    服务器版本信息
SELECT DATABASE( )    当前数据库名 (或者返回空)
SELECT USER( )    当前用户名
SHOW STATUS    服务器状态
SHOW VARIABLES    服务器配置变量
</code></pre><h3 id="MySQL-序列使用"><a href="#MySQL-序列使用" class="headerlink" title="MySQL 序列使用"></a>MySQL 序列使用</h3><pre><code>MySQL序列是一组整数：1, 2, 3, ...，由于一张数据表只能有一个字段自增主键， 
如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。
</code></pre><h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h4><pre><code>CREATE TABLE insect
    (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (id),
    name VARCHAR(30) NOT NULL, # type of insect
    date DATE NOT NULL, # date collected
    origin VARCHAR(30) NOT NULL # where collected
    );
INSERT INTO insect (id,name,date,origin) VALUES
    (NULL,&apos;housefly&apos;,&apos;2001-09-10&apos;,&apos;kitchen&apos;),
    (NULL,&apos;millipede&apos;,&apos;2001-09-10&apos;,&apos;driveway&apos;),
    (NULL,&apos;grasshopper&apos;,&apos;2001-09-10&apos;,&apos;front yard&apos;);
</code></pre><h4 id="获取AUTO-INCREMENT值"><a href="#获取AUTO-INCREMENT值" class="headerlink" title="获取AUTO_INCREMENT值"></a>获取AUTO_INCREMENT值</h4><pre><code>在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。
</code></pre><h4 id="重置序列"><a href="#重置序列" class="headerlink" title="重置序列"></a>重置序列</h4><pre><code>如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。
ALTER TABLE insect DROP id;
ALTER TABLE insect
ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,
ADD PRIMARY KEY (id);
</code></pre><h4 id="设置序列的开始值"><a href="#设置序列的开始值" class="headerlink" title="设置序列的开始值"></a>设置序列的开始值</h4><pre><code>一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现
CREATE TABLE insect
    (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (id),
    name VARCHAR(30) NOT NULL, 
    date DATE NOT NULL,
    origin VARCHAR(30) NOT NULL
)engine=innodb auto_increment=100 charset=utf8;
</code></pre><h3 id="MySQL-处理重复数据"><a href="#MySQL-处理重复数据" class="headerlink" title="MySQL 处理重复数据"></a>MySQL 处理重复数据</h3><h4 id="防止表中出现重复数据"><a href="#防止表中出现重复数据" class="headerlink" title="防止表中出现重复数据"></a>防止表中出现重复数据</h4><pre><code>你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。
1.如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person_tbl</span><br><span class="line">(</span><br><span class="line">   first_name CHAR(20) NOT NULL,</span><br><span class="line">   last_name CHAR(20) NOT NULL,</span><br><span class="line">   sex CHAR(10),</span><br><span class="line">   PRIMARY KEY (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

2.INSERT IGNORE INTO会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">   VALUES( &apos;Jay&apos;, &apos;Thomas&apos;);</span><br></pre></td></tr></table></figure>

3.另一种设置数据的唯一性方法是添加一个UNIQUE索引。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person_tbl</span><br><span class="line">(</span><br><span class="line">   first_name CHAR(20) NOT NULL,</span><br><span class="line">   last_name CHAR(20) NOT NULL,</span><br><span class="line">   sex CHAR(10)</span><br><span class="line">   UNIQUE (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="统计重复数据"><a href="#统计重复数据" class="headerlink" title="统计重复数据"></a>统计重复数据</h4><pre><code>以下我们将统计表中 first_name 和 last_name的重复记录数
SELECT COUNT(*) as repetitions, last_name, first_name
FROM person_tbl
GROUP BY last_name, first_name
HAVING repetitions &gt; 1;
确定哪一列包含的值可能会重复。
在列选择列表使用COUNT(*)列出的那些列。
在GROUP BY子句中列出的列。
HAVING子句设置重复数大于1。
</code></pre><h4 id="过滤重复数据"><a href="#过滤重复数据" class="headerlink" title="过滤重复数据"></a>过滤重复数据</h4><pre><code>1.你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。
    SELECT DISTINCT last_name, first_name FROM person_tbl;
2.使用 GROUP BY 来读取数据表中不重复的数据。
    SELECT last_name, first_name
    FROM person_tbl
    GROUP BY (last_name, first_name);
</code></pre><h4 id="删除重复数据"><a href="#删除重复数据" class="headerlink" title="删除重复数据"></a>删除重复数据</h4><pre><code>1.删除person_tbl表中的重复数据
CREATE TABLE tmp SELECT last_name, first_name, sex
FROM person_tbl;
GROUP BY (last_name, first_name, sex);
DROP TABLE person_tbl;
ALTER TABLE tmp RENAME TO person_tbl;
2.可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。
ALTER IGNORE TABLE person_tbl
ADD PRIMARY KEY (last_name, first_name);
</code></pre><h3 id="MySQL-及-SQL-注入"><a href="#MySQL-及-SQL-注入" class="headerlink" title="MySQL 及 SQL 注入"></a>MySQL 及 SQL 注入</h3><pre><code>如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。    
我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。
// 过滤用户的输入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (preg_match(&quot;/^\w&#123;8,20&#125;$/&quot;, $_GET[&apos;username&apos;], $matches))</span><br><span class="line">&#123;</span><br><span class="line">   $result = mysqli_query($conn, &quot;SELECT * FROM users </span><br><span class="line">						  WHERE username=$matches[0]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> else </span><br><span class="line">&#123;</span><br><span class="line">   echo &quot;username 输入异常&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

防止SQL注入，我们需要注意以下几个要点：
    1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双&quot;-&quot;进行转换等。
    2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
    5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。
    6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。
</code></pre><h4 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h4><pre><code>在脚本语言，如Perl和PHP你可以对用户输入的数据进行转义从而来防止SQL注入。
如：mysqli_real_escape_string()
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (get_magic_quotes_gpc()) </span><br><span class="line">&#123;</span><br><span class="line">  $name = stripslashes($name);</span><br><span class="line">&#125;</span><br><span class="line">$name = mysqli_real_escape_string($conn, $name);</span><br><span class="line"> mysqli_query($conn, &quot;SELECT * FROM users WHERE name=&apos;&#123;$name&#125;&apos;&quot;);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="Like语句中的注入"><a href="#Like语句中的注入" class="headerlink" title="Like语句中的注入"></a>Like语句中的注入</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sub = addcslashes(mysqli_real_escape_string($conn, &quot;%something_&quot;), &quot;%_&quot;);</span><br><span class="line">// $sub == \%something\_</span><br><span class="line"> mysqli_query($conn, &quot;SELECT * FROM messages WHERE subject LIKE &apos;&#123;$sub&#125;%&apos;&quot;);</span><br><span class="line">addcslashes() 函数在指定的字符前添加反斜杠。</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="MySQL-导出数据"><a href="#MySQL-导出数据" class="headerlink" title="MySQL 导出数据"></a>MySQL 导出数据</h3><pre><code>MySQL中你可以使用SELECT...INTO OUTFILE语句来简单的导出数据到文本文件上。
1.将数据表 runoob_tbl 数据导出到 /tmp/tutorials.txt 文件中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM runoob_tbl </span><br><span class="line">   INTO OUTFILE &apos;/tmp/tutorials.txt&apos;;</span><br></pre></td></tr></table></figure>

2.可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM passwd INTO OUTFILE &apos;/tmp/tutorials.txt&apos;</span><br><span class="line">   FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos;</span><br><span class="line">   LINES TERMINATED BY &apos;\r\n&apos;;</span><br></pre></td></tr></table></figure>

3.生成一个文件，各值用逗号隔开。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos;</span><br><span class="line">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class="line">LINES TERMINATED BY &apos;\n&apos;</span><br><span class="line">FROM test_table;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="导出表作为原始数据"><a href="#导出表作为原始数据" class="headerlink" title="导出表作为原始数据"></a>导出表作为原始数据</h4><pre><code>mysqldump是mysql用于转存储数据库的实用程序。
使用mysqldump导出数据需要使用 --tab 选项来指定导出文件指定的目录，该目标必须是可写的。    
以下实例将数据表 runoob_tbl 导出到 /tmp 目录中。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p --no-create-info \</span><br><span class="line">           --tab=/tmp database_name table_name</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="导出SQL格式的数据"><a href="#导出SQL格式的数据" class="headerlink" title="导出SQL格式的数据"></a>导出SQL格式的数据</h4><pre><code>1.导出SQL格式的数据到指定文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p database_name table_name &gt; dump.txt</span><br></pre></td></tr></table></figure>

2.导出整个数据库的数据
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p database_name &gt; database_dump.txt</span><br></pre></td></tr></table></figure>

3.备份所有数据库
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p --all-databases &gt; database_dump.txt</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="将数据表及数据库拷贝至其他主机"><a href="#将数据表及数据库拷贝至其他主机" class="headerlink" title="将数据表及数据库拷贝至其他主机"></a>将数据表及数据库拷贝至其他主机</h4><pre><code>将数据备份至 dump.txt 文件中
    mysqldump -u root -p database_name table_name &gt; dump.txt
将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建
    mysql -u root -p database_name &lt; dump.txt
使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的
    mysqldump -u root -p database_name \
        | mysql -h other-host.com database_name
</code></pre><h3 id="MySQL-导入数据"><a href="#MySQL-导入数据" class="headerlink" title="MySQL 导入数据"></a>MySQL 导入数据</h3><h4 id="使用-LOAD-DATA-导入数据"><a href="#使用-LOAD-DATA-导入数据" class="headerlink" title="使用 LOAD DATA 导入数据"></a>使用 LOAD DATA 导入数据</h4><pre><code>将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。
    LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl;
    如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。
</code></pre><h4 id="使用-mysqlimport-导入数据"><a href="#使用-mysqlimport-导入数据" class="headerlink" title="使用 mysqlimport 导入数据"></a>使用 mysqlimport 导入数据</h4><pre><code>从文件 dump.txt 中将数据导入到 mytbl 数据表中
    mysqlimport -u root -p --local database_name dump.txt
</code></pre><h4 id="mysqlimport的常用选项介绍"><a href="#mysqlimport的常用选项介绍" class="headerlink" title="mysqlimport的常用选项介绍"></a>mysqlimport的常用选项介绍</h4><p><img src="/images/mysql_import.png" alt="mysql_import"></p>
<blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MYSQL</a></p>
</blockquote>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>fs模块-文件</title>
    <url>/2017/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-fs.html</url>
    <content><![CDATA[<h3 id="fs模块-文件系统"><a href="#fs模块-文件系统" class="headerlink" title="fs模块-文件系统"></a>fs模块-文件系统</h3><pre><code>以下方法均有同步和异步版本
说明：文件 I/O 是对标准 POSIX 函数的简单封装。 通过 require(&apos;fs&apos;) 使用该模块。 所有的方法都有异步和同步的形式。
异步方法的最后一个参数都是一个回调函数。 传给回调函数的参数取决于具体方法，但回调函数的第一个参数都会保留给异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。
步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。
</code></pre><h3 id="异步的删除文件"><a href="#异步的删除文件" class="headerlink" title="异步的删除文件"></a>异步的删除文件</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.unlink(&apos;tmp/hello&apos;, function (err) &#123;</span><br><span class="line">	if (err) throw err;</span><br><span class="line">	console.log(&apos;删除成功&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="同步的删除文件"><a href="#同步的删除文件" class="headerlink" title="同步的删除文件"></a>同步的删除文件</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	fs.unlinkSync(&apos;tmp/hello&apos;);</span><br><span class="line">&#125;catch (e) &#123;</span><br><span class="line">	console.error(e);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;删除成功&apos;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="fs-contants"><a href="#fs-contants" class="headerlink" title="fs.contants"></a>fs.contants</h3><pre><code>作用：返回一个包含常用文件系统操作的常量的对象。FRWX（可见、读、写、执行）
</code></pre><h3 id="fs-FSWatcher-类"><a href="#fs-FSWatcher-类" class="headerlink" title="fs.FSWatcher 类"></a>fs.FSWatcher 类</h3><pre><code>作用：从 fs.watch() 返回的对象是该类型。
方法：change、error、close分别代表监视目录或文件的改变和出错和关闭监视。
    fs.watch(&apos;./tmp&apos;, (eventType, filename) =&gt; {
        if (filename) { console.log(filename); }
    });
</code></pre><h3 id="fs-ReadStream-类"><a href="#fs-ReadStream-类" class="headerlink" title="fs.ReadStream 类"></a>fs.ReadStream 类</h3><pre><code>作用：ReadStream 是一个可读流。
属性：
    readStream.bytesRead - 已读取的字节数。
    readStream.path - 流正在读取的文件的路径，指定在 fs.createReadStream() 的第一个参数
方法：open、close分别对应ReadStream文件fs.open()被打开和fs.close()被关闭时触发。
</code></pre><h3 id="fs-Stats-类"><a href="#fs-Stats-类" class="headerlink" title="fs.Stats 类"></a>fs.Stats 类</h3><pre><code>从 fs.stat()、fs.lstat() 和 fs.fstat() 及其同步版本返回的对象都是该类型。
stats.isFile()
stats.isDirectory()
stats.isBlockDevice()
stats.isCharacterDevice()
stats.isSymbolicLink() (仅对 fs.lstat() 有效)
stats.isFIFO()
stats.isSocket()
</code></pre><h3 id="Stat-时间值"><a href="#Stat-时间值" class="headerlink" title="Stat 时间值"></a>Stat 时间值</h3><pre><code>atime &quot;访问时间&quot; - 文件数据最近被访问的时间。
mtime &quot;修改时间&quot; - 文件数据最近被修改的时间。
ctime &quot;变化时间&quot; - 文件状态最近更改的时间。
birthtime &quot;创建时间&quot; - 文件创建的时间。 
</code></pre><h3 id="fs-WriteStream类"><a href="#fs-WriteStream类" class="headerlink" title="fs.WriteStream类"></a>fs.WriteStream类</h3><pre><code>作用：WriteStream 一个可写流。
属性：
    writeStream.bytesWritten - 已写入的字节数。 不包括仍在排队等待写入的数据。
    writeStream.path - 流正在写入的文件的路径，指定在 fs.createWriteStream() 的第一个参数。
方法：
    open() - 当 WriteStream 文件被打开时触发。
    close() - 当 WriteStream 底层的文件描述符已被使用 fs.close() 方法关闭时触发。
</code></pre><h3 id="fs-access-path-mode-callback"><a href="#fs-access-path-mode-callback" class="headerlink" title="fs.access(path[, mode], callback);"></a>fs.access(path[, mode], callback);</h3><pre><code>作用：判断用户是否有权限操作给定的目录或者是文件。
    如果要检查一个文件是否存在且不操作它。
mode参数的可选项：
    fs.constants.F_OK - path 文件对调用进程可见（默认）。
    fs.constants.R_OK - path 文件可被调用进程读取。
    fs.constants.W_OK - path 文件可被调用进程写入。
    fs.constants.X_OK - path 文件可被调用进程执行。
</code></pre><h3 id="fs-accessSync-path-mode"><a href="#fs-accessSync-path-mode" class="headerlink" title="fs.accessSync(path[, mode]);"></a>fs.accessSync(path[, mode]);</h3><pre><code>fs.access() 的同步版本。
</code></pre><h3 id="fs-appendFile-file-data-options-callback"><a href="#fs-appendFile-file-data-options-callback" class="headerlink" title="fs.appendFile(file, data[, options], callback);"></a>fs.appendFile(file, data[, options], callback);</h3><pre><code>作用：异步地追加数据到一个文件，如果文件不存在则创建文件。
fs.appendFile(&apos;filename.txt&apos;, &apos;data to append&apos; , (err) =&gt; {
    if (err) throw err;
    console.log(&apos;添加成功&apos;);
});
</code></pre><h3 id="fs-chmod-path-mode-callback"><a href="#fs-chmod-path-mode-callback" class="headerlink" title="fs.chmod(path, mode, callback);"></a>fs.chmod(path, mode, callback);</h3><pre><code>作用： 更改文件属性（存取模式）(mode)。
</code></pre><h3 id="fs-chown-path-uid-gid-callback"><a href="#fs-chown-path-uid-gid-callback" class="headerlink" title="fs.chown(path, uid, gid, callback);"></a>fs.chown(path, uid, gid, callback);</h3><pre><code>作用：修改文件目录属主。用户ID，群体身份（共享资源系统使用者的身份）
</code></pre><h3 id="fs-close-fd-callback"><a href="#fs-close-fd-callback" class="headerlink" title="fs.close(fd, callback);"></a>fs.close(fd, callback);</h3><pre><code>作用：关闭已打开的文件。
</code></pre><h3 id="fs-createReadStream-path-options"><a href="#fs-createReadStream-path-options" class="headerlink" title="fs.createReadStream(path[, options]);"></a>fs.createReadStream(path[, options]);</h3><pre><code>作用：返回一个新建的ReadStream对象。
</code></pre><h3 id="fs-createWriteStream-path-options"><a href="#fs-createWriteStream-path-options" class="headerlink" title="fs.createWriteStream(path[, options]);"></a>fs.createWriteStream(path[, options]);</h3><pre><code>作用：返回一个新建的WriteStream对象。
</code></pre><h3 id="fs-existsSync-path"><a href="#fs-existsSync-path" class="headerlink" title="fs.existsSync(path);"></a>fs.existsSync(path);</h3><pre><code>作用： 判断文件是否存在的同步版，异步已经废弃了。
</code></pre><h3 id="fs-fchmod-fd-mode-callback"><a href="#fs-fchmod-fd-mode-callback" class="headerlink" title="fs.fchmod(fd, mode, callback);"></a>fs.fchmod(fd, mode, callback);</h3><pre><code>作用：更改文件权限（文件描述符）。
</code></pre><h3 id="fs-fchown-fd-uid-gid-callback"><a href="#fs-fchown-fd-uid-gid-callback" class="headerlink" title="fs.fchown(fd, uid, gid, callback);"></a>fs.fchown(fd, uid, gid, callback);</h3><pre><code>作用：更改文件所有权(文件描述符)。
</code></pre><h3 id="fs-fdatasync-fd-callback"><a href="#fs-fdatasync-fd-callback" class="headerlink" title="fs.fdatasync(fd, callback);"></a>fs.fdatasync(fd, callback);</h3><pre><code>作用：刷新数据到磁盘。
</code></pre><h3 id="fs-fstat-fd-callback"><a href="#fs-fstat-fd-callback" class="headerlink" title="fs.fstat(fd, callback);"></a>fs.fstat(fd, callback);</h3><pre><code>作用：返回文件的详细信息。
</code></pre><h3 id="fs-fsync-fd-callback"><a href="#fs-fsync-fd-callback" class="headerlink" title="fs.fsync(fd, callback);"></a>fs.fsync(fd, callback);</h3><pre><code>作用：同步缓存数据到磁盘。
</code></pre><h3 id="fs-ftruncate-fd-len-callback"><a href="#fs-ftruncate-fd-len-callback" class="headerlink" title="fs.ftruncate(fd, len, callback);"></a>fs.ftruncate(fd, len, callback);</h3><pre><code>作用：截取文件内容。
</code></pre><h3 id="fs-futimes-fd-atime-mtime-callback"><a href="#fs-futimes-fd-atime-mtime-callback" class="headerlink" title="fs.futimes(fd, atime, mtime, callback);"></a>fs.futimes(fd, atime, mtime, callback);</h3><pre><code>作用：更改一个文件所提供的文件描述符引用的文件的时间戳。
</code></pre><h3 id="fs-lchmod-path-mode-callback"><a href="#fs-lchmod-path-mode-callback" class="headerlink" title="fs.lchmod(path, mode, callback);"></a>fs.lchmod(path, mode, callback);</h3><pre><code>作用：更改文件权限(不解析符号链接)。
</code></pre><h3 id="fs-lchown-path-uid-gid-callback"><a href="#fs-lchown-path-uid-gid-callback" class="headerlink" title="fs.lchown(path, uid, gid, callback)"></a>fs.lchown(path, uid, gid, callback)</h3><pre><code>作用：更改文件所有权（不解析符号链接）。
</code></pre><h3 id="fs-link-existingPath-newPath-callback"><a href="#fs-link-existingPath-newPath-callback" class="headerlink" title="fs.link(existingPath, newPath, callback);"></a>fs.link(existingPath, newPath, callback);</h3><pre><code>作用：创建硬链接(只能在本券中)。
</code></pre><h3 id="fs-lstat-path-callback"><a href="#fs-lstat-path-callback" class="headerlink" title="fs.lstat(path, callback);"></a>fs.lstat(path, callback);</h3><pre><code>作用：获取文件信息(不解析符号链接)。
</code></pre><h3 id="fs-mkdir-path-mode-callback"><a href="#fs-mkdir-path-mode-callback" class="headerlink" title="fs.mkdir(path[, mode], callback);"></a>fs.mkdir(path[, mode], callback);</h3><pre><code>作用：创建文件目录，如果目录已存在，将抛出异常。
</code></pre><h3 id="fs-mkdtemp-prefix-options-callback"><a href="#fs-mkdtemp-prefix-options-callback" class="headerlink" title="fs.mkdtemp(prefix[, options], callback);"></a>fs.mkdtemp(prefix[, options], callback);</h3><pre><code>作用：创建临时目录。
</code></pre><h3 id="fs-open-path-flags-mode-callback"><a href="#fs-open-path-flags-mode-callback" class="headerlink" title="fs.open(path, flags[, mode], callback);"></a>fs.open(path, flags[, mode], callback);</h3><pre><code>作用：打开文件。
</code></pre><h3 id="fs-read-fd-buffer-offset-length-position-callback"><a href="#fs-read-fd-buffer-offset-length-position-callback" class="headerlink" title="fs.read(fd, buffer, offset, length, position, callback);"></a>fs.read(fd, buffer, offset, length, position, callback);</h3><pre><code>作用：读取文件内容。
</code></pre><h3 id="fs-readdir-path-options-callback"><a href="#fs-readdir-path-options-callback" class="headerlink" title="fs.readdir(path[, options], callback);"></a>fs.readdir(path[, options], callback);</h3><pre><code>作用：读取文件目录。
</code></pre><h3 id="fs-readFile-path-options-callback"><a href="#fs-readFile-path-options-callback" class="headerlink" title="fs.readFile(path[, options], callback);"></a>fs.readFile(path[, options], callback);</h3><pre><code>作用：读取文件。
</code></pre><h3 id="fs-readlink-path-options-callback"><a href="#fs-readlink-path-options-callback" class="headerlink" title="fs.readlink(path[, options], callback);"></a>fs.readlink(path[, options], callback);</h3><pre><code>作用：读取软连接信息。
</code></pre><h3 id="fs-readSync-fd-buffer-offset-length-position"><a href="#fs-readSync-fd-buffer-offset-length-position" class="headerlink" title="fs.readSync(fd, buffer, offset, length, position);"></a>fs.readSync(fd, buffer, offset, length, position);</h3><pre><code>作用：读取文件内容，返回字节数。
</code></pre><h3 id="fs-realpath-path-options-callback"><a href="#fs-realpath-path-options-callback" class="headerlink" title="fs.realpath(path[, options], callback);"></a>fs.realpath(path[, options], callback);</h3><pre><code>作用：获取真实路径。
</code></pre><h3 id="fs-rename-oldPath-newPath-callback"><a href="#fs-rename-oldPath-newPath-callback" class="headerlink" title="fs.rename(oldPath, newPath, callback);"></a>fs.rename(oldPath, newPath, callback);</h3><pre><code>作用：重命名路径。
</code></pre><h3 id="fs-rmdir-path-callback"><a href="#fs-rmdir-path-callback" class="headerlink" title="fs.rmdir(path, callback);"></a>fs.rmdir(path, callback);</h3><pre><code>作用：删除文件目录。
</code></pre><h3 id="fs-stat-path-callback"><a href="#fs-stat-path-callback" class="headerlink" title="fs.stat(path, callback);"></a>fs.stat(path, callback);</h3><pre><code>作用：获取文件信息。
</code></pre><h3 id="fs-symlink-target-path-type-callback"><a href="#fs-symlink-target-path-type-callback" class="headerlink" title="fs.symlink(target, path[, type], callback);"></a>fs.symlink(target, path[, type], callback);</h3><pre><code>作用：创建符号链接。
</code></pre><h3 id="fs-truncate-path-len-callback"><a href="#fs-truncate-path-len-callback" class="headerlink" title="fs.truncate(path[, len], callback);"></a>fs.truncate(path[, len], callback);</h3><pre><code>作用：文件内容截取操作。
</code></pre><h3 id="fs-unlink-path-callback"><a href="#fs-unlink-path-callback" class="headerlink" title="fs.unlink(path, callback);"></a>fs.unlink(path, callback);</h3><pre><code>作用：删除文件操作。
</code></pre><h3 id="fs-unwatchFile-filename-listener"><a href="#fs-unwatchFile-filename-listener" class="headerlink" title="fs.unwatchFile(filename[, listener]);"></a>fs.unwatchFile(filename[, listener]);</h3><pre><code>作用：解除文件监听。
</code></pre><h3 id="fs-utimes-path-atime-mtime-callback"><a href="#fs-utimes-path-atime-mtime-callback" class="headerlink" title="fs.utimes(path, atime, mtime, callback);"></a>fs.utimes(path, atime, mtime, callback);</h3><pre><code>作用：修改文件时间戳。
</code></pre><h3 id="fs-watch-filename-options-listener"><a href="#fs-watch-filename-options-listener" class="headerlink" title="fs.watch(filename[, options][, listener]);"></a>fs.watch(filename[, options][, listener]);</h3><pre><code>作用：监控文件。
</code></pre><h3 id="fs-watchFile-filename-options-listener"><a href="#fs-watchFile-filename-options-listener" class="headerlink" title="fs.watchFile(filename[, options], listener);"></a>fs.watchFile(filename[, options], listener);</h3><pre><code>作用：监控文件。
</code></pre><h3 id="fs-write-fd-buffer-offset-length-position-callback"><a href="#fs-write-fd-buffer-offset-length-position-callback" class="headerlink" title="fs.write(fd, buffer[, offset[, length[, position]]], callback);"></a>fs.write(fd, buffer[, offset[, length[, position]]], callback);</h3><pre><code>作用：向文件写数据。
</code></pre><h3 id="fs-writeFile-file-data-options-callback"><a href="#fs-writeFile-file-data-options-callback" class="headerlink" title="fs.writeFile(file, data[, options], callback);"></a>fs.writeFile(file, data[, options], callback);</h3><pre><code>作用：向文件写数据。        
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">fs参考-api</a><br>    <a href="http://blog.csdn.net/zza000000/article/details/54341943" target="_blank" rel="noopener">fs模块</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>全局变量-global</title>
    <url>/2017/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</url>
    <content><![CDATA[<h1 id="global-全局变量"><a href="#global-全局变量" class="headerlink" title="global - 全局变量"></a>global - 全局变量</h1><pre><code>global - 全局变量，相当于浏览器环境下的window对象。
</code></pre><h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><pre><code>作用：当前模块的文件夹名称。等同于 __filename 的 path.dirname() 的值。
</code></pre><h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><pre><code>作用：当前模块的文件名称---解析后的绝对路径。
</code></pre><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><pre><code>作用：导出一个对象。
module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容。
</code></pre><h2 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h2><pre><code>作用：导出一个方法，为module.exports的简写形式。
</code></pre><p>PS:    module.exports和exports的区别<br>    每一个node.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是 {}<br>    module.exports本身不具备任何属性和方法。如果，Module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。</p>
<h2 id="require-path"><a href="#require-path" class="headerlink" title="require(path)"></a>require(path)</h2><pre><code>作用：引入模块。
</code></pre><p>PS：module导入查找顺序。核心模块 -》 否则将执行下列查找<br>如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 .js、.json 或 .node 拓展名再加载。<br>.js 文件会被解析为 JavaScript 文本文件，.json 文件会被解析为 JSON 文本文件。 .node 文件会被解析为通过 dlopen 加载的编译后的插件模块。<br>以 ‘/‘ 为前缀的模块是文件的绝对路径。 例如，require(‘/home/marco/foo.js’) 会加载 /home/marco/foo.js 文件。<br>以 ‘./‘ 为前缀的模块是相对于调用 require() 的文件的。 也就是说，circle.js 必须和 foo.js 在同一目录下以便于 require(‘./circle’) 找到它。<br>当没有以 ‘/‘、’./‘ 或 ‘../‘ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。<br>如果给定的路径不存在，则 require() 会抛出一个 code 属性为 ‘MODULE_NOT_FOUND’ 的 Error。    </p>
<h1 id="timer（定时器）"><a href="#timer（定时器）" class="headerlink" title="timer（定时器）"></a>timer（定时器）</h1><h2 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[, …args])"></a>setImmediate(callback[, …args])</h2><pre><code>作用：创建 Immediate 对象。
</code></pre><h2 id="clearImmediate-immediateObject"><a href="#clearImmediate-immediateObject" class="headerlink" title="clearImmediate(immediateObject)"></a>clearImmediate(immediateObject)</h2><pre><code>作用：取消一个由 setImmediate() 创建的 Immediate 对象。
</code></pre><h2 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a>setInterval(callback, delay[, …args])</h2><pre><code>作用：创建 Timeout 对象。
</code></pre><h2 id="clearInterval-timeoutObject"><a href="#clearInterval-timeoutObject" class="headerlink" title="clearInterval(timeoutObject)"></a>clearInterval(timeoutObject)</h2><pre><code>作用：取消一个由 setInterval() 创建的 Timeout 对象。
</code></pre><h2 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a>setTimeout(callback, delay[, …args])</h2><pre><code>作用：创建 Timeout 对象。
</code></pre><h2 id="clearTimeout-timeoutObject"><a href="#clearTimeout-timeoutObject" class="headerlink" title="clearTimeout(timeoutObject)"></a>clearTimeout(timeoutObject)</h2><pre><code>作用：取消一个由 setTimeout() 创建的 Timeout 对象。
</code></pre><h1 id="events（事件）"><a href="#events（事件）" class="headerlink" title="events（事件）"></a>events（事件）</h1><p>包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<h2 id="绑定监听事件"><a href="#绑定监听事件" class="headerlink" title="绑定监听事件"></a>绑定监听事件</h2><h3 id="emitter-addListener-eventName-listener"><a href="#emitter-addListener-eventName-listener" class="headerlink" title="emitter.addListener(eventName, listener)"></a>emitter.addListener(eventName, listener)</h3><h3 id="emitter-on-eventName-listener"><a href="#emitter-on-eventName-listener" class="headerlink" title="emitter.on(eventName, listener)"></a>emitter.on(eventName, listener)</h3><h3 id="emitter-once-eventName-listener"><a href="#emitter-once-eventName-listener" class="headerlink" title="emitter.once(eventName, listener)"></a>emitter.once(eventName, listener)</h3><h3 id="emitter-prependListener-eventName-listener"><a href="#emitter-prependListener-eventName-listener" class="headerlink" title="emitter.prependListener(eventName, listener)"></a>emitter.prependListener(eventName, listener)</h3><h3 id="emitter-prependOnceListener-eventName-listener"><a href="#emitter-prependOnceListener-eventName-listener" class="headerlink" title="emitter.prependOnceListener(eventName, listener)"></a>emitter.prependOnceListener(eventName, listener)</h3><p>PS：添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 下次触发 eventName 事件时，监听器会被移除，然后调用。</p>
<h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><h3 id="emitter-emit-eventName-…args"><a href="#emitter-emit-eventName-…args" class="headerlink" title="emitter.emit(eventName[, …args])"></a>emitter.emit(eventName[, …args])</h3><p>PS：如果事件有注册监听返回 true，否则返回 false。</p>
<h2 id="移除监听事件"><a href="#移除监听事件" class="headerlink" title="移除监听事件"></a>移除监听事件</h2><h3 id="emitter-removeListener-eventName-listener"><a href="#emitter-removeListener-eventName-listener" class="headerlink" title="emitter.removeListener(eventName, listener)"></a>emitter.removeListener(eventName, listener)</h3><h3 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a>emitter.removeAllListeners([eventName])</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="‘newListener’-事件"><a href="#‘newListener’-事件" class="headerlink" title="‘newListener’ 事件"></a>‘newListener’ 事件</h3><h3 id="‘removeListener’-事件"><a href="#‘removeListener’-事件" class="headerlink" title="‘removeListener’ 事件"></a>‘removeListener’ 事件</h3><p>PS：当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。</p>
<h3 id="‘error’-事件"><a href="#‘error’-事件" class="headerlink" title="‘error’ 事件"></a>‘error’ 事件</h3><p>PS：当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。<br>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<h3 id="EventEmitter-defaultMaxListeners"><a href="#EventEmitter-defaultMaxListeners" class="headerlink" title="EventEmitter.defaultMaxListeners"></a>EventEmitter.defaultMaxListeners</h3><h3 id="emitter-setMaxListeners-n"><a href="#emitter-setMaxListeners-n" class="headerlink" title="emitter.setMaxListeners(n)"></a>emitter.setMaxListeners(n)</h3><h3 id="emitter-getMaxListeners"><a href="#emitter-getMaxListeners" class="headerlink" title="emitter.getMaxListeners()"></a>emitter.getMaxListeners()</h3><h3 id="emitter-listenerCount-eventName"><a href="#emitter-listenerCount-eventName" class="headerlink" title="emitter.listenerCount(eventName)"></a>emitter.listenerCount(eventName)</h3><p>PS：返回正在监听名为 eventName 的事件的监听器的数量。</p>
<h3 id="emitter-listeners-eventName"><a href="#emitter-listeners-eventName" class="headerlink" title="emitter.listeners(eventName)"></a>emitter.listeners(eventName)</h3><p>PS：返回名为 eventName 的事件的监听器数组的副本。</p>
<h3 id="emitter-eventNames"><a href="#emitter-eventNames" class="headerlink" title="emitter.eventNames()"></a>emitter.eventNames()</h3><p>PS：返回一个列出触发器已注册监听器的事件的数组。 数组中的值为string或symbol。</p>
<h1 id="assert（断言）"><a href="#assert（断言）" class="headerlink" title="assert（断言）"></a>assert（断言）</h1><p>assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误,可用于测试模块功能，有少数几个是常用的。</p>
<h1 id="console控制台"><a href="#console控制台" class="headerlink" title="console控制台"></a>console控制台</h1><h2 id="console-assert-value-message-…args"><a href="#console-assert-value-message-…args" class="headerlink" title="console.assert(value[, message][, …args])"></a>console.assert(value[, message][, …args])</h2><p>PS：一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。</p>
<h2 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a>console.clear()</h2><p>PS：当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。</p>
<h2 id="console-count-label"><a href="#console-count-label" class="headerlink" title="console.count([label])"></a>console.count([label])</h2><p>PS：维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。</p>
<h2 id="console-countReset-label-’default’"><a href="#console-countReset-label-’default’" class="headerlink" title="console.countReset([label=’default’])"></a>console.countReset([label=’default’])</h2><p>PS：重置指定 label 的内部计数器。</p>
<h2 id="console-log-data-…args"><a href="#console-log-data-…args" class="headerlink" title="console.log([data][, …args])"></a>console.log([data][, …args])</h2><p>console.info([data][, …args])<br>console.debug(data[, …args])</p>
<h2 id="console-error-data-…args"><a href="#console-error-data-…args" class="headerlink" title="console.error([data][, …args])"></a>console.error([data][, …args])</h2><p>console.warn([data][, …args])<br>PS：打印到 stderr，并带上换行符。</p>
<h2 id="console-group-…label"><a href="#console-group-…label" class="headerlink" title="console.group([…label])"></a>console.group([…label])</h2><p>console.groupCollapsed()<br>PS：将后续行的缩进增加两个空格。<br>console.groupEnd()<br>PS：将后续行的缩进减少两个空格。<br>PS：打印到 stdout，并带上换行符。</p>
<h2 id="console-time-label"><a href="#console-time-label" class="headerlink" title="console.time(label)"></a>console.time(label)</h2><p>console.timeEnd(label)<br>PS：启动一个定时器，用以计算一个操作的持续时间。</p>
<h2 id="console-trace-message-…args"><a href="#console-trace-message-…args" class="headerlink" title="console.trace([message][, …args])"></a>console.trace([message][, …args])</h2><p>PS：打印字符串 ‘Trace :’ 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。</p>
<h2 id="console-dir-obj-options"><a href="#console-dir-obj-options" class="headerlink" title="console.dir(obj[, options])"></a>console.dir(obj[, options])</h2><p>PS：在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。</p>
<h1 id="process-进程"><a href="#process-进程" class="headerlink" title="process - 进程"></a>process - 进程</h1><p>process 对象是一个全局变量，它提供当前 Node.js 进程的有关信息，以及控制当前 Node.js 进程。</p>
<h2 id="process-事件"><a href="#process-事件" class="headerlink" title="process 事件"></a>process 事件</h2><h3 id="beforeExit-事件"><a href="#beforeExit-事件" class="headerlink" title="beforeExit 事件"></a>beforeExit 事件</h3><p>当 Node.js 的事件循环数组已经为空，并且没有额外的工作被添加进来，事件 ‘beforeExit’ 会被触发。</p>
<h3 id="disconnect-事件"><a href="#disconnect-事件" class="headerlink" title="disconnect 事件"></a>disconnect 事件</h3><p>如果 Node.js 进程是由 IPC 通道的方式创建的，当 IPC 通道关闭时，会触发’disconnect’事件。</p>
<h3 id="exit-事件"><a href="#exit-事件" class="headerlink" title="exit 事件"></a>exit 事件</h3><p>两种情况触发：<br>显式调用 process.exit() 方法，使得 Node.js 进程即将结束；<br>Node.js 事件循环数组中不再有额外的工作，使得 Node.js 进程即将结束。</p>
<h3 id="message-事件"><a href="#message-事件" class="headerlink" title="message 事件"></a>message 事件</h3><p>如果 Node.js 进程是由 IPC 通道的方式创建的，当子进程收到父进程发送的消息时(消息通过 childprocess.send() 发送），会触发 ‘message’ 事件。</p>
<h3 id="rejectionHandled-事件"><a href="#rejectionHandled-事件" class="headerlink" title="rejectionHandled 事件"></a>rejectionHandled 事件</h3><p>如果有 Promise 被 rejected，并且此 Promise在 Nodje.js 事件循环的下次轮询及之后期间，被绑定了一个错误处理器（例如使用 promise.catch()），会触发 ‘rejectionHandled’ 事件。</p>
<h3 id="uncaughtException-事件"><a href="#uncaughtException-事件" class="headerlink" title="uncaughtException 事件"></a>uncaughtException 事件</h3><p>如果 Javascript 未捕获的异常，沿着代码调用路径反向传递回事件循环，会触发 ‘uncaughtException’ 事件。 Node.js 默认情况下会将这些异常堆栈打印到 stderr 然后进程退出。 为 ‘uncaughtException’ 事件增加监听器会覆盖上述默认行为。</p>
<h3 id="unhandledRejection-事件"><a href="#unhandledRejection-事件" class="headerlink" title="unhandledRejection 事件"></a>unhandledRejection 事件</h3><p>如果在事件循环的一次轮询中，一个 Promise 被 rejected，并且此 Promise 没有绑定错误处理器，’unhandledRejection 事件会被触发。</p>
<h3 id="warning-事件"><a href="#warning-事件" class="headerlink" title="warning 事件"></a>warning 事件</h3><p>任何时候Node.js发出进程告警，都会触发’warning’事件。</p>
<h2 id="信号事件"><a href="#信号事件" class="headerlink" title="信号事件"></a>信号事件</h2><p>SIGUSR1、SIGTERM 、SIGINT、SIGPIPE等等</p>
<h2 id="IPC（Inter-Process-Communication，进程间通信）方法"><a href="#IPC（Inter-Process-Communication，进程间通信）方法" class="headerlink" title="IPC（Inter-Process Communication，进程间通信）方法"></a>IPC（Inter-Process Communication，进程间通信）方法</h2><h3 id="process-channel"><a href="#process-channel" class="headerlink" title="process.channel"></a>process.channel</h3><p>如果Node.js进程是由IPC channel方式创建的，process.channel属性保存IPC channel的引用。 如果IPC channel不存在，此属性值为undefined。</p>
<h3 id="process-connected"><a href="#process-connected" class="headerlink" title="process.connected"></a>process.connected</h3><p>如果Node.js进程是由IPC channel方式创建的， 只要IPC channel保持连接，process.connected属性就会返回true。 process.disconnect()被调用后，此属性会返回false。</p>
<h3 id="process-disconnect"><a href="#process-disconnect" class="headerlink" title="process.disconnect()"></a>process.disconnect()</h3><p>如果 Node.js 进程是从IPC频道派生出来的, process.disconnect()函数会关闭到父进程的IPC频道，以允许子进程一旦没有其他链接来保持活跃就优雅地关闭。</p>
<h3 id="process-pid"><a href="#process-pid" class="headerlink" title="process.pid"></a>process.pid</h3><p>返回进程的PID。</p>
<h3 id="process-ppid"><a href="#process-ppid" class="headerlink" title="process.ppid"></a>process.ppid</h3><p>返回父进程的id。</p>
<h3 id="process-send-message-sendHandle-options-callback"><a href="#process-send-message-sendHandle-options-callback" class="headerlink" title="process.send(message[, sendHandle[, options]][, callback])"></a>process.send(message[, sendHandle[, options]][, callback])</h3><p>如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息。 接收到的消息被视为父进程的ChildProcess对象上的一个’message’事件。</p>
<h2 id="process-abort"><a href="#process-abort" class="headerlink" title="process.abort()"></a>process.abort()</h2><p>使Node.js进程立即结束，并生成一个core文件。</p>
<h2 id="process-arch"><a href="#process-arch" class="headerlink" title="process.arch"></a>process.arch</h2><p>返回CPU体系机构字符串（arm、arm64）。</p>
<h2 id="process-execPath"><a href="#process-execPath" class="headerlink" title="process.execPath"></a>process.execPath</h2><p>Node.js执行的路径。</p>
<h2 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h2><p>返回一个数组。[process.execPath, 当前执行js文件路径, 剩余的元素为其他命令行参数。]</p>
<h2 id="process-argv0"><a href="#process-argv0" class="headerlink" title="process.argv0"></a>process.argv0</h2><p>保存Node.js启动时传入的argv[0]参数值的一份只读副本。</p>
<h2 id="process-chdir-directory"><a href="#process-chdir-directory" class="headerlink" title="process.chdir(directory)"></a>process.chdir(directory)</h2><p>变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)。</p>
<h2 id="process-config（可读可写）"><a href="#process-config（可读可写）" class="headerlink" title="process.config（可读可写）"></a>process.config（可读可写）</h2><p>返回一个Javascript对象。此对象描述了用于编译当前Node.js执行程序时涉及的配置项信息。</p>
<h2 id="process-cpuUsage-previousValue"><a href="#process-cpuUsage-previousValue" class="headerlink" title="process.cpuUsage([previousValue])"></a>process.cpuUsage([previousValue])</h2><p>返回包含当前进程的用户CPU时间和系统CPU时间的对象。</p>
<h2 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h2><p>返回 Node.js 进程当前工作的目录。</p>
<h2 id="process-emitWarning-warning-options"><a href="#process-emitWarning-warning-options" class="headerlink" title="process.emitWarning(warning[, options])"></a>process.emitWarning(warning[, options])</h2><p>process.emitWarning()方法可用于发出定制的或应用特定的进程警告。<br>process.emitWarning(warning[, type[, code]][, ctor])</p>
<h2 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h2><p>返回一个包含用户环境信息的对象。</p>
<h2 id="process-execArgv"><a href="#process-execArgv" class="headerlink" title="process.execArgv"></a>process.execArgv</h2><p>返回当Node.js进程被启动时，Node.js特定的命令行选项。如：–harmony</p>
<h2 id="process-execPath-1"><a href="#process-execPath-1" class="headerlink" title="process.execPath"></a>process.execPath</h2><p>process.execPath 属性，返回启动Node.js进程的可执行文件所在的绝对路径。</p>
<h2 id="process-exit-code"><a href="#process-exit-code" class="headerlink" title="process.exit([code])"></a>process.exit([code])</h2><p>process.exit()方法以结束状态码code指示Node.js同步终止进程。</p>
<h2 id="process-exitCode"><a href="#process-exitCode" class="headerlink" title="process.exitCode"></a>process.exitCode</h2><p>当进程正常结束，或通过process.exit()结束但未传递参数时，此数值标识进程结束的状态码。</p>
<h2 id="process-getegid"><a href="#process-getegid" class="headerlink" title="process.getegid()"></a>process.getegid()</h2><p>返回Node.js进程的有效数字标记的组身份(See getegid(2))。</p>
<h2 id="process-geteuid"><a href="#process-geteuid" class="headerlink" title="process.geteuid()"></a>process.geteuid()</h2><p>返回Node.js进程的有效数字标记的用户身份(See geteuid(2))。</p>
<h2 id="process-getgid"><a href="#process-getgid" class="headerlink" title="process.getgid()"></a>process.getgid()</h2><p>返回Node.js进程的数字标记的组身份(See getgid(2))。</p>
<h2 id="process-getgroups"><a href="#process-getgroups" class="headerlink" title="process.getgroups()"></a>process.getgroups()</h2><p>返回数组，其中包含了补充的组ID。</p>
<h2 id="process-getuid"><a href="#process-getuid" class="headerlink" title="process.getuid()"></a>process.getuid()</h2><p>返回Node.js进程的数字标记的用户身份(See getuid(2))。</p>
<h2 id="process-hrtime-time"><a href="#process-hrtime-time" class="headerlink" title="process.hrtime([time])"></a>process.hrtime([time])</h2><p>返回当前时间以[seconds, nanoseconds] tuple Array表示的高精度解析值， nanoseconds是当前时间无法使用秒的精度表示的剩余部分。</p>
<h2 id="process-initgroups-user-extra-group"><a href="#process-initgroups-user-extra-group" class="headerlink" title="process.initgroups(user, extra_group)"></a>process.initgroups(user, extra_group)</h2><p>读取/etc/group文件，并且初始化组访问列表，该列表包括了用户所在的所有组。</p>
<h2 id="process-kill-pid-signal"><a href="#process-kill-pid-signal" class="headerlink" title="process.kill(pid[, signal])"></a>process.kill(pid[, signal])</h2><p>将signal发送给pid标识的进程。</p>
<h2 id="process-mainModule"><a href="#process-mainModule" class="headerlink" title="process.mainModule"></a>process.mainModule</h2><p>提供了一种获取require.main的替代方式。</p>
<h2 id="process-memoryUsage"><a href="#process-memoryUsage" class="headerlink" title="process.memoryUsage()"></a>process.memoryUsage()</h2><p>返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节。</p>
<h2 id="process-nextTick-callback-…args"><a href="#process-nextTick-callback-…args" class="headerlink" title="process.nextTick(callback[, …args])"></a>process.nextTick(callback[, …args])</h2><p>将 callback 添加到”next tick 队列”。<br> 每次事件轮询后，在额外的I/O执行前，next tick队列都会优先执行。</p>
<h2 id="process-noDeprecation"><a href="#process-noDeprecation" class="headerlink" title="process.noDeprecation"></a>process.noDeprecation</h2><h2 id="process-platform"><a href="#process-platform" class="headerlink" title="process.platform"></a>process.platform</h2><p>返回字符串，标识Node.js进程运行其上的操作系统平台。</p>
<h2 id="process-release"><a href="#process-release" class="headerlink" title="process.release"></a>process.release</h2><p>返回与当前发布相关的元数据对象，包括源代码和源代码头文件 tarball的URLs。</p>
<h2 id="process-setegid-id"><a href="#process-setegid-id" class="headerlink" title="process.setegid(id)"></a>process.setegid(id)</h2><p>为进程设置有效的用户组ID。</p>
<h2 id="process-seteuid-id"><a href="#process-seteuid-id" class="headerlink" title="process.seteuid(id)"></a>process.seteuid(id)</h2><p>process.seteuid()方法为进程设置有效的用户ID。</p>
<h2 id="process-setgid-id"><a href="#process-setgid-id" class="headerlink" title="process.setgid(id)"></a>process.setgid(id)</h2><p>process.setgid() 为进程方法设置组ID。</p>
<h2 id="process-setgroups-groups"><a href="#process-setgroups-groups" class="headerlink" title="process.setgroups(groups)"></a>process.setgroups(groups)</h2><h2 id="process-setuid-id"><a href="#process-setuid-id" class="headerlink" title="process.setuid(id)"></a>process.setuid(id)</h2><p>设置进程的用户ID。</p>
<h2 id="process-stderr"><a href="#process-stderr" class="headerlink" title="process.stderr"></a>process.stderr</h2><p>返回连接到stderr(fd 2)的流。</p>
<h2 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a>process.stdin</h2><p>返回连接到 stdin (fd 0)的流。</p>
<h2 id="process-stdout"><a href="#process-stdout" class="headerlink" title="process.stdout"></a>process.stdout</h2><p>返回连接到 stdout (fd 1)的流。</p>
<h2 id="process-throwDeprecation"><a href="#process-throwDeprecation" class="headerlink" title="process.throwDeprecation"></a>process.throwDeprecation</h2><h2 id="process-title"><a href="#process-title" class="headerlink" title="process.title"></a>process.title</h2><p>用于获取或设置当前进程在 ps 命令中显示的进程名字。</p>
<h2 id="process-traceDeprecation"><a href="#process-traceDeprecation" class="headerlink" title="process.traceDeprecation"></a>process.traceDeprecation</h2><h2 id="process-umask-mask"><a href="#process-umask-mask" class="headerlink" title="process.umask([mask])"></a>process.umask([mask])</h2><p>用于返回或设置Node.js进程的默认创建文件的权限掩码。</p>
<h2 id="process-uptime"><a href="#process-uptime" class="headerlink" title="process.uptime()"></a>process.uptime()</h2><p>返回当前 Node.js 进程运行时间秒长。</p>
<h2 id="process-version"><a href="#process-version" class="headerlink" title="process.version"></a>process.version</h2><p>返回Node.js的版本信息。</p>
<h2 id="process-versions"><a href="#process-versions" class="headerlink" title="process.versions"></a>process.versions</h2><p>返回一个对象，此对象列出了Node.js和其依赖的版本信息。</p>
<h1 id="path（路径）"><a href="#path（路径）" class="headerlink" title="path（路径）"></a>path（路径）</h1><p>path 模块提供了一些工具函数，用于处理文件与目录的路径。<br>path 模块的默认操作会根据 Node.js 应用程序运行的操作系统的不同而变化（Windows与POSIX）。<br>要想在任何操作系统上处理 Windows 文件路径时获得一致的结果，可以使用 path.win32，如path.win32.basename(‘C:\temp\myfile.html’);<br>要想在任何操作系统上处理 POSIX 文件路径时获得一致的结果，可以使用 path.posix，如path.posix.basename(‘/tmp/myfile.html’);</p>
<h2 id="path-basename-path-ext"><a href="#path-basename-path-ext" class="headerlink" title="path.basename(path[, ext])"></a>path.basename(path[, ext])</h2><p>返回一个 path 的最后一部分，类似于 Unix 中的 basename 命令。</p>
<h2 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h2><p>提供平台特定的路径分隔符：Windows 上是 ;POSIX 上是 :</p>
<h2 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h2><p>返回一个 path 的目录名，类似于 Unix 中的 dirname 命令。</p>
<h2 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h2><p>返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。</p>
<h2 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h2><p>会从一个对象返回一个路径字符串。 与 path.parse() 相反。<br>PS：<br>如果提供了 pathObject.dir，则 pathObject.root 会被忽略<br>如果提供了 pathObject.base 存在，则 pathObject.ext 和 pathObject.name 会被忽略</p>
<h2 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h2><p>返回一个对象，对象的属性表示 path 的元素。</p>
<h2 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h2><p>会判定 path 是否为一个绝对路径。</p>
<h2 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h2><p>使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。</p>
<h2 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h2><p>会规范化给定的 path，并解析 ‘..’ 和 ‘.’ 片段。</p>
<h2 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h2><p>返回从 from 到 to 的相对路径（基于当前工作目录）。</p>
<h2 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h2><p>会把一个路径或路径片段的序列解析为一个绝对路径。</p>
<h2 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h2><p>提供了平台特定的路径片段分隔符：Windows 上是 \POSIX 上是 /</p>
<h1 id="url"><a href="#url" class="headerlink" title="url"></a>url</h1><p>url 模块提供了一些实用函数，用于 URL 处理与解析。</p>
<h1 id="querystring（查询字符串）"><a href="#querystring（查询字符串）" class="headerlink" title="querystring（查询字符串）"></a>querystring（查询字符串）</h1><p>querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。</p>
<h2 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str[, sep[, eq[, options]]])"></a>querystring.parse(str[, sep[, eq[, options]]])</h2><p>该方法会把一个 URL 查询字符串 str 解析成一个键值对的集合。</p>
<h2 id="querystring-unescape-str"><a href="#querystring-unescape-str" class="headerlink" title="querystring.unescape(str)"></a>querystring.unescape(str)</h2><p>该方法是提供给 querystring.parse() 使用的，通常不直接使用。</p>
<h2 id="querystring-stringify-obj-sep-eq-options"><a href="#querystring-stringify-obj-sep-eq-options" class="headerlink" title="querystring.stringify(obj[, sep[, eq[, options]]])"></a>querystring.stringify(obj[, sep[, eq[, options]]])</h2><p>该方法通过遍历给定的 obj 对象的自身属性，生成 URL 查询字符串。</p>
<h2 id="querystring-escape-str"><a href="#querystring-escape-str" class="headerlink" title="querystring.escape(str)"></a>querystring.escape(str)</h2><p>该方法是提供给 querystring.stringify() 使用的，通常不直接使用。</p>
<h1 id="Buffer（缓冲器）"><a href="#Buffer（缓冲器）" class="headerlink" title="Buffer（缓冲器）"></a>Buffer（缓冲器）</h1><p>在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>
<h1 id="string-decoder（字符串解码器）"><a href="#string-decoder（字符串解码器）" class="headerlink" title="string_decoder（字符串解码器）"></a>string_decoder（字符串解码器）</h1><p>string_decoder 模块提供了一个 API，用于把 Buffer 对象解码成字符串，但会保留编码过的多字节 UTF-8 与 UTF-16 字符。</p>
<h1 id="child-process（子进程）"><a href="#child-process（子进程）" class="headerlink" title="child_process（子进程）"></a>child_process（子进程）</h1><p>child_process 模块提供了衍生子进程的功能，它与 popen(3) 类似，但不完全相同。 这个功能主要由 child_process.spawn() 函数提供。</p>
<h1 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster (集群)"></a>cluster (集群)</h1><p>Node.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。</p>
<h1 id="crypto-加密"><a href="#crypto-加密" class="headerlink" title="crypto (加密)"></a>crypto (加密)</h1><p>crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。</p>
<h1 id="dgram-数据报"><a href="#dgram-数据报" class="headerlink" title="dgram (数据报)"></a>dgram (数据报)</h1><p>dgram模块提供了 UDP 数据包 socket 的实现。</p>
<h1 id="net-网络"><a href="#net-网络" class="headerlink" title="net (网络)"></a>net (网络)</h1><p>net 模块提供了创建基于流的 TCP 或 IPC 服务器(net.createServer())和客户端(net.createConnection()) 的异步网络 API。</p>
<h1 id="dns-域名服务器"><a href="#dns-域名服务器" class="headerlink" title="dns (域名服务器)"></a>dns (域名服务器)</h1><p>1.使用底层操作系统工具进行域名解析，且无需进行网络通信。<br>2.连接到一个真实的 DNS 服务器进行域名解析，且始终使用网络进行 DNS 查询。</p>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p>客户端与服务端通信。<br>Node.js 中的 HTTP 接口被设计成支持协议的许多特性。 比如，大块编码的消息。 这些接口不缓冲完整的请求或响应，用户能够以流的形式处理数据。</p>
<h1 id="tls-安全传输层"><a href="#tls-安全传输层" class="headerlink" title="tls (安全传输层)"></a>tls (安全传输层)</h1><p>tls 模块是对安全传输层（TLS）及安全套接层（SSL）协议的实现，建立在OpenSSL的基础上。</p>
<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。</p>
<h1 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error (错误)"></a>Error (错误)</h1><p>所有由 Node.js 引起的 JavaScript 错误与系统错误都继承自或实例化自标准的 JavaScript <error> 类，且保证至少提供类中的属性。</error></p>
<h1 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs (文件系统)"></a>fs (文件系统)</h1><p>文件 I/O 是对标准 POSIX 函数的简单封装。 通过 require(‘fs’) 使用该模块。 所有的方法都有异步和同步的形式。</p>
<h1 id="os-操作系统"><a href="#os-操作系统" class="headerlink" title="os (操作系统)"></a>os (操作系统)</h1><p>os 模块提供了一些操作系统相关的实用方法。</p>
<h1 id="readline-逐行读取"><a href="#readline-逐行读取" class="headerlink" title="readline (逐行读取)"></a>readline (逐行读取)</h1><p>用于从可读流（如 process.stdin）读取数据，每次读取一行。</p>
<h1 id="repl-交互式解释器"><a href="#repl-交互式解释器" class="headerlink" title="repl (交互式解释器)"></a>repl (交互式解释器)</h1><p>repl 模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或嵌入到其他应用中。</p>
<h1 id="stream-流"><a href="#stream-流" class="headerlink" title="stream (流)"></a>stream (流)</h1><p>流（stream）在 Node.js 中是处理流数据的抽象接口（abstract interface）。 stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。</p>
<h1 id="tty（终端）"><a href="#tty（终端）" class="headerlink" title="tty（终端）"></a>tty（终端）</h1><h1 id="util-实用工具"><a href="#util-实用工具" class="headerlink" title="util (实用工具)"></a>util (实用工具)</h1><p>util 模块主要用于支持 Node.js 内部 API 的需求。 大部分实用工具也可用于应用程序与模块开发者。</p>
<h1 id="V8（引擎）"><a href="#V8（引擎）" class="headerlink" title="V8（引擎）"></a>V8（引擎）</h1><p>v8 模块暴露了特定于V8版本内置到 Node.js 二进制文件中的API。</p>
<h1 id="vm-虚拟机"><a href="#vm-虚拟机" class="headerlink" title="vm (虚拟机)"></a>vm (虚拟机)</h1><p>vm 模块提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码。</p>
<h1 id="Zlib（压缩）"><a href="#Zlib（压缩）" class="headerlink" title="Zlib（压缩）"></a>Zlib（压缩）</h1><p>zlib模块提供通过 Gzip 和 Deflate/Inflate 实现的压缩功能。</p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>path模块-路径</title>
    <url>/2017/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-path.html</url>
    <content><![CDATA[<h3 id="path模块-路径"><a href="#path模块-路径" class="headerlink" title="path模块-路径"></a>path模块-路径</h3><pre><code>在不同系统中，路径分隔符显示不同。POSIX 上的 / 与 Windows 上的 \
说明：path 模块提供了一些工具函数，用于处理文件与目录的路径。
</code></pre><h3 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h3><pre><code>作用：提供了平台特定的路径片段分隔符。
    windows上是 \
    POSIX上是 /
</code></pre><h3 id="path-win32-和-path-posix"><a href="#path-win32-和-path-posix" class="headerlink" title="path.win32 和 path.posix"></a>path.win32 和 path.posix</h3><pre><code>要想在任何操作系统上处理 Windows 文件路径时获得一致的结果，可以使用 path.win32
    path.win32.basename(&apos;c:\\temp\\myfile.html&apos;); // myfile.html
要想在任何操作系统上处理 POSIX 文件路径时获得一致的结果，可以使用 path.posix
    path.posix.basename(&apos;/temp/myfile.html&apos;); // myfile.html
</code></pre><h3 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h3><pre><code>作用：提供平台特定的路径分隔符。
    windows是;
    POSIX是:
    process.env.PATH; // &apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&apos;
    process.env.PATH.split(path.delimiter); // [&apos;/usr/bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin&apos;, &apos;/sbin&apos;, &apos;/usr/local/bin&apos;]
</code></pre><h3 id="path-basename-path-ext"><a href="#path-basename-path-ext" class="headerlink" title="path.basename(path[, ext]);"></a>path.basename(path[, ext]);</h3><pre><code>作用：返回一个 path 的最后一部分。
    path.basename(&apos;/foo/bar/myfile.html&apos;); // &apos;myfile.html&apos;
    patn.basename(&apos;/foo/bar/myfile.html&apos;, &apos;.html&apos;); // &apos;myfile&apos;
</code></pre><h3 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path);"></a>path.dirname(path);</h3><pre><code>作用：返回一个path的目录名。
    path.dirname(&apos;/foo/bar/myfile&apos;); // foo/bar
</code></pre><h3 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h3><pre><code>作用：返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。
    path.extname(&apos;index.coffee.md&apos;); // &apos;.md&apos;
</code></pre><h3 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject);"></a>path.format(pathObject);</h3><pre><code>作用：会从一个对象返回一个路径字符串。 与 path.parse() 相反。
参数：Object
    {
        dir: &apos;&apos;,
        root: &apos;&apos;,
        base: &apos;&apos;,
        name: &apos;&apos;,
        ext: &apos;&apos;
    }
    在windows中
    path.format({
        root: &apos;ignored&apos;,
        dir: &apos;\home\user&apos;,
        base: &apos;file.txt&apos;
    });
    // &apos;\home\user\file.txt&apos;
</code></pre><h3 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path);"></a>path.parse(path);</h3><pre><code>作用：返回一个对象，对象的属性表示 path 的元素。
    path.parse(&apos;/home/user/file.txt&apos;);
    // {
        root: &apos;/&apos;,
        base: &apos;/home/user&apos;,
        ext: &apos;.txt&apos;.
        name: &apos;file&apos;
    }
</code></pre><h3 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path);"></a>path.isAbsolute(path);</h3><pre><code>作用：会判定 path 是否为一个绝对路径。
    path.isAbsolute(&apos;bar\baz&apos;); // true
</code></pre><h3 id="path-join-…path"><a href="#path-join-…path" class="headerlink" title="path.join([…path]);"></a>path.join([…path]);</h3><pre><code>作用：使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。
    path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;); // 返回: &apos;/foo/bar/baz/asdf&apos;
</code></pre><h3 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path);"></a>path.normalize(path);</h3><pre><code>作用：规范化给定的 path，并解析 &apos;..&apos; 和 &apos;.&apos; 片段。
    path.normalize(&apos;/foo/bar/baz/asdf/quux/..&apos;); // &apos;/foo/bar/baz/asdf&apos;
</code></pre><h3 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to);"></a>path.relative(from, to);</h3><pre><code>作用：返回从 from 到 to 的相对路径（基于当前工作目录）。
    path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;);
    // &apos;../../impl/bbb&apos;
</code></pre><h3 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths]);"></a>path.resolve([…paths]);</h3><pre><code>作用：把一个路径或路径片段的序列解析为一个绝对路径。
    path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;); // &apos;/foo/bar/baz&apos;
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/path.html" target="_blank" rel="noopener">path参考-api</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>util模块-工具</title>
    <url>/2017/nodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-util.html</url>
    <content><![CDATA[<h3 id="util模块"><a href="#util模块" class="headerlink" title="util模块"></a>util模块</h3><pre><code>说明：util 模块主要用于支持 Node.js 内部 API 的需求。 大部分实用工具也可用于应用程序与模块开发者。
</code></pre><h3 id="util-callbackify-original"><a href="#util-callbackify-original" class="headerlink" title="util.callbackify(original)"></a>util.callbackify(original)</h3><h3 id="util-debuglog-section"><a href="#util-debuglog-section" class="headerlink" title="util.debuglog(section)"></a>util.debuglog(section)</h3><pre><code>作用：util.debuglog() 方法用于创建一个函数，基于 NODE_DEBUG 环境变量的存在与否有条件地写入调试信息到 stderr。
    const debuglog = util.debuglog(&apos;foo&apos;);
    debuglog(&apos;hello from foo [%d]&apos;, 123);
    若程序的环境运行是带上NODE_DEBUG=foo,则FOO 3245: hello from foo [123]
    3234是进程id
</code></pre><h3 id="util-deprecate-function-string"><a href="#util-deprecate-function-string" class="headerlink" title="util.deprecate(function, string)"></a>util.deprecate(function, string)</h3><pre><code>作用：util.deprecate() 方法会包装给定的 function 或类，并标记为废弃的。
    // 在util模块中
    exports.puts = util.deprecate(function() {
      for (let i = 0, len = arguments.length; i &lt; len; ++i) {
        process.stdout.write(arguments[i] + &apos;\n&apos;);
      }
    }, &apos;util.puts: 使用 console.log 代替&apos;);
</code></pre><h3 id="util-format-format-…args"><a href="#util-format-format-…args" class="headerlink" title="util.format(format[, …args])"></a>util.format(format[, …args])</h3><pre><code>作用：返回一个格式化后的字符串，使用第一个参数作为一个类似 printf 的格式。
对应的占位符：
    %s - 字符串
    %d - 数值
    %i - Integer
    %f - Float
    %j - JSON
    %o - Object
    %% - 单个百分号（&apos;%&apos;）。不消耗参数。
    util.format(&apos;%s:%d&apos;, &apos;fan&apos;, 100); // &apos;fan:100&apos;
</code></pre><h3 id="util-inherits-constructor-superConstructor"><a href="#util-inherits-constructor-superConstructor" class="headerlink" title="util.inherits(constructor, superConstructor)"></a>util.inherits(constructor, superConstructor)</h3><pre><code>注意，不建议使用 util.inherits()。 请使用 ES6 的 class 和 extends 关键词获得语言层面的继承支持。
作用：从一个构造函数中继承原型方法到另一个。 constructor 的原型会被设置到一个从 superConstructor 创建的新对象上。
    util.inherits(MyStream, EventEmitter);
</code></pre><h3 id="util-inspect-object-options"><a href="#util-inspect-object-options" class="headerlink" title="util.inspect(object[, options])"></a>util.inspect(object[, options])</h3><pre><code>作用：返回 object 的字符串表示，主要用于调试。 附加的 options 可用于改变格式化字符串的某些方面。
</code></pre><h3 id="自定义-util-inspect-颜色"><a href="#自定义-util-inspect-颜色" class="headerlink" title="自定义 util.inspect 颜色"></a>自定义 util.inspect 颜色</h3><pre><code>作用：可以通过 util.inspect.styles 和 util.inspect.colors 属性全局地自定义 util.inspect 的颜色输出（如果已启用）。
</code></pre><h3 id="util-inspect-custom"><a href="#util-inspect-custom" class="headerlink" title="util.inspect.custom"></a>util.inspect.custom</h3><pre><code>作用：可被用于声明自定义的查看函数。
</code></pre><h3 id="util-inspect-defaultOptions"><a href="#util-inspect-defaultOptions" class="headerlink" title="util.inspect.defaultOptions"></a>util.inspect.defaultOptions</h3><pre><code>作用：defaultOptions 值允许对被 util.inspect 使用的默认选项进行自定义。
</code></pre><h3 id="util-promisify-original"><a href="#util-promisify-original" class="headerlink" title="util.promisify(original)"></a>util.promisify(original)</h3><pre><code>作用：让一个遵循通常的让一个遵循通常的 Node.js 回调风格的函数， 即 (err, value) =&gt; ... 回调函数是最后一个参数, 返回一个返回值是一个 promise 版本的函数。    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://nodejs.cn/api/util.html" target="_blank" rel="noopener">util参考-api</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>postman</title>
    <url>/2017/postman.html</url>
    <content><![CDATA[<pre><code>虽然一直使用postman进行http相关的调试，但一直都停留在简单使用，并没有对其的深入学习。
现在比较全面的学习下post相关功能。
</code></pre><h3 id="postman仪表盘布局"><a href="#postman仪表盘布局" class="headerlink" title="postman仪表盘布局"></a>postman仪表盘布局</h3><pre><code>分为左右两栏（sidebar + main）
    siderbar：Search + History + Collections
    main：
        第一行：请求方式 + URL + Params + Send(Send and Download) + Save(Save as)
        第二行(request)：Authorization + Headers + Body + Pre-request Script(请求发送前运行的脚本) + Tests + Code(转化为相应的语言请求代码)
        第三行(response)：Body + Cookies + Headers + Tests + Status(响应状态) + Time(响应等待时间)     
</code></pre><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><pre><code>HTTP请求的4部分:URL，method，headers，body。
对于body说明：
    1.mutipart/form-data：是网页表单用来传输数据的默认格式。（提交表单上传文件）
    2.x-www-form-urlencoded：同前面一样，注意,你不能上传文件通过这个编码模式。
    3.raw：raw request可以包含任何东西。所有填写的text都会随着请求发送。
    4.binary：image, audio or video files.text files 。 也不能保存历史，每次选择文件，提交。
身份验证Authentication：
    1.Basic Auth：填写用户名和密码，点击Refresh headers
    2.Digest Auth：要比Basic Auth复杂的多。使用当前填写的值生成authorization header。
        所以在生成header之前要确保设置的正确性。
        如果当前的header已经存在，postman会移除之前的header。
    3.OAuth 1.0a：postman的OAuth helper让你签署支持OAuth 1.0基于身份验证的请求。
        OAuth不用获取access token,你需要去API提供者获取的。
        OAuth 1.0可以在header或者查询参数中设置value。
    4.OAuth 2.0：postman支持获得OAuth 2.0 token并添加到requests中。    
</code></pre><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><pre><code>对于body说明：
    1.Pretty：格式化了JSON和XML，方便查看。
    2.Raw：是text文本。
    3.Preview：返回html页面。
cookies：可以显示browser cookies，需要开启Interceptor。
</code></pre><h3 id="Writting-Test"><a href="#Writting-Test" class="headerlink" title="Writting Test"></a>Writting Test</h3><pre><code>暂不涉及！！！
Postman的Tests标签可以用来写测试
</code></pre><h3 id="运行Collections"><a href="#运行Collections" class="headerlink" title="运行Collections"></a>运行Collections</h3><pre><code>Postman测试管理的单位是测试集（Collections），测试集内可以创建文件夹(Folder)和具体的请求(Requests)。
postman允许你运行collection，你可以运行任意的次数。 
最后会给出一个整体运行的结果。
会保存每一次运行的结果，提供给你比较每一次运行结果的不同。
</code></pre><h3 id="Postman开发者模式"><a href="#Postman开发者模式" class="headerlink" title="Postman开发者模式"></a>Postman开发者模式</h3><pre><code>使用环境变量可以方便的在开发和测试环境进行切换。
1.点击环境管理按钮添加环境。
2.通常会有开发和测试两个环境，分别添加相应的环境变量。
    环境一：ev_develop
        url：127.0.0.1.8081
    环境二：ev_test
        url：10.1.1.133.8080
3.使用环境变量
    {{url}}/api/v1/currentUser.json
    No Environment选择对应的环境即可
4.查看和编辑环境变量
    下拉select和眼睛图标
</code></pre><h3 id="Postman接口测试"><a href="#Postman接口测试" class="headerlink" title="Postman接口测试"></a>Postman接口测试</h3><pre><code>1.对于同一接口的多个测试请求，可统一使用后缀命名
    在Collections中
    如测试登录的不同情况：
    login_normal
    login_bad_username
    login_bad_password
    login_miss_username
    login_miss_password
2.对于关键字搜索测试，可使用关键字作为后缀，以保持与开发关键字一致
    如测试评分资料内容列表展示
    评分资料内容列表_pageNum
    评分资料内容列表_numPerPage
    评分资料内容列表_docName
3.对于需要额外说明的测试请求，需要在描述里增加注释
    点击edit添加Description
</code></pre><h3 id="Postman接口测试进阶"><a href="#Postman接口测试进阶" class="headerlink" title="Postman接口测试进阶"></a>Postman接口测试进阶</h3><pre><code>1.全局变量的创建方式与环境变量相同    
2.使用方式也是相同的，不同的是全局变量可以在不同环境下共用    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/flowerspring/article/details/52774399" target="_blank" rel="noopener">postman 使用详解</a><br>    <a href="https://jingyan.baidu.com/article/0f5fb09907e3046d8334ea2f.html" target="_blank" rel="noopener">postmen 使用入门</a></p>
</blockquote>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda库的使用</title>
    <url>/2017/ramda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p><a href="https://github.com/fanerge/Ramda-study/blob/master/ramda/js/pointfree.js" target="_blank" rel="noopener">学习源代码地址</a></p>
<h4 id="了解Pointfree的概念"><a href="#了解Pointfree的概念" class="headerlink" title="了解Pointfree的概念"></a>了解Pointfree的概念</h4><pre><code>概念：fn = R.pipe(f1, f2, f3);
可以把数据处理的过程，定义成一种与参数无关的合成运算。
**不使用所要处理的值，只合成运算过程。**
</code></pre><h5 id="一些小例子"><a href="#一些小例子" class="headerlink" title="一些小例子"></a>一些小例子</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// pointfree例子</span><br><span class="line">var addOne = x =&gt; x + 1;</span><br><span class="line">var square = x =&gt; x * x;</span><br><span class="line">var addOneThenSquare = R.pipe(square, addOne);</span><br><span class="line">var pointfree1 = addOneThenSquare(3);</span><br><span class="line">console.log(pointfree1); // 10</span><br><span class="line">// addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。</span><br><span class="line"></span><br><span class="line">var prop = (p, obj) =&gt; obj[p]; // 封装了读取操作，它需要两个参数p（属性名）和obj（对象）。</span><br><span class="line">var propRole = R.curry(prop)(&apos;role&apos;); // 将函数柯里化</span><br><span class="line">var demo1 = propRole(&#123;role: &apos;fan&apos;&#125;);</span><br><span class="line">console.log(demo1); // fan</span><br><span class="line"></span><br><span class="line">var data = [</span><br><span class="line">  &#123;name: &apos;张三&apos;, role: &apos;worker&apos;&#125;,</span><br><span class="line">  &#123;name: &apos;李四&apos;, role: &apos;worker&apos;&#125;,</span><br><span class="line">  &#123;name: &apos;王五&apos;, role: &apos;manager&apos;&#125;,</span><br><span class="line">];</span><br><span class="line">var isWorker = r =&gt; r === &apos;worker&apos;;</span><br><span class="line">var getWorkers = R.filter(R.pipe(R.prop(&apos;role&apos;), isWorker));</span><br><span class="line">var demo2 = getWorkers(data);</span><br><span class="line">// console.log(demo2); </span><br><span class="line">// [</span><br><span class="line">//   &#123;&quot;name&quot;: &quot;张三&quot;, &quot;role&quot;: &quot;worker&quot;&#125;,</span><br><span class="line">//   &#123;&quot;name&quot;: &quot;李四&quot;, &quot;role&quot;: &quot;worker&quot;&#125;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="Pointfree示例一"><a href="#Pointfree示例一" class="headerlink" title="Pointfree示例一"></a>Pointfree示例一</h5><pre><code>**求下面字符串，请问其中最长的单词有多少个字符？**
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &apos;Lorem ipsum dolor sit amet consectetur adipiscing elit&apos;;</span><br><span class="line">// 以空格分割单词</span><br><span class="line">var splitBySpace = s =&gt; s.split(&apos; &apos;);</span><br><span class="line">// 获得每个单词的长度</span><br><span class="line">var getLength = w =&gt; w.length;</span><br><span class="line">// 单词数组转化为单词长度的数组</span><br><span class="line">var getLengArr = arr =&gt; R.map(getLength, arr);</span><br><span class="line">// 返回较大的数字</span><br><span class="line">var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;</span><br><span class="line">// 返回最大的一个数字</span><br><span class="line">var findBiggestNumber = arr =&gt; R.reduce(getBiggerNumber, 0, arr);</span><br><span class="line"></span><br><span class="line">var getLongestWordLength = R.pipe(  </span><br><span class="line">	splitBySpace,</span><br><span class="line">	getLengArr,</span><br><span class="line">	findBiggestNumber</span><br><span class="line">  );</span><br><span class="line">var demo3 = getLongestWordLength(str);</span><br><span class="line">console.log(demo3); // 11</span><br><span class="line"></span><br><span class="line">// 使用ramda库</span><br><span class="line">var getLongestWordLength = R.pipe(</span><br><span class="line">	R.split(&apos; &apos;),</span><br><span class="line">	R.map(R.length),</span><br><span class="line">	R.reduce(R.max, 0)</span><br><span class="line">  );</span><br><span class="line">var demo3 = getLongestWordLength(str);</span><br><span class="line">// console.log(demo3); // 11</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="Pointfree-示例二"><a href="#Pointfree-示例二" class="headerlink" title="Pointfree 示例二"></a>Pointfree 示例二</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 下面是一段服务器返回的 JSON 数据。</span><br><span class="line">var data = &#123;</span><br><span class="line">	result: &quot;SUCCESS&quot;,</span><br><span class="line">	interfaceVersion: &quot;1.0.3&quot;,</span><br><span class="line">	requested: &quot;10/17/2013 15:31:20&quot;,</span><br><span class="line">	lastUpdated: &quot;10/16/2013 10:52:39&quot;,</span><br><span class="line">	tasks: [</span><br><span class="line">		&#123;id: 104, complete: false,            priority: &quot;high&quot;,</span><br><span class="line">				  dueDate: &quot;2013-11-29&quot;,      username: &quot;Scott&quot;,</span><br><span class="line">				  title: &quot;Do something&quot;,      created: &quot;9/22/2013&quot;&#125;,</span><br><span class="line">		&#123;id: 105, complete: false,            priority: &quot;medium&quot;,</span><br><span class="line">				  dueDate: &quot;2013-11-22&quot;,      username: &quot;Lena&quot;,</span><br><span class="line">				  title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;&#125;,</span><br><span class="line">		&#123;id: 107, complete: true,             priority: &quot;high&quot;,</span><br><span class="line">				  dueDate: &quot;2013-11-22&quot;,      username: &quot;Mike&quot;,</span><br><span class="line">				  title: &quot;Fix the foo&quot;,       created: &quot;9/22/2013&quot;&#125;,</span><br><span class="line">		&#123;id: 108, complete: false,            priority: &quot;low&quot;,</span><br><span class="line">				  dueDate: &quot;2013-11-15&quot;,      username: &quot;Punam&quot;,</span><br><span class="line">				  title: &quot;Adjust the bar&quot;,    created: &quot;9/25/2013&quot;&#125;,</span><br><span class="line">		&#123;id: 110, complete: false,            priority: &quot;medium&quot;,</span><br><span class="line">				  dueDate: &quot;2013-11-15&quot;,      username: &quot;Scott&quot;,</span><br><span class="line">				  title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;&#125;,</span><br><span class="line">		&#123;id: 112, complete: true,             priority: &quot;high&quot;,</span><br><span class="line">				  dueDate: &quot;2013-11-27&quot;,      username: &quot;Lena&quot;,</span><br><span class="line">				  title: &quot;Alter all quuxes&quot;,  created: &quot;10/5/2013&quot;&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fetchData = function (data) &#123;</span><br><span class="line">  return Promise.resolve(data);</span><br><span class="line">&#125;;</span><br><span class="line">// 提取 tasks 属性</span><br><span class="line">var SelectTasks = R.prop(&apos;tasks&apos;);</span><br><span class="line"></span><br><span class="line">// 过滤出指定的用户</span><br><span class="line">var filterMember = member =&gt; R.filter(</span><br><span class="line">  R.propEq(&apos;username&apos;, member)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">// 排除已经完成的任务</span><br><span class="line">var excludeCompletedTasks = R.reject(R.propEq(&apos;complete&apos;, true));</span><br><span class="line"></span><br><span class="line">// 选取指定属性</span><br><span class="line">var selectFields = R.map(</span><br><span class="line">	R.pick([&apos;id&apos;, &apos;dueDate&apos;, &apos;title&apos;, &apos;priority&apos;])</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">// 按照到期日期排序</span><br><span class="line">var sortByDueDate = R.sortBy(R.prop(&apos;dueDate&apos;));</span><br><span class="line"></span><br><span class="line">// 合成函数</span><br><span class="line">var getIncompleteTaskSummaries = function (membername) &#123;</span><br><span class="line">  return fetchData(data)</span><br><span class="line">  .then(R.prop(&apos;tasks&apos;))</span><br><span class="line">  .then(R.filter(R.propEq(&apos;username&apos;, membername)))</span><br><span class="line">  .then(R.reject(R.propEq(&apos;complete&apos;, true)))</span><br><span class="line">  .then(R.map(R.pick([&apos;id&apos;, &apos;dueData&apos;, &apos;title&apos;, &apos;priority&apos;])))</span><br><span class="line">  .then(R.sortBy(R.prop(&apos;dueData&apos;)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var scottList = getIncompleteTaskSummaries(&apos;Scott&apos;);</span><br><span class="line">console.log(scottList);	</span><br><span class="line">[[object Object] &#123;</span><br><span class="line">  dueDate: &quot;2013-11-15&quot;,</span><br><span class="line">  id: 110,</span><br><span class="line">  priority: &quot;medium&quot;,</span><br><span class="line">  title: &quot;Rename everything&quot;</span><br><span class="line">&#125;, [object Object] &#123;</span><br><span class="line">  dueDate: &quot;2013-11-29&quot;,</span><br><span class="line">  id: 104,</span><br><span class="line">  priority: &quot;high&quot;,</span><br><span class="line">  title: &quot;Do something&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">阮老师–Pointfree 编程风格指南</a><br><a href="http://ramda.cn/" target="_blank" rel="noopener">Ramda 中文</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda无参数风格编程 (Pointfree Style)和声明式编程</title>
    <url>/2017/ramda%E8%BF%90%E7%94%A8-1.html</url>
    <content><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="部分应用（Partial-Application）"><a href="#部分应用（Partial-Application）" class="headerlink" title="部分应用（Partial Application）"></a>部分应用（Partial Application）</h4><pre><code>在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？
例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var books = [</span><br><span class="line">  &#123;year: 1991, title: &apos;11111&apos;&#125;,</span><br><span class="line">  &#123;year: 1991, title: &apos;22222&apos;&#125;,</span><br><span class="line">  &#123;year: 1992, title: &apos;33333&apos;&#125;</span><br><span class="line">];</span><br><span class="line">const publishedInYear = (book, year) =&gt; book.year === year;</span><br><span class="line">const titlesForYear = (books, year) =&gt; &#123;</span><br><span class="line">  const selected = R.filter(book =&gt; publishedInYear(book, year), books);</span><br><span class="line">  return R.map(book =&gt; book.title, selected);</span><br><span class="line">&#125;;</span><br><span class="line">var book1 = titlesForYear(books, 1991); // [&apos;11111&apos;, &apos;22222&apos;]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><pre><code>获取或返回其他函数的函数称为 &quot;高阶函数&quot;。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 高阶函数</span><br><span class="line">var publishedInYear = function (year) &#123;</span><br><span class="line">  return function (book) &#123;</span><br><span class="line">	return book.year === year;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">// 箭头函数</span><br><span class="line">// var publishedInYear = year =&gt; book =&gt; book.year === year;</span><br><span class="line">var titlesForYear = (books, year) =&gt; &#123;</span><br><span class="line">  const selected = R.filter(publishedInYear(year), books);</span><br><span class="line">  return R.map(book =&gt; book.title, selected);</span><br><span class="line">&#125;; </span><br><span class="line">console.log(titlesForYear(books, 1992)); // &apos;33333&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h5><pre><code>partial/partialRight（部分应用）
定义：这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例子，只是想检查一本书是否是在指定年份出版的。</span><br><span class="line">var publishedInYear = (book, year) =&gt; book.year === year;</span><br><span class="line">var titleForYear = (books, year) =&gt; &#123;</span><br><span class="line">  const selected = R.filter(R.partialRight(publishedInYear, [year]), books);</span><br><span class="line">  return R.map(book =&gt; book.title, selected);</span><br><span class="line">&#125;;</span><br><span class="line">// console.log(titleForYear(books, 1992)); // [&apos;33333&apos;]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h5><pre><code>定义：一个柯里化了的函数是一系列高阶一元函数，将多参数函数转化为单参数函数。
一般来说，我只有需要在多个地方对同一个函数使用 partial 的时候，才会对函数进行柯里化。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var publishedInYear = R.curry((year, book) =&gt; book.year === year);</span><br><span class="line">var titlesForYear = (books, year) =&gt; &#123;</span><br><span class="line">  const selected = R.filter(publishedInYear(year), books);</span><br><span class="line">  return R.map(book =&gt; book.title, selected);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(titlesForYear(books, 1992)); // [&apos;33333&apos;]</span><br><span class="line">var book2 = publishedInYear(1992, &#123;year: 1992, title: &apos;33333&apos;&#125;); // true</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="顺序错误的参数"><a href="#顺序错误的参数" class="headerlink" title="顺序错误的参数"></a>顺序错误的参数</h5><pre><code>filp：交换函数前两个参数的位置。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);</span><br><span class="line">console.log(R.flip(mergeThree)(1, 2, 3)); // [2, 1, 3]</span><br></pre></td></tr></table></figure>

__或placeholder (占位符)
定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。
更通用的选择是使用 &quot;placeholder&quot; 参数（__）
假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const threeArgs = curry((a, b, c) =&gt; &#123; /* ... */ &#125;);</span><br><span class="line">const middleArgumentLater = threeArgs(&apos;value for a&apos;, R.__, &apos;value for c&apos;);</span><br><span class="line"></span><br><span class="line">var publishedInYear = R.curry((year, book) =&gt; book.year === year)</span><br><span class="line">var titlesForYear = R.curry((year, books) =&gt;</span><br><span class="line">  R.pipe(</span><br><span class="line">	R.filter(publishedInYear(year)),</span><br><span class="line">	R.map(book =&gt; book.title)</span><br><span class="line">  )(books)</span><br><span class="line">)</span><br><span class="line">// console.log(titlesForYear(1991, books)); // [&quot;11111&quot;, &quot;22222&quot;]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><h5 id="命令式-vs-声明式"><a href="#命令式-vs-声明式" class="headerlink" title="命令式 vs 声明式"></a>命令式 vs 声明式</h5><pre><code>命令式编程中，程序员需要告诉计算机怎么做来完成任务。
声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var square = x =&gt; R.multiply(x, x);</span><br><span class="line">var operate = R.pipe(</span><br><span class="line">  R.multiply,</span><br><span class="line">  R.add(1),</span><br><span class="line">  square</span><br><span class="line">  );</span><br><span class="line">var operate3 = operate(3, 4); // 169</span><br><span class="line">// add(1) 与增量运算符（++）非常相似，但 ++ 修改了被操作的值，因此它是 &quot;mutation&quot; 的。</span><br><span class="line">// 所以使用R.add(1),R.subtract(1)代替++ 和 --</span><br><span class="line">// Ramda提供了R.inc和R.dec</span><br><span class="line">R.dec(42); //=&gt; 41</span><br><span class="line">R.negate(42); //=&gt; -42 取反</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="比较-Comparison"><a href="#比较-Comparison" class="headerlink" title="比较(Comparison)"></a>比较(Comparison)</h5><pre><code>使用R.gt()、R.gte()、R.lt()、R.lte()、R.equals()代替&gt;、&gt;=、&lt;、&lt;=、===
identical：如果两个参数是完全相同，则返回 true，否则返回 false。如果它们引用相同的内存，也认为是完全相同的。
isEmpty：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。
isNil：检测输入值是否为 null 或 undefined 。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 改写投票的例子</span><br><span class="line">var wasBornInCountry = person =&gt; R.equals(person.birthCountry, &apos;CHINA&apos;);</span><br><span class="line">var wasNaturalized = person =&gt; Boolean(person.naturalizationDate);</span><br><span class="line">var isOver18 = person =&gt; R.gte(person.age, 18);</span><br><span class="line">var isCitizen = R.either(wasBornInCountry, wasBornInCountry);</span><br><span class="line">var isEligibleToVote = R.both(isOver18, isCitizen);</span><br><span class="line">console.log(isEligibleToVote(&#123;</span><br><span class="line">  birthCountry: &apos;CHINA&apos;, </span><br><span class="line">  naturalizationDate: false,</span><br><span class="line">  age: 22</span><br><span class="line">&#125;)); // true</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="逻辑-Logic"><a href="#逻辑-Logic" class="headerlink" title="逻辑(Logic)"></a>逻辑(Logic)</h5><pre><code>both 和 either 来代替 &amp;&amp; 和 || 运算符。使用 complement 代替 !。
我以下列方式进行分类：and、or 和 not 用于处理数值；both、either 和 complement 用于处理函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var setting = &#123;&#125;;</span><br><span class="line">var lineWith = setting.lineWith || 80;</span><br><span class="line">var lineWith = R.defaultTo(80, setting.lineWith);</span><br><span class="line">console.log(lineWith); //使用后者代替前者</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="条件-Conditionals"><a href="#条件-Conditionals" class="headerlink" title="条件(Conditionals)"></a>条件(Conditionals)</h5><pre><code>R.ifElse 代替 if-else
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var forever21 = age =&gt; age &gt;= 21 ? 21 : age + 1</span><br><span class="line">// console.log(forever21(19)); // 20</span><br><span class="line">var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), () =&gt; 21, R.inc)(age)</span><br><span class="line">// console.log(forever21(19)); // 20</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="constants-常量"><a href="#constants-常量" class="headerlink" title="constants (常量)"></a>constants (常量)</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R.always(42) 代替 42</span><br><span class="line">R.T() === true 忽略所有参数</span><br><span class="line">console.log(R.T(false)); // true</span><br><span class="line">R.F() === false 忽略所有参数</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="identity-恒等"><a href="#identity-恒等" class="headerlink" title="identity (恒等)"></a>identity (恒等)</h5><pre><code>输出恒等于输入。如，a =&gt; a
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">identity：将输入值原样返回。适合用作默认或占位函数。</span><br><span class="line">nthArg；返回一个函数，该函数返回它的第 n 个参数。</span><br><span class="line">const alwaysDrivingAge = age =&gt; ifElse(lt(__, 16), always(16), a =&gt; a)(age)</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="when-和-unless"><a href="#when-和-unless" class="headerlink" title="when 和 unless"></a>when 和 unless</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var alwaysDrivingAge = age =&gt; R.unless(R.gte(R.__, 16), R.always(16))(age)</span><br><span class="line">console.log(alwaysDrivingAge(15)); // 16</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><pre><code>作用：来代替 switch 语句或链式的 if...then...else 语句
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const water = temperature =&gt; R.cond([</span><br><span class="line">  [R.equals(0),   R.always(&apos;water freezes at 0°C&apos;)],</span><br><span class="line">  [R.equals(100), R.always(&apos;water boils at 100°C&apos;)],</span><br><span class="line">  [R.T,           temp =&gt; `nothing special happens at $&#123;temp&#125;°C`]</span><br><span class="line">])(temperature)</span><br><span class="line">console.log(water(23)); // nothing special happens at 23°C</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：高阶函数、部分应用函数、柯里化（Curry）、改变参数顺序的方法（flip、plachhokder__、pipeline）
常用的声明式编程替换命令式编程：add、subtract、multiply、divide等等
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="noopener">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="noopener">Thinking in Ramda系列文章</a></p>
</blockquote>
<blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="noopener">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="noopener">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda无参数风格和对象的相关操作</title>
    <url>/2017/ramda%E8%BF%90%E7%94%A8-2.html</url>
    <content><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="Pointfree-风格（无参数风格）"><a href="#Pointfree-风格（无参数风格）" class="headerlink" title="Pointfree 风格（无参数风格）"></a>Pointfree 风格（无参数风格）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), R.always(21), R.inc)(age);</span><br><span class="line">// console.log(forever21(23)); // 21</span><br><span class="line"></span><br><span class="line">// pointfree风格的</span><br><span class="line">var forever21 = R.ifElse(R.gte(R.__, 21), R.always(21), R.inc);</span><br><span class="line">// console.log(forever21(21));</span><br><span class="line">// 我们刚刚让 age 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 age 参数。</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="多元函数（多参数函数）"><a href="#多元函数（多参数函数）" class="headerlink" title="多元函数（多参数函数）"></a>多元函数（多参数函数）</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var titlesForYear = R.curry((year, books) =&gt; &#123;</span><br><span class="line">  R.pipe(</span><br><span class="line">	R.filter(publishedInYear(year)),</span><br><span class="line">	R.map(book =&gt; book.title)    </span><br><span class="line">  )(books);</span><br><span class="line">&#125;);</span><br><span class="line">// console.log(titlesForYear(2012)(books));</span><br><span class="line"></span><br><span class="line">var titlesForYear = year =&gt; &#123;</span><br><span class="line">  R.pipe(</span><br><span class="line">	R.filter(publishedInYear(year)),</span><br><span class="line">	R.map(book =&gt; book.title)</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line">console.log(titlesForYear(2012));</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="重构为-pointfree-风格的代码"><a href="#重构为-pointfree-风格的代码" class="headerlink" title="重构为 pointfree 风格的代码"></a>重构为 pointfree 风格的代码</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 改写18岁投票系统</span><br><span class="line">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY</span><br><span class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</span><br><span class="line">const isOver18 = person =&gt; person.age &gt;= 18</span><br><span class="line">const isCitizen = person =&gt; wasBornInCountry(person) || wasNaturalized(person)</span><br><span class="line">const isEligibleToVote = person =&gt; isOver18(person) &amp;&amp; isCitizen(person)</span><br><span class="line"></span><br><span class="line">const isEligibleToVote = person =&gt; both(isOver18, isCitizen)(person)</span><br><span class="line">const isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line">const isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="读取对象属性"><a href="#读取对象属性" class="headerlink" title="读取对象属性"></a>读取对象属性</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY</span><br><span class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</span><br><span class="line">const isOver18 = person =&gt; person.age &gt;= 18</span><br><span class="line">const isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line">const isEligibleToVote = both(isOver18, isCitizen)</span><br><span class="line"></span><br><span class="line">// 改写为</span><br><span class="line">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY)</span><br><span class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)</span><br><span class="line">const isOver18 = person =&gt; gte(person.age, 18)</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h5><pre><code>定义：取出对象中指定属性的值。如果不存在，则返回 undefined。
R.prop(&apos;x&apos;, {x: 100}); //=&gt; 100
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var wasBornInCountry = R.compose(R.equals(&apos;CHINA&apos;), R.prop(&apos;birthCountry&apos;))</span><br><span class="line">var wasNaturalized = R.compose(Boolean, R.prop(&apos;naturalizationDate&apos;))</span><br><span class="line">var isOver18 = R.compose(R.gte(R.__, 18), R.prop(&apos;age&apos;))</span><br><span class="line">console.log(R.both(wasBornInCountry, isOver18)(person1)); // true</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。
R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {a: 1, d: 4}
</code></pre><h5 id="has-hasIn"><a href="#has-hasIn" class="headerlink" title="has/hasIn"></a>has/hasIn</h5><pre><code>has定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。
R.has(&apos;name&apos;)({name: &apos;alice&apos;});
hasIn定义：如果对象自身或其原型链上含有指定的属性，则返回 true；否则返回 false。
</code></pre><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><pre><code>定义：取出给定路径上的值。
R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); //=&gt; 2
</code></pre><h5 id="propOr-pathOr"><a href="#propOr-pathOr" class="headerlink" title="propOr / pathOr"></a>propOr / pathOr</h5><pre><code>propOr定义：propOr 和 pathOr 像是 prop/path 与 defaultTo 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值
propOr(&apos;&lt;Unnamed&gt;&apos;, &apos;name&apos;, person);
</code></pre><h5 id="keys-values"><a href="#keys-values" class="headerlink" title="keys / values"></a>keys / values</h5><pre><code>keys 返回一个包含对象中所有属性名称的数组，values 返回这些属性的值组成的数组。
</code></pre><h5 id="对属性增、删、改、查"><a href="#对属性增、删、改、查" class="headerlink" title="对属性增、删、改、查"></a>对属性增、删、改、查</h5><pre><code>···    
assoc/assocPath
assoc：浅复制对象，然后设置或覆盖对象的指定属性。
R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); //=&gt; {a: 1, b: 2, c: 3}
assocPath：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。
R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); //=&gt; {a: {b: {c: 42}}}

dissoc/dissocPath/omit
dissoc：删除对象中指定 prop 属性。
R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); //=&gt; {a: 1, c: 3}
dissocPath：浅复制对象，删除返回对象中指定路径上的属性。
R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); //=&gt; {a: {b: {}}}
omit：删除对象中给定的 keys 对应的属性。
R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">####	属性转换</span><br><span class="line">	evolve：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。</span><br></pre></td></tr></table></figure>

var tomato  = {firstName: &apos;  Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123};
var transformations = {
  firstName: R.trim,
  lastName: R.trim, // Will not get invoked.
  data: {elapsed: R.add(1), remaining: R.add(-1)}
};
R.evolve(transformations, tomato); //=&gt; {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">####	合并对象</span><br><span class="line">	merge：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。</span><br></pre></td></tr></table></figure>

R.merge({ &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10 }, { &apos;age&apos;: 40 });
//=&gt; { &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 40 }
// 定义一个反转合并的函数(用前面的同名属性覆盖后面的同名属性)
 reverseMerge：const reverseMerge = R.flip(merge)
```
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：pointfree(无参数风格编程) 
对象属性：读取(prop、pick、has、path、propOr、pathOr、keys、values、)
增删改查(assoc、assocPath、dissoc、dissocPath、omit)
属性转换(evolve)
合并对象(merge)
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="noopener">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="noopener">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda运用概述</title>
    <url>/2017/ramda%E8%BF%90%E7%94%A8-4.html</url>
    <content><![CDATA[<p>继续函数式编程的学习。</p>
<p>它提供了一系列以函数式、声明式和数据不变性方式工作的函数。<br>在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：</p>
<ol>
<li>数据最后：几乎所有的函数都将数据参数作为最后一个参数。</li>
<li>柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</li>
</ol>
<h4 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h4><p>入门：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：map、filter 和 reduce 等。<br>函数组合：演示了可以使用工具（如 both、either、pipe 和 compose）以多种方式组合函数。<br>部分应用(Partial Application)：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 partial 和 curry 可以实现部分应用。我们还学习了 flip 和占位符（__）。<br>声明式编程：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。<br>无参数风格编程(Pointfree Style)：介绍了 pointfree 风格的思想，也被称为 “tatic” 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。<br>数据不变性和对象：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。<br>数据不变性和数组：继续上一节的主题，展示了数据不变性在数组中的应用。<br>透镜(Lenses)：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 view、set 和 over 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。</p>
<blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="noopener">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="noopener">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>sql函数学习</title>
    <url>/2017/sql%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h3 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h3><pre><code>SQL 拥有很多可用于计数和计算的内建函数。
</code></pre><h4 id="SQL-Aggregate-函数"><a href="#SQL-Aggregate-函数" class="headerlink" title="SQL Aggregate 函数"></a>SQL Aggregate 函数</h4><pre><code>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。
AVG() - 返回平均值
COUNT() - 返回行数
FIRST() - 返回第一个记录的值
LAST() - 返回最后一个记录的值
MAX() - 返回最大值
MIN() - 返回最小值
SUM() - 返回总和
</code></pre><h4 id="SQL-Scalar-函数"><a href="#SQL-Scalar-函数" class="headerlink" title="SQL Scalar 函数"></a>SQL Scalar 函数</h4><pre><code>SQL Scalar 函数基于输入值，返回一个单一的值。
UCASE() - 将某个字段转换为大写
LCASE() - 将某个字段转换为小写
MID() - 从某个文本字段提取字符，MySql 中使用
SubString(字段，1，end) - 从某个文本字段提取字符
LEN() - 返回某个文本字段的长度
ROUND() - 对某个数值字段进行指定小数位数的四舍五入
NOW() - 返回当前的系统日期和时间
FORMAT() - 格式化某个字段的显示方式
</code></pre><h4 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h4><pre><code>一下实例中均使用数据库sql，表名为access_log
AVG() 函数返回数值列的平均值。
语法：SELECT AVG(column_name) FROM table_name;
1.返回count的平均值
    SELECT AVG(count) FROM access_log
2.返回大于count平均数的元组
    SELECT site_id, count FROM access_log
    WHERE count &gt; (SELECT AVG(count) FROM access_log);
</code></pre><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h4><pre><code>COUNT() 函数返回匹配指定条件的行数（NULL 不计入）。
语法：SELECT COUNT(column_name) FROM table_name; // COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）
    SELECT COUNT(DISTINCT column_name) FROM table_name; // COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目
1.返回表中记录数
    SELECT COUNT(*) FROM access_log
2.返回site_id = 3的记录拥有count的数量，并改名为nums
    SELECT COUNT(count) AS nums FROM access_log WHERE site_id = 3
3.计算 &quot;access_log&quot; 表中不同 site_id 的记录数
    SELECT COUNT(DISTINCT site_id) AS nums FROM access_log
</code></pre><h4 id="SQL-FIRST-函数"><a href="#SQL-FIRST-函数" class="headerlink" title="SQL FIRST() 函数"></a>SQL FIRST() 函数</h4><pre><code>FIRST() 函数返回指定的列中第一个记录的值。
注释：只有 MS Access 支持 FIRST() 函数。
语法：SELECT FIRST(column_name) FROM table_name;
MySQL 语法：
    SELECT column_name FROM table_name
    ORDER BY column_name ASC
    LIMIT 1;
1.mysql中获取第一条记录
    SELECT count FROM access_log ORDER BY count ASC LIMIT 1;
</code></pre><h4 id="SQL-LAST-函数"><a href="#SQL-LAST-函数" class="headerlink" title="SQL LAST() 函数"></a>SQL LAST() 函数</h4><pre><code>LAST() 函数返回指定的列中最后一个记录的值。
注释：只有 MS Access 支持 LAST() 函数。
语法：SELECT LAST(column_name) FROM table_name;
MySQL 语法：
    SELECT * FROM table_name 
    ORDER BY column_name ASC
    LIMIT 1;
1.mysql中获取最后一条记录
SELECT * FROM access_log ORDER BY count DESC LIMIT 1;
</code></pre><h4 id="SQL-MAX-函数"><a href="#SQL-MAX-函数" class="headerlink" title="SQL MAX() 函数"></a>SQL MAX() 函数</h4><pre><code>MAX() 函数返回指定列的最大值。
语法：SELECT MAX(column_name) FROM table_name;
1.返回count最大的一条记录
    SELECT * FROM access_log WHERE count = (SELECT MAX(count) FROM access_log)
</code></pre><h4 id="SQL-MIN-函数"><a href="#SQL-MIN-函数" class="headerlink" title="SQL MIN() 函数"></a>SQL MIN() 函数</h4><pre><code>MIN() 函数返回指定列的最小值。
语法：SELECT column_name FROM table_name;
1.返回count最小的一条记录中的aid 和 count字段
    SELECT aid, count FROM access_log WHERE count = (SELECT MIN(count) FROM access_log)
</code></pre><h4 id="SQL-SUM-函数"><a href="#SQL-SUM-函数" class="headerlink" title="SQL SUM() 函数"></a>SQL SUM() 函数</h4><pre><code>SUM() 函数返回数值列的总数。
语法：SELECT column_name FROM table_name;
1.返回count 的总和
    SELECT SUM(count) FROM access_log    
</code></pre><h4 id="SQL-GROUP-BY-语句"><a href="#SQL-GROUP-BY-语句" class="headerlink" title="SQL GROUP BY 语句"></a>SQL GROUP BY 语句</h4><pre><code>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。
语法：
    SELECT column_name, aggregate_function(column_name)
    FROM table_name
    WHERE column_name operator value
    GROUP BY column_name;
1.返回通过site_id分组对count求和
    SELECT site_id, SUM(access_log.count) AS nums 
    FROM access_log GROUP BY site_id
2.统计所有网站的访问的记录数（LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。）
SELECT websites.name, COUNT(access_log.aid) AS nums 
FROM access_log LEFT JOIN websites ON access_log.site_id = websites.id 
GROUP BY websites.name
</code></pre><h4 id="SQL-HAVING-子句"><a href="#SQL-HAVING-子句" class="headerlink" title="SQL HAVING 子句"></a>SQL HAVING 子句</h4><pre><code>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。
HAVING 子句可以让我们筛选分组后的各组数据。
1.现在我们想要查找总访问量大于 200 的网站
SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log
INNER JOIN Websites
ON access_log.site_id=Websites.id)
GROUP BY Websites.name
HAVING SUM(access_log.count) &gt; 200;
</code></pre><h4 id="SQL-UCASE-函数"><a href="#SQL-UCASE-函数" class="headerlink" title="SQL UCASE() 函数"></a>SQL UCASE() 函数</h4><pre><code>UCASE() 函数把字段的值转换为大写。
语法：SELECT UCASE(column_name) FROM table_name;
1.将某个列转化为大写
    SELECT UCASE(websites.url) AS url3 FROM websites
</code></pre><h4 id="SQL-LCASE-函数"><a href="#SQL-LCASE-函数" class="headerlink" title="SQL LCASE() 函数"></a>SQL LCASE() 函数</h4><pre><code>LCASE() 函数把字段的值转换为大写。
语法：SELECT LCASE(column_name) FROM table_name;
1.将某个列转化为小写
    SELECT LCASE(country) FROM websites
</code></pre><h4 id="SQL-MID-函数"><a href="#SQL-MID-函数" class="headerlink" title="SQL MID() 函数"></a>SQL MID() 函数</h4><pre><code>MID() 函数用于从文本字段中提取字符。
语法：SELECT MID(column_name, start [,length]) FROM table_name;
1.获取网站地址
    SELECT MID(websites.url, 4) FROM websites
</code></pre><h4 id="SQL-LEN-函数"><a href="#SQL-LEN-函数" class="headerlink" title="SQL LEN() 函数"></a>SQL LEN() 函数</h4><pre><code>LEN() 函数返回文本字段中值的长度。
语法：SELECT LEN(column_name) FROM table_name;
MySQL中函数为 LENGTH()
    SELECT LENGTH(column_name) FROM table_name;
1.获取网址长度
    SELECT LENGTH(websites.url) FROM websites;
</code></pre><h4 id="SQL-ROUND-函数"><a href="#SQL-ROUND-函数" class="headerlink" title="SQL ROUND() 函数"></a>SQL ROUND() 函数</h4><pre><code>ROUND() 函数用于把数值字段舍入为指定的小数位数。
语法：SELECT ROUND(column_name, decimals) FROM table_name;
1.对url四舍五入处理
    SELECT ROUND(url) FROM websites WHERE id=7;
</code></pre><h4 id="SQL-NOW-函数"><a href="#SQL-NOW-函数" class="headerlink" title="SQL NOW() 函数"></a>SQL NOW() 函数</h4><pre><code>NOW() 函数返回当前系统的日期和时间。
语法：SELECT NOW() FROM websites
</code></pre><h4 id="SQL-FORMAT-函数"><a href="#SQL-FORMAT-函数" class="headerlink" title="SQL FORMAT() 函数"></a>SQL FORMAT() 函数</h4><pre><code>FORMAT() 函数用于对字段的显示进行格式化。
语法：SELECT FORMAT(column_name, format) FROM table_name;
1.格式化日期
    SELECT name, url, DATE_FORMAT(Now(), &apos;%Y-%m-%d&apos;) AS date FROM websites
</code></pre><h4 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h4><pre><code>[SQL参考手册](http://www.runoob.com/sql/sql-quickref.html)
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/sql/sql-hosting.html" target="_blank" rel="noopener">SQL</a></p>
</blockquote>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda数组的操作和透镜</title>
    <url>/2017/ramda%E8%BF%90%E7%94%A8-3.html</url>
    <content><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="数据不变性和数组"><a href="#数据不变性和数组" class="headerlink" title="数据不变性和数组"></a>数据不变性和数组</h4><h5 id="读取数组元素"><a href="#读取数组元素" class="headerlink" title="读取数组元素"></a>读取数组元素</h5><pre><code>nth -- 类型于对象prop
slice -- 类似于对象pick
contains -- 类似于对象的has
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const numbers = [10, 20, 30, 40, 50, 60]</span><br><span class="line">R.nth(3, numbers) // =&gt; 40  (0-based indexing)</span><br><span class="line">R.nth(-2, numbers) // =&gt; 50 (negative numbers start from the right)</span><br><span class="line">R.slice(2, 5, numbers) // =&gt; [30, 40, 50] (see below)</span><br><span class="line">R.contains(20, numbers) // =&gt; true</span><br></pre></td></tr></table></figure>

nth(0) === head
nth(length-1) === last
tail -- 访问除首个元素之外的所有元素的函数
init -- 除最后一个元素之外的所有元素的方法
take(N) -- 前 N 个元素
takeLast(N) -- 后 N 个元素
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const numbers = [10, 20, 30, 40, 50, 60]</span><br><span class="line">R.head(numbers) // =&gt; 10</span><br><span class="line">R.tail(numbers) // =&gt; [20, 30, 40, 50, 60]</span><br><span class="line">R.last(numbers) // =&gt; 60</span><br><span class="line">R.init(numbers) // =&gt; [10, 20, 30, 40, 50]</span><br><span class="line">R.take(3, numbers) // =&gt; [10, 20, 30]</span><br><span class="line">R.takeLast(3, numbers) // =&gt; [40, 50, 60]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="增、删、改数组元素"><a href="#增、删、改数组元素" class="headerlink" title="增、删、改数组元素"></a>增、删、改数组元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert：将元素插入到 list 指定索引处。</span><br><span class="line">R.insert(2, &apos;x&apos;, [1,2,3,4]); //=&gt; [1,2,&apos;x&apos;,3,4]</span><br><span class="line">update：替换数组中指定索引处的值。</span><br><span class="line">R.update(1, 11, [0, 1, 2]);     //=&gt; [0, 11, 2]</span><br><span class="line">append：在列表末尾拼接一个元素。</span><br><span class="line">R.append(&apos;tests&apos;, [&apos;write&apos;, &apos;more&apos;]); //=&gt; [&apos;write&apos;, &apos;more&apos;, &apos;tests&apos;]</span><br><span class="line">prepend：在列表头部之前拼接一个元素。</span><br><span class="line">R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); //=&gt; [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]</span><br><span class="line">concat：连接列表或字符串。</span><br><span class="line">R.concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]</span><br><span class="line">// 反转数组拼接</span><br><span class="line">const concatAfter = R.flip(R.concat)</span><br><span class="line">remove：删除列表中从 start 开始的 count 个元素。</span><br><span class="line">R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=&gt; [1,2,6,7,8]</span><br><span class="line">without：求第二个列表中，未包含在第一个列表中的任一元素的集合。</span><br><span class="line">R.without([1, 2], [1, 2, 1, 3, 4]); //=&gt; [3, 4]</span><br><span class="line">drop：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。</span><br><span class="line">R.drop(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;bar&apos;, &apos;baz&apos;]</span><br><span class="line">dropLast：删除 &quot;list&quot; 末尾的 n 个元素。</span><br><span class="line">R.dropLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;, &apos;bar&apos;]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="变换元素"><a href="#变换元素" class="headerlink" title="变换元素"></a>变换元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adjust：将数组中指定索引处的值替换为经函数变换的值。</span><br><span class="line">R.adjust(R.add(10), 1, [1, 2, 3]);     //=&gt; [1, 12, 3]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="透镜（Lenses）"><a href="#透镜（Lenses）" class="headerlink" title="透镜（Lenses）"></a>透镜（Lenses）</h4><h5 id="什么是透镜？"><a href="#什么是透镜？" class="headerlink" title="什么是透镜？"></a>什么是透镜？</h5><pre><code>透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。
可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。
</code></pre><h5 id="如何创建透镜"><a href="#如何创建透镜" class="headerlink" title="如何创建透镜"></a>如何创建透镜</h5><pre><code>lens：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));</span><br><span class="line">R.view(xLens, &#123;x: 1, y: 2&#125;);            //=&gt; 1</span><br><span class="line">R.set(xLens, 4, &#123;x: 1, y: 2&#125;);          //=&gt; &#123;x: 4, y: 2&#125;</span><br><span class="line">// 还有三个便捷函数</span><br><span class="line">LensProp：创建关注对象某一属性的透镜。</span><br><span class="line">lensPath: 创建关注对象某一嵌套属性的透镜。</span><br><span class="line">lensIndex: 创建关注数组某一索引的透镜。</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="我能用它做什么呢？"><a href="#我能用它做什么呢？" class="headerlink" title="我能用它做什么呢？"></a>我能用它做什么呢？</h5><pre><code>Ramda 提供了三个配合透镜一起使用的的函数：
    view：读取透镜的值。
    set：更新透镜的值。
    over：将变换函数作用于透镜。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));</span><br><span class="line">R.view(xLens, &#123;x: 1, y: 2&#125;);            //=&gt; 1</span><br><span class="line">R.set(xLens, 4, &#123;x: 1, y: 2&#125;);          //=&gt; &#123;x: 4, y: 2&#125;</span><br><span class="line">R.over(xLens, R.negate, &#123;x: 1, y: 2&#125;);  //=&gt; &#123;x: -1, y: 2&#125;</span><br><span class="line">// 区别:</span><br><span class="line">// set 和 over 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：某些较大数据结构的处理 -- 透镜。
数组：读取(nth、slice、contains、head、last、tail、init、take、takeLast)
增、删、改(insert、update、append、prepend、concat、remove、without、drop、dropLast)
变换(adjust)
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="noopener">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="noopener">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>vue admin</title>
    <url>/2017/vue-admin.html</url>
    <content><![CDATA[<h2 id="最近个人接触了一些后台管理系统的搭建，参考了很多资料，打算把自己的后台管理系统开发经验写成博客，可能会帮助到一些想做后台管理系统的朋友，更主要的记录整个开发思路，以及vue的一整套解决方案。"><a href="#最近个人接触了一些后台管理系统的搭建，参考了很多资料，打算把自己的后台管理系统开发经验写成博客，可能会帮助到一些想做后台管理系统的朋友，更主要的记录整个开发思路，以及vue的一整套解决方案。" class="headerlink" title="最近个人接触了一些后台管理系统的搭建，参考了很多资料，打算把自己的后台管理系统开发经验写成博客，可能会帮助到一些想做后台管理系统的朋友，更主要的记录整个开发思路，以及vue的一整套解决方案。"></a>最近个人接触了一些后台管理系统的搭建，参考了很多资料，打算把自己的后台管理系统开发经验写成博客，可能会帮助到一些想做后台管理系统的朋友，更主要的记录整个开发思路，以及vue的一整套解决方案。</h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="后台管理系统主要功能-vue-cli搭建项目"><a href="#后台管理系统主要功能-vue-cli搭建项目" class="headerlink" title="后台管理系统主要功能(vue-cli搭建项目)"></a>后台管理系统主要功能(vue-cli搭建项目)</h3><ol>
<li>element-ui 饿了么出品的vue2.0 pc端 UI框架</li>
<li>axios vue官方推荐的请求库 支持Promise</li>
<li>html5的本地存储LocalStorage（用于记住密码等） 与 SessionStorage （用于存储个人信息和token等）</li>
<li>浏览器样式兼容库 normalize.css 格式化css</li>
<li>类似于YouTube的页面跳转精度条-nprogress 轻量的全局进度条控制</li>
<li>官方提供的状态管理库 vuex</li>
<li>官方提供路由 vue-router</li>
<li>集成icon-font图标(symbol方式)</li>
<li>添加全屏功能<br>（后续会继续添加）</li>
</ol>
<h3 id="先在项目中引入-element-ui"><a href="#先在项目中引入-element-ui" class="headerlink" title="先在项目中引入 element-ui"></a>先在项目中引入 <a href="http://element.eleme.io/#/zh-CN" target="_blank" rel="noopener">element-ui</a></h3><ol>
<li>安装 element-ui  npm i element-ui -S</li>
<li>引入相关资源<br> import ElementUI from ‘element-ui’<br> import ‘element-ui/lib/theme-default/index.css’<br> Vue.use(ElementUI)<br> 这样你就可以愉快的在你的项目中使用element的组件了。</li>
<li>例如使用 Message 消息提示<br> 就可以在任何vue组件中 this.$message(‘这是一条消息提示’); // this指向vue实例</li>
</ol>
<h3 id="在项目中引入axios请求库axios"><a href="#在项目中引入axios请求库axios" class="headerlink" title="在项目中引入axios请求库axios"></a>在项目中引入axios请求库<a href="https://www.axios.com/" target="_blank" rel="noopener">axios</a></h3><ol>
<li>安装 axios npm i axios -S   </li>
<li>在使用axios的时候我们经常要进行一些封装和全局配置等<br> 我一般开发时会在src目录下新建一个api的文件夹，里面存放对axios的封装（axios.js）和项目所有请求（http.js）</li>
<li><p>这里重点讲一下axios.js这个文件夹，也就是对axios的封装以及拦截操作<br> 这里是全局配置</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var service = axios.create(&#123;</span><br><span class="line">  baseURL:&quot;https://some-domain.com/api/&quot;,</span><br><span class="line">  timeout:1000,</span><br><span class="line">  headers: &#123;&apos;X-Custom-Header&apos;:&apos;foobar&apos;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 这里是request拦截操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// request拦截器</span><br><span class="line">service.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">  if (store.getters.token) &#123; // 判断全局状态中是否有token，也就是说判断你不是合法用户</span><br><span class="line">	config.headers[&apos;token&apos;] = store.getters.token; // 让每个请求携带自定义token，开心不用没个请求都带上token字段了</span><br><span class="line">  &#125;</span><br><span class="line">  return config;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  Promise.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 这里是response拦截操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// respone拦截器</span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">	// code为非20000是抛错 可结合自己业务进行修改</span><br><span class="line">	const res = response.data;</span><br><span class="line">	if (res.code !== 20000) &#123;</span><br><span class="line">	  // 在该页面使用element组件，别忘了需要引入哦！！</span><br><span class="line">	  Message(&#123;</span><br><span class="line">		message: res.data,</span><br><span class="line">		type: &apos;error&apos;,</span><br><span class="line">		duration: 5 * 1000</span><br><span class="line">	  &#125;);</span><br><span class="line"></span><br><span class="line">	  // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;</span><br><span class="line">	  if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123;</span><br><span class="line">		// 这里需要你进行相应的操作处理</span><br><span class="line">	  &#125;</span><br><span class="line">	  return Promise.reject(error);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	  return response.data;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">	Message(&#123;</span><br><span class="line">	  message: error.message,</span><br><span class="line">	  type: &apos;error&apos;,</span><br><span class="line">	  duration: 5 * 1000</span><br><span class="line">	&#125;);</span><br><span class="line">	return Promise.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">// 最后被忘了，要export 这个实例</span><br><span class="line">export default service;</span><br></pre></td></tr></table></figure>
</li>
<li><p>阻止http.js请求文件<br> 里面的内容大致是这样的</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import service from &apos;./axios&apos;</span><br><span class="line">const ApiUrl = &#123;</span><br><span class="line">	login: &apos;login/&apos;, // 存放api路径</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">	login () &#123;</span><br><span class="line">		// 这里后期我会发在vuex中的actions里面</span><br><span class="line">		service.post(ApiUrl.login, &#123;</span><br><span class="line">		  username: &apos;fanerge&apos;,</span><br><span class="line">		  password: &apos;XXXXXX&apos;</span><br><span class="line">		&#125;)</span><br><span class="line">		.then((res) =&gt; &#123;</span><br><span class="line">			let resp = res.data</span><br><span class="line">			console.log(resp)</span><br><span class="line">		&#125;)</span><br><span class="line">		.catch((err) =&gt; &#123;</span><br><span class="line">			console.error(err)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>参考<a href="https://juejin.im/post/595b4d776fb9a06bbe7dba56" target="_blank" rel="noopener">vueAdmin-template</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda入门和函数组合</title>
    <url>/2017/ramda%E8%BF%90%E7%94%A8.html</url>
    <content><![CDATA[<p>继续函数式编程的学习。</p>
<h4 id="总结Ramda与Lodash和Underscore的优势"><a href="#总结Ramda与Lodash和Underscore的优势" class="headerlink" title="总结Ramda与Lodash和Underscore的优势"></a>总结Ramda与Lodash和Underscore的优势</h4><h5 id="自动柯里化"><a href="#自动柯里化" class="headerlink" title="自动柯里化"></a>自动柯里化</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 一map函数为例，解释Ramda的自动柯里化 </span><br><span class="line">// map函数解释：param1为对集合每一项进行处理并返回同类型的数据，param2需要处理的集合（Array或Object）</span><br><span class="line">// 第一种，为使用柯里化</span><br><span class="line">var map3 = R.map(function (item) &#123;</span><br><span class="line">  return item * item;</span><br><span class="line">&#125;, [1, 2, 3, 4]); </span><br><span class="line">// console.log(map3); // [1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line">// 第一种curry化（转化成单参数函数）</span><br><span class="line">var map1 = R.map(function (item) &#123;</span><br><span class="line">  return item * item;</span><br><span class="line">&#125;);</span><br><span class="line">var map2 = map1([1, 2, 3, 4]);</span><br><span class="line">// console.log(map2); // [1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="函数参数优先于数据"><a href="#函数参数优先于数据" class="headerlink" title="函数参数优先于数据"></a>函数参数优先于数据</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数优先于数据</span><br><span class="line">var map4 = R.map(R.multiply(2), [1, 2, 3, 4]);</span><br><span class="line">// console.log(map4); // [2, 4, 6, 8]</span><br><span class="line">var map5 = R.map(R.multiply(2))([1, 2, 3, 4]);</span><br><span class="line">// console.log(map5); // [2, 4, 6, 8]</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="Ramdajs的组合"><a href="#Ramdajs的组合" class="headerlink" title="Ramdajs的组合"></a>Ramdajs的组合</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ramdajs的compose组合</span><br><span class="line">var users = [</span><br><span class="line">  &#123; &apos;user&apos;: &apos;user1&apos;,  &apos;age&apos;: 36 &#125;,</span><br><span class="line">  &#123; &apos;user&apos;: &apos;user2&apos;,    &apos;age&apos;: 40 &#125;,</span><br><span class="line">  &#123; &apos;user&apos;: &apos;user3&apos;, &apos;age&apos;: 18 &#125;</span><br><span class="line">];</span><br><span class="line">// R.pluck(k)[array] === R.map(R.prop(k), array)</span><br><span class="line">var pluck1 = R.pluck(&apos;user&apos;)(users);</span><br><span class="line">var pluck2 = R.map(R.prop(&apos;user&apos;))(users);</span><br><span class="line"></span><br><span class="line">// compose为函数组合（从右到左）</span><br><span class="line">var pluck3 = R.compose(R.join(&apos;,&apos;), R.pluck(&apos;user&apos;))(users);</span><br><span class="line">// console.log(pluck3); // user1,user2,user3</span><br><span class="line">// pipe为函数组合（从左到右）</span><br><span class="line">var pipe1 = R.pipe(R.pluck(&apos;user&apos;), R.join(&apos;*&apos;))(users);</span><br><span class="line">// console.log(pipe1); // user1*user2*user3</span><br><span class="line"></span><br><span class="line">// 依次获得用户的出生年</span><br><span class="line">var compose1 = R.compose(R.join(&apos;,&apos;), R.map(R.subtract(new Date().getFullYear())), R.pluck(&apos;age&apos;))(users);</span><br><span class="line">console.log(compose1); // 1981,1977,1999</span><br><span class="line"></span><br><span class="line">// 获得最年轻的用户信息</span><br><span class="line">var userMin = R.compose(R.head, R.sortBy(R.prop(&apos;age&apos;)))(users);</span><br><span class="line">var userMax = R.compose(R.last, R.sortBy(R.prop(&apos;age&apos;)))(users);</span><br><span class="line">var userMax1 = R.compose(R.head, R.reverse, R.sortBy(R.prop(&apos;age&apos;)))(users);</span><br><span class="line">console.log(userMin, userMax); // &#123;user: &quot;user3&quot;, age: 18&#125; &#123;user: &quot;user2&quot;, age: 40&#125;</span><br><span class="line">console.log(userMax1); // &#123;user: &quot;user2&quot;, age: 40&#125;</span><br></pre></td></tr></table></figure>

**纯函数**纯函数是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 &quot;输出&quot;，不会对数据库进行读写，不会修改输入参数等。
纯函数的基本思想是：相同的输入，永远会得到相同的输出。
**数据不变性**函数式编程的另一个重要概念是 &quot;Immutability&quot;，&quot;Immutability&quot; 是指 &quot;数据不变性&quot;。
当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。
开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach</span><br><span class="line">for (const value of Array) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">forEach(value =&gt; console.log(value), Array);</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">map(x =&gt; x*2, [1, 2, 3]); // [2, 4, 6]</span><br><span class="line"></span><br><span class="line">filter/reject(互补)</span><br><span class="line">const isEven = x =&gt; x % 2 === 0;</span><br><span class="line">filter(isEven, [1, 2, 3]); // [2]</span><br><span class="line">reject(isEven, [1, 2, 3]); // [1, 3]</span><br><span class="line"></span><br><span class="line">find</span><br><span class="line">find(isEven, [1, 2, 3, 4]); // 2</span><br><span class="line"></span><br><span class="line">reduce</span><br><span class="line">const add = (accum, value) =&gt; accum + value;	</span><br><span class="line">reduce(add, 5, [1, 2, 3, 4]); // 15</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h4><h5 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h5><pre><code>Complement：对函数的返回值取反。接受一个函数 f，返回一个新函数 g。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isEven = x =&gt; x % 2 === 0;</span><br><span class="line">var complement1 = R.find(isEven, [1, 1, 2, 4]); // 2</span><br><span class="line">var complement2 = R.find(R.complement(isEven), [1, 2, 2, 4]); // 1</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="Both-Either"><a href="#Both-Either" class="headerlink" title="Both/Either"></a>Both/Either</h5><pre><code>both：该函数调用两个函数，并对两函数返回值进行与（&amp;&amp;）操作。
either：该函数调用两个函数，并对两函数返回值进行或（||）操作。    
投票系统（投票资格的条件：在本国出生，或者后来加入该国国籍，且年满18岁。）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断是否有投票的权利</span><br><span class="line">let person1 = &#123;</span><br><span class="line">  birthCountry: &apos;CHINA&apos;,</span><br><span class="line">  naturalizationDate: false,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;;</span><br><span class="line">const wasBornInCountry = person =&gt; person.birthCountry === &apos;CHINA&apos;;</span><br><span class="line">const wasNaturalized = person =&gt; Boolean(person.naturalizationDate);</span><br><span class="line">const isOver18 = person =&gt; person.age &gt;= 18;</span><br><span class="line">var isCitizen = R.either(wasBornInCountry, wasNaturalized); // 在本国出生，或者后来加入该国国籍。</span><br><span class="line">var isEligibleToVote = R.both(isCitizen, isOver18);</span><br><span class="line">var vote1 = isEligibleToVote(person1); // true</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="Pipelines-管道"><a href="#Pipelines-管道" class="headerlink" title="Pipelines(管道)"></a>Pipelines(管道)</h5><pre><code>pipe：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var multiply = (num1, num2) =&gt; num1 * num2;</span><br><span class="line">var addOne = num =&gt; num + 1;</span><br><span class="line">var square = num =&gt; num * num;</span><br><span class="line">var operate1 = R.pipe(multiply, addOne, square)(1, 2); // ((1*2)+1)^2 = 9</span><br></pre></td></tr></table></figure>

compose：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var operate2 =R.compose(square, addOne, multiply)(1, 2); // 9</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>本节学习了：函数、纯函数、IMMUTABILITY、foreach（递归替代循环）、map、filter、reject、find、reduce、
函数组合的方法：complement、either、both、pipe、compose、
</code></pre><blockquote>
<p>   参考文献：<br>    <a href="http://www.cnblogs.com/whitewolf/p/javascript-functional-programming-Ramdajs.html" target="_blank" rel="noopener">JavaScript函数编程-Ramdajs</a><br>    <a href="https://zhuanlan.zhihu.com/p/27446536" target="_blank" rel="noopener">Thinking in Ramda系列文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title>sql参考手册</title>
    <url>/2017/sql%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html</url>
    <content><![CDATA[<h4 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND / OR"></a>AND / OR</h4><pre><code>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。
语法：SELECT column_name(s) FROM table_name WHERE condition AND|OR condition;
选择count大于10 且 count小于230
    SELECT * FROM access_log WHERE count &gt; 10 AND count &lt; 230
选择count小于10 或 count大于230    
    SELECT * FROM access_log WHERE count &lt; 10 OR count &gt; 230
</code></pre><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><pre><code>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。
语法：
    // 添加一列
    ALTER TABLE table_name  
    ADD column_name datatype 
    // 删除一列
    ALTER TABLE table_name   
    DROP COLUMN column_name
    // 更改一列字段类型    
    ALTER TABLE table_name   
    MODIFY COLUMN column_name VARCHAR(10)
    // 更改一列
    ALTER TABLE table_name   
    CHANGE COLUMN column_name re_name
</code></pre><h4 id="AS-alias"><a href="#AS-alias" class="headerlink" title="AS (alias)"></a>AS (alias)</h4><pre><code>SELECT column_name AS column_alias 
FROM table_name
OR
SELECT column_name
FROM table_name AS table_alias
对url改名为ii    
    SELECT url AS ii FROM websites
</code></pre><h4 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h4><pre><code>语法：
    SELECT column_name(s)
    FROM table_name
    WHERE column_name
    BETWEEN value1 AND value2
选择alexa1到10的所有记录
    SELECT * FROM websites WHERE alexa BETWEEN 1 AND 10    
</code></pre><h4 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a>CREATE DATABASE</h4><pre><code>语法：CREATE DATABASE database_name
创建IIII数据库    
    CREATE DATABASE IIII    
</code></pre><h4 id="DROP-DATABASE"><a href="#DROP-DATABASE" class="headerlink" title="DROP DATABASE"></a>DROP DATABASE</h4><pre><code>语法：DROP DATABASE database_name
删除IIII数据库
    DROP DATABASE IIII
</code></pre><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h4><pre><code>语法：
    CREATE TABLE table_name (
        column_name data_type,
        column_name data_type,
        ...
    )
创建一个名为 sds 的表，且有字段int    
    CREATE TABLE sds (id int)
</code></pre><h4 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h4><pre><code>语法：DROP TABLE IF EXISTS tabale_name
如果表sds存在就删除
    DROP TABLE IF EXISTS sds
</code></pre><h4 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h4><pre><code>创建索引
语法：
    CREATE INDEX index_name
    ON tabale_name (column_name)
    OR
    CREATE UNIQUE INDEX index_name
    ON tabale_name (column_name)
</code></pre><h4 id="CREATE-VIEW"><a href="#CREATE-VIEW" class="headerlink" title="CREATE VIEW"></a>CREATE VIEW</h4><pre><code>创建视图
视图是基于 SQL 语句的结果集的可视化的表。
语法：
    CREATE VIEW view_name AS
    SELECT column_name(s)
    FROM tabale_name
</code></pre><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><pre><code>DELETE FROM tabale_name
WHERE some_column = some_value
OR
DELETE FROM tabale_name // 删除整个表
DELETE * FROM tabale_name
</code></pre><h4 id="DROP-DATABASE-1"><a href="#DROP-DATABASE-1" class="headerlink" title="DROP DATABASE"></a>DROP DATABASE</h4><pre><code>删除数据库
DROP DATABASE data_name
</code></pre><h4 id="DROP-INDEX"><a href="#DROP-INDEX" class="headerlink" title="DROP INDEX"></a>DROP INDEX</h4><pre><code>删除索引
DROP INDEX index_name
</code></pre><h4 id="DROP-TABLE-1"><a href="#DROP-TABLE-1" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h4><pre><code>删除表
DROP TABLE table_name
</code></pre><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><pre><code>合计函数 (比如 SUM) 常常需要添加 GROUP BY 语句。
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value1
GROUP BY column_name
</code></pre><h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><pre><code>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。    
SELECT column_name, aggregate_function(column_name)
FROM tabale_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value
</code></pre><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><pre><code>IN 操作符允许您在 WHERE 子句中规定多个值。
SELECT column_name(s)
FROM tabale_name
WHERE column_name
IN(value1, value2)
</code></pre><h4 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h4><pre><code>插入数据
INSERT INTO tabale_name
VALUES(value1, value2, ...value3)
OR    
INSERT INTO tabale_name
(column1, column2, ...column3)
VALUES(value1, value2, ...value3)
</code></pre><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><pre><code>在表中存在至少一个匹配时，INNER JOIN 关键字返回行。    
SELECT column_name(s)
FROM tabale_name1
INNER JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name
</code></pre><h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><pre><code>返回左表
SELECT column_name(s)
FROM tabale_name1
LEFT JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name
</code></pre><h4 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h4><pre><code>返回左表
SELECT column_name(s)
FROM tabale_name1
RIGHT JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name        
</code></pre><h4 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h4><pre><code>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。    
SELECT column_name(s)
FROM tabale_name1
FULL JOIN tabale_name2
ON tabale_name1.column_name = tabale_name2.column_name
</code></pre><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><pre><code>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。    
SELECT column_name(s)
FROM tabale_name
WHERE column_name LIKE pattern
</code></pre><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><pre><code>ORDER BY 语句用于对结果集进行排序。
SELECT column_name 
FROM table_name
ORDER BY column_name[ASC|DESC]
</code></pre><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><pre><code>查询
SELECT column_name(s)
FROM tabale_name
</code></pre><h4 id="SELECT-1"><a href="#SELECT-1" class="headerlink" title="SELECT *"></a>SELECT *</h4><pre><code>SELECT *
FROM tabale_name
</code></pre><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><pre><code>关键词 DISTINCT 用于返回唯一不同的值。    
SELECT DISTINCT column_name(s)
FROM tabale_name
</code></pre><h4 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h4><pre><code>SELECT *
INTO new_table_name [IN externaldatabase]
FROM old_table_name
OR
SELECT column_name(s)
INTO new_table_name [IN externaldatabase]
FROM old_table_name
</code></pre><h4 id="SELECT-TOP"><a href="#SELECT-TOP" class="headerlink" title="SELECT TOP"></a>SELECT TOP</h4><pre><code>SELECT column_name(s)
FROM table_name
LIMIT number
</code></pre><h4 id="TRUNCATE-TABLE"><a href="#TRUNCATE-TABLE" class="headerlink" title="TRUNCATE TABLE"></a>TRUNCATE TABLE</h4><pre><code>TRUNCATE TABLE table_name    
</code></pre><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><pre><code>SQL UNION 操作符合并两个或多个 SELECT 语句的结果。
SELECT column_name(s) FROM tabale_name1
UNION
SELECT column_name(s) FROM tabale_name2
</code></pre><h4 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h4><pre><code>SELECT column_name(s) FROM tabale_name1
UNION ALL
SELECT column_name(s) FROM tabale_name2
</code></pre><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><pre><code>更新
UPDATE tabale_name
SET column1=value, column2=value
WHERE some_column=some_value
</code></pre><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><pre><code>条件
SELECT column_name(s)
FROM tabale_name
WHERE column_name operator value
</code></pre><blockquote>
<p>   参考文档<br>    <a href="http://www.runoob.com/sql/sql-quickref.html" target="_blank" rel="noopener">SQL文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>vue vuex</title>
    <url>/2017/vue-vuex.html</url>
    <content><![CDATA[<h2 id="今天来总结下，在项目中使用vuex，项目采用easy-mock模拟数据"><a href="#今天来总结下，在项目中使用vuex，项目采用easy-mock模拟数据" class="headerlink" title="今天来总结下，在项目中使用vuex，项目采用easy-mock模拟数据"></a>今天来总结下，在项目中使用vuex，项目采用<a href="https://easy-mock.com" target="_blank" rel="noopener">easy-mock</a>模拟数据</h2><p><em>如有不正确的地方，请大家联系我，谢谢。</em></p>
<h3 id="首先在项目中添加vuex"><a href="#首先在项目中添加vuex" class="headerlink" title="首先在项目中添加vuex"></a>首先在项目中添加vuex</h3><ol>
<li><p>在store文件夹下面建立index.js,内容如下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  import Vue from &apos;vue&apos;</span><br><span class="line">  import Vuex from &apos;vuex&apos;</span><br><span class="line">  import &#123; login &#125; from &apos;@/api/http&apos; // 用于登录的</span><br><span class="line">  Vue.use(Vuex)</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123; // 保存全局state --- this.$store.state[key]-- 放在computed</span><br><span class="line">	userInfo: null,</span><br><span class="line">	token: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123; // 对state进行不修改操作，相当于数据库的查操作 --- this.$store.getter[key]-- 放在computed</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123; // 同步操作state --- this.$store.commit(&apos;func&apos;,payload)-- 放在methods</span><br><span class="line">	login (state, payload) &#123;</span><br><span class="line">	  state.userInfo = payload</span><br><span class="line">	&#125;,</span><br><span class="line">	setToken (state, payload) &#123;</span><br><span class="line">	  state.token = payload</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123; // 异步操作state --- this.$store.dispatch(&apos;func&apos;,payload)-- 放在methods</span><br><span class="line">	login (&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">	  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		login(userInfo.username, userInfo.password)</span><br><span class="line">		.then((res) =&gt; &#123;</span><br><span class="line">		  commit(&apos;login&apos;, res.userInfo) // 全局state中保存用户信息</span><br><span class="line">		  commit(&apos;setToken&apos;, res.token) // 全局state中保存token</span><br><span class="line">		  resolve(res) // 这里很关键，必须要传递res参数，登录之后的其他操作</span><br><span class="line">		&#125;)</span><br><span class="line">		.catch((err) =&gt; &#123;</span><br><span class="line">		  reject(err)</span><br><span class="line">		&#125;)</span><br><span class="line">	  &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js中添加</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import store from &apos;./store&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在api文件夹中http.js文件中</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import http from &apos;./axios&apos;</span><br><span class="line">export function login (username, password) &#123;</span><br><span class="line">  return http.post(&apos;user/login&apos;, &#123;</span><br><span class="line">	username,</span><br><span class="line">	password</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在登录组件中login.vue    </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">     login (data) &#123;</span><br><span class="line">       this.$store.dispatch(&apos;login&apos;, data)</span><br><span class="line">       .then((res) =&gt; &#123;</span><br><span class="line">         console.dir(res)</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch((err) =&gt; &#123;</span><br><span class="line">         console.error(err)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>vue官网-全局与实例解读</title>
    <url>/2017/vue%E5%AE%98%E7%BD%91-%E5%85%A8%E5%B1%80%E4%B8%8E%E5%AE%9E%E4%BE%8B%E8%A7%A3%E8%AF%BB.html</url>
    <content><![CDATA[<h1 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h1><h2 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend( options )"></a>Vue.extend( options )</h2><pre><code>用法：使用基础 Vue 构造器，创建一个“子类”。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建构造器</span><br><span class="line">var Profile = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">	  firstName: &apos;Walter&apos;,</span><br><span class="line">	  lastName: &apos;White&apos;,</span><br><span class="line">	  alias: &apos;Heisenberg&apos;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 创建 Profile 实例，并挂载到一个元素上。</span><br><span class="line">new Profile().$mount(&apos;#mount-point&apos;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick( [callback, context] )"></a>Vue.nextTick( [callback, context] )</h2><pre><code>用法：在下次 DOM 更新循环结束之后执行延迟回调。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改数据</span><br><span class="line">vm.msg = &apos;Hello&apos;</span><br><span class="line">// DOM 还没有更新</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  // DOM 更新之后进行相应的操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Vue-set-target-key-value"><a href="#Vue-set-target-key-value" class="headerlink" title="Vue.set( target, key, value )"></a>Vue.set( target, key, value )</h2><pre><code>用法：设置对象的属性。
</code></pre><h2 id="Vue-delete-target-key"><a href="#Vue-delete-target-key" class="headerlink" title="Vue.delete( target, key )"></a>Vue.delete( target, key )</h2><pre><code>用法：删除对象的属性。
</code></pre><h2 id="Vue-directive-id-definition"><a href="#Vue-directive-id-definition" class="headerlink" title="Vue.directive( id, [definition] )"></a>Vue.directive( id, [definition] )</h2><pre><code>用法：注册或获取全局指令。
如自定义指令，v-focus
</code></pre><h2 id="Vue-filter-id-definition"><a href="#Vue-filter-id-definition" class="headerlink" title="Vue.filter( id, [definition] )"></a>Vue.filter( id, [definition] )</h2><pre><code>用法：注册或获取全局过滤器。
</code></pre><h2 id="Vue-component-id-definition"><a href="#Vue-component-id-definition" class="headerlink" title="Vue.component( id, [definition] )"></a>Vue.component( id, [definition] )</h2><pre><code>用法：注册或获取全局组件。
</code></pre><h2 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use( plugin )"></a>Vue.use( plugin )</h2><pre><code>用法：安装 Vue.js 插件。
</code></pre><h2 id="Vue-mixin-mixin"><a href="#Vue-mixin-mixin" class="headerlink" title="Vue.mixin( mixin )"></a>Vue.mixin( mixin )</h2><pre><code>用法：全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。
</code></pre><h2 id="Vue-compile-template"><a href="#Vue-compile-template" class="headerlink" title="Vue.compile( template )"></a>Vue.compile( template )</h2><pre><code>用法：在 render 函数中编译模板字符串。
</code></pre><h2 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h2><pre><code>用法：提供字符串形式的 Vue 安装版本号。
</code></pre><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><pre><code>以下实例均为 vm。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new (&#123;</span><br><span class="line">	el: &apos;#app&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><pre><code>作用：Vue 实例代理了对其 data 对象属性的访问。
</code></pre><h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h3><pre><code>作用：Vue 实例代理了对其 props 对象属性的访问。
</code></pre><h3 id="vm-el（只读）"><a href="#vm-el（只读）" class="headerlink" title="vm.$el（只读）"></a>vm.$el（只读）</h3><pre><code>作用：Vue 实例使用的根 DOM 元素。
</code></pre><h3 id="vm-options（只读）"><a href="#vm-options（只读）" class="headerlink" title="vm.$options（只读）"></a>vm.$options（只读）</h3><pre><code>作用：用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处。
</code></pre><h3 id="vm-parent（只读）"><a href="#vm-parent（只读）" class="headerlink" title="vm.$parent（只读）"></a>vm.$parent（只读）</h3><pre><code>作用：父实例，如果当前实例有的话。
</code></pre><h3 id="vm-root（只读）"><a href="#vm-root（只读）" class="headerlink" title="vm.$root（只读）"></a>vm.$root（只读）</h3><pre><code>作用：当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。
</code></pre><h3 id="vm-children（只读）"><a href="#vm-children（只读）" class="headerlink" title="vm.$children（只读）"></a>vm.$children（只读）</h3><pre><code>作用：当前实例的直接子组件。
</code></pre><h3 id="vm-slots（只读）"><a href="#vm-slots（只读）" class="headerlink" title="vm.$slots（只读）"></a>vm.$slots（只读）</h3><pre><code>作用：用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：slot=&quot;foo&quot; 中的内容将会在 vm.$slots.foo 中被找到)。
</code></pre><h3 id="vm-scopedSlots（只读）"><a href="#vm-scopedSlots（只读）" class="headerlink" title="vm.$scopedSlots（只读）"></a>vm.$scopedSlots（只读）</h3><pre><code>作用：用来访问作用域插槽。
</code></pre><h3 id="vm-refs（只读）"><a href="#vm-refs（只读）" class="headerlink" title="vm.$refs（只读）"></a>vm.$refs（只读）</h3><pre><code>作用：一个对象，持有已注册过 ref 的所有子组件。
</code></pre><h3 id="vm-isServer（只读）"><a href="#vm-isServer（只读）" class="headerlink" title="vm.$isServer（只读）"></a>vm.$isServer（只读）</h3><pre><code>作用：当前 Vue 实例是否运行于服务器。
</code></pre><h3 id="vm-attrs（只读）"><a href="#vm-attrs（只读）" class="headerlink" title="vm.$attrs（只读）"></a>vm.$attrs（只读）</h3><pre><code>作用：包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)。
</code></pre><h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a>vm.$listeners</h3><pre><code>作用：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。
</code></pre><h2 id="实例方法-数据"><a href="#实例方法-数据" class="headerlink" title="实例方法/数据"></a>实例方法/数据</h2><h3 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch(expOrFn, callback, [options]);"></a>vm.$watch(expOrFn, callback, [options]);</h3><pre><code>作用：观察 Vue 实例变化的一个表达式或计算属性函数。
返回值：{Function} unwatch
    vm.$watch 返回一个取消观察函数，用来停止触发回调：
</code></pre><h3 id="vm-set-target-key-value"><a href="#vm-set-target-key-value" class="headerlink" title="vm.$set( target, key, value )"></a>vm.$set( target, key, value )</h3><pre><code>作用：这是全局 Vue.set 的别名。
</code></pre><h3 id="vm-delete-target-key"><a href="#vm-delete-target-key" class="headerlink" title="vm.$delete( target, key )"></a>vm.$delete( target, key )</h3><pre><code>作用：这是全局 Vue.delete 的别名。
</code></pre><h2 id="实例方法-事件"><a href="#实例方法-事件" class="headerlink" title="实例方法/事件"></a>实例方法/事件</h2><h3 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on(event, callback);"></a>vm.$on(event, callback);</h3><pre><code>作用：监听当前实例上的自定义事件。
</code></pre><h3 id="vm-once-event-callback"><a href="#vm-once-event-callback" class="headerlink" title="vm.$once(event, callback);"></a>vm.$once(event, callback);</h3><pre><code>作用：监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。
</code></pre><h3 id="vm-off-event-callback"><a href="#vm-off-event-callback" class="headerlink" title="vm.$off( [event, callback] )"></a>vm.$off( [event, callback] )</h3><pre><code>作用：移除自定义事件监听器。
</code></pre><h3 id="vm-emit-event-…args"><a href="#vm-emit-event-…args" class="headerlink" title="vm.$emit(event, […args]);"></a>vm.$emit(event, […args]);</h3><pre><code>作用：触发当前实例上的事件。附加参数都会传给监听器回调。
</code></pre><h2 id="实例方法-生命周期"><a href="#实例方法-生命周期" class="headerlink" title="实例方法/生命周期"></a>实例方法/生命周期</h2><h3 id="vm-mount-elementOrSelector"><a href="#vm-mount-elementOrSelector" class="headerlink" title="vm.$mount( [elementOrSelector] )"></a>vm.$mount( [elementOrSelector] )</h3><pre><code>作用：如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。
</code></pre><h3 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h3><pre><code>作用：迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。
</code></pre><h3 id="vm-nextTick-callback"><a href="#vm-nextTick-callback" class="headerlink" title="vm.$nextTick( [callback] )"></a>vm.$nextTick( [callback] )</h3><pre><code>作用：将回调延迟到下次 DOM 更新循环之后执行。
</code></pre><h3 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy()"></a>vm.$destroy()</h3><pre><code>作用：完全销毁一个实例。
</code></pre><h1 id="指令（内置）"><a href="#指令（内置）" class="headerlink" title="指令（内置）"></a>指令（内置）</h1><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><pre><code>作用：更新元素的 textContent。
    还可以使用 {{ Mustache }}
</code></pre><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><pre><code>作用：更新元素的 innerHTML 。
</code></pre><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><pre><code>作用：根据表达式之真假值，切换元素的 display CSS 属性。
    当条件变化时该指令触发过渡效果。
</code></pre><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><pre><code>作用：根据表达式的值的真假条件渲染元素。
    在切换时元素及它的数据绑定 / 组件被销毁并重建。
</code></pre><h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><pre><code>作用：否则，前一兄弟元素必须有 v-if 或 v-else-if。
</code></pre><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><pre><code>作用：表示 v-if 的 “else if 块”。
</code></pre><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><pre><code>作用：基于源数据多次渲染元素或模板块。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--数组--&gt;</span><br><span class="line">&lt;div v-for=&quot;(item, index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!--对象--&gt;</span><br><span class="line">&lt;div v-for=&quot;(val, key, index) in object&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="v-on（-）"><a href="#v-on（-）" class="headerlink" title="v-on（@）"></a>v-on（@）</h2><pre><code>作用：绑定事件监听器。
事件修饰符：.stop, .prevent, .capture, .self, {keyCode | keyAlias}
    .native, .once, .left, .right, .middle, .passive    
</code></pre><h2 id="v-bind（-）"><a href="#v-bind（-）" class="headerlink" title="v-bind（:）"></a>v-bind（:）</h2><pre><code>作用：绑定属性。
属性修饰符：.prop, .camel, .sync（会扩展成一个更新父组件绑定值的 v-on 侦听器）    
</code></pre><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><pre><code>作用：表单和数据的双向绑定。
表单修饰符：.lazy, .number, .trim
</code></pre><h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><pre><code>作用：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。
</code></pre><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><pre><code>作用：这个指令保持在元素上直到关联实例结束编译。    
    需配合 CSS 规则 [v-cloak] { display: none } 一起使用。
</code></pre><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><pre><code>作用：只渲染元素和组件一次。
</code></pre><h1 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h1><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><pre><code>作用：性能考虑。
使用场景：v-for, transition-group 过渡组件。
</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><pre><code>ref 被用来给元素或子组件注册引用信息。
</code></pre><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><pre><code>作用：用于标记往哪个具名插槽中插入子组件内容。
</code></pre><h2 id="slot-scoped"><a href="#slot-scoped" class="headerlink" title="slot-scoped"></a>slot-scoped</h2><pre><code>作用：用于将元素或组件表示为作用域插槽。
</code></pre><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><pre><code>作用：用于动态组件且基于 DOM 内模板的限制来工作。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- component changes when currentView changes --&gt;</span><br><span class="line">&lt;component v-bind:is=&quot;currentView&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;</span><br><span class="line">&lt;!-- a `&lt;table&gt;` element and so would be hoisted out      --&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="内置的组件"><a href="#内置的组件" class="headerlink" title="内置的组件"></a>内置的组件</h1><h2 id="component"><a href="#component" class="headerlink" title="component"></a>component</h2><pre><code>用法：渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。
props: is, inline-template
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;</span><br><span class="line">&lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span><br><span class="line">&lt;component :is=&quot;$options.components.child&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><pre><code>用法：&lt;transition&gt; 元素作为单个元素/组件的过渡效果。
props：...
事件：...
</code></pre><h2 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h2><pre><code>用法：&lt;transition-group&gt; 元素作为多个元素/组件的过渡效果。
props: tag, move-class, mode
事件：...
</code></pre><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><pre><code>props：include, exclude    
用法：&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
</code></pre><h2 id="slot-1"><a href="#slot-1" class="headerlink" title="slot"></a>slot</h2><pre><code>用法：&lt;slot&gt; 元素作为组件模板之中的内容分发插槽。&lt;slot&gt; 元素自身将被替换。
props：name
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://cn.vuejs.org/v2/api" target="_blank" rel="noopener">官方api</a></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue开发规范</title>
    <url>/2017/vue%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html</url>
    <content><![CDATA[<h2 id="组件名为多个单词"><a href="#组件名为多个单词" class="headerlink" title="组件名为多个单词"></a>组件名为多个单词</h2><pre><code>组件名应该始终是多个单词的，根组件 App 除外。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;todo-item&apos;, &#123; //  自动将组件的 name 设置为 todo-item</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;TodoItem&apos;, // 最佳实践为组件带上 name 调试有好处 </span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="组件数据"><a href="#组件数据" class="headerlink" title="组件数据"></a>组件数据</h2><pre><code>组件的 data 必须是一个函数。
每次返回一个新的纯对象。
</code></pre><h2 id="Prop定义"><a href="#Prop定义" class="headerlink" title="Prop定义"></a>Prop定义</h2><pre><code>Prop 定义应该尽量详细（至少为其指定 type ）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  status: &#123;</span><br><span class="line">	type: String,</span><br><span class="line">	required: true,</span><br><span class="line">	validator: function (value) &#123;</span><br><span class="line">	  return [</span><br><span class="line">		&apos;syncing&apos;,</span><br><span class="line">		&apos;synced&apos;,</span><br><span class="line">		&apos;version-conflict&apos;,</span><br><span class="line">		&apos;error&apos;</span><br><span class="line">	  ].indexOf(value) !== -1</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="为-v-for-设置键值"><a href="#为-v-for-设置键值" class="headerlink" title="为 v-for 设置键值"></a>为 v-for 设置键值</h2><pre><code>总是用 key 配合 v-for。
</code></pre><h2 id="为组件样式设置作用域"><a href="#为组件样式设置作用域" class="headerlink" title="为组件样式设置作用域"></a>为组件样式设置作用域</h2><pre><code>下面对于单文件组件。
对于应用来说，顶级 App 组件和布局组件中的样式可以是全局的，
但是其它所有组件都应该是有作用域的（3种方式）。
</code></pre><ol>
<li>scoped <style scoped></style>    </li>
<li><p>css Modules</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button :class=&quot;[$style.button]&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.button &#123;</span><br><span class="line">  border: none;</span><br><span class="line">  border-radius: 2px;</span><br><span class="line">&#125;</span><br><span class="line">.buttonClose &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BEM 约定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.c-Button &#123;</span><br><span class="line">  border: none;</span><br><span class="line">  border-radius: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有属性名 必要<br>在插件、混入等扩展中始终为自定义的私有属性使用 $_ 前缀。<br>并附带一个命名空间以回避和其它作者的冲突 (比如 $<em>yourPluginName</em>)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myGreatMixin = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">	$_myGreatMixin_update: function () &#123;</span><br><span class="line">	  // ...</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="组件文件"><a href="#组件文件" class="headerlink" title="组件文件"></a>组件文件</h2><pre><code>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。
components/
|- TodoList.vue
|- TodoItem.vue
</code></pre><h2 id="单文件组件文件的大小写（大驼峰）"><a href="#单文件组件文件的大小写（大驼峰）" class="headerlink" title="单文件组件文件的大小写（大驼峰）"></a>单文件组件文件的大小写（大驼峰）</h2><pre><code>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。
</code></pre><h2 id="基础组件名"><a href="#基础组件名" class="headerlink" title="基础组件名"></a>基础组件名</h2><pre><code>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，
比如 Base、App 或 V。
components/
|- BaseButton.vue
|- BaseTable.vue
|- BaseIcon.vue
</code></pre><h2 id="单例组件名"><a href="#单例组件名" class="headerlink" title="单例组件名"></a>单例组件名</h2><pre><code>只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。
components/
|- TheHeading.vue
|- TheSidebar.vue
</code></pre><h2 id="紧密耦合的组件名"><a href="#紧密耦合的组件名" class="headerlink" title="紧密耦合的组件名"></a>紧密耦合的组件名</h2><pre><code>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。
components/
|- TodoList.vue
|- TodoListItem.vue
|- TodoListItemButton.vue
</code></pre><h2 id="组件名中的单词顺序"><a href="#组件名中的单词顺序" class="headerlink" title="组件名中的单词顺序"></a>组件名中的单词顺序</h2><pre><code>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。
components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingsCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue
</code></pre><h2 id="自闭合组件"><a href="#自闭合组件" class="headerlink" title="自闭合组件"></a>自闭合组件</h2><pre><code>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span><br><span class="line">&lt;MyComponent/&gt;</span><br><span class="line">&lt;!-- 在 DOM 模板中 --&gt;</span><br><span class="line">&lt;my-component&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="模板中的组件名大小写"><a href="#模板中的组件名大小写" class="headerlink" title="模板中的组件名大小写"></a>模板中的组件名大小写</h2><pre><code>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。
&lt;!-- 在所有地方 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
</code></pre><h2 id="JS-JSX-中的组件名大小写"><a href="#JS-JSX-中的组件名大小写" class="headerlink" title="JS/JSX 中的组件名大小写"></a>JS/JSX 中的组件名大小写</h2><pre><code>JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，
可以使用 kebab-case 字符串。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;MyComponent&apos;, &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">import MyComponent from &apos;./MyComponent.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;MyComponent&apos;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="完整单词的组件名"><a href="#完整单词的组件名" class="headerlink" title="完整单词的组件名"></a>完整单词的组件名</h2><pre><code>组件名应该倾向于完整单词而不是缩写。
components/
|- StudentDashboardSettings.vue 学生面板设置
|- UserProfileOptions.vue
</code></pre><h2 id="Prop-名大小写"><a href="#Prop-名大小写" class="headerlink" title="Prop 名大小写"></a>Prop 名大小写</h2><pre><code>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  greetingText: String</span><br><span class="line">&#125;</span><br><span class="line">// 在 html 中</span><br><span class="line">&lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="多个特性的元素"><a href="#多个特性的元素" class="headerlink" title="多个特性的元素"></a>多个特性的元素</h2><pre><code>多个特性的元素应该分多行撰写，每个特性一行。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">  src=&quot;https://vuejs.org/images/logo.png&quot;</span><br><span class="line">  alt=&quot;Vue Logo&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="模板中简单的表达式"><a href="#模板中简单的表达式" class="headerlink" title="模板中简单的表达式"></a>模板中简单的表达式</h2><pre><code>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。
</code></pre><h2 id="简单的计算属性"><a href="#简单的计算属性" class="headerlink" title="简单的计算属性"></a>简单的计算属性</h2><pre><code>应该把复杂计算属性分割为尽可能多的更简单的属性。
</code></pre><h2 id="带引号的特性值（双引号）"><a href="#带引号的特性值（双引号）" class="headerlink" title="带引号的特性值（双引号）"></a>带引号的特性值（双引号）</h2><pre><code>非空 HTML 特性值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。
</code></pre><h2 id="指令缩写"><a href="#指令缩写" class="headerlink" title="指令缩写"></a>指令缩写</h2><pre><code>指令缩写 (用 : 表示 v-bind: 和用 @ 表示 v-on:) 应该要么都用要么都不用。
</code></pre><h2 id="组件-实例的选项的顺序"><a href="#组件-实例的选项的顺序" class="headerlink" title="组件/实例的选项的顺序"></a>组件/实例的选项的顺序</h2><pre><code>组件/实例的选项应该有统一的顺序。
副作用 (触发组件外的影响)
    el
全局感知 (要求组件以外的知识)
    name
    parent
组件类型 (更改组件的类型)
    functional
模板修改器 (改变模板的编译方式)
    delimiters
    comments
模板依赖 (模板内使用的资源)
    components
    directives
    filters
组合 (向选项里合并属性)
    extends
    mixins
接口 (组件的接口)
    inheritAttrs
    model
    props/propsData
本地状态 (本地的响应式属性)
    data
    computed
事件 (通过响应式事件触发的回调)
    watch
生命周期钩子 (按照它们被调用的顺序)
非响应式的属性 (不依赖响应系统的实例属性)
    methods
渲染 (组件输出的声明式描述)
    template/render
    renderError
</code></pre><h2 id="元素特性的顺序"><a href="#元素特性的顺序" class="headerlink" title="元素特性的顺序"></a>元素特性的顺序</h2><pre><code>元素 (包括组件) 的特性应该有统一的顺序。    
定义 (提供组件的选项)
    is
列表渲染 (创建多个变化的相同元素)
    v-for
条件渲染 (元素是否渲染/显示)
    v-if
    v-else-if
    v-else
    v-show
    v-cloak
渲染方式 (改变元素的渲染方式)
    v-pre
    v-once
全局感知 (需要超越组件的知识)
    id
唯一的特性 (需要唯一值的特性)
    ref
    key
    slot
双向绑定 (把绑定和事件结合起来)
    v-model
其它特性 (所有普通的绑定或未绑定的特性)
事件 (组件事件监听器)
    v-on
内容 (复写元素的内容)
    v-html
    v-text
</code></pre><h2 id="组件-实例选项中的空行"><a href="#组件-实例选项中的空行" class="headerlink" title="组件/实例选项中的空行"></a>组件/实例选项中的空行</h2><pre><code>你可能想在多个属性之间增加一个空行，特别是在这些选项一屏放不下，
需要滚动才能都看到的时候。
</code></pre><h2 id="单文件组件的顶级元素的顺序"><a href="#单文件组件的顶级元素的顺序" class="headerlink" title="单文件组件的顶级元素的顺序"></a>单文件组件的顶级元素的顺序</h2><pre><code>单文件组件应该总是让 template、script 和 style 标签的顺序保持一致。
且 &lt;style&gt; 要放在最后，因为另外两个标签至少要有一个。
&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;style&gt;/* ... */&lt;/style&gt;
</code></pre><h2 id="没有在-v-if-v-if-else-v-else-中使用-key-谨慎使用"><a href="#没有在-v-if-v-if-else-v-else-中使用-key-谨慎使用" class="headerlink" title="没有在 v-if/v-if-else/v-else 中使用 key 谨慎使用"></a>没有在 v-if/v-if-else/v-else 中使用 key 谨慎使用</h2><pre><code>如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 &lt;div&gt; 元素)。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;error&quot; key=&quot;search-status&quot;&gt;</span><br><span class="line">  错误：&#123;&#123; error &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else key=&quot;search-results&quot;&gt;</span><br><span class="line">  &#123;&#123; results &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="scoped-中的元素选择器-谨慎使用"><a href="#scoped-中的元素选择器-谨慎使用" class="headerlink" title="scoped 中的元素选择器 谨慎使用"></a>scoped 中的元素选择器 谨慎使用</h2><pre><code>元素选择器应该避免在 scoped 中出现。
</code></pre><h2 id="隐性的父子组件通信-谨慎使用"><a href="#隐性的父子组件通信-谨慎使用" class="headerlink" title="隐性的父子组件通信 谨慎使用"></a>隐性的父子组件通信 谨慎使用</h2><pre><code>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;TodoItem&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">	todo: &#123;</span><br><span class="line">	  type: Object,</span><br><span class="line">	  required: true</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">	&lt;input</span><br><span class="line">	  :value=&quot;todo.text&quot;</span><br><span class="line">	  @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;</span><br><span class="line">	&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="非-Flux-的全局状态管理-谨慎使用"><a href="#非-Flux-的全局状态管理-谨慎使用" class="headerlink" title="非 Flux 的全局状态管理 谨慎使用"></a>非 Flux 的全局状态管理 谨慎使用</h2><pre><code>应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://cn.vuejs.org/v2/style-guide" target="_blank" rel="noopener">vue代码指南</a></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue官网-选项解读</title>
    <url>/2017/vue%E5%AE%98%E7%BD%91-%E9%80%89%E9%A1%B9%E8%A7%A3%E8%AF%BB.html</url>
    <content><![CDATA[<h2 id="选项-数据"><a href="#选项-数据" class="headerlink" title="选项/数据"></a>选项/数据</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">	data() &#123;            // 声明所有的根级响应式属性</span><br><span class="line">		return &#123;&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	props: &#123;&#125;,          // 父组件传递过来的属性</span><br><span class="line">	propsData: &#123;&#125;,      // 只能用于 new 创建的实例时传递 props。主要作用是方便测试</span><br><span class="line">	methods: &#123;&#125;,		// 组件相关的方法</span><br><span class="line">	computed: &#123;&#125;,		// 组件的计算属性</span><br><span class="line">	watch: &#123;&#125;,			// 监听组件的 data 中数据变化执行对应函数	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><pre><code>类型：Object | Function（对于组件只是使用这种方式，并且返回一个纯对象）
作用：Vue 实例的数据对象。
最佳实践：data中需要声明所有的根级响应式属性。
    有些时候想为 data 添加新数据。Vue.set( target, key, value )；target 可以是Object 和 Array(多个VUE实例对象)， key 为对应数据的键，value 为对应数据的值。
    对应还有 Vue.delete( target, key ) 移除VUE实例对象指定key的属性。
数据驱动的原理：Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。
    属性通过 Object.defineProperty(obj, prop, descriptor) 来实现数据驱动。
</code></pre><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><pre><code>类型：Array&lt;string&gt; | Object
作用：用于接收来自父组件的数据。对象允许配置高级选项，如是否必填（required）、
类型检测（type）、自定义校验（validator函数）和设置默认值（default）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 对象语法，提供校验</span><br><span class="line">Vue.component(&apos;props-demo-advanced&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">	// 检测类型</span><br><span class="line">	height: Number,</span><br><span class="line">	// 检测类型 + 其他验证</span><br><span class="line">	age: &#123;</span><br><span class="line">	  type: Number,</span><br><span class="line">	  default: 0,</span><br><span class="line">	  required: true,</span><br><span class="line">	  validator: function (value) &#123;</span><br><span class="line">		return value &gt;= 0</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h3><pre><code>类型：{ [key: string]: any }
作用：只能用于 new 创建的实例时传递 props。主要作用是方便测试。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  propsData: &#123;</span><br><span class="line">	msg: &apos;hello&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><pre><code>类型：{ [key: string]: Function | { get: Function, set: Function } }
作用：计算属性的结果会被缓存，除非依赖的响应式属性（data中的数据）变化才会重新计算。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">	// 仅读取</span><br><span class="line">	aDouble: function () &#123;</span><br><span class="line">	  return this.a * 2</span><br><span class="line">	&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 组件类使用</span><br><span class="line">this.aDouble</span><br><span class="line">// 组件外使用</span><br><span class="line">vm.aDouble</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><pre><code>类型：{ [key: string]: Function }
作用：为组件定义方法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">	plus: function () &#123;</span><br><span class="line">	  this.a++</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 组件内使用</span><br><span class="line">this.plus()</span><br><span class="line">// 组件外使用</span><br><span class="line">vm.plus()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><pre><code>类型：{ [key: string]: string | Function | Object }
作用：键是需要观察的表达式data中的属性，值是对应回调函数。值也可以是方法名，或者包含选项的对象
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">	a: 1,</span><br><span class="line">	b: 2,</span><br><span class="line">	c: 3</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">	a: function (val, oldVal) &#123;</span><br><span class="line">	  console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">	&#125;,</span><br><span class="line">	// 方法名</span><br><span class="line">	b: &apos;someMethod&apos;,</span><br><span class="line">	// 深度 watcher</span><br><span class="line">	c: &#123;</span><br><span class="line">	  handler: function (val, oldVal) &#123; /* ... */ &#125;,</span><br><span class="line">	  deep: true</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="选项-DOM"><a href="#选项-DOM" class="headerlink" title="选项/DOM"></a>选项/DOM</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  template: &apos;&lt;div&gt;我是模板&lt;/div&gt;&apos;,</span><br><span class="line">  render (h) &#123;</span><br><span class="line">	throw new Error(&apos;oops&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderError (h, err) &#123;</span><br><span class="line">	return h(&apos;pre&apos;, &#123; style: &#123; color: &apos;red&apos; &#125;&#125;, err.stack)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><pre><code>类型：string | HTMLElement
作用：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标（只在由 new 创建的实例中遵守）。
</code></pre><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><pre><code>类型：string    
作用：一个字符串模板作为 Vue 实例的标识使用。
</code></pre><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><pre><code>类型：(createElement: () =&gt; VNode) =&gt; VNode
作用：字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。
</code></pre><h3 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a>renderError</h3><pre><code>类型：(createElement: () =&gt; VNode, error: Error) =&gt; VNode
作用：当 render 函数遭遇错误时，提供另外一种渲染输出。
</code></pre><h2 id="选项-生命周期钩子（函数）"><a href="#选项-生命周期钩子（函数）" class="headerlink" title="选项/生命周期钩子（函数）"></a>选项/生命周期钩子（函数）</h2><pre><code>在组件的具体某个过程触发相应的函数
可以理解为：创建 -&gt; 挂载 -&gt; 更新 -&gt; 激活 -&gt; 销毁
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">	beforeCreate() &#123;&#125;, // 实例初始化之后</span><br><span class="line">	created() &#123;&#125;,      // 在实例创建完成后被立即调用</span><br><span class="line">	beforeMount() &#123;&#125;,  // 在挂载开始之前被调用</span><br><span class="line">	mounted() &#123;&#125;,      // 实例挂载到 DOM 节点</span><br><span class="line">	beforeUpdate() &#123;&#125;, // 数据更新时调用</span><br><span class="line">	updated() &#123;&#125;,      // 数据更新完成后调用</span><br><span class="line">	activated() &#123;&#125;,    // keep-alive 组件激活时调用</span><br><span class="line">	deactivated() &#123;&#125;,  // keep-alive 组件停用时调用</span><br><span class="line">	beforeDestory() &#123;&#125;,// 实例销毁之前调用</span><br><span class="line">	destoryed() &#123;&#125;     // 实例销毁后调用。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

详细信息请看官网-生命周期图示
</code></pre><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="生命周期图示"></p>
<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><pre><code>执行时机：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。
</code></pre><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><pre><code>执行时机：在实例创建完成后被立即调用。完成以下任务：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调，但实例并没有挂载到真实节点。
</code></pre><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><pre><code>执行时机：在挂载开始之前被调用：相关的 render 函数首次被调用。
</code></pre><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><pre><code>执行时机：当实例挂载到文档 DOM 元素时触发。
注意 mounted 不会保证所有的子组件也都一起被挂载，下面可以保证所有子组件都一起被挂起。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">	// 整个视图页面全部渲染时触发，类似于jquery的ready方法。</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><pre><code>执行时机：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。
</code></pre><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><pre><code>执行时机：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
    此时可以进行 DOM 操作。
</code></pre><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><pre><code>执行时机：keep-alive 组件激活时调用。
</code></pre><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><pre><code>执行时机：keep-alive 组件停用时调用。    
</code></pre><h3 id="beforeDestory"><a href="#beforeDestory" class="headerlink" title="beforeDestory"></a>beforeDestory</h3><pre><code>执行时机：实例销毁之前调用。在这一步，实例仍然完全可用。
</code></pre><h3 id="destoryed"><a href="#destoryed" class="headerlink" title="destoryed"></a>destoryed</h3><pre><code>执行时机：Vue 实例销毁后调用。
</code></pre><h2 id="选项-资源"><a href="#选项-资源" class="headerlink" title="选项/资源"></a>选项/资源</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;,</span><br><span class="line">	directives: &#123;&#125;, // 注册局部指令</span><br><span class="line">	filters: &#123;&#125;,    // 注册局部过滤器</span><br><span class="line">	compoents: &#123;&#125;   // 注册局部组件 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><pre><code>类型：Object
1.注册自定义指令（全局）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当绑定元素插入到 DOM 中。</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;,</span><br><span class="line">	// directives: &#123;&#125; 注册局部指令</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

这里指令的钩子函数：bind、inserted、update、componentUpdated、unbind
每个钩子函数的参数：(包括 el，binding，vnode，oldVnode)。
2.使用自定义指令
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;input v-focus&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><pre><code>类型：Object
1.注册全局过滤器
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.filter(&apos;add4&apos;, function (value) &#123;</span><br><span class="line">return value + 4;</span><br><span class="line">  // 返回处理后的值</span><br><span class="line">&#125;);</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;,</span><br><span class="line">	data() &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			num: 10</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	// filters: &#123;&#125; 注册局部过滤器</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

2.使用过滤器
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;p&gt;10 + 4 = &#123;&#123;num | add4&#125;&#125;&lt;/p&gt; // 14</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="compoents（局部组件的注册）"><a href="#compoents（局部组件的注册）" class="headerlink" title="compoents（局部组件的注册）"></a>compoents（局部组件的注册）</h3><pre><code>类型：Object
1.注册全局组件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;);</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;,</span><br><span class="line">	data() &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			num: 10</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	// components: &#123;&#125; 注册局部组件</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

2.使用组件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;my-component /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="选项-组合"><a href="#选项-组合" class="headerlink" title="选项/组合"></a>选项/组合</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import parentComponent from &apos;./path&apos;;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;,</span><br><span class="line">	parent: parentComponent, // 定义当前组件的父组件</span><br><span class="line">	minxins: [mixin],        // 定义局部混合逻辑（引入的先触发）</span><br><span class="line">	extends: CompA           // 定义局部继承（自身的先触发）</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><pre><code>类型：Vue instance
作用：指定已创建的实例的父实例，在两者之间建立父子关系。
    子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。
</code></pre><h3 id="minxins"><a href="#minxins" class="headerlink" title="minxins"></a>minxins</h3><pre><code>类型：Array&lt;Object&gt;
作用：混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。
混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被
混入该组件本身的选项。
1.创建局部混合
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mixin = &#123;</span><br><span class="line">  created: function () &#123;</span><br><span class="line">	console.log(&apos;混合对象的钩子被调用&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

2.使用混合
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  mixins: [mixin], // 这里使用</span><br><span class="line">  created: function () &#123;</span><br><span class="line">	console.log(&apos;组件钩子被调用&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

这里需要说明：混合对象的 钩子将在组件自身钩子 之前 调用。 
</code></pre><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><pre><code>类型：Object | Function
作用：允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。
    这和 mixins 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var CompA = &#123; ... &#125;</span><br><span class="line">// 在没有调用 `Vue.extend` 时候继承 CompA</span><br><span class="line">var CompB = &#123;</span><br><span class="line">  extends: CompA,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h3><pre><code>provide：Object | () =&gt; Object
inject：Array&lt;string&gt; | { [key: string]: string | Symbol }
说明：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。
</code></pre><h2 id="选项-其它"><a href="#选项-其它" class="headerlink" title="选项/其它"></a>选项/其它</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><pre><code>类型：string    
作用：只有作为组件选项时起作用，并为组件命名。
最佳实践：为每个组件命名，利于 vue-devtools 调试。
</code></pre><h3 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h3><pre><code>类型：Array&lt;string&gt;
作用：改变纯文本插入分隔符。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  delimiters: [&apos;$&#123;&apos;, &apos;&#125;&apos;]</span><br><span class="line">&#125;);</span><br><span class="line">// 分隔符变成了 ES6 模板字符串的风格</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h3><pre><code>类型：boolean
作用：使组件无状态 (没有 data ) 和无实例 (没有 this 上下文)。
</code></pre><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><pre><code>类型：{ prop?: string, event?: string }
作用：允许一个自定义组件在使用 v-model 时定制 prop 和 event。
</code></pre><h3 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h3><pre><code>类型：boolean
作用：默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。
</code></pre><h3 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h3><pre><code>类型：boolean
作用：当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://cn.vuejs.org/v2/api" target="_blank" rel="noopener">官方api</a></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue  end</title>
    <url>/2017/vue-end.html</url>
    <content><![CDATA[<h2 id="今天完成后台界面中引入iconfont图标和添加全屏功能screenfull"><a href="#今天完成后台界面中引入iconfont图标和添加全屏功能screenfull" class="headerlink" title="今天完成后台界面中引入iconfont图标和添加全屏功能screenfull"></a>今天完成后台界面中引入<a href="http://www.iconfont.cn" target="_blank" rel="noopener">iconfont</a>图标和添加全屏功能<a href>screenfull</a></h2><p><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="引入iconfont图标，这是阿里的开源产品，个人感觉不错，其中symbol方式应该会成为未来的主流方式（不支持ie8）"><a href="#引入iconfont图标，这是阿里的开源产品，个人感觉不错，其中symbol方式应该会成为未来的主流方式（不支持ie8）" class="headerlink" title="引入iconfont图标，这是阿里的开源产品，个人感觉不错，其中symbol方式应该会成为未来的主流方式（不支持ie8）"></a>引入iconfont图标，这是阿里的开源产品，个人感觉不错，其中symbol方式应该会成为未来的主流方式（不支持ie8）</h3><ol>
<li>进入iconfont后，创建项目，把自己喜欢的图标都放到项目中去，点击下载这里我们只需要iconfont.js文件</li>
<li><p>在main.js中引入 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;@/assets/icon-font/iconfont&apos; // 引入iconfont图库</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里我把它单独封装一个组件，以便其他地方使用(直接贴上源码了，都能看懂)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;svg class=&quot;icon&quot; :style=&quot;&#123;width: width + &apos;em&apos;, height: height + &apos;em&apos;, verticalAlign: verticalAlign + &apos;em&apos;&#125;&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">	  &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt;</span><br><span class="line">	&lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">	name: &apos;iconfont&apos;,</span><br><span class="line">	props: &#123;</span><br><span class="line">		icon: &#123;</span><br><span class="line">			type: String,</span><br><span class="line">			required: true </span><br><span class="line">		&#125;,</span><br><span class="line">		width: &#123;</span><br><span class="line">			type: Number,</span><br><span class="line">			default: 1</span><br><span class="line">		&#125;,</span><br><span class="line">		height: &#123;</span><br><span class="line">			type: Number,</span><br><span class="line">			default: 1</span><br><span class="line">		&#125;,</span><br><span class="line">		verticalAlign: &#123;</span><br><span class="line">			type: Number,</span><br><span class="line">			default: -0.15</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	data () &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		iconName () &#123;</span><br><span class="line">			return `#$&#123;this.icon&#125;`</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .icon &#123;</span><br><span class="line">	   fill: currentColor;</span><br><span class="line">	   overflow: hidden;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用的时候</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iconfont icon=&quot;icon-daxiang&quot; :width=&quot;2&quot; :height=&quot;2&quot; :verticalAlign=&quot;-0.5&quot;&gt;&lt;/iconfont&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="添加全屏功能"><a href="#添加全屏功能" class="headerlink" title="添加全屏功能"></a>添加全屏功能</h3><ol>
<li>安装依赖 npm i screenfull -S</li>
<li>我还是封装成组件，一遍其他项目使用(贴原代码) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;iconfont @click.native=&quot;toggleFullScreen&quot; :icon=&quot;iconType&quot;&gt;&lt;/iconfont&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import screenfull from &apos;screenfull&apos;</span><br><span class="line">import iconfont from &apos;@/components/iconfont&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">	name: &apos;screenfull&apos;,</span><br><span class="line">	data () &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">		isFullscreen: false,</span><br><span class="line">		iconType: &apos;icon-quanping&apos;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		toggleFullScreen () &#123;</span><br><span class="line">			if (!screenfull.enabled) &#123;</span><br><span class="line">				this.$message(&#123;</span><br><span class="line">				  message: &apos;you browser can not work&apos;,</span><br><span class="line">				  type: &apos;warning&apos;</span><br><span class="line">				&#125;);</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			this.iconType = this.isFullscreen ? &apos;icon-quanping&apos; : &apos;icon-tuichuquanping&apos;</span><br><span class="line">			screenfull.toggle()</span><br><span class="line">			this.isFullscreen = !this.isFullscreen</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	components: &#123;</span><br><span class="line">		iconfont</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>后台系统，先做的这里，以后在添加。打算接着撸一段事件的函数式编程</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件开发方法总结</title>
    <url>/2017/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<p><em>VUE 组件的三种开发方式</em><br><strong>    开发组件大致分为3个步骤： 组件声明-组件注册（全局和局部）-组件使用</strong></p>
<h1 id="使用-script-标签"><a href="#使用-script-标签" class="headerlink" title="使用 script 标签"></a>使用 script 标签</h1><pre><code>1.组件声明
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注意：使用&lt;script&gt;标签时，type指定为text/x-template，意在告诉浏览器这不是一段js脚本，浏览器在解析HTML文档时会忽略&lt;script&gt;标签内定义的内容。--&gt;	</span><br><span class="line">&lt;!-- type 和 id 必须要填写 --&gt;</span><br><span class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;myComponent&quot;&gt;</span><br><span class="line">	&lt;!--只能有一个根节点，下面两种方式同样遵循--&gt;</span><br><span class="line">       &lt;div class=&quot;root&quot;&gt;</span><br><span class="line">		&lt;p&gt;我是p1&lt;/p&gt;</span><br><span class="line">		&lt;p&gt;我是p2&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure>

2.组件注册（分为全局注册和局部注册）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局注册：需要确保在根实例初始化之前注册，这样才能使组件在任意实例中都可以使用。</span><br><span class="line">	Vue.component(&apos;my-component&apos;,MyComponent);//此句一定要放在new Vue(&#123;...&#125;);之前</span><br><span class="line">局部注册：限定了组件只能在被注册的组件中使用，而无法在其他组件中使用。</span><br><span class="line">//全局注册组件</span><br><span class="line">Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">	template: &apos;#myComponent&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

3.组件使用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">       &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>

本例全部代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&lt;!--3.组件使用--&gt;</span><br><span class="line">			&lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!--1.组件声明--&gt;</span><br><span class="line">		&lt;script type=&quot;text/x-template&quot; id=&quot;myComponent&quot;&gt;</span><br><span class="line">			&lt;div&gt;This is a component!&lt;/div&gt;</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">	&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		&lt;!--2.组件注册--&gt;</span><br><span class="line">		Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">			template: &apos;#myComponent&apos;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		new Vue(&#123;</span><br><span class="line">			el: &apos;#app&apos;</span><br><span class="line">		&#125;);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="使用-template-标签"><a href="#使用-template-标签" class="headerlink" title="使用 template 标签"></a>使用 template 标签</h1><pre><code>1.组件声明
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;myComponent&quot;&gt;</span><br><span class="line">       &lt;div&gt;This is a component!&lt;/div&gt;</span><br><span class="line">   &lt;/template&gt;</span><br></pre></td></tr></table></figure>

2.组件注册
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">	template: &apos;#myComponent&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

3.使用组件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">       &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>

本例全部代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&lt;!--3.组件使用--&gt;</span><br><span class="line">			&lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!--1.组件声明--&gt;</span><br><span class="line">		&lt;template id=&quot;myComponent&quot;&gt;</span><br><span class="line">			&lt;div&gt;This is a component!&lt;/div&gt;</span><br><span class="line">		&lt;/template&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">	&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		&lt;!--2.组件注册--&gt;</span><br><span class="line">		Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">			template: &apos;#myComponent&apos;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		new Vue(&#123;</span><br><span class="line">			el: &apos;#app&apos;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><pre><code>注：这种方法常用在vue单页应用中。
1.创建组件（hello.vue）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">	&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;hello&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">	  msg: &apos;欢迎！&apos;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

父组件代码（app.vue，这里app.vue为hello.vue的父组件）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 展示模板 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;!-- 3.使用组件 --&gt;</span><br><span class="line">	&lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 导入组件</span><br><span class="line">import Hello from &apos;./components/hello&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  // 2.这里进行组件局部注册</span><br><span class="line">  components: &#123;</span><br><span class="line">	Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a><br>    <a href="http://blog.csdn.net/u012123026/article/details/72460470" target="_blank" rel="noopener">vue组件的3种书写形式</a><br>    <a href="http://blog.csdn.net/u013910340/article/details/72763418" target="_blank" rel="noopener">vue.js中组件的创建和使用方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件通信的方式总结</title>
    <url>/2017/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h1><pre><code>父组件通过 props 向子组件传递数据，子组件通过执行父组件的方法，通知父组件子组件所发生的变化。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;one-address :addressitems=&quot;addressitems&quot; @edit-address=&quot;editAddress&quot;&gt;&lt;/one-address&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;div&gt;&#123;&#123; addressitems.partment &#125;&#125;&#123;&#123; addressitems.address &#125;&#125;&lt;/div&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">	addressitems: Object</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">	 editAddress () &#123;</span><br><span class="line">	  this.$emit(&apos;edit-address&apos;, false)</span><br><span class="line">	 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h1><pre><code>非父子组件通信同样也可以用Vue.$emit自定义事件来解决
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bus = new Vue();</span><br><span class="line">// 组件A</span><br><span class="line">bus.$emit(&apos;id-selected&apos;, 1);</span><br><span class="line">// 组件B</span><br><span class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class="line"> console.log(id)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="vue跨组件跨模块通信"><a href="#vue跨组件跨模块通信" class="headerlink" title="vue跨组件跨模块通信"></a>vue跨组件跨模块通信</h1><pre><code>使用 vuex
vuex有四个核心概念，其中state和getters主要是用于数据的存储与输出，
而mutations和actions是用于提交事件并修改state中的数据。
这里盗取vuex官网图，需要详细了解请访问[vuex](https://vuex.vuejs.org)
</code></pre><p><img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" alt="vuex原理图"></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.jianshu.com/p/a78277be91d0" target="_blank" rel="noopener">vue组件之间的多种通信方法</a><br>    <a href="http://whutzkj.space/2017/08/05/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/#more" target="_blank" rel="noopener">vue组件之间的通信（一）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>从对象的遍历到浅拷贝的思考</title>
    <url>/2017/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E5%88%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%80%9D%E8%80%83.html</url>
    <content><![CDATA[<p>我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有<span style="color: red;">String</span>类型，ES6之后对象的属性有<span style="color: red;">String和Symbol类型</span>。<br>由于文章上下文关系，本文将按照’属性描述符’-&gt;’对象的属性遍历方法介绍’-&gt;’现代ECMAScript对象的浅拷贝’进行介绍，现代ECMAScript对象的深拷贝比较复杂，有时间在分析。</p>
<h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。</p>
<h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p>
<h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p>
<h2 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</p>
<h2 id="属性描述符的读写操作"><a href="#属性描述符的读写操作" class="headerlink" title="属性描述符的读写操作"></a>属性描述符的读写操作</h2><p>我们可以通过Object.getOwnPropertyDescriptor(o,name)、Object.getOwnPropertyDescriptors(obj)来查看属性描述符，<br>通过Object.defineProperty(o,name,desc)、Object.defineProperties(o,descriptors)、Object.create(proto,descriptors)等方法来更改属性描述符。</p>
<h1 id="对象的属性遍历方法介绍"><a href="#对象的属性遍历方法介绍" class="headerlink" title="对象的属性遍历方法介绍"></a>对象的属性遍历方法介绍</h1><p>上面，我们了解了属性描述符，其中枚举这个属性描述符，在不同方法对对象属性的遍历过程产生的作用差异很大，下面我开始介绍如何遍历对象的属性。<br><strong>本小结的测试代码，我就不贴出来了，都很简单，我这里直接给出结论，感兴趣的朋友可以自己尝试。</strong></p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>定义：for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (item in object) &#123;...&#125;</span><br><span class="line">// itme--在每次迭代时，将不同的属性名分配给变量。</span><br><span class="line">// object--被迭代枚举其属性的对象。</span><br></pre></td></tr></table></figure></p>
<p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.可以遍历对象自身和原型链上可枚举的属性<br>2.任意顺序，说明遍历的属性先后顺序不定（不同运行环境顺序不同）。不建议对数组使用for…in来遍历主要原因就是这个，另一方面为性能考虑for…in还会遍历到原型链上的可枚举属性。</p>
<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>定义：Object.keys() 方法会返回一个由该对象的自身的可枚举属性组成的数组。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.keys(obj)</span><br><span class="line">// obj--要返回其枚举自身属性的对象。</span><br></pre></td></tr></table></figure></p>
<p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性是可枚举的<br>3.任意顺序，枚举属性的顺序和for…in/Object.getOwnPropertyNames(obj)一致<br>4.返回一个所有元素为字符串（不包括Symbol）的数组</p>
<h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>定义：Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.getOwnPropertyNames(obj)</span><br><span class="line">// obj--一个对象，其自身的可枚举和不可枚举属性的名称被返回。</span><br></pre></td></tr></table></figure></p>
<p>PS：这里我们需要记住该方法遍历属性的特点：<br>1.属性是自身的<br>2.属性了枚举和不可枚举都可以遍历<br>3.任意顺序，枚举属性的顺序和for…in/Object.keys(obj)一致</p>
<h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>定义：Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.getOwnPropertySymbols(obj)</span><br><span class="line">// obj--要返回 Symbol 属性的对象。</span><br></pre></td></tr></table></figure></p>
<p>PS：<br>1.属性是自身的<br>2.属性为Symbol类型</p>
<h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><p>定义：Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reflect.ownKeys(target)</span><br><span class="line">// target--获取自身属性键的目标对象。</span><br></pre></td></tr></table></figure></p>
<p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>这里看，似乎能遍历出自身的所有属性，还差原型连上的属性。</p>
<h2 id="总结下上面的方法"><a href="#总结下上面的方法" class="headerlink" title="总结下上面的方法"></a>总结下上面的方法</h2><p>为了好归纳，我这里将对象的属性分为以下类别：1.自身可枚举的属性，2.自身不可枚举的属性，3.Symbol类型的属性，4.原型链上的可枚举属性，5.原型链上的不可枚举属性，6.原型链上的Symbol属性<strong>2018-03-16更新</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">可遍历的属性类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>for…in</td>
<td style="text-align:center">1，4</td>
</tr>
<tr>
<td>Object.keys()</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>Object.getOwnPropertyNames()</td>
<td style="text-align:center">1，2</td>
</tr>
<tr>
<td>Object.getOwnPropertySymbols()</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td>Reflect.ownKeys()</td>
<td style="text-align:center">1，2，3</td>
</tr>
</tbody>
</table>
<p>从上表分析，还没有一个方法能完美解决，我们只能组合使用了。<br>PS：除了for…in其余方法均返回数组。</p>
<h1 id="现代ECMAScript对象的浅拷贝"><a href="#现代ECMAScript对象的浅拷贝" class="headerlink" title="现代ECMAScript对象的浅拷贝"></a>现代ECMAScript对象的浅拷贝</h1><p>本小节会我们会实现各种浅拷贝，并分析各自的劣势，最终我们将实现一种比较完美的方法（暂不考虑兼容性）。</p>
<h2 id="现看一个以前实现的方法"><a href="#现看一个以前实现的方法" class="headerlink" title="现看一个以前实现的方法"></a>现看一个以前实现的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function shallowCopy (obj) &#123;</span><br><span class="line">  if (typeof obj !== &apos;object&apos;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  var newObj = obj instanceof Array ? [] : &#123;&#125;</span><br><span class="line">  for (var key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这中方法对于ES6之前的确可行，毕竟我也用过这样的方法，有了Symbol之后这个就不再正确了。</p>
<h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><blockquote>
<p>   该方式在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。<br>不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的 对象 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们</p>
</blockquote>
<h2 id="Object-assign-和-展开运算符（…）"><a href="#Object-assign-和-展开运算符（…）" class="headerlink" title="Object.assign 和 展开运算符（…）"></a>Object.assign 和 展开运算符（…）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name: &apos;yzf&apos;,</span><br><span class="line">	age: 100,</span><br><span class="line">	sex: &apos;male&apos;,</span><br><span class="line">	[Symbol()]: &apos;symbol1&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = Object.assign(&#123;&#125;, obj)</span><br><span class="line">// obj2</span><br><span class="line">&#123;</span><br><span class="line">	name: &apos;yzf&apos;,</span><br><span class="line">	age: 100,</span><br><span class="line">	sex: &apos;male&apos;,</span><br><span class="line">	[Symbol()]: &apos;symbol1&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的定义：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。<br>特点：自身的可枚举的包括Symbol类型的，不包括不可枚举的属性和原型链上的属性，不完美。</p>
<h2 id="Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors"><a href="#Object-create-Object-getPrototypeOf-Object-getOwnPropertyDescriptors" class="headerlink" title="Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()"></a>Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()</h2><p>首先需要介绍一下相关的方法，ES7的Object.getOwnPropertyDescriptors()。</p>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>定义：Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">// 需要获取自身属性的对象。</span><br></pre></td></tr></table></figure></p>
<p>PS：<br>1.属性是自身的<br>2.属性可以是字符串或Symbol<br>3.属性是可枚举或不可枚举<br>4.包括了集体属性的描述符（value）<br>到这里似乎我们已经找到了，比较完美的解决方案了，我们来组合一下这3个方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// obj为需要浅拷贝的对象</span><br><span class="line">let obj1 = Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj), </span><br><span class="line">  Object.getOwnPropertyDescriptors(obj) </span><br><span class="line">)</span><br><span class="line">// obj1就是我们浅拷贝的得到的对象。</span><br></pre></td></tr></table></figure></p>
<p>PS：obj1对象通过Object.create()方法指定了自身的原型链（从原型链继承了相关属性），然后在通过Object.getOwnPropertyDescriptors()方法把自身的（包括可枚举的、不可枚举的、Symbol类型的）全部添加obj1上，这样是实现了我们的真正意义上的浅拷贝。 </p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>数组的浅拷贝ary.slice()、 ary.concat()、[…ary]、JSON.parse(JSON.stringify(ary))<br><a href="https://fanerge.github.io/">期望加入一个技术氛围nice的团队-成都</a></p>
<blockquote>
<p>   参考文档：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="noopener">Object.getOwnPropertySymbols</a><br><a href="https://github.com/Alvin-Liu/Blog/issues/8" target="_blank" rel="noopener">ES6时代，你真的会克隆对象吗？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>前端同学需要了解的通信知识</title>
    <url>/2017/%E5%89%8D%E7%AB%AF%E5%90%8C%E5%AD%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h1 id="head、options、get、put、post、delete含义与区别"><a href="#head、options、get、put、post、delete含义与区别" class="headerlink" title="head、options、get、put、post、delete含义与区别"></a>head、options、get、put、post、delete含义与区别</h1><pre><code>了解它们的区别，这对于 RESTful架构 来说非常有意义。
</code></pre><p>如果你还不知道什么叫 <a href="https://fanerge.github.io/2017/10/13/RESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/">RESTful架构</a>？</p>
<h2 id="HEAD请求（判断资源是否存在）"><a href="#HEAD请求（判断资源是否存在）" class="headerlink" title="HEAD请求（判断资源是否存在）"></a>HEAD请求（判断资源是否存在）</h2><pre><code>HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。
有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，
我们通常使用GET，但这里用HEAD则意义更加明确。
</code></pre><h2 id="OPTIONS请求（获取当前URL支持的方法）"><a href="#OPTIONS请求（获取当前URL支持的方法）" class="headerlink" title="OPTIONS请求（获取当前URL支持的方法）"></a>OPTIONS请求（获取当前URL支持的方法）</h2><pre><code>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。
若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
</code></pre><h2 id="POST请求（相当于数据库操作–增）"><a href="#POST请求（相当于数据库操作–增）" class="headerlink" title="POST请求（相当于数据库操作–增）"></a>POST请求（相当于数据库操作–增）</h2><pre><code>POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，
就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。
</code></pre><h2 id="DELETE请求（相当于数据库操作–删）"><a href="#DELETE请求（相当于数据库操作–删）" class="headerlink" title="DELETE请求（相当于数据库操作–删）"></a>DELETE请求（相当于数据库操作–删）</h2><pre><code>DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。
</code></pre><h2 id="PUT请求（相当于数据库操作–改）"><a href="#PUT请求（相当于数据库操作–改）" class="headerlink" title="PUT请求（相当于数据库操作–改）"></a>PUT请求（相当于数据库操作–改）</h2><pre><code>PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，
用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。
</code></pre><h2 id="GET请求（相当于数据库操作–查）"><a href="#GET请求（相当于数据库操作–查）" class="headerlink" title="GET请求（相当于数据库操作–查）"></a>GET请求（相当于数据库操作–查）</h2><pre><code>GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，
只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。
无论进行多少次操作，结果都是一样的。
</code></pre><h1 id="常见的-GET-和-POST-的区别（浅比较）"><a href="#常见的-GET-和-POST-的区别（浅比较）" class="headerlink" title="常见的 GET 和 POST 的区别（浅比较）"></a>常见的 GET 和 POST 的区别（浅比较）</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/get%E5%92%8Cpost.png" alt="get和post的区别"><br>    这些都是比较常见的，我就直接借用下<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">杨光</a>的总结。</p>
<h1 id="也许这才是面试官想要的"><a href="#也许这才是面试官想要的" class="headerlink" title="也许这才是面试官想要的"></a>也许这才是面试官想要的</h1><p>上面我们的分析都是从<a href="https://fanerge.github.io/2017/10/14/OSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">TCP/IP五层网络架构</a>中的 <span style="color: red;">应用层</span> 和 生产使用时做了区别，<br>这里我们就进入更底层的 <span style="color: red;">传输层 </span>的分析吧！</p>
<blockquote>
<p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>这里你只需要知道这个就好了，更详细请访问<a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="noopener">get与post的区别</a>。    </p>
</blockquote>
<h1 id="总结一下-http-状态码"><a href="#总结一下-http-状态码" class="headerlink" title="总结一下 http 状态码"></a>总结一下 http 状态码</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/http%E7%8A%B6%E6%80%81%E7%A0%81%E6%B1%87%E6%80%BB.png" alt="通用的http状态码"><br>    看着这些是不是有些头大，下面我为大家总结一些通用的状态码。<br>    100-199 用于指定客户端应相应的某些动作。<br>    200-299 用于表示请求成功。<br>    300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>    400-499 用于指出客户端的错误。<br>    500-599 用于支持服务器错误。</p>
<h2 id="1"><a href="#1" class="headerlink" title="1**"></a>1**</h2><h3 id="100-Continue-继续"><a href="#100-Continue-继续" class="headerlink" title="100 (Continue/继续)"></a>100 (Continue/继续)</h3><pre><code>如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。
在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端
不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 
</code></pre><h3 id="101-Switching-Protocols-转换协议"><a href="#101-Switching-Protocols-转换协议" class="headerlink" title="101 (Switching Protocols/转换协议)"></a>101 (Switching Protocols/转换协议)</h3><pre><code>指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 
</code></pre><h2 id="2"><a href="#2" class="headerlink" title="2**"></a>2**</h2><h3 id="200-OK-正常"><a href="#200-OK-正常" class="headerlink" title="200 (OK/正常)"></a>200 (OK/正常)</h3><pre><code>200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；
如果没有调用setStatus方法的话，就会得到200。 
</code></pre><h3 id="201-Created-已创建"><a href="#201-Created-已创建" class="headerlink" title="201 (Created/已创建)"></a>201 (Created/已创建)</h3><pre><code>201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。
</code></pre><h3 id="202-Accepted-接受"><a href="#202-Accepted-接受" class="headerlink" title="202 (Accepted/接受)"></a>202 (Accepted/接受)</h3><pre><code>202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。 
</code></pre><h3 id="203-Non-Authoritative-Information-非官方信息"><a href="#203-Non-Authoritative-Information-非官方信息" class="headerlink" title="203 (Non-Authoritative Information/非官方信息)"></a>203 (Non-Authoritative Information/非官方信息)</h3><pre><code>状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的
是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 
</code></pre><h3 id="204-No-Content-无内容"><a href="#204-No-Content-无内容" class="headerlink" title="204 (No Content/无内容)"></a>204 (No Content/无内容)</h3><pre><code>在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于
用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet
可能作如下操作： 
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pageVersion =Integer.parseInt(request.getParameter(&quot;pageVersion&quot;));</span><br><span class="line">if (pageVersion &gt;;= currentVersion) &#123;</span><br><span class="line">   response.setStatus(response.SC_NO_CONTENT);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	   // Create regular page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="205-Reset-Content-重置内容"><a href="#205-Reset-Content-重置内容" class="headerlink" title="205 (Reset Content/重置内容)"></a>205 (Reset Content/重置内容)</h3><pre><code>重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用
于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 
</code></pre><h3 id="206-Partial-Content-局部内容"><a href="#206-Partial-Content-局部内容" class="headerlink" title="206 (Partial Content/局部内容)"></a>206 (Partial Content/局部内容)</h3><pre><code>206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。
这是 HTTP 1.1中新加入的。 
</code></pre><h2 id="3"><a href="#3" class="headerlink" title="3**"></a>3**</h2><h3 id="300-Multiple-Choices-多重选择"><a href="#300-Multiple-Choices-多重选择" class="headerlink" title="300 (Multiple Choices/多重选择)"></a>300 (Multiple Choices/多重选择)</h3><pre><code>300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。
如果服务器有首选设置，首选项将会被列于定位响应头信息中。 
</code></pre><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 (Moved Permanently)"></a>301 (Moved Permanently)</h3><pre><code>永久性重定向。 
</code></pre><h3 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 (Move temporarily)"></a>302 (Move temporarily)</h3><pre><code>临时性重定向。
</code></pre><h3 id="303-See-Other-参见其他信息"><a href="#303-See-Other-参见其他信息" class="headerlink" title="303 (See Other/参见其他信息)"></a>303 (See Other/参见其他信息)</h3><pre><code>与301类似，使用GET和POST请求查看
</code></pre><h3 id="304-Not-Modified-未更改"><a href="#304-Not-Modified-未更改" class="headerlink" title="304 (Not Modified/未更改)"></a>304 (Not Modified/未更改)</h3><pre><code>当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后
有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被
更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这
个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程
已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化
和页面修正日期的例子)给出。 
</code></pre><h3 id="305-Use-Proxy-使用代理"><a href="#305-Use-Proxy-使用代理" class="headerlink" title="305 (Use Proxy/使用代理)"></a>305 (Use Proxy/使用代理)</h3><pre><code>305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="307-Temporary-Redirect-临时重定向"><a href="#307-Temporary-Redirect-临时重定向" class="headerlink" title="307 (Temporary Redirect/临时重定向)"></a>307 (Temporary Redirect/临时重定向)</h3><pre><code>与302类似，使用GET请求重定向。 
</code></pre><h2 id="4"><a href="#4" class="headerlink" title="4**"></a>4**</h2><h3 id="400-Bad-Request-错误请求"><a href="#400-Bad-Request-错误请求" class="headerlink" title="400 (Bad Request/错误请求)"></a>400 (Bad Request/错误请求)</h3><pre><code>400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。 
</code></pre><h3 id="401-Unauthorized-未授权"><a href="#401-Unauthorized-未授权" class="headerlink" title="401 (Unauthorized/未授权)"></a>401 (Unauthorized/未授权)</h3><pre><code>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。
这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。” 
</code></pre><h3 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 (Forbidden/禁止)"></a>403 (Forbidden/禁止)</h3><pre><code>403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于
服务器上的损坏文件或目录许可而引起。 
</code></pre><h3 id="404-Not-Found-未找到"><a href="#404-Not-Found-未找到" class="headerlink" title="404 (Not Found/未找到)"></a>404 (Not Found/未找到)</h3><pre><code>404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。
它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有
专门的方法实现它：sendError(&quot;message&quot;)。相对于setStatus使用sendError得好处是：服务器会自动
生成一个错误页来显示错误信息。
</code></pre><h3 id="405-Method-Not-Allowed-方法未允许"><a href="#405-Method-Not-Allowed-方法未允许" class="headerlink" title="405 (Method Not Allowed/方法未允许)"></a>405 (Method Not Allowed/方法未允许)</h3><pre><code>405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源
不允许使用。该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="406-Not-Acceptable-无法访问"><a href="#406-Not-Acceptable-无法访问" class="headerlink" title="406 (Not Acceptable/无法访问)"></a>406 (Not Acceptable/无法访问)</h3><pre><code>406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。
406是新加入 HTTP 1.1中的。 
</code></pre><h3 id="407-Proxy-Authentication-Required-代理服务器认证要求"><a href="#407-Proxy-Authentication-Required-代理服务器认证要求" class="headerlink" title="407 (Proxy Authentication Required/代理服务器认证要求)"></a>407 (Proxy Authentication Required/代理服务器认证要求)</h3><pre><code>407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。
该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头
信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="408-Request-Timeout-请求超时"><a href="#408-Request-Timeout-请求超时" class="headerlink" title="408 (Request Timeout/请求超时)"></a>408 (Request Timeout/请求超时)</h3><pre><code>408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="409-Conflict-冲突"><a href="#409-Conflict-冲突" class="headerlink" title="409 (Conflict/冲突)"></a>409 (Conflict/冲突)</h3><pre><code>该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="410-Gone-已经不存在"><a href="#410-Gone-已经不存在" class="headerlink" title="410 (Gone/已经不存在)"></a>410 (Gone/已经不存在)</h3><pre><code>410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。
410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="411-Length-Required-需要数据长度"><a href="#411-Length-Required-需要数据长度" class="headerlink" title="411 (Length Required/需要数据长度)"></a>411 (Length Required/需要数据长度)</h3><pre><code>411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端
发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="412-Precondition-Failed-先决条件错误"><a href="#412-Precondition-Failed-先决条件错误" class="headerlink" title="412 (Precondition Failed/先决条件错误)"></a>412 (Precondition Failed/先决条件错误)</h3><pre><code>412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="413-Request-Entity-Too-Large-请求实体过大"><a href="#413-Request-Entity-Too-Large-请求实体过大" class="headerlink" title="413 (Request Entity Too Large/请求实体过大)"></a>413 (Request Entity Too Large/请求实体过大)</h3><pre><code>413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。
如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="414-Request-URI-Too-Long-请求URI过长"><a href="#414-Request-URI-Too-Long-请求URI过长" class="headerlink" title="414 (Request URI Too Long/请求URI过长)"></a>414 (Request URI Too Long/请求URI过长)</h3><pre><code>414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、
域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。
该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="415-Unsupported-Media-Type-不支持的媒体格式"><a href="#415-Unsupported-Media-Type-不支持的媒体格式" class="headerlink" title="415 (Unsupported Media Type/不支持的媒体格式)"></a>415 (Unsupported Media Type/不支持的媒体格式)</h3><pre><code>415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="416-Requested-Range-Not-Satisfiable-请求范围无法满足"><a href="#416-Requested-Range-Not-Satisfiable-请求范围无法满足" class="headerlink" title="416 (Requested Range Not Satisfiable/请求范围无法满足)"></a>416 (Requested Range Not Satisfiable/请求范围无法满足)</h3><pre><code>416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。
奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。 
</code></pre><h3 id="417-Expectation-Failed-期望失败"><a href="#417-Expectation-Failed-期望失败" class="headerlink" title="417 (Expectation Failed/期望失败)"></a>417 (Expectation Failed/期望失败)</h3><pre><code>如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的
请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态
告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 
</code></pre><h2 id="5"><a href="#5" class="headerlink" title="5**"></a>5**</h2><h3 id="500-Internal-Server-Error-内部服务器错误"><a href="#500-Internal-Server-Error-内部服务器错误" class="headerlink" title="500 (Internal Server Error/内部服务器错误)"></a>500 (Internal Server Error/内部服务器错误)</h3><pre><code>500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能
（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。 
</code></pre><h3 id="501-Not-Implemented-未实现"><a href="#501-Not-Implemented-未实现" class="headerlink" title="501 (Not Implemented/未实现)"></a>501 (Not Implemented/未实现)</h3><pre><code>501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT
这样的服务器并不支持的命令。 
</code></pre><h3 id="502-Bad-Gateway-错误的网关"><a href="#502-Bad-Gateway-错误的网关" class="headerlink" title="502 (Bad Gateway/错误的网关)"></a>502 (Bad Gateway/错误的网关)</h3><pre><code>502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 
</code></pre><h3 id="503-Service-Unavailable-服务无法获得"><a href="#503-Service-Unavailable-服务无法获得" class="headerlink" title="503 (Service Unavailable/服务无法获得)"></a>503 (Service Unavailable/服务无法获得)</h3><pre><code>状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程
或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户
端什么时候可以在试一次。 
</code></pre><h3 id="504-Gateway-Timeout-网关超时"><a href="#504-Gateway-Timeout-网关超时" class="headerlink" title="504 (Gateway Timeout/网关超时)"></a>504 (Gateway Timeout/网关超时)</h3><pre><code>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。
该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="505-HTTP-Version-Not-Supported-不支持的-HTTP-版本"><a href="#505-HTTP-Version-Not-Supported-不支持的-HTTP-版本" class="headerlink" title="505 (HTTP Version Not Supported/不支持的 HTTP 版本)"></a>505 (HTTP Version Not Supported/不支持的 HTTP 版本)</h3><pre><code>505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。
该状态是新加入 HTTP 1.1的。
</code></pre><h1 id="http-缓存相关"><a href="#http-缓存相关" class="headerlink" title="http 缓存相关"></a>http 缓存相关</h1><p>这里关于前端仔 http缓存相关的知识，我就不再总结了，有兴趣的同学可以访问我<a href="https://fanerge.github.io/2017/09/01/http%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">http缓存相关的知识</a>。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/testcoffee/p/6295970.html" target="_blank" rel="noopener">get、put、post、delete含义与区别</a><br>    <a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">HTTP协议中GET和POST方法的区别</a><br>    <a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别</a><br>    <a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin" target="_blank" rel="noopener">有同学不好翻墙，就看百度的http状态码吧</a><br>    <a href="http://www.cnblogs.com/lxinxuan/archive/2009/10/22/1588053.html" target="_blank" rel="noopener">HTTP状态码大全</a></p>
</blockquote>
]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>代码重构技巧</title>
    <url>/2017/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<h1 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h1><p>任何不会被修改的变量都可以当做参数传入新的函数；一个变量会被修改可以把它当做返回值。</p>
<h1 id="重构方法-重新组织函数"><a href="#重构方法-重新组织函数" class="headerlink" title="重构方法-重新组织函数"></a>重构方法-重新组织函数</h1><h2 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h2><p>将这段代码放进一个独立地函数中，并让函数名称解释该函数的用途。<br>包装函数的粒度小，复用的几率就大。<br>适用于：为一些代码提供一个清晰的函数名。<br>函数命名：以它“做什么”来命名，而不是以它“怎么做”命名。</p>
<h2 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h2><p>在函数调用点插入函数本体，然后移除该函数。<br>适用于：原函数内部代码清晰易读，不需要提炼为一个单独的函数。</p>
<h2 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h2><p>将所有对该变量的引用动作，替换为对它赋值的哪个表达式自身。<br>适用于：只使用了一次，或许可以移除该临时变量。</p>
<h2 id="Replace-Temp-with-Query（以查询取代临时变量）"><a href="#Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp with Query（以查询取代临时变量）"></a>Replace Temp with Query（以查询取代临时变量）</h2><p>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其它函数使用。<br>适用于：由于临时变量作用域只在函数内部，如果把临时变量替换为一个查询，那么同一个类中的所有函数都可以获取这份信息。</p>
<h2 id="Introduce-Explaining-Variable（引入解释性变量）"><a href="#Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaining Variable（引入解释性变量）"></a>Introduce Explaining Variable（引入解释性变量）</h2><p>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。<br>适用于：用一个命名清晰的变量来代替难以理解的代码或函数。</p>
<h2 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h2><p>针对每次赋值，创造一个独立、对应的临时变量（再多一个临时变量）。<br>适用于：你的程序有某个临时变量被赋值超过一次，它即不是循环变量，而不被用于收集计算结果。</p>
<h2 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h2><p>以一个临时变量取代该参数的位置。<br>适用于：用一个临时变量（有意义的名字）保存参数。</p>
<h2 id="Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Method Object（以函数对象取代函数）"></a>Replace Method with Method Object（以函数对象取代函数）</h2><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。<br>然后你可以在同一个对象中将这个大型函数分解为多个小型函数。<br>适用于：你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。</p>
<h2 id="Substitute-Algorithm（替换算法）"><a href="#Substitute-Algorithm（替换算法）" class="headerlink" title="Substitute Algorithm（替换算法）"></a>Substitute Algorithm（替换算法）</h2><p>将函数本体代替为另一个算法。<br>适用于：你想要把某个算法替换为另一个更加清晰的算法。</p>
<h1 id="重构方法-在对象之间搬移特性"><a href="#重构方法-在对象之间搬移特性" class="headerlink" title="重构方法-在对象之间搬移特性"></a>重构方法-在对象之间搬移特性</h1><h2 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h2><p>在该函数最常引用的类中建立一个有着类似行为的新函数。<br>将旧函数编程一个单纯的委托函数，或是将旧函数完全移除。<br>适用于：一个类有太多行为，或一个类与另一个类有太多合作而形成高度耦合。</p>
<h2 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h2><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。<br>适用于：对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它。</p>
<h2 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h2><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。<br>适用于：某个类做了应该由两个类做的事。</p>
<h2 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h2><p>将这个类的所有特性搬移到另一个类中，然后移除原类。<br>适用于：某个类没有做太多事情。</p>
<h2 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h2><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。<br>适用于：客户通过一个委托类来调用另一个对象。</p>
<h2 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h2><p>让客户直接调用受托类。<br>适用于：某个类做了过多的简单委托动作。</p>
<h2 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h2><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。<br>适用于：你需要为提供服务的类添加一个函数，但你无法修改这个类。<br>外加函数终归是权益之计，尽量将其搬移到服务类中去（Introduce Local Extension）。</p>
<h2 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h2><p>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。<br>适用于：你需要为服务类提供一些额外函数，但你无法修改这个类。</p>
<h1 id="重构方法-重新组织数据"><a href="#重构方法-重新组织数据" class="headerlink" title="重构方法-重新组织数据"></a>重构方法-重新组织数据</h1><h2 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h2><p>为这个字段建立取值/设置函数，并且只以这些函数来访问字段。<br>适用于：你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。</p>
<h2 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h2><p>将数据项变成对象。<br>适用于：你有一个数据项，需要与其他数据和行为一起使用才有意义。</p>
<h2 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h2><p>将这个值对象变成引用对象。<br>适用于：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。</p>
<h2 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h2><p>将它变成一个值对象。<br>适用于：你有一个引用对象，很小且不可该表，而且不易管理。</p>
<h2 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h2><p>以对象替换数组。对于数组中的每个元素，以一个字段来表示。<br>适用于：你有一个数组，其中的元素各自代表不同的东西。</p>
<h2 id="Duplicate-Observed-Data（复制“被监视数据”）"><a href="#Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data（复制“被监视数据”）"></a>Duplicate Observed Data（复制“被监视数据”）</h2><p>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。<br>MVC模型</p>
<h2 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><p>添加一个反向指针，并使修改函数能够同时更新两条连接。<br>适用于：两个类都需要使用对方特性，但其间只有一条单向连接。</p>
<h2 id="Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><p>去除不必要的关联。<br>适用于：两个类之间有双向关联，但其中一个类如今不需要另一个类的特性。</p>
<h2 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h2><p>创造一个常量，根据其意义为它命名，并将上述的字面量替换为这个常量。<br>适用于：你有一个字面数值，带上特别含义。</p>
<h2 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h2><p>将它声明为private，并提供相应的访问函数get和set。<br>适用于：你的类中存在一个public字段。</p>
<h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>让这个函数返回集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。<br>适用于：有一个函数返回一个集合。</p>
<h2 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h2><p>为该记录创建一个“哑”数据对象。<br>适用于：你需要面对传统编程环境中的记录结构。</p>
<h2 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h2><p>以一个新的类替换该数值类型码。<br>适用于：类之中有一个数值类型码，但它并不影响类的行为。</p>
<h2 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h2><p>以自带取代这个类型码（多态）。<br>适用于：你有一个不可变的类型码，它会影响类的行为。</p>
<h2 id="Replace-Type-Code-with-State-Strategy（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy（以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy（以State/Strategy取代类型码）</h2><p>以状态对象取代类型码。<br>适用于：你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。</p>
<h2 id="Replace-Subclass-with-Fields（以字段取代子类）"><a href="#Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="Replace Subclass with Fields（以字段取代子类）"></a>Replace Subclass with Fields（以字段取代子类）</h2><p>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。<br>适用于：你的各个子类的唯一差别只在“返回常量数据”的函数身上。</p>
<h1 id="重构方法-简化条件表达式"><a href="#重构方法-简化条件表达式" class="headerlink" title="重构方法-简化条件表达式"></a>重构方法-简化条件表达式</h1><h2 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h2><p>从if、then、else三个段落中分别提炼出独立函数。<br>适用于：你有一个复杂的条件（if-then-else）语句。</p>
<h2 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h2><p>将这些测试合并为一个条件表达式，并将这个表达式提炼成一个独立的函数。<br>适用于：你有一系列条件测试，都得到相同结果。</p>
<h2 id="Consilidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consilidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consilidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consilidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>将这个端重复代码搬移到条件表达式之外。<br>适用于：在条件表达式的每个分支上有着相同的一段代码。</p>
<h2 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h2><p>以break语句或return语句取代控制标记。<br>适用于：在一系列布尔表达式中，某个变量带有“控制标记”（control flag）的作用。</p>
<h2 id="Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）</h2><p>使用卫语句表现所有特殊情况（尽量不要转换成嵌套）。<br>适用于：函数中的条件逻辑使人难以看清正常的执行路径。</p>
<h2 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h2><p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。<br>适用于：你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p>
<h2 id="Introduce-Null-Object（引入Null对象）"><a href="#Introduce-Null-Object（引入Null对象）" class="headerlink" title="Introduce Null Object（引入Null对象）"></a>Introduce Null Object（引入Null对象）</h2><p>将null值替换为null对象。<br>适用于：你需要再三检查对象是否为null。</p>
<h2 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h2><p>以断言明确表现这种假设。<br>适用于：某一段代码需要对程序状态做出某种假设。</p>
<h1 id="重构方法-简化函数调用"><a href="#重构方法-简化函数调用" class="headerlink" title="重构方法-简化函数调用"></a>重构方法-简化函数调用</h1><h2 id="Rename-Method（函数改名）"><a href="#Rename-Method（函数改名）" class="headerlink" title="Rename Method（函数改名）"></a>Rename Method（函数改名）</h2><p>修改函数的名称。<br>适用于：函数的名称未能解释函数的用途。<br>函数命名，参考“做什么”而不是“怎么做”。</p>
<h2 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h2><p>为此函数添加一个对象参数，让该对象带进函数所需信息。<br>适用于：某个函数需要从调用端得到更对信息。<br>这样做有一个好处，不用关心参数的位置。</p>
<h2 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h2><p>将该参数去除。<br>适用于：函数本体不再需要某个参数。</p>
<h2 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h2><p>建立两个不同的函数，其中一个负责查询，另一个负责修改。<br>适用于：某个函数既返回对象状态值，又修改对象状态。</p>
<h2 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h2><p>建立单一函数，以参数表达那些不同的值。<br>适用于：若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p>
<h2 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h2><p>针对该参数的每一个可能值，建立一个独立函数。<br>适用于：你有一个函数，其中完全取决于参数值而不采取不同行为。</p>
<h2 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h2><p>改为传递整个对象（传递整个对象，不要值传递对象的某些属性）。<br>适用于：你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<h2 id="Replace-Parameter-with-Methods（以函数取代参数）"><a href="#Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="Replace Parameter with Methods（以函数取代参数）"></a>Replace Parameter with Methods（以函数取代参数）</h2><p>让参数接受者去除该项参数，并直接调用前一个函数。<br>适用于：对象调用某一个函数，并将所得结果作为参数，传递给另一个函数。<br>而接受参数的函数本身也能够用前一个函数。</p>
<h2 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h2><p>以一个对象取代这些参数。<br>适用于：某些参数总是很自然地同时出现。</p>
<h2 id="Remove-Setting-Method（移除设置函数）"><a href="#Remove-Setting-Method（移除设置函数）" class="headerlink" title="Remove Setting Method（移除设置函数）"></a>Remove Setting Method（移除设置函数）</h2><p>去掉该字段的所有设值函数。<br>适用于：类中的某个字段应该在对象创建时被设值，然后不再改变。</p>
<h2 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h2><p>将这个函数修改为private。<br>适用于：有一个函数，从来没有被其他任何类用到。</p>
<h2 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h2><p>将构造函数替换为工厂函数。<br>适用于：你希望在创建对象时不仅仅时做简单的建构动作。</p>
<h2 id="Enucapsulate-Downcast（封装向下转型）"><a href="#Enucapsulate-Downcast（封装向下转型）" class="headerlink" title="Enucapsulate Downcast（封装向下转型）"></a>Enucapsulate Downcast（封装向下转型）</h2><p>将向下转型动作移到函数中。<br>适用于：某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。</p>
<h2 id="Replace-Error-Code-with-Exception（异常取代错误代码）"><a href="#Replace-Error-Code-with-Exception（异常取代错误代码）" class="headerlink" title="Replace Error Code with Exception（异常取代错误代码）"></a>Replace Error Code with Exception（异常取代错误代码）</h2><p>改用异常。<br>适用于：某个函数返回一个特定的代码，用以表示某种错误情况。</p>
<h2 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h2><p>修改调用者，使它在调用函数之前先做检查。<br>适用于：面对一个调用这可以预先检查的条件，你抛出了一个异常。</p>
<h1 id="重构方法-处理概括关系（继承关系）"><a href="#重构方法-处理概括关系（继承关系）" class="headerlink" title="重构方法-处理概括关系（继承关系）"></a>重构方法-处理概括关系（继承关系）</h1><h2 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h2><p>将该字段移至超类。<br>适用于：两个子类都拥有相同的字段。</p>
<h2 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h2><p>将函数移至超类。<br>适用于：有些函数，在各个子类中产生完全相同的结果。</p>
<h2 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h2><p>在超类中新建一个构造函数，并在子类构造函数中调用它。<br>适用于：你在各个子类中拥有一些构造函数，它们的本体机会完全一致。</p>
<h2 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h2><p>将这个函数移到相关的那些子类去。<br>适用于：超类中的某个函数只与部分（而非全部）子类有关。</p>
<h2 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h2><p>将这个字段移到需要它的那些子类去。<br>适用于：超类中的某个字段只被部分（而非全部）子类用到。</p>
<h2 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h2><p>新建一个子类，将上面所说的那一部分特性移到子类中。<br>适用于：类中的某些特性只被某些（而非全部）实例用到。</p>
<h2 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h2><p>为这两个类建立建立一个超类，将相同特性移至超类。<br>适用于：这两个类有相似特性。</p>
<h2 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h2><p>将相同的子集提炼到一个独立接口中。<br>适用于：若干客户适用类接口中的同一子集，或者两个类的接口有部分相同。</p>
<h2 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h2><p>将它们合为一体。<br>适用于：超类和子类之间无太大区别。</p>
<h2 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h2><p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。<br>适用于：你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节有所不同。</p>
<h2 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h2><p>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。<br>适用于：某个子类只适用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<h2 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h2><p>让委托类继承受托类。<br>适用于：你在两个类之间委托关系，并经常为整个接口编写许多极简单的委托函数。</p>
<h1 id="重构方法-大型重构"><a href="#重构方法-大型重构" class="headerlink" title="重构方法-大型重构"></a>重构方法-大型重构</h1><h2 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h2><p>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。<br>适用于：某个继承体系同时承担两项责任。</p>
<h2 id="ConvertProcedural-Design-to-Objects（将过程化设计转化为对象设计）"><a href="#ConvertProcedural-Design-to-Objects（将过程化设计转化为对象设计）" class="headerlink" title="ConvertProcedural Design to Objects（将过程化设计转化为对象设计）"></a>ConvertProcedural Design to Objects（将过程化设计转化为对象设计）</h2><p>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。<br>适用于：你手上有一些传统过程化风格的代码。</p>
<h2 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h2><p>将领域逻辑分离出来，为它们建立独立地领域类。<br>适用于：某些GUI类之中包含了领域逻辑。</p>
<h2 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h2><p>建立继承体系，以一个子类表示一种特殊情况。<br>适用于：你有某个类做了太多工作，其中一部分工作是以大量表达式完成的。</p>
<h1 id="代码的坏味道–及解决方案"><a href="#代码的坏味道–及解决方案" class="headerlink" title="代码的坏味道–及解决方案"></a>代码的坏味道–及解决方案</h1><h2 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h2><p>Extract Method（提炼函数）<br>Pull Up Method（函数上移到超类）<br>Form Template Method（塑造模板函数）<br>Substitute Algorithm（替换算法）<br>Extract Class（提炼类）</p>
<h2 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h2><p>Extract Method（提炼函数）<br>Replace Temp with Query（以查询取代临时变量）<br>Introduce Parameter Object（引入参数对象）<br>Preserve Whole Object（保持对象完整）<br>Replace Method with Method Object（以函数对象取代函数）<br>Decompose Conditional（分解条件表达式）</p>
<h2 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h2><p>Extract Class（提炼类）<br>Extract Subclass（提炼子类）<br>Extract Interface（提炼接口）<br>Duplicate Observed Data（复制“被监视数据”）</p>
<h2 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h2><p>Replace Parameter with Method（用函数替换参数）<br>Preserve Whole Object（保持对象完整）<br>Introduce Parameter Object（引入参数对象）</p>
<h2 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h2><p>Extract Class（提炼类）</p>
<h2 id="Shotgun-Surgery（霰xian弹式修改）"><a href="#Shotgun-Surgery（霰xian弹式修改）" class="headerlink" title="Shotgun Surgery（霰xian弹式修改）"></a>Shotgun Surgery（霰xian弹式修改）</h2><p>Move Method（移动函数）<br>Move Field（移动字段）<br>Inline Class（内联类）</p>
<h2 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h2><p>Move Method（移动函数）<br>Extract Method（提炼方法）</p>
<h2 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h2><p>Extract Class（提炼类）<br>Introduce Parameter Object（引入参数对象）<br>Preserve Whole Object（保持整个对象）</p>
<h2 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h2><p>Replace Data Value with Object（用对象替换数据值）<br>Replace Type Code with Class（用类替换类型代码）<br>Extract Class（提炼类）<br>Introduce Parameter Object（引入参数对象）<br>Replace Array with Object（用对象代替数组）</p>
<h2 id="Switch-Statements（switch-惊悚现身）"><a href="#Switch-Statements（switch-惊悚现身）" class="headerlink" title="Switch Statements（switch 惊悚现身）"></a>Switch Statements（switch 惊悚现身）</h2><p>Extract Method（提炼函数）<br>Move Method（移动函数）<br>Replace Type Code with Subclass（以子类替换类型代码）<br>Replace Type Code with State/Strategy（以State/Strategy取代类型码）<br>Replace Conditional with Polymorphism（以多态取代条件表达式）<br>Replace Parameter with Explicit Methods（以明确函数取代参数）<br>Introduce Null Object（引入null对象）</p>
<h2 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h2><p>Move Method（移动函数）<br>Move Field（移动字段）</p>
<h2 id="Lazy-Class（冗赘类）"><a href="#Lazy-Class（冗赘类）" class="headerlink" title="Lazy Class（冗赘类）"></a>Lazy Class（冗赘类）</h2><p>Collapse Hierarchy（折叠继承体系）<br>Inline Class（内联类）</p>
<h2 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h2><p>Collapse Hierarchy（折叠继承体系）<br>Inline Class（内联类）<br>Remove Parameter（移除参数）<br>Rename Method（移除函数）</p>
<h2 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h2><p>Extract Class（提炼类）<br>Introduce Null Object（引入Null对象）</p>
<h2 id="Message-Chains（过渡耦合的消息链）"><a href="#Message-Chains（过渡耦合的消息链）" class="headerlink" title="Message Chains（过渡耦合的消息链）"></a>Message Chains（过渡耦合的消息链）</h2><p>Hide Delegate（隐藏“委托关系”）<br>Extract Method（提炼函数）<br>Move Method（移动函数）</p>
<h2 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h2><p>Remove Middle Man（中间人）<br>Inline Method（内联方法）<br>Replace Delegation with Inheritance（以继承取代委托）</p>
<h2 id="Inappropriate-Intimacy（狎昵关系）–两个类过于亲密"><a href="#Inappropriate-Intimacy（狎昵关系）–两个类过于亲密" class="headerlink" title="Inappropriate Intimacy（狎昵关系）–两个类过于亲密"></a>Inappropriate Intimacy（狎昵关系）–两个类过于亲密</h2><p>Move Method（移动函数）<br>Move Field（移动字段）<br>Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）<br>Extract Class（提炼类）<br>Hide Delegate（隐藏“委托关系”）<br>Replace Inheritance with Delegation（以委托取代继承）</p>
<h2 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h2><p>Rename Method（重命名函数）<br>Move Method（移动函数）<br>Extract Superclass（提炼超类）</p>
<h2 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h2><p>Move Method（移动函数）<br>Intorduce Foreign Method（引入外加函数）<br>Introduce Local Extension（引入本地扩展）</p>
<h2 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h2><p>Encapsulate Field（自封装字段）<br>Encapsulate Collection（封装集合）<br>Remove Setting Method（移除设置函数）<br>Move Method（移除函数）<br>Extract Method（提炼函数）<br>Hide Method（隐藏函数）</p>
<h2 id="Refused-Bequest（被拒绝的馈赠）"><a href="#Refused-Bequest（被拒绝的馈赠）" class="headerlink" title="Refused Bequest（被拒绝的馈赠）"></a>Refused Bequest（被拒绝的馈赠）</h2><p>Push Down Method（函数下移）–移动子类<br>Push Down Field（字段下移）<br>Replace Inheritance with Delegation（以委托取代继承）</p>
<h2 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h2><p>Rename Metho（重命名方法）<br>Introduce Assertion（引入断言）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文整理于《重构改善既有代码的设计》，这本书是用java写的，整理的目的是为了自己能写出更健壮、更具扩展性的代码，为以后的编码做参考。<br>个人能力有限，如有理解不当还望指出，更深入的了解还请参阅次书籍。</p>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>代码重构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法--冒泡排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p><a href="https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html">或许你需要对算法的基本概念进行了解，请访问该链接。</a></p>
<h1 id="冒泡排序算法定义（Bubble-Sort）"><a href="#冒泡排序算法定义（Bubble-Sort）" class="headerlink" title="冒泡排序算法定义（Bubble Sort）"></a>冒泡排序算法定义（Bubble Sort）</h1><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p>
<h1 id="冒泡排序算法原理"><a href="#冒泡排序算法原理" class="headerlink" title="冒泡排序算法原理"></a>冒泡排序算法原理</h1><p>冒泡排序算法的运作如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个数的位置。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。一次比较后，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个（因为最后一个已经是最大的了，不需要参与比较）。</li>
<li>持续对剩余未排序的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h1 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。<br>    C=n-1；M=0；</p>
<p><span>所以，冒泡排序最好的时间复杂度为 O(n)。</span>若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。<br>    C=n<em>(n-1)/2 = O(n^2)；M=3n</em>(n-1)/2 = O(n^2)<br><span>所以，冒泡排序最坏的时间复杂度为 O(n^2)。</span><br>综上，因此冒泡排序总的平均时间复杂度为  O(n^2)。        </p>
<h2 id="冒泡排序算法的稳定性"><a href="#冒泡排序算法的稳定性" class="headerlink" title="冒泡排序算法的稳定性"></a>冒泡排序算法的稳定性</h2><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。<br>所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，<br>那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，<br>所以冒泡排序是一种稳定排序算法。</p>
<h1 id="冒泡排序算法描述"><a href="#冒泡排序算法描述" class="headerlink" title="冒泡排序算法描述"></a>冒泡排序算法描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubbleSort(array) &#123;</span><br><span class="line">	let len = array.length, j, arr = array.slice();</span><br><span class="line">	let tempExchangeVal;</span><br><span class="line">	while (len &gt; 0) &#123;</span><br><span class="line">		for (j = 0; j &lt; len - 1; j++) &#123;</span><br><span class="line">			if (arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">				// 交换两个值</span><br><span class="line">				tempExchangeVal = arr[j];</span><br><span class="line">				arr[j] = arr[j + 1];</span><br><span class="line">				arr[j + 1] = tempExchangeVal;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		len--;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line">const arr = [5, 4, 3, 2, 1];</span><br><span class="line">let arrSorted = bubbleSort(arr);</span><br><span class="line">console.log(arrSorted); // [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr); // [5, 4, 3, 2, 1];</span><br></pre></td></tr></table></figure>
<p>PS：这里在方法中新生成了一个数组，有不可变对象的思想。</p>
<h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" alt="冒泡排序"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">图片来源</a>，在此表示感谢！</p>
<blockquote>
<p>   参考文档：<br><a href="https://www.cnblogs.com/zhouliang/p/6638010.html" target="_blank" rel="noopener">JS-排序详解-冒泡排序</a><br><a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a><br><a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="noopener">冒泡排序</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用dos命令总结</title>
    <url>/2017/%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="什么是DOS命令"><a href="#什么是DOS命令" class="headerlink" title="什么是DOS命令"></a>什么是DOS命令</h1><p>DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h2><h3 id="md-mkdir"><a href="#md-mkdir" class="headerlink" title="md/mkdir"></a>md/mkdir</h3><p>作用：创建一个子目录（make directory）。<br>语法：md[C:][path]〈subPath〉</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>作用：改变或显示当前目录（change directory）。<br>语法：cd [C:][path]<br>PS：路径可以使用绝对路径和相对路径两种。<br>    cd\ 表示退回到根目录。<br>    cd.. 表示退回到上级目录。<br>    如果只有cd而没有参数，则只显示当前路径。<br>    注意：子目录中一定有两个“特殊目录”，即“.”“..”，其中一点表示当前目录，两点表示上一层目录。<br>    从简单实用的角度来看，我们只要学会逐层进入（cd 下一层某目录名），和逐层退出（cd..）就可以解决所有问题。</p>
<h3 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h3><p>作用：删除空子目录（remove directory）。<br>语法：rd [c:][path]<br>PS：rd是专门删除空子目录的命令。<br>    del 删除文件命令。<br>    注意两条：一是不能删除非空目录；二是不能删除当前目录。     </p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>作用：主要用来显示一个目录下的文件和子目录。(directory)<br>语法：dir [C:][path][filename][/o][/s][/p][/w][/a]<br>PS：斜杠表示后面的内容是参数。<br>    /p 显示信息满一屏时，暂停显示，按任意键后显示下一屏<br>    /o 排序显示。o后面可以接不同意义的字母<br>    /w 只显示文件名目录名，每行五个文件名。即宽行显示<br>    /s 将目录及子目录的全部目录文件都显示<br>    /a 显示隐藏文件</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>作用：设备可执行文件的搜索路径，只对文件有效。<br>语法：path[盘符1：][路径1][盘符2：][路径2]…<br>PS：当运行一个可执行文件时，dos会先在当前目录中搜索该文件，若找到则运行之；若找不到该文件，则根据path命令所设置的路径，顺序逐条地到目录中搜索该文件</p>
<h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>作用：显示指定驱动器上所有目录路径和这些目录下的所有文件名。<br>语法：tree [盘符：][/f][&gt;prn]</p>
<h3 id="deltree"><a href="#deltree" class="headerlink" title="deltree"></a>deltree</h3><p>作用：删除目录树。<br>语法：DELTREE [C1:][path1]<br>PS：这个命令将整个指定目录树全部消灭，而不管它是否是只读、隐藏与否。使用应特别小心。它是一个危险命令。</p>
<h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p>作用：将整个计算机的进程显示出来，同任务管理器。<br>语法：tasklist</p>
<h2 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>作用：磁盘格式化。<br>语法：format〈盘符：〉[/s][/4][/q]    </p>
<h3 id="unformat"><a href="#unformat" class="headerlink" title="unformat"></a>unformat</h3><p>作用：对进行过格式化误操作丢失数据的磁盘进行恢复。<br>语法：unformat〈盘符〉[/l][/u][/p][/test]    </p>
<h3 id="chkdsk"><a href="#chkdsk" class="headerlink" title="chkdsk"></a>chkdsk</h3><p>作用：显示磁盘状态、内存状态和指定路径下指定文件的不连续数目。<br>语法：chkdsk [盘符：][路径][文件名][/f][/v]<br>PS：PS：例如要检查A盘使用情况，就输入chkdsk　A: ，检查c盘使用情况，就输入chkdsk　C: ，如果直接输入chkdsk，就检查当前磁盘的使用情况。    </p>
<h3 id="diskcopy"><a href="#diskcopy" class="headerlink" title="diskcopy　"></a>diskcopy　</h3><p>作用：复制格式和内容完全相同的软盘。<br>语法：diskcopy[盘符1：][盘符2：]</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>作用：建立、更改、删除磁盘卷标。<br>语法：label[盘符：][卷标名]    </p>
<h3 id="vol"><a href="#vol" class="headerlink" title="vol"></a>vol</h3><p>作用：查看磁盘卷标号。<br>语法：vol[盘符：]</p>
<h3 id="scandisk"><a href="#scandisk" class="headerlink" title="scandisk"></a>scandisk</h3><p>作用：检测磁盘的fat表、目录结构、文件系统等是否有问题，并可将检测出的问题加以修复。<br>语法：scandisk[盘符1：]{[盘符2：]…}[/all]</p>
<h3 id="defrag"><a href="#defrag" class="headerlink" title="defrag"></a>defrag</h3><p>作用：整理磁盘，消除磁盘碎块。<br>语法：defrag[盘符：][/f]<br>PS：选用/f参数，将文件中存在盘上的碎片消除，并调整磁盘文件的安排，确保文件之间毫无空隙。从而加快读盘速度和节省磁盘空间。</p>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>作用：将当前驱动器上的dos系统文件io.sys,msdos.sys和command 传送到指定的驱动器上。<br>语法：sys[盘符：]    </p>
<h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>作用：拷贝一个或多个文件到指定盘上。<br>语法：copy [源盘][路径]（源文件名） [目标盘][路径](目标文件名）</p>
<h3 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h3><p>作用：复制指定的目录和目录下的所有文件连同目录结构。<br>语法：xcopy [源盘：]〈源路径名〉[目标盘符：][目标路径名][/s][/v][/e]<br>PS：xcopy是copy的扩展，可以把指定的目录连文件和目录结构一并拷贝，但不能拷贝隐藏文件和系统文件。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>作用：显示ascii码文件的内容。<br>语法：type [C:][path][filename.ext]<br>PS：type命令用来在屏幕上快速、简便地显示文本文件的内容，扩展名为TXT的文件是文本文件。    </p>
<h3 id="ren"><a href="#ren" class="headerlink" title="ren"></a>ren</h3><p>作用：对指定磁盘、目录中的一个文件或一组文件更改名称（rename）。<br>语法：ren[盘符：][路径]〈旧文件名〉〈新文件名〉<br>PS：改名操作只限于某个文件某组文件的名称，它不会更改文件所在的目录。    </p>
<h3 id="fc"><a href="#fc" class="headerlink" title="fc"></a>fc</h3><p>作用：比较文件的异同，并列出差异处。<br>语法：fc[盘符：][路径名]〈文件名〉[盘符：][路径名][文件名][/a][/c][/n]</p>
<h3 id="attrib"><a href="#attrib" class="headerlink" title="attrib"></a>attrib</h3><p>作用：修改指定文件的属性。<br>语法：attrib[文件名][r][—r][a][—a][h][—h][—s]</p>
<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>作用：删除指定的文件。<br>语法：del[盘符：][路径]〈文件名〉[/p]    </p>
<h3 id="undelete"><a href="#undelete" class="headerlink" title="undelete"></a>undelete</h3><p>作用：恢复被误删除文件。<br>语法：undelete[盘符：][路径名]〈文件名〉[/dos][/list][/all]    </p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol>
<li>cls——清屏幕命令    </li>
<li>ver查看系统版本号命令    </li>
<li>date日期设置命令<br>date[mm——dd——yy]</li>
<li>time系统时钟设置命令<br>time[hh：mm：ss：xx]</li>
<li>mem显示系统的硬件和操作系统的状况。<br>mem[/c][/f][/m][/p]</li>
<li>msg显示系统的硬件和操作系统的状况。<br>msg[/s]</li>
</ol>
<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><h3 id="Ping命令的独特用法"><a href="#Ping命令的独特用法" class="headerlink" title="Ping命令的独特用法"></a>Ping命令的独特用法</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：ping +空格+“IP地址或者域名” [-t][-l][-n]<br>PS：-t：不停的Ping对方的机器，直到用户按Ctrl＋C键终止。因为如果想用Ping命令测试网络传输质量，至少要查看Ping命令三分钟到五分钟的结果。<br>    -l：定义echo数据包大小。我们可以将数据包的大小定义在极限值附近，以此可以测试出网络传输质量的优劣，尤其是测试外网的传输质量，非常明显。<br>    -n：在默认情况下，Ping命令一般都会发送四个数据包，通过这个命令可以自己定义发送的个数，对测试网络传输质量很有帮助。我们结合实例说明一下如何通过Ping命令的测试结果判断网络传输质量。</p>
<h3 id="tracert命令的使用技巧"><a href="#tracert命令的使用技巧" class="headerlink" title="tracert命令的使用技巧"></a>tracert命令的使用技巧</h3><p>作用：tracert命令可以测试路由器的工作是否正常（部分网站无法访问）。<br>    我们根据返回的结果来判断，哪一个环节的网络出现了问题。<br>语法：tracert +空格+“IP地址或者域名”</p>
<h3 id="用netstat命令判断是否被攻击"><a href="#用netstat命令判断是否被攻击" class="headerlink" title="用netstat命令判断是否被攻击"></a>用netstat命令判断是否被攻击</h3><p>作用：netstat命令可以查看单位的网络是否被攻击。<br>语法：netstat [-a][-n][-b]<br>PS：-a：显示所有连接和监听端口<br>　　-n：以数字形式显示地址和端口号<br>　　-b：显示包含于创建每个连接或监听端口的可执行组件。另外，使用该参数之后，还可以显示占用TCP协议端口的一些程序名称</p>
<h3 id="巧用ARP命令防范ARP病毒"><a href="#巧用ARP命令防范ARP病毒" class="headerlink" title="巧用ARP命令防范ARP病毒"></a>巧用ARP命令防范ARP病毒</h3><p>作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。<br>语法：arp -s ip地址 MAC</p>
<h3 id="灵活使用ipconfig命令"><a href="#灵活使用ipconfig命令" class="headerlink" title="灵活使用ipconfig命令"></a>灵活使用ipconfig命令</h3><p>作用：ipconfig这个命令查看计算机当前的网络配置信息。<br>ps：Ipconfig /all：完全显示计算机的网络信息，IP地址、MAC地址及其他相关的信息，都可以显示出来。<br>　　Ipconfig /release：释放计算机当前获得的IP地址。对于使用动态IP地址的单位来说，如果发现机器无法上网，而计算机从DHCP服务器处获得的IP地址等相关信息不完全，可以将该地址释放。<br>　　Ipconfig /renew：从DHCP服务器重新获得IP地址。释放了IP地址及相关信息之后，必须重新获得一个IP地址，直接输入此命令之后，便可以从DHCP服务器处获得一个IP地址。如果不用此命令，要想重新获得一个IP地址信息，需要重新启动计算机或注销计算机才行。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>net 系列</li>
<li>tlist -t 以树行列表显示进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li>
<li>kill -f 进程名 加-f参数后强制结束某进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内）</li>
</ol>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>shutdown.exe -a　取消关机<br>shutdown.exe -s 关机<br>shutdown.exe -f　强行关闭应用程序。<br>shutdown.exe -m \计算机名　控制远程计算机。<br>shutdown.exe -i　显示图形用户界面，但必须是Shutdown的第一个参数。<br>shutdown.exe -l　注销当前用户。<br>shutdown.exe -r　关机并重启。<br>shutdown.exe -t时间　设置关机倒计时。<br>shutdown.exe -c”消息内容”　输入关机对话框中的消息内容（不能超127个字符）。<br>示例：<br>    电脑要在24:00关机 – at 24:00 Shutdown -s<br>    倒计时的方式关机 – Shutdown.exe -s -t 7200</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h3><p>作用：该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，使用这个命令你可以得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等。在此我们就有必要了解几个基本的参数。<br>PS：-a 使用这个参数，只要你知道了远程主机的机器名称，就可以得到它的NETBIOS信息（下同）。<br>    -A 这个参数也可以得到远程主机的NETBIOS信息，但需要你知道它的IP。<br>    -n 列出本地机器的NETBIOS信息。</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>作用：这是一个用来查看网络状态的命令，操作简便功能强大。<br>PS：-a 查看本地机器的所有开放端口，可以有效发现和预防木马，可以知道机器所开的服务等信息<br>    这里可以看出本地机器开放有FTP服务、Telnet服务、邮件服务、WEB服务等。用法：netstat -a IP。<br>    -r 列出当前的路由信息，告诉我们本地机器的网关、子网掩码等信息。用法：netstat -r IP。</p>
<h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>作用：跟踪路由信息，使用此命令可以查出数据从本地机器传输到目标主机所经过的所有途径，这对我们了解网络布局和结构很有帮助。</p>
<h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><p>作用：这个命令是网络命令中最重要的一个，必须透彻掌握它的每一个子命令的用法，因为它的功能实在是太强大了在这里，我们重点掌握几个常用的子命令。</p>
<ol>
<li>net view<br>使用此命令查看远程主机的所有共享资源。命令格式为net view \IP。</li>
<li>net use<br>把远程主机的某个共享资源影射为本地盘符，图形界面方便使用。命令格式为net use x: \IP\sharename。</li>
<li>net start<br>使用它来启动远程主机上的服务。用法：net start servername</li>
<li>net stop<br>入侵后发现远程主机的某个服务碍手碍脚，怎么办？利用这个命令停掉就ok了，用法和net start同。</li>
<li>net user<br>查看和帐户有关的情况，包括新建帐户、删除帐户、查看特定帐户、激活帐户、帐户禁用等。<br>1，net user abcd 1234 /add，新建一个用户名为abcd，密码为1234的帐户，默认为user组成员。<br>2，net user abcd /del，将用户名为abcd的用户删除。<br>3，net user abcd /active:no，将用户名为abcd的用户禁用。<br>4，net user abcd /active:yes，激活用户名为abcd的用户。<br>5，net user abcd，查看用户名为abcd的用户的情况</li>
<li>net localgroup　<br>查看所有和用户组有关的信息和进行相关操作。</li>
<li>net time<br>这个命令可以查看远程主机当前的时间。</li>
</ol>
<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>作用：这个命令的作用是安排在特定日期或时间执行某个特定的命令和程序。<br>    用法：at time command \computer    </p>
<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>作用：首先在命令行键入ftp回车，出现ftp的提示符，这时候可以键入“help”来查看帮助（任何DOS命令都可以使用此方法查看其帮助）。<br>    1.ftp<br>    2.open 主机IP ftp端口<br>    3.录入用户名和密码，就可以进行相应操作了。<br>    dir 跟DOS命令一样，用于查看服务器的文件，直接敲上dir回车，就可以看到此ftp服务器上的文件。<br>    cd 进入某个文件夹。<br>    get 下载文件到本地机器。<br>    put 上传文件到远程服务器。这就要看远程ftp服务器是否给了你可写的权限了，如果可以，呵呵，该怎么 利用就不多说了，大家就自由发挥去吧。<br>    delete 删除远程ftp服务器上的文件。这也必须保证你有可写的权限。<br>    bye 退出当前连接。<br>    quit 同上。</p>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>作用：功能强大的远程登陆命令，几乎所有的入侵者都喜欢用它，屡试不爽。为什么？它操作简单，如同使用自己的机器一样，只要你熟悉DOS命令，在成功以administrator身份连接了远程机器后，就可以用它来**想干的一切了。下面介绍一下使用方法，首先键入telnet回车，再键入help查看其帮助信息。    </p>
<h1 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h1><ol>
<li>向上箭头”↑”和向下箭头”↓”—–回看上一次执行的命令        </li>
<li>“Ctrl+C” 组合键或”Break”键 —–中断操作        </li>
<li>鼠标操作”标记” —————–用来选中文本        </li>
<li>鼠标操作”粘贴” —————–用来把剪贴板内容粘贴到提示符下        </li>
</ol>
<h2 id="程序进程"><a href="#程序进程" class="headerlink" title="程序进程"></a>程序进程</h2><p>作用：ntsd 是一条dos命令，功能是用于结束一些常规下结束不了的死进程。<br>使用：<br>    1.利用进程的PID结束进程<br>        命令格式：ntsd -c q -p pid<br>        命令范例：ntsd -c q -p 1332 （结束explorer.exe进程）<br>    2.利用进程名结束进程<br>        命令格式：ntsd -c q -pn <strong><em>.exe （</em></strong>.exe 为进程名，exe不能省）<br>        命令范例：ntsd -c q -pn explorer.exe<br>    3.taskkill结束进程<br>        命令格式：taskkill /pid 1234 /f （ 也可以达到同样的效果）</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.jb51.net/article/30526.htm" target="_blank" rel="noopener">20种常用的DOS命令小结</a><br>    <a href="http://www.360doc.com/content/10/0712/19/1822972_38550278.shtml" target="_blank" rel="noopener">DOS中的PING命令的几种用法</a><br>    <a href="https://baike.baidu.com/item/DOS%E5%91%BD%E4%BB%A4/5143255?fr=aladdin#7" target="_blank" rel="noopener">百度文库-dos命令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>dos命令</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-基数排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="基数排序（radix-sort）的基础"><a href="#基数排序（radix-sort）的基础" class="headerlink" title="基数排序（radix sort）的基础"></a>基数排序（radix sort）的基础</h1><p>技术排序的定义：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<h1 id="基数排序步骤"><a href="#基数排序步骤" class="headerlink" title="基数排序步骤"></a>基数排序步骤</h1><p>以LSD为例，排序数组arr = [73, 22, 93, 43, 55, 14, 28, 65, 39, 81];<br>    注：最低位优先(Least Significant Digit first)法，简称LSD法<br>        最高位优先(Most Significant Digit first)法，简称MSD法</p>
<ol>
<li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p>
</li>
<li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>PS：LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序适用于：</span><br><span class="line"> *  (1)数据范围较小，建议在小于1000</span><br><span class="line"> *  (2)每个数值都要大于等于0</span><br><span class="line"> * @param  arr 待排序数组</span><br><span class="line"> * @param  maxDigit 最大位数</span><br><span class="line"> */</span><br><span class="line">//LSD Radix Sort</span><br><span class="line">function radixSort(array, maxDigit) &#123;</span><br><span class="line">	var mod = 10;</span><br><span class="line">	var dev = 1;</span><br><span class="line">	var counter = [];</span><br><span class="line">	var arr = array.slice();</span><br><span class="line">	console.time(&apos;基数排序耗时&apos;);</span><br><span class="line">	for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">		for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">			var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">			if(counter[bucket]== null) &#123;</span><br><span class="line">				counter[bucket] = [];</span><br><span class="line">			&#125;</span><br><span class="line">			counter[bucket].push(arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		var pos = 0;</span><br><span class="line">		for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">			var value = null;</span><br><span class="line">			if(counter[j]!=null) &#123;</span><br><span class="line">				while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">					  arr[pos++] = value;</span><br><span class="line">				&#125;</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.timeEnd(&apos;基数排序耗时&apos;);</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</span><br><span class="line">var demo = radixSort(arr,2);</span><br><span class="line">console.log(arr); // [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</span><br><span class="line">console.log(demo); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图">    </p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="noopener">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="noopener">基数排序</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-堆排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="堆排序（Heapsort）的基础"><a href="#堆排序（Heapsort）的基础" class="headerlink" title="堆排序（Heapsort）的基础"></a>堆排序（Heapsort）的基础</h1><p>定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h1 id="我们需要了解什么叫堆"><a href="#我们需要了解什么叫堆" class="headerlink" title="我们需要了解什么叫堆"></a>我们需要了解什么叫堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：<br>        (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点<br>        若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p>
<h2 id="来个例子说明"><a href="#来个例子说明" class="headerlink" title="来个例子说明"></a>来个例子说明</h2><p>【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。<br>    小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。<br>    大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。<br>    注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。<br>    来张图表示一下：<br>    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b360e14f7bec54e755e1124cd851f035/43a7d933c895d1433f14885273f082025aaf0764.jpg" alt="大跟堆和小跟堆"></p>
<h2 id="堆的高度"><a href="#堆的高度" class="headerlink" title="堆的高度"></a>堆的高度</h2><p>堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p><div style="color: red;"><br>    <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>    <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>    <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br></3></2></1></div>    </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>```
/**
 * 对数组中的前n项整理成堆
 * @param array
 * @param n
 */
function refreshHeap(array, n){
    if(array.length&lt;n)n = array.length;

    //array[n/2-1]表示的是最后一个有子节点的节点
    for(let i=Math.floor(n/2)-1;i&gt;=0;i--){
        //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点
        //这个while是判断当前节点与其子节点是否需要调整
        while(2*i+1&lt;n){
            let j = 2*i+1;
            //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点
            if(j+1&lt;n){
                //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点）
                if(array[j]&lt;a[j+1]){
                    j++;
                }
            }
            //如果最大子节点大于其父节点，则交换
            if(a[i]&lt;a[j]){
                let tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
                //交换之后整个堆被破坏，需要重新调整，故令i=j
                //这个调整表示的是从j节点开始判断堆是否需要调整
                //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整
                i = j;
            }else{
                break;
            }
        }
    }
    return array;
}

function heapSort(array, n){
    if(array.length&lt;n)n = array.length;
    while(n&gt;0){
        //刷新堆之后，将array[0]（最大值）与最后一个子节点交换
        //然后重新刷新堆(不包括最后那些排好序的节点了)
        refreshHeap(array, n--);
        let tmp = array[n];
        array[n] = array[0];
        array[0] = tmp;
    }
    return array;
}

var a = [16,7,3,20,17,8];
console.log(a); // [16, 7, 3, 20, 17, 8]
heapSort(a,a.length);
console.log(a); // [3, 7, 8, 16, 17, 20]
```    
</code></pre><p>时间复杂度：T(n) = O(nlogn)<br>空间复杂度：S(n) = O(1)<br>稳定性：不稳定<br>排序方式：内排序    </p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F" alt="动图">    </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/liuyaqi1993/article/details/69569059" target="_blank" rel="noopener">JavaScript数据结构之 堆排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="noopener">堆排序</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-希尔排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="希尔排序（Shell-Sort）的基础"><a href="#希尔排序（Shell-Sort）的基础" class="headerlink" title="希尔排序（Shell Sort）的基础"></a>希尔排序（Shell Sort）的基础</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<h1 id="实现希尔排序（n为待排序arr-length）"><a href="#实现希尔排序（n为待排序arr-length）" class="headerlink" title="实现希尔排序（n为待排序arr.length）"></a>实现希尔排序（n为待排序arr.length）</h1><h2 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p>
<p>该方法实质上是一种分组插入方法</p>
<p>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。<br>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>假设待排序文件有10个记录，其关键字分别是：<br>    592,401,874,141,348,72,911,887,820,283。<br>增量序列的取值依次为：n = 10, 则增量d1 = 10/2 = 5。<br>    5，2，1<br><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" alt="计算过程"><br>    算法时间复杂度：T(n) = O(n*logn^2)<br>    内排序(内存排序就够了)<br>    不稳定(排序后原始顺序无法保证)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function shellSort(array) &#123;</span><br><span class="line">	let arr = array.slice(),</span><br><span class="line">		len = arr.length;</span><br><span class="line">	for(var fraction = Math.floor(len/2); fraction &gt; 0; fraction = Math.floor(fraction/2))&#123;</span><br><span class="line">		// 这里实质上有进行了直接插入排序</span><br><span class="line">		for(var i = fraction; i &lt; len; i++)&#123;</span><br><span class="line">			for(var j = i - fraction; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[fraction + j]; j -= fraction)&#123;</span><br><span class="line">				var temp = arr[j];</span><br><span class="line">				arr[j] = arr[fraction + j];</span><br><span class="line">				arr[fraction + j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr1 = [592,401,874,141,348,72,911,887,820,283];</span><br><span class="line">let arr2 = shellSort(arr1);</span><br><span class="line">console.log(arr1); // [592, 401, 874, 141, 348, 72, 911, 887, 820, 283]</span><br><span class="line">console.log(arr2); // [72, 141, 283, 348, 401, 592, 820, 874, 887, 911]</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：首个增量一般取值为 Math.floor(arr.length/2),对每个分组进行直接插入排序。<br>    重复上面过程，知道增量为1时，整个数组恰被分成一组，算法便终止。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a><br>    <a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="noopener">基本算法学习(一)之希尔排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="noopener">希尔排序</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-归并算法</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="归并排序（MERGE-SORT）基础"><a href="#归并排序（MERGE-SORT）基础" class="headerlink" title="归并排序（MERGE-SORT）基础"></a>归并排序（MERGE-SORT）基础</h1><p>定义：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>实现过程：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
<h1 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h1><p>归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>假设要对数组C进行归并排序，步骤是：<br>    let C = [10, 4, 6, 3, 8, 2, 5, 7];<br>    1.先将C划分为两个数组A和B（即把数组C从中间分开 n = Math.floor(C.length/2)）<br>    2.再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。<br>    3.然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。<br>    4.依次类推，直到合并到最上层结束，这时数据的排序已经完成了。</p>
<h2 id="算法划分和合并过程"><a href="#算法划分和合并过程" class="headerlink" title="算法划分和合并过程"></a>算法划分和合并过程</h2><p><div style="color: red;"><br>    先划分：              [10, 4, 6, 3, 8, 2, 5, 7]<br>    第一次划分：[10, 4, 6, 3]         [8, 2, 5, 7]<br>    第二次划分：[10, 4]   [6, 3]      [8, 2]  [5, 7]<br>    第三次划分：[10] [4] [6] [3]      [8] [2] [5] [7]<br>    再合并：<br>    第一次合并：[4, 10] [3, 6]      [2, 8] [5, 7]<br>    第二次合并：[3, 4, 6, 10]      [2, 5, 7, 8]<br>    第三次合并：[2, 3, 4, 5, 6, 7, 8, 10]<br></div><br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt="图解">    </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function　merge(left, right)&#123;</span><br><span class="line">	var　result=[];</span><br><span class="line">	while(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">		if(left[0] &lt; right[0])&#123;</span><br><span class="line">		/*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/</span><br><span class="line">			result.push(left.shift());</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			result.push(right.shift());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return　result.concat(left).concat(right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function　mergeSort(items)&#123;</span><br><span class="line">	if(items.length === 1)&#123;</span><br><span class="line">		return　items;</span><br><span class="line">	&#125;</span><br><span class="line">	let　middle = Math.floor(items.length/2),</span><br><span class="line">		left = items.slice(0, middle), //得到下标从0~index-1的数组</span><br><span class="line">		right = items.slice(middle); //得到下标从index开始到末尾的数组</span><br><span class="line">	return　merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [10, 4, 6, 3, 8, 2, 5, 7];</span><br><span class="line">let demo = mergeSort(arr)</span><br><span class="line">console.log(arr); // [10, 4, 6, 3, 8, 2, 5, 7]</span><br><span class="line">console.log(demo); // [2, 3, 4, 5, 6, 7, 8, 10]</span><br></pre></td></tr></table></figure>
</code></pre><p>ps：使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。<br>    时间复杂度：O(n log n)<br>    空间复炸都：O（n)<br>    稳定性：稳定<br>    排序方式：外排序</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">图片来源，在此表示感谢</a>    </p>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/fendou_dexiaoniao/article/details/46594125" target="_blank" rel="noopener">JS实现归并排序</a><br>    <a href="https://www.cnblogs.com/lizhancheng/p/3989809.html" target="_blank" rel="noopener">js归并排序法</a><br>    <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin#5_10" target="_blank" rel="noopener">归并排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-快速排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="快速排序（Quicksort）的基础"><a href="#快速排序（Quicksort）的基础" class="headerlink" title="快速排序（Quicksort）的基础"></a>快速排序（Quicksort）的基础</h1><p>定义：快速排序（Quicksort）是对冒泡排序的一种改进。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h1 id="快速排序算法的介绍"><a href="#快速排序算法的介绍" class="headerlink" title="快速排序算法的介绍"></a>快速排序算法的介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br>一趟快速排序的算法是：<br>    1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>    2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>    3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>    4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>    5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<h1 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h1><p>假设用户输入了如下数组：<br><span style="padding-left: 24px; color: red;">6, 2, 7, 3, 8, 9</span><br>1.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。<br>我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：<br><span style="padding-left: 24px; color: red;">3, 2, 7, 6, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=0 j=3 k=6</span><br>接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br><span style="padding-left: 24px; color: red;">i=2 j=3 k=6</span><br>称上面两次比较为一个循环。<br>接着，再递减变量j，不断重复进行上面的循环比较。<br>在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：<br><span style="padding-left: 24px; color: red;">3, 2, 6, 7, 8, 9</span><br>如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。<br>然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。<br>注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前面讲了那么多了，简单就记住下面的步骤就好了。</p>
<p><div style="color: red;"><br>1、找基准（一般是以当前数组的第一项的值）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br></div><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(array)&#123;</span><br><span class="line">	let arr = array.slice();</span><br><span class="line"></span><br><span class="line">	//如果数组&lt;=1,则直接返回</span><br><span class="line">	if(arr.length&lt;=1)&#123;</span><br><span class="line">		return arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//找基准，并把基准从原数组删除</span><br><span class="line">	var pivot=arr.splice(0,1)[0];</span><br><span class="line">	//定义左右数组</span><br><span class="line">	var left=[];</span><br><span class="line">	var right=[];</span><br><span class="line"></span><br><span class="line">	//比基准小的放在left，比基准大的放在right</span><br><span class="line">	for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">		if(arr[i]&lt;=pivot)&#123;</span><br><span class="line">			left.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			right.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//递归</span><br><span class="line">	return quickSort(left).concat([pivot],quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [6, 2, 7, 3, 8, 9];</span><br><span class="line">let demo = quickSort(arr);</span><br><span class="line"></span><br><span class="line">console.log(arr); // [6, 2, 7, 3, 8, 9];</span><br><span class="line">console.log(demo); // [2, 3, 6, 7, 8, 9];</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：T(n) = O(n^2)<br>空间复杂度：S(n) = O(logn)<br>稳定性：不稳定<br>是否为内排序：是</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" alt="动态图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">图片来源网络，在次表示感谢</a></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dll-ft/p/5850487.html" target="_blank" rel="noopener">JS实现快速排序</a><br>    <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&amp;fromid=2084344&amp;fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#3_7" target="_blank" rel="noopener">快速排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-桶排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="桶排序的基础"><a href="#桶排序的基础" class="headerlink" title="桶排序的基础"></a>桶排序的基础</h1><p>桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。<br>桶排序的说明：桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O(n)）。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p>
<h1 id="桶排序的步骤"><a href="#桶排序的步骤" class="headerlink" title="桶排序的步骤"></a>桶排序的步骤</h1><div style="color: red;"><br>1.    找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.    计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.    再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.    将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.    将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br></div>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 插入排序</span><br><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">	var len = arr.length;</span><br><span class="line">	var preIndex, current;</span><br><span class="line">	for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">		preIndex = i - 1;</span><br><span class="line">		current = arr[i];</span><br><span class="line">		while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">			arr[preIndex+1] = arr[preIndex];</span><br><span class="line">			preIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[preIndex+1] = current;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 桶排序</span><br><span class="line">function bucketSort(array, bucketSize) &#123;</span><br><span class="line">	let arr = array.slice();</span><br><span class="line">	let i;</span><br><span class="line">	let minValue = arr[0];</span><br><span class="line">	let maxValue = arr[0];</span><br><span class="line"></span><br><span class="line">	// 空数组时直接返回空数组</span><br><span class="line">	if (arr.length === 0) &#123;</span><br><span class="line">	  return arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">	  if (arr[i] &lt; minValue) &#123;</span><br><span class="line">		  minValue = arr[i];                //输入数据的最小值</span><br><span class="line">	  &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">		  maxValue = arr[i];                //输入数据的最大值</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 桶的初始化</span><br><span class="line">	let DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5</span><br><span class="line">	bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">	let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   </span><br><span class="line">	let buckets = new Array(bucketCount);</span><br><span class="line"></span><br><span class="line">	// 二维数组，每个桶初始化为空数组</span><br><span class="line">	for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">		buckets[i] = [];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 利用映射函数将数据分配到各个桶中</span><br><span class="line">	for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr.length = 0;</span><br><span class="line">	for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">		insertionSort(buckets[i]);                      //对每个桶进行插入排序</span><br><span class="line">		for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">			arr.push(buckets[i][j]);                      </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109];</span><br><span class="line">var demo = bucketSort(arr, 4); // 这里我分配了4个桶，桶越多越快但需要的内存就越多</span><br><span class="line">console.log(arr); // [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]</span><br><span class="line">console.log(demo); // [13, 28, 47, 51, 63, 67, 98, 101, 109, 117, 121, 133, 139, 141, 156, 157, 157, 181, 189, 194]</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br>什么时候最快（Best Cases）：<br>  当输入的数据可以均匀的分配到每一个桶中<br>什么时候最慢（Worst Cases）：<br>  当输入的数据被分配到了同一个桶中</li>
</ol>
<h1 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg" alt="图片展示"></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="noopener">JS的十大经典算法排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin#4_2" target="_blank" rel="noopener">桶排序</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我使用过的面试题</title>
    <url>/2017/%E6%88%91%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="技术基础"><a href="#技术基础" class="headerlink" title="技术基础"></a>技术基础</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="doctype的作用"><a href="#doctype的作用" class="headerlink" title="doctype的作用"></a>doctype的作用</h3><p>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>
<h3 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h3><p>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；<br>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h3 id="data-属性的作用和相关的API操作"><a href="#data-属性的作用和相关的API操作" class="headerlink" title="data-属性的作用和相关的API操作"></a>data-属性的作用和相关的API操作</h3><p>HTML 5 增加了一项新功能是 自定义数据属性 ，也就是  data-* 自定义属性。<br>    在HTML5中我们可以使用以 data- 为前缀来设置我们需要的自定义属性，来进行一些数据的存放。<br>    data数据都属于页面私有，不会被搜索引擎等外部系统引用。<br>相关的API<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;user&quot; data-id=&quot;001&quot; data-uname=&quot;fanerge&quot; data-date-of-birth=&quot;1991-10-15&quot;&gt; &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let dom = document.querySelector(&apos;#user&apos;)</span><br><span class="line">// 老的访问方式</span><br><span class="line">dom.getAttribute(&apos;data-uname&apos;) // fanerge</span><br><span class="line">dom.setAttribute(&apos;data-uname&apos;, &apos;余真帆&apos;) // 余真帆</span><br><span class="line"></span><br><span class="line">// HTML5 提供的访问方法(存在一定的兼容性)</span><br><span class="line">dom.dataset // 一个DOMStringMap</span><br><span class="line">dom.dataset.id // 001</span><br><span class="line">dom.dataset.dateOfBirth // 1991-10-15</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>扩展，data-属性选择器<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// css</span><br><span class="line">.user[data-name=&apos;fanerge&apos;] &#123;</span><br><span class="line">       color: brown;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">document.querySelectorAll(&apos;[data-text-colour=&quot;red&quot;]&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h3><p>defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。<br>    defer (延迟脚本)<br>        相当于告诉浏览器立即下载，但延迟执行（整个页面都解析完毕）。<br>    async(异步脚本)<br>        指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容（css、图片、font等）。<br>        需要注意，异步脚本不要在加载期间修改DOM。 </p>
<h3 id="事件DOMContentLoaded和load的区别"><a href="#事件DOMContentLoaded和load的区别" class="headerlink" title="事件DOMContentLoaded和load的区别"></a>事件DOMContentLoaded和load的区别</h3><p>它们触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。<br>    DOM文档加载的步骤为</p>
<pre><code>1.    解析HTML结构。
2.    加载样式表文件和外部脚本。
3.    解析并执行脚本代码。
4.    DOM树构建完成。//DOMContentLoaded（这里也是jquery的ready方法绑定的时机）
5.    加载图片等外部文件。
6.    页面加载完毕。//load
</code></pre><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ol>
<li><p>与Cookie的比较<br>来看MDN定义：<br>  sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。<br>  localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。<br>  Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies。<br>共同点：都是保存在浏览器端、且同源的<br>区别点：<br>  1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下<br>  2.存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大<br>  3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭<br>  4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的<br>  5.web Storage提供了良好的api如length、key、setItem、getItem、removeItem、clear等方法<br>个人认为产生这些客户端存储的目的是由于 http协议 是无状态，客户端帮助存储客户的操作，发送给服务端以便服务端做出相应的判断。<br>cookie语法：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;name=value; domain=cookieDomain; path=/; &quot;;</span><br><span class="line">;path=path (例如 &apos;/&apos;, &apos;/mydir&apos;) 如果没有定义，默认为当前文档位置的路径。</span><br><span class="line">;domain=domain (例如 &apos;example.com&apos;， &apos;.example.com&apos; (包括所有子域名), &apos;subdomain.example.com&apos;) 如果没有定义，默认为当前文档位置的路径的域名部分。</span><br><span class="line">;max-age=max-age-in-seconds (例如一年为60*60*24*365)</span><br><span class="line">;expires=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期这个值的格式参见Date.toUTCString() </span><br><span class="line">;secure (cookie只通过https协议传输) cookie的值字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).</span><br></pre></td></tr></table></figure>
<p>cookie的路径：（路径能解决在同一个域下访问 cookie 的问题）<br>  出于安全方面的考虑，只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置。<br>  让这个设置的cookie 能被其他目录或者父级的目录访问的方法：<br>  document.cookie = “userName = 独行冰海; path=/“;<br>cookie的域：（域能解决同一个主域下的访问问题）<br>  让 “<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a> 下的cookie被 “mp3.baidu.com” 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 “/“<br>  document.cookie = “username=独行冰海; path=/; domain=baidu.com”</p>
</li>
<li><p>扩展-缓存相关的知识<br>http头部缓存相关key<br>  request header缓存相关</p>
<pre><code>1.cache-control：no-cache、no-store、max-age
2.if-none-match：该字段与响应中的eTag一起使用，表示检查实体是否有更新改变
3.if-modified-since: 该字段与last-modified配合使用
</code></pre><p>  response header缓存相关：</p>
<pre><code>1.Etag：
2.expires：
3.last-modified:
</code></pre></li>
<li><p>应用场景<br>首次注册用户的引导等</p>
</li>
<li><p>在什么情况是失效<br>  1.浏览器清除缓存<br>  2.5M大小的限制<br>  3.IOS safari 的隐私模式（主要我查MDN上有说明，其他浏览器隐私模式会新建 Storage对象，不会与普通模式公用，且关闭隐私模式时 Storage对象 就消失）</p>
</li>
<li><p>浏览器内多个标签页之间的通信<br>1.localstorge + storage 事件<br>  页面1：localStorage.setItem(“name”, ‘测试’);<br>  页面2: window.addEventListener(‘stroge’, (e)=&gt; { console.log(<code>${e.key} = ${e.newValue}</code>) }, false)<br>2.cookie + setInterval（类似于轮询）</p>
</li>
</ol>
<h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><pre><code>History.length
History.scrollRestoration (实验性)-- 允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。
History.state 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。

History.back()
History.forward()
History.go()
History.pushState()
History.replaceState()
</code></pre><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。<br>作用：解决上面问题，window.postMessage() 方法可以安全地实现跨源通信。<br>语法：otherWindow.postMessage(message, targetOrigin, [transfer]);<br>参数：otherWindow<br>        其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。<br>    message<br>        将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。<br>    targetOrigin（安全性从这里入手）<br>        通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。<br>    transfer 可选<br>        是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。<br>其他window监听message事件<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;, receiveMessage, false);</span><br><span class="line"></span><br><span class="line">function receiveMessage(event)&#123;</span><br><span class="line">  // For Chrome, the origin property is in the event.originalEvent</span><br><span class="line">  // object.</span><br><span class="line">  var origin = event.origin || event.originalEvent.origin; </span><br><span class="line">  if (origin !== &quot;http://example.org:8080&quot;)</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">  // todo...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：message 的属性有:<br>    data<br>        从其他 window 中传递过来的对象。<br>    origin<br>        调用 postMessage  时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “<a href="https://example.org" target="_blank" rel="noopener">https://example.org</a> (implying port 443)”、“<a href="http://example.net" target="_blank" rel="noopener">http://example.net</a> (implying port 80)”、“<a href="http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。" target="_blank" rel="noopener">http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。</a><br>    source<br>        对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。    </p>
<p>关注下安全性问题<br>    1.如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。<br>    2.请始终使用origin和source属性验证发件人的身份，还应该始终验证接收到data的消息的语法。<br>    3.当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">详细需了解-MDN</a></p>
<h4 id="WebSocket对象"><a href="#WebSocket对象" class="headerlink" title="WebSocket对象"></a>WebSocket对象</h4><p>作用：<br>    提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。<br>    WebSocket构造器方法接受一个必须的参数和一个可选的参数：<br>语法：<br>    WebSocket WebSocket(in DOMString url,in optional DOMString[] protocols);<br>具体参数：<br>    url – 表示要连接的URL。这个URL应该为响应WebSocket的地址。<br>    protocols 可选 – 可以是一个单个的协议名字字符串或者包含多个协议名字字符串的数组。这些字符串用来表示子协议，这样做可以让一个服务器实现多种WebSocket子协议（例如你可能希望通过制定不同的协议来处理不同类型的交互）。如果没有制定这个参数，它会默认设为一个空字符串。<br>属性：<br>    binaryType、onclose、onerror、onmessage、onopen（EventListener）<br>方法：<br>    void send(in DOMString data);<br>    void close(in optional unsigned long code, in optional DOMString reason);<br>构造器方法可能抛出以下异常：<br>    SECURITY_ERR – 试图连接的端口被屏蔽。<br>示例：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Create WebSocket connection.</span><br><span class="line">const socket = new WebSocket(&apos;ws://localhost:8080&apos;);</span><br><span class="line"></span><br><span class="line">// Connection opened</span><br><span class="line">socket.addEventListener(&apos;open&apos;, function (event) &#123;</span><br><span class="line">	socket.send(&apos;Hello Server!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Listen for messages</span><br><span class="line">socket.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">	console.log(&apos;Message from server&apos;, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">MDN-WebSocket</a></p>
<p>扩展（Ajax轮询）这是比较原始的方案<br>    定义：轮询（polling）：客户端按规定时间定时向服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.setInterval(function()&#123;$.ajax(getting)&#125;,1000);</span><br></pre></td></tr></table></figure></p>
<pre><code>长轮询（递归）
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getting = &#123;</span><br><span class="line">	url:&apos;server.php&apos;,</span><br><span class="line">	dataType:&apos;json&apos;,</span><br><span class="line">	success:function(res) &#123;</span><br><span class="line">		// todo...</span><br><span class="line">		$.ajax(getting); //关键在这里，回调函数内再次请求Ajax</span><br><span class="line">	&#125;        </span><br><span class="line">	error:function(res)&#123;</span><br><span class="line">		$.ajax(getting);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">$.ajax(getting); // 这里第一次调用ajax</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="CMD和AMD以及UMD，UMD的实现"><a href="#CMD和AMD以及UMD，UMD的实现" class="headerlink" title="CMD和AMD以及UMD，UMD的实现"></a>CMD和AMD以及UMD，UMD的实现</h4><p>AMD（浏览器环境）– RequireJS<br>CMD（Node） – CommonJS<br>UMD: 通用模块规范（兼容低版本浏览器设置在window上的属性如window.$ – 代表jquery）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 自己封装一个符合UMD的功能函数库取名 fanerge</span><br><span class="line">(function (window, factory) &#123;</span><br><span class="line">	if (typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">		// UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。</span><br><span class="line">		module.exports = factory();</span><br><span class="line">	&#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">		// 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</span><br><span class="line">		define(factory);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 否则就绑定到全局的一个属性上，这里绑定到window对象的fanerge属性上</span><br><span class="line">		window.fanerge = factory();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)(this, function () &#123;</span><br><span class="line">	let fanerge = &#123;&#125;;</span><br><span class="line">	fanerge.alert = function alert() &#123;</span><br><span class="line">		alert(&apos;fanerge&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fanerge.log = function log() &#123;</span><br><span class="line">		console.log(&apos;fanerge&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return fanerge;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用时</span><br><span class="line">fanerge.log()</span><br></pre></td></tr></table></figure></p>
<h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>分类：专用worker（一个专用worker仅仅能被生成它的脚本所使用）、共享worker<br>作用：Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。<br>限制：在worker内直接操作DOM节点，或者使用window对象的默认方法和属性。<br>主线程与worker数据传递：workers和主线程间的数据传递通过这样的消息机制进行——双方都使用postMessage()方法发送各自的消息，使用onmessage事件处理函数来响应消息（消息被包含在Message事件的data属性中）。这个过程中数据并不是被共享而是被复制。<br>终止worker：<br>    在主线程中终止：workerName.terminate(); worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。<br>    在worker中终止：close();<br>处理错误：onerror 事件处理函数会被调用，对应的参数，message – 可读性良好的错误消息；filename – 发生错误的脚本文件名；lineno – 发生错误时所在脚本文件的行号。<br>生成subworker： 在worker 中能够生成 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。<br>引入脚本与库：Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；<br>共享worker与专有worker的区别：<br>    1.创建worker<br>        var myWorker = new Worker(‘worker.js’); // 专有<br>        var myWorker = new SharedWorker(‘worker.js’); // 共享<br>    2.通信（发送消息和接收消息都需要携带port）<br>        父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。<br>        myWorker.port.start();  // 父级线程中的调用<br>        port.start(); // worker线程中的调用, 假设port变量代表一个端口<br>        共享worker中消息的接收和发送<br>        消息可以像之前那样发送到worker了，但是postMessage() 方法必须被端口对象调用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">详情参考MDN-web Worker</a></p>
<h4 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h4><p>1、File- 单个文件；提供了诸如file name、file size、mimetype等只读文件属性。<br>2、FileList- 一个类数组File对象集合；<br>构造函数<br>    File()  返回一个新构建的文件对象（File）。<br>属性<br>    File.lastModified – 返回当前 File 对象所引用文件最后修改时间， 自 1970年1月1日0:00 以来的毫秒数。<br>    File.name – 返回当前 File 对象所引用文件的名字。<br>    File.size – 返回文件的大小。<br>    File.type – 返回文件的 多用途互联网邮件扩展类型。<br>获取用户选择文件的方式<br>    来自用户在一个input元素上选择文件后返回的FileList对象。<br>        e.target.files; //FileList<br>    来自拖放操作生成的 DataTransfer对象。<br>        e.dataTransfer.files; //FileList<br>    来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。</p>
<h4 id="FileReader-API"><a href="#FileReader-API" class="headerlink" title="FileReader API"></a>FileReader API</h4><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>构造函数<br>    FileReader() – 返回一个新构造的FileReader。<br>属性：<br>    error    DOMError    在读取文件时发生的错误. 只读.<br>    readyState    unsigned short    表明FileReader对象的当前状态. 值为State constants中的一个. 只读<br>    result    jsval    读取到的文件内容.这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的. 只读.<br>方法：<br>    void abort();<br>    void readAsArrayBuffer(in Blob blob);<br>    void readAsBinaryString(in Blob blob);<br>    void readAsDataURL(in Blob blob);<br>    void readAsText(in Blob blob, [optional] in DOMString encoding);<br>事件处理程序：<br>    onabort – 当读取操作被中止时调用.<br>    onerror – 当读取操作发生错误时调用.<br>    onload – 当读取操作成功完成时调用.<br>    onloadend – 当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用.<br>    onloadstart – 当读取操作将要开始之前调用.<br>    onprogress – 在读取数据过程中周期性调用.<br>示例（本地文件预览）<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let oFReader = new FileReader(), // 新建一个 FileReader实例</span><br><span class="line">	rFilter = /^(?:image\/bmp|image\/)$/i; // 可以读取的文件格式</span><br><span class="line">	</span><br><span class="line">// 文件异步读取完成时，将设置预览组件的 src 属性</span><br><span class="line">oFReader.onload = function (oFREvent) &#123;</span><br><span class="line">	document.getElementById(&quot;uploadPreview&quot;).src = oFREvent.target.result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 加载用户选择的图片</span><br><span class="line">function loadImageFile() &#123;</span><br><span class="line">	// 没有选择文件</span><br><span class="line">	if (document.getElementById(&quot;uploadImage&quot;).files.length === 0) &#123; return; &#125;</span><br><span class="line">	var oFile = document.getElementById(&quot;uploadImage&quot;).files[0];</span><br><span class="line">	// 文件的 MIMETYPE 不满足当前正则</span><br><span class="line">	if (!rFilter.test(oFile.type)) &#123; return; &#125;</span><br><span class="line">	// 读取文件</span><br><span class="line">	oFReader.readAsDataURL(oFile);</span><br><span class="line">&#125;</span><br><span class="line">loadImageFile()</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h3 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别"></a>块级元素和行内元素的区别</h3><h3 id="CSS-sprites"><a href="#CSS-sprites" class="headerlink" title="CSS sprites"></a>CSS sprites</h3><h3 id="line-height-和-vertical-align"><a href="#line-height-和-vertical-align" class="headerlink" title="line-height 和 vertical-align"></a>line-height 和 vertical-align</h3><p>line-height的值由font-size和字体类型共同决定。<br>vertical-align的值<br>    vertical-align: top / bottom，表示与 line-box 的顶部或底部对齐<br>    vertical-align: text-top / text-bottom，表示与 content-area 的顶部或底部对齐</p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>需要配合脱离文档流的属性使用，position: relative, absolute, fixed。</p>
<h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>以Bootstrap3为例（12栅格系统）<br>    采用float + width(百分比) + @media(媒体查询实现适配)<br>以Bootstrap4为例<br>    采用容器flex布局（容器6个属性，子项目6个属性）</p>
<h3 id="Media-Query"><a href="#Media-Query" class="headerlink" title="Media Query"></a>Media Query</h3><p>语法：<br>    1.link元素中的CSS媒体查询<br>        <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</code><br>    2.样式表中的CSS媒体查询<br>        @media (max-width: 600px) { … }<br>逻辑操作符:<br>    all（默认）<br>    not – not 关键字应用于整个媒体查询，在媒体查询为假时返回真 (比如 monochrome 应用于彩色显示设备上或一个600像素的屏幕应用于 min-width: 700px 属性查询上 )。<br>    and – and关键字用于合并多个媒体属性或合并媒体属性与媒体类型。<br>        @media tv and (min-width: 700px) and (orientation: landscape) { … }<br>    only – only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式<br>        <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;</code></p>
<h3 id="CSS选择器的性能优化"><a href="#CSS选择器的性能优化" class="headerlink" title="CSS选择器的性能优化"></a>CSS选择器的性能优化</h3><p>说明：<br>    1.样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。<br>    2.如果你非常在意页面的性能那千万别使用CSS3选择器。实际上，在所有浏览器中，用 class 和 id 来渲染，比那些使用同胞，后代选择器，子选择器（sibling, descendant and child selectors）对页面性能的改善更值得关注。<br>CSS选择器的效率从高到低排序：<br>    1.id选择器（#myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[rel=”external”]）9.伪类选择器（a:hover,li:nth-child）<br>具体做法：<br>    1.不要在编写id规则时用标签名或类名<br>    2.不要在编写class规则时用标签名<br>    3.把多层标签选择规则用class规则替换，减少css查找<br>    4.避免使用子选择器<br>    5.依靠继承<br>    <a href="http://www.aliued.cn/2013/01/24/%E7%BD%91%E7%AB%99css%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%A7%E8%83%BD%E8%AE%A8%E8%AE%BA.html" target="_blank" rel="noopener">参考阿里文章</a></p>
<h3 id="CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考"><a href="#CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考" class="headerlink" title="CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考"></a>CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考</h3><p><a href="https://www.sass.hk/" target="_blank" rel="noopener">SASS</a></p>
<h3 id="Webfonts"><a href="#Webfonts" class="headerlink" title="Webfonts"></a>Webfonts</h3><p>作用：WebFont 技术可以让网页使用在线字体，而无需使用图片，从而有机会解决开头设计师提到的问题。它通过 CSS 的@font-face语句引入在线字体，使用 CSS 选择器指定运用字体的文本，与此同时专用于 Web 展示的 woff 格式字体也得到各大浏览器厂商支持，进一步减少了字体的体积。<br>语法：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &apos;ciclefina&apos;;</span><br><span class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot&apos;);</span><br><span class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">		 url(&apos;fonts/cicle_fina-webfont.woff2&apos;) format(&apos;woff2&apos;);</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  font-style: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WebFont的优势：<br>    支持选中、复制<br>    支持 Ctrl+F 查找<br>    对搜索引擎友好<br>    支持工具翻译<br>    支持无障碍访问，支持朗读<br>    字体是矢量图形，支持矢量缩放，自动适配高清屏<br>    文本修改方便<br>    字形可以重复利用，节省网络资源<br>中文 WebFont 的困境：<br>    1、中文字体体积<br>    2、浏览器类型（各种壳的浏览器）<br>    3、操作系统（主要是XP系统）<br>现有的中文 WebFont 解决方案：<br>    1.本地制作<br>        通过字体制作工具来删除没有使用的字符，即制作精简版字体，这也是我之前实践过的方案。</p>
<pre><code>2. 字体云服务    
</code></pre><p><a href="https://www.youziku.com/" target="_blank" rel="noopener">https://www.youziku.com/</a><br>    3开源工具<br><a href="http://font-spider.org/" target="_blank" rel="noopener">字蛛（Font-Spider）</a><br><a href="http://www.uisdc.com/the-great-chinese-webfont" target="_blank" rel="noopener">参考Webfont</a>        </p>
<h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><p>说明：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>    由容器 Container 和 子项目 Item 构成。</p>
<h4 id="Container-容器相关的属性"><a href="#Container-容器相关的属性" class="headerlink" title="Container 容器相关的属性"></a>Container 容器相关的属性</h4><p>首先 display: flex / inline-flex;<br>flex-direction – 决定主轴的方向（即项目的排列方向）。<br>flex-wrap – 如果一条（主轴）轴线排不下，如何换行。<br>flex-flow – 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br>justify-content – 定义了项目在主轴上的对齐方式。<br>align-items – 定义项目在交叉轴上如何对齐。<br>align-content – 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<h4 id="Item-子项目相关的属性"><a href="#Item-子项目相关的属性" class="headerlink" title="Item 子项目相关的属性"></a>Item 子项目相关的属性</h4><p>order – 定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow – 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink – 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-basis – 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>flex – 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>align-self – 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮老师博客-Flex</a>        </p>
<h4 id="适配retina屏幕"><a href="#适配retina屏幕" class="headerlink" title="适配retina屏幕"></a>适配retina屏幕</h4><p>什么是retina屏幕适配？<br>    当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。<br>    换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。<br>适配方法：<br>1.直接加载2倍大小的图片。<br>    假如要显示的图片大小为200px<em>300px，你准备的实际图片大小应该为400px</em>600px，并且使用以下代码控制即可：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;pic.png&quot; height=&quot;200px&quot; width=&quot;300px&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>缺点：
    对于普通屏来说加载多倍图势必会导致页面加载时间加长，用户体验不佳。
更好的方案：
</code></pre><p><a href="http://imulus.github.io/retinajs/" target="_blank" rel="noopener">开源retina.js</a><br>原理是通过window.devicePixelRatio &gt; 1判断是不同屏还是retina屏，然后再加载对应的几倍图。<br>2.Image-set控制<br>    假如要显示的图片大小为200px<em>300px，你准备的图片应有两张：一张大小为200px</em>300px，命名为pic.png；另一张大小为400px*600px，命名为<a href="mailto:pic@2x.png" target="_blank" rel="noopener">pic@2x.png</a>（@2x是Retina图标的标准命名方式），然后使用以下css代码控制：<br>    背景方式使用：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#logo &#123;</span><br><span class="line">	background: url(pic.png) 0 0 no-repeat;</span><br><span class="line">	background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x);</span><br><span class="line">	background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);</span><br><span class="line">	background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);</span><br><span class="line">	background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>在img标签属性中使用：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;pic.png&quot; srcset=&quot;pic@2x.png 2x&quot; /&gt;</span><br></pre></td></tr></table></figure>
</code></pre><p>3.使用@media控制<br>    实际是判断屏幕的像素比来取舍是否显示高分辨率图像，代码如下：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 1.5),</span><br><span class="line">  only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */</span><br><span class="line">  only screen and (-o-min-device-pixel-ratio: 3/2),</span><br><span class="line">  only screen and (min-device-pixel-ratio: 1.5) &#123;</span><br><span class="line">	#logo &#123;</span><br><span class="line">		background-image: url(pic@2x.png);</span><br><span class="line">		background-size: 100px auto;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.ui.cn/detail/24556.html" target="_blank" rel="noopener">参考文章</a>        </p>
<h4 id="CSS3新增伪类以含义"><a href="#CSS3新增伪类以含义" class="headerlink" title="CSS3新增伪类以含义"></a>CSS3新增伪类以含义</h4><p>p:first-letter    选择每一个P元素的第一个字母<br>p:first-line    选择每一个P元素的第一行<br>p:first-child    指定只有当p元素是其父级的第一个子级的样式<br>p:last-child    选择每个p元素是其父级的最后一个子级。<br>p:first-of-type    选择每个p元素是其父级的第一个p元素<br>p:last-of-type    选择每个p元素是其父级的最后一个p元素<br>p:only-of-type    选择每个p元素是其父级的唯一p元素<br>p:only-child    选择每个p元素是其父级的唯一子元素<br>p:nth-child(2)    选择每个p元素是其父级的第二个子元素<br>p:nth-last-child(2)    选择每个p元素的是其父级的第二个子元素，从最后一个子项计数<br>p:nth-of-type(2)    选择每个p元素是其父级的第二个p元素<br>p:nth-last-of-type(2)    选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</p>
<p>:root    选择文档的根元素<br>p:empty    选择每个没有任何子级的p元素（包括文本节点）<br>input:enabled    选择每一个已启用的输入元素<br>input:disabled    选择每一个禁用的输入元素<br>input:checked    选择每个选中的输入元素<br>:not(p)    选择每个并非p元素的元素<br>::selection    匹配元素中被用户选中或处于高亮状态的部分</p>
<p>a[src^=”https”]    选择每一个src属性的值以”https”开头的元素<br>a[src$=”.pdf”]    选择每一个src属性的值以”.pdf”结尾的元素<br>a[src*=”runoob”]    选择每一个src属性的值包含子字符串”runoob”的元素</p>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="JavaScript语言"><a href="#JavaScript语言" class="headerlink" title="JavaScript语言"></a>JavaScript语言</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>定义：定义在一个函数内部的函数（将函数内部的变量保留在内存中，这样外部就可以改函数内相关的变量）。<br>    闭包就是能够读取其他函数内部变量的函数。<br>用途：一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>    1.匿名自执行函数 (function(){ // todo… })()<br>    2.缓存（针对于复杂的计算，每次计算前先读缓存如果没有在进行计算并添加到缓存）<br>    3.实现封装（可以将函数内部的变量通过暴露接口在函数外可以访问）<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = function()&#123;    </span><br><span class="line">	//变量作用域为函数内部，外部无法访问    </span><br><span class="line">	var name = &quot;default&quot;;       </span><br><span class="line">	   </span><br><span class="line">	return &#123;    </span><br><span class="line">	   getName : function()&#123;    </span><br><span class="line">		   return name; // 可以访问 name 属性    </span><br><span class="line">	   &#125;,    </span><br><span class="line">	   setName : function(newName)&#123;    </span><br><span class="line">		   name = newName; // 可以为 name 赋值    </span><br><span class="line">	   &#125;    </span><br><span class="line">	&#125;    </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<pre><code>4.闭包的另一个重要用途是实现面向对象中的对象
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;    </span><br><span class="line">	var name = &quot;default&quot;;       </span><br><span class="line">	   </span><br><span class="line">	return &#123;    </span><br><span class="line">	   getName : function()&#123;    </span><br><span class="line">		   return name;    </span><br><span class="line">	   &#125;,    </span><br><span class="line">	   setName : function(newName)&#123;    </span><br><span class="line">		   name = newName;    </span><br><span class="line">	   &#125;    </span><br><span class="line">	&#125;    </span><br><span class="line">&#125;;    </span><br><span class="line">	  </span><br><span class="line">var john = Person();    </span><br><span class="line">john.getName();   </span><br><span class="line">john.setName(&quot;john&quot;);    </span><br><span class="line">john.getName();</span><br></pre></td></tr></table></figure>
</code></pre><p><a href="http://www.jb51.net/article/57259.htm" target="_blank" rel="noopener">51脚本</a></p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量作用域<br>函数作用域<br>块级作用域<br>    ES6提出，let 和 const 声明。{}范围为该区域<br>    建议在支持的环境尽量使用 let 和 const 代替 var。<br>作用域链<br>    动态作用域 – 函数执行时才确定的。this（4种情况，资料较多这里不再阐述）<br>    静态作用域 – 函数定义时就确定的。<br>    函数的可以允许嵌套的。例如有一个全局函数a， 在 a 在有又定义了函数 b，此时就形成了一条作用域链。<br>        b -&gt; a -&gt; window(浏览器)/global(Node环境)</p>
<h4 id="原型（-gt-代表指向）"><a href="#原型（-gt-代表指向）" class="headerlink" title="原型（-&gt; 代表指向）"></a>原型（-&gt; 代表指向）</h4><p>Number.prototype(有一些自己的方法如，toFixed) -&gt; Object.prototype (对象所有的方法) -&gt; undefined(原型链的顶层，为null)<br>Number、String、Boolean、Array、Date、RegExp、都是上面的原型链。<br>Math对象有点特殊，无需在使用这个对象之前对它进行定义。类似于在该对象上定义了许多静态属性和静态方法，可以直接使用（Math.PI、Math.abs(-3)）。<br><img src="http://oxpnrlb4j.bkt.clouddn.com/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="搞懂这张就好了"></p>
<h4 id="面向对象-继承"><a href="#面向对象-继承" class="headerlink" title="面向对象/继承"></a>面向对象/继承</h4><p><a href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象</a><br><a href="https://fanerge.github.io/2017/08/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-1/">继承</a><br><a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">JS实现继承的几种方式</a></p>
<h4 id="this（也就是说的动态作用域）"><a href="#this（也就是说的动态作用域）" class="headerlink" title="this（也就是说的动态作用域）"></a>this（也就是说的动态作用域）</h4><p>1.普通函数（挂载到全局上面）<br>    在 ‘use strict’ 严格模式中指向 undefined<br>    在非严格模式中指向window/global（适执行环境而定）<br>2.对象的方法<br>    this 指向该对象<br>3.作为构造函数调用<br>    this 指向该构造函数的实例<br>4.call、apply以及bind方法可以改变this指向<br>    this 均指向第一个参数<br>    区别：call、apply返回值是你调用的方法的返回值；而bind返回由指定的this值和初始化参数改造的原函数拷贝。<br>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">这三个方法的区别，请访问MDN</a></p>
<h4 id="call和apply的作用，以及区别"><a href="#call和apply的作用，以及区别" class="headerlink" title="call和apply的作用，以及区别"></a>call和apply的作用，以及区别</h4><p>参见上面        </p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>1.过去常用于设计为一个独立的作用域<br>    (function(形参){ // todo })(实参);<br>2.函数声明也是匿名函数<br>    let demo = function(){};        </p>
<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>1.描述几个正则的语法含义，比如：[]、{}、\w、\d、\s等<br>    [abc]    查找方括号之间的任何字符。<br>    [^abc]    查找任何不在方括号之间的字符。<br>    [0-9]    查找任何从 0 至 9 的数字。<br>    n{X}    匹配包含 X 个 n 的序列的字符串。<br>    n{X,}    前面的模式 n 连续出现至少 X 次时匹配。<br>    n{X,Y}    前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。<br>    PS：所有的大写均表示非。<br>    \w    查找单词字符。<br>    \d    查找数字。<br>    \s    查找空白字符。包括空格符、制表符、回车符、换行符、垂直换行符、换页符<br>    \b    匹配单词边界。<br>2.i/g/m等的含义（ES6中添加u、y）<br>    i – ignore（忽略大小写）<br>    g – global（全局匹配及查找所有匹配而非在找到第一个匹配后停止）<br>    m – multiple（执行多行匹配）<br>    ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。<br>    ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。<br>3.replace方法<br>    第二个参数为string – string.replace(searchvalue,newvalue)<br>    第二个参数是回调函数<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.replace(/(^\s+)|(\s+$)/g,function(result,$1,$2,offset,source)&#123;</span><br><span class="line">	//arguments中的每个元素对应一个参数</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>具体参数说明：<br>result: 本次匹配到的结果<br>$1,…$9: 正则表达式中有几个()，就会传递几个参数，$1~$9分别代表本次匹配中每个()提取的结果，最多9个<br>offset:记录本次匹配的开始位置<br>source:接受匹配的原始字符串<br>4.匹配任意字符（使用互补的方式来实现）<br>    [\s\S] 或 [\w\W] 或 [.\r\n]<br>    注：\w 等价于 [A-Za-z0-9_]<br><a href="http://www.jb51.net/article/80544.htm" target="_blank" rel="noopener">51job</a>            </p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>1.DOM事件流<br>    冒泡：事件冒泡的过程是：a –&gt; div –&gt; body 。<br>        产生的原因：因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。<br>        处理问题：event.stopPropagation()阻止事件的传递行为。<br>        应用：事件委托<br>    捕获：事件从Document节点自上而下向目标节点传播的阶段<br>    完整的DOM事件流模型：<br>        捕获阶段 、目标阶段 、冒泡阶段<br>2.兼容性问题（优先级逐渐升高）<br>    html的onclick属性绑定<br>    dom.onclick = function(){}<br>    dom.attachEvent(“onclick”, callback) // dom.detachEvent(“onclick”, callback)<br>    dom.addEventListener(‘click’, callback, userCapture) // dom.removeEventListener(‘click’, callback, userCapture)<br>3.事件代理<br>    原理为事件冒泡<br>    例如一下DOM结构<br>    ul<br>        li<br>        li<br>    对ul绑定事件，而不是对li绑定事件。在通targe.tagName，以及点的是哪一个li做不用的操作。<br>4.自定义事件<br>    如何实现一个自定义事件的系统<br>    定义：自定义事件就是自己定义事件类型，自己定义事件处理函数，在合适的时候需要哪个事件类型，就去调用哪个处理程。<br>    实现过程：（其实就是发布订阅模式或监听者模式）<br>1.定义自定义事件构造函数<br>            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function EventTarget()&#123;</span><br><span class="line">	//保存事件处理程序数组集合，每个实例不共享</span><br><span class="line">	this.handlers = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.在构造函数的原型上添加实例共享的方法<br>            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">	constructor: EventTarget, // 矫正原型链指向</span><br><span class="line">	addEvent: function(type, handler) &#123;&#125;, // 添加一个事件处理函数</span><br><span class="line">	addEvents: function(obj)&#123;&#125;, // 批量添加事件</span><br><span class="line">	removeEvent: function(type, handler)&#123;&#125;, // 移除一个事件处理函数</span><br><span class="line">	removeEvents: function(params) &#123;&#125;, // 批量移除事件</span><br><span class="line">	fireEvent: function(type) &#123;&#125;, // 触发一个事件</span><br><span class="line">	fireEvents: function(array) &#123;&#125; // 批量触发事件</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3.调用<br>            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">  console.log(123);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var target = new EventTarget();</span><br><span class="line">target.addEvent(&quot;eat&quot;, b);</span><br><span class="line"> </span><br><span class="line">target.fireEvent(&#123; type: &quot;eat&quot; &#125;); // 12</span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/wkyseo/article/details/53609509" target="_blank" rel="noopener">详细信息参考博客</a></p>
<h4 id="BOM-DOM"><a href="#BOM-DOM" class="headerlink" title="BOM/DOM"></a>BOM/DOM</h4><p>BOM – 浏览器对象模型（Browser Object Model，简称BOM）。<br>    提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本，对Cookie的支持等。<br>    Window 对象<br>    Navigator 对象<br>    Screen 对象<br>    History 对象<br>    Location 对象<br>DOM – 文档对象模型（Document Object Model，简称DOM）。<br>    DOM 就是针对 HTML 和 XML 提供的一个API。<br>    兼容性问题<br>    常规的增删改查等操作的原生方法的考核<br>    查：<br>        getElementById()、<br>        getElementsByTagName()、<br>        getElementsByName()、<br>        getElementsByClassName()、<br>        querySelector()、<br>        querySelectorAll()<br>    改：<br>        document.getElementById(id).innerHTML=new value：修改HTML元素<br>        document.getElementById(id).attribute=new value：修改元素属性<br>        document.getElementById(id).style.property=new style：修改元素CSS<br>        setAttribute()：setAttribute()方法将设置元素中某个属性和值<br>        parent.replaceChild(child,oldElem)：替换节点<br>    增：<br>        A.append(B) : 把B追加到A内部（所有的A元素，以下类似）<br>        A.appendTo(B) : 把A追加到B内部<br>        A.prepend(B) : 把B追加到A内部的内容前(即B成为A第一个子元素)<br>        A.prependTo(B) : 把A追加到B的内容前（即A成为B第一个子元素）<br>        A.after(B) : 在A后追加B<br>        A.before(B): 在A前追加B<br>        node.insertBefore(A,B): 在父节点node里面的B节点前面追加A<br>        parent.replaceChild(child,oldElem)：替换节点<br>    删：<br>        dom.remove()：删除该元素<br>        parent.removeChild(child)：删除子元素</p>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>1.JS实现一个动画的方式<br>    setTimeout、<br>    setInterval、<br>    setImmediate（window.clearImmediate）微软取消该方法，不建议使用、<br>    window.requestAnimationFrame(callback)（window.cancelAnimationFrame() ）<br>        参数：一个在每次需要重新绘制动画时调用的包含指定函数的参数。<br>        这个回调函数有一个传参，DOMHighResTimeStamp，指示从触发 requestAnimationFrame 回调到现在的时间。<br>2.CSS3的动画<br>    申明一个动画：<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes animationName &#123;</span><br><span class="line">	from &#123;background: red;&#125;</span><br><span class="line">	to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>    PS：参数说明，animationname、keyframes-selector（from（0%）、to（100%））、css-styles
使用一个动画：
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div:hover &#123;</span><br><span class="line">	animation: animationName 5s;</span><br><span class="line">&#125;</span><br><span class="line">PS：animation: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br></pre></td></tr></table></figure>
</code></pre><p>3.如何优化动画的流畅度<br>    每一帧都需要在16ms内渲染<br>    动画添加到opacity和transform等属性之上。<br>    将内容藏在不起眼的地方，使用pointer-events:通过透明度为0来隐藏元素。<br>    不要同一时间所有元素都做动画，除非使用编排。<br>    轻微地增加延迟，让编排动作变得简单。<br>    使用全局倍数来设计慢动画，然后加速之后所有的元素。<br>    拍下你的UI，并且重放他们，以获取有价值的第三方关点。<br>    网络活动导致滞后，你需要提前或者滞后加载大的http请求。<br>    不要直接绑定滚动。<br>    尽早&amp;经常在手机上测试。<br>    在不同的设备上经常测试，屏幕大小，像素，或者设备都有着极大的暗示。<br>4.animation-fill-mode<br>    animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。<br>    属性值：none | forwards | backwards | both<br><a href="http://www.open-open.com/lib/view/open1480991763196.html" target="_blank" rel="noopener">流畅web动画的十个法则</a></p>
<h4 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h4><h4 id="动画事件-自定义事件（start、process、end等）"><a href="#动画事件-自定义事件（start、process、end等）" class="headerlink" title="动画事件/自定义事件（start、process、end等）"></a>动画事件/自定义事件（start、process、end等）</h4><p>animationstart - CSS 动画开始后触发<br>animationiteration - CSS 动画重复播放时触发<br>animationend - CSS 动画完成后触发</p>
<h4 id="shim和polyfill"><a href="#shim和polyfill" class="headerlink" title="shim和polyfill"></a>shim和polyfill</h4><p>polyfill 是 shim 的一种。<br>shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；<br>polyfill 特指 shim 成的 api 是遵循标准的，其典型做法是在IE浏览器中增加 window.XMLHttpRequest ，内部实现使用 ActiveXObject。</p>
<h4 id="Ajax-跨域"><a href="#Ajax-跨域" class="headerlink" title="Ajax/跨域"></a>Ajax/跨域</h4><p>1.对Ajax的作用、API方法的理解<br>    Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。<br>    XMLHttpRequest(ActiveXObject 兼容版本ie)或新的Fetch API<br>    重点研究下Fetch API<br>        Fetch API提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。<br>        Fetch 接口<br>GlobalFetch<br>    包含了 fetch() 方法，用于获取资源。<br>Headers（构造器）<br>    相当于 response/request 的头信息，可以修改它，或者针对不同的结果做不同的操作。<br>    Headers.append()<br>        给现有的header添加一个值, 或者添加一个未存在的header并赋值.<br>    Headers.delete()<br>        从Headers对象中删除指定header.<br>    Headers.get()<br>        从Headers对象中返回指定header的第一个值.<br>    Headers.getAll()<br>        以数组的形式从Headers对象中返回指定header的全部值.<br>    Headers.has()<br>        以布尔值的形式从Headers对象中返回是否存在指定的header.<br>    Headers.keys()<br>        以迭代器的形式返回Headers对象中所有存在的header名.<br>    Headers.set()<br>        替换现有的header的值, 或者添加一个未存在的header并赋值.<br>    Headers.values()<br>        以迭代器的形式返回Headers对象中所有存在的header的值.<br>    Headers.entries()<br>        以 迭代器 的形式返回Headers对象中所有的键值对.<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myHeaders = new Headers();</span><br><span class="line">myHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);</span><br><span class="line">myHeaders.set(&quot;Content-Type&quot;, &quot;text/html&quot;);</span><br><span class="line">console.log(myHeaders.get(&quot;Content-Length&quot;)); // 11</span><br><span class="line">myHeaders.delete(&quot;X-Custom-Header&quot;);</span><br><span class="line">myHeaders.has(&quot;Content-Type&quot;)</span><br></pre></td></tr></table></figure></p>
<p>Body<br>    代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。<br>    Body.bodyUsed（属性）<br>        包含一个指示body是否被读取过的 Boolean 值。<br>    Body.arrayBuffer()<br>        使用一个buffer数组来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.blob()<br>        使用一个Blob对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.formData()<br>        使用一个 FormData 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.json()<br>        使用一个 JSON 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    Body.text()<br>        使用一个USVString (文本) 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body" target="_blank" rel="noopener">MDN-Fetch-body</a><br>Request（构造器）<br>    相当于一个资源请求。<br>    Request.method 只读<br>        请求使用的方法 (GET, POST, 等.)<br>    Request.url 只读<br>        请求使用的 URL。<br>    Request.headers 只读<br>        请求所关联的 Headers 对象。<br>    Request.context 只读<br>        请求的上下文 例如：(例如：audio, image, iframe, 等)<br>    Request.referrer 只读<br>        请求的来源 (例如：client).<br>    Request.mode 只读<br>        请求的模式 (例如： cors, no-cors, same-origin).<br>    Request.credentials 只读<br>        请求的凭证 (例如： omit, same-origin).<br>    Request.redirect 只读<br>        如何处理重定向模式 (例如： follow, error, or manual)<br>    Request.integrity 只读<br>        请求内容的 subresource integrity 值 (例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).<br>    Request.cache 只读<br>        请求的缓存模式 (例如： default, reload, no-cache).<br>    Body.bodyUsed 只读<br>        指示body是否被使用， 类型为Boolean<br>    Request.clone()<br>        创建当前request的副本。</p>
<pre><code>Request implements Body, so it also has the following methods available to it:
    Body.arrayBuffer()
    Returns a promise that resolves with an ArrayBuffer representation of the request body.
    Body.blob()
    Returns a promise that resolves with an Blob representation of the request body.
    Body.formData()
    Returns a promise that resolves with an FormData representation of the request body.
    Body.json()
    Returns a promise that resolves with an JSON representation of the request body.
    Body.text()
    Returns a promise that resolves with an USVString (text) representation of the request body.
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request" target="_blank" rel="noopener">MDN-Fetch-request</a><br>Response（构造器）<br>    相当于请求的响应。<br>    Response.type 只读<br>        包含Response的类型 (例如, basic, cors).<br>    Response.url 只读<br>        包含Response的URL.<br>    Response.useFinalURL<br>        包含了一个布尔值来标示这是否是该Response的最终URL.<br>    Response.status 只读<br>        包含Response的状态码 (例如, 200 成功).<br>    Response.ok 只读<br>        包含了一个布尔值来标示该Response成功(状态码200-299) 还是失败.<br>    Response.redirected 只读<br>        表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个<br>    Response.statusText 只读<br>        包含了与该Response状态码一致的状态信息 (例如, OK对应200).<br>    Response.headers 只读<br>        包含此Response所关联的Headers 对象.<br>    Response 实现了 Body, 所以以下属性同样可用:<br>    Body.bodyUsed 只读<br>     包含了一个布尔值来标示该Response是否读取过Body.<br>    Response.clone()<br>        创建一个Response对象的克隆<br>    Response.error()<br>        返回一个绑定了网络错误的新的Response对象<br>    Response.redirect()<br>        用另一个URL创建一个新的 response.<br>    Response 实现了 Body, 所以以下方法同样可用:<br>        Body.arrayBuffer()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为ArrayBuffer格式的promise对象<br>        Body.blob()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为Blob格式的promise对象<br>        Body.formData()<br>        读取Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为FormData格式的promise对象<br>        Body.json()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为JSON格式的promise对象<br>        Body.text()<br>        读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为USVString格式的promise对象<br>        参数：<br>            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myHeaders = new Headers();</span><br><span class="line">var myInit = &#123; method: &apos;GET&apos;,</span><br><span class="line">			   headers: myHeaders,</span><br><span class="line">			   mode: &apos;cors&apos;,</span><br><span class="line">			   cache: &apos;default&apos; &#125;;	</span><br><span class="line">fetch(&apos;flowers.jpg&apos;,myInit)</span><br></pre></td></tr></table></figure></p>
<pre><code>返回值：
    Promise 对象
    PS：就算是404也会返回promise resolved 还需要使用Response.ok 是不是为 true进一步判断。
</code></pre><p>2.同步和异步<br>3.同源策略<br>    作用：同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>    定义：同domain（或ip）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。<br>    同源主要的限制：<br>        （1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>        （2） DOM和js对象无法获得。<br>        （3） AJAX 请求不能发送。<br>4.跟后端的数据交互的方式：JSON/XML，JS如何解析JSON为对象<br>    // json字符串<br>    var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’;<br>    // json对象<br>    var str2 = { “name”: “cxh”, “sex”: “man” };</p>
<pre><code>// JSON字符串转换为JSON对象方法一
// var obj = eval(&apos;(&apos; + str1 + &apos;)&apos;);
// JSON字符串转换为JSON对象方法二
// var obj = JSON.parse(str1)

// JSON对象转换为JSON字符串方法一
JSON.stringify(str2)
</code></pre><h4 id="对HTTP协议的理解"><a href="#对HTTP协议的理解" class="headerlink" title="对HTTP协议的理解"></a>对HTTP协议的理解</h4><p>1.常见的状态码<br>    200 OK<br>    301 Moved Permanently<br>    302 Found<br>    304 Not Modified<br>    307 Temporary Redirect<br>    400 Bad Request<br>    401 Unauthorized<br>    403 Forbidden<br>    404 Not Found<br>    410 Gone<br>    500 Internal Server Error<br>    501 Not Implemented<br>    <a href="https://fanerge.github.io/2017/11/05/%E5%89%8D%E7%AB%AF%E5%90%8C%E5%AD%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/">前端同学需要了解的通信知识</a><br>2.常见的HTTP请求和响应<br>    <a href="https://www.cnblogs.com/honghong87/articles/6941436.html" target="_blank" rel="noopener">参考博客</a><br>3.1同源策略限制了一下行为：<br>    1.Cookie、LocalStorage 和 IndexDB 无法读取<br>    2.DOM 和 JS 对象无法获取<br>    3.Ajax请求发送不出去<br>3.2解决跨域的方法<br>    window.name + iframe<br>    location.hash + iframe<br>    jsonp（jsonp的原理和优缺点）<br>        1.原理：动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本,通过这个特性(也可以说漏洞),服务器端不在返回json格式,而是返回一段调用某个函数的js代码（该页面中存在该函数），在src中进行了调用，这样实现了跨域。<br>        前面3中方式均只支持get方式<br>    document.domain + iframe（跨子域）<br>    HTML5中postMessage方案<br>        window.postMessage(msg,targetOrigin)<br>        window.addEventListener(‘message’,function(e) {}<br>    跨域资源共享 CORS<br>    WebSocket协议跨域<br>        后端主要配置，Access-Control-Allow-Origin<br>    node代理跨域<br>    nginx代理跨域<br>    详细请自行参考MDN相关文档<br>    <a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">正确面对跨域，别慌</a><br>4.JSONP请求如何取消？<br>    删除script标签（存在兼容性问题）<br>    将callback函数置为空函数<br>5.GET/POST方法的区别和使用场景<br>    get只应该用于获取数据，post用于提交数据（存在副作用）。<br>6.JavaScript模板引擎<br>    Template.js<br>    pug<br>    Mustache<br>    <a href="https://segmentfault.com/a/1190000000502743" target="_blank" rel="noopener">参考segmentfault</a><br>7.JavaScript设计模式<br>    <a href="https://fanerge.github.io/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">javascript设计模式</a></p>
<h3 id="Mobile-Web"><a href="#Mobile-Web" class="headerlink" title="Mobile Web"></a>Mobile Web</h3><p>重要概念<br>    设备像素：设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。<br>    CSS像素：这是一个抽象的像素概念，它是为web开发者创造的（是可以改变的，取决于用于是否缩放）。<br>    设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)<br>    最重要的两个视口，布局视口和理想<br>        布局视口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。<br>        理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：理想的布局视口。<br>        下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：<br>            <meta name="viewport" content="width=device-width"><br>屏幕适配 – 主要是屏幕分辨率、尺寸、屏幕方向这些因素。<br>    CSS3的媒体查询（media query）<br>    <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0&quot; /&gt;</code><br>        width=device-width - 布局视口等于理想视口<br>        device-width - 设备的宽度<br>        initial-scale - 初始的缩放比例<br>        minimum-scale - 允许用户缩放到的最小比例<br>        maximum-scale - 允许用户缩放到的最大比例<br>        user-scalable - 用户是否可以手动缩放<br>    <code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot; &gt;</code><br>    //禁止自动识别电话号码和邮箱<br>    <code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; &gt;</code><br>    //苹果手机：会删除默认的工具栏和菜单栏，网站开启对web app程序的支持<br>    <code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</code><br>    //苹果手机：在web app应用下状态条（屏幕顶部条）的颜色,默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。<br>    <code>&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;</code><br>    //苹果手机：如果把一个web app添加到了主屏幕中，那么从主屏幕中打开这个web app则全屏显示<br>    <code>&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/static/images/identity/HTML5_Badge_64.png&quot; /&gt;</code><br>    //苹果手机：将应用添加到手机主屏幕，会有一个icon可以直接进入<br>重置部分css<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">	 font: 16px/1.5 Helvetica, Arial;</span><br><span class="line">	//这里是设置字体，Helvetica字体在移动端各系统都支持（都不支持微软雅黑）</span><br><span class="line">	-webkit-text-size-adjust: none; </span><br><span class="line">	//设置文本不会放大，普通网页在移动端打开文本是会跟随网页结构缩放的</span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">	-webkit-tap-highlight-color: transparent;</span><br><span class="line">	//在一些手机上，如iphone，点击按钮等元素会出现点击态的背景色，设置为透明就看不出来了</span><br><span class="line">	-webkit-user-select:none;</span><br><span class="line">	//设置元素内的文字及其子元素将不会被选中</span><br><span class="line">&#125;</span><br><span class="line">// 去除webkit的滚动条</span><br><span class="line">	::-webkit-scrollbar&#123;</span><br><span class="line">	   display: none;</span><br><span class="line">	&#125;</span><br><span class="line">	div &#123;</span><br><span class="line">		-webkit-overflow-scrolling : touch;</span><br><span class="line">	&#125;</span><br><span class="line">// 去除button在ios上的默认样式</span><br><span class="line">	button &#123;</span><br><span class="line">		-webkit-appearance: none;</span><br><span class="line">		border-radius: 0;</span><br><span class="line">	&#125;</span><br><span class="line">// placeholder元素样式的修改</span><br><span class="line">	input::-webkit-input-placeholder&#123;color:red;&#125;</span><br><span class="line">	input:focus::-webkit-input-placeholder&#123;color:green;&#125;</span><br><span class="line">// 使用css3的transition、transform（translate、scale、rotate、skew）、或者animation来进行动画或过度。</span><br><span class="line">// 使用图片时，会发现图片下总是有大概4px的空白</span><br><span class="line">	img&#123;display:block&#125;；</span><br><span class="line">	img&#123;vertical-align:top&#125;</span><br></pre></td></tr></table></figure></p>
<p>事件<br>    touchstart：当手指放在屏幕上触发;<br>    touchmove：当手指在屏幕上滑动时，连续地触发;<br>    touchend：当手指从屏幕上离开时触发;<br>    touchcancel： 当系统停止跟踪时触发;<br>        event.touches.length // 当前几个手指在触屏上</p>
<h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>1.对AMD、CMD（node.js）、UMD等规范的了解，以及ES6中关于模块的标准定义<br>2.使用过常用的模块化框架：Requirejs、Seajs等<br>3.使用模块化的方式，能够解决什么问题？<br>    命名空间冲突（全局变量覆盖）<br>    文件依赖管理<br>    立即执行函数 + 闭包(实现模块的基本方法)<br>4.动态加载JavaScript有几种方式？<br>    1.使用document.write/writeln(）方式<br>        document.writeln(“<script src="\"http://lib.sinaapp.com/js/jquery/1.6/jquery.min.js\""></script>“);<br>    2.使用jquery getScript(url,callback)方法实现动态加载js文件<br>        $.getScript(‘test.js’,function(){<br>            // TODO…<br>        });<br>    3.动态改变已有script的src属性<br>    4.使用原生js 动态创建script标签，并指定script的src属性<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loadJs(url,callback)&#123;</span><br><span class="line">	var script=document.createElement(&apos;script&apos;);</span><br><span class="line"></span><br><span class="line">	script.type=&quot;text/javascript&quot;;</span><br><span class="line">	if(typeof(callback)!=&quot;undefined&quot;)&#123;</span><br><span class="line">		if(script.readyState)&#123;</span><br><span class="line">			script.onreadystatechange=function()&#123;</span><br><span class="line"></span><br><span class="line">				if(script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</span><br><span class="line">					script.onreadystatechange=null;</span><br><span class="line">					callback();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			script.onload=function()&#123;</span><br><span class="line">				callback();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	script.src=url;</span><br><span class="line">	document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadJs(&quot;test.js&quot;,function()&#123;</span><br><span class="line">	// todo...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<pre><code>5.用XHR取得要脚本的内容，再创建 Script 对象。
6.如何判断动态脚本是否加载完成
    为scriptdom节点添加监听事件 onload 和 onreadystatechange
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scriptDom.onload = scriptDom.onreadystatechange = function()&#123;  </span><br><span class="line">	// 这里处理了兼容性，不同浏览器 readyState 的值不一样</span><br><span class="line">   if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;)&#123;  </span><br><span class="line">   // todo...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>5.动态加载CSS方法<br>    1.导入css文件<br>        @import url(style.css);<br>    2.简单的在页面中加载一个外部CSS文件<br>        document.createStyleSheet(cssFile);<br>    3.用createElement方法创建CSS的Link标签<br>7.分析依赖的方式<br>    动态分析，也是运行时分析<br>    本地编译分析出依赖链<br>8.如何做好模块加载的性能优化    </p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><pre><code>参见阮一峰教程
</code></pre><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>Angularjs<br>React （重点）<br>Babkbone<br>Vuejs （重点）    </p>
<h4 id="前端安全（XSS、CSRF等，攻击和防范方案）"><a href="#前端安全（XSS、CSRF等，攻击和防范方案）" class="headerlink" title="前端安全（XSS、CSRF等，攻击和防范方案）"></a>前端安全（XSS、CSRF等，攻击和防范方案）</h4><p>在项目中有遇到过前端方面的安全问题吗？<br>什么是XSS、CSRF？<br>常见的漏洞场景有哪些？<br>如何防范XSS、CSRF<br>网站登陆都加验证码是为了解决哪方面的安全问题？有没有更好的方案？    </p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>1.请减少HTTP请求（代理模式合并http请求）<br>    合并图片（css sprites），合并CSS和JS文件；图片较多的页面也可以使用 lazyLoad 等技术进行优化。<br>2.请正确理解 Repaint重绘 和 Reflow重排<br>3.减少DOM操作（缓存dom节点）<br>    对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。<br>4.尽量使用json数据与后端交互而不是xml<br>5.高效使用HTML标签和CSS样式    （语义化利于seo）<br>6.使用CDN加速（内容分发网络）<br>7.将CSS和JS放到外部文件中引用，CSS放头，JS放尾<br>8.精简CSS和JS文件（压缩）<br>9.压缩图片和使用图片Sprite技术<br>10.注意控制Cookie大小和污染（使用storage代替）<br>    cookie会在每次http请求自动添加，有点浪费<br>11.按需加载资源<br>12.缓存（主要是http头部字段和service workers）    </p>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>1.有哪几种浏览器内核<br>    Trident – ie4-ie8<br>    Gecko   – 网景-firefox<br>    Presto  – Opera（Opera现已改用Google Chrome的Blink内核）<br>    Webkit  – Chrome、Safari<br>2.排版引擎<br>    KHTML<br>    WebCore<br>3.浏览器兼容性<br>    css前缀<br>    js自带方法的适配<br>    对各种资源的支持webP图片格式<br>4.浏览器渲染页面的原理（不同浏览器不一样）<br>    DOM Tree：浏览器将HTML解析成树形的数据结构。<br>    CSS Rule Tree：浏览器将CSS解析成树形的数据结构。<br>    Render Tree: DOM和CSSOM合并后生成Render Tree。<br>    layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br>    painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。<br>    reflow（重排）和repaint（重绘）<br>    <a href="https://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noopener">参考</a><br>5.浏览器检测和识别<br>    根据浏览器特性来判断<br>    根据UA来检测 – navigator.userAgent 字符串比较</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>1.框架的设计方案</p>
<p>2.解决哪些问题    </p>
<h4 id="前端架构设计"><a href="#前端架构设计" class="headerlink" title="前端架构设计"></a>前端架构设计</h4><p>前端架构是一系列工具和流程的集合，旨在提升前端代码质量，并实现高效、可持续的工作流。<br>1.前端架构四个核心：<br>    ● 代码——如何实现系统架构中的HTML、CSS和JavaScript<br>    ● 流程——构建高效并且防止出错的工作流所需要的工具和流程<br>    ● 测试——为网站搭建稳固基础<br>    ● 文档——规划好系统设计蓝图<br>2.前端架构师职责：<br>    ● 体系设计——清晰描绘产品和代码的最终形态<br>    ● 工作规划——制定完整开发工作流<br>    ● 监督跟进——保证项目高效率完成    </p>
<h4 id="跨终端开发"><a href="#跨终端开发" class="headerlink" title="跨终端开发"></a>跨终端开发</h4><p>1.响应性设计（Mobile web），Media Queries<br>    栅格系统（bootstrap）具体实现float + width百分比 + @media query<br>    松软盒子flex 具体实现flex布局 + width百分比 + @media query<br>2.Hybird APP（PhoneGap、AppCan、Titanium等）大致的原理，以及解决的问题<br>    Web App、Hybrid App、 Native App<br>    原理：通过JSBridge,web页面可以调用Native的api,Native也可调用web页面的api或者通知H5页面回调。<br>3.React Native 和 weex<br>4.重构<br>    主要考虑（性能优化和扩展性）<br>    <a href="https://www.cnblogs.com/depsi/p/5063965.html" target="_blank" rel="noopener">性能优化</a><br>5.前端工程化<br>    借助Node.js的功能（读写文件、搭建服务器、读写数据库等等）帮我们完成如图片、代码压缩、代码检测等事情。<br>    模块化与组件化: npm, es6, react/angularjs<br>    代码版本管理: git<br>    代码风格管理: jscs, editorconfig<br>    代码编译: babel, scss, imgmin, csssprit, inline-svg<br>    代码质量管理 (QA): eslint, mocha<br>    代码构建: webpack<br>    项目脚手架: yeoman<br>    持续集成/持续交付/持续部署: jenkins<br>    本地化与国际化<br>6.系统架构/设计</p>
<h1 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h1><ol>
<li>描述一个你遇到过的技术问题，你是如何解决的？        </li>
<li><p>是否有设计过通用的组件？<br>请设计一个 Dialog（弹出层）等组件<br>你会提供什么接口？<br>调用过程是怎样的？可能会遇到什么细节问题？<br>API<br>  visible – 对话框是否可见<br>  title – 标题<br>  closable – 是否显示右上角的关闭按钮<br>  mask – 是否展示遮罩<br>  maskClosable – 点击蒙层是否允许关闭<br>  maskStyle – 遮罩样式<br>  bodyStyle – Dialog body 样式<br>  footer – 底部内容，当不需要默认底部按钮时，可以设为 footer={null}<br>  cancelText – 取消按钮文字<br>  okText – 确认按钮文字<br>  onCancel – 点击遮罩层或右上角叉或取消按钮的回调<br>  onOk – 点击确定回调<br>  zIndex    设置 Modal 的 z-index（特殊情况使用）</p>
</li>
<li><p>请描述一下你做过的哪个前端方面的功能让你特别有成就感    </p>
</li>
<li>在制作一个Web应用或Web站点的过程中，你是如何考虑它的UI、安全性、高性能、SEO、可维护性以及技术因素的？        </li>
<li>说说最近最流行的一些东西吧？常去哪些网站？        </li>
</ol>
<h1 id="潜力（加分项）"><a href="#潜力（加分项）" class="headerlink" title="潜力（加分项）"></a>潜力（加分项）</h1><ol>
<li>熟悉一门非前端语言，并且有项目开发经验，包括且不限于C/C++/Python/PHP/Java/Ruby等</li>
<li>在Native开发上有相关的经验（iOS、Android）等</li>
<li>有自己的独立博客并且有自己的思考和总结性质的文章、github有自己维护的仓库并且活跃（即开源项目）</li>
<li>对技术的追求有热情，特别对新技术的敏感性，能够积极主动学习新技术，并且能够有实践性的应用，比如：HTML5、Nodejs、MVVM、Promise、React、React Native、Angular等等</li>
<li>有较好的产品意识，并且有积极推动业务进步并拿到结果的案例</li>
<li>主动性、逻辑性、沟通、协同等方面的软实力良好</li>
<li>项目管理PM角色的经历（团队合作、沟通、协调能力）    </li>
</ol>
<h1 id="你对break和continue的理解"><a href="#你对break和continue的理解" class="headerlink" title="你对break和continue的理解"></a>你对break和continue的理解</h1><p>break 关键字<br>    break 主要用在循环语句或者 switch 语句中。<br>    break 在循环语句中作用是跳出本层（并非本次）的循环。<br>    break 在switch语句中作用是跳出该switch语句体。<br>continue 关键字<br>    continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。<br>    在 for 循环中，continue 语句使程序立即跳转到更新语句i++。<br>    在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。    </p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-插入排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="插入排序算法定义（Insertion-Sort）"><a href="#插入排序算法定义（Insertion-Sort）" class="headerlink" title="插入排序算法定义（Insertion Sort）"></a>插入排序算法定义（Insertion Sort）</h1><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，<br>这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序<br>数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。<br>是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，<br>但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。<br>在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<p>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，<br>直到全部插入完为止。</p>
<h1 id="插入排序的分类"><a href="#插入排序的分类" class="headerlink" title="插入排序的分类"></a>插入排序的分类</h1><p>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。<br>属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个<br>已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。<br>例如,已知待排序的一组记录是：60,71,49,11,24,3,66<br>假设在排序过程中，前3个记录已按关键码值递增的次序重新排列，构成一个有序序列：49,60,71<br>将待排序记录中的第4个记录（即11）插入上述有序序列，以得到一个新的含4个记录的有序序列。<br>首先，应找到11的插入位置，再进行插入。可以讲11放入数组的第一个单元r[0]中，这个单元称为监视哨，<br>然后从71起从右到左查找，11小于71，将71右移一个位置，11小于60，又将60右移一个位置，11小于49，<br>又再将49右移一个位置，这时再将11与r[0]的值比较，11≥r[0]，它的插入位置就是r[1]。<br>假设11大于第一个值r[1]。它的插入位置应该在r[1]和r[2]之间，由于60已经右移了，留出来的位置正好留给11.<br>后面的记录依照同样的方法逐个插入到该有序序列中。若记录数n,续进行n-1趟排序，才能完成。<br>直接插入排序的算法思路：<br>（1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；<br>（2） 设置开始查找的位置j；<br>（3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；<br>（4） 将r[0]插入r[j+1]的位置上。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insertSort(array)&#123;  </span><br><span class="line">	let i,</span><br><span class="line">		j, </span><br><span class="line">		temp,</span><br><span class="line">		arr = array.slice(),  // 这里对原数组拷贝</span><br><span class="line">		n = arr.length; </span><br><span class="line">		</span><br><span class="line">	for(i = 1;i &lt; n;i++)&#123;   </span><br><span class="line">		j = i-1; </span><br><span class="line">		temp = arr[i]; // 第i项为待插入的项  </span><br><span class="line">		</span><br><span class="line">		while(j &lt; i &amp;&amp; arr[j] &gt; temp)&#123;   </span><br><span class="line">			arr[j+1] = arr[j];   </span><br><span class="line">			j--;  </span><br><span class="line">		&#125;   </span><br><span class="line">		</span><br><span class="line">		arr[j+1] = temp;   </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return arr;   </span><br><span class="line">&#125;   </span><br><span class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </span><br><span class="line">let demo = insertSort(arrayA);</span><br><span class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</span><br><span class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" alt="直接插入排序"><br>最佳情况：输入数组按升序排列。T(n) = O(n)<br>最坏情况：输入数组按降序排列。T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p>
<h2 id="折半插入排序（二分插入排序）"><a href="#折半插入排序（二分插入排序）" class="headerlink" title="折半插入排序（二分插入排序）"></a>折半插入排序（二分插入排序）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。<br>在处理A[i]时，A[0]……A[i-1]已经按关键码值排好序。所谓折半比较，就是在插入A[i]时，<br>取A[i-1/2]的关键码值与A[i]的关键码值进行比较，如果A[i]的关键码值小于A[i-1/2]的关键码值，<br>则说明A[i]只能插入A[0]到A[i-1/2]之间，故可以在A[0]到A[i-1/2-1]之间继续使用折半比较；<br>否则只能插入A[i-1/2]到A[i-1]之间，故可以在A[i-1/2+1]到A[i-1]之间继续使用折半比较。<br>如此担负，直到最后能够确定插入的位置为止。一般在A[k]和A[r]之间采用折半，其中间结点为A[k+r/2]，<br>经过一次比较即可排除一半记录，把可能插入的区间减小了一半，故称为折半。<br>执行折半插入排序的前提是文件记录必须按顺序存储。</p>
<h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><p>（1）计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，<br>    说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置 到中间值的位置，这样很简单的完成了折半；<br>（2）在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，<br>    范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；<br>（3）确定位置之后，将整个序列后移，并将元素插入到相应位置。</p>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function binaryInsertSort(array)&#123;</span><br><span class="line">	let arr = array.slice();</span><br><span class="line">	for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">		let key = arr[i], </span><br><span class="line">			left = 0, </span><br><span class="line">			right = i - 1;</span><br><span class="line"></span><br><span class="line">		while (left &lt;= right) &#123;</span><br><span class="line">			let middle = parseInt((left + right) / 2);</span><br><span class="line"></span><br><span class="line">			if (key &lt; arr[middle]) &#123;</span><br><span class="line">				right = middle - 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				left = middle + 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (var j = i - 1; j &gt;= left; j--) &#123;</span><br><span class="line">		  arr[j + 1] = arr[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[left] = key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </span><br><span class="line">let demo = binaryInsertSort(arrayA);</span><br><span class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</span><br><span class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="二分插入排序"><br>最佳情况：T(n) = O(nlogn)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p>
<blockquote>
<p>   参考文档：<br><a href="https://www.cnblogs.com/90zeng/p/insert_sort.html" target="_blank" rel="noopener">数据结构复习：直接插入排序与二分插入排序的C++实现</a><br><a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="noopener">插入排序</a><br><a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-计数排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="计数排序的基础"><a href="#计数排序的基础" class="headerlink" title="计数排序的基础"></a>计数排序的基础</h1><p>定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）<br>计数排序对输入的数据有附加的限制条件：<br>    1、输入的线性表的元素属于有限偏序集S；<br>    2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。    </p>
<h1 id="计数排序算法思想"><a href="#计数排序算法思想" class="headerlink" title="计数排序算法思想"></a>计数排序算法思想</h1><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p>
<h1 id="现实计数算法"><a href="#现实计数算法" class="headerlink" title="现实计数算法"></a>现实计数算法</h1><h2 id="具体算法实现步骤"><a href="#具体算法实现步骤" class="headerlink" title="具体算法实现步骤"></a>具体算法实现步骤</h2><p><1>. 找出待排序的数组中最大和最小的元素；</1></p>
<p><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></p>
<p><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></p>
<p><4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function countingSort(arr)&#123;</span><br><span class="line">	let len = arr.length,</span><br><span class="line">		Result = [], // 保存排序后的数组</span><br><span class="line">		Count = [], // 保存各项出现次数的数组</span><br><span class="line">		min = max = arr[0];</span><br><span class="line">	console.time(&apos;计数排序计时&apos;);</span><br><span class="line"></span><br><span class="line">	// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数</span><br><span class="line">	for(var i = 0; i &lt; len; i++)&#123;</span><br><span class="line">		Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数</span><br><span class="line">		min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值</span><br><span class="line">		max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从最小值-&gt;最大值,将计数逐项相加</span><br><span class="line">	for(var j = min; j &lt; max; j++)&#123;</span><br><span class="line">		Count[j+1] = (Count[j+1]||0)+(Count[j]||0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</span><br><span class="line">	for(var k = len - 1; k &gt;= 0;k--)&#123;</span><br><span class="line">		/*Result[位置] = arr数据*/</span><br><span class="line">		Result[Count[arr[k]] - 1] = arr[k];</span><br><span class="line">		/*减少Count数组中保存的计数*/</span><br><span class="line">		Count[arr[k]]--;</span><br><span class="line">		/*显示Result数组每一步详情*/</span><br><span class="line">		console.log(Result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	console.timeEnd(&apos;计数排序计时&apos;);</span><br><span class="line">	return Result;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(countingSort(arr));</span><br></pre></td></tr></table></figure></4></p>
<pre><code>PS：时间复杂度：T(n) = O(n)
空间复杂度：S(n) = O(k)
是否稳定：是
排序方式：外排序
</code></pre><p>运行结果为:<br>[ , , , , , , , , , , , , , 48 ]<br>[ , , , , , , , , , , , , , 48, 50 ]<br>[ , , , , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , , , 48, 50 ]<br>[ , , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]<br>[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]<br>[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]<br>[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]<br>计数排序计时: 16ms<br>[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]</p>
<h1 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" alt="动态图 | center"></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://hao.jser.com/archive/13600/" target="_blank" rel="noopener">基本算法学习(四)之计数排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin" target="_blank" rel="noopener">计数排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-选择排序</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h1 id="选择排序算法定义（Selection-Sort）"><a href="#选择排序算法定义（Selection-Sort）" class="headerlink" title="选择排序算法定义（Selection Sort）"></a>选择排序算法定义（Selection Sort）</h1><p>选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。选择排序的基本思想是：<br>每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；<br>第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；<br>以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，<br>使有序序列不断增长直到全部排序完毕。</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><p>每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</p>
<h2 id="简单选择排序的基本思想"><a href="#简单选择排序的基本思想" class="headerlink" title="简单选择排序的基本思想"></a>简单选择排序的基本思想</h2><p>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；<br>第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，<br>第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，<br>使有序序列不断增长直到全部排序完毕。</p>
<h2 id="简单选择排序的存储状态"><a href="#简单选择排序的存储状态" class="headerlink" title="简单选择排序的存储状态"></a>简单选择排序的存储状态</h2><p>初始序列：{49 27 65 97 76 12 38}<br>第1趟：12与49交换：12{27 65 97 76 49 38}<br>第2趟：27不动　：12 27{65 97 76 49 38}<br>第3趟：65与38交换：12 27 38{97 76 49 65}<br>第4趟：97与49交换：12 27 38 49{76 97 65}<br>第5趟：76与65交换：12 27 38 49 65{97 76}<br>第6趟：97与76交换：12 27 38 49 65 76 97 完成</p>
<p>PS：其中大括号内为无序区，大括号外为有序序列</p>
<h1 id="简单选择排序的算法分析"><a href="#简单选择排序的算法分析" class="headerlink" title="简单选择排序的算法分析"></a>简单选择排序的算法分析</h1><p>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，<br>则不需要移动记录。最坏情况下，需要移动记录的次数最多为3（n-1）（此情况中待排序记录并非完全逆序，<br>给完全逆序记录排序的移动次数应为(n/2)*3，其中n/2向下取整）。<br>简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。<br>当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，<br>共需要进行的比较次数是∑ =(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n2)。</p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function selectionSort(array) &#123;</span><br><span class="line">	let arr = array.slice(), // 深拷贝一份原数组</span><br><span class="line">		len = arr.length,</span><br><span class="line">		minIndex,</span><br><span class="line">		temp;</span><br><span class="line">	for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">		minIndex = i;</span><br><span class="line">		for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">			if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class="line">				minIndex = j;                 //将最小数的索引保存</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = arr[i];</span><br><span class="line">		arr[i] = arr[minIndex];</span><br><span class="line">		arr[minIndex] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [5, 4, 3, 2, 1];</span><br><span class="line">var demo = selectionSort(arr);</span><br><span class="line">console.log(arr); // [5, 4, 3, 2, 1]</span><br><span class="line">console.log(demo); // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>PS：建议使用不可变对象的思想进行编程。</p>
<h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" alt="选择排序动图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">图片来源</a>，在此表示感谢！</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="noopener">选择排序（Selection Sort）</a><br>    <a href="https://baike.baidu.com/item/选择排序法/2304587" target="_blank" rel="noopener">选择排序法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-总结性文章</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E6%80%A7%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="排序算法的基本概念"><a href="#排序算法的基本概念" class="headerlink" title="排序算法的基本概念"></a>排序算法的基本概念</h1><h2 id="什么叫排序？"><a href="#什么叫排序？" class="headerlink" title="什么叫排序？"></a>什么叫排序？</h2><p>排序(Sorting) 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。</p>
<h2 id="排序算法的性质"><a href="#排序算法的性质" class="headerlink" title="排序算法的性质"></a>排序算法的性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。<br>反之，不稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中S在R之前。</p>
<h3 id="时间复杂度（最差、平均、和最好性能）T-n"><a href="#时间复杂度（最差、平均、和最好性能）T-n" class="headerlink" title="时间复杂度（最差、平均、和最好性能）T(n)"></a>时间复杂度（最差、平均、和最好性能）T(n)</h3><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。<br>    T(n) = O(f(n))<br>一般而言，好的性能是 O(nlogn)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">查看时间复杂度计算方式</a></p>
<h3 id="空间复杂度S-n"><a href="#空间复杂度S-n" class="headerlink" title="空间复杂度S(n)"></a>空间复杂度S(n)</h3><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。</p>
<h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>内排序：所有排序操作都在内存中完成。<br>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。<br><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">更多详情</a></p>
<h1 id="先来张总结性图片"><a href="#先来张总结性图片" class="headerlink" title="先来张总结性图片"></a>先来张总结性图片</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt></p>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（尾部），故名。</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个（因为每次最后遍历的最后一个数都是最大的，所以不需要再次比较了）。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>选择排序法是对定位比较交换法（也就是冒泡排序法）的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。</p>
<h2 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换，<br>2.第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换，<br>3.以此类推…<br>4.第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，<br>5.使有序序列不断增长直到全部排序完毕。<br>PS：冒泡排序是逐次把当前序列中最大值<span style="color: red;">推</span>到后面去。<br>    选择排序是逐次把当前序列中最小值<span style="color: red;">放</span>到前面去。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。<br>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。</p>
<h2 id="直接插入排序实现步骤"><a href="#直接插入排序实现步骤" class="headerlink" title="直接插入排序实现步骤"></a>直接插入排序实现步骤</h2><p>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：<br>①初始状态：无序区为R[1..n]，有序区为空。<br>②第1趟排序<br>在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br>……<br>③第i趟排序<br>第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。</p>
<h2 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.二分法查找插入位置<br>    如果R&lt;R[m]成立，那右指针就要向左移动中间指针一位，否则，左指针要向右移动中间指针一位。反复查找，直到左指针大于右指针时停止。<br>2.后移，有点迷惑，什么时候需要后移呢？有哪些记录需要移动呢？<br>    虽然我们很清楚的知道，我们需要后移那些排序码大于R的记录，但难免会问自己这样几个问题。其实它相当于需要移动从i-1到左指针的记录。<br>3.插入<br>    由1中得到的左指针其实就是元素要插入的位置。<br><a href="https://fanerge.github.io/2017/11/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p>
<h2 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>对数组arr，长度为n进行排序<br>1.第一个增量为Math.floor(n/2)，再最每个小的分租进行直接插入排序；<br>2.第二个增量为Math.floor(n/4)，再最每个小的分租进行直接插入排序；<br>3.以此类推…，直到增量为1，这是排序完成。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h2 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾,这时完成排序。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h2 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>一趟快速排序的算法是：排序序列A，N为排序序列长度<br>1.找基准（一般是以当前数组的第一项的值）<br>2.遍历数组，小于基准的放在left，大于基准的放在right<br>3.递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h2 id="实现步骤-6"><a href="#实现步骤-6" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h2><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</p>
<h2 id="实现步骤-7"><a href="#实现步骤-7" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出待排序的数组中最大和最小的元素；<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>4.反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="桶排序-Bucket-SORT）"><a href="#桶排序-Bucket-SORT）" class="headerlink" title="桶排序 (Bucket SORT）"></a>桶排序 (Bucket SORT）</h1><h2 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h2><p>输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。</p>
<h2 id="实现步骤-8"><a href="#实现步骤-8" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。<br>2.计算出每个桶中的数据范围为 L = (max - min)/N。<br>3.再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…<br>4.将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。<br>5.将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h2><p>基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<h2 id="实现步骤-9"><a href="#实现步骤-9" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。<br>以下<span style="color: red;">红色</span>字体代表桶编号<br>得到：<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 81<br><span style="color: red;">2</span> 22<br><span style="color: red;">3</span> 73 93 43<br><span style="color: red;">4</span> 14<br><span style="color: red;">5</span> 55 65<br><span style="color: red;">6</span><br><span style="color: red;">7</span><br><span style="color: red;">8</span> 28<br><span style="color: red;">9</span> 39<br>再将这些桶子中的数值重新串接起来，成为以下的数列。<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p>
</li>
<li><p>接着再进行一次分配，这次是根据十位数来分配<br><span style="color: red;">0</span><br><span style="color: red;">1</span> 14<br><span style="color: red;">2</span> 22 28<br><span style="color: red;">3</span> 39<br><span style="color: red;">4</span> 43<br><span style="color: red;">5</span> 55<br><span style="color: red;">6</span> 65<br><span style="color: red;">7</span> 73<br><span style="color: red;">8</span> 81<br><span style="color: red;">9</span> 93<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br><a href="https://fanerge.github.io/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html">或许你还是不太了解，这里有该算法的详细实现过程</a></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些算法我还记得在大学时学过的，只不过当然并没有太在意，这也许就是–欠下的债，终究是要还的。</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法基本概念</title>
    <url>/2017/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content><![CDATA[<h1 id="对于评述算法优劣术语的说明"><a href="#对于评述算法优劣术语的说明" class="headerlink" title="对于评述算法优劣术语的说明"></a>对于评述算法优劣术语的说明</h1><ol>
<li>稳定：如果a原本在b的前面，若a=b，排序之后a仍然在b前面。</li>
<li>不稳定：如果a原本在b的前面，若a=b，排序之后a可能会在b的后面。</li>
<li>内排序：所有排序操作都在内存中完成。</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
<li>时间复杂度：一个算法执行所消耗的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ol>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="时间复杂度的定义-T-n-O-f-n"><a href="#时间复杂度的定义-T-n-O-f-n" class="headerlink" title="时间复杂度的定义 T(n)=O(f(n))"></a>时间复杂度的定义 T(n)=O(f(n))</h2><pre><code>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，
若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，
则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的
渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。
</code></pre><h2 id="时间复杂度的计算步骤"><a href="#时间复杂度的计算步骤" class="headerlink" title="时间复杂度的计算步骤"></a>时间复杂度的计算步骤</h2><ol>
<li>计算出基本操作的执行次数T(n)<br>  基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。<br>  在做算法分析时，一般默认为考虑最坏的情况。</li>
<li>计算出T(n)的数量级<br>  求T(n)的数量级，只要将T(n)进行如下一些操作，忽略常量、低次幂和最高次幂的系数。<br>  令f(n)=T(n)的数量级。</li>
<li>用大O来表示时间复杂度<br>  当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。<br>  记作T(n)=O(f(n))。</li>
</ol>
<h2 id="计算一下时间复杂度"><a href="#计算一下时间复杂度" class="headerlink" title="计算一下时间复杂度"></a>计算一下时间复杂度</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i=1;i&lt;=n;i++)   //循环了，当然是O(n^2)</span><br><span class="line">       for(j=1;j&lt;=n;j++)</span><br><span class="line">           s++;</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：这里的执行次数为 <span style="color: red;">n*n</span> 次 ，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">       for(j=1;j&lt;=i;j++)</span><br><span class="line">           s++;</span><br></pre></td></tr></table></figure>
</code></pre><p>PS：这里的执行次数为 <span style="color: red;">(1+2+3+…+n)≈(n^2)/2</span>次，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><h2 id="空间复杂度定义-S-n-O-f-n"><a href="#空间复杂度定义-S-n-O-f-n" class="headerlink" title="空间复杂度定义 S(n)=O(f(n))"></a>空间复杂度定义 S(n)=O(f(n))</h2><pre><code>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。
比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。
而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。
</code></pre><h1 id="各种算法的总结"><a href="#各种算法的总结" class="headerlink" title="各种算法的总结"></a>各种算法的总结</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p>
<pre><code>总结：接着我会使用 js 来做各种排序算法的分析。 
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="noopener">js十大排序算法</a><br>    <a href="http://univasity.iteye.com/blog/1164707" target="_blank" rel="noopener">算法时间复杂度的计算 [整理]</a><br>    <a href="http://blog.csdn.net/firefly_2002/article/details/8008987" target="_blank" rel="noopener">如何计算时间复杂度</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP学习-了解</title>
    <url>/2017/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>最近，由于最近项目需要集成到老项目中去，采用原始的前后端不分离开发，需要学习jsp语言。<br><em>如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。</em></p>
<h3 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h3><pre><code>1.    JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。
</code></pre><h3 id="JSP-生命周期"><a href="#JSP-生命周期" class="headerlink" title="JSP 生命周期"></a>JSP 生命周期</h3><pre><code>1.    编译阶段：
当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。
编译的过程包括三个步骤：
    解析JSP文件。
    将JSP文件转为servlet。
    编译servlet。
2.    初始化阶段：
    容器载入JSP文件后，它会在为请求提供任何服务前调用jspInit()方法。如果您需要执行自定义的JSP初始化任务，复写jspInit()方法就行了，就像下面这样：
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void jspInit()&#123;</span><br><span class="line">  // 初始化代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。
执行阶段：
    这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。
    当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。
    _jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样：
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _jspService(HttpServletRequest request,</span><br><span class="line">				 HttpServletResponse response)</span><br><span class="line">&#123;</span><br><span class="line">   // 服务端处理代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    _jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。
销毁阶段：
    SP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。
    jspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jspDestroy()方法的格式如下：</span><br><span class="line">public void jspDestroy()</span><br><span class="line">&#123;</span><br><span class="line">   // 清理代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h3><pre><code>语法格式：
    &lt;% 代码片段 %&gt;
    &lt;jsp:scriptlet&gt;
       代码片段
    &lt;/jsp:scriptlet&gt;
中文编码问题：
    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
JSP声明
    &lt;%! declaration; [ declaration; ]+ ... %&gt;
    &lt;jsp:declaration&gt;
       代码片段
    &lt;/jsp:declaration&gt;
    例子：
    &lt;%! int i = 0; %&gt; 
JSP表达式    
    &lt;%= 表达式 %&gt;
    &lt;jsp:expression&gt;
       表达式
    &lt;/jsp:expression&gt;
JSP注释
    &lt;%-- 注释 --%&gt;
JSP指令
    JSP指令用来设置与整个JSP页面相关的属性。
    &lt;%@ directive attribute=&quot;value&quot; %&gt;
    例子：
    &lt;%@ page ... %&gt;    定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等
    &lt;%@ include ... %&gt;    包含其他文件
    &lt;%@ taglib ... %&gt;    引入标签库的定义，可以是自定义标签
JSP行为
    JSP行为标签使用XML语法结构来控制servlet引擎。
    &lt;jsp:action_name attribute=&quot;value&quot; /&gt;
JSP隐含对象
    JSP支持九个自动定义的变量，江湖人称隐含对象。
    request    HttpServletRequest类的实例
    response    HttpServletResponse类的实例
判断语句
    if-else
        &lt;%! int day =  %&gt;
        &lt;% if (day == 1 | day == 7) { %&gt;
            &lt;p&gt;今天是周末&lt;/p&gt;
        &lt;% } else { %&gt;
              &lt;p&gt;今天不是周末&lt;/p&gt;
        &lt;% } %&gt;
    switch-case
        &lt;% 
        switch(day) {
        case 0:
           out.println(&quot;星期天&quot;);
           break;
        case 1:
           out.println(&quot;星期一&quot;);
           break;
        default:
           out.println(&quot;星期六&quot;);
        }
        %&gt;
循环语句
    for
        &lt;%for ( fontSize = 1; fontSize &lt;= 3; fontSize++){ %&gt;
           &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt;
            菜鸟教程
           &lt;/font&gt;&lt;br /&gt;
        &lt;%}%&gt;
    while
        &lt;%while ( fontSize &lt;= 3){ %&gt;
           &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt;
            菜鸟教程
           &lt;/font&gt;&lt;br /&gt;
        &lt;%fontSize++;%&gt;
        &lt;%}%&gt;
JSP 字面量
    布尔值(boolean)：true 和 false;
    整型(int)：与 Java 中的一样;
    浮点型(float)：与 Java 中的一样;
    字符串(string)：以单引号或双引号开始和结束;
    Null：null。
</code></pre><h3 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h3><pre><code>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。
    &lt;%@ directive attribute=&quot;value&quot; %&gt;
Page指令
    Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。
    &lt;%@ page attribute=&quot;value&quot; %&gt;
    &lt;jsp:directive.page attribute=&quot;value&quot; /&gt;
Include指令
    JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。
    &lt;%@ include file=&quot;文件相对 url 地址&quot; %&gt;
    &lt;jsp:directive.include file=&quot;文件相对 url 地址&quot; /&gt;
Taglib指令
    JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。
    &lt;%@ taglib uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; %&gt;
    &lt;jsp:directive.taglib uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; /&gt;
</code></pre><h3 id="JSP动作元素"><a href="#JSP动作元素" class="headerlink" title="JSP动作元素"></a>JSP动作元素</h3><pre><code>JSP动作元素在请求处理阶段起作用。JSP动作元素是用XML语法写成的。
    &lt;jsp:action_name attribute=&quot;value&quot; /&gt;
</code></pre><h3 id="JSP隐式对象"><a href="#JSP隐式对象" class="headerlink" title="JSP隐式对象"></a>JSP隐式对象</h3><pre><code>JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。    
</code></pre><h3 id="JSP客户端请求"><a href="#JSP客户端请求" class="headerlink" title="JSP客户端请求"></a>JSP客户端请求</h3><pre><code>当浏览器请求一个网页时，它会向网络服务器发送一系列不能被直接读取的信息，因为这些信息是作为HTTP信息头的一部分来传送的。您可以查阅HTTP协议来获得更多的信息。
</code></pre><h3 id="JSP服务器响应"><a href="#JSP服务器响应" class="headerlink" title="JSP服务器响应"></a>JSP服务器响应</h3><pre><code>Response响应对象主要将JSP容器处理后的结果传回到客户端。可以通过response变量设置HTTP的状态和向客户端发送数据，如Cookie、HTTP文件头信息等。
</code></pre><h3 id="JSP-HTTP状态码"><a href="#JSP-HTTP状态码" class="headerlink" title="JSP HTTP状态码"></a>JSP HTTP状态码</h3><pre><code>以状态行+CRLF（回车换行）开始
零行或多行头模块+CRLF
一个空行，比如CRLF
可选的消息体比如文件，查询数据，查询输出
</code></pre><h3 id="JSP-表单处理"><a href="#JSP-表单处理" class="headerlink" title="JSP 表单处理"></a>JSP 表单处理</h3><pre><code>JSP 读取表单数据
    getParameter(): 使用 request.getParameter() 方法来获取表单参数的值。
    getParameterValues(): 获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 ，如checkbox类型
    getParameterNames():该方法可以取得所有变量的名称，该方法返回一个Emumeration。
    getInputStream():调用此方法来读取来自客户端的二进制数据流。
</code></pre><h3 id="JSP过滤器"><a href="#JSP过滤器" class="headerlink" title="JSP过滤器"></a>JSP过滤器</h3><pre><code>JSP 和 Servlet 中的过滤器都是 Java 类。
过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。
可以将一个或多个过滤器附加到一个 Servlet 或一组 Servlet。过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。
过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：
在客户端的请求访问后端资源之前，拦截这些请求。
在服务器的响应发送回客户端之前，处理这些响应。
</code></pre><h3 id="JSP-Cookie-处理"><a href="#JSP-Cookie-处理" class="headerlink" title="JSP Cookie 处理"></a>JSP Cookie 处理</h3><pre><code>Cookie是存储在客户机的文本文件，它们保存了大量轨迹信息。在servlet技术基础上，JSP显然能够提供对HTTP cookie的支持。
</code></pre><h3 id="JSP-Session"><a href="#JSP-Session" class="headerlink" title="JSP Session"></a>JSP Session</h3><pre><code>有三种方法来维持客户端与服务器的会话
    Cookies
    隐藏表单域  &lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&gt;
    重写URL   http://w3cschool.cc/file.htm;sessionid=12345
session对象
    JSP利用servlet提供的HttpSession接口来识别一个用户，存储这个用户的所有访问信息。
    默认情况下，JSP允许会话跟踪，一个新的HttpSession对象将会自动地为新的客户端实例化。
</code></pre><h3 id="JSP-文件上传"><a href="#JSP-文件上传" class="headerlink" title="JSP 文件上传"></a>JSP 文件上传</h3><h3 id="JSP-日期处理"><a href="#JSP-日期处理" class="headerlink" title="JSP 日期处理"></a>JSP 日期处理</h3><pre><code>使用JSP最重要的优势之一，就是可以使用所有Java  API。本章将会详细地讲述Java中的Date类，它在java.util包下，封装了当前日期和时间。
</code></pre><h3 id="JSP-页面重定向"><a href="#JSP-页面重定向" class="headerlink" title="JSP 页面重定向"></a>JSP 页面重定向</h3><pre><code>当需要将文档移动到一个新的位置时，就需要使用JSP重定向了。
</code></pre><h3 id="JSP-点击量统计"><a href="#JSP-点击量统计" class="headerlink" title="JSP 点击量统计"></a>JSP 点击量统计</h3><h3 id="JSP-自动刷新"><a href="#JSP-自动刷新" class="headerlink" title="JSP 自动刷新"></a>JSP 自动刷新</h3><pre><code>想象一下，如果要直播比赛的比分，或股票市场的实时状态，或当前的外汇配给，该怎么实现呢？显然，要实现这种实时功能，您就不得不规律性地刷新页面。
</code></pre><h3 id="JSP-发送邮件"><a href="#JSP-发送邮件" class="headerlink" title="JSP 发送邮件"></a>JSP 发送邮件</h3>]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Node.js-读书笔记</title>
    <url>/2017/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89.html</url>
    <content><![CDATA[<p>最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。</p>
<h2 id="Node-js-基础知识"><a href="#Node-js-基础知识" class="headerlink" title="Node.js 基础知识"></a>Node.js 基础知识</h2><h3 id="chrome-与-Node-工作原理"><a href="#chrome-与-Node-工作原理" class="headerlink" title="chrome 与 Node 工作原理"></a>chrome 与 Node 工作原理</h3><pre><code>chrome：HTML + JavaScript + WebKit + V8 &gt;&gt; 中间层 &gt;&gt; 网卡 + 硬盘 + 显卡 + ...
Node：JavaScript + V8 &gt;&gt; 中间层（libuv）&gt;&gt; 网卡 + 硬盘 + 显卡 + ...
说明：libuv 是 Node 的新跨平台抽象层，用于抽象 Windows 的 IOCP 及 Unix 的 libev。
    作者打算在这个库的包含所有平台的差异性。
</code></pre><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.get(&apos;url&apos;, (data) =&gt; &#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

异步是并行的基础。
单线程，不适合大量计算占用 CPU 导致无法继续调用异步I/O。
</code></pre><h2 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h2><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><pre><code>模块引用：
    var math = require(&apos;math&apos;);    
模块定义：
    exports.add = () =&gt; {
        var a = 1,
            b = 3;
        return a + b;
    }
exports 是 module 的属性。
Node 引入模块的步骤：
    路径分析
    文件定位
    编译执行
</code></pre><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><pre><code>文件模块 &gt;&gt; 核心模块（JavaScript） &gt;&gt; 内建模块（C/C++）
</code></pre><h2 id="异步I-O-1"><a href="#异步I-O-1" class="headerlink" title="异步I/O"></a>异步I/O</h2><h3 id="Node-的异步I-O"><a href="#Node-的异步I-O" class="headerlink" title="Node 的异步I/O"></a>Node 的异步I/O</h3><pre><code>Node 自身的执行模型 -- 事件循环。
单线程、事件循环、观察者和I/O线程池
</code></pre><h3 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h3><pre><code>定时器：setTimeout()\setInterval()
process.nextTick()
    在事件循环的下一次循环中调用 callback 回调函数。
    效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；
    与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。
setImmediate()
    nextTick()的回调函数执行的优先级要高于setImmediate();    
    process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者,
    I/O观察者先于check观察者.
</code></pre><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>高阶函数：以函数作为参数或返回值。
偏函数用法：通过指定部分参数来产生一个新的定制函数的形式就是偏函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isType = function (type)&#123;</span><br><span class="line">	return function (obj) &#123;</span><br><span class="line">		return Object.prototype.toString.call(obj) == &apos;[object &apos; + type + &apos;]&apos;;</span><br><span class="line">	&#125;; </span><br><span class="line">&#125;</span><br><span class="line">var isString = isType(&apos;String&apos;);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h3><pre><code>事件发布/订阅模式（事件绑定）
promise
generator
async-await
</code></pre><h3 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h3><pre><code>eventproxy
[async](https://github.com/caolan/async)
</code></pre><h2 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h2><h2 id="理解Buffer"><a href="#理解Buffer" class="headerlink" title="理解Buffer"></a>理解Buffer</h2><pre><code>Buffer 是一个像Array的对象，但它主要用于操作字节。
Buffer 对象
    var buf = new Buffer(&apos;string&apos;, &apos;utf-8&apos;);
</code></pre><h3 id="Buffer-的转换"><a href="#Buffer-的转换" class="headerlink" title="Buffer 的转换"></a>Buffer 的转换</h3><pre><code>    支持的字符串编码类型：
    ASCII\UTF-8\UTF-16LE/UCS-2\Base64\Binary\Hex
字符串转 Buffer    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var buf = new Buffer(str, [encoding]);</span><br><span class="line">buf.write(string, [offset], [length], [encoding]);</span><br></pre></td></tr></table></figure>

Buffer 转字符串
buf.toString([encoding], [start], [end]);
</code></pre><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>TCP 和 UDP 属于网络传输层协议，HTTP 属于应用层协议。
</code></pre><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><pre><code>创建TCP 服务器端 net 模块
TCP 服务的事件
</code></pre><h3 id="构建UDP-服务（用户数据包协议）"><a href="#构建UDP-服务（用户数据包协议）" class="headerlink" title="构建UDP 服务（用户数据包协议）"></a>构建UDP 服务（用户数据包协议）</h3><pre><code>创建UDP套接字 dgram模块
创建UDP 服务器端
创建UDP 客户端
UDP 套接字事件
</code></pre><h3 id="构建HTTP-服务"><a href="#构建HTTP-服务" class="headerlink" title="构建HTTP 服务"></a>构建HTTP 服务</h3><pre><code>HTTP 超文本传输协议。
http 模块
HTTP 客户端
</code></pre><h3 id="构建WebSocket-服务"><a href="#构建WebSocket-服务" class="headerlink" title="构建WebSocket 服务"></a>构建WebSocket 服务</h3><pre><code>以前的方案：Comet（彗星）技术细节为：长轮询（long-polling）或iframe流（streaming）。
长轮询原理：客户端向服务器断发送请求，服务端只在超时或有数据响应时断开连接（res.end()），
    客户端在接收到数据或者超时后重新发送请求。
iframe流原理：iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，
    然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。
    通过iframe里的内容进行长时间的请求，当需要传输内容时通过调用父页面js方法来实现页面展示，以此达到comet所需要的效果。
WebSocket原理：WebSocket是一种在单个TCP连接上进行全双工通讯的协议。
    WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，
    浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
</code></pre><h3 id="网络服务与安全"><a href="#网络服务与安全" class="headerlink" title="网络服务与安全"></a>网络服务与安全</h3><pre><code>Node在网络安全上提供了3个模块
</code></pre><ol>
<li>crypto – 主要用于加密和解密，SHA1、MD5。</li>
<li>tls – 类似于net模块，它是建立在TLS/SSL加密的TCP连接上。</li>
<li>https – 类似于http模块，他它是建立于安全的连接之上。<br>TLS/SSL<br>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构。<br>每个服务器断和客户端都有自己的公私钥。<br>公钥要来加密要传输的数据，私钥用来解密接收到的数据。<br>Node在底层采用的是openssl实现TLS/SSL。<br>数字证书：CA（Certificate Authority，数字证书认证中心）<br>HTTPS服务<br>HTTPS服务就是工作在TLS/SSL上的HTTP。<blockquote>
<p>参考文档<br><a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="noopener">朴灵-深入浅出Node</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端总结</title>
    <url>/2017/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;</code><br>    width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。<br>    height：和 width 相对应，指定高度。<br>    initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。<br>    maximum-scale：允许用户缩放到的最大比例。<br>    minimum-scale：允许用户缩放到的最小比例。<br>    user-scalable：用户是否可以手动缩放。</p>
<h3 id="IOS中safari允许全屏浏览"><a href="#IOS中safari允许全屏浏览" class="headerlink" title="IOS中safari允许全屏浏览"></a>IOS中safari允许全屏浏览</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;</span><br><span class="line">```	</span><br><span class="line">###	IOS中Safari顶端状态条样式</span><br><span class="line">`&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;`</span><br><span class="line">PS：如果要去除全部的，就把default ：状态栏背景是白色。</span><br><span class="line">black ：状态栏背景是黑色。</span><br><span class="line">black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。</span><br><span class="line">如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。</span><br><span class="line">###	忽略将数字变为电话号码</span><br><span class="line">`&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;`</span><br><span class="line">###	忽略识别email</span><br><span class="line">`&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; &gt;`</span><br><span class="line">###	添加到主屏后的标题（IOS）</span><br><span class="line">`&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;`</span><br><span class="line">###	百度禁止转码</span><br><span class="line">`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;`</span><br><span class="line">###	优先使用最新版本 IE 和 Chrome</span><br><span class="line">`&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;`</span><br><span class="line">###	设置缓存</span><br><span class="line">`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;`</span><br><span class="line">##	小技巧</span><br><span class="line">###	select 下拉选择设置右对齐</span><br></pre></td></tr></table></figure>
<p>select option {<br>    direction: rtl;<br>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	消除 IE10 里面的那个叉号</span><br><span class="line">`input:-ms-clear&#123;display:none;&#125;`</span><br><span class="line">###	关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)</span><br></pre></td></tr></table></figure></p>
<p>-webkit-text-size-adjust: 100%;<br>-ms-text-size-adjust: 100%;<br>text-size-adjust: 100%;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</span><br><span class="line">可以通过正则去掉</span><br><span class="line">`this.value = this.value.replace(/\u2006/g, &apos;&apos;);`</span><br><span class="line">###	移动端 HTML5 input date 不支持 placeholder 问题</span><br><span class="line">`&lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot;  id=&quot;date&quot;&gt;`</span><br><span class="line">###	部分机型存在type为search的input，自带close按钮样式修改方法</span><br></pre></td></tr></table></figure></p>
<p>#Search::-webkit-search-cancel-button{<br>    display: none;<br>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	开启电话功能和短信和发邮件</span><br></pre></td></tr></table></figure></p>
<p><a href="tel:123456" target="_blank" rel="noopener">123456</a><br><a href="sms:123456" target="_blank" rel="noopener">123456</a><br>&lt;a mailto:<a href="mailto:dooyoe@gmail.com" target="_blank" rel="noopener">dooyoe@gmail.com</a>“&gt;<a href="mailto:dooyoe@gmail.com" target="_blank" rel="noopener">dooyoe@gmail.com</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	IOS Web app启动动画</span><br><span class="line">&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</span><br><span class="line">&lt;link href=&quot;apple-touch-startup-image-640x960.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</span><br><span class="line">&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</span><br><span class="line">&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</span><br><span class="line">&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</span><br><span class="line">&lt;link href=&quot;apple-touch-startup-image-2048x1496.png&quot; media=&quot;(device-width: 1536px)  and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;</span><br><span class="line">（landscape：横屏 | portrait：竖屏）</span><br><span class="line">###	添加到主屏后的APP图标</span><br></pre></td></tr></table></figure></p>
<!-- 设计原图 --> 
<p><link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed"><br><!-- 添加高光效果 --> </p>
<p><link href="short_cut_114x114.png" rel="apple-touch-icon"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	去除webkit的滚动条</span><br></pre></td></tr></table></figure></p>
<p>element::-webkit-scrollbar{<br>    display: none;<br>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS：如果要去除全部的，就把 element去掉。</span><br><span class="line">	添加这个属性滚动如丝般顺滑： -webkit-overflow-scrolling : touch;</span><br><span class="line">###	去除button在ios上的默认样式</span><br><span class="line">```	</span><br><span class="line">-webkit-appearance: none;</span><br><span class="line">border-radius: 0;</span><br></pre></td></tr></table></figure></p>
<h3 id="长时间按住页面出现闪退"><a href="#长时间按住页面出现闪退" class="headerlink" title="长时间按住页面出现闪退"></a>长时间按住页面出现闪退</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element &#123;</span><br><span class="line">	-webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Retina屏的1px边框"><a href="#Retina屏的1px边框" class="headerlink" title="Retina屏的1px边框"></a>Retina屏的1px边框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element&#123;</span><br><span class="line">	border-width: thin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="transition闪屏"><a href="#transition闪屏" class="headerlink" title="transition闪屏"></a>transition闪屏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/设置内嵌的元素在 3D 空间如何呈现：保留3D /</span><br><span class="line">-webkit-transform-style: preserve-3d;</span><br><span class="line">/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /</span><br><span class="line">-webkit-backface-visibility:hidden;</span><br></pre></td></tr></table></figure>
<h3 id="旋转屏幕时，字体大小调整的问题"><a href="#旋转屏幕时，字体大小调整的问题" class="headerlink" title="旋转屏幕时，字体大小调整的问题"></a>旋转屏幕时，字体大小调整的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123;</span><br><span class="line">	-webkit-text-size-adjust:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="placeholder元素样式的修改"><a href="#placeholder元素样式的修改" class="headerlink" title="placeholder元素样式的修改"></a>placeholder元素样式的修改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input::-webkit-input-placeholder&#123;color:red;&#125;</span><br><span class="line">input:focus::-webkit-input-placeholder&#123;color:green;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不想让按钮-touch时有蓝色的边框或半透明灰色遮罩"><a href="#不想让按钮-touch时有蓝色的边框或半透明灰色遮罩" class="headerlink" title="不想让按钮 touch时有蓝色的边框或半透明灰色遮罩"></a>不想让按钮 touch时有蓝色的边框或半透明灰色遮罩</h3><p>对于a,button,input,textarea<br><code>-webkit-tap-highlight-color:rgba(0,0,0,0);</code></p>
<h3 id="移动端做动画效果采用css3"><a href="#移动端做动画效果采用css3" class="headerlink" title="移动端做动画效果采用css3"></a>移动端做动画效果采用css3</h3><p>transition、transform（scale、translate、rotate、skew）或者 animation<br>动画尽量少用margin、top等集合属性，因为这样会触发浏览器重排（reflow）</p>
<h3 id="使用图片时去除图片下4px的空白"><a href="#使用图片时去除图片下4px的空白" class="headerlink" title="使用图片时去除图片下4px的空白"></a>使用图片时去除图片下4px的空白</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img&#123;display:block&#125;；</span><br><span class="line">img&#123;vertical-align:top&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何禁止保存或拷贝图像（IOS）"><a href="#如何禁止保存或拷贝图像（IOS）" class="headerlink" title="如何禁止保存或拷贝图像（IOS）"></a>如何禁止保存或拷贝图像（IOS）</h3><p><code>img { -webkit-touch-callout: none; }</code></p>
<h3 id="手机拍照和上传图片"><a href="#手机拍照和上传图片" class="headerlink" title="手机拍照和上传图片"></a>手机拍照和上传图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 选择照片 --&gt; </span><br><span class="line">&lt;input type=file accept=&quot;image/*&quot;&gt; </span><br><span class="line">&lt;!-- 选择视频 --&gt; </span><br><span class="line">&lt;input type=file accept=&quot;video/*&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="弹性盒子的过渡"><a href="#弹性盒子的过渡" class="headerlink" title="弹性盒子的过渡"></a>弹性盒子的过渡</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display:-webkit-box; // 早期的版本</span><br><span class="line">display:-webkit-box-flex; // 过渡版本</span><br><span class="line">display:-webkit-flex; // 最新的版本</span><br></pre></td></tr></table></figure>
<h3 id="禁止用户选中文字"><a href="#禁止用户选中文字" class="headerlink" title="禁止用户选中文字"></a>禁止用户选中文字</h3><p><code>-webkit-user-select:none;</code></p>
<h3 id="定义新的盒模型"><a href="#定义新的盒模型" class="headerlink" title="定义新的盒模型"></a>定义新的盒模型</h3><p><code>box-sizing:border-box</code></p>
<h3 id="css权重（逐次降低）"><a href="#css权重（逐次降低）" class="headerlink" title="css权重（逐次降低）"></a>css权重（逐次降低）</h3><pre><code>style--1000
!important
id--100
class--10
标签--1
</code></pre><h3 id="使用rem"><a href="#使用rem" class="headerlink" title="使用rem"></a>使用rem</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">	font-size: 625%; // 相当于 12px *6.25 = 100px</span><br><span class="line">&#125;</span><br><span class="line">以后的元素的width、height、padding等集合属性都可以用rem来表示。</span><br><span class="line">```		</span><br><span class="line">###	移动端字体</span><br><span class="line">`font-family: Helvetica,sans-serif;`</span><br><span class="line">###	iphone原生键盘统计字数时</span><br><span class="line">在 iphone原生键盘上用 keyup统计字符数时，系统不会自动监控你选择文字的事件，应该使用input事件。</span><br><span class="line">###	毛玻璃效果</span><br><span class="line">实现毛玻璃效果，透过背景看其他元素模糊，自身元素不模糊。</span><br></pre></td></tr></table></figure>
<p>-webkit-backdrop-filter: saturate(180%) blur(20px);<br>background: rgba(0,0,0,0.5);<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	需要展示小于12px的文字</span><br><span class="line">`transform:scale(%);`</span><br><span class="line">###	禁止IOS弹出各种操作窗口及关闭自动大写与自动修正</span><br></pre></td></tr></table></figure></p>
<p>-webkit-touch-callout:none</p>
<p><input type="text" autocapitalize="off" autocorrect="off"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###	Andriod 上去掉语音输入按钮</span><br><span class="line">`input::-webkit-input-speech-button &#123;display: none&#125;`</span><br><span class="line">#	js部分</span><br><span class="line">##	移动端事件</span><br><span class="line">click事件有300ms的延迟</span><br><span class="line">###	触摸事件touch类事件</span><br><span class="line">touchstart：手指触摸到屏幕会触发</span><br><span class="line">touchmove：当手指在屏幕上移动时，会触发</span><br><span class="line">touchend：当手指离开屏幕时，会触发</span><br><span class="line">touchcancel：可由系统进行的触发，比如手指触摸屏幕的时候，突然alert了一下，或者系统中其他打断了touch的行为，则可以触发该事件</span><br><span class="line">###	敲击事件tap类事件</span><br><span class="line">tap: 手指碰一下屏幕会触发</span><br><span class="line">longTap: 手指长按屏幕会触发</span><br><span class="line">singleTap: 手指碰一下屏幕会触发</span><br><span class="line">doubleTap: 手指双击屏幕会触发</span><br><span class="line">###	swipe类事件</span><br><span class="line">swipe：手指在屏幕上滑动时会触发</span><br><span class="line">swipeLeft：手指在屏幕上向左滑动时会触发</span><br><span class="line">swipeRight：手指在屏幕上向右滑动时会触发</span><br><span class="line">swipeUp：手指在屏幕上向上滑动时会触发</span><br><span class="line">swipeDown：手指在屏幕上向下滑动时会触发</span><br><span class="line">###	旋转屏幕事件</span><br><span class="line">`onorientationchange`	</span><br><span class="line">###	audio、video默认播放事件</span><br><span class="line">window.onload或计时器等都不能触发播放，必须用 JS写事件让用户手动点击触发才会开始播放</span><br></pre></td></tr></table></figure></p>
<p>$(document).one(‘touchstart’,function(){<br>    audio.play();<br>})<br><code>`</code></p>
<h3 id="移动事件三方库"><a href="#移动事件三方库" class="headerlink" title="移动事件三方库"></a>移动事件三方库</h3><p><a href="http://hammerjs.github.io" target="_blank" rel="noopener">Hammer.JS</a><br><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">FastClick</a></p>
<p>参考文档：<br>    <a href="https://www.cnblogs.com/imwtr/p/5882166.html" target="_blank" rel="noopener">移动端前端常见的触摸相关事件touch、tap、swipe等整理</a><br>    <a href="http://mp.weixin.qq.com/s/KpRaX4gPnqvadIZijSmYSQ" target="_blank" rel="noopener">web前端 —— 移动端知识的一些总结</a><br>    <a href="http://web.jobbole.com/85132/" target="_blank" rel="noopener">移动端事件介绍</a><br>    <a href="http://www.imooc.com/article/1115" target="_blank" rel="noopener">移动端web开发技巧</a><br>    <a href="https://masonry.desandro.com/" target="_blank" rel="noopener">瀑布流框架</a><br>    <a href="http://www.jb51.net/article/84973.htm" target="_blank" rel="noopener">倾力总结40条常见的移动端Web页面问题解决方案</a></p>
]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配</title>
    <url>/2017/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html</url>
    <content><![CDATA[<h1 id="简单webApp的处理方案"><a href="#简单webApp的处理方案" class="headerlink" title="简单webApp的处理方案"></a>简单webApp的处理方案</h1><p>这种app是一种典型的弹性布局：关键元素高宽和位置都不变，只有容器元素在做伸缩变换。对于这类app，记住一个开发原则就好：文字流式，控件弹性，图片等比缩放。</p>
<h1 id="网易的做法（以设计稿为640的计算，还有750等等）"><a href="#网易的做法（以设计稿为640的计算，还有750等等）" class="headerlink" title="网易的做法（以设计稿为640的计算，还有750等等）"></a>网易的做法（以设计稿为640的计算，还有750等等）</h1><p>（1）先拿设计稿竖着的横向分辨率除以100得到body元素的宽度<br>    如果设计稿基于iphone4/5，横向分辨率为640，body的width为640 / 100 = 6.4rem<br>（2）布局时，设计图标注的尺寸除以100得到css中的尺寸<br>    播放器高度为210px，写样式的时候css应该这么写：height: 2.1rem。之所以取一个100作为参照，就是为了这里计算rem的方便！<br>（3）在dom ready以后，通过以下代码设置html的font-size。<br>    document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + ‘px’;<br>    这里的目的是保证，1rem等于100px，方便后面计算<br>（4）font-size可能需要额外的媒介查询，并且font-size不能使用rem<br>    @media screen and (max-width:321px){<br>        .m-navlist{font-size:15px}<br>    }<br>    @media screen and (min-width:321px) and (max-width:400px){<br>        .m-navlist{font-size:16px}<br>    }<br>PS：第一，需要设置视口<br>        <meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"><br>    第二，当deviceWidth大于设计稿的横向分辨率时，html的font-size始终等于横向分辨率/body元素宽<br>        var deviceWidth = document.documentElement.clientWidth;<br>        if(deviceWidth &gt; 640) deviceWidth = 640;<br>        document.documentElement.style.fontSize = deviceWidth / 6.4 + ‘px’;<br>    第三，当物理分辨率大于1280时，应该去访问PC网站了。</p>
<h1 id="淘宝的做法"><a href="#淘宝的做法" class="headerlink" title="淘宝的做法"></a>淘宝的做法</h1><p>（1）动态设置viewport的scale<br>    var scale = 1 / devicePixelRatio;<br>    document.querySelector(‘meta[name=”viewport”]’).setAttribute(‘content’,’initial-scale=’ + scale + ‘, maximum-scale=’ + scale + ‘, minimum-scale=’ + scale + ‘, user-scalable=no’);<br>（2）动态计算html的font-size<br>    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + ‘px’;<br>（3）布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10<br>（4）font-size可能需要额外的媒介查询，并且font-size不使用rem，这一点跟网易是一样的。<br>PS：第一，当设备竖着时横向物理分辨率大于1080时，应该去访问PC网站了。</p>
<h1 id="淘宝开源的布局库"><a href="#淘宝开源的布局库" class="headerlink" title="淘宝开源的布局库"></a>淘宝开源的布局库</h1><p><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">lib-flexible</a><br><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="noopener">详细介绍</a></p>
<p><a href="http://www.cnblogs.com/lyzg/p/4877277.html" target="_blank" rel="noopener">整理于互联网</a></p>
]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端, 布局</tag>
      </tags>
  </entry>
  <entry>
    <title>JS常用设计模式总结</title>
    <url>/2017/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>设计模式，是一套经过前人总结、业务验证并适合于特定业务开发的代码组织方式，可能会有一些同学会认为设计模式没有用，我这里需要指出设计模式并不是万能的只适合于特定业务场景的开发（对我们的业务开发起到一定的指导作用，所有设计模式的目的都是让开发者编写可维护、易扩展的代码），其实你日常开发中或多或少都使用过设计模式，只是你不知道名字而已（如，绑定事件和触发事件这就是一个简单的发布-订阅模式）。<br>本文所有设计模式都是使用 JavaScript 语言书写，这些案例都是较为基础的，目的是帮助前端同学更好的理解设计模式。<br>为了你更好的理解设计模式，你需要了解设计模式的六大原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则，可以看这篇<a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">设计模式六大原则</a>。<br>本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的<a href="https://github.com/fanerge/fanerge.github.io" target="_blank" rel="noopener">个人技术博客项目</a>给个star哦。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>
<h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>设计模式一般需要满足下列原则【2019-01-09更新】<br>SOLID 是几个单词首字母组合而来，分别表示 单一功能原则、开闭原则、里氏替换原则、接口隔离原则以及依赖反转原则。<br>单一功能原则：如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。<br>开闭原则：“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。<br>里氏替换原则：名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。<br>接口隔离原则：JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。<br>依赖反转原则：高层次模块不能依赖低层次模块，它们依赖于抽象接口，抽象接口不能依赖具体实现，具体实现依赖抽象接口。总结下来就两个字，解耦。</p>
<h1 id="工厂模式（Factory）"><a href="#工厂模式（Factory）" class="headerlink" title="工厂模式（Factory）"></a>工厂模式（Factory）</h1><p>定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。<br>举例：计算器（加、减、乘、除）、自行车售卖（山地、公路）、饮料机（咖啡、牛奶、水）、RPG中职业（战士、法师、射手）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br>举例：：模态框、登录控件、注销控件<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>定义：策略模式包括两个部分，算法的使用部分（不变的）和算法的实现部分（可变的）。<br>举例：表单效验（是否为空、长度、手机号、邮箱等等）、计算年终奖（工资、效绩）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；<br>举例： 图片预加载、图片懒加载、合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、缓存代理（缓存请求结果、计算结果）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br>举例：手机购买页面（颜色、数量、内存、价格）、MVC模式（控制层便是位于表现层与模型层之间的中介者）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="装饰者模式（Decorator）"><a href="#装饰者模式（Decorator）" class="headerlink" title="装饰者模式（Decorator）"></a>装饰者模式（Decorator）</h1><p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。<br>举例：雷霆战机（吃道具的例子）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="发布订阅模式（Observer）"><a href="#发布订阅模式（Observer）" class="headerlink" title="发布订阅模式（Observer）"></a>发布订阅模式（Observer）</h1><p>定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。<br>举例：模块通信、事件绑定与触发、售楼中心<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。<br>举例：常用于接口适配、兼容多个库（如Prototype库的$函数和YUI的get方法）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>举例：jquery的$.each()、<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>举例：用桥接模式联结多个类、事件监控<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>举例：兼容浏览器事件绑定、兼容浏览器阻止冒泡、默认事件<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br>举例：<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><p>定义：模版方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。<br>举例：泡饮品（茶 和 coffee）、公司面试（百度面试 和 阿里面试）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象（子对象）和组合对象的使用具有一致性。<br>举例：文件扫描（目录为组合对象和文件为子对象）、dom节点操作<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。<br>举例：分页控件、撤销组件<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。<br>举例：挤公交车递钱（只有售票员可以收钱）、交押金预定手机<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成（环境类、状态类）。<br>举例：文件下载（开始、暂停、完成、失败等）、红绿灯<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
<h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了（具体做法缓存对象从而达到重复利用）。<br>举例：内衣厂展示许多商品展示、地图应用（对象池）<br><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">需要详细了解该模式，请访问该链接</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Node.js-读书笔记</title>
    <url>/2017/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><pre><code>常见的需求：
</code></pre><ol>
<li>请求方法的判断（保存在报文）<br>常见的方法有：GET(查看)\POST(更新)\DELETE(删除)\PUT(新建)\CONNECT\HEAD<br>通过req.method 来判断</li>
<li>URL的路径解析（保存在报文）<br><a href="http://localhost:8080/a.html" target="_blank" rel="noopener">http://localhost:8080/a.html</a><br>通过req.url 来查找</li>
<li>URL中查询字符串解析（保存在报文）<br>?foo=bar&amp;baz=val<br>使用Node提供的querystring 模块处理</li>
<li>Cookie的解析（保存在报文）<br>网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>http 为无状态协议。<br>数据保存在客户端。</li>
<li>Session（会话）的需求（保存在报文）<br>数据保存在服务器端。<br>1.基于Cookie 来实现用户和数据的映射。<br>  原理：在客户端只保存口令，发送请求是通过该口令再去查找对应的数据<br>2.通过查询字符串来实现浏览器端和服务器端数据的对应。<br>  不推荐使用，风险大。<br>两种存储方式：<br>1.内存<br>2.数据工具<br>  Redis是一个支持网络、基于内存、可选持久性的键值对存储数据库。</li>
<li>Basic认证（保存在报文）<br>当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</li>
<li>数据上传<br>思路：先判断数据的格式，再通过对应的解析方法解析。<br>1.表单数据的解析<br>先判断req.headers[‘content-type’] === ‘application/x-www-formurlencoded’<br>  querystring.parse(req.rawBody);<br>2.其他格式<br>  json – application/json<br>  xml – application/xml</li>
<li><p>任意格式文件的上传处理<br>此时需要<form action="/upload" method="post" enctype="multipart/form-data"></form></p>
</li>
<li><p>缓存<br>YSlow中提出的缓存规则：<br>1.添加Expires 和 Cache-Control 到报文头中。<br>2.配置ETags。<br>3.让Ajax 可缓存。<br>数据上传与安全<br>1.内存限制（提交数据占用了所有内存）<br>  限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。<br>  通过流式解析，将数据导向到磁盘中，Node只保留文件路径等小数据。<br>2.CSRF<br>  Cross-Site Request Forgery（跨站点请求伪造）</p>
</li>
</ol>
<h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><pre><code>文件路径型
    静态文件：URL 的路径与网站目录的路径一致，无须转换。
    动态文件：在 MVC 模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，
        它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。
MVC
    MVC 模型的主要思想是将业务逻辑按职责分离。
        控制器（Controller），一组行为的集合。
        模型（Model），数据相关的操作和封装。
        视图（View），视图的渲染。
        1.路由解析，根据URL寻找到对应的控制器和行为。
        2.行为调用相关的模型，进行数据操作。
        3.数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。
    路由映射
    1.手工映射
        正则匹配
        参数解析
    2.自然映射
RESTful        
    REST Representational State Transfer （表现层状态转化）        
    POST /user/fanerge 修改用户信息
    DELETE /user/fanerge 删除用户
    PUT /user/fanerge 新建用户        
    GET /user/fanerge 查询用户信息    
    请求方法    
</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre><code>作用：middleware 来简化和隔离这些基础设施与业务逻辑之间的细节，使开发者更加关注在业务的开发。    
</code></pre><p><img src="/images/middleware.png" alt="中间件工作原理"><br>    中间件设计格式（connect的设计）<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var querystring = function (req, res, next) &#123;</span><br><span class="line">	// TODO</span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>使用中间件（串联多个中间件）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(&apos;/user/:username&apos;, querystring, cookie, session, function (req, res) &#123;</span><br><span class="line">	// 这里处理具体的业务逻辑</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


异常处理
    同步异常 -- try {} catch (err) {throw err} 
    异步异常
        需要把异常传递出来
        domain 模块    
</code></pre><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><pre><code>内容响应
    Content-Encoding: gzip
    Content-Length: 21170
    Content-Type: text/javascript; charset=utf-8
    MIME : Multipurpose Internet Mail Extensions    
    附件下载：有些MIME类的资源不需要在客户端中打开它，只需要弹出并下载它即可。
        Content-Disposition: inline(查看)/attachment(附件下载);
        例如：Content-Disposition: attachment; filename=&apos;filename.ext&apos;; // 下载附件并为其命名
    响应JSON
    响应跳转    
视图渲染
模板
    如EJS、Pug等
    模板引擎
        语法分解。
        处理表达式。
        生成待执行的语句。
        与数据一起执行，生成最终字符串。
    with的应用    
        模板安全 XSS 解决方案 转义用户的输入
    模板逻辑
    集成文件系统    
    子模板    
    布局视图    
    模板性能
Bigpipe
    BigPipe是一个重新设计的基础动态网页服务体系。
    前端加载技术，它的提出主要是为了解决重数据页面的加载问题。
    Bigpipe 的解决思路则是将页面分割成多个部分（pagelet），
    先向用户输出没有数据（框架），将每个部分逐步输出到前端，
    再最终渲染填充框架，完成整个网页的渲染。
    这个过程中需要前端js的参与，它负责将后续输出的数据渲染到页面上。
    1.页面布局框架（无数据的）。
    2.后端持续性的数据输出。
    3.前端渲染。
        bigpipe.ready() -- 以一个key注册一个事件。
        bigpipe.set() -- 触发一个事件，进行页面渲染。
</code></pre><h2 id="玩转进程"><a href="#玩转进程" class="headerlink" title="玩转进程"></a>玩转进程</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><pre><code>child_process 模块
创建子进程
    1.spawn(): 启动一个子进程来执行命令。
    2.exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，
    它有一个回调函数获知子进程的状况。
    3.execFile(): 启动一个子进程来执行可执行文件。
    4.fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的Javascript文件模块即可。
    spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，
    一旦创建的进程运行超过设定的时间将会被杀死。
    exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。
进程间通信
    message事件 绑定发送事件
    send()方法 触发发送消息
句柄传递
    child_process.send(message, [sendHandle]);
    句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。
    比如句柄可以用来标识一个服务器端socket对象、客户端socket对象、UDP套接字、一个管道等。
</code></pre><h3 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h3><pre><code>进程事件
    message
    error
    exit
    close
    disconnect
自动重启
    自杀信号
    负载均衡（轮叫调度）    
        由主进程接受链接，将其依次分发给工作进程。
        cluster 模块
    状态共享
        第三方数据存储 通过轮询
        主动通知 当数据更新时，主动通知子进程。
</code></pre><h3 id="Cluster-模块"><a href="#Cluster-模块" class="headerlink" title="Cluster 模块"></a>Cluster 模块</h3><pre><code>解决多核CPU的利用率问题。
Cluster 工作原理
    该模块是 child_process 和 net 模块的组合应用。
Cluster 事件
    fork
    online
    listening
    disconnect
    exit
    setup
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>测试驱动开发
</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code>测试代码编写的原则
1.单一职责
2.接口抽象
3.层次分离
单元测试介绍
1.断言
    assert 模块
    单元测试中用来保证最小单元是否正常的检测方法。
    用于检查程序在运行时是否满足期望。
    ok(): 判断结果是否为真。
    equal(): 判断实际值余期望值是否相等。
    notEqual(): 判断实际值与期望值是否不相等。
    deepEqual(): 判断实际值余期望值是否深度相等（对象和数组的元素是否相等）。
    notDeepEqual(): 判断实际值与期望值是否不深度相等。
    strictEqual(): 判断实际值与期望值是否严格相等（===）。
    notStrictEqual(): 判断实际值与期望值是否不严格相等（!==）。
    throws(): 判断代码块是否抛出异常。
    doesNotThrow(): 判断代码块是否没有抛出异常。
    ifError(): 判断实际值是否为一个假值（null、undefined、0、&apos;&apos;、false），若实际值为真值，将抛出异常。
2.测试框架
    用于管理测试用例和生成测试报告。
    mocha 模块
    测试风格
        TDD 测试驱动开发
        BDD 行为驱动开发
    测试报告
        mocha --reporters
    测试代码的文件组织
    测试用例
    异步测试
    测试覆盖率
    mock 或者 muk
    私有方法的测试
        var lib = rewire(&apos;../lib/index.js&apos;); // 需要测试方法所在的文件
        var litmit = lib.__get__(&apos;limit&apos;); // 需要测试的方法
3.工程化与自动化    
    工程化 -- Makefile
    持续集成 -- travis-ci
</code></pre><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><pre><code>负载测试、压力测试和基准测试。
基准测试：（对基本的方法如Array.protoryp.map 和 for循环的比较）
    benchmark 模块
压力测试：（网络接口进行压力测试）
    常用的工具：ab、siege、http_load
基准测试驱动开发
    1.写基准测试
    2.写/改代码
    3.收集数据
    4.找出问题
    5.回到第（2）步
测试数据余业务数据的转换
    PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。
    UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。
    TPS 是每秒内的事务数，比如执行了dml操作，那么相应的tps会增加；
    QPS 是指每秒内查询次数，比如执行了select操作，相应的qps会增加。
    QPS = PV/H (H为访问量集中的时间单位小时)。
</code></pre><h2 id="产品化"><a href="#产品化" class="headerlink" title="产品化"></a>产品化</h2><pre><code>包括：工程化、架构、容灾备份、部署和运维。
</code></pre><h3 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a>项目工程化</h3><pre><code>1.目录结构
    Web框架：Express、Koa、Egg
2.构建工具
    合并静态文件、压缩文件大小、打包应用、编译模块。
    Makefile 
        一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，
        makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，
        哪些文件需要重新编译，甚至于进行更复杂的功能操作，
        因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。
    Grunt
3.编码规范
    JSLint JSHint ESLint
4.代码审查
</code></pre><h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><pre><code>部署环境
部署操作    
</code></pre><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><pre><code>动静分离
    静态请求用 Nginx 和 CDN 来保存
启用缓存
    Redis 和 Memcached
多进程架构    
    读写分离
</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code>访问日志
异常日志
日志与数据库
分割日志
</code></pre><h3 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h3><pre><code>业务逻辑型监控 和 硬件型监控
监控    
    日志监控
    响应时间
    进程监控
    磁盘监控
    内存监控
    CPU占用监控
    CPU load监控
    I/O负载
    网络监控
    应用状态监控
    DNS 监控 -- 免费DNS监控服务 DNSPod
    报警的实现
        邮件报警 -- nodemailer 模块
        短信或电话报警 

监控系统的稳定性
</code></pre><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><pre><code>多机器
多机房
容灾备份
</code></pre><h3 id="异构共存"><a href="#异构共存" class="headerlink" title="异构共存"></a>异构共存</h3><h2 id="调试Node"><a href="#调试Node" class="headerlink" title="调试Node"></a>调试Node</h2><pre><code>Debugger
    1.在代码中插入 debugger
    2.运行 node debug demo.js
Node Inspector
    1.安装 npm install -g node-inspector
    2.错误堆栈
</code></pre><h2 id="Node-编码规范"><a href="#Node-编码规范" class="headerlink" title="Node 编码规范"></a>Node 编码规范</h2><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><pre><code>1.空格与格式 -- 采用2个空格缩进，而不是tab缩进。
2.变量声明 -- 每个变量声明都应该带var。
3.空格 -- 操作符前后加空格，如+、-、*、%、/、=等
4.单双引号的问题 -- 只在html标签的属性中使用双引号，其余使用单引号。
    但在JSON中，严格的规范是要求使用字符串使用双引号，内容中出现双引号时需要转义。
5.大括号的位置 -- 不需要另起一行
6.逗号 -- 若逗号不在行结尾，前面需要一个空格。
7.分号 -- 给表达式结尾添加分号。    
</code></pre><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><pre><code>1.变量命名 -- 小驼峰式命名。
2.方法命名 -- 小驼峰式命名，尽量采用动词或判断词汇。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getUser = () =&gt; &#123;&#125;;</span><br><span class="line">var isAdmin = () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

3.类命名（构造函数和Class） -- 大驼峰式命名。
4.常量命名 -- 全大写字母和下划线。    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var PINK_COLOR = &apos;pink&apos;;</span><br></pre></td></tr></table></figure>


5.文件命名 -- 全小写字母和下划线。
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_process.js // 普通文件</span><br><span class="line">_linklist.js // 私有文件</span><br></pre></td></tr></table></figure>

6.包名 -- 不要包含 js 或 node 的字样，它们是重复的。
</code></pre><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><pre><code>1.使用 === 替代 ==
2.当遇到 0、undefined、null、false、&apos;&apos;假值时，不需要使用 === 或 ==。    
</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code>尽量使用 {}、[]，不要使用 new Object() 和 new Array()    
</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><pre><code>1.慎用with
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with (obj) &#123;</span><br><span class="line">	foo = bar;</span><br><span class="line">&#125;</span><br><span class="line">// 出现4中结果：obj.foo = obj.bar; obj.foo = bar; foo = obj.bar; foo = bar;</span><br></pre></td></tr></table></figure>

2.慎用eval()
</code></pre><h3 id="数组与对象"><a href="#数组与对象" class="headerlink" title="数组与对象"></a>数组与对象</h3><pre><code>1.字面量格式 -- 结尾用逗号分隔，若分行，一行只能一个元素。
2.for in 循环 -- 只能对对象使用，不能对数组使用。
    for in语句以任意顺序遍历一个对象的可枚举属性（包括原型上的属性）。
3.不要把数组当对象使用    
</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><pre><code>1.异步回调函数的第一个参数应该是错误指示    
2.执行传入的回调函数    
</code></pre><h3 id="类与模块"><a href="#类与模块" class="headerlink" title="类与模块"></a>类与模块</h3><pre><code>1.类继承（Node推荐的类继承方式）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Socket (options) &#123;</span><br><span class="line">	stream.Stream.call(this);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Socket, stream.Stream);</span><br></pre></td></tr></table></figure>

2.导出 -- 所有供外部调用的方法或变量均需要挂载在exports变量上。
    当需要将文件当做一个类导出时，需要通过如下方式挂载。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = Class;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="注解规范"><a href="#注解规范" class="headerlink" title="注解规范"></a>注解规范</h3><pre><code>采用 JSDoc
</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><pre><code>1.冲突的解决原则 -- 入乡随俗
2.给编辑器设置检测工具    
3.版本控制中的hook    
4.持续集成
</code></pre><h2 id="搭建局域NPM仓库"><a href="#搭建局域NPM仓库" class="headerlink" title="搭建局域NPM仓库"></a>搭建局域NPM仓库</h2><blockquote>
<p>参考文档<br>    <a href="https://www.baidu.com/s?ie=utf8&amp;oe=utf8&amp;wd=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode&amp;tn=98010089_dg&amp;ch=1" target="_blank" rel="noopener">朴灵-深入浅出Node</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda运用--官方文档解读</title>
    <url>/2017/ramda%E8%BF%90%E7%94%A8-5.html</url>
    <content><![CDATA[<p>从8月25到8月29共5个晚上和小部分周末时间撸完了Ramda官方文档，继续在事件中继续学习。<br>Rmda中共分为List、Relation、Object、Function、Math、Type、Logic、String共8大类。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><pre><code>定义：检测字符串是否匹配给定的正则表达式。
```   
R.test(/^x/, &apos;xyz&apos;); // true
```   
</code></pre><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><pre><code>定义：正则匹配字符串。注意，如果没有匹配项，则返回空数组。和 String.prototype.match 不同，后者在没有匹配项时会返回 null。
```   
R.match(/([a-z]a)/g, &apos;bananas&apos;); //=&gt; [&apos;ba&apos;, &apos;na&apos;, &apos;na&apos;]
```   
</code></pre><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><pre><code>定义：替换字符串的子串或正则匹配到的值。
```   
R.replace(&apos;foo&apos;, &apos;bar&apos;, &apos;foo foo foo&apos;); // bar foo foo
```   
</code></pre><h5 id="split"><a href="#split" class="headerlink" title="split"></a>split</h5><pre><code>定义：根据指定的分隔符将字符串拆分为字符串类型的数组。
```   
R.split(&apos;.&apos;, &apos;a.b.c.xyz.d&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;xyz&apos;, &apos;d&apos;]
```   
</code></pre><h5 id="toLower"><a href="#toLower" class="headerlink" title="toLower"></a>toLower</h5><pre><code>定义：将字符串转换成小写。
```   
R.toLower(&apos;XYZ&apos;); // xyz
```   
</code></pre><h5 id="toUpper"><a href="#toUpper" class="headerlink" title="toUpper"></a>toUpper</h5><pre><code>定义：将字符串转换为大写。
```   
R.toUpper(&apos;abc&apos;); // ABC
```   
</code></pre><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><pre><code>定义：返回代表输入元素的字符串。求得的输出结果应该等价于输入的值。许多内建的 toString 方法都不满足这一条件。
如果输入值是 [object Object] 对象，且自身含有 toString 方法（不是 Object.prototype.toString 方法），那么直接调用这个方法求返回值。
这意味着，通过用户自定义的构造函数可以提供合适的 toString 方法。
```   
R.toString(42); // 42
```   
</code></pre><h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><pre><code>定义：删除字符串首、尾两端的空白字符。
```   
R.trim(&apos;   xyz  &apos;); //=&gt; &apos;xyz&apos;
```   
</code></pre><h4 id="List-Array"><a href="#List-Array" class="headerlink" title="List(Array)"></a>List(Array)</h4><h5 id="adjust"><a href="#adjust" class="headerlink" title="adjust"></a>adjust</h5><pre><code>定义：将数组中指定索引处的值替换为经函数变换的值。
```   
R.adjust(R.add(10))(1)([1, 2, 3]); // [1, 12, 3]
```   
</code></pre><h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><pre><code>定义：如果列表中的所有元素都满足 predicate，则返回 true；否则，返回 false。
```   
var equals3 = R.equals(3);
R.all(equals3)([3, 3, 3]); // true
R.all(equals3)([1, 3, 3]); // false
```   
</code></pre><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><pre><code>定义：只要列表中有一个元素满足 predicate，就返回 true，否则返回 false。
```   
var lessThan0 = R.flip(R.lt)(0);
var lessThan2 = R.flip(R.lt)(2);
R.any(lessThan0)([1, 2]); // false
R.any(lessThan2)([1, 2]); // true
```   
</code></pre><h5 id="aperture"><a href="#aperture" class="headerlink" title="aperture"></a>aperture</h5><pre><code>定义：返回一个新列表，列表中的元素为由原列表相邻元素组成的 n 元组。如果 n 大于列表的长度，则返回空列表。
```   
R.aperture(2, [1, 2, 3, 4, 5]); // [[1, 2], [2, 3], [3, 4], [4, 5]]
```   
</code></pre><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><pre><code>定义：在列表末尾拼接一个元素。
```   
R.append(5)([1, 2, 3]); // [1, 2, 3, 5]
```   
</code></pre><h5 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h5><pre><code>定义：chain 将函数映射到列表中每个元素，并将结果连接起来。 chain 在一些库中也称为 flatMap（先 map 再 flatten ）。
```   
var duplicate = n =&gt; [n, n];
R.chain(duplicate, [1, 2, 3]); // [1, 1, 2, 2, 3, 3]
```        
</code></pre><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><pre><code>定义：连接列表或字符串。
```   
R.concat(&apos;ABC&apos;, &apos;DEF&apos;); // ABCDEF
R.concat([1, 2, 3])([4, 5, 6]); // [1, 2, 3, 4, 5, 6]
```            
</code></pre><h5 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h5><pre><code>定义：只要列表中有一个元素等于指定值，则返回 true；否则返回 false。通过 R.equals 函数进行相等性判断。
```   
R.contains(2, [1, 2, 3]); // true
```       
</code></pre><h5 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h5><pre><code>定义：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。
```   
R.drop(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;zhen&apos;]
R.drop(2, &apos;fanerge&apos;); // nerge
```       
</code></pre><h5 id="dropLast"><a href="#dropLast" class="headerlink" title="dropLast"></a>dropLast</h5><pre><code>定义：删除 &quot;list&quot; 末尾的 n 个元素。
```   
R.dropLast(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;fan&apos;]
R.dropLast(2, &apos;fanerge&apos;); // faner
```       
</code></pre><h5 id="dropLastWhile"><a href="#dropLastWhile" class="headerlink" title="dropLastWhile"></a>dropLastWhile</h5><pre><code>定义：对 list 从后向前一直删除满足 predicate 的尾部元素，直到遇到第一个 falsy 值，此时停止删除操作。
predicate 需要作为第一个参数传入。
```   
var lteThree = x =&gt; x &lt;= 3;
R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3, 4]
```       
</code></pre><h5 id="dropRepeats"><a href="#dropRepeats" class="headerlink" title="dropRepeats"></a>dropRepeats</h5><pre><code>定义：返回一个没有连续重复元素的 list。通过 R.equals 函数进行相等性判断。
```   
R.dropRepeats([1, 1, 2, 2, 3, 3, 2, 2]); // [1, 2, 3, 2] 
```       
</code></pre><h5 id="dropRepeatsWith"><a href="#dropRepeatsWith" class="headerlink" title="dropRepeatsWith"></a>dropRepeatsWith</h5><pre><code>定义：返回一个没有连续重复元素的 list。首个参数提供的 predicate 用于检测 list 中相邻的两个元素是否相等。
一系列相等元素中的首个元素会被保留。
```   
var list = [1, -1, 1, 3, 4, -4];
R.dropRepeatsWith(R.eqBy(Math.abs), list); // [1, 3, 4]
```       
</code></pre><h5 id="dropWhile"><a href="#dropWhile" class="headerlink" title="dropWhile"></a>dropWhile</h5><pre><code>定义：对 list 从前向后删除满足 predicate 的头部元素，直到遇到第一个 falsy 值。
predicate 需要作为第一个参数传入。
```   
var lteTwo = x =&gt; x &lt;= 2;
R.dropWile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); // [3, 4, 3, 2, 1]
```       
</code></pre><h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h5><pre><code>定义：检查列表或字符串是否以给定的值结尾。
```   
R.endsWith(&apos;c&apos;, &apos;abc&apos;); // true
R.endsWith([&apos;c&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true
```       
</code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><pre><code>定义：使用 predicate 遍历传入的 Filterable，返回满足 predicate 的所有元素的新的 Filterable。新 Filterable 与原先的类型相同。Filterable 类型包括 plain object 或者任何带有 filter 方法的类型，如 Array 。
```   
var isEven = n =&gt; n % 2 === 0;
R.filter(isEven, [1, 2, 3, 4]); // [2, 4]
```       
</code></pre><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><pre><code>定义：查找并返回 list 中首个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。
```   
var xs = [{a: 1}, {a: 2}, {a: 3}];
R.find(R.propEq(&apos;a&apos;, 2))(xs); // {a: 2}
```   
</code></pre><h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h5><pre><code>定义：查找并返回 list 中首个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。
```   
var xs = [{a: 1}, {a: 2}, {a: 3}];
R.findIndex(R.propEq(&apos;a&apos;, 2))(xs); // 1
```   
</code></pre><h5 id="findLast"><a href="#findLast" class="headerlink" title="findLast"></a>findLast</h5><pre><code>定义：查找并返回 list 中最后一个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。
```   
var xs = [{a: 1, b: 0}, {a:1, b: 1}];
R.findLast(R.propEq(&apos;a&apos;, 1))(xs); // {a: 1, b: 1}
```   
</code></pre><h5 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h5><pre><code>定义：查找并返回 list 中最后一个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。
```   
var xs = [{a: 1, b: 0}, {a:1, b: 1}];
R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs); // 1
```   
</code></pre><h5 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h5><pre><code>定义：获取 list 的所有元素（包含所有子数组中的元素），然后由这些元素组成一个新的数组。深度优先。
```   
R.flatten([1, [2, [3]]]); // [1, 2, 3]
```   
</code></pre><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><pre><code>定义：遍历 list，对 list 中的每个元素执行方法 fn。
Ramda 的 forEach 会将原数组返回。
```   
var printPlusFive = x =&gt; console.log(x + 5);
R.forEach(printPlusFive, [1, 2, 3]); // [1, 2, 3]
```   
</code></pre><h5 id="fromPairs"><a href="#fromPairs" class="headerlink" title="fromPairs"></a>fromPairs</h5><pre><code>定义：由一系列 “键值对” 创建一个 object。如果某个键出现多次，选取最右侧的键值对。
```   
var R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]); // {a: 1, b: 2, c: 3}
```   
</code></pre><h5 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h5><pre><code>定义：将列表根据一定规则拆分成多组子列表，并存储在一个对象中。
对列表中的每个元素调用函数，根据函数返回结果进行分组。
函数返回字符串作为相等性判断，返回的字符串作为存储对象的键，具有相同返回字符串的元素聚合为数组，作为该键的值。
```   
var byGrade = R.groupBy(function(student) {
  var score = student.score;
  return score &lt; 65 ? &apos;F&apos; :
         score &lt; 70 ? &apos;D&apos; :
         score &lt; 80 ? &apos;C&apos; :
         score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;
});
var students = [{name: &apos;Abby&apos;, score: 84},
                {name: &apos;Eddy&apos;, score: 58},
                // ...
                {name: &apos;Jack&apos;, score: 69}];
byGrade(students);
// {
//   &apos;A&apos;: [{name: &apos;Dianne&apos;, score: 99}],
//   &apos;B&apos;: [{name: &apos;Abby&apos;, score: 84}]
//   // ...,
//   &apos;F&apos;: [{name: &apos;Eddy&apos;, score: 58}]
// }
```   
</code></pre><h5 id="groupWith"><a href="#groupWith" class="headerlink" title="groupWith"></a>groupWith</h5><pre><code>定义：通过给定的对比函数，将列表按顺序分割成多组子列表。
对比函数只比较相邻元素。
```   
var R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 13, 21]); 
// [[0], [1, 1], [2], [3], [5], [13], [21]]
```   
</code></pre><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><pre><code>定义：求列表或字符串的首个元素。在某些库中，该函数也被称作 first。
```   
R.head([1, 2, 3]); // 1
R.head(&apos;fan&apos;); // f
```   
</code></pre><h5 id="indexBy"><a href="#indexBy" class="headerlink" title="indexBy"></a>indexBy</h5><pre><code>定义：通过生成键的函数，将元素为对象的 list 转换为以生成的键为索引的新对象。注意，如果 list 中多个对象元素生成相同的键，以最后一个对象元素作为该键的值。
```   
var list = [{id: &apos;xyz&apos;, title: &apos;A&apos;}, {id: &apos;abc&apos;, title: &apos;B&apos;}];
R.indexBy(R.prop(&apos;id&apos;), list);
//=&gt; {abc: {id: &apos;abc&apos;, title: &apos;B&apos;}, xyz: {id: &apos;xyz&apos;, title: &apos;A&apos;}}
```   
</code></pre><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><pre><code>定义：返回给定元素在数组中首次出现时的索引值，如果数组中没有该元素，则返回 -1。通过 R.equals 函数进行相等性判断。
```   
R.indexOf(3, [1, 2, 3, 4]); // 2
```       
</code></pre><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><pre><code>定义：返回 list 或 string 删除最后一个元素后的部分。
```   
R.init([1, 2, 3]);  //=&gt; [1, 2]
R.init(&apos;abc&apos;);  //=&gt; &apos;ab&apos;
```       
</code></pre><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><pre><code>定义：将元素插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。
```   
R.insert(2, &apos;x&apos;, [1, 2, 3, 4]); // [1,2,&apos;x&apos;,3,4]
```       
</code></pre><h5 id="insertAll"><a href="#insertAll" class="headerlink" title="insertAll"></a>insertAll</h5><pre><code>定义：将子 list 插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。
```   
R.insertAll(2, [&apos;x&apos;, &apos;y&apos;], [1, 2, 3, 4]); // [1, 2, &apos;x&apos;, &apos;y&apos;, 3, 4]
```       
</code></pre><h5 id="intersperse"><a href="#intersperse" class="headerlink" title="intersperse"></a>intersperse</h5><pre><code>定义：在列表的元素之间插入分割元素。
```   
R.intersperse(&apos;n&apos;, [&apos;ba&apos;, &apos;a&apos;, &apos;a&apos;]); //=&gt; [&apos;ba&apos;, &apos;n&apos;, &apos;a&apos;, &apos;n&apos;, &apos;a&apos;]
```       
</code></pre><h5 id="into"><a href="#into" class="headerlink" title="into"></a>into</h5><pre><code>定义：使用 transducer 对 list 中的元素进行转换，然后使用基于 accumulator 的类型的迭代器函数将转换后的元素依次添加到 accumulator 上。
```   
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));
R.into([], transducer, numbers); //=&gt; [2, 3]
```       
</code></pre><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><pre><code>定义：将列表中所有元素通过 分隔符 串连为一个字符串。
```   
var spacer = R.join(&apos;#&apos;);
spacer([1, 2, 3]); // 1#2#3
```       
</code></pre><h5 id="last"><a href="#last" class="headerlink" title="last"></a>last</h5><pre><code>定义：返回列表或字符串的最后一个元素。
```   
R.last([&apos;fan&apos;, &apos;zhen&apos;, &apos;yu&apos;]); // yu
R.last(&apos;abc&apos;); // c
```       
</code></pre><h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><pre><code>定义：返回数组中某元素最后一次出现的位置，如果数组中不包含该项则返回 -1 。通过 R.equals 函数进行相等性判断。
```   
R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); // 6
```   
</code></pre><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><pre><code>定义：通过 list.length，返回数组的大小（数组中元素的数量）。
```   
R.length([]); // 0
```   
</code></pre><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><pre><code>定义：接收一个函数和一个 functor, 将该函数应用到 functor 的每个值上，返回一个具有相同形态的 functor。
Ramda 为 Array 和 Object 提供了合适的 map 实现，因此 R.map 适用于 [1, 2, 3] 或 {x: 1, y: 2, z: 3}。
若第二个参数自身存在 map 方法，则调用自身的 map 方法。
```   
var double = x =&gt; x * 2;
R.map(double, [1, 2, 3]); // [2, 4, 6]
```   
</code></pre><h5 id="mapAccum"><a href="#mapAccum" class="headerlink" title="mapAccum"></a>mapAccum</h5><pre><code>定义：mapAccum 的行为类似于 map 和 reduce 的组合；
它将迭代函数作用于列表中的每个元素，从左往右传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。 
迭代函数接收两个参数，acc 和 value， 返回一个元组 [acc, value]。
```   
var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];
var appender = (a, b) =&gt; [a + b, a + b];
R.mapAccum(appender, 0, digits); // [&apos;01234&apos;, [&apos;01&apos;, &apos;012&apos;, &apos;0123&apos;, &apos;01234&apos;]]
```   
</code></pre><h5 id="mapAccumRight"><a href="#mapAccumRight" class="headerlink" title="mapAccumRight"></a>mapAccumRight</h5><pre><code>定义：mapAccumRight 的行为类似于 map 和 reduce 的组合；
它将迭代函数作用于列表中的每个元素，从右往左传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。
和 mapAccum 类似，除了列表遍历顺序是从右往左的。
迭代函数接收两个参数，value 和 acc ，返回一个元组 [value, acc]。
```   
var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];
var append = (a, b) =&gt; [a + b, a + b];
R.mapAccumRight(append, 5, digits); // [[&apos;12345&apos;, &apos;2345&apos;, &apos;345&apos;, &apos;45&apos;], &apos;12345&apos;]
```   
</code></pre><h5 id="mapObjIndexed"><a href="#mapObjIndexed" class="headerlink" title="mapObjIndexed"></a>mapObjIndexed</h5><pre><code>定义：Object 版本的 map。mapping function 接受三个参数： (value, key, obj) 。如果仅用到参数 value，则用 map 即可。
```   
var values = {x: 1, y: 2, z: 3};
var prependKeyAndDouble = (val, key, obj) =&gt; key + (val * 2);
R.mapIndexed(prependKeyAndDouble, values); // { x: &apos;x2&apos;, y: &apos;y4&apos;, z: &apos;z6&apos; }
```   
</code></pre><h5 id="mergaAll"><a href="#mergaAll" class="headerlink" title="mergaAll"></a>mergaAll</h5><pre><code>定义：将对象类型列表合并为一个对象。
```   
R.mergeAll([{foo: 1}, {bar: 2}, {baz: 3}]); // {foo: 1, bar: 2, baz: 3}
```   
</code></pre><h5 id="none"><a href="#none" class="headerlink" title="none"></a>none</h5><pre><code>定义：如果列表中的元素都不满足 predicate，返回 true；否则返回 false。
```   
var isEven = n =&gt; n % 2 === 0;
R.none(isEven, [1, 2, 3]); // true
```   
</code></pre><h5 id="nth"><a href="#nth" class="headerlink" title="nth"></a>nth</h5><pre><code>定义：返回列表或字符串的第 n 个元素。如果 n 为负数，则返回索引为 length + n 的元素。
```   
var list = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;quux&apos;];
R.nth(1, list); // &apos;bar&apos;
```   
</code></pre><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><pre><code>定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。
```   
R.pair(&apos;foo&apos;, &apos;bar&apos;); // [&apos;foo&apos;, &apos;bar&apos;]
```   
</code></pre><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><pre><code>定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。
```   
R.partition(R.contains(&apos;s&apos;), [&apos;sss&apos;, &apos;ttt&apos;, &apos;foo&apos;, &apos;bars&apos;]);
// [ [ &apos;sss&apos;, &apos;bars&apos; ],  [ &apos;ttt&apos;, &apos;foo&apos; ] ]
```   
</code></pre><h5 id="pluck"><a href="#pluck" class="headerlink" title="pluck"></a>pluck</h5><pre><code>定义：从列表内的每个对象元素中取出特定名称的属性，组成一个新的列表。
pluck 可以作用于任何 functor ，包括 Array，因为它等价于 R.map(R.prop(k), f)。
```   
R.pluck(&apos;a&apos;)([{a: 1}, {a: 2}]); // [1, 2]
```   
</code></pre><h5 id="prepend"><a href="#prepend" class="headerlink" title="prepend"></a>prepend</h5><pre><code>定义：在列表头部之前拼接一个元素。
```   
R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); // [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]
```   
</code></pre><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><pre><code>定义：返回从 from 到 to 之间的所有数的升序列表。左闭右开（包含 from，不包含 to）。
```   
R.range(1, 5); // [1, 2, 3, 4]
```   
</code></pre><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><pre><code>定义：左折叠操作。
遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。
可以用 R.reduced 提前终止遍历操作。
```   
R.reduce(R.subtract, 0, [1, 2, 3, 4]) // =&gt; ((((0 - 1) - 2) - 3) - 4) = -10
```   
</code></pre><h5 id="reduceBy"><a href="#reduceBy" class="headerlink" title="reduceBy"></a>reduceBy</h5><pre><code>定义：首先对列表中的每个元素调用函数 keyFn ，根据 keyFn 返回的字符串对列表元素进行分组。
然后调用 reducer 函数 valueFn，对组内的元素进行折叠操作。
该函数相当于更通用的 groupBy 函数。
```   
var reduceToNamesBy = R.reduceBy((acc, student) =&gt; acc.concat(student.name), []);
var namesByGrade = reduceToNamesBy(function(student) {
  var score = student.score;
  return score &lt; 65 ? &apos;F&apos; :
         score &lt; 70 ? &apos;D&apos; :
         score &lt; 80 ? &apos;C&apos; :
         score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;
});
var students = [{name: &apos;Lucy&apos;, score: 92},
                {name: &apos;Drew&apos;, score: 85},
                {name: &apos;Bart&apos;, score: 62}];
namesByGrade(students);
// {
//   &apos;A&apos;: [&apos;Lucy&apos;],
//   &apos;B&apos;: [&apos;Drew&apos;]
//   &apos;F&apos;: [&apos;Bart&apos;]
// }
```   
</code></pre><h5 id="reduced"><a href="#reduced" class="headerlink" title="reduced"></a>reduced</h5><pre><code>定义：返回一个封装的值，该值代表 reduce 或 transduce 操作的最终结果。
返回值是一个黑盒：不保证其内部结构的稳定性。
```   
R.reduce(
    (acc, item) =&gt; item &gt; 3 ? R.reduced(acc) : acc.concat(item),
    [],
    [1, 2, 3, 4, 5]
); // [1, 2, 3]
```   
</code></pre><h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h5><pre><code>定义：右折叠操作。
遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。
类似于 reduce，除了遍历列表的顺序是从右向左的。
```   
R.reduceRight(R.subtract, 0, [1, 2, 3, 4]); // (1 - (2 - (3 - (4 - 0)))) = -2
```   
</code></pre><h5 id="reduceWhile"><a href="#reduceWhile" class="headerlink" title="reduceWhile"></a>reduceWhile</h5><pre><code>定义：与 reduce 类似， reduceWhile 会遍历列表，相继调用二元迭代函数，并返回最终累积值。
reduceWhile 在每次调用迭代函数前，先使用 predicate 进行判断，如果 predicate 返回 false ，则提前终止遍历操作，并返回当前累积值。
```   
var isOdd = (acc, x) =&gt; x % 2 === 1;
var xs = [1, 3, 5, 60, 777, 800];
R.reduceWhile(isOdd, R.add, 0, xs); // 9
```   
</code></pre><h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><pre><code>定义：filter 的补操作。返回结果为 R.filter 操作结果的补集。
```   
var isOdd = (acc, x) =&gt; x % 2 === 1;
R.reject(isOdd, [1, 2, 3, 4]); // [2, 4]
```   
</code></pre><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><pre><code>定义：删除列表中从 start 开始的 count 个元素。_ 注意，该操作是非破坏性的：不改变原列表，返回处理后列表的拷贝。
```   
R.remove(2, 3, [1, 2, 3, 4, 5, 6, 7, 8]); // [1, 2, 6, 7, 8]
```   
</code></pre><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><pre><code>定义：生成包含 n 个同一元素的数组。
```   
R.repeat(&apos;h&apos;, 5); // [&apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;]
```   
</code></pre><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><pre><code>定义：对列表或字符串的排列顺序取反。
```   
R.reverse([1, 2, 3]); // [3, 2, 1]
```   
</code></pre><h5 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h5><pre><code>定义：Scan 与 reduce 类似，但会将每次迭代计算的累积值记录下来，组成一个列表返回。
```   
var numbers = [1, 2, 3, 4];
var factorials = R.scan(R.multiply, 1, numbers); // [1, 1, 2, 6, 24]
```   
</code></pre><h5 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h5><pre><code>定义：将一个 Applicative 的 Traversable 转换成一个 Traversable 类型的 Applicative。
```   
R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=&gt; Just([1, 2, 3])
```   
</code></pre><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><pre><code>定义：取出给定的列表或字符串（或带有 slice 方法的对象）中，从 fromIndex（包括）到 toIndex（不包括）的元素。
```   
R.slice(1, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]); // [&apos;b&apos;, &apos;c&apos;]
```   
</code></pre><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><pre><code>定义：使用比较函数对列表进行排序。比较函数每次接受两个参数，如果第一个值较小，则返回负数；如果第一个值较大，则返回正数；如果两值相等，返回零。注意，返回的是列表的 拷贝 ，不会修改原列表。
```   
var diff = function (a, b) { return a - b };
R.sort(diff, [4, 2, 7, 5]); // [2, 4, 5, 7]
```   
</code></pre><h5 id="splitAt"><a href="#splitAt" class="headerlink" title="splitAt"></a>splitAt</h5><pre><code>定义：在指定的索引处拆分列表或者字符串。
```   
R.splitAt(1, [1, 2, 3]); // [[1], [2, 3]]
R.splitAt(5, &apos;hello world&apos;); // [&apos;hello&apos;, &apos;world&apos;]
```   
</code></pre><h5 id="splitEvery"><a href="#splitEvery" class="headerlink" title="splitEvery"></a>splitEvery</h5><pre><code>定义：将列表拆分成指定长度的子列表集。
```   
R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); // [[1, 2, 3], [4, 5, 6], 7]
R.splitEvery(3, &apos;foobarbaz&apos;); //=&gt; [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]
```   
</code></pre><h5 id="splitWhen"><a href="#splitWhen" class="headerlink" title="splitWhen"></a>splitWhen</h5><pre><code>定义：查找列表中首个满足 predicate 的元素，在该处将列表拆分为两部分。首个满足 predicate 的元素包含在后一部分。
```   
R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=&gt; [[1], [2, 3, 1, 2, 3]]
```   
</code></pre><h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h5><pre><code>定义：检查列表是否以给定的值开头。
```   
R.startsWith(&apos;a&apos;, &apos;abc&apos;); // true
R.startsWith([&apos;a&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true
```   
</code></pre><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><pre><code>定义：删除列表中的首个元素（或者调用对象的 tail 方法）。
```   
R.tail([1, 2, 3]); // [2, 3]
```   
</code></pre><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><pre><code>定义：返回列表的前 n 个元素、字符串的前n个字符或者用作 transducer/transform（或者调用对象的 take 方法）。
```   
R.take(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;]
```   
</code></pre><h5 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h5><pre><code>定义：返回列表的后 n 个元素。如果 n &gt; list.length，则返回 list.length 个元素。
```   
R.takeLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;baz&apos;]
```   
</code></pre><h5 id="takeLastWhile"><a href="#takeLastWhile" class="headerlink" title="takeLastWhile"></a>takeLastWhile</h5><pre><code>定义：从后往前取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。
```   
var isNotOne = x =&gt; x !== 1;
R.takeLastWhile(isNotOne, [1, 2, 3, 4]); // [2, 3, 4]
```   
</code></pre><h5 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h5><pre><code>定义：从前往后取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。
```   
var isNotFour = x =&gt; x !== 4;
R.takeLastWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3]
```   
</code></pre><h5 id="times"><a href="#times" class="headerlink" title="times"></a>times</h5><pre><code>定义：执行输入的函数 n 次，返回由函数执行结果组成的数组。
fn 为一元函数，n 次调用接收的参数为：从 0 递增到 n-1 。
```   
R.times(R.identity, 5); // [0, 1, 2, 3, 4]
```   
</code></pre><h5 id="transduce"><a href="#transduce" class="headerlink" title="transduce"></a>transduce</h5><pre><code>定义：用 iterator function 初始化 transducer ，生成一个 transformed iterator function。
然后顺次遍历列表，对每个列表元素先进行转换，然后与累积值进行归约，返回值作为下一轮迭代的累积值。最终返回与初始累积值类型相同的一个累积值。
```   
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));
R.transduce(transducer, R.flip(R.append), [], numbers); //=&gt; [2, 3]
```   
</code></pre><h5 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h5><pre><code>定义：二维数组行列转置。输入 n 个长度为 x 的数组，输出 x 个长度为 n 的数组。
```   
R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
```       
</code></pre><h5 id="traverse"><a href="#traverse" class="headerlink" title="traverse"></a>traverse</h5><pre><code>定义：将返回值为 Applicative 类型的函数映射到一个 Traversable 上。
然后使用 sequence 将结果由 Traversable of Applicative 转换为 Applicative of Traversable。
```   
var safeDiv = n =&gt; d =&gt; d === 0 ? Nothing() : Just(n / d);
R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=&gt; Just([5, 2.5, 2])
```       
</code></pre><h5 id="unfold"><a href="#unfold" class="headerlink" title="unfold"></a>unfold</h5><pre><code>定义：通过一个种子值（ seed ）创建一个列表。unfold 接受一个迭代函数：
该函数或者返回 false 停止迭代，或者返回一个长度为 2 的数组：数组首个元素添加到结果列表，第二个元素作为种子值传给下一轮迭代使用。
```   
var f = n =&gt; n &gt; 50 ? false : [-n, n + 10];
R.unfold(f, 10); //=&gt; [-10, -20, -30, -40, -50]
```       
</code></pre><h5 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h5><pre><code>定义：列表去重操作。返回无重复元素的列表。通过 R.equals 函数进行相等性判断。
```   
R.uniq([1, 1, 2, 1]); // [1, 2]
```   
</code></pre><h5 id="uniqBy"><a href="#uniqBy" class="headerlink" title="uniqBy"></a>uniqBy</h5><pre><code>定义：返回无重复元素的列表。元素通过给定的函数的返回值以及 R.equals 进行相同性判断。如果给定的函数返回值相同，保留第一个元素。
```   
R.uniqBy(Math.abs, [1, -1, 2, 1]); // [1, 2]
```   
</code></pre><h5 id="uniqWith"><a href="#uniqWith" class="headerlink" title="uniqWith"></a>uniqWith</h5><pre><code>定义：返回无重复元素的列表。元素通过 predicate 进行相同性判断。如果通过 predicate 判断两元素相同，保留第一个元素。
```   
var strEq = R.eqBy(String);
R.uniqWith(strEq)([1, &apos;1&apos;, 2, 1]); //=&gt; [1, 2]
```   
</code></pre><h5 id="unnest"><a href="#unnest" class="headerlink" title="unnest"></a>unnest</h5><pre><code>定义：R.chain(R.identity) 的简写, 对 Chain 类型的数据消除一层嵌套。
```   
R.unnest([1, [2], [[3]]]); //=&gt; [1, 2, [3]]
```   
</code></pre><h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><pre><code>定义：替换数组中指定索引处的值。
```   
R.update(1, 11, [0, 1, 2]); // [0, 11, 2]
```   
</code></pre><h5 id="without"><a href="#without" class="headerlink" title="without"></a>without</h5><pre><code>定义：求第二个列表中，未包含在第一个列表中的任一元素的集合。通过 R.equals 函数进行相等性判断。
```   
R.without([1, 2], [1, 2, 1, 3, 4]); // [3, 4]
```   
</code></pre><h5 id="xprod"><a href="#xprod" class="headerlink" title="xprod"></a>xprod</h5><pre><code>定义：将两个列表的元素两两组合，生成一个新的元素对列表。
```   
R.xprod([1, 2], [&apos;a&apos;, &apos;b&apos;]); // [[1, &apos;a&apos;], [1, &apos;b&apos;], [2, &apos;a&apos;], [2, &apos;b&apos;]]
```   
</code></pre><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><pre><code>定义：将两个列表对应位置的元素组合，生成一个新的元素对列表。生成的列表长度取决于较短的输入列表的长度。
注意，zip 等价于 zipWith(function(a, b) { return [a, b] }) 。
```   
R.zip([1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]
```   
</code></pre><h5 id="zipObj"><a href="#zipObj" class="headerlink" title="zipObj"></a>zipObj</h5><pre><code>定义：将两个列表对应位置的元素作为键值对组合，生成一个新的键值对的列表。生成的列表长度取决于较短的输入列表的长度。
注意，zip 等价于 pipe(zipWith(pair), fromPairs) 。
```   
R.zipObj([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]); // {a: 1, b: 2, c: 3}
```   
</code></pre><h5 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h5><pre><code>定义：将两个列表对应位置的元素通过一个函数处理，生成一个新的元素的列表。生成的列表长度取决于较短的输入列表的长度。
```   
var f = (x, y) =&gt; {
  // ...
};
R.zipWith(f, [1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);
//=&gt; [f(1, &apos;a&apos;), f(2, &apos;b&apos;), f(3, &apos;c&apos;)]
```   
</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="assoc"><a href="#assoc" class="headerlink" title="assoc"></a>assoc</h5><pre><code>定义：浅复制对象，然后设置或覆盖对象的指定属性。
```   
R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); {a: 1, b: 2, c: 3}
```       
</code></pre><h5 id="assocPath"><a href="#assocPath" class="headerlink" title="assocPath"></a>assocPath</h5><pre><code>定义：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。
```   
R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); // {a: {b: {c: 42}}}
```       
</code></pre><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><pre><code>定义：深复制。其值可能（嵌套）包含 Array、Object、Number、String、Boolean、Date 类型的数据。Function 通过引用复制。
```   
var objects = [{}, {}, {}];
var objectsClone = R.clone(objects);
objects === objectsClone; // true
```           
</code></pre><h5 id="dissoc"><a href="#dissoc" class="headerlink" title="dissoc"></a>dissoc</h5><pre><code>定义：删除对象中指定 prop 属性。
```   
R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); // {a: 1, c: 3}
```           
</code></pre><h5 id="dissocPath"><a href="#dissocPath" class="headerlink" title="dissocPath"></a>dissocPath</h5><pre><code>定义：浅复制对象，删除返回对象中指定路径上的属性。
```   
R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); // {a: {b: {}}}
```       
</code></pre><h5 id="eqProps"><a href="#eqProps" class="headerlink" title="eqProps"></a>eqProps</h5><pre><code>定义：判断两个对象指定的属性值是否相等。通过 R.equals 函数进行相等性判断。可用作柯里化的 predicate 。
```   
var o1 = {a: 1, b: 2, c: 3, d: 4};
var o2 = {a: 10, b: 20, c: 3, d: 40};
R.eqProps(&apos;a&apos;, o1, o2); // false
```       
</code></pre><h5 id="evolve"><a href="#evolve" class="headerlink" title="evolve"></a>evolve</h5><pre><code>定义：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。所有非原始类型属性都通过引用来复制。
如果某个 transformation 函数对应的键在被变换的 object 中不存在，那么该方法将不会执行。
```   
var tomato  = {firstName: &apos;  Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123};
var transformations = {
    firstName: R.trim,
    lastName: R.trim, // Will not get invoked
    data: {elapsed: R.add(1), remaining: R.add(-1)}
};
R.evolve(transformations, tomato); // {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123}
```       
</code></pre><h5 id="forEachObjIndexed"><a href="#forEachObjIndexed" class="headerlink" title="forEachObjIndexed"></a>forEachObjIndexed</h5><pre><code>定义：遍历 object，对 object 中的每对 key 和 value 执行方法 fn。
fn 接收三个参数: (value, key, obj).
```   
var printKeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value);
R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=&gt; {x: 1, y: 2}
```       
</code></pre><h5 id="has"><a href="#has" class="headerlink" title="has"></a>has</h5><pre><code>定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。
```   
R.has(&apos;name&apos;)({name: &apos;fanerge&apos;}); // true
```       
</code></pre><h5 id="hasIn"><a href="#hasIn" class="headerlink" title="hasIn"></a>hasIn</h5><pre><code>定义：如果对象自身或原型链上含有指定的属性，则返回 true；否则返回 false。
```   
var Rect = function (w, h) {
    this.width = w;
    this.height = h;
};
Rect.prototype.area = function (){
    return this.width * this.heigth;
};
var rect1 = new Rect(100, 200);
R.hasIn(&apos;area&apos;)(rect1); // true
```       
</code></pre><h5 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h5><pre><code>定义：与 R.invertObj 类似，但会将值放入数组中，来处理一个键对应多个值的情况。
```   
var raceResultsByFirstName = {
  first: &apos;alice&apos;,
  second: &apos;jake&apos;,
  third: &apos;alice&apos;,
};
R.invert(raceResultsByFirstName);
//=&gt; { &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] }
```       
</code></pre><h5 id="invertObj"><a href="#invertObj" class="headerlink" title="invertObj"></a>invertObj</h5><pre><code>定义：将对象的键、值交换位置：值作为键，对应的键作为值。交换后的键会被强制转换为字符串。注意，如果原对象同一值对应多个键，采用最后遍历到的键。
```   
var raceResults = {
  first: &apos;alice&apos;,
  second: &apos;jake&apos;
};
R.invertObj(raceResults);
//=&gt; { &apos;alice&apos;: &apos;first&apos;, &apos;jake&apos;:&apos;second&apos; }
```       
</code></pre><h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><pre><code>定义：返回给定对象所有可枚举的、自身属性的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.keys({a: 1, b: 2, c: 3}); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
```       
</code></pre><h5 id="keysIn"><a href="#keysIn" class="headerlink" title="keysIn"></a>keysIn</h5><pre><code>定义：返回给定对象所有属性（包括 prototype 属性）的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function () { this.x = &apos;X&apos; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.keysIn(f); // [&apos;x&apos;, &apos;y&apos;]
```       
</code></pre><h5 id="lens"><a href="#lens" class="headerlink" title="lens"></a>lens</h5><pre><code>定义：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。
setter 不会改变原数据。
```   
var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));
R.view(xLens, {x: 1, y: 2}); // 1
R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2}
R.over(xLens, R.negate, {x: 1, y: 2}); // {x: -1, y: 2}
```       
</code></pre><h5 id="lensIndex"><a href="#lensIndex" class="headerlink" title="lensIndex"></a>lensIndex</h5><pre><code>定义：返回聚焦到指定索引的 lens。
```   
var headLens = R.lensIndex(0);
R.view(headLens, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // a
R.set(headLens, &apos;x&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;x&apos;, &apos;b&apos;, &apos;c&apos;]
R.over(headLens, R.toUpper, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]
```       
</code></pre><h5 id="lensPath"><a href="#lensPath" class="headerlink" title="lensPath"></a>lensPath</h5><pre><code>定义：返回聚焦到指定路径的 lens。
```   
var xHeadYLens = R.lensPath([&apos;x&apos;, 0, &apos;y&apos;]);
R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // 2
R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
```       
</code></pre><h5 id="lensProp"><a href="#lensProp" class="headerlink" title="lensProp"></a>lensProp</h5><pre><code>定义：返回聚焦到指定属性的 lens。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.view(xLens, {x: 1, y: 2});            //=&gt; 1
R.set(xLens, 4, {x: 1, y: 2});          //=&gt; {x: 4, y: 2}
R.over(xLens, R.negate, {x: 1, y: 2});  //=&gt; {x: -1, y: 2}
```       
</code></pre><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。
```   
R.merge({&apos;name&apos;: &apos;fanerge&apos;, &apos;age&apos;: 10}, {age: 30}); // {&apos;name&apos;: &apos;fanerge&apos;, age: 30}
```   
</code></pre><h5 id="mergaDeepLeft"><a href="#mergaDeepLeft" class="headerlink" title="mergaDeepLeft"></a>mergaDeepLeft</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个值都是对象，则继续递归合并这两个值。
否则，采用第一个对象的值。
```   
R.mergeDeepLeft({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }},
            { age: 40, contact: { email: &apos;baa@example.com&apos; }});
// { name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }}
```   
</code></pre><h5 id="mergaDeepRight"><a href="#mergaDeepRight" class="headerlink" title="mergaDeepRight"></a>mergaDeepRight</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个值都是对象，则继续递归合并这两个值。
否则，采用第二个对象的值。
```   
R.mergeDeepRight({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }},
             { age: 40, contact: { email: &apos;baa@example.com&apos; }});
// { name: &apos;fred&apos;, age: 40, contact: { email: &apos;baa@example.com&apos; }}
```   
</code></pre><h5 id="mergaDeepWith"><a href="#mergaDeepWith" class="headerlink" title="mergaDeepWith"></a>mergaDeepWith</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个关联的值都是对象，则继续递归合并这两个值。
否则，使用给定函数对两个值进行处理，并将返回值作为该 key 的新值。
如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。
```   
R.mergeDeepWith(R.concat,
            { a: true, c: { values: [10, 20] }},
            { b: true, c: { values: [15, 35] }});
// { a: true, b: true, c: { values: [10, 20, 15, 35] }}
```   
</code></pre><h5 id="mergeDeepWithKey"><a href="#mergeDeepWithKey" class="headerlink" title="mergeDeepWithKey"></a>mergeDeepWithKey</h5><pre><code>定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在：
并且两个关联的值都是对象，则继续递归合并这两个值。
否则，使用给定函数对该 key 和对应的两个值进行处理，并将返回值作为该 key 的新值。
如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。
```   
let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r
R.mergeDeepWithKey(concatValues,
                   { a: true, c: { thing: &apos;foo&apos;, values: [10, 20] }},
                   { b: true, c: { thing: &apos;bar&apos;, values: [15, 35] }});
// { a: true, b: true, c: { thing: &apos;bar&apos;, values: [10, 20, 15, 35] }}
```       
</code></pre><h5 id="mergeWith"><a href="#mergeWith" class="headerlink" title="mergeWith"></a>mergeWith</h5><pre><code>定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。
如果某个 key 在两个对象中都存在，则使用给定的函数对每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。
```   
R.mergeWith(R.concat, 
                {a: true, values: [10, 20]}, 
                {b: true, values: [15, 35]});
// {a: true, b: true, values: [10, 20, 15, 35]}
```       
</code></pre><h5 id="mergeWithKey"><a href="#mergeWithKey" class="headerlink" title="mergeWithKey"></a>mergeWithKey</h5><pre><code>定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。
如果某个 key 在两个对象中都存在，则使用给定的函数对该 key 和每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。
```   
let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r
R.mergeWithKey(concatValues,
               { a: true, thing: &apos;foo&apos;, values: [10, 20] },
               { b: true, thing: &apos;bar&apos;, values: [15, 35] });
// { a: true, b: true, thing: &apos;bar&apos;, values: [10, 20, 15, 35] }
```       
</code></pre><h5 id="objOf"><a href="#objOf" class="headerlink" title="objOf"></a>objOf</h5><pre><code>定义：创建一个包含单个键值对的对象。
```   
var matchPhrases = R.compose(
    R.objOf(&apos;must&apos;),
    R.map(R.objOf(&apos;match_phrase&apos;))
);
matchPhrases([&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; {must: [{match_phrase: &apos;foo&apos;}, {match_phrase: &apos;bar&apos;}, {match_phrase: &apos;baz&apos;}]}
```   
</code></pre><h5 id="omit"><a href="#omit" class="headerlink" title="omit"></a>omit</h5><pre><code>定义：删除对象中给定的 keys 对应的属性。
```   
R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {b: 2, c: 3}
```       
</code></pre><h5 id="over"><a href="#over" class="headerlink" title="over"></a>over</h5><pre><code>定义：对数据结构中被 lens 聚焦的部分进行函数变换。
```   
var headLens = R.lensIndex(0);
R.over(headLens, R.toUpper, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); // [&apos;FOO&apos;, &apos;bar&apos;, &apos;baz&apos;]
```       
</code></pre><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><pre><code>定义：取出给定路径上的值。
```   
R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2
```       
</code></pre><h5 id="pathOr"><a href="#pathOr" class="headerlink" title="pathOr"></a>pathOr</h5><pre><code>定义：如果非空对象在给定路径上存在值，则将该值返回；否则返回给定的默认值。
```   
R.pathOr(&apos;N/A&apos;, [&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2
```       
</code></pre><h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。
```   
R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4}
```       
</code></pre><h5 id="pickAll"><a href="#pickAll" class="headerlink" title="pickAll"></a>pickAll</h5><pre><code>定义：与 pick 类似，但 pickAll 会将不存在的属性以 key: undefined 键值对的形式返回。
```   
R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;e&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4, e: undefined}
```       
</code></pre><h5 id="pickBy"><a href="#pickBy" class="headerlink" title="pickBy"></a>pickBy</h5><pre><code>定义：返回对象的部分拷贝，其中仅包含 key 满足 predicate 的属性。
```   
var isUpperCase = (val, key) =&gt; key.toUpperCase() === key;
R.pickBy(isUpperCase, {a: 1,b: 2, A: 3, B: 4}); // {A: 3, B: 4}
```       
</code></pre><h5 id="project"><a href="#project" class="headerlink" title="project"></a>project</h5><pre><code>定义：模拟 SQL 中的 select 语句。
```   
var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2};
var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7};
var kids = [abby, fred];
R.project([&apos;name&apos;, &apos;grade&apos;], kids); // [{name: &apos;Abby&apos;, grade: 2}, {name: &apos;Fred&apos;, grade: 7}]
```   
</code></pre><h5 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h5><pre><code>定义：取出对象中指定属性的值。如果不存在，则返回 undefined。
```   
R.prop(&apos;x&apos;, {x: 100}); // 100
```   
</code></pre><h5 id="propOr"><a href="#propOr" class="headerlink" title="propOr"></a>propOr</h5><pre><code>定义：对于给定的非空对象，如果指定属性存在，则返回该属性值；否则返回给定的默认值。
```   
var alice = {
  name: &apos;ALICE&apos;,
  age: 101
};
var favorite = R.prop(&apos;favoriteLibrary&apos;);
var favoriteWithDefault = R.propOr(&apos;Ramda&apos;, &apos;favoriteLibrary&apos;);

favorite(alice);  // undefined
favoriteWithDefault(alice);  // &apos;Ramda&apos;
```   
</code></pre><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><pre><code>定义：返回 prop 的数组：输入为 keys 数组，输出为对应的 values 数组。values 数组的顺序与 keys 的相同。
```   
R.props([&apos;x&apos;, &apos;y&apos;], {x: 1, y: 2}); // [1, 2]
```   
</code></pre><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><pre><code>定义：通过 lens 对数据结构聚焦的部分进行设置。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2}
```   
</code></pre><h5 id="toPairs"><a href="#toPairs" class="headerlink" title="toPairs"></a>toPairs</h5><pre><code>定义：将一个对象的属性转换成键、值二元组类型的数组，只处理对象自身的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.toPairs({a: 1, b: 2, c: 3}); // [[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]
```       
</code></pre><h5 id="toPairsIn"><a href="#toPairsIn" class="headerlink" title="toPairsIn"></a>toPairsIn</h5><pre><code>定义：将一个对象的属性转换成键、值二元组类型的数组，包括原型链上的属性。注意，不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function () { this.x = &apos;X&apos;; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.toPairsIn(f); // [[&apos;x&apos;,&apos;X&apos;], [&apos;y&apos;,&apos;Y&apos;]]
```       
</code></pre><h5 id="values"><a href="#values" class="headerlink" title="values"></a>values</h5><pre><code>定义：返回对象所有自身可枚举的属性的值。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
R.values({a: 1, b: 2, c: 3}); //=&gt; [1, 2, 3]
```       
</code></pre><h5 id="valuesIn"><a href="#valuesIn" class="headerlink" title="valuesIn"></a>valuesIn</h5><pre><code>定义：返回对象所有属性的值，包括原型链上的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。
```   
var F = function() { this.x = &apos;X&apos;; };
F.prototype.y = &apos;Y&apos;;
var f = new F();
R.valuesIn(f); //=&gt; [&apos;X&apos;, &apos;Y&apos;]
```       
</code></pre><h5 id="view"><a href="#view" class="headerlink" title="view"></a>view</h5><pre><code>定义：返回数据结构中，lens 聚焦的部分。lens 的焦点决定了数据结构中的哪部分是可见的。
```   
var xLens = R.lensProp(&apos;x&apos;);
R.view(xLens, {x: 1, y: 2});  //=&gt; 1
```       
</code></pre><h5 id="where"><a href="#where" class="headerlink" title="where"></a>where</h5><pre><code>定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。测试规范对象的每个属性值都必须是 predicate 。
每个 predicate 作用于待检测对象对应的属性值，如果所有 predicate 都返回 true，则 where 返回 true，否则返回 false 。
where 非常适合于需要声明式表示约束的函数，比如 filter 和 find 。
```   
var pred = R.where({
  a: R.equals(&apos;foo&apos;),
  b: R.complement(R.equals(&apos;bar&apos;)),
  x: R.gt(R.__, 10),
  y: R.lt(R.__, 20)
});

pred({a: &apos;foo&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; true
pred({a: &apos;xxx&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; false
```       
</code></pre><h5 id="whereEq"><a href="#whereEq" class="headerlink" title="whereEq"></a>whereEq</h5><pre><code>定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。
如果对于每一个测试规范对象的属性值，待检测对象中都有一个对应的相同属性值，则 where 返回 true，否则返回 false 。
whereEq 是 where 的一种特殊形式。
```   
var pred = R.whereEq({a: 1, b: 2});
pred({a: 1});              //=&gt; false
pred({a: 1, b: 2});        //=&gt; true
```       
</code></pre><h4 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h4><h5 id="allPass"><a href="#allPass" class="headerlink" title="allPass"></a>allPass</h5><pre><code>定义：传入包含多个 predicate 的列表，返回一个 predicate：如果给定的参数满足列表中的所有 predicate ，则返回 true。
该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。
```   
var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;);
var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;);
var isQueenOfSpades = R.allPass([isQueen, isSpade]);
isQueenOfSpades({rank: &apos;Q&apos;, suit: &apos;??&apos;}); // true
```   
</code></pre><h5 id="anyPass"><a href="#anyPass" class="headerlink" title="anyPass"></a>anyPass</h5><pre><code>定义：传入包含多个 predicate 的列表，返回一个 predicate：只要给定的参数满足列表中的一个 predicate ，就返回 true。
该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。
```   
var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;);
var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;);
var isQueenOfSpades = R.anyPass([isQueen, isSpade]);
isQueenOfSpades({rank: &apos;K&apos;, suit: &apos;??&apos;}); // true
```   
</code></pre><h5 id="and（针对于值）"><a href="#and（针对于值）" class="headerlink" title="and（针对于值）"></a>and（针对于值）</h5><pre><code>定义：如果两个参数都是 true，则返回 true；否则返回 false。相当于且（&amp;&amp;）
```   
R.and(true, true); // true
```           
</code></pre><h5 id="or（针对于值）"><a href="#or（针对于值）" class="headerlink" title="or（针对于值）"></a>or（针对于值）</h5><pre><code>定义：逻辑或运算，只要有一个参数为 truth-y，就返回 true；否则返回 false。
```   
R.or(true, true); // true
```   
</code></pre><h5 id="not（针对于值）"><a href="#not（针对于值）" class="headerlink" title="not（针对于值）"></a>not（针对于值）</h5><pre><code>定义：逻辑非运算。 当传入参数为 false-y 值时，返回 true；truth-y 值时，返回 false。
```   
R.not(true); // false
```   
</code></pre><h5 id="both（针对于函数）"><a href="#both（针对于函数）" class="headerlink" title="both（针对于函数）"></a>both（针对于函数）</h5><pre><code>定义：该函数调用两个函数，并对两函数返回值进行与操作。若第一个函数结果为 false-y 值 (false, null, 0 等)，则返回该结果，否则返回第二个函数的结果。注意，both 为短路操作，即如果第一个函数返回 false-y 值，则不会调用第二个函数。
```   
var gt10 = R.gt(R.__, 10);
var lt20 = R.lt(R.__, 20);
var f = R.both(gt10, lt20);
f(15); // true
```           
</code></pre><h5 id="either（针对于函数）"><a href="#either（针对于函数）" class="headerlink" title="either（针对于函数）"></a>either（针对于函数）</h5><pre><code>定义：返回由 || 运算符连接的两个函数的包装函数。如果两个函数中任一函数的执行结果为 truth-y，则返回其执行结果。 注意，这个是短路表达式，意味着如果第一个函数返回 truth-y 值的话，第二个函数将不会执行。
```   
var gt10 = x =&gt; x &gt; 10;
var even = x =&gt; x % 2 === 0;
var f = R.either(gt10, even);
f(101); // true
```   
</code></pre><h5 id="complement（针对于函数）"><a href="#complement（针对于函数）" class="headerlink" title="complement（针对于函数）"></a>complement（针对于函数）</h5><pre><code>定义：对函数的返回值取反。接受一个函数 f，返回一个新函数 g：在输入参数相同的情况下，若 f 返回 &apos;true-y&apos; ，则 g 返回 false-y ，反之亦然。
```   
var isNotNil = R.complement(R.isNil);
isNotNil(null); // true
```       
</code></pre><h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><pre><code>定义：返回一个封装了 if / else，if / else if/ else逻辑的函数 fn。 R.cond 接受列表元素为 [predicate，transformer] 的列表。 
fn 的所有参数顺次作用于每个 predicate，直到有一个返回 &quot;truthy&quot; 值，此时相应 transformer 对参数处理，并作为 fn 的结果返回。
如果没有 predicate 匹配，则 fn 返回 undefined。
```   
var fn = R.cond([
    [R.equals(0), R.always(&apos;water freezes at 0&apos;)],
    [R.equals(100), R.always(&apos;water freezes at 100&apos;)],
    [R.T, temp =&gt; `nothing special happens at ${temp}`],
]);
fn(3); // nothing special happens at 3
```       
</code></pre><h5 id="defaultTo"><a href="#defaultTo" class="headerlink" title="defaultTo"></a>defaultTo</h5><pre><code>定义：如果第二个参数不是 null、undefined 或 NaN，则返回第二个参数，否则返回第一个参数（默认值）。
```   
var defaultTo42 = R.defaultTo(42);
defaultTo42(undefined); // 42 
defaultTo42(13); // 13 
```       
</code></pre><h5 id="ifElse"><a href="#ifElse" class="headerlink" title="ifElse"></a>ifElse</h5><pre><code>定义：根据 condition predicate 的返回值调用 onTrue 或 onFalse 函数。
```   
var inCount = R.ifElse(
    R.has(&apos;count&apos;),
    R.over(R.lensProp(&apos;count&apos;), R.inc),
    R.assoc(&apos;count&apos;, 1)
);
incCount({});           //=&gt; { count: 1 }
incCount({ count: 1 }); //=&gt; { count: 2 }
```       
</code></pre><h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h5><pre><code>定义：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。
```   
R.isEmpty([1, 2, 3]); // false
R.isEmpty(&apos;&apos;); // true
```   
</code></pre><h5 id="pathSatisfies"><a href="#pathSatisfies" class="headerlink" title="pathSatisfies"></a>pathSatisfies</h5><pre><code>定义：如果对象的给定路径上的属性满足 predicate，返回 ture；否则返回 false。
```   
R.pathSatisfies(y =&gt; y &gt; 0, [&apos;x&apos;, &apos;y&apos;], {x: {y: 2}}); // true
```   
</code></pre><h5 id="propSatisfies"><a href="#propSatisfies" class="headerlink" title="propSatisfies"></a>propSatisfies</h5><pre><code>定义：如果指定的对象属性满足 predicate，返回 true；否则返回 false。
```   
R.propSatisfies(x =&gt; x &gt; 0, &apos;x&apos;, {x: 1, y: 2}); // true
```   
</code></pre><h5 id="unless"><a href="#unless" class="headerlink" title="unless"></a>unless</h5><pre><code>定义：判断输入值是否满足 predicate，若不符合，则将输入值传给 whenFalseFn 处理，并将处理结果作为返回；若符合，则将输入值原样返回。
```   
let safeInc = R.unless(R.isNil, R.inc);
safeInc(null); //=&gt; null
safeInc(1); //=&gt; 2
```   
</code></pre><h5 id="until"><a href="#until" class="headerlink" title="until"></a>until</h5><pre><code>定义：接受一个 predicate ，transform function 和 初始值，返回一个与初始值相同类型的值。
对输入值进行 transform ，直到 transform 的结果满足 predicate，此时返回这个满足 predicate 的值。
```   
R.until(R.gt(R.__, 100), R.multiply(2))(1); // 128
```   
</code></pre><h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><pre><code>定义：判断输入值是否满足 predicate，若符合，则将输入值传给 whenTrueFn 处理，并将处理结果作为返回；若不符合，则将输入值原样返回。
```   
var truncate = R.when(
  R.propSatisfies(R.gt(R.__, 10), &apos;length&apos;),
  R.pipe(R.take(10), R.append(&apos;…&apos;), R.join(&apos;&apos;))
);
truncate(&apos;12345&apos;);         // &apos;12345&apos;
truncate(&apos;0123456789ABC&apos;); // &apos;0123456789…&apos;
```   
</code></pre><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><h5 id><a href="#" class="headerlink" title="__"></a>__</h5><pre><code>定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。
```   
假设 g 代表柯里化的三元函数
g(1, 2, 3)
g(R.__, 2, 3)(1)
g(R.__, R__, 3)(1)(2)
g(R.__, 2, R.__)(1)(3)
g(R.__, 2)(R.__, 3)(1)
// 这些函数都是等价的。
var greet = R.replace(&apos;{name}&apos;, R.__, &apos;Hello, {name}!&apos;);
greet(&apos;Fanerge&apos;); // Hello, Fanerge
```       
</code></pre><h5 id="addIndex"><a href="#addIndex" class="headerlink" title="addIndex"></a>addIndex</h5><pre><code>定义：通过向列表迭代函数的回调函数添加两个新的参数：当前索引、整个列表，创建新的列表迭代函数。
```   
var mapIndexed = R.addIndex(R.map);
mapIndexed((val, idx) =&gt; {idx + &apos;-&apos; + val}, [&apos;f&apos;, &apos;a&apos;, &apos;n&apos;]); // [&apos;0-f&apos;, &apos;1-a&apos;, &apos;2-n&apos;]
```   
</code></pre><h5 id="always"><a href="#always" class="headerlink" title="always"></a>always</h5><pre><code>定义：返回一个返回恒定值的函数。注意，对于非原始值，返回的值是对原始值的引用。
```   
var t = R.always(&apos;Tee&apos;);
t(); // Tee
```   
</code></pre><h5 id="ap"><a href="#ap" class="headerlink" title="ap"></a>ap</h5><pre><code>定义：将函数列表作用于值列表上。
```   
R.ap([R.multiply(2), R.add(3)], [1, 2, 3]); // [2, 4, 6, 4, 5, 6]
```   
</code></pre><h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><pre><code>定义：将函数 fn 作用于参数列表 args。apply 可以将变参函数转换为为定参函数。如果上下文很重要，则 fn 应该绑定其上下文。
```   
var nums = [1, 2, 3, -99, 42, 6, 7];
R.apply(Math.max, nums); // 42
```   
</code></pre><h5 id="applySpec"><a href="#applySpec" class="headerlink" title="applySpec"></a>applySpec</h5><pre><code>定义：接受一个属性值为函数的对象，返回一个能生成相同结构对象的函数。返回的函数使用传入的参数调用对象的每个属性位对应的函数，来生成相应属性的值。
```   
var getMetrics = R.applySpec({    
    sum: R.add,
    nested: { mul: R.multiply }
});
getMetrics(2, 4); // {sum: 6, nested: { mul: 8 }}
```   
</code></pre><h5 id="ascend"><a href="#ascend" class="headerlink" title="ascend"></a>ascend</h5><pre><code>定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个升序比较函数。
```   
var byAge = R.ascend(R.prop(&apos;age&apos;));
var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}];
var peopleByYoungestFirst = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}]
```       
</code></pre><h5 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h5><pre><code>定义：将任意元函数封装为二元函数（只接受2个参数）中。任何额外的参数都不会传递给被封装的函数。
```   
var takesThreeArgs = function (a, b, c){
    return [a, b, c];
};
vat takeTwoArgs = R.binary(takesThreeArgs);
// takeTwoArgs.length; // 2
takeTwoArgs(1, 2, 3); // [1, 2, undefined]
```           
</code></pre><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><pre><code>定义：创建一个绑定了上下文的函数。
注意：与 Function.prototype.bind 不同，R.bind 不会绑定额外参数。
```   
var log = R.bind(console.log, console);
log(1); // 1
```   
</code></pre><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><pre><code>定义：提取第一个参数作为函数，其余参数作为刚提取的函数的参数，调用该函数并将结果返回。
```   
R.call(R.add, 1, 2); // 3
```       
</code></pre><h5 id="comparator"><a href="#comparator" class="headerlink" title="comparator"></a>comparator</h5><pre><code>定义：由首个参数是否小于第二个参数的判断函数，生成一个比较函数。
```   
var byAge = R.comparator((a, b) =&gt; a.age &lt; b.age);
var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}];
var peopleByIncreasingAge = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}]
```       
</code></pre><h5 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h5><pre><code>定义：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
```   
R.compose(R.add(1), R.multiply(2))(3); // 7
```           
</code></pre><h5 id="composeK"><a href="#composeK" class="headerlink" title="composeK"></a>composeK</h5><pre><code>定义：接受一系列函数，返回从右向左的 Kleisli 组合，每个函数必须返回支持 chain 操作的值。
```   
R.composeK(h, g, f) 等同于 R.compose(R.chain(h)，R.chain(g)，R.chain(f))。
```       
</code></pre><h5 id="composeP"><a href="#composeP" class="headerlink" title="composeP"></a>composeP</h5><pre><code>定义： 从右向左执行返回 Promise 的函数的组合。最右边的函数可以是任意元函数（参数个数不限）; 其余函数必须是一元函数。
```   
var db = {
      users: {
            JOE: {
              name: &apos;Joe&apos;,
              followers: [&apos;STEVE&apos;, &apos;SUZY&apos;]
            }
      }
};
var lookupUser = (userId) =&gt; Promise.resolve(db.users[userId]);
var lookupFollowers = (user) =&gt; Promise.resolve(user.followers);
lookupUser(&apos;JOE&apos;).then(lookupFollowers);
var followersForUser = R.composeP(lookupFollowers, lookupUser);
followersForUser(&apos;JOE&apos;).then(followers =&gt; console.log(&apos;Followers:&apos;, followers)) // [&quot;STEVE&quot;,&quot;SUZY&quot;]
```   
</code></pre><h5 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h5><pre><code>定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。
```   
// constructor function
function Animal (kind) {
    this.kind = kind;
}
Animal.prototype.sighting = function () {
    return `it&apos;s a ${this.kind}!`;
};
var AnimalConstructor = R.construct(Animal);
console.log(AnimalConstructor(&apos;PIG&apos;)); // {&quot;kind&quot;:&quot;PIG&quot;}
```   
</code></pre><h5 id="constructN"><a href="#constructN" class="headerlink" title="constructN"></a>constructN</h5><pre><code>定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。为了能够使用变参的构造函数，返回函数的元数需要明确指定。
```   
function Salad() {
  this.ingredients = arguments;
};
Salad.prototype.recipe = function() {
  var instructions = R.map((ingredient) =&gt; (
    &apos;Add a whollop of &apos; + ingredient, this.ingredients)
  )
  return R.join(&apos;\n&apos;, instructions)
}

var ThreeLayerSalad = R.constructN(3, Salad)

// Notice we no longer need the &apos;new&apos; keyword, and the constructor is curried for 3 arguments.
var salad = ThreeLayerSalad(&apos;Mayonnaise&apos;)(&apos;Potato Chips&apos;)(&apos;Ketchup&apos;)
console.log(salad.recipe());
// Add a whollop of Mayonnaise
// Add a whollop of Potato Chips
// Add a whollop of Potato Ketchup
```   
</code></pre><h5 id="converge"><a href="#converge" class="headerlink" title="converge"></a>converge</h5><pre><code>定义：接受一个 converging 函数和一个分支函数列表，返回一个新函数。
当被调用时，新函数接受参数，并将这些参数转发给每个分支函数；然后将每个分支函数的计算结果作为参数传递给 converging 函数，converging 函数的计算结果即新函数的返回值。
```   
var average = R.converge(R.divide, [R.sum, R.length]);
average([1, 2, 3, 4, 5, 6, 7]); // 4
```   
</code></pre><h5 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h5><pre><code>定义：对函数进行柯里化。柯里化函数与其他语言中的柯里化函数相比，有两个非常好的特性：
1.参数不需要一次只传入一个。 
    g(1)(2)(3) === g(1, 2, 3)
2.占位符值 R.__ 可用于标记暂未传入参数的位置。允许部分应用于任何参数组合，而无需关心它们的位置和顺序。
    F(1, 2, 3) === F(R.__, 2, 3)(1) === F(R.__, 3)(1)(2)
```   
var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d;
var curriedAddFourNumbers = R.curry(addFourNumbers);
var f = curriedAddFourNumbers(1); // 返回剩余三个参数的函数
f(2, 3, 4); // 10(当参数全部传入，才返回结果)
```   
</code></pre><h5 id="curryN"><a href="#curryN" class="headerlink" title="curryN"></a>curryN</h5><pre><code>定义：对函数进行柯里化，并限制柯里化函数的元数。
```   
var sumArgs = (...args) =&gt; R.sum(args);
var curriedFourNumbers = R.curryN(5, sumArgs);
var f = curriedAddFourNumbers(1, 2);
var g = f(3, 4, 5); // 15
```       
</code></pre><h5 id="descend"><a href="#descend" class="headerlink" title="descend"></a>descend</h5><pre><code>定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个降序比较函数。
```   
var byAge = R.descend(R.prop(&apos;age&apos;));
var people = [

];
var peopleByOldFirst = R.sort(byAge, people);
```       
</code></pre><h5 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h5><pre><code>定义：根据传入参数的类型返回其对应的空值。
Ramda 定义了各类型的空值如下：Array ([])，Object ({})，String (&apos;&apos;)，和 Arguments。empty 还支持其它定义了 &lt;Type&gt;.empty 和/或 &lt;Type&gt;.prototype.empty 的类型。
```   
R.empty(Just(42)); // Noting()
R.empty([1, 2]); // []
```       
</code></pre><h5 id="F"><a href="#F" class="headerlink" title="F"></a>F</h5><pre><code>定义：恒定返回 false 的函数。忽略所有的输入参数。
```   
R.F(); // false
```       
</code></pre><h5 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h5><pre><code>定义：交换函数前两个参数的位置。
```   
var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);
mergeThree(1, 2, 3); // [1, 2, 3]
R.flip(mergeThree)(1, 2, 3); // [2, 1, 3]
```       
</code></pre><h5 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h5><pre><code>定义：将输入值原样返回。适合用作默认或占位函数。
```   
R.identity(1); // 1
var obj = {};
R.identity(obj) === obj; // true
```       
</code></pre><h5 id="invoker"><a href="#invoker" class="headerlink" title="invoker"></a>invoker</h5><pre><code>定义：将具有指定元数（参数个数）的具名方法，转换为可以被给定参数和目标对象直接调用的函数。
返回的函数是柯里化的，它接收 arity + 1 个参数，其中最后一个参数是目标对象。
```   
var sliceFrom = R.invoker(1, &apos;slice&apos;);
sliceFrom(6, &apos;abcdefghijklm&apos;); //=&gt; &apos;ghijklm&apos;
```       
</code></pre><h5 id="juxt"><a href="#juxt" class="headerlink" title="juxt"></a>juxt</h5><pre><code>定义：juxt 将函数列表作用于值列表。
```   
var getRange = R.juxt([Math.min, Math.max]);
getRange(3, 4, 9, -3); // [-3, 9]
```       
</code></pre><h5 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h5><pre><code>定义：提升一个多元函数，使之能映射到列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。
```   
var madd3 = R.lift((a, b, c) =&gt; a + b + c);
madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]
```       
</code></pre><h5 id="liftN"><a href="#liftN" class="headerlink" title="liftN"></a>liftN</h5><pre><code>定义：将一个函数提升为指定元数的函数，使之能映射到多个列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。
```   
var madd3 = R.liftN(3, (...args) =&gt; R.sum(args));
madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]
```       
</code></pre><h5 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a>memoize</h5><pre><code>定义：memoize 方法可以缓存函数的计算结果。
创建一个新函数，被调用时，缓存特定参数对应的经 fn 计算的结果，并将结果返回。
此后如果用相同的参数调用缓存的 fn 时，直接返回该参数对应的缓存结果，不必再调用 fn。
```   
var count = 0;
const factorial = R.memoize(n =&gt; {
    count += 1;
    return R.product(R.range(1, n + 1));
});
factorial(5); // 120
factorial(5); // 120
count; // 1(只进行了一次运算)
```       
</code></pre><h5 id="memoizeWith"><a href="#memoizeWith" class="headerlink" title="memoizeWith"></a>memoizeWith</h5><pre><code>定义：R.memoize 的可定制版本。memoizeWith 需要一个额外的函数，该函数接受一个参数集，用于创建缓存的键值，在该缓存中会存储被缓存函数的结果。
注意，生成缓存键值时，要避免可能会错误地覆盖之前已缓存键值对的冲突。
```   
var count = 0;
const factorial = R.memoizeWith(R.identity, n =&gt; {
    count += 1;
    return R.product(R.range(1, n + 1));
});
factorial(5); // 120
factorial(5); // 120
count; // 1(只进行了一次运算)
```           
</code></pre><h5 id="nAry"><a href="#nAry" class="headerlink" title="nAry"></a>nAry</h5><pre><code>定义：将一个任意元（包括零元）的函数，封装成一个确定元数（参数个数）的函数。任何多余的参数都不会传入被封装的函数。
```   
var takesTwoArgs = (a, b) =&gt; [a, b];
takesTwoArgs.length; // 2
takesTwoArgs(1, 2); // [1, 2]
var takesOneArg = R.nAry(1, takeTwoArgs);
takesOneArg.length; // 1
takesOneArg(1, 2); // [1, undefined]
```       
</code></pre><h5 id="nthArg"><a href="#nthArg" class="headerlink" title="nthArg"></a>nthArg</h5><pre><code>定义：返回一个函数，该函数返回它的第 n 个参数。
```   
R.nthArg(1)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;); // b
```       
</code></pre><h5 id="o"><a href="#o" class="headerlink" title="o"></a>o</h5><pre><code>定义：o 是一个柯里化组合函数，返回一元函数。
类似于 compose，o 从右到左执行函数组合。但与 compose 不同的是，传递给 o 的最右边的函数为一元函数。
```   
R.o(R.multiply(10), R.add(10))(-4); // 60
```       
</code></pre><h5 id="of"><a href="#of" class="headerlink" title="of"></a>of</h5><pre><code>定义：将给定值作为元素，封装成单元素数组。
```   
R.of(42); // [42]
```       
</code></pre><h5 id="once"><a href="#once" class="headerlink" title="once"></a>once</h5><pre><code>定义：创建一个只能调用一次的函数。
将给定函数 fn 封装到新函数fn&apos;中，fn&apos; 确保 fn 只能调用一次。重复调用fn&apos; ，只会返回第一次执行时的结果。
```   
var addOneOnce = R.once(x =&gt; x + 1);
addOneOnce(10); // 11
addOneOnce(51); // 11
```       
</code></pre><h5 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h5><pre><code>定义：部分应用。
接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将初始参数和 g 的参数顺次传给 f，并返回 f 的执行结果。
```   
var multiply2 = (a, b) =&gt; a * b;
var double = R.partial(multiply2, [2]);
double(3); // 2*3=6
```       
</code></pre><h5 id="partialRight"><a href="#partialRight" class="headerlink" title="partialRight"></a>partialRight</h5><pre><code>定义：部分应用。
接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将 g 的参数和初始参数顺序传给 f，并返回 f 的执行结果。
```   
var multiply2 = (a, b) =&gt; a * b;
var double = R.partial(multiply2, [2]);
double(3); // 3*2=6
```       
</code></pre><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><pre><code>定义：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。
```   
var f = R.pipe(Math.pow, R.negate, R.inc);
f(3, 4); // -(3^4) + 1
```       
</code></pre><h5 id="pipeK"><a href="#pipeK" class="headerlink" title="pipeK"></a>pipeK</h5><pre><code>定义：将一系列函数，转换成从左到右的 Kleisli 组合，每个函数必须返回支持chain操作的值。
R.pipeK(f, g, h) 等价于 R.pipe(R.chain(f), R.chain(g), R.chain(h))。
```   
var getStateCode = R.pipeK(
  parseJson,
  get(&apos;user&apos;),
  get(&apos;address&apos;),
  get(&apos;state&apos;),
  R.compose(Maybe.of, R.toUpper)
);
getStateCode(&apos;{&quot;user&quot;:{&quot;address&quot;:{&quot;state&quot;:&quot;ny&quot;}}}&apos;);
// Just(&apos;NY&apos;)
```       
</code></pre><h5 id="pipeP"><a href="#pipeP" class="headerlink" title="pipeP"></a>pipeP</h5><pre><code>定义：从左往右执行返回 Promise 的函数的组合。最左边的函数可以是任意元函数（参数个数不限）；其余函数必须是一元函数。
```   
var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
```       
</code></pre><h5 id="T"><a href="#T" class="headerlink" title="T"></a>T</h5><pre><code>定义：恒定返回 true 的函数。忽略所有的输入参数。
```   
R.T(); // true
```       
</code></pre><h5 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h5><pre><code>定义：对输入的值执行给定的函数，然后返回输入的值。
```   
var sayX = x =&gt; console.log(&apos;x is &apos; + x);
R.tap(sayX, 100); // 100
```       
</code></pre><h5 id="tryCatch"><a href="#tryCatch" class="headerlink" title="tryCatch"></a>tryCatch</h5><pre><code>定义：tryCatch 接受两个函数：tryer 和 catcher，生成的函数执行 tryer，若未抛出异常，则返回执行结果。
若抛出异常，则执行 catcher，返回 catcher 的执行结果。注意，为了有效的组合该函数，tryer 和 catcher 应返回相同类型的值。
```   
R.tryCatch(R.prop(&apos;x&apos;), R.f)({x: true}); // true
```       
</code></pre><h5 id="unapply"><a href="#unapply" class="headerlink" title="unapply"></a>unapply</h5><pre><code>定义：输入一个只接收单个数组作为参数的函数，返回一个新函数：
接收任意个参数；
将参数组成数组传递给 fn ；
返回执行结果。
换言之，R.unapply 将一个使用数组作为参数的函数，变为一个不定参函数。 R.unapply 是 R.apply 的逆函数
```   
R.unapply(JSON.stringify, 1, 2, 3); // &apos;[1, 2, 3]&apos;
```   
</code></pre><h5 id="unary"><a href="#unary" class="headerlink" title="unary"></a>unary</h5><pre><code>定义：将任意元（包括零元）函数封装成一元函数。任何额外的参数都不会传递给被封装的函数。
```   
var takesTwoArgs = function(a, b) {
  return [a, b];
};
takesTwoArgs.length; //=&gt; 2
takesTwoArgs(1, 2); //=&gt; [1, 2]

var takesOneArg = R.unary(takesTwoArgs);
takesOneArg.length; //=&gt; 1
// 只有一个参数能被传递到函数当中
takesOneArg(1, 2); //=&gt; [1, undefined]
```   
</code></pre><h5 id="uncurryN"><a href="#uncurryN" class="headerlink" title="uncurryN"></a>uncurryN</h5><pre><code>定义：将一个柯里化的函数转换为一个 n 元函数。
```   
var addFour = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d;
var uncurriedAddFour = R.uncurryN(4, addFour);
uncurriedAddFour(1, 2, 3, 4); // 10
```   
</code></pre><h5 id="useWith"><a href="#useWith" class="headerlink" title="useWith"></a>useWith</h5><pre><code>定义：接受一个函数 fn 和一个 transformer 函数的列表，返回一个柯里化的新函数。
当被调用时，新函数将每个参数转发给对应位置的 transformer 函数，然后将每个 transformer 函数的计算结果作为参数传递给 fn，fn 的计算结果即新函数的返回值。
如果新函数传传入参数的数量比 transformer 函数的数量多，多出的参数会作为附加参数直接传给 fn 。
如果不需要处理多出的那部分参数，除了忽略之外，也可以用 identity 函数来作为 transformer ，以保证新函数的参数数量是确定的。
```   
R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=&gt; 81
```   
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><pre><code>定义：两数相加。
```   
R.add(2)(3); // 5
```   
</code></pre><h5 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h5><pre><code>定义：两数相除。等价于a / b。
```   
R.divide(71, 100); // 0.71
```   
</code></pre><h5 id="dec（相当于自减）"><a href="#dec（相当于自减）" class="headerlink" title="dec（相当于自减）"></a>dec（相当于自减）</h5><pre><code>定义：减一。与i--的区别为会生产一个新数据（不改变原有值）。
```   
R.dec(42); // 41
```   
</code></pre><h5 id="inc（相当于自加）"><a href="#inc（相当于自加）" class="headerlink" title="inc（相当于自加）"></a>inc（相当于自加）</h5><pre><code>定义：加1。
```   
R.inc(42); // 43
```       
</code></pre><h5 id="mathMod"><a href="#mathMod" class="headerlink" title="mathMod"></a>mathMod</h5><pre><code>定义：mathMod 和算术取模操作类似，而不像 % 操作符 （或 R.modulo）。所以 -17 % 5 等于 -2，而 mathMod(-17, 5) 等于 3 。
mathMod 要求参数为整型，并且当模数等于 0 或者负数时返回 NaN 。
```   
R.mathMod(-17, 5); // 3
R.mathMod(17, 5); // 2
```       
</code></pre><h5 id="mean"><a href="#mean" class="headerlink" title="mean"></a>mean</h5><pre><code>定义：返回给定数字列表的平均值。
```   
R.mean([2, 7, 9]); // 6
```       
</code></pre><h5 id="median"><a href="#median" class="headerlink" title="median"></a>median</h5><pre><code>定义：返回给定数字列表的中位数。
```   
R.median([2, 9, 7]); // 7
```       
</code></pre><h5 id="modulo"><a href="#modulo" class="headerlink" title="modulo"></a>modulo</h5><pre><code>定义：用第一个参数除以第二个参数，并返回余数。注意，该函数是 JavaScript-style 的求模操作。数学求模另见 mathMod。
```   
R.modulo(17, 3); // 2
R.modulo(-17, 3); // -2
```       
</code></pre><h5 id="multiply"><a href="#multiply" class="headerlink" title="multiply"></a>multiply</h5><pre><code>定义：两数相乘，等价于柯里化的 a * b 。
```   
R.multiply(2, 3); // 6
```   
</code></pre><h5 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h5><pre><code>定义：取反操作。
```   
R.negate(42); // -42
```   
</code></pre><h5 id="product"><a href="#product" class="headerlink" title="product"></a>product</h5><pre><code>定义：列表中的所有元素相乘。
```   
R.product([2, 3, 4]); // 24
```   
</code></pre><h5 id="subtract"><a href="#subtract" class="headerlink" title="subtract"></a>subtract</h5><pre><code>定义：首个参数减去第二个参数。
```   
R.subtract(1, 2); // -1
```   
</code></pre><h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><pre><code>定义：对数组中所有元素求和。
```   
R.sum([1, 2, 3]); // 6
```   
</code></pre><h4 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h4><h5 id="clamp"><a href="#clamp" class="headerlink" title="clamp"></a>clamp</h5><pre><code>定义：将数字限制在指定的范围内。
clamp 也可用于其他有序类型，如字符串和日期。
```   
R.clamp(1, 10, -5); // 1
R.clamp(1, 10, 4); // 4
```   
</code></pre><h5 id="countBy"><a href="#countBy" class="headerlink" title="countBy"></a>countBy</h5><pre><code>定义：根据给定函数提供的统计规则对列表中的元素进行分类计数。
返回一个对象，其键值对为：fn 根据列表元素生成键，列表中通过 fn 映射为对应键的元素的个数作为值。
注意，由于 JavaScript 对象的实现方式，所有键都被强制转换为字符串。
```   
var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
R.countBy(Math.floor, numbers); // {&apos;1&apos;: 3, &apos;2&apos;: 2, &apos;3&apos;: 1 }
```   
</code></pre><h5 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h5><pre><code>定义：求差集。求第一个列表中，未包含在第二个列表中的任一元素的集合。对象和数组比较数值相等，而非引用相等。
```   
R.difference([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [1, 2]
```   
</code></pre><h5 id="differenceWith"><a href="#differenceWith" class="headerlink" title="differenceWith"></a>differenceWith</h5><pre><code>定义：求第一个列表中未包含在第二个列表中的所有元素的集合（集合中没有重复元素）。
两列表中的元素通过 predicate 判断相应元素是否同时 “包含在” 两列表中。
```   
var cmp = (x, y) =&gt; x.a === y.a;
var l1 = [{a: 1}, {a: 2}, {a: 3}];
var l2 = [{a: 3}, {a: 4}];
R.differenceWith(cmp, l1, l2); // [{a: 1}, {a: 2}]
```   
</code></pre><h5 id="eqBy"><a href="#eqBy" class="headerlink" title="eqBy"></a>eqBy</h5><pre><code>定义：接受一个函数和两个值，通过传入函数对两个值进行相等性判断。如果两个值的计算结果相等，则返回 true ；否则返回 false 。
```   
R.eqBy(Math.abs, 5, -5); // true
```   
</code></pre><h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><pre><code>定义：如果传入的参数相等，返回 true；否则返回 false。可以处理几乎所有 JavaScript 支持的数据结构。
```   
R.equals(1, 1); // true
R.equals([&apos;1&apos;], [&apos;1&apos;]); // true
```   
</code></pre><h5 id="gt"><a href="#gt" class="headerlink" title="gt"></a>gt</h5><pre><code>定义：如果首个参数大于第二个参数，返回 true；否则返回 false。
```   
R.gt(2, 1); // true
```   
</code></pre><h5 id="gte"><a href="#gte" class="headerlink" title="gte"></a>gte</h5><pre><code>定义：如果首个参数大于等于第二个参数，返回 true；否则返回 false。
```   
R.gte(2, 1); // true
```   
</code></pre><h5 id="identical"><a href="#identical" class="headerlink" title="identical"></a>identical</h5><pre><code>定义：如果两个参数是完全相同，则返回 true，否则返回 false。
如果它们引用相同的内存，也认为是完全相同的。NaN 和 NaN 是完全相同的；0 和 -0 不是完全相同的。
```   
var o = {};
R.identical(o, o); //=&gt; true
R.identical(1, 1); //=&gt; true
```   
</code></pre><h5 id="innerJoin"><a href="#innerJoin" class="headerlink" title="innerJoin"></a>innerJoin</h5><pre><code>定义：接受一个 predicate pred 、列表 xs 和 ys ，返回列表 xs&apos;。
依次取出 xs 中的元素，若通过 pred 判断等于 ys 中的一个或多个元素，则放入 xs&apos; 。
pred 必须为二元函数，两个参数分别来自于对应两个列表中的元素。
```   
R.innerJoin(
  (record, id) =&gt; record.id === id,
  [{id: 824, name: &apos;Richie Furay&apos;},
   {id: 956, name: &apos;Dewey Martin&apos;},
   {id: 313, name: &apos;Bruce Palmer&apos;},
   {id: 456, name: &apos;Stephen Stills&apos;},
   {id: 177, name: &apos;Neil Young&apos;}],
  [177, 456, 999]
);
// [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}]
```   
</code></pre><h5 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h5><pre><code>定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。
```   
R.intersection([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [4, 3]
```   
</code></pre><h5 id="intersectionWith"><a href="#intersectionWith" class="headerlink" title="intersectionWith"></a>intersectionWith</h5><pre><code>定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。由给定的 predicate 进行相同性判断。
```   
var buffaloSpringfield = [
  {id: 824, name: &apos;Richie Furay&apos;},
  {id: 956, name: &apos;Dewey Martin&apos;},
  {id: 313, name: &apos;Bruce Palmer&apos;},
  {id: 456, name: &apos;Stephen Stills&apos;},
  {id: 177, name: &apos;Neil Young&apos;}
];
var csny = [
  {id: 204, name: &apos;David Crosby&apos;},
  {id: 456, name: &apos;Stephen Stills&apos;},
  {id: 539, name: &apos;Graham Nash&apos;},
  {id: 177, name: &apos;Neil Young&apos;}
];

var list = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield, csny);
//=&gt; [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}]
```   
</code></pre><h5 id="lt"><a href="#lt" class="headerlink" title="lt"></a>lt</h5><pre><code>定义：如果首个参数小于第二个参数，返回 true；否则返回 false。
```   
R.lt(2, 1); // false
R.lt(&apos;a&apos;, &apos;b&apos;); // true
```   
</code></pre><h5 id="lte"><a href="#lte" class="headerlink" title="lte"></a>lte</h5><pre><code>定义：如果首个参数小于或等于第二个参数，返回 true；否则返回 false。
```   
R.lt(2, 2); // false
R.lt(&apos;a&apos;, &apos;b&apos;); // true
```   
</code></pre><h5 id="max"><a href="#max" class="headerlink" title="max"></a>max</h5><pre><code>定义：返回两个参数中的较大值。
```   
R.max(789, 123); // 789
```   
</code></pre><h5 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h5><pre><code>定义：接收一个函数和两个值，返回使给定函数执行结果较大的值。
```   
var square = n =&gt; n * n;
R.maxBy(square, -3, 2); // -3
R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); // -5
```   
</code></pre><h5 id="min"><a href="#min" class="headerlink" title="min"></a>min</h5><pre><code>定义：返回两个参数中的较小值。
```   
R.min(789, 123); // 123
R.min(&apos;a&apos;, &apos;c&apos;); // a
```   
</code></pre><h5 id="minBy"><a href="#minBy" class="headerlink" title="minBy"></a>minBy</h5><pre><code>定义：接收一个函数和两个值，返回使给定函数执行结果较小的值。
```   
var square = n =&gt; n * n;
R.minBy(square, -3, 2); // 2
```   
</code></pre><h5 id="pathEq"><a href="#pathEq" class="headerlink" title="pathEq"></a>pathEq</h5><pre><code>定义：判断对象的嵌套路径上是否为给定的值，通过 R.equals 函数进行相等性判断。常用于列表过滤。
```   
var user1 = { address: { zipCode: 90210 } };
var user2 = { address: { zipCode: 55555 } };
var user3 = { name: &apos;Bob&apos; };
var users = [ user1, user2, user3 ];
var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 90210);
var list = R.filter(isFamous, users); // [{&quot;address&quot;:{&quot;zipCode&quot;:90210}}]
```   
</code></pre><h5 id="propEq"><a href="#propEq" class="headerlink" title="propEq"></a>propEq</h5><pre><code>定义：如果指定对象属性与给定的值相等，则返回 true ；否则返回 false 。通过 R.equals 函数进行相等性判断。
```   
var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;};
var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;};
var rusty = {name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;};
var alois = {name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;};
var kids = [abby, fred, rusty, alois];
var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;);
R.filter(hasBrownHair, kids); // [fred, rusty]
```   
</code></pre><h5 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h5><pre><code>定义：根据给定的函数对列表进行排序。
```   
var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop(&apos;name&apos;)));
var alice = {
  name: &apos;ALICE&apos;,
  age: 101
};
var bob = {
  name: &apos;Bob&apos;,
  age: -10
};
var clara = {
  name: &apos;clara&apos;,
  age: 314.159
};
var people = [clara, bob, alice];
sortByNameCaseInsensitive(people); //=&gt; [alice, bob, clara]
```   
</code></pre><h5 id="sortWith"><a href="#sortWith" class="headerlink" title="sortWith"></a>sortWith</h5><pre><code>定义：依据比较函数列表对输入列表进行排序。
```   
var alice = {
  name: &apos;alice&apos;,
  age: 40
};
var bob = {
  name: &apos;bob&apos;,
  age: 30
};
var clara = {
  name: &apos;clara&apos;,
  age: 40
};
var people = [clara, bob, alice];
var ageNameSort = R.sortWith([
  R.descend(R.prop(&apos;age&apos;)),
  R.ascend(R.prop(&apos;name&apos;))
]);
ageNameSort(people); //=&gt; [alice, clara, bob]
```   
</code></pre><h5 id="symmetricDifference"><a href="#symmetricDifference" class="headerlink" title="symmetricDifference"></a>symmetricDifference</h5><pre><code>定义：求对称差集。所有不属于两列表交集元素的集合，其元素在且仅在给定列表中的一个里面出现。
```   
R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=&gt; [1,2,7,6,5]
```   
</code></pre><h5 id="symmetricDifferenceWith"><a href="#symmetricDifferenceWith" class="headerlink" title="symmetricDifferenceWith"></a>symmetricDifferenceWith</h5><pre><code>定义：求对称差集。所有不属于两列表交集元素的集合。交集的元素由条件函数的返回值决定。
```   
var eqA = R.eqBy(R.prop(&apos;a&apos;));
var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
R.symmetricDifferenceWith(eqA, l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
```       
</code></pre><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><pre><code>定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。
```   
R.union([1, 2, 3], [2, 3, 4]); //=&gt; [1, 2, 3, 4]
```       
</code></pre><h5 id="unionWith"><a href="#unionWith" class="headerlink" title="unionWith"></a>unionWith</h5><pre><code>定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。由 predicate 的返回值决定两元素是否重复。
```   
var l1 = [{a: 1}, {a: 2}];
var l2 = [{a: 1}, {a: 4}];
R.unionWith(R.eqBy(R.prop(&apos;a&apos;)), l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 4}]
```       
</code></pre><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><h5 id="is"><a href="#is" class="headerlink" title="is"></a>is</h5><pre><code>定义：检测一个对象（val）是否是给定构造函数的实例。该函数会依次检测其原型链，如果存在的话。
```   
R.is(Object, {}); // true
```   
</code></pre><h5 id="isNil"><a href="#isNil" class="headerlink" title="isNil"></a>isNil</h5><pre><code>定义：检测输入值是否为 null 或 undefined 。
```   
R.isNil(null); // true
```   
</code></pre><h5 id="propIs"><a href="#propIs" class="headerlink" title="propIs"></a>propIs</h5><pre><code>定义：判断指定对象的属性是否为给定的数据类型，是则返回 true ；否则返回 false 。
```   
R.propIs(Number, &apos;x&apos;, {x: 1, y: 2}); // true
```   
</code></pre><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><pre><code>定义：用一个单词来描述输入值的（原生）类型，返回诸如 &apos;Object&apos;、&apos;Number&apos;、&apos;Array&apos;、&apos;Null&apos; 之类的结果。不区分用户自定义的类型，统一返回 &apos;Object&apos;。
```   
R.type([]); // Array
```   
</code></pre>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
</search>
