<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/page/2/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/page/2/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/12/排序算法-希尔排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/排序算法-希尔排序/" itemprop="url">
                  排序算法-希尔排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T15:06:49+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/排序算法-希尔排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/排序算法-希尔排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  783
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="希尔排序（Shell-Sort）的基础"><a href="#希尔排序（Shell-Sort）的基础" class="headerlink" title="希尔排序（Shell Sort）的基础"></a>希尔排序（Shell Sort）的基础</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<h1 id="实现希尔排序（n为待排序arr-length）"><a href="#实现希尔排序（n为待排序arr-length）" class="headerlink" title="实现希尔排序（n为待排序arr.length）"></a>实现希尔排序（n为待排序arr.length）</h1><h2 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h2><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p>
<p>该方法实质上是一种分组插入方法</p>
<p>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。<br>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>假设待排序文件有10个记录，其关键字分别是：<br>    592,401,874,141,348,72,911,887,820,283。<br>增量序列的取值依次为：n = 10, 则增量d1 = 10/2 = 5。<br>    5，2，1<br><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" alt="计算过程"><br>    算法时间复杂度：T(n) = O(n*logn^2)<br>    内排序(内存排序就够了)<br>    不稳定(排序后原始顺序无法保证)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function shellSort(array) &#123;</div><div class="line">	let arr = array.slice(),</div><div class="line">		len = arr.length;</div><div class="line">	for(var fraction = Math.floor(len/2); fraction &gt; 0; fraction = Math.floor(fraction/2))&#123;</div><div class="line">		// 这里实质上有进行了直接插入排序</div><div class="line">		for(var i = fraction; i &lt; len; i++)&#123;</div><div class="line">			for(var j = i - fraction; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[fraction + j]; j -= fraction)&#123;</div><div class="line">				var temp = arr[j];</div><div class="line">				arr[j] = arr[fraction + j];</div><div class="line">				arr[fraction + j] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr1 = [592,401,874,141,348,72,911,887,820,283];</div><div class="line">let arr2 = shellSort(arr1);</div><div class="line">console.log(arr1); // [592, 401, 874, 141, 348, 72, 911, 887, 820, 283]</div><div class="line">console.log(arr2); // [72, 141, 283, 348, 401, 592, 820, 874, 887, 911]</div></pre></td></tr></table></figure>
</code></pre><p>PS：首个增量一般取值为 Math.floor(arr.length/2),对每个分组进行直接插入排序。<br>    重复上面过程，知道增量为1时，整个数组恰被分成一组，算法便终止。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="external">基本算法学习(一)之希尔排序(JS)</a><br>    <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">希尔排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/12/Symbol总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/Symbol总结/" itemprop="url">
                  Symbol总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T11:31:07+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/Symbol总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/Symbol总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,020
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Symbol-基础"><a href="#Symbol-基础" class="headerlink" title="Symbol 基础"></a>Symbol 基础</h1><h2 id="Symbol-引入的原因"><a href="#Symbol-引入的原因" class="headerlink" title="Symbol 引入的原因"></a>Symbol 引入的原因</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。<br>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>语法：Symbol([description])<br>参数：description – 可选的，字符串。symbol的description可以用于调试，但无法访问到symbol本身。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol();</div><div class="line">let s2 = Symbol();</div><div class="line"></div><div class="line">s1 === s2 // false</div></pre></td></tr></table></figure>
</code></pre><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 这里作为对象的属性使用，独一无二</div><div class="line">let s1 = Symbol();</div><div class="line">let a = &#123;</div><div class="line">	[s1]: &apos;我是Symbol类型的&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(a[s1]);</div></pre></td></tr></table></figure>
</code></pre><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。<br><span style="color: red;">它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</span><br>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<h1 id="Symbol-for-key-，Symbol-keyFor-key"><a href="#Symbol-for-key-，Symbol-keyFor-key" class="headerlink" title="Symbol.for(key)，Symbol.keyFor(key)"></a>Symbol.for(key)，Symbol.keyFor(key)</h1><h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p>我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&apos;foo&apos;);</div><div class="line">let s2 = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">s1 === s2 // true</div></pre></td></tr></table></figure></p>
<pre><code>PS：上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。
    Symbol.for(key)与Symbol(desc)这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
</code></pre><h2 id="Symbol-keyFor-key"><a href="#Symbol-keyFor-key" class="headerlink" title="Symbol.keyFor(key)"></a>Symbol.keyFor(key)</h2><pre><code>Symbol.keyFor方法返回一个（全局）已登记的 Symbol 类型值的key。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s1) // &quot;foo&quot;</div><div class="line"></div><div class="line">let s2 = Symbol(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s2) // undefined</div></pre></td></tr></table></figure>

PS：上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。
</code></pre><h1 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h1><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h2 id="迭代-symbols"><a href="#迭代-symbols" class="headerlink" title="迭代 symbols"></a>迭代 symbols</h2><ol>
<li>Symbol.iterator<br>  一个返回一个对象默认迭代器的方法。使用 for…of。</li>
<li>Symbol.asyncIterator（实验性API）<br>  一个返回对象默认的异步迭代器的方法。使用 for await of。</li>
</ol>
<h2 id="正则表达式-symbols"><a href="#正则表达式-symbols" class="headerlink" title="正则表达式 symbols"></a>正则表达式 symbols</h2><ol>
<li>Symbol.match<br>  一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match().</li>
<li>Symbol.replace<br>  一个替换匹配字符串的子串的方法. 使用 String.prototype.replace().</li>
<li>Symbol.search<br>  一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search().</li>
<li>Symbol.split<br>  一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split().</li>
</ol>
<h2 id="其他-symbols"><a href="#其他-symbols" class="headerlink" title="其他 symbols"></a>其他 symbols</h2><ol>
<li>Symbol.hasInstance<br>  一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof.</li>
<li>Symbol.isConcatSpreadable<br>  一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat().</li>
<li>Symbol.unscopables<br>  拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</li>
<li>Symbol.species<br>  一个用于创建派生对象的构造器函数。</li>
<li>Symbol.toPrimitive<br>  一个将对象转化为基本数据类型的方法。</li>
<li>Symbol.toStringTag<br>  用于对象的默认描述的字符串值。使用Object.prototype.toString().</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">阮一峰-Symbol</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">MDN-Symbol</a>    </p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Set和Map的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Set和Map的用法/" itemprop="url">
                  Set和Map的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T21:33:57+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Set和Map的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Set和Map的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,590
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Set-详解"><a href="#Set-详解" class="headerlink" title="Set 详解"></a>Set 详解</h1><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>语法：new Set([iterable]);<br>参数：如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。<br>返回值：一个新的Set对象。</p>
<h2 id="来个简单实例"><a href="#来个简单实例" class="headerlink" title="来个简单实例"></a>来个简单实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3]);</div><div class="line">console.log(set) // Set(3) &#123;1, 2, 3&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol>
<li>Set.prototype<br>表示Set构造器的原型，允许向所有Set对象添加新的属性。</li>
<li>Set.prototype.constructor<br>返回实例的构造函数。默认情况下是Set。</li>
<li>Set.prototype.size<br>返回Set对象的值的个数。</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</li>
<li>Set.prototype.clear()<br>移除Set对象内的所有元素。</li>
<li>Set.prototype.delete(value)<br>移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</li>
<li>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</li>
<li>Set.prototype.keys()<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</li>
<li>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</li>
<li>Set.prototype<a href="">@@iterator</a><br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值</li>
</ol>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-基础"><a href="#WeakSet-基础" class="headerlink" title="WeakSet 基础"></a>WeakSet 基础</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<h3 id="WeakSet-具有的方法"><a href="#WeakSet-具有的方法" class="headerlink" title="WeakSet 具有的方法"></a>WeakSet 具有的方法</h3>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const ws = new WeakSet();</div><div class="line">const obj = &#123;&#125;;</div><div class="line"></div><div class="line">ws.add(window);</div><div class="line">ws.add(obj);</div><div class="line"></div><div class="line">ws.has(window); // true</div><div class="line"></div><div class="line">ws.delete(window);</div><div class="line">ws.has(window);    // false</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-出现的背景"><a href="#Map-出现的背景" class="headerlink" title="Map 出现的背景"></a>Map 出现的背景</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<h2 id="基础特性-1"><a href="#基础特性-1" class="headerlink" title="基础特性"></a>基础特性</h2><p>语法：new Map([iterable])<br>参数：iterable<br>    Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>
<h2 id="简单的Map-实例"><a href="#简单的Map-实例" class="headerlink" title="简单的Map 实例"></a>简单的Map 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line"></div><div class="line">map.set(-0, 123);</div><div class="line">map.get(+0) // 123</div><div class="line"></div><div class="line">map.set(true, 1);</div><div class="line">map.set(&apos;true&apos;, 2);</div><div class="line">map.get(true) // 1</div><div class="line"></div><div class="line">map.set(undefined, 3);</div><div class="line">map.set(null, 4);</div><div class="line">map.get(undefined) // 3</div><div class="line"></div><div class="line">map.set(NaN, 123);</div><div class="line">map.get(NaN) // 123</div></pre></td></tr></table></figure>
</code></pre><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ol>
<li>Map.prototype<br>表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。</li>
<li>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</li>
<li>Map.prototype.size<br>返回Map对象的键/值对的数量。</li>
</ol>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</li>
<li>Map.prototype.delete(key)<br>移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。</li>
<li>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</li>
<li>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</li>
<li>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</li>
<li>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</li>
<li>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</li>
<li>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li>
<li>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</li>
<li>Map.prototype<a href="">@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</li>
</ol>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的基础"><a href="#WeakMap-的基础" class="headerlink" title="WeakMap 的基础"></a>WeakMap 的基础</h3><pre><code>WeakMap结构与Map结构类似，也是用于生成键值对的集合。
WeakMap与Map的区别有两点：
</code></pre><ol>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<h3 id="WeakMap-的方法"><a href="#WeakMap-的方法" class="headerlink" title="WeakMap 的方法"></a>WeakMap 的方法</h3><ol>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>delete()</li>
</ol>
<h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>WeakMap 应用的典型场合就是 DOM 节点作为键名。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let myElement = document.getElementById(&apos;logo&apos;);</div><div class="line">let myWeakmap = new WeakMap();</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</div><div class="line"></div><div class="line">myElement.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">  let logoData = myWeakmap.get(myElement);</div><div class="line">  logoData.timesClicked++;</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure></p>
<p>PS：上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">MDN-Set</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">MDN-Map</a><br>    <a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="external">阮一峰-Set和Map</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Proxy和Reflect的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Proxy和Reflect的用法/" itemprop="url">
                  Proxy和Reflect的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T18:51:05+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Proxy和Reflect的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Proxy和Reflect的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,659
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h1><h2 id="Proxy-定义"><a href="#Proxy-定义" class="headerlink" title="Proxy 定义"></a>Proxy 定义</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<h2 id="Proxy-语法"><a href="#Proxy-语法" class="headerlink" title="Proxy 语法"></a>Proxy 语法</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 目标对象，需要被拦截 或 处理的对象，数组，函数甚至是其他的代理器</div><div class="line">let target = &#123;&#125;;</div><div class="line">// 拦截器对象</div><div class="line">let handler = &#123;</div><div class="line">	get(target, name)&#123;</div><div class="line">		// 这里如果 target 没有name属性的话，就设定一个默认值</div><div class="line">		return name in target ? target[name] : 27;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">console.log(target.name); // undefined</div><div class="line">console.log(proxy.name); // 27</div></pre></td></tr></table></figure>
</code></pre><p>PS：Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<h2 id="Proxy-支持的拦截操作一览，一共13种"><a href="#Proxy-支持的拦截操作一览，一共13种" class="headerlink" title="Proxy 支持的拦截操作一览，一共13种"></a>Proxy 支持的拦截操作一览，一共13种</h2><ol>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<h2 id="Proxy-revocable-可撤销的代理"><a href="#Proxy-revocable-可撤销的代理" class="headerlink" title="Proxy.revocable() 可撤销的代理"></a>Proxy.revocable() 可撤销的代理</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let target = &#123;&#125;;</div><div class="line">let handler = &#123;&#125;;</div><div class="line"></div><div class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</div><div class="line"></div><div class="line">proxy.foo = 123;</div><div class="line">console.log(proxy.foo);</div><div class="line"></div><div class="line">revoke(); // 取消Proxy实例</div><div class="line">console.log(proxy.foo); // TypeError: Revoked</div></pre></td></tr></table></figure></p>
<p>PS：Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。<br>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-的问题"><a href="#this-的问题" class="headerlink" title="this 的问题"></a>this 的问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const target = &#123;</div><div class="line">  m: function () &#123;</div><div class="line">	console.log(this === proxy);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">const handler = &#123;&#125;;</div><div class="line"></div><div class="line">const proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">target.m() // false</div><div class="line">proxy.m()  // true</div></pre></td></tr></table></figure></p>
<h2 id="Proxy-的应用"><a href="#Proxy-的应用" class="headerlink" title="Proxy 的应用"></a>Proxy 的应用</h2><h3 id="扩展数组的属性和方法"><a href="#扩展数组的属性和方法" class="headerlink" title="扩展数组的属性和方法"></a>扩展数组的属性和方法</h3><p>需求：对于数组对象，有时候我们只想要得到数组中对象的某个键值内容。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var AddSomeFunctionHandler=&#123;</div><div class="line">	get:function(obj,prop)&#123;</div><div class="line"></div><div class="line">		if(prop in obj)&#123;</div><div class="line">			return obj[prop]   // 按数组默认方式访问元素</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if(prop === &apos;name&apos;)&#123;</div><div class="line">			return obj.map(o=&gt;o.name)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var PersonArray=[&#123;</div><div class="line">	name:&quot;Alice&quot;,age:23</div><div class="line">&#125;,&#123;</div><div class="line">	name:&quot;Bob&quot;,age:45</div><div class="line">&#125;,&#123;</div><div class="line">	name:&quot;Mike&quot;,age:27</div><div class="line">&#125;]</div><div class="line"></div><div class="line">var p= new Proxy(PersonArray,AddSomeFunctionHandler)</div><div class="line">console.log(p.name) // [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</div></pre></td></tr></table></figure></p>
<h1 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h1><h2 id="Reflect-定义"><a href="#Reflect-定义" class="headerlink" title="Reflect 定义"></a>Reflect 定义</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。<br>Reflect对象的设计目的有这样几个：</p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li>
</ol>
<h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><p>Reflect对象一共有13个静态方法。</p>
<ol>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)<br>PS：上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</li>
</ol>
<h2 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h2><p>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  get baz() &#123;</div><div class="line">	return this.foo + this.bar;</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">Reflect.get(myObject, &apos;foo&apos;) // 1</div><div class="line">Reflect.get(myObject, &apos;bar&apos;) // 2</div><div class="line">Reflect.get(myObject, &apos;baz&apos;) // 3</div></pre></td></tr></table></figure></p>
<h2 id="实例–使用-Proxy-实现观察者模式"><a href="#实例–使用-Proxy-实现观察者模式" class="headerlink" title="实例–使用 Proxy 实现观察者模式"></a>实例–使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。<br>如果你还不懂<a href="">观察者模式</a><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//添加观察者</div><div class="line">const queuedObservers = new Set();</div><div class="line">const observe = fn =&gt; queuedObservers.add(fn);</div><div class="line"></div><div class="line">//proxy 的set 方法</div><div class="line">function set(target, key, value, receiver) &#123;</div><div class="line">	const result = Reflect.set(target, key, value, receiver);</div><div class="line">	queuedObservers.forEach(observer =&gt; observer());</div><div class="line">	return result;</div><div class="line">&#125;</div><div class="line">//创建proxy代理</div><div class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</div><div class="line">//被观察的 对象</div><div class="line">const person = observable(&#123;</div><div class="line">	name: &apos;张三&apos;,</div><div class="line">	age: 20</div><div class="line">&#125;);</div><div class="line"></div><div class="line">observe(print);</div><div class="line">console.log(person.name); // 张三</div><div class="line">person.name = &apos;李四&apos;;</div><div class="line">console.log(person.name); // 李四</div></pre></td></tr></table></figure></p>
<blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">阮一峰-Reflect</a><br>    <a href="https://www.cnblogs.com/WhiteHorseIsNotHorse/p/7016010.html" target="_blank" rel="external">用es6 （proxy 和 reflect）轻松实现 观察者模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Generator函数的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Generator函数的用法/" itemprop="url">
                  Generator函数的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T15:48:46+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Generator函数的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Generator函数的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,088
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h1><p>从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<h1 id="Generator函数的简单示例"><a href="#Generator函数的简单示例" class="headerlink" title="Generator函数的简单示例"></a>Generator函数的简单示例</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* g() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var demo = g();</div></pre></td></tr></table></figure>
</code></pre><p>PS：上面代码定义了一个 Generator 函数g，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br><span style="color: red">返回的是，遍历器对象（Iterator Object）。例如这里，{ value: ‘hello’, done: false }</span></p>
<h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h1><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。<br>    （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。<br>    （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。<br>    （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。<br>    （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
<h1 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h1><pre><code>可以遍历 数组 和 实现了 Symbol.iterator 方法的对象。
</code></pre><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function *foo() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">  yield 4;</div><div class="line">  yield 5;</div><div class="line">  return 6;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let v of foo()) &#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">// 1 2 3 4 5</div></pre></td></tr></table></figure></p>
<h1 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a>Generator.prototype.next()</h1><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123; </div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen(); // &quot;Generator &#123; &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 1, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 2, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: 3, done: false &#125;&quot;</div><div class="line">g.next();      // &quot;Object &#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure></p>
<h1 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h1><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。    </p>
<h1 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h1><p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line"></div><div class="line">g.next()        // &#123; value: 1, done: false &#125;</div><div class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">g.next()        // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure></p>
<p>PS：遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。<br>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p>
<h1 id="比较一下多个异步操作的编码"><a href="#比较一下多个异步操作的编码" class="headerlink" title="比较一下多个异步操作的编码"></a>比较一下多个异步操作的编码</h1><p>step1完成才能做step2，step2完成才能做step3，step3完成才能做step4</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数("></a>回调函数(</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">step1(function (value1) &#123;</div><div class="line">  step2(value1, function(value2) &#123;</div><div class="line">	step3(value2, function(value3) &#123;</div><div class="line">	  step4(value3, function(value4) &#123;</div><div class="line">		// Do something with value4</div><div class="line">	  &#125;);</div><div class="line">	&#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>PS：层数多了就形成了回调地狱。</p>
<h2 id="Promise-组织代码"><a href="#Promise-组织代码" class="headerlink" title="Promise 组织代码"></a>Promise 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Q.fcall(step1)</div><div class="line">  .then(step2)</div><div class="line">  .then(step3)</div><div class="line">  .then(step4)</div><div class="line">  .then(function (value4) &#123;</div><div class="line">	// Do something with value4</div><div class="line">  &#125;, function (error) &#123;</div><div class="line">	// Handle any error from step1 through step4</div><div class="line">  &#125;)</div><div class="line">  .done();</div></pre></td></tr></table></figure>
</code></pre><p>PS：是不是代码稍微要清晰一些了。</p>
<h2 id="Generator-组织代码"><a href="#Generator-组织代码" class="headerlink" title="Generator 组织代码"></a>Generator 组织代码</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function* longRunningTask() &#123;</div><div class="line">  try &#123;</div><div class="line">	var value1 = yield step1();</div><div class="line">	var value2 = yield step2(value1);</div><div class="line">	var value3 = yield step3(value2);</div><div class="line">	var value4 = yield step4(value3);</div><div class="line">	// Do something with value4</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">	// Handle any error from step1 through step4</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function scheduler(task) &#123;</div><div class="line">  setTimeout(function() &#123;</div><div class="line">	var taskObj = task.next(task.value);</div><div class="line">	// 如果Generator函数未结束，就继续调用</div><div class="line">	if (!taskObj.done) &#123;</div><div class="line">	  task.value = taskObj.value</div><div class="line">	  scheduler(task);</div><div class="line">	&#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">scheduler(longRunningTask());</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator 函数的语法</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">MDN-Generator</a><br>    <a href="http://blog.csdn.net/jiangbo_phd/article/details/51820642" target="_blank" rel="external">ES6 Generator 函数的使用</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/11/Promise的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Promise的用法/" itemprop="url">
                  Promise的用法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T10:31:27+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/11/Promise的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/11/Promise的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,535
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ES6出来了很久，Promise也一直在用，现在总结一下具体用法。</p>
<h1 id="Promise-定义"><a href="#Promise-定义" class="headerlink" title="Promise 定义"></a>Promise 定义</h1><p>Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="MDN"><br>    这里使用MDN的图片</p>
<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="创造了一个-Promise-实例"><a href="#创造了一个-Promise-实例" class="headerlink" title="创造了一个 Promise 实例"></a>创造了一个 Promise 实例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">	resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">	reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h2 id="对-Promise-实例成功-或-失败-做相应的处理"><a href="#对-Promise-实例成功-或-失败-做相应的处理" class="headerlink" title="对 Promise 实例成功 或 失败 做相应的处理"></a>对 Promise 实例成功 或 失败 做相应的处理</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(value) &#123;</div><div class="line">  // success</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<h2 id="分为三种调用形式（注意最后面需要带着错误处理函数）"><a href="#分为三种调用形式（注意最后面需要带着错误处理函数）" class="headerlink" title="分为三种调用形式（注意最后面需要带着错误处理函数）"></a>分为三种调用形式（注意最后面需要带着错误处理函数）</h2><ol>
<li>promise.then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li>
<li>promise.then((resolve) =&gt; { // 成功的处理函数 }).then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 })</li>
<li>promise.then(null, (reject) =&gt; { // 错误的处理函数 })</li>
</ol>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个<span style="color: red">新的</span>Promise 对象，从而达到链式调用。</p>
<h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(resolve) &#123;</div><div class="line">  // 成功的处理函数</div><div class="line">&#125;).catch(function(error) &#123;</div><div class="line">  console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p>
<p>PS：Promise.all方法接受一个数组或具有Iterator 接口的对象作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>（1）只有p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure></p>
<p>PS：Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</div></pre></td></tr></table></figure></p>
<p>PS：将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<h2 id="根据不同参数，返回结果情况"><a href="#根据不同参数，返回结果情况" class="headerlink" title="根据不同参数，返回结果情况"></a>根据不同参数，返回结果情况</h2><ol>
<li>参数是一个Promise实例<br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个thenable对象（thenable对象指的是具有then方法的对象）<br>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</li>
<li>参数不是具有then方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</li>
<li>不带有任何参数<br>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。</li>
</ol>
<h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br>下面两种形式一样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const p = Promise.reject(&apos;出错了&apos;);</div><div class="line">// 等同于</div><div class="line">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</div><div class="line"></div><div class="line">p.then(null, function (s) &#123;</div><div class="line">  console.log(s)</div><div class="line">&#125;);</div><div class="line">// 出错了</div></pre></td></tr></table></figure></p>
<h1 id="自己部署有用的方法"><a href="#自己部署有用的方法" class="headerlink" title="自己部署有用的方法"></a>自己部署有用的方法</h1><h2 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<h3 id="部署-done-方法"><a href="#部署-done-方法" class="headerlink" title="部署 done 方法"></a>部署 done 方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.done = function (onFulfilled, onRejected) &#123;</div><div class="line">  this.then(onFulfilled, onRejected)</div><div class="line">	.catch(function (reason) &#123;</div><div class="line">	  // 抛出一个全局错误</div><div class="line">	  setTimeout(() =&gt; &#123; throw reason &#125;, 0);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">	.then(f1)</div><div class="line">	.catch(r1)</div><div class="line">	.then(f2)</div><div class="line">	.done();</div></pre></td></tr></table></figure>
</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h2><h3 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<h3 id="部署finally方法"><a href="#部署finally方法" class="headerlink" title="部署finally方法"></a>部署finally方法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.finally = function (callback) &#123;</div><div class="line">  let P = this.constructor;</div><div class="line">  return this.then(</div><div class="line">	value  =&gt; P.resolve(callback()).then(() =&gt; value),</div><div class="line">	reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.listen(0)</div><div class="line">	.then(function () &#123;</div><div class="line">	// run test</div><div class="line">	&#125;)</div><div class="line">	.finally(server.stop);</div></pre></td></tr></table></figure></p>
<h1 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h1><p><span style="color: red">目前还为提案，Promise 库Bluebird、Q和when，提供了这个方法。</span></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。    </p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.try(f) // 这里不需要管 f 是同步还是异步函数。</div><div class="line">  .then(...)</div><div class="line">  .catch(...)</div></pre></td></tr></table></figure>
</code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const preloadImage = function (path) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">	const image = new Image();</div><div class="line">	image.onload  = resolve;</div><div class="line">	image.onerror = reject;</div><div class="line">	image.src = path;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">preloadImage</div><div class="line">	.then((reslove) =&gt; &#123; console.log(&apos;图片加载成功了哦！&apos;) &#125;)</div><div class="line">	.catch((reject) =&gt; &#123; console.log(&apos;图片加载失败了哦！&apos;) &#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN–Promiese</a><br>    <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰–Promise</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/10/排序算法-插入排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/10/排序算法-插入排序/" itemprop="url">
                  排序算法-插入排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T21:12:03+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/10/排序算法-插入排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/10/排序算法-插入排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,652
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="插入排序算法定义（Insertion-Sort）"><a href="#插入排序算法定义（Insertion-Sort）" class="headerlink" title="插入排序算法定义（Insertion Sort）"></a>插入排序算法定义（Insertion Sort）</h1><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，<br>    这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序<br>    数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。<br>    是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，<br>    但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。<br>    在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<pre><code>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，
直到全部插入完为止。
</code></pre><h1 id="插入排序的分类"><a href="#插入排序的分类" class="headerlink" title="插入排序的分类"></a>插入排序的分类</h1><p>包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。<br>    属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个<br>    已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。<br>        例如,已知待排序的一组记录是：60,71,49,11,24,3,66<br>        假设在排序过程中，前3个记录已按关键码值递增的次序重新排列，构成一个有序序列：49,60,71<br>        将待排序记录中的第4个记录（即11）插入上述有序序列，以得到一个新的含4个记录的有序序列。<br>        首先，应找到11的插入位置，再进行插入。可以讲11放入数组的第一个单元r[0]中，这个单元称为监视哨，<br>        然后从71起从右到左查找，11小于71，将71右移一个位置，11小于60，又将60右移一个位置，11小于49，<br>        又再将49右移一个位置，这时再将11与r[0]的值比较，11≥r[0]，它的插入位置就是r[1]。<br>        假设11大于第一个值r[1]。它的插入位置应该在r[1]和r[2]之间，由于60已经右移了，留出来的位置正好留给11.<br>        后面的记录依照同样的方法逐个插入到该有序序列中。若记录数n,续进行n-1趟排序，才能完成。<br>        直接插入排序的算法思路：<br>        （1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；<br>        （2） 设置开始查找的位置j；<br>        （3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；<br>        （4） 将r[0]插入r[j+1]的位置上。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function insertSort(array)&#123;  </div><div class="line">	let i,</div><div class="line">		j, </div><div class="line">		temp,</div><div class="line">		arr = array.slice(),  // 这里对原数组拷贝</div><div class="line">		n = arr.length; </div><div class="line">		</div><div class="line">	for(i = 1;i &lt; n;i++)&#123;   </div><div class="line">		j = i-1; </div><div class="line">		temp = arr[i]; // 第i项为待插入的项  </div><div class="line">		</div><div class="line">		while(j &lt; i &amp;&amp; arr[j] &gt; temp)&#123;   </div><div class="line">			arr[j+1] = arr[j];   </div><div class="line">			j--;  </div><div class="line">		&#125;   </div><div class="line">		</div><div class="line">		arr[j+1] = temp;   </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return arr;   </div><div class="line">&#125;   </div><div class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </div><div class="line">let demo = insertSort(arrayA);</div><div class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure>
</code></pre><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" alt="直接插入排序"><br>    最佳情况：输入数组按升序排列。T(n) = O(n)<br>    最坏情况：输入数组按降序排列。T(n) = O(n2)<br>    平均情况：T(n) = O(n2)</p>
<h2 id="折半插入排序（二分插入排序）"><a href="#折半插入排序（二分插入排序）" class="headerlink" title="折半插入排序（二分插入排序）"></a>折半插入排序（二分插入排序）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。<br>    在处理A[i]时，A[0]……A[i-1]已经按关键码值排好序。所谓折半比较，就是在插入A[i]时，<br>    取A[i-1/2]的关键码值与A[i]的关键码值进行比较，如果A[i]的关键码值小于A[i-1/2]的关键码值，<br>    则说明A[i]只能插入A[0]到A[i-1/2]之间，故可以在A[0]到A[i-1/2-1]之间继续使用折半比较；<br>    否则只能插入A[i-1/2]到A[i-1]之间，故可以在A[i-1/2+1]到A[i-1]之间继续使用折半比较。<br>    如此担负，直到最后能够确定插入的位置为止。一般在A[k]和A[r]之间采用折半，其中间结点为A[k+r/2]，<br>    经过一次比较即可排除一半记录，把可能插入的区间减小了一半，故称为折半。<br>    执行折半插入排序的前提是文件记录必须按顺序存储。</p>
<h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><p>（1）计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，<br>        说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置 到中间值的位置，这样很简单的完成了折半；<br>    （2）在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，<br>        范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；<br>    （3）确定位置之后，将整个序列后移，并将元素插入到相应位置。</p>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function binaryInsertSort(array)&#123;</div><div class="line">	let arr = array.slice();</div><div class="line">	for (let i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">		let key = arr[i], </div><div class="line">			left = 0, </div><div class="line">			right = i - 1;</div><div class="line"></div><div class="line">		while (left &lt;= right) &#123;</div><div class="line">			let middle = parseInt((left + right) / 2);</div><div class="line"></div><div class="line">			if (key &lt; arr[middle]) &#123;</div><div class="line">				right = middle - 1;</div><div class="line">			&#125; else &#123;</div><div class="line">				left = middle + 1;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for (var j = i - 1; j &gt;= left; j--) &#123;</div><div class="line">		  arr[j + 1] = arr[j];</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		arr[left] = key;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arrayA = [1 , 3, 2, 6, 4, 5];   </div><div class="line">let demo = binaryInsertSort(arrayA);</div><div class="line">console.log(arrayA); // [1, 3, 2, 6, 4, 5]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure>
</code></pre><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="二分插入排序"><br>    最佳情况：T(n) = O(nlogn)<br>    最差情况：T(n) = O(n2)<br>    平均情况：T(n) = O(n2)</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/90zeng/p/insert_sort.html" target="_blank" rel="external">数据结构复习：直接插入排序与二分插入排序的C++实现</a><br>    <a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="external">插入排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/09/排序算法-选择排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/09/排序算法-选择排序/" itemprop="url">
                  排序算法-选择排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-09T20:18:16+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/09/排序算法-选择排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/09/排序算法-选择排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  935
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="选择排序算法定义（Selection-Sort）"><a href="#选择排序算法定义（Selection-Sort）" class="headerlink" title="选择排序算法定义（Selection Sort）"></a>选择排序算法定义（Selection Sort）</h1><pre><code>选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。选择排序的基本思想是：
每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。
基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。
</code></pre><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；
第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；
以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，
使有序序列不断增长直到全部排序完毕。
</code></pre><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><pre><code>每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。
基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。
</code></pre><h2 id="简单选择排序的基本思想"><a href="#简单选择排序的基本思想" class="headerlink" title="简单选择排序的基本思想"></a>简单选择排序的基本思想</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；
第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，
第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，
使有序序列不断增长直到全部排序完毕。
</code></pre><h2 id="简单选择排序的存储状态"><a href="#简单选择排序的存储状态" class="headerlink" title="简单选择排序的存储状态"></a>简单选择排序的存储状态</h2><pre><code>初始序列：{49 27 65 97 76 12 38}
</code></pre><p>　　第1趟：12与49交换：12{27 65 97 76 49 38}<br>　　第2趟：27不动　：12 27{65 97 76 49 38}<br>　　第3趟：65与38交换：12 27 38{97 76 49 65}<br>　　第4趟：97与49交换：12 27 38 49{76 97 65}<br>　　第5趟：76与65交换：12 27 38 49 65{97 76}<br>　　第6趟：97与76交换：12 27 38 49 65 76 97 完成</p>
<pre><code>PS：其中大括号内为无序区，大括号外为有序序列
</code></pre><h1 id="简单选择排序的算法分析"><a href="#简单选择排序的算法分析" class="headerlink" title="简单选择排序的算法分析"></a>简单选择排序的算法分析</h1><pre><code>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，
则不需要移动记录。最坏情况下，需要移动记录的次数最多为3（n-1）（此情况中待排序记录并非完全逆序，
给完全逆序记录排序的移动次数应为(n/2)*3，其中n/2向下取整）。
简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。
当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，
共需要进行的比较次数是∑ =(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n2)。
</code></pre><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function selectionSort(array) &#123;</div><div class="line">	let arr = array.slice(), // 深拷贝一份原数组</div><div class="line">		len = arr.length,</div><div class="line">		minIndex,</div><div class="line">		temp;</div><div class="line">	for (var i = 0; i &lt; len - 1; i++) &#123;</div><div class="line">		minIndex = i;</div><div class="line">		for (var j = i + 1; j &lt; len; j++) &#123;</div><div class="line">			if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</div><div class="line">				minIndex = j;                 //将最小数的索引保存</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		temp = arr[i];</div><div class="line">		arr[i] = arr[minIndex];</div><div class="line">		arr[minIndex] = temp;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [5, 4, 3, 2, 1];</div><div class="line">var demo = selectionSort(arr);</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>

PS：建议使用不可变对象的思想进行编程。
</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" alt="选择排序动图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">选择排序（Selection Sort）</a><br>    <a href="https://baike.baidu.com/item/选择排序法/2304587" target="_blank" rel="external">选择排序法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/08/排序算法-冒泡排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/08/排序算法-冒泡排序/" itemprop="url">
                  排序算法--冒泡排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T21:31:41+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/08/排序算法-冒泡排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/08/排序算法-冒泡排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  794
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">或许你需要对算法的基本概念进行了解，请访问该链接。</a></p>
<h1 id="冒泡排序算法定义（Bubble-Sort）"><a href="#冒泡排序算法定义（Bubble-Sort）" class="headerlink" title="冒泡排序算法定义（Bubble Sort）"></a>冒泡排序算法定义（Bubble Sort）</h1><pre><code>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。
</code></pre><h1 id="冒泡排序算法原理"><a href="#冒泡排序算法原理" class="headerlink" title="冒泡排序算法原理"></a>冒泡排序算法原理</h1><pre><code>冒泡排序算法的运作如下：（从后往前）
</code></pre><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h1 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><pre><code>若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。
    C=n-1；M=0；
</code></pre><p><span>所以，冒泡排序最好的时间复杂度为 O(n)。</span><br>    若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，<br>    且每次比较都必须移动记录三次来达到交换记录位置。<br>        C=n<em>(n-1)/2 = O(n^2)；M=3n</em>(n-1)/2 = O(n^2)</p>
<p><span>所以，冒泡排序最好的时间复杂度为 O(n^2)。</span><br>    综上，因此冒泡排序总的平均时间复杂度为  O(n^2)。        </p>
<h2 id="冒泡排序算法的稳定性"><a href="#冒泡排序算法的稳定性" class="headerlink" title="冒泡排序算法的稳定性"></a>冒泡排序算法的稳定性</h2><pre><code>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，
那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，
所以冒泡排序是一种稳定排序算法。
</code></pre><h1 id="冒泡排序算法描述"><a href="#冒泡排序算法描述" class="headerlink" title="冒泡排序算法描述"></a>冒泡排序算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(array) &#123;</div><div class="line">	let len = array.length, j, arr = array.slice();</div><div class="line">	let tempExchangeVal;</div><div class="line">	while (len &gt; 0) &#123;</div><div class="line">		for (j = 0; j &lt; len - 1; j++) &#123;</div><div class="line">			if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">				// 交换两个值</div><div class="line">				tempExchangeVal = arr[j];</div><div class="line">				arr[j] = arr[j + 1];</div><div class="line">				arr[j + 1] = tempExchangeVal;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		len--;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">const arr = [5, 4, 3, 2, 1];</div><div class="line">let arrSorted = bubbleSort(arr);</div><div class="line">console.log(arrSorted); // [1, 2, 3, 4, 5]</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1];</div></pre></td></tr></table></figure>

PS：这里在方法中新生成了一个数组，有不可变对象的思想。
</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" alt="冒泡排序"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/zhouliang/p/6638010.html" target="_blank" rel="external">JS-排序详解-冒泡排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="external">冒泡排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/08/排序算法基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/08/排序算法基本概念/" itemprop="url">
                  排序算法基本概念
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T20:19:57+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/08/排序算法基本概念/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/08/排序算法基本概念/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  764
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对于评述算法优劣术语的说明"><a href="#对于评述算法优劣术语的说明" class="headerlink" title="对于评述算法优劣术语的说明"></a>对于评述算法优劣术语的说明</h1><ol>
<li>稳定：如果a原本在b的前面，若a=b，排序之后a仍然在b前面。</li>
<li>不稳定：如果a原本在b的前面，若a=b，排序之后a可能会在b的后面。</li>
<li>内排序：所有排序操作都在内存中完成。</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
<li>时间复杂度：一个算法执行所消耗的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ol>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="时间复杂度的定义-T-n-O-f-n"><a href="#时间复杂度的定义-T-n-O-f-n" class="headerlink" title="时间复杂度的定义 T(n)=O(f(n))"></a>时间复杂度的定义 T(n)=O(f(n))</h2><pre><code>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，
若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，
则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的
渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。
</code></pre><h2 id="时间复杂度的计算步骤"><a href="#时间复杂度的计算步骤" class="headerlink" title="时间复杂度的计算步骤"></a>时间复杂度的计算步骤</h2><ol>
<li>计算出基本操作的执行次数T(n)<br>  基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。<br>  在做算法分析时，一般默认为考虑最坏的情况。</li>
<li>计算出T(n)的数量级<br>  求T(n)的数量级，只要将T(n)进行如下一些操作，忽略常量、低次幂和最高次幂的系数。<br>  令f(n)=T(n)的数量级。</li>
<li>用大O来表示时间复杂度<br>  当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。<br>  记作T(n)=O(f(n))。</li>
</ol>
<h2 id="计算一下时间复杂度"><a href="#计算一下时间复杂度" class="headerlink" title="计算一下时间复杂度"></a>计算一下时间复杂度</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)   //循环了，当然是O(n^2)</div><div class="line">       for(j=1;j&lt;=n;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure>
</code></pre><p>PS：这里的执行次数为 <span style="color: red;">n*n</span> 次 ，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)</div><div class="line">       for(j=1;j&lt;=i;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure>
</code></pre><p>PS：这里的执行次数为 <span style="color: red;">(1+2+3+…+n)≈(n^2)/2</span>次，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><h2 id="空间复杂度定义-S-n-O-f-n"><a href="#空间复杂度定义-S-n-O-f-n" class="headerlink" title="空间复杂度定义 S(n)=O(f(n))"></a>空间复杂度定义 S(n)=O(f(n))</h2><pre><code>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。
比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。
而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。
</code></pre><h1 id="各种算法的总结"><a href="#各种算法的总结" class="headerlink" title="各种算法的总结"></a>各种算法的总结</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p>
<pre><code>总结：接着我会使用 js 来做各种排序算法的分析。 
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="external">js十大排序算法</a><br>    <a href="http://univasity.iteye.com/blog/1164707" target="_blank" rel="external">算法时间复杂度的计算 [整理]</a><br>    <a href="http://blog.csdn.net/firefly_2002/article/details/8008987" target="_blank" rel="external">如何计算时间复杂度</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">130</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共172.1k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="80" height="160" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 100px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/hibiki/hibiki.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
