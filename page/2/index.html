<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/page/2/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/page/2/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/09/排序算法-选择排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/09/排序算法-选择排序/" itemprop="url">
                  排序算法-选择排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-09T20:18:16+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/09/排序算法-选择排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/09/排序算法-选择排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  935
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="选择排序算法定义（Selection-Sort）"><a href="#选择排序算法定义（Selection-Sort）" class="headerlink" title="选择排序算法定义（Selection Sort）"></a>选择排序算法定义（Selection Sort）</h1><pre><code>选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。选择排序的基本思想是：
每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。
基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。
</code></pre><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；
第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；
以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，
使有序序列不断增长直到全部排序完毕。
</code></pre><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><pre><code>每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。
基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。
</code></pre><h2 id="简单选择排序的基本思想"><a href="#简单选择排序的基本思想" class="headerlink" title="简单选择排序的基本思想"></a>简单选择排序的基本思想</h2><pre><code>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；
第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，
第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，
使有序序列不断增长直到全部排序完毕。
</code></pre><h2 id="简单选择排序的存储状态"><a href="#简单选择排序的存储状态" class="headerlink" title="简单选择排序的存储状态"></a>简单选择排序的存储状态</h2><pre><code>初始序列：{49 27 65 97 76 12 38}
</code></pre><p>　　第1趟：12与49交换：12{27 65 97 76 49 38}<br>　　第2趟：27不动　：12 27{65 97 76 49 38}<br>　　第3趟：65与38交换：12 27 38{97 76 49 65}<br>　　第4趟：97与49交换：12 27 38 49{76 97 65}<br>　　第5趟：76与65交换：12 27 38 49 65{97 76}<br>　　第6趟：97与76交换：12 27 38 49 65 76 97 完成</p>
<pre><code>PS：其中大括号内为无序区，大括号外为有序序列
</code></pre><h1 id="简单选择排序的算法分析"><a href="#简单选择排序的算法分析" class="headerlink" title="简单选择排序的算法分析"></a>简单选择排序的算法分析</h1><pre><code>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，
则不需要移动记录。最坏情况下，需要移动记录的次数最多为3（n-1）（此情况中待排序记录并非完全逆序，
给完全逆序记录排序的移动次数应为(n/2)*3，其中n/2向下取整）。
简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。
当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，
共需要进行的比较次数是∑ =(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n2)。
</code></pre><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function selectionSort(array) &#123;</div><div class="line">	let arr = array.slice(), // 深拷贝一份原数组</div><div class="line">		len = arr.length,</div><div class="line">		minIndex,</div><div class="line">		temp;</div><div class="line">	for (var i = 0; i &lt; len - 1; i++) &#123;</div><div class="line">		minIndex = i;</div><div class="line">		for (var j = i + 1; j &lt; len; j++) &#123;</div><div class="line">			if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</div><div class="line">				minIndex = j;                 //将最小数的索引保存</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		temp = arr[i];</div><div class="line">		arr[i] = arr[minIndex];</div><div class="line">		arr[minIndex] = temp;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [5, 4, 3, 2, 1];</div><div class="line">var demo = selectionSort(arr);</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1]</div><div class="line">console.log(demo); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>

PS：建议使用不可变对象的思想进行编程。
</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" alt="选择排序动图"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">选择排序（Selection Sort）</a><br>    <a href="https://baike.baidu.com/item/选择排序法/2304587" target="_blank" rel="external">选择排序法</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/08/排序算法-冒泡排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/08/排序算法-冒泡排序/" itemprop="url">
                  排序算法--冒泡排序
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T21:31:41+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/08/排序算法-冒泡排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/08/排序算法-冒泡排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  794
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://fanerge.github.io/2017/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">或许你需要对算法的基本概念进行了解，请访问该链接。</a></p>
<h1 id="冒泡排序算法定义（Bubble-Sort）"><a href="#冒泡排序算法定义（Bubble-Sort）" class="headerlink" title="冒泡排序算法定义（Bubble Sort）"></a>冒泡排序算法定义（Bubble Sort）</h1><pre><code>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。
</code></pre><h1 id="冒泡排序算法原理"><a href="#冒泡排序算法原理" class="headerlink" title="冒泡排序算法原理"></a>冒泡排序算法原理</h1><pre><code>冒泡排序算法的运作如下：（从后往前）
</code></pre><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h1 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><pre><code>若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。
    C=n-1；M=0；
</code></pre><p><span>所以，冒泡排序最好的时间复杂度为 O(n)。</span><br>    若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，<br>    且每次比较都必须移动记录三次来达到交换记录位置。<br>        C=n<em>(n-1)/2 = O(n^2)；M=3n</em>(n-1)/2 = O(n^2)</p>
<p><span>所以，冒泡排序最好的时间复杂度为 O(n^2)。</span><br>    综上，因此冒泡排序总的平均时间复杂度为  O(n^2)。        </p>
<h2 id="冒泡排序算法的稳定性"><a href="#冒泡排序算法的稳定性" class="headerlink" title="冒泡排序算法的稳定性"></a>冒泡排序算法的稳定性</h2><pre><code>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，
那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，
所以冒泡排序是一种稳定排序算法。
</code></pre><h1 id="冒泡排序算法描述"><a href="#冒泡排序算法描述" class="headerlink" title="冒泡排序算法描述"></a>冒泡排序算法描述</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(array) &#123;</div><div class="line">	let len = array.length, j, arr = array.slice();</div><div class="line">	let tempExchangeVal;</div><div class="line">	while (len &gt; 0) &#123;</div><div class="line">		for (j = 0; j &lt; len - 1; j++) &#123;</div><div class="line">			if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">				// 交换两个值</div><div class="line">				tempExchangeVal = arr[j];</div><div class="line">				arr[j] = arr[j + 1];</div><div class="line">				arr[j + 1] = tempExchangeVal;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		len--;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">const arr = [5, 4, 3, 2, 1];</div><div class="line">let arrSorted = bubbleSort(arr);</div><div class="line">console.log(arrSorted); // [1, 2, 3, 4, 5]</div><div class="line">console.log(arr); // [5, 4, 3, 2, 1];</div></pre></td></tr></table></figure>

PS：这里在方法中新生成了一个数组，有不可变对象的思想。
</code></pre><h1 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" alt="冒泡排序"><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">图片来源</a>，在此表示感谢！</p>
<blockquote>
<p>   参考文档：<br>    <a href="https://www.cnblogs.com/zhouliang/p/6638010.html" target="_blank" rel="external">JS-排序详解-冒泡排序</a><br>    <a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a><br>    <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="external">冒泡排序</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/08/排序算法基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/08/排序算法基本概念/" itemprop="url">
                  排序算法基本概念
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T20:19:57+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/08/排序算法基本概念/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/08/排序算法基本概念/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  764
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对于评述算法优劣术语的说明"><a href="#对于评述算法优劣术语的说明" class="headerlink" title="对于评述算法优劣术语的说明"></a>对于评述算法优劣术语的说明</h1><ol>
<li>稳定：如果a原本在b的前面，若a=b，排序之后a仍然在b前面。</li>
<li>不稳定：如果a原本在b的前面，若a=b，排序之后a可能会在b的后面。</li>
<li>内排序：所有排序操作都在内存中完成。</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
<li>时间复杂度：一个算法执行所消耗的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ol>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="时间复杂度的定义-T-n-O-f-n"><a href="#时间复杂度的定义-T-n-O-f-n" class="headerlink" title="时间复杂度的定义 T(n)=O(f(n))"></a>时间复杂度的定义 T(n)=O(f(n))</h2><pre><code>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，
若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，
则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的
渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。
</code></pre><h2 id="时间复杂度的计算步骤"><a href="#时间复杂度的计算步骤" class="headerlink" title="时间复杂度的计算步骤"></a>时间复杂度的计算步骤</h2><ol>
<li>计算出基本操作的执行次数T(n)<br>  基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。<br>  在做算法分析时，一般默认为考虑最坏的情况。</li>
<li>计算出T(n)的数量级<br>  求T(n)的数量级，只要将T(n)进行如下一些操作，忽略常量、低次幂和最高次幂的系数。<br>  令f(n)=T(n)的数量级。</li>
<li>用大O来表示时间复杂度<br>  当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。<br>  记作T(n)=O(f(n))。</li>
</ol>
<h2 id="计算一下时间复杂度"><a href="#计算一下时间复杂度" class="headerlink" title="计算一下时间复杂度"></a>计算一下时间复杂度</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)   //循环了，当然是O(n^2)</div><div class="line">       for(j=1;j&lt;=n;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure>
</code></pre><p>PS：这里的执行次数为 <span style="color: red;">n*n</span> 次 ，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)</div><div class="line">       for(j=1;j&lt;=i;j++)</div><div class="line">           s++;</div></pre></td></tr></table></figure>
</code></pre><p>PS：这里的执行次数为 <span style="color: red;">(1+2+3+…+n)≈(n^2)/2</span>次，所以时间复杂度为<span style="color: red;">O(n^2)</span>。</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><h2 id="空间复杂度定义-S-n-O-f-n"><a href="#空间复杂度定义-S-n-O-f-n" class="headerlink" title="空间复杂度定义 S(n)=O(f(n))"></a>空间复杂度定义 S(n)=O(f(n))</h2><pre><code>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。
比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。
而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。
</code></pre><h1 id="各种算法的总结"><a href="#各种算法的总结" class="headerlink" title="各种算法的总结"></a>各种算法的总结</h1><p><img src="http://oz5ii8zjo.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p>
<pre><code>总结：接着我会使用 js 来做各种排序算法的分析。 
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="external">js十大排序算法</a><br>    <a href="http://univasity.iteye.com/blog/1164707" target="_blank" rel="external">算法时间复杂度的计算 [整理]</a><br>    <a href="http://blog.csdn.net/firefly_2002/article/details/8008987" target="_blank" rel="external">如何计算时间复杂度</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/07/js设计模式-享元模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/07/js设计模式-享元模式/" itemprop="url">
                  js设计模式-享元模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-07T20:59:00+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/07/js设计模式-享元模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/07/js设计模式-享元模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  986
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="享元模式的基础"><a href="#享元模式的基础" class="headerlink" title="享元模式的基础"></a>享元模式的基础</h1><pre><code>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。
使用场景：第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；第二种是应用在DOM层上，
    享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄。
作用：Flyweight中有两个重要概念--内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，
    而外部信息可以在通过外部删除或者保存。
</code></pre><h1 id="内衣厂展示许多商品"><a href="#内衣厂展示许多商品" class="headerlink" title="内衣厂展示许多商品"></a>内衣厂展示许多商品</h1><pre><code>说明：假设有个内衣工厂，目前的产品有50种男士内衣与50种女士内衣，为了推销产品，
    工厂决定生产一些塑料模特来穿上它们的内衣拍成内衣广告。
这里很显然适合使用 &lt;span style=&quot;color: red;&quot;&gt;享元模式&lt;/span&gt; 来组织代码。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 定义塑料模特的构造函数</div><div class="line">var Model = function (sex) &#123;</div><div class="line">	this.sex = sex;</div><div class="line">&#125;</div><div class="line">// 为模特拍照</div><div class="line">Model.prototype.takePhoto = function () &#123;</div><div class="line">	console.log(&apos;sex=&apos; + this.sex + &apos;underwear=&apos; + this.underwear )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实例化一个男模特 和 一个女模特</div><div class="line">var maleModel = new Model(&apos;male&apos;),</div><div class="line">	female    = new Model(&apos;female&apos;);    </div><div class="line">for (var i = 1; i &lt;=50; i++)&#123;</div><div class="line">	// 分别为模特换上 50 件内衣 以及 照相</div><div class="line">	maleModel.underwear = &apos;underwear&apos; + i;</div><div class="line">	maleModel.takePhoto();</div><div class="line">&#125;</div><div class="line">for (var i = 1; i &lt;=50; i++)&#123;</div><div class="line">	// 分别为模特换上 50 件内衣 以及 照相</div><div class="line">	female.underwear = &apos;underwear&apos; + i;</div><div class="line">	femaleModel.takePhoto();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：很显然，这里只需要两个对象便完成这个需求。
</code></pre><h1 id="地图应用（对象池）"><a href="#地图应用（对象池）" class="headerlink" title="地图应用（对象池）"></a>地图应用（对象池）</h1><pre><code>说明：对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取对象。
    如果对象池里没有空闲对象则创建一个新的对象，当获取的对象完成他的职责之后，再进入池子等待被下次获取。
    假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip 。
    当第一次搜索A地点时假设出现了2个小气泡，第二次搜索A附近的B地点的时候页面出现了6个小气泡，
    按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。
    这样第二次搜索结果页面里，我们只需要再创建4个小气泡而不是6个。
</code></pre><h2 id="定义个气泡工厂"><a href="#定义个气泡工厂" class="headerlink" title="定义个气泡工厂"></a>定义个气泡工厂</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var toolTipFactory = (function () &#123;</div><div class="line">	var toolTipPool  = [];   // toolTip 对象池</div><div class="line">	return &#123;</div><div class="line">		create : function () &#123;</div><div class="line">			if(toolTipPool.length === 0)&#123;</div><div class="line">			   var div = document.createElement(&apos;div&apos;);</div><div class="line">			   document.body.appendChild(div);</div><div class="line">			   return div;</div><div class="line">			&#125; else&#123;</div><div class="line">			   return toolTipPool.shift(); //shift a dom</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		recover : function (tooltipDom) &#123;</div><div class="line">			return toolTipPool.push(tooltipDom);  </div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

PS：气泡工厂的对象池为数组是私有属性被包含在工厂闭包里，这个工厂又两个暴露对外的方法，
    create表示获取一个div节点，recover表示回收一个div节点。
</code></pre><h2 id="第一次搜索（2个气泡）"><a href="#第一次搜索（2个气泡）" class="headerlink" title="第一次搜索（2个气泡）"></a>第一次搜索（2个气泡）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [];</div><div class="line">for(var i = 0, str; str = [&apos;A&apos;,&apos;B&apos;][i++])&#123;  // get ary elem</div><div class="line">	var toolTip = toolTipFactory.create();</div><div class="line">	toolTip.innerHTML = str;</div><div class="line">	ary.push(toolTip)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

PS：现在重新回到第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们。
</code></pre><h2 id="现在开始回收节点"><a href="#现在开始回收节点" class="headerlink" title="现在开始回收节点"></a>现在开始回收节点</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(var i = 0 , toolTip ; toolTip = ary[i++])&#123;</div><div class="line">	toolTip.recover(toolTip)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="第二次搜索（6个气泡）"><a href="#第二次搜索（6个气泡）" class="headerlink" title="第二次搜索（6个气泡）"></a>第二次搜索（6个气泡）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i =0 , str; str = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;][i++]; )&#123;</div><div class="line">	var toolTip = toolTipFactory.create();</div><div class="line">	toolTip.innerHTML(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：现在页面中已经出现了6个节点，上一次创建好的节点被共享给了下一次操作。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.jianshu.com/p/a158478c95b5" target="_blank" rel="external">三分钟教会你JS设计模式之享元模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/09/2379774.html" target="_blank" rel="external">深入理解JavaScript系列（37）：设计模式之享元模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/07/js设计模式-状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/07/js设计模式-状态模式/" itemprop="url">
                  js设计模式-状态模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-07T20:15:23+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/07/js设计模式-状态模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/07/js设计模式-状态模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  919
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="状态模式的基础"><a href="#状态模式的基础" class="headerlink" title="状态模式的基础"></a>状态模式的基础</h1><pre><code>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。
    状态模式是一个非常常用的设计模式，它主要有两个角色组成：
    （1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。
    （2）状态类：表示一种状态，包含其相应的处理方法
作用：状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以可以让代码更加清晰，
    提高应用程序的维护性和扩展性。
使用场景：文件下载（开始、暂停、完成、失败等）、红绿灯
</code></pre><h1 id="红绿灯（红绿黄灯）"><a href="#红绿灯（红绿黄灯）" class="headerlink" title="红绿灯（红绿黄灯）"></a>红绿灯（红绿黄灯）</h1><pre><code>说明：我们简单地通过一个红绿灯的例子来说明状态模式，红绿灯拥有一个状态：哪一种颜色的灯亮了，
每一种颜色的灯亮了之后又各自的动作，一共有红绿黄三种颜色的灯，也就是有三种状态。
</code></pre><h2 id="定义环境类（红绿灯对象）"><a href="#定义环境类（红绿灯对象）" class="headerlink" title="定义环境类（红绿灯对象）"></a>定义环境类（红绿灯对象）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var trafficLight = (function () &#123;</div><div class="line">	var currentLight = null;</div><div class="line">	return &#123;</div><div class="line">		change: function (light) &#123;</div><div class="line">			currentLight = light;</div><div class="line">			currentLight.go();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

PS：上面的代码中，trafficLight是一个红绿灯对象，它有一个局部变量currentLight表示当前亮灯的对象，
    同时返回一个方法，这个方法用来改变红绿灯的状态，并触发相应的处理程序。
</code></pre><h2 id="定义状态类（三种不同颜色的灯）"><a href="#定义状态类（三种不同颜色的灯）" class="headerlink" title="定义状态类（三种不同颜色的灯）"></a>定义状态类（三种不同颜色的灯）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 红灯</div><div class="line">function RedLight() &#123; &#125;</div><div class="line">RedLight.prototype.go = function () &#123;</div><div class="line">	console.log(&quot;this is red light&quot;);</div><div class="line">&#125;</div><div class="line">// 绿灯</div><div class="line">function GreenLight() &#123; &#125;</div><div class="line">GreenLight.prototype.go = function () &#123;</div><div class="line">	console.log(&quot;this is green light&quot;);</div><div class="line">&#125;</div><div class="line">// 黄灯</div><div class="line">function YellowLight() &#123; &#125;</div><div class="line">YellowLight.prototype.go = function () &#123;</div><div class="line">	console.log(&quot;this is yellow light&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这段代码分别定义了红绿黄三种颜色的灯对象，每一个对象都包含一个go方法作为亮灯之后的处理程序。
</code></pre><h2 id="客户端切换不同颜色的灯"><a href="#客户端切换不同颜色的灯" class="headerlink" title="客户端切换不同颜色的灯"></a>客户端切换不同颜色的灯</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">trafficLight.change(new RedLight()); // this is red light</div><div class="line">trafficLight.change(new YellowLight()); // this is yellow light</div></pre></td></tr></table></figure>

PS：通过传入灯对象到change方法中，从而改变红绿灯的状态，触发其相应的处理程序，
这就是一个典型的状态模式的应用。
</code></pre><h1 id="菜单组件（JS组件开发中的状态模式）"><a href="#菜单组件（JS组件开发中的状态模式）" class="headerlink" title="菜单组件（JS组件开发中的状态模式）"></a>菜单组件（JS组件开发中的状态模式）</h1><pre><code>说明：状态模式在开发JS组件时非常有用，我们平时开发组件时很多时候要切换组件的状态，
每种状态有不同的处理方式，这个时候就可以使用状态模式进行开发。比如我们要开发一个菜单组件，
菜单拥有最基本的两种状态：显示和隐藏，相应的显示或隐藏可能会有各自的其他操作。
</code></pre><h2 id="定义一个环境类（菜单对象）"><a href="#定义一个环境类（菜单对象）" class="headerlink" title="定义一个环境类（菜单对象）"></a>定义一个环境类（菜单对象）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Menu() &#123; &#125;</div><div class="line">Menu.prototype.toggle = function (state) &#123;</div><div class="line">	state();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这个菜单类有一个toggle方法用来切换状态，然后调用相应的处理方法。
</code></pre><h2 id="定义状态类（切换菜单）"><a href="#定义状态类（切换菜单）" class="headerlink" title="定义状态类（切换菜单）"></a>定义状态类（切换菜单）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var menuStates = &#123;</div><div class="line">	&quot;show&quot;: function () &#123;</div><div class="line">		console.log(&quot;the menu is showing&quot;);</div><div class="line">	&#125;,</div><div class="line">	&quot;hide&quot;: function () &#123;</div><div class="line">		console.log(&quot;the menu is hiding&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

PS：通过一个对象menuStates来定义menu的状态，这里有两种状态show和hide，然后拥有相应的处理方法。
</code></pre><h2 id="客户端切换菜单状态"><a href="#客户端切换菜单状态" class="headerlink" title="客户端切换菜单状态"></a>客户端切换菜单状态</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var menu = new Menu();</div><div class="line">menu.toggle(menuStates.show);</div><div class="line">menu.toggle(menuStates.hide);</div></pre></td></tr></table></figure>

PS：这段代码实例化了一个Menu对象，然后分别切换了显示和隐藏两种状态，如果有第三种状态，
我们只需要menuStates添加相应的状态和处理程序即可。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/18/2437099.html" target="_blank" rel="external">深入理解JavaScript系列（43）：设计模式之状态模式</a><br>    <a href="http://www.cnblogs.com/lrzw32/p/4994817.htm" target="_blank" rel="external">Javascript设计模式理论与实战：状态模式</a><br>    <a href="http://luopq.com/2015/11/25/design-pattern-state/" target="_blank" rel="external">Javascript设计模式理论与实战：状态模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/06/js设计模式-职责链模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/06/js设计模式-职责链模式/" itemprop="url">
                  js设计模式-职责链模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T21:11:22+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/06/js设计模式-职责链模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/06/js设计模式-职责链模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  879
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="职责链模式的基础"><a href="#职责链模式的基础" class="headerlink" title="职责链模式的基础"></a>职责链模式的基础</h1><pre><code>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。
    将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。
    职责链模式的名字非常形象，一系列可能会处理请求的对象被该连接成一条链，请求在这些对象之间依次传递，
    直到遇到一个可以处理它的对象，我们把这些对象成为链中的节点。
优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。
使用场景：挤公交车递钱（只有售票元可以收钱）、交押金预定手机
</code></pre><h1 id="交押金预定手机"><a href="#交押金预定手机" class="headerlink" title="交押金预定手机"></a>交押金预定手机</h1><blockquote>
<p>   假设一个电视网站对于某部新上市的手机经过了2轮缴纳500元定金与200元定金的预定，现在已经到了正式购买的阶段。<br>    支付了500元定金的用户在购买阶段可以使用100元优惠券，200元定金可以使用50元优惠券，普通用户没有如果没有库存不一定能买到。<br>    约定：<br>    orderType: 表示订单类型(定金或者普通用户),code的值为1时候是500元定金用户，为2是200元定金用户，为3则是普通用户。<br>    pay : 表示用户是否支付定金，用户虽然下过500元定金的订单但是如果他一直没有支付定金，那么只能降级为普通用户。<br>    stock : 仅用户普通用户的库存数量，定金用户不受限制。</p>
</blockquote>
<pre><code>首先定义三种预定的客户的订单并且让每种客户订单有满足当前预定条件和不满足当前预定条件（需后面继续处理）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 500 元客户订单</div><div class="line">var order500 = function (orderType,pay,stock) &#123;</div><div class="line">	if(orderType === 1 &amp;&amp; pay)&#123;</div><div class="line">		 console.log(&apos;500 rmb deposit, get 100 coupon &apos;)</div><div class="line">	&#125; else &#123;</div><div class="line">		return &apos;nextSuccessor&apos;  // unknow the next node but always pass to next.</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 200 元客户订单</div><div class="line">var order200 = function (orderType,pay,stock) &#123;</div><div class="line">	if(orderType === 2 &amp;&amp; pay)&#123;</div><div class="line">		console.log(&apos;200 rmb deposit , get 50 coupon&apos;)</div><div class="line">	&#125; else&#123;</div><div class="line">		 return &apos;nextSuccessor&apos;; </div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 无预约客户订单</div><div class="line">var orderNormal = function (orderType,pay,stock) &#123;</div><div class="line">	if(stock &gt; 0)&#123;</div><div class="line">		 console.log(&apos;normal buy no coupon&apos;)</div><div class="line">	&#125; else&#123;</div><div class="line">		 console.log(&apos;the stock lack&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 定制职责链对象（作用是形成订单职责链）</div><div class="line">var Chain = function (fn) &#123;</div><div class="line">	this.fn = fn;</div><div class="line">	this.successor = null;</div><div class="line">&#125;;</div><div class="line">// 设置职责链</div><div class="line">Chain.prototype.setNextSuccessor = function (successor) &#123;</div><div class="line">	return this.successor = successor;</div><div class="line">&#125;;</div><div class="line">// 设置每个节点的调用方式</div><div class="line">Chain.prototype.passRequest = function () &#123;</div><div class="line">	var ret = this.fn.apply(this.arguments);</div><div class="line">	if(ret === &apos;nextSuccessor&apos;)&#123;</div><div class="line">		return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments)</div><div class="line">	&#125;</div><div class="line">	return ret;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 现在我们把3个订单函数分别包装成职责链的节点</div><div class="line">var chainOrder500 = new Chain(order500);</div><div class="line">var chainOrder200 = new Chain(order200);</div><div class="line">var chainOrderNormal = new Chain(orderNormal);</div><div class="line"></div><div class="line">// 这里我们把上面封装的节点连成一条线，依次判断执行</div><div class="line">chainOrder500.setNextSuccessor(chainOrder200)</div><div class="line">chainOrder200.setNextSuccessor(chainOrderNormal)</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">chainOrder500.passRequest(1,true,6); // 500 rmb deposit, get 100 coupon</div><div class="line">chainOrder500.passRequest(2,true,4); // 200 rmb deposit , get 50 coupon</div></pre></td></tr></table></figure>

假如我们又想支持，300元定金购买，那我们就在改链中增加一个节点即可
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var order300 = function () &#123;</div><div class="line">// todo</div><div class="line">&#125;;</div><div class="line">chainOrder300 = new Chain(chainOrder300)</div><div class="line">chainOrder500.setNextSuccessor(chainOrder300)</div><div class="line">chainOrder300.setNextSuccessor(chainOrder200)</div></pre></td></tr></table></figure>

我们可以自由灵活的增加移除和链中的节点顺序，这样就很简单能满足瞬息万变的需求了。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.jianshu.com/p/19b0033423be" target="_blank" rel="external">三分钟教会你JS设计模式之职责链模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/10/2435381.html" target="_blank" rel="external">深入理解JavaScript系列（38）：设计模式之职责链模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/06/js设计模式-备忘录模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/06/js设计模式-备忘录模式/" itemprop="url">
                  js设计模式-备忘录模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:00:30+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/06/js设计模式-备忘录模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/06/js设计模式-备忘录模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  765
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="备忘录模式的基础"><a href="#备忘录模式的基础" class="headerlink" title="备忘录模式的基础"></a>备忘录模式的基础</h1><pre><code>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    这样就可以将该对象恢复到原先保存的状态
作用：在我们的开发中偶尔会遇到这样一种情况，需要对用户的行为进行撤销。要想实现撤销，
    首先需要保存软件系统的历史状态，当用户执行撤销时用之前的状态覆盖当前状态。
    本节介绍的备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便的回到一个特定的历史步骤。
    备忘录模式在js中经常用于数据缓存。        
使用场景：分页控件、撤销组件    
</code></pre><h1 id="分页控件"><a href="#分页控件" class="headerlink" title="分页控件"></a>分页控件</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var Page = function()&#123;</div><div class="line">	let page = 1,</div><div class="line">		cache = &#123;&#125;,</div><div class="line">		data;</div><div class="line">	return function( page )&#123;</div><div class="line">		if ( cache[ page ] )&#123;</div><div class="line">				data =  cache[ page ];</div><div class="line">				render( data );</div><div class="line">		&#125;else&#123;</div><div class="line">				Ajax.send( &apos;cgi.xx.com/xxx&apos;, function( data )&#123;</div><div class="line">				   cache[ page ] = data;</div><div class="line">				   render( data );</div><div class="line">				&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>

PS：分页控件, 从服务器获得某一页的数据后可以存入缓存。以后再翻回这一页的时候，
    可以直接使用缓存里的数据而无需再次请求服务器。
</code></pre><h1 id="撤销组件"><a href="#撤销组件" class="headerlink" title="撤销组件"></a>撤销组件</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// 备忘录构造函数</div><div class="line">var Memento = function(state)&#123;</div><div class="line">	var _state = state;</div><div class="line">	this.getState = function()&#123;</div><div class="line">		return _state;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 原法器，saveStateToMemento创建一个备忘录，存储当前状态。</div><div class="line">var Originator = function()&#123;</div><div class="line">	var _state;</div><div class="line">	this.setState = function(state)&#123;</div><div class="line">		_state = state;</div><div class="line">	&#125;</div><div class="line">	this.getState = function()&#123;</div><div class="line">		return _state;</div><div class="line">	&#125;</div><div class="line">	this.saveStateToMemento = function()&#123;</div><div class="line">		return new Memento(_state)</div><div class="line">	&#125;</div><div class="line">	this.getStateFromMemento = function(memento)&#123;</div><div class="line">		_state = memento.getState();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// CareTaker称之为负责人也可以叫管理者，它负责保存备忘录</div><div class="line">var CareTaker = function()&#123;</div><div class="line">	var _mementoList = [];</div><div class="line">	this.add = function(memento)&#123;</div><div class="line">		_mementoList.push(memento);</div><div class="line">	&#125;</div><div class="line">	this.get = function(index)&#123;</div><div class="line">		return _mementoList[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var originator = new Originator();</div><div class="line">var careTaker = new CareTaker();</div><div class="line">originator.setState(&quot;State 1&quot;);</div><div class="line">originator.setState(&quot;State 2&quot;);</div><div class="line">careTaker.add(originator.saveStateToMemento());</div><div class="line">originator.setState(&quot;State 3&quot;);</div><div class="line">careTaker.add(originator.saveStateToMemento());</div><div class="line">originator.setState(&quot;State 4&quot;);</div><div class="line"> </div><div class="line">console.log(&quot;当前状态: &quot; + originator.getState());</div><div class="line">// 当前状态: State 4</div><div class="line">originator.getStateFromMemento(careTaker.get(0));</div><div class="line">console.log(&quot;恢复第一次保存状态: &quot; + originator.getState());</div><div class="line">// 恢复第一次保存状态: State 2</div><div class="line">originator.getStateFromMemento(careTaker.get(1));</div><div class="line">console.log(&quot;恢复第二次保存: &quot; + originator.getState());</div><div class="line">// 恢复第二次保存: State 3</div></pre></td></tr></table></figure>

PS：这个例子里面Originator称为原发器，可以通过saveStateToMemento创建一个备忘录，存储当前状态。
    Memento是一个备忘录对象，只供原发器使用，提供状态提取方法。CareTaker称之为负责人也可以叫管理者，
    它负责保存备忘录，但是不能对备忘录内容进行操作或检查。
优点：
    * 提供了一种状态恢复的时间机制，使得用户可以方便的回退到一个特定的历史步骤。
    * 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。
缺点：
    * 备忘录模式的主要缺点是资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免的需要占用大量的存储空间。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.isjs.cn/?p=998" target="_blank" rel="external">《javascript设计模式 – 备忘录模式》</a><br>    <a href="http://www.alloyteam.com/2012/10/commonly-javascript-design-patterns-memorandum-mode/" target="_blank" rel="external">【Javascript设计模式14】-备忘录模式</a>    </p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/05/前端同学需要了解通信知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/05/前端同学需要了解通信知识/" itemprop="url">
                  前端同学需要了解的通信知识
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T18:15:14+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/通信协议/" itemprop="url" rel="index">
                    <span itemprop="name">通信协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/05/前端同学需要了解通信知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/05/前端同学需要了解通信知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3,456
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="head、options、get、put、post、delete含义与区别"><a href="#head、options、get、put、post、delete含义与区别" class="headerlink" title="head、options、get、put、post、delete含义与区别"></a>head、options、get、put、post、delete含义与区别</h1><pre><code>了解它们的区别，这对于 RESTful架构 来说非常有意义。
</code></pre><p>如果你还不知道什么叫 <a href="https://fanerge.github.io/2017/10/13/RESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/">RESTful架构</a>？</p>
<h2 id="HEAD请求（判断资源是否存在）"><a href="#HEAD请求（判断资源是否存在）" class="headerlink" title="HEAD请求（判断资源是否存在）"></a>HEAD请求（判断资源是否存在）</h2><pre><code>HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。
有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，
我们通常使用GET，但这里用HEAD则意义更加明确。
</code></pre><h2 id="OPTIONS请求（获取当前URL支持的方法）"><a href="#OPTIONS请求（获取当前URL支持的方法）" class="headerlink" title="OPTIONS请求（获取当前URL支持的方法）"></a>OPTIONS请求（获取当前URL支持的方法）</h2><pre><code>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。
若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
</code></pre><h2 id="POST请求（相当于数据库操作–增）"><a href="#POST请求（相当于数据库操作–增）" class="headerlink" title="POST请求（相当于数据库操作–增）"></a>POST请求（相当于数据库操作–增）</h2><pre><code>POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，
就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。
</code></pre><h2 id="DELETE请求（相当于数据库操作–删）"><a href="#DELETE请求（相当于数据库操作–删）" class="headerlink" title="DELETE请求（相当于数据库操作–删）"></a>DELETE请求（相当于数据库操作–删）</h2><pre><code>DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。
</code></pre><h2 id="PUT请求（相当于数据库操作–改）"><a href="#PUT请求（相当于数据库操作–改）" class="headerlink" title="PUT请求（相当于数据库操作–改）"></a>PUT请求（相当于数据库操作–改）</h2><pre><code>PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，
用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。
</code></pre><h2 id="GET请求（相当于数据库操作–查）"><a href="#GET请求（相当于数据库操作–查）" class="headerlink" title="GET请求（相当于数据库操作–查）"></a>GET请求（相当于数据库操作–查）</h2><pre><code>GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，
只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。
无论进行多少次操作，结果都是一样的。
</code></pre><h1 id="常见的-GET-和-POST-的区别（浅比较）"><a href="#常见的-GET-和-POST-的区别（浅比较）" class="headerlink" title="常见的 GET 和 POST 的区别（浅比较）"></a>常见的 GET 和 POST 的区别（浅比较）</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/get%E5%92%8Cpost.png" alt="get和post的区别"><br>    这些都是比较常见的，我就直接借用下<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="external">杨光</a>的总结。</p>
<h1 id="也许这才是面试官想要的"><a href="#也许这才是面试官想要的" class="headerlink" title="也许这才是面试官想要的"></a>也许这才是面试官想要的</h1><p>上面我们的分析都是从<a href="https://fanerge.github.io/2017/10/14/OSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">TCP/IP五层网络架构</a>中的 <span style="color: red;">应用层</span> 和 生产使用时做了区别，<br>这里我们就进入更底层的 <span style="color: red;">传输层 </span>的分析吧！</p>
<blockquote>
<p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>这里你只需要知道这个就好了，更详细请访问<a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="external">get与post的区别</a>。    </p>
</blockquote>
<h1 id="总结一下-http-状态码"><a href="#总结一下-http-状态码" class="headerlink" title="总结一下 http 状态码"></a>总结一下 http 状态码</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/http%E7%8A%B6%E6%80%81%E7%A0%81%E6%B1%87%E6%80%BB.png" alt="通用的http状态码"><br>    看着这些是不是有些头大，下面我为大家总结一些通用的状态码。<br>    100-199 用于指定客户端应相应的某些动作。<br>    200-299 用于表示请求成功。<br>    300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>    400-499 用于指出客户端的错误。<br>    500-599 用于支持服务器错误。</p>
<h2 id="1"><a href="#1" class="headerlink" title="1**"></a>1**</h2><h3 id="100-Continue-继续"><a href="#100-Continue-继续" class="headerlink" title="100 (Continue/继续)"></a>100 (Continue/继续)</h3><pre><code>如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。
在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端
不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 
</code></pre><h3 id="101-Switching-Protocols-转换协议"><a href="#101-Switching-Protocols-转换协议" class="headerlink" title="101 (Switching Protocols/转换协议)"></a>101 (Switching Protocols/转换协议)</h3><pre><code>指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 
</code></pre><h2 id="2"><a href="#2" class="headerlink" title="2**"></a>2**</h2><h3 id="200-OK-正常"><a href="#200-OK-正常" class="headerlink" title="200 (OK/正常)"></a>200 (OK/正常)</h3><pre><code>200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；
如果没有调用setStatus方法的话，就会得到200。 
</code></pre><h3 id="201-Created-已创建"><a href="#201-Created-已创建" class="headerlink" title="201 (Created/已创建)"></a>201 (Created/已创建)</h3><pre><code>201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。
</code></pre><h3 id="202-Accepted-接受"><a href="#202-Accepted-接受" class="headerlink" title="202 (Accepted/接受)"></a>202 (Accepted/接受)</h3><pre><code>202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。 
</code></pre><h3 id="203-Non-Authoritative-Information-非官方信息"><a href="#203-Non-Authoritative-Information-非官方信息" class="headerlink" title="203 (Non-Authoritative Information/非官方信息)"></a>203 (Non-Authoritative Information/非官方信息)</h3><pre><code>状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的
是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 
</code></pre><h3 id="204-No-Content-无内容"><a href="#204-No-Content-无内容" class="headerlink" title="204 (No Content/无内容)"></a>204 (No Content/无内容)</h3><pre><code>在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于
用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet
可能作如下操作： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int pageVersion =Integer.parseInt(request.getParameter(&quot;pageVersion&quot;));</div><div class="line">if (pageVersion &gt;;= currentVersion) &#123;</div><div class="line">   response.setStatus(response.SC_NO_CONTENT);</div><div class="line">&#125; else &#123;</div><div class="line">	   // Create regular page</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="205-Reset-Content-重置内容"><a href="#205-Reset-Content-重置内容" class="headerlink" title="205 (Reset Content/重置内容)"></a>205 (Reset Content/重置内容)</h3><pre><code>重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用
于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 
</code></pre><h3 id="206-Partial-Content-局部内容"><a href="#206-Partial-Content-局部内容" class="headerlink" title="206 (Partial Content/局部内容)"></a>206 (Partial Content/局部内容)</h3><pre><code>206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。
这是 HTTP 1.1中新加入的。 
</code></pre><h2 id="3"><a href="#3" class="headerlink" title="3**"></a>3**</h2><h3 id="300-Multiple-Choices-多重选择"><a href="#300-Multiple-Choices-多重选择" class="headerlink" title="300 (Multiple Choices/多重选择)"></a>300 (Multiple Choices/多重选择)</h3><pre><code>300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。
如果服务器有首选设置，首选项将会被列于定位响应头信息中。 
</code></pre><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 (Moved Permanently)"></a>301 (Moved Permanently)</h3><pre><code>永久性重定向。 
</code></pre><h3 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 (Move temporarily)"></a>302 (Move temporarily)</h3><pre><code>临时性重定向。
</code></pre><h3 id="303-See-Other-参见其他信息"><a href="#303-See-Other-参见其他信息" class="headerlink" title="303 (See Other/参见其他信息)"></a>303 (See Other/参见其他信息)</h3><pre><code>与301类似，使用GET和POST请求查看
</code></pre><h3 id="304-Not-Modified-未更改"><a href="#304-Not-Modified-未更改" class="headerlink" title="304 (Not Modified/未更改)"></a>304 (Not Modified/未更改)</h3><pre><code>当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后
有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被
更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这
个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程
已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化
和页面修正日期的例子)给出。 
</code></pre><h3 id="305-Use-Proxy-使用代理"><a href="#305-Use-Proxy-使用代理" class="headerlink" title="305 (Use Proxy/使用代理)"></a>305 (Use Proxy/使用代理)</h3><pre><code>305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="307-Temporary-Redirect-临时重定向"><a href="#307-Temporary-Redirect-临时重定向" class="headerlink" title="307 (Temporary Redirect/临时重定向)"></a>307 (Temporary Redirect/临时重定向)</h3><pre><code>与302类似，使用GET请求重定向。 
</code></pre><h2 id="4"><a href="#4" class="headerlink" title="4**"></a>4**</h2><h3 id="400-Bad-Request-错误请求"><a href="#400-Bad-Request-错误请求" class="headerlink" title="400 (Bad Request/错误请求)"></a>400 (Bad Request/错误请求)</h3><pre><code>400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。 
</code></pre><h3 id="401-Unauthorized-未授权"><a href="#401-Unauthorized-未授权" class="headerlink" title="401 (Unauthorized/未授权)"></a>401 (Unauthorized/未授权)</h3><pre><code>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。
这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。” 
</code></pre><h3 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 (Forbidden/禁止)"></a>403 (Forbidden/禁止)</h3><pre><code>403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于
服务器上的损坏文件或目录许可而引起。 
</code></pre><h3 id="404-Not-Found-未找到"><a href="#404-Not-Found-未找到" class="headerlink" title="404 (Not Found/未找到)"></a>404 (Not Found/未找到)</h3><pre><code>404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。
它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有
专门的方法实现它：sendError(&quot;message&quot;)。相对于setStatus使用sendError得好处是：服务器会自动
生成一个错误页来显示错误信息。
</code></pre><h3 id="405-Method-Not-Allowed-方法未允许"><a href="#405-Method-Not-Allowed-方法未允许" class="headerlink" title="405 (Method Not Allowed/方法未允许)"></a>405 (Method Not Allowed/方法未允许)</h3><pre><code>405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源
不允许使用。该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="406-Not-Acceptable-无法访问"><a href="#406-Not-Acceptable-无法访问" class="headerlink" title="406 (Not Acceptable/无法访问)"></a>406 (Not Acceptable/无法访问)</h3><pre><code>406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。
406是新加入 HTTP 1.1中的。 
</code></pre><h3 id="407-Proxy-Authentication-Required-代理服务器认证要求"><a href="#407-Proxy-Authentication-Required-代理服务器认证要求" class="headerlink" title="407 (Proxy Authentication Required/代理服务器认证要求)"></a>407 (Proxy Authentication Required/代理服务器认证要求)</h3><pre><code>407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。
该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头
信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="408-Request-Timeout-请求超时"><a href="#408-Request-Timeout-请求超时" class="headerlink" title="408 (Request Timeout/请求超时)"></a>408 (Request Timeout/请求超时)</h3><pre><code>408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="409-Conflict-冲突"><a href="#409-Conflict-冲突" class="headerlink" title="409 (Conflict/冲突)"></a>409 (Conflict/冲突)</h3><pre><code>该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="410-Gone-已经不存在"><a href="#410-Gone-已经不存在" class="headerlink" title="410 (Gone/已经不存在)"></a>410 (Gone/已经不存在)</h3><pre><code>410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。
410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="411-Length-Required-需要数据长度"><a href="#411-Length-Required-需要数据长度" class="headerlink" title="411 (Length Required/需要数据长度)"></a>411 (Length Required/需要数据长度)</h3><pre><code>411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端
发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="412-Precondition-Failed-先决条件错误"><a href="#412-Precondition-Failed-先决条件错误" class="headerlink" title="412 (Precondition Failed/先决条件错误)"></a>412 (Precondition Failed/先决条件错误)</h3><pre><code>412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="413-Request-Entity-Too-Large-请求实体过大"><a href="#413-Request-Entity-Too-Large-请求实体过大" class="headerlink" title="413 (Request Entity Too Large/请求实体过大)"></a>413 (Request Entity Too Large/请求实体过大)</h3><pre><code>413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。
如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="414-Request-URI-Too-Long-请求URI过长"><a href="#414-Request-URI-Too-Long-请求URI过长" class="headerlink" title="414 (Request URI Too Long/请求URI过长)"></a>414 (Request URI Too Long/请求URI过长)</h3><pre><code>414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、
域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。
该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="415-Unsupported-Media-Type-不支持的媒体格式"><a href="#415-Unsupported-Media-Type-不支持的媒体格式" class="headerlink" title="415 (Unsupported Media Type/不支持的媒体格式)"></a>415 (Unsupported Media Type/不支持的媒体格式)</h3><pre><code>415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="416-Requested-Range-Not-Satisfiable-请求范围无法满足"><a href="#416-Requested-Range-Not-Satisfiable-请求范围无法满足" class="headerlink" title="416 (Requested Range Not Satisfiable/请求范围无法满足)"></a>416 (Requested Range Not Satisfiable/请求范围无法满足)</h3><pre><code>416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。
奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。 
</code></pre><h3 id="417-Expectation-Failed-期望失败"><a href="#417-Expectation-Failed-期望失败" class="headerlink" title="417 (Expectation Failed/期望失败)"></a>417 (Expectation Failed/期望失败)</h3><pre><code>如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的
请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态
告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 
</code></pre><h2 id="5"><a href="#5" class="headerlink" title="5**"></a>5**</h2><h3 id="500-Internal-Server-Error-内部服务器错误"><a href="#500-Internal-Server-Error-内部服务器错误" class="headerlink" title="500 (Internal Server Error/内部服务器错误)"></a>500 (Internal Server Error/内部服务器错误)</h3><pre><code>500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能
（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。 
</code></pre><h3 id="501-Not-Implemented-未实现"><a href="#501-Not-Implemented-未实现" class="headerlink" title="501 (Not Implemented/未实现)"></a>501 (Not Implemented/未实现)</h3><pre><code>501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT
这样的服务器并不支持的命令。 
</code></pre><h3 id="502-Bad-Gateway-错误的网关"><a href="#502-Bad-Gateway-错误的网关" class="headerlink" title="502 (Bad Gateway/错误的网关)"></a>502 (Bad Gateway/错误的网关)</h3><pre><code>502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 
</code></pre><h3 id="503-Service-Unavailable-服务无法获得"><a href="#503-Service-Unavailable-服务无法获得" class="headerlink" title="503 (Service Unavailable/服务无法获得)"></a>503 (Service Unavailable/服务无法获得)</h3><pre><code>状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程
或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户
端什么时候可以在试一次。 
</code></pre><h3 id="504-Gateway-Timeout-网关超时"><a href="#504-Gateway-Timeout-网关超时" class="headerlink" title="504 (Gateway Timeout/网关超时)"></a>504 (Gateway Timeout/网关超时)</h3><pre><code>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。
该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="505-HTTP-Version-Not-Supported-不支持的-HTTP-版本"><a href="#505-HTTP-Version-Not-Supported-不支持的-HTTP-版本" class="headerlink" title="505 (HTTP Version Not Supported/不支持的 HTTP 版本)"></a>505 (HTTP Version Not Supported/不支持的 HTTP 版本)</h3><pre><code>505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。
该状态是新加入 HTTP 1.1的。
</code></pre><h1 id="http-缓存相关"><a href="#http-缓存相关" class="headerlink" title="http 缓存相关"></a>http 缓存相关</h1><p>这里关于前端仔 http缓存相关的知识，我就不再总结了，有兴趣的同学可以访问我<a href="https://fanerge.github.io/2017/09/01/http%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">http缓存相关的知识</a>。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/testcoffee/p/6295970.html" target="_blank" rel="external">get、put、post、delete含义与区别</a><br>    <a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="external">HTTP协议中GET和POST方法的区别</a><br>    <a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="external">99%的人都理解错了HTTP中GET与POST的区别</a><br>    <a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin" target="_blank" rel="external">有同学不好翻墙，就看百度的http状态码吧</a><br>    <a href="http://www.cnblogs.com/lxinxuan/archive/2009/10/22/1588053.html" target="_blank" rel="external">HTTP状态码大全</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/02/js设计模式-组合模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/02/js设计模式-组合模式/" itemprop="url">
                  js设计模式-组合模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-02T19:57:34+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/02/js设计模式-组合模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/02/js设计模式-组合模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  546
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="组合模式的基础"><a href="#组合模式的基础" class="headerlink" title="组合模式的基础"></a>组合模式的基础</h1><pre><code>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，
    组合模式使得用户对单个对象和组合对象的使用具有一致性。
作用：组合模式让你可以优化处理递归或分级数据结构。
使用场景：系统目录结构、网站导航结构、文件扫描、DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、
    删除、遍历子节点的通用功能。
该模式由两部分构成：
    1.子对象（Leaf）：组成组合对象的最基本对象。
    2.组合对象（Composite）：由子对象组合起来的复杂对象。
</code></pre><h1 id="组合模式的例子"><a href="#组合模式的例子" class="headerlink" title="组合模式的例子"></a>组合模式的例子</h1><pre><code>文件扫描
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// 定义组合对象（文件夹）</div><div class="line">let Folder = function( name )&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.files = [];</div><div class="line">&#125;;</div><div class="line">Folder.prototype.add = function( file )&#123;</div><div class="line">	this.files.push( file );</div><div class="line">&#125;;</div><div class="line">Folder.prototype.scan = function()&#123;</div><div class="line">	console.log(&apos;开始文件扫描:&apos; + this.name);</div><div class="line">	for( let i = 0, file, files = this.files; file = files[i++]; )&#123;</div><div class="line">		file.scan();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//定义叶子对象（文件）</div><div class="line">let File = function( name )&#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;;</div><div class="line">File.prototype.add = function()&#123;</div><div class="line">	throw new Error(&apos;文件下面不能再添加文件&apos;);</div><div class="line">&#125;;</div><div class="line">File.prototype.scan = function()&#123;</div><div class="line">	console.log(&apos;开始扫瞄：&apos; + this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let folder = new Folder(&apos;前端学习&apos;);</div><div class="line">let folder1 = new Folder(&apos;JS学习&apos;);</div><div class="line">let folder2 = new Folder(&apos;JQ学习&apos;);</div><div class="line"></div><div class="line">let file1 = new File(&apos;JS设计模式&apos;);</div><div class="line">let file2 = new File(&apos;JQ实战&apos;);</div><div class="line">let file3 = new File(&apos;前端性能&apos;);</div><div class="line"></div><div class="line">folder1.add(file1);</div><div class="line">folder2.add(file2);</div><div class="line">folder.add(folder1);</div><div class="line">folder.add(folder2);</div><div class="line">folder.add(file3);</div><div class="line">folder.scan();</div><div class="line"></div><div class="line">// 输出</div><div class="line">开始文件扫描：前端学习</div><div class="line">开始文件扫描：JS学习</div><div class="line">开始扫瞄：JS设计模式</div><div class="line">开始文件扫描：JQ学习</div><div class="line">开始扫瞄：JQ实战</div><div class="line">开始扫瞄：前端性能</div></pre></td></tr></table></figure>

PS：父类和子类必须具有相同的接口（方法），只不过它们相同的方法具有的功能不相同，
    例如父类的实例具有 add 方法作用是，可以添加文件夹 或者 文件。子类的实例具有 
    add 方法则不能添加文件夹 或者 文件，却抛出一个错误（子类重写父类的方法）。 
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9B%86%E5%90%88/0521%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.txt" target="_blank" rel="external">0521组合模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/12/2435530.html" target="_blank" rel="external">深入理解JavaScript系列（40）：设计模式之组合模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/01/js设计模式-模版方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/01/js设计模式-模版方法模式/" itemprop="url">
                  js设计模式-模版方法模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T20:48:34+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/01/js设计模式-模版方法模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/01/js设计模式-模版方法模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  554
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><pre><code>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，
    一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中
    所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，
    从而实现自己的业务逻辑。

使用场景：
</code></pre><ol>
<li>泡饮品（茶 和 coffee）</li>
<li>公司面试（百度面试 和 阿里面试）</li>
</ol>
<h1 id="IT公司面试"><a href="#IT公司面试" class="headerlink" title="IT公司面试"></a>IT公司面试</h1><pre><code>下面就以IT公司面试作为父类，百度面试作为子类来实现面试流程模版方法。
（1.笔试 &gt;&gt; 2.技术面试 &gt;&gt; 3.领导面试 &gt;&gt; 4.等offer）
</code></pre><h2 id="定义父类"><a href="#定义父类" class="headerlink" title="定义父类"></a>定义父类</h2><pre><code>let ITInterview = function(){};
</code></pre><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 笔试</div><div class="line">ITInterview.prototype.writtenTest = function()&#123;</div><div class="line">	console.log(&quot;某公司笔试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 技术面试</div><div class="line">ITInterview.prototype.technicalInterview = function()&#123;</div><div class="line">	console.log(&quot;某公司技术面试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="领导面试"><a href="#领导面试" class="headerlink" title="领导面试"></a>领导面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 领导面试</div><div class="line">ITInterview.prototype.leader = function()&#123;</div><div class="line">	console.log(&quot;某公司leader来面试了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="等offer"><a href="#等offer" class="headerlink" title="等offer"></a>等offer</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 等通知</div><div class="line">ITInterview.prototype.waitNotice = function()&#123;</div><div class="line">	console.log(&quot;某公司的offer到了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="定义模版方法"><a href="#定义模版方法" class="headerlink" title="定义模版方法"></a>定义模版方法</h3><pre><code>作用：封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ITInterview.init = function()&#123;</div><div class="line">	this.writtenTest();</div><div class="line">	this.technicalInterview();</div><div class="line">	this.leader();</div><div class="line">	this.waitNotice();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h2 id="定义子类（百度面试）"><a href="#定义子类（百度面试）" class="headerlink" title="定义子类（百度面试）"></a>定义子类（百度面试）</h2><pre><code>首先子类需要重父类哪里继承所有的方法
let BaiDuInterview = function(){};
BaiDuInterview.prototype = new ITInterview();
</code></pre><h3 id="百度笔试"><a href="#百度笔试" class="headerlink" title="百度笔试"></a>百度笔试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 笔试</div><div class="line">BaiDuInterview.prototype.writtenTest = function()&#123;</div><div class="line">	console.log(&quot;百度公司笔试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="百度技术面试"><a href="#百度技术面试" class="headerlink" title="百度技术面试"></a>百度技术面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 技术面试</div><div class="line">BaiDuInterview.prototype.technicalInterview = function()&#123;</div><div class="line">	console.log(&quot;百度公司技术面试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="百度领导面试"><a href="#百度领导面试" class="headerlink" title="百度领导面试"></a>百度领导面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 领导面试</div><div class="line">BaiDuInterview.prototype.leader = function()&#123;</div><div class="line">	console.log(&quot;百度公司leader来面试了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="等offer-1"><a href="#等offer-1" class="headerlink" title="等offer"></a>等offer</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 等通知</div><div class="line">BaiDuInterview.prototype.waitNotice = function()&#123;</div><div class="line">	console.log(&quot;百度公司的offer到了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><pre><code>let baiduInterview = new BaiDuInterview();
baiduInterview.init();
依次输出：
    百度公司笔试测试
    百度公司技术面试测试
    百度公司leader来面试了
    百度公司的offer到了
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/xu_ya_fei/article/details/51628310" target="_blank" rel="external">JS设计模式之模板方法</a><br>    <a href="https://www.2cto.com/kf/201507/420128.html" target="_blank" rel="external">JavaScript：设计模式之模板方法</a><br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4780227.html" target="_blank" rel="external">javascript模板方法模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">123</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共155.1k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="80" height="160" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 100px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/hibiki/hibiki.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
