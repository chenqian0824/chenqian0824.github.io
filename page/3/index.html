<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/page/3/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/page/3/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/01/js设计模式-访问者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/01/js设计模式-访问者模式/" itemprop="url">
                  js设计模式-访问者模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T20:11:11+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/01/js设计模式-访问者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/01/js设计模式-访问者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  645
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在访问者模式中，主要包括下面几个角色"><a href="#在访问者模式中，主要包括下面几个角色" class="headerlink" title="在访问者模式中，主要包括下面几个角色"></a>在访问者模式中，主要包括下面几个角色</h1><ol>
<li>抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</li>
<li>访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</li>
<li>抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</li>
<li>元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</li>
<li>结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 访问者  </div><div class="line">function Visitor() &#123;  </div><div class="line">  this.visit = function( concreteElement ) &#123;  </div><div class="line">    concreteElement.doSomething();  </div><div class="line">  &#125;  </div><div class="line">&#125; </div><div class="line"></div><div class="line">// 元素类  </div><div class="line">function ConceteElement() &#123;  </div><div class="line">  this.doSomething = function() &#123;  </div><div class="line">    console.log(&quot;这是一个具体元素&quot;);  </div><div class="line">  &#125;  </div><div class="line">  this.accept = function( visitor ) &#123;  </div><div class="line">    visitor.visit(this);  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">// Client  </div><div class="line">var ele = new ConceteElement();  </div><div class="line">var v = new Visitor();  </div><div class="line">ele.accept( v );</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="访问者模式的适用场景"><a href="#访问者模式的适用场景" class="headerlink" title="访问者模式的适用场景"></a>访问者模式的适用场景</h1><ol>
<li>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</li>
<li>假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</li>
</ol>
<h1 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h1><ol>
<li>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</li>
<li>扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/itpinpai/article/details/51644922" target="_blank" rel="external">【JS设计模式】访问者模式的代码示例</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/31/Redux-API整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/Redux-API整理/" itemprop="url">
                  Redux-API整理
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T17:29:04+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/31/Redux-API整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/31/Redux-API整理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,622
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redux 定义了一系列的约定（contract）来让你来实现（例如 reducers），同时提供少量辅助函数来把这些约定整合到一起。<br>Redux 只关心如何管理 state。在实际的项目中，你还需要使用 UI 绑定库如 react-redux。</p>
<h1 id="顶级暴露的方法"><a href="#顶级暴露的方法" class="headerlink" title="顶级暴露的方法"></a>顶级暴露的方法</h1><pre><code>createStore(reducer, [initialState])
combineReducers(reducers)
applyMiddleware(...middlewares)
bindActionCreators(actionCreators, dispatch)
compose(...functions)
</code></pre><h1 id="Store-API"><a href="#Store-API" class="headerlink" title="Store API"></a>Store API</h1><pre><code>getState()
dispatch(action)
subscribe(listener)
getReducer()
replaceReducer(nextReducer)
</code></pre><h1 id="createStore-reducer-initialState-enhancer"><a href="#createStore-reducer-initialState-enhancer" class="headerlink" title="createStore(reducer, [initialState], enhancer)"></a>createStore(reducer, [initialState], enhancer)</h1><pre><code>定义：
    创建一个 Redux store 来以存放应用中所有的 state。
    应用中应有且仅有一个 store。
参数：
    1.reducer (Function): 接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。
    2.[initialState] (any): 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 合
        并后传给它，或者从之前保存的用户会话中恢复一个传给它。
    3.enhancer (Function): Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过
        的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。
返回值：
    (Store): 保存了应用所有 state 的对象。改变 state 的惟一方法是 dispatch action。
    你也可以 subscribe 监听 state 的变化，然后更新 UI。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line"></div><div class="line">function todos(state = [], action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">	case &apos;ADD_TODO&apos;:</div><div class="line">	  return state.concat([ action.text ])</div><div class="line">	default:</div><div class="line">	  return state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let store = createStore(todos, [ &apos;Use Redux&apos; ])</div><div class="line"></div><div class="line">store.dispatch(&#123;</div><div class="line">  type: &apos;ADD_TODO&apos;,</div><div class="line">  text: &apos;Read the docs&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(store.getState())</div><div class="line">// [ &apos;Use Redux&apos;, &apos;Read the docs&apos; ]</div></pre></td></tr></table></figure>

注意：
1.应用中不要创建多个 store！相反，使用 combineReducers 来把多个 reducer 创建成一个根 reducer。
2.如果 state 是普通对象，永远不要修改它！
    数组：[].concat()、[].slice()
    对象：Object.assian({}, obj)、{...oldObj, ...newObj}
</code></pre><h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h1><pre><code>Store 就是用来维持应用所有的 state 树 的一个对象。
改变 store 内 state 的惟一途径是对它 dispatch 一个 action。
</code></pre><h2 id="getState"><a href="#getState" class="headerlink" title="getState()"></a>getState()</h2><pre><code>作用：
    返回应用当前的 state 树。
返回值：
    (any): 应用当前的 state 树。
</code></pre><h2 id="dispatch-action"><a href="#dispatch-action" class="headerlink" title="dispatch(action)"></a>dispatch(action)</h2><pre><code>作用：    
    分发 action。这是触发 state 变化的惟一途径。
    会使用当前 getState() 的结果和传入的 action 以同步方式的调用 store 的 reduce 函数。
    返回值会被作为下一个 state。
参数：
    1.action (Object): 描述应用变化的普通对象。
        Action 是把数据传入 store 的惟一途径，所以任何数据，无论来自 UI 事件，网络回调
        或者是其它资源如 WebSockets，最终都应该以 action 的形式被 dispatch。
        例如：{type: &apos;Add&apos;, payload: &apos;我是非必填&apos;}
返回值：
    (Object): 要 dispatch 的 action。
注意：
    同步 -- 使用 createStore 创建的 “纯正” store 只支持普通对象类型的 action，
    而且会立即传到 reducer 来执行。
    异步 -- 如果你用 applyMiddleware 来套住 createStore 时，middleware 可以修改 
    action 的执行，并支持执行 dispatch intent（意图）。
    你需要手动安装 redux-thunk 或者 redux-promise 库。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">let store = createStore(todos, [ &apos;Use Redux&apos; ])</div><div class="line"></div><div class="line">function addTodo(text) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;ADD_TODO&apos;,</div><div class="line">	text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.dispatch(addTodo(&apos;Read the docs&apos;))</div><div class="line">store.dispatch(addTodo(&apos;Read about the middleware&apos;))</div></pre></td></tr></table></figure>
</code></pre><h2 id="subscribe-listener"><a href="#subscribe-listener" class="headerlink" title="subscribe(listener)"></a>subscribe(listener)</h2><pre><code>作用：
    添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。
    你可以在回调函数里调用 getState() 来拿到当前 state。
    如果需要解绑这个变化监听器，执行 subscribe 返回的函数即可。
参数：
    1.listener (Function): 每当 dispatch action 的时候都会执行的回调。
返回值：
    (Function): 一个可以解绑变化监听器的函数。
</code></pre><h2 id="replaceReducer-nextReducer"><a href="#replaceReducer-nextReducer" class="headerlink" title="replaceReducer(nextReducer)"></a>replaceReducer(nextReducer)</h2><pre><code>作用：
    替换 store 当前用来计算 state 的 reducer。
    只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。
参数：
    1.reducer (Function) store 会使用的下一个 reducer。
</code></pre><h1 id="combineReducers-reducers"><a href="#combineReducers-reducers" class="headerlink" title="combineReducers(reducers)"></a>combineReducers(reducers)</h1><pre><code>定义：
    把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，
    然后就可以对这个 reducer 调用 createStore。
    需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分。
    合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。
    state 对象的结构由传入的多个 reducer 的 key 决定。    
    最终，state 对象的结构会是这样的：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  reducer1: ...</div><div class="line">  reducer2: ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    PS：通过为传入对象的 reducer 命名不同来控制 state key 的命名。
    例如，你可以调用 combineReducers({ todos: myTodosReducer, counter: myCounterReducer }) 
    将 state 结构变为 { todos, counter }。
参数：
    1.reducers (Object): 一个对象，它的值（value） 对应不同的 reducer 函数，这些 reducer 
    函数后面会被合并成一个。
返回值：
    (Function)：一个调用 reducers 对象里所有 reducer 的 reducer，并且构造一个与 reducers 
    对象结构相同的 state 对象。
</code></pre><h1 id="applyMiddleware-…middlewares"><a href="#applyMiddleware-…middlewares" class="headerlink" title="applyMiddleware(…middlewares)"></a>applyMiddleware(…middlewares)</h1><pre><code>Middleware 只是包装了 store 的 dispatch 方法。
使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。    
Action 发出以后，过一段时间再执行 Reducer，这就是异步。    
redux-thunk
redux-promise
redux-devtools
参数：
    1....middlewares (arguments): 遵循 Redux middleware API 的函数。
        每个 middleware 接受 Store 的 dispatch 和 getState 函数作为命名参数，并返回一个函数。
    规格：
        ({ getState, dispatch }) =&gt; next =&gt; action。
返回值：
    (Function) 一个应用了 middleware 后的 store enhancer。这个 store enhancer 就是一个函数，
    并且需要应用到 createStore。
    它会返回一个应用了 middleware 的新的 createStore。
使用 Thunk Middleware 来做异步 Action    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore, combineReducers, applyMiddleware &#125; from &apos;redux&apos;</div><div class="line">import thunk from &apos;redux-thunk&apos;</div><div class="line">import * as reducers from &apos;./reducers&apos;</div><div class="line"></div><div class="line">// 调用 applyMiddleware，使用 middleware 增强 createStore：</div><div class="line">let createStoreWithMiddleware = applyMiddleware(thunk)(createStore)</div><div class="line"></div><div class="line">// 像原生 createStore 一样使用。</div><div class="line">let reducer = combineReducers(reducers)</div><div class="line">let store = createStoreWithMiddleware(reducer)</div><div class="line"></div><div class="line">function fetchSecretSauce() &#123;</div><div class="line">  return fetch(&apos;https://www.google.com/search?q=secret+sauce&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这些是你已熟悉的普通 action creator。</div><div class="line">// 它们返回的 action 不需要任何 middleware 就能被 dispatch。</div><div class="line">// 但是，他们只表达「事实」，并不表达「异步数据流」</div><div class="line"></div><div class="line">function makeASandwich(forPerson, secretSauce) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;MAKE_SANDWICH&apos;,</div><div class="line">	forPerson,</div><div class="line">	secretSauce</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function apologize(fromPerson, toPerson, error) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;APOLOGIZE&apos;,</div><div class="line">	fromPerson,</div><div class="line">	toPerson,</div><div class="line">	error</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function withdrawMoney(amount) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;WITHDRAW&apos;,</div><div class="line">	amount</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 即使不使用 middleware，你也可以 dispatch action：</div><div class="line">store.dispatch(withdrawMoney(100))</div><div class="line"></div><div class="line">// 但是怎样处理异步 action 呢，</div><div class="line">// 比如 API 调用，或者是路由跳转？</div><div class="line"></div><div class="line">// 来看一下 thunk。</div><div class="line">// Thunk 就是一个返回函数的函数。</div><div class="line">// 下面就是一个 thunk。</div><div class="line"></div><div class="line">function makeASandwichWithSecretSauce(forPerson) &#123;</div><div class="line"></div><div class="line">  // 控制反转！</div><div class="line">  // 返回一个接收 `dispatch` 的函数。</div><div class="line">  // Thunk middleware 知道如何把异步的 thunk action 转为普通 action。</div><div class="line"></div><div class="line">  return function (dispatch) &#123;</div><div class="line">	return fetchSecretSauce().then(</div><div class="line">	  sauce =&gt; dispatch(makeASandwich(forPerson, sauce)),</div><div class="line">	  error =&gt; dispatch(apologize(&apos;The Sandwich Shop&apos;, forPerson, error))</div><div class="line">	)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="bindActionCreators-actionCreators-dispatch"><a href="#bindActionCreators-actionCreators-dispatch" class="headerlink" title="bindActionCreators(actionCreators, dispatch)"></a>bindActionCreators(actionCreators, dispatch)</h1><pre><code>定义：
    惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，
    却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。
参数：
    1.actionCreators (Function or Object): 一个 action creator，或者键值是 action creators 的对象。
    2.dispatch (Function): 一个 dispatch 函数，由 Store 实例提供。
返回值：
    (Function or Object): 一个与原对象类似的对象，只不过这个对象中的的每个函数值都可以直接 dispatch action。
    如果传入的是一个函数，返回的也是一个函数。
</code></pre><h1 id="compose-…functions"><a href="#compose-…functions" class="headerlink" title="compose(…functions)"></a>compose(…functions)</h1><pre><code>定义：
    从右到左来组合多个函数。
    这是函数式编程中的方法，为了方便，被放到了 Redux 里。 
    当需要把多个 store 增强器依次执行的时候，需要用到它。
参数：
    (arguments): 需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。
返回值：
    (Function): 从右到左把接收到的函数合成后的最终函数。
</code></pre><h1 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h1><pre><code>作用：Redux 官方提供的 React 绑定库。
本库深受 分离容器组件和展示组件 思想启发。
在应用中，只有最顶层组件是对 Redux 可知（例如路由处理）这是很好的。
所有它们的子组件都应该是“笨拙”的，并且是通过 props 获取数据。
对比 容器组件 和 展示组件
</code></pre><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">容器组件</th>
<th style="text-align:right">展示组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置</td>
<td style="text-align:center">最顶层，路由处理</td>
<td style="text-align:right">中间和子组件</td>
</tr>
<tr>
<td>使用 Redux</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>读取数据</td>
<td style="text-align:center">从 Redux 获取 state</td>
<td style="text-align:right">从 props 获取数据</td>
</tr>
<tr>
<td>修改数据</td>
<td style="text-align:center">向 Redux 发起 actions</td>
<td style="text-align:right">从 props 调用回调函数</td>
</tr>
</tbody>
</table>
<h2 id="不使用-Redux-的展示组件"><a href="#不使用-Redux-的展示组件" class="headerlink" title="不使用 Redux 的展示组件"></a>不使用 Redux 的展示组件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from &apos;react&apos;;</div><div class="line"></div><div class="line">export default class Counter extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">	return (</div><div class="line">	  &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;</div><div class="line">		&#123;this.props.value&#125;</div><div class="line">	  &lt;/button&gt;</div><div class="line">	);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="容器组件使用-connect-方法连接-Redux"><a href="#容器组件使用-connect-方法连接-Redux" class="headerlink" title="容器组件使用 connect() 方法连接 Redux"></a>容器组件使用 connect() 方法连接 Redux</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</div><div class="line"></div><div class="line">import Counter from &apos;../components/Counter&apos;;</div><div class="line">import &#123; increment &#125; from &apos;../actionsCreators&apos;;</div><div class="line"></div><div class="line">// 哪些 Redux 全局的 state 是我们组件想要通过 props 获取的？</div><div class="line">function mapStateToProps(state) &#123;</div><div class="line">  return &#123;</div><div class="line">	value: state.counter</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 哪些 action 创建函数是我们想要通过 props 获取的？</div><div class="line">function mapDispatchToProps(dispatch) &#123;</div><div class="line">  return &#123;</div><div class="line">	onIncrement: () =&gt; dispatch(increment())</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(Counter);</div></pre></td></tr></table></figure>
</code></pre><h2 id="注入-Redux-Store"><a href="#注入-Redux-Store" class="headerlink" title="注入 Redux Store"></a>注入 Redux Store</h2><pre><code>我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。
对于服务端渲染而言，你可以在处理请求中完成这个。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	import ReactDOM from &apos;react-dom&apos;;</div><div class="line">	import &#123; Component &#125; from &apos;react&apos;;</div><div class="line">	import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line"></div><div class="line">	class App extends Component &#123;</div><div class="line">	  render() &#123;</div><div class="line">		// ...</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	const targetEl = document.getElementById(&apos;root&apos;);</div><div class="line"></div><div class="line">	ReactDOM.render(</div><div class="line">	  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">		&lt;App /&gt;</div><div class="line">	  &lt;/Provider&gt;,</div><div class="line">	  targetEl</div><div class="line">);</div></pre></td></tr></table></figure>
</code></pre><h2 id="具体-API"><a href="#具体-API" class="headerlink" title="具体 API"></a>具体 API</h2><h3 id=""><a href="#" class="headerlink" title=""></a><provider store=""></provider></h3><pre><code>作用：
    &lt;Provider store&gt; 使组件层级中的 connect() 方法都能够获得 Redux store。
    正常情况下，你的根组件应该嵌套在 &lt;Provider&gt; 中才能使用 connect() 方法。
属性：
    store (Redux Store): 应用程序中唯一的 Redux store 对象
    children (ReactElement) 组件层级的根组件。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">	&lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt;</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  targetEl</div><div class="line">);</div></pre></td></tr></table></figure>
</code></pre><h3 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h3><pre><code>作用：
    连接 React 组件与 Redux store。
    连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。
参数：
    1.[mapStateToProps(state, [ownProps]): stateProps] (Function): 
        如果定义该参数，组件将会监听 Redux store 的变化。
    2.[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 
        如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，
        而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。
    3.[mergeProps(stateProps, dispatchProps, ownProps): props] (Function):
        如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的
        props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。
    4.[options] (Object) 如果指定这个参数，可以定制 connector 的行为。
返回值：
    根据配置信息，返回一个注入了 state 和 action creator 的 React 组件。
静态属性：
    WrappedComponent (Component): 传递到 connect() 函数的原始组件类。
静态方法：
    组件原来的静态方法都被提升到被包装的 React 组件。
实例方法：
    getWrappedInstance(): ReactComponent
    仅当 connect() 函数的第四个参数 options 设置了 { withRef: true } 才返回被包装的组件实例。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://github.com/react-guide/redux-tutorial-cn" target="_blank" rel="external">redux 官方文档</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/29/React-routerV4总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/React-routerV4总结/" itemprop="url">
                  React-routerV4总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T20:01:36+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/29/React-routerV4总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/29/React-routerV4总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,521
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h1><pre><code>作用：
    &lt;Router&gt; 使用 HTML5 提供的 history API (pushState, replaceState 和 popstate 事件) 来保持 UI 和 URL 的同步。
属性：
    basename: string
        当前位置的基准 URL。如果你的页面部署在服务器的二级（子）目录，你需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。
    getUserConfirmation: func
        当导航需要确认时执行的函数。默认使用 window.confirm。
    forceRefresh: bool
        当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true。
    keyLength: number
        location.key 的长度。默认是 6。
    children: node
        渲染单一子组件（元素）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;</div><div class="line"></div><div class="line">&lt;BrowserRouter</div><div class="line">  basename=&quot;/calendar&quot;</div><div class="line">  forceRefresh=&quot;false&quot;</div><div class="line">  getUserConfirmation=&#123;optionalFunc&#125;</div><div class="line">  keyLength=&quot;10&quot;</div><div class="line">&gt;</div><div class="line">  &lt;Link to=&quot;/today&quot; /&gt; // 渲染为 &lt;a href=&quot;/calendar/today&quot;&gt;</div><div class="line">&lt;/BrowserRouter&gt;</div></pre></td></tr></table></figure>
</code></pre><h1 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h1><pre><code>作用：
    HashRouter 是一种特定的 &lt;Router&gt;， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步。
属性：
    basename: string
        当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。
    getUserConfirmation: func
        当导航需要确认时执行的函数。默认使用 window.confirm。
    hashType: string
        window.location.hash 使用的 hash 类型。有如下几种：
        &quot;slash&quot; - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops
        &quot;noslash&quot; - 后面没有斜杠，例如 # 和 #sunshine/lollipops
        &quot;hashbang&quot; - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops
        默认为 &quot;slash&quot;。
    children: node
        渲染单一子组件（元素）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import &#123; HashRouter &#125; from &apos;react-router-dom&apos;</div><div class="line"></div><div class="line">&lt;HashRouter&gt;</div><div class="line">  &lt;App/&gt;</div><div class="line">&lt;/HashRouter&gt;</div></pre></td></tr></table></figure>
</code></pre><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><pre><code>作用：
    为您的应用提供声明式的、无障碍导航。        
属性：    
    to: string/object
        需要跳转到的路径(pathname)或地址（location）。
        需要跳转到的地址（location）。
    replace: bool
        当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。
        当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。    
</code></pre><pre><code>&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;
&lt;Link to={{
  pathname: '/courses',
  search: '?sort=name',
  hash: '#the-hash',
  state: { fromDashboard: true }
}}/&gt;
</code></pre><h1 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h1><pre><code>作用：    
    为当前 URL 添加 class 和 style。
属性：
    activeClassName: string
        选中 URL 是添加的class。
    activeStyle：object
        选中 URL 是添加的style。
    exact: bool    
        如果为 true，path 为 &apos;/one&apos; 的路由将不能匹配 &apos;/one/two&apos;，反之，亦然。    
    strict: bool
        对路径末尾斜杠的匹配。如果为 true。path 为 &apos;/one/&apos; 将不能匹配 &apos;/one&apos; 但可以匹配 &apos;/one/two&apos;。
    isActive: func    
        为URL匹配添加更严谨的逻辑函数。    
</code></pre><h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><pre><code>作用：    
    当用户离开当前页面前做出一些提示。
属性：
    message: string/func
        当用户离开当前页面时，设置的提示信息。
        当用户离开当前页面时，设置的回掉函数
    when: bool
        通过设置一定条件要决定是否启用 Prompt
</code></pre><h1 id="MemoryRouter"><a href="#MemoryRouter" class="headerlink" title="MemoryRouter"></a>MemoryRouter</h1><pre><code>作用：
    无 DOM 的环境。

属性：
    initialEntries: array
        一个 history 堆栈的数组。
    initialIndex: number
        在 initialEntries 数组中的初始index。
    getUserConfirmation: func
    keyLength: number
    children: node
</code></pre><h1 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h1><pre><code>作用：
    重定向将替代当前的location 中的 history。
属性：
    to: string/object
        重定向string
        重定向object
    push: bool
        当为 true 时，替换掉整个history，而不是当前这一条。
    from: string    
        重定向的路径名。
</code></pre><h1 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h1><pre><code>作用：
    它最基本的职责就是当页面的访问地址与 Route 上的 path 匹配时，就渲染出对应的 UI 界面。
属性：
    component: func
        只有当访问地址和路由匹配时，一个 React component 才会被渲染，此时此组件接受 route props (match, location, history)。
    render: func    
        此方法适用于内联渲染，而且不会产生上文说的重复装载问题。
    children: func
        有时候你可能只想知道访问地址是否被匹配，然后改变下别的东西，而不仅仅是对应的页面。
    path: string
    exact: bool
    strict: bool
</code></pre><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><pre><code>作用：底层路由接口组件，使用封装后的组件代替。    
    &lt;BrowserRouter&gt;
    &lt;HashRouter&gt;
    &lt;MemoryRouter&gt;
    &lt;NativeRouter&gt;
    &lt;StaticRouter&gt;
属性：
    history：object
        导航的history对象
    children: node
</code></pre><h1 id="StaticRouter"><a href="#StaticRouter" class="headerlink" title="StaticRouter"></a>StaticRouter</h1><pre><code>定义：
    不会更改location的 &lt;Router&gt;，服务端渲染。
属性：
    basename: string
    location: string    
    context: object    
    children: node    
</code></pre><h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><pre><code>定义：
    只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;。
    我们只想渲染出第一个匹配的路由就可以了，于是 &lt;Switch&gt; 应运而生！
属性：
    children: node
</code></pre><h1 id="对象和方法"><a href="#对象和方法" class="headerlink" title="对象和方法"></a>对象和方法</h1><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><h3 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h3><pre><code>1.browser history -- HTML5 history API
2.hash history    -- 低版本浏览器
3.memory history  -- 无DOM环境（RN 和 Node）
</code></pre><h3 id="histoty对象详解"><a href="#histoty对象详解" class="headerlink" title="histoty对象详解"></a>histoty对象详解</h3><pre><code>length -- number 浏览历史堆栈中的条目数。        
action -- string 路由跳转到当前执行页面的动作，分为 PUSH、REPLACE、POP。
location -- object 当前访问地址信息组成的对象
    （pathname、search、hash、state）

push(path, [state]) 在历史堆栈信息里加入一个新条目。
replace(path, [state]) 在历史堆栈信息里替换掉当前的条目
go(n) 将 history 堆栈中的指针向前移动 n。
goBack() 等同于 go(-1)
goForward 等同于 go(1)
block(prompt) 阻止跳转
</code></pre><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><pre><code>location 是指你当前的位置，将要去的位置，或是之前所在的位置
在以下情境中可以获取 location 对象:
    1.在 Route component 中，以 this.props.location 获取
    2.在 Route render 中，以 ({location}) =&gt; () 方式获取
    3.在 Route children 中，以 ({location}) =&gt; () 方式获取
    4.在 withRouter 中，以 this.props.location 的方式获取
可以在不同情境中使用 location：
    1.&lt;Link to={location} /&gt;
    2.&lt;NaviveLink to={location} /&gt;
    3.&lt;Redirect to={location /&gt;
    4.history.push(location)
    5.history.replace(location)
</code></pre><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><pre><code>match 对象包含了 &lt;Route path&gt; 如何与 URL 匹配的信息，具有以下属性：
    1.params: object 路径参数，通过解析 URL 中的动态部分获得键值对
    2.isExact: bool 为 true 时，整个 URL 都需要匹配
    3.path: string 用来匹配的路径模式，用于创建嵌套的 &lt;Route&gt;
    4.url: string URL 匹配的部分，用于嵌套的 &lt;Link&gt;
在以下情境中可以获取 match 对象
    1.在 Route component 中，以 this.props.match获取
    2.在 Route render 中，以 ({match}) =&gt; () 方式获取
    3.在 Route children 中，以 ({match}) =&gt; () 方式获取
    4.在 withRouter 中，以 this.props.match的方式获取
    5.matchPath 的返回值
注：当一个 Route 没有 path 时，它会匹配一切路径。
</code></pre><h2 id="matchPath"><a href="#matchPath" class="headerlink" title="matchPath"></a>matchPath</h2><pre><code>pathname
props
</code></pre><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" rel="external">MDN-history</a><br>    <a href="http://blog.csdn.net/sinat_17775997/article/details/69218382" target="_blank" rel="external">初探 React Router 4.0</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/29/Redux总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/Redux总结/" itemprop="url">
                  Redux总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T19:53:24+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/29/Redux总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/29/Redux总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  998
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h1><h2 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h2><pre><code>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。
</code></pre><h2 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h2><pre><code>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。
</code></pre><h2 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h2><pre><code>为了描述 action 如何改变 state tree ，你需要编写 reducers。
</code></pre><p>Immutable 是一个可实现持久数据结构的 JavaScript 库。</p>
<h1 id="Redux-基本概念"><a href="#Redux-基本概念" class="headerlink" title="Redux 基本概念"></a>Redux 基本概念</h1><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const ADD_TODO = &apos;ADD_TODO&apos;</div><div class="line">&#123;</div><div class="line">  type: ADD_TODO,</div><div class="line">  text: &apos;Build my first Redux app&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。
一般来说你会通过 store.dispatch() 将 action 传到 store。    
Action 本质上是 JavaScript 普通对象。
我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。
</code></pre><h3 id="Action-创建函数"><a href="#Action-创建函数" class="headerlink" title="Action 创建函数"></a>Action 创建函数</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function addTodo(text) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: ADD_TODO,</div><div class="line">	text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

Action 创建函数 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。
</code></pre><h3 id="分发-Action（此时就新建了一条-todo）"><a href="#分发-Action（此时就新建了一条-todo）" class="headerlink" title="分发 Action（此时就新建了一条 todo）"></a>分发 Action（此时就新建了一条 todo）</h3><pre><code>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch(addTodo(&apos;新建的todo&apos;))</div></pre></td></tr></table></figure>
</code></pre><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><pre><code>Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。
而这正是 reducer 要做的事情。
</code></pre><h3 id="设计-State-结构"><a href="#设计-State-结构" class="headerlink" title="设计 State 结构"></a>设计 State 结构</h3><pre><code>在 Redux 应用中，所有的 state 都被保存在一个单一对象中。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  visibilityFilter: &apos;SHOW_ALL&apos;,</div><div class="line">  todos: [</div><div class="line">	&#123;</div><div class="line">	  text: &apos;Consider using Redux&apos;,</div><div class="line">	  completed: true,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">	  text: &apos;Keep all state in a single tree&apos;,</div><div class="line">	  completed: false</div><div class="line">	&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="Action-处理（reducer-纯函数）"><a href="#Action-处理（reducer-纯函数）" class="headerlink" title="Action 处理（reducer 纯函数）"></a>Action 处理（reducer 纯函数）</h3><pre><code>reducer 模版（不再reducer中执行有副作用的操作，如 API 请求和路由跳转）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 模版(previousState, action) =&gt; newState</div><div class="line"></div><div class="line">function todoApp(state = initialState, action) &#123;</div><div class="line">  // 这里暂不处理任何 action，</div><div class="line">  // 仅返回传入的 state。</div><div class="line">  return state</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="处理多个-action"><a href="#处理多个-action" class="headerlink" title="处理多个 action"></a>处理多个 action</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function todoApp(state = initialState, action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">	case SET_VISIBILITY_FILTER:</div><div class="line">	  return Object.assign(&#123;&#125;, state, &#123;</div><div class="line">		visibilityFilter: action.filter</div><div class="line">	  &#125;)</div><div class="line">	case ADD_TODO:</div><div class="line">	  return Object.assign(&#123;&#125;, state, &#123;</div><div class="line">		todos: [</div><div class="line">		  ...state.todos,</div><div class="line">		  &#123;</div><div class="line">			text: action.text,</div><div class="line">			completed: false</div><div class="line">		  &#125;</div><div class="line">		]</div><div class="line">	  &#125;)</div><div class="line">	default:</div><div class="line">	  return state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 Reducer</h3><pre><code>注意每个 reducer 只负责管理全局 state 中它负责的一部分。
每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。
</code></pre><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><pre><code>总结，action 和 reducers。
action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。
Store的作用：
1.维持应用的 state
2.提供 getState() 方法获取 state    
3.提供 dispatch(action) 方法更新 state
4.通过 subscribe(listener) 注册监听器
5.通过 subscribe(listener) 返回的函数注销监听器
</code></pre><h3 id="发起-Actions"><a href="#发起-Actions" class="headerlink" title="发起 Actions"></a>发起 Actions</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 订阅 state 更改</div><div class="line">// 注意 subscribe() 返回一个函数用来注销监听器</div><div class="line">let unsubscribe = store.subscribe(() =&gt;</div><div class="line">  console.log(store.getState())</div><div class="line">)</div><div class="line">// 发起 action</div><div class="line">store.dispatch(reducers)</div></pre></td></tr></table></figure>
</code></pre><h2 id="数据流动"><a href="#数据流动" class="headerlink" title="数据流动"></a>数据流动</h2><pre><code>Redux 应用中数据的生命周期
1.调用 store.dispatch(action)
    你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。
2.Redux store 调用传入的 reducer 函数
    Store 会把两个参数传入 reducer： 当前的 state 树和 action。
    let nextState = todoApp(previousState, action);
3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。    
    combineReducers() 来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。
4.Redux store 保存了根 reducer 返回的完整 state 树。    
</code></pre><h1 id="Redux-高级"><a href="#Redux-高级" class="headerlink" title="Redux 高级"></a>Redux 高级</h1><h2 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a>异步 Action</h2><pre><code>Action
    每个 API 请求都需要 dispatch 至少三种 action：    
    1.一种通知 reducer 请求开始的 action。    
    2.一种通知 reducer 请求成功结束的 action。    
    3.一种通知 reducer 请求失败的 action。    
同步 Action Creator    
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export const SELECT_SUBREDDIT = &apos;SELECT_SUBREDDIT&apos;</div><div class="line"></div><div class="line">export function selectSubreddit(subreddit) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: SELECT_SUBREDDIT,</div><div class="line">	subreddit</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="设计-state-结构"><a href="#设计-state-结构" class="headerlink" title="设计 state 结构"></a>设计 state 结构</h3><h3 id="处理-Action（reducer）"><a href="#处理-Action（reducer）" class="headerlink" title="处理 Action（reducer）"></a>处理 Action（reducer）</h3><pre><code>处理异步 action：redux-thunk、redux-promise、redux-promise-middleware
</code></pre><h3 id="异步-Action-Creator"><a href="#异步-Action-Creator" class="headerlink" title="异步 Action Creator"></a>异步 Action Creator</h3><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><pre><code>你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。        
问题: 记录日志    
问题: 崩溃报告    
</code></pre><h2 id="搭配-React-Router"><a href="#搭配-React-Router" class="headerlink" title="搭配 React Router"></a>搭配 React Router</h2><pre><code>Redux 和 React Router 将分别成为你数据和 URL 的事实来源。    
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.redux.org.cn/docs/introduction/Motivation.html" target="_blank" rel="external">Redux 中文文档</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/26/React-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/26/React-API/" itemprop="url">
                  React-API
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T20:28:33+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/26/React-API/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/26/React-API/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,684
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React-高阶-API"><a href="#React-高阶-API" class="headerlink" title="React 高阶 API"></a>React 高阶 API</h1><pre><code>Creating React Elements
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">推荐使用 JSX</div><div class="line">createElement() -- 根据给定的类型创建并返回新的 React element。</div><div class="line">createFactory() -- 根据给定的类型返回一个创建React元素的函数。</div></pre></td></tr></table></figure>

Transforming Elements
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cloneElement() -- 以 element 作为起点，克隆并返回一个新的 React Element。</div><div class="line">isValidElement() -- 验证对象是否是一个React元素。返回 true 或 false 。</div><div class="line">React.Children() -- React.Children 提供了处理 this.props.children 这个不透明数据结构的工具。</div><div class="line">	React.Children.map(children, function[(thisArg)]) -- 返回数组</div><div class="line">	React.Children.forEach(children, function[(thisArg)]) -- 对数组每项进行操作</div><div class="line">	React.Children.count(children) -- 返回组件总数</div><div class="line">	React.Children.only(children) -- 返回仅有的子级</div><div class="line">	React.Children.toArray(children) -- 返回扁平数组</div></pre></td></tr></table></figure>
</code></pre><h1 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h1><pre><code>React 组件可以让你把UI分割为独立、可复用的片段，并将每一片段视为相互独立的部分。
React组件可以通过继承 React.Component 或 React.PureComponent 来定义。
</code></pre><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">	return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

组件生命周期
    装配 -- 这些方法会在组件实例被创建和插入DOM中时被调用
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">constructor()</div><div class="line">componentWillMount()</div><div class="line">render()</div><div class="line">componentDidMount()</div></pre></td></tr></table></figure>

    更新 -- 属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps()</div><div class="line">shouldComponentUpdate()</div><div class="line">componentWillUpdate()</div><div class="line">render()</div><div class="line">componentDidUpdate()</div></pre></td></tr></table></figure>

    卸载 -- 当一个组件被从DOM中移除时，该方法被调用
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">componentWillUnmount()</div></pre></td></tr></table></figure>

其他API
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setState() 参数为对象或函数</div><div class="line">forceUpdate()</div></pre></td></tr></table></figure>

类属性
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">defaultProps</div><div class="line">	defaultProps可以被定义为组件类的一个属性，用以为类设置默认的属性。</div><div class="line">displayName</div><div class="line">	displayName被用在调试信息中。</div></pre></td></tr></table></figure>

实例属性
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">props</div><div class="line">	this.props包含了组件该调用者定义的属性。</div><div class="line">state</div><div class="line">	状态是该组件的特定数据，其可能改变多次。</div></pre></td></tr></table></figure>

参考
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">render()</div><div class="line">	可以返回：React元素、字符串和数字、Portals、null、布尔值（null和布尔值什么都不渲染）</div><div class="line">constructor(props)</div><div class="line">	super(props) 有两个作用：</div><div class="line">		this 指向（子类的实例）</div><div class="line">		在构造函数中使用 this.props  </div><div class="line">componentWillMount()		</div><div class="line">	在装配发生前被立刻调用。</div><div class="line">	其在render()之前被调用。</div><div class="line">componentDidMount()	</div><div class="line">	在组件被装配后立即调用。	</div><div class="line">	初始化使得DOM节点应该进行到这里。ajax 和 定时器</div><div class="line">componentWillReceiveProps(nextProps)	</div><div class="line">	在装配了的组件接收到新属性前调用。</div><div class="line">shouldComponentUpdate(nextProps, nextState)	</div><div class="line">	使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出。</div><div class="line">componentWillUpdate(nextProps, nextState)	</div><div class="line">	当接收到新属性或状态时，componentWillUpdate()为在渲染前被立即调用。</div><div class="line">componentDidUpdate(prevProps, prevState)	</div><div class="line">	在更新发生后立即被调用。该方法并不会在初始化渲染时调用。</div><div class="line">componentWillUnmount()	</div><div class="line">	在组件被卸载和销毁之前立刻调用。	</div><div class="line">	可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素。</div><div class="line">setState(updater, [callback])</div><div class="line">	参数为对象 &#123;name: &apos;fanerge&apos;&#125;</div><div class="line">	参数为函数(prevState, props) =&gt; stateChange</div><div class="line">component.forceUpdate(callback)	</div><div class="line">	调用forceUpdate()将会导致组件的 render()方法被调用，并忽略shouldComponentUpdate()。</div></pre></td></tr></table></figure>
</code></pre><h2 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h2><pre><code>浅对比继承该类来对 prop 和 state 进行比较，并调用 shouldComponentUpate()。 
深对比使用 forceUpdate() 和 不可变对象 来促进嵌套数据的快速比较。        
</code></pre><h1 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">react-dom这个软件包提供了针对DOM的方法，可以在你应用的顶级域中调用，也可以在有需要的情况下用作跳出React模型的出口。</div><div class="line">render()</div><div class="line">	渲染一个React元素，添加到位于提供的container里的DOM元素中，并返回这个组件的一个引用 (或者对于无状态组件返回null).</div></pre></td></tr></table></figure>

    ReactDOM.render(
      element,
      container,
      [callback]
    )
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.unmountComponentAtNode(container)</div><div class="line">	从DOM元素中移除已挂载的React组件，清除它的事件处理器和state。</div><div class="line">	有组件被卸载的时候返回true，没有组件可供卸载时返回 false。</div><div class="line">ReactDOM.findDOMNode(component)</div><div class="line">	如果这个组件已经被挂载到DOM中，函数会返回对应的浏览器中生成的DOM元素 。</div><div class="line">	大多数情况下，你可以添加一个指向DOM节点的引用，从而完全避免使用 findDOMNode 这个函数.</div></pre></td></tr></table></figure>
</code></pre><h1 id="ReactDOMServer"><a href="#ReactDOMServer" class="headerlink" title="ReactDOMServer"></a>ReactDOMServer</h1><pre><code>ReactDOMServer 类可以让你在服务端渲染你的组件。
</code></pre><h2 id="ReactDOMServer-renderToString-element"><a href="#ReactDOMServer-renderToString-element" class="headerlink" title="ReactDOMServer.renderToString(element)"></a>ReactDOMServer.renderToString(element)</h2><pre><code>把一个React元素渲染为原始的HTML。
你可以用这个方法在服务端生成HTML，并根据初始请求发送标记来加快页面的加载速度，
同时让搜索引擎可以抓取你的页面来达到优化SEO的目的。    
</code></pre><h2 id="ReactDOMServer-renderToStaticMarkup-element"><a href="#ReactDOMServer-renderToStaticMarkup-element" class="headerlink" title="ReactDOMServer.renderToStaticMarkup(element)"></a>ReactDOMServer.renderToStaticMarkup(element)</h2><pre><code>类似 renderToString，但是不会创建额外的DOM属性，例如 data-reactid 这些仅在React内部使用的属性。
如果你希望把React当作一个简单的静态页面生成器来使用，这很有用，因为去掉
</code></pre><h1 id="DOM-Elements"><a href="#DOM-Elements" class="headerlink" title="DOM Elements"></a>DOM Elements</h1><h2 id="React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。"><a href="#React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。" class="headerlink" title="React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。"></a>React实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class -- className</div><div class="line">for -- htmlFor</div><div class="line">tabindex -- tabIndex</div><div class="line">aria-* （对于残障人士更易使用的各种机制）小写字母命名 </div><div class="line">data-* （自定义属性）小写字母命名</div></pre></td></tr></table></figure>
</code></pre><h2 id="React和HTML-DOM属性的区别"><a href="#React和HTML-DOM属性的区别" class="headerlink" title="React和HTML DOM属性的区别"></a>React和HTML DOM属性的区别</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">checked属性</div><div class="line">	受控组件 -- &lt;input&gt;标签type属性值为checkbox或radio时，支持checked属性。</div><div class="line">	非受控组件 -- defaultChecked这是非受控组件的属性</div><div class="line">类名属性</div><div class="line">	class -- className</div><div class="line">dangerouslySetInnerHTML函数</div><div class="line">	处理Cross-site scripting (XSS) </div><div class="line">	dangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。</div><div class="line">htmlFor</div><div class="line">	for -- htmlFor</div><div class="line">绑定事件</div><div class="line">	onchange -- onChange</div><div class="line">selected</div><div class="line">	受控组件 -- 使用selected属性，设定组件是否选中的状态。</div><div class="line">style属性</div><div class="line">	&lt;Hello style=&#123;&#123;color: &apos;blue&apos;&#125;&#125; /&gt;</div><div class="line">	浏览器后缀除了ms以外，都应该以大写字母开头。</div><div class="line">	这就是为什么WebkitTransition有一个大写字母W。</div><div class="line">suppressContentEditableWarning</div><div class="line">	contentEditable 该属性少使用。</div><div class="line">value</div><div class="line">	受控组件 -- &lt;input&gt; 和 &lt;textarea&gt; 组件都支持value属性。</div><div class="line">	非受控组件 -- defaultValue属性对应的是非受控组件的属性，用来设置组件第一次加载时的值。</div><div class="line">支持所有的HTMl属性</div></pre></td></tr></table></figure>
</code></pre><h1 id="SyntheticEvent"><a href="#SyntheticEvent" class="headerlink" title="SyntheticEvent"></a>SyntheticEvent</h1><h2 id="您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。"><a href="#您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。" class="headerlink" title="您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。"></a>您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">boolean bubbles</div><div class="line">boolean cancelable</div><div class="line">DOMEventTarget currentTarget</div><div class="line">boolean defaultPrevented</div><div class="line">number eventPhase</div><div class="line">boolean isTrusted</div><div class="line">DOMEvent nativeEvent</div><div class="line">void preventDefault()</div><div class="line">boolean isDefaultPrevented()</div><div class="line">void stopPropagation()</div><div class="line">boolean isPropagationStopped()</div><div class="line">DOMEventTarget target</div><div class="line">number timeStamp</div><div class="line">string type</div></pre></td></tr></table></figure>
</code></pre><h2 id="事件池"><a href="#事件池" class="headerlink" title="事件池"></a>事件池</h2><pre><code>SyntheticEvent是共享的。那就意味着在调用事件回调之后，SyntheticEvent对象将会被重用，并且所有属性会被置空。
</code></pre><h2 id="支持的事件"><a href="#支持的事件" class="headerlink" title="支持的事件"></a>支持的事件</h2><pre><code>在事件名后面加Capture就能在事件捕获阶段注册事件处理函数。
你可以使用onClickCapture代替onClick在事件捕获阶段来处理点击事件。
[查看所有支持的事件](https://doc.react-china.org/docs/events.html)
</code></pre><h1 id="Test-Utilities"><a href="#Test-Utilities" class="headerlink" title="Test Utilities"></a>Test Utilities</h1><pre><code>导入 -- import ReactTestUtils from &apos;react-dom/test-utils&apos;;
[单元测试](https://doc.react-china.org/docs/test-utils.html)
</code></pre><h1 id="浅层渲染"><a href="#浅层渲染" class="headerlink" title="浅层渲染"></a>浅层渲染</h1><pre><code>[浅层渲染](https://doc.react-china.org/docs/shallow-renderer.html)
</code></pre><h1 id="Test-Renderer"><a href="#Test-Renderer" class="headerlink" title="Test Renderer"></a>Test Renderer</h1><pre><code>[Test Renderer](https://doc.react-china.org/docs/test-renderer.html)        
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://doc.react-china.org/docs/react-api.html" target="_blank" rel="external">React官方API</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/26/web常见的安全问题及解决方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/26/web常见的安全问题及解决方法/" itemprop="url">
                  web常见的安全问题及解决方法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T19:48:33+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/26/web常见的安全问题及解决方法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/26/web常见的安全问题及解决方法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,938
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端安全问题"><a href="#前端安全问题" class="headerlink" title="前端安全问题"></a>前端安全问题</h1><h2 id="XSS-漏洞"><a href="#XSS-漏洞" class="headerlink" title="XSS 漏洞"></a>XSS 漏洞</h2><pre><code>定义：
    跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。
    恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
举例：
1.HTML DOM
    视图（textContent）
        &lt;a href=&quot;/user/1&quot;&gt;{{ user_name }}&lt;/a&gt;
    数据
        &lt;script&gt;alert(1)&lt;/script&gt;
    结果
        &lt;a href=&quot;/user/1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/a&gt;
    最基本的例子，如果此处不对 user_name 中的特殊符号进行 escape，就会造成 XSS。
2.HTML Attribute
    视图（attribute）
        &lt;img src=&quot;{{ image_url }}&quot;&gt;
    数据
        onerror=&quot;alert(1)&quot;
    结果
        &lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt;
    这个例子表明，如果只对尖括号进行 escape 是不够的，很多时候引号也需要被 escape。
    简单来说，对不同输出场景，需要使用不同的 escape 规则。
3.Javascript
        &lt;script&gt;var user_data = {{ user_data|json_encode }};&lt;/script&gt;
    数据
        {&quot;exploit&quot;: &quot;&lt;/script&gt;&lt;script&gt;alert(1);//&quot;}
    结果
        &lt;script&gt;var user_data = {&quot;exploit&quot;: &quot;&lt;/script&gt;&lt;script&gt;alert(1);//&quot;};&lt;/script&gt;
    这是一个特别的例子，大多数人觉得，对于输出在 &lt;script&gt; 中的内容，json_encode 一下就安全了，其实不然。在这个例子中，XSS 仍然发生了。
解决方案：
    1.在不同上下文中，使用合适的 escape 方式
    2.不要相信任何来自用户的输入，（不仅限于 POST Body，还包括 QueryString，甚至是 Headers）
</code></pre><h2 id="CSRF-漏洞"><a href="#CSRF-漏洞" class="headerlink" title="CSRF 漏洞"></a>CSRF 漏洞</h2><pre><code>定义：    
    CSRF（Cross-site request forgery）跨站请求伪造通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。
    它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。
    与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。
理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。
    CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......
    造成的问题包括：个人隐私泄露以及财产安全。    
CSRF攻击攻击原理及过程如下：
   1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
   2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
   3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
   4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
   5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
   网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 
举例：    
1.跨站转账
    银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000
　　危险网站B，它里面有一段HTML的代码如下：
　　&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;
　　首先，你登录了银行网站A保存了cookie，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块......
　　为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。
    在访问危险网站B的之前，你已经登录了银行网站A，而B中的&lt;img&gt;以GET的方式请求第三方资源（这里的第三方就是指银行网站了，
    原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，
    去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，
    认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作......    
解决方案：（让服务器分辨出是真实用户还是攻击者）    
    1.为请求带上 token
    2.验证HTTP Referer字段
        根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。
    3.在HTTP头中自定义属性并验证
</code></pre><h1 id="后端安全问题"><a href="#后端安全问题" class="headerlink" title="后端安全问题"></a>后端安全问题</h1><h2 id="SQL-注入漏洞"><a href="#SQL-注入漏洞" class="headerlink" title="SQL 注入漏洞"></a>SQL 注入漏洞</h2><pre><code>问题展示：
    &lt;?php $user = mysql_query(&apos;SELECT * FROM USERS WHERE UserName=&quot;&apos;.$_GET[&apos;user&apos;].&apos;&quot;&apos;); ?&gt;
    那么当请求中 user 参数为 &quot;;DROP TABLE USERS;-- 时，合成的 SQL 语句是：
    SELECT * FROM USERS WHERE UserName=&quot;&quot;;DROP TABLE USERS;--&quot;
    // 这样将删除表 users
解决方案：
    所有 SQL 语句都使用参数化查询（推荐）或对参数进行 escape（不推荐）
</code></pre><h2 id="权限控制漏洞"><a href="#权限控制漏洞" class="headerlink" title="权限控制漏洞"></a>权限控制漏洞</h2><pre><code>问题展示：
    未经授权可以进行的操作都是权限控制漏洞。
    例如，某些网站的后台操作就仗着「以为用户不知道入口地址」不进行任何权限检查，
    又例如，某些操作可能出现不允许更改的字段被用户递交更改（往往是那些网页上标记为 disabled 或者 hidden 的字段），
    再例如，允许通过 ../ 访问到不应该被访问的文件等（一般存在于 include 中）。
解决方案：
    所有地方都要进行权限检查（如是否已登录、当前用户是否有足够权限、该项是否可修改等），
    总之，不要相信任何来自用户的数据，URL 当然也是。
</code></pre><h2 id="SESSION-与-COOKIE"><a href="#SESSION-与-COOKIE" class="headerlink" title="SESSION 与 COOKIE"></a>SESSION 与 COOKIE</h2><pre><code>问题展示：
    Session 和 Cookie 是两种用于存储用户当前状态的工具。
    某些开发者不了解 Session 与 Cookie 的区别，误用或者混用，导致敏感信息泄露或者信息篡改。
    Cookie 存储在浏览器上，用户可以查看和修改 Cookie。
解决方案：
    Session 是存储在服务端的数据，一般来说安全可靠；大多数 Session 都是基于 Cookie 实现的
    （在 Cookie 中存储一串 SESSION_ID，在服务器上存储该 SESSION_ID 对应的内容）。
</code></pre><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><pre><code>问题展示：
    首先，用户的 IP 地址一般存储在 REMOTE_ADDR 中，这是唯一的可信的 IP 地址数据（视不同语言而定）。
    然后某些代理服务器，会将用户的真实 IP 地址附加在 header 的 VIA 或 X_FORWARDED_FOR 中（因为REMOTE_ADDR 是代理服务器自身的 IP）。
    所以，要获取用户 IP 地址，一般做法是，判断是否存在 VIA 或者 X_FORWARDED_FOR 头，
    如果存在，则使用它们，如果不存在则使用 REMOTE_ADDR。
    这就产生问题了，X_FORWARDED_FOR 或 VIA 是 HTTP Header，换句话说，它们是可以被伪造的。
    例如，在投票中，如果采信了 X_FORWARDED_FOR，往往意味着被刷票。
解决方案：
    只使用 REMOTE_ADDR 作为获取 IP 的手段。
</code></pre><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><pre><code>问题展示：
    验证码里常见的问题有：非一次性、容易被识别。
解决方案：
    非一次性指的是，同一个验证码可以一直被用下去。一般来说，每进行一次验证码校对（无论正确与否），
    都应该强制更换或清除 Session 中的验证码。
    关于识别问题，在当前科技水平下，不加噪点不加扭曲的验证码几乎是 100% 可识别的。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/fengyinchao/article/details/50775121" target="_blank" rel="external">Web 开发常见安全问题</a><br>    <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="external">浅谈CSRF攻击方式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/25/React-基础知识整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/25/React-基础知识整理/" itemprop="url">
                  React-基础知识整理
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T20:17:11+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/25/React-基础知识整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/25/React-基础知识整理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,971
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="父组件给子组件传递数据时"><a href="#父组件给子组件传递数据时" class="headerlink" title="父组件给子组件传递数据时"></a>父组件给子组件传递数据时</h1><pre><code>向下 -- 通过 Props 传递数据
向上 -- 通过 Props 传递事件    
</code></pre><h1 id="在使用-ES6-的-classes-创建组件时"><a href="#在使用-ES6-的-classes-创建组件时" class="headerlink" title="在使用 ES6 的 classes 创建组件时"></a>在使用 ES6 的 classes 创建组件时</h1><pre><code>构造方法 constructor 中包含：参数为 props
    1.super(props);
        在ES6中 只有使用 super() 方法才能在继承父类的子类中正确获取到子类的 this 。
        super(props)的目的：在constructor中可以使用this.props
    2.this.state = {name: &apos;fanerge&apos;}; // 定义组件状态
    3.this.handleClick = this.handleClick.bind(this); // 为事件处理函数绑定this    
</code></pre><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><pre><code>当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，
把子组件的 state 数据提升至其共同的父组件当中保存。
之后父组件可以通过 props 将状态数据传递到子组件当中。
这样应用当中的状态数据就能够更方便地交流共享了。
</code></pre><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><pre><code>父组件 &gt;&gt; 子组件 （通过 props 来传递）
子组件 &gt;&gt; 父组件 （我们再通过 props 传递一个父组件当中的事件处理函数到子组件当中。）
</code></pre><h1 id="为什么不可变性在React当中非常重要"><a href="#为什么不可变性在React当中非常重要" class="headerlink" title="为什么不可变性在React当中非常重要"></a>为什么不可变性在React当中非常重要</h1><pre><code>Array(9).fill(null); // 定义一个长度为9的空数组。
this.state.squares.slice(); // 对数组this.state.squares的拷贝，返回一个新数组。（不可变数据）
改变应用数据的方式一般分为两种。
    第一种是直接修改已有的变量的值。
    第二种则是将已有的变量替换为一个新的变量。
    Object.assign(target, ...sources) 将源对象复制到目标对象。    
</code></pre><h1 id="函数定义组件（无state和生命周期）"><a href="#函数定义组件（无state和生命周期）" class="headerlink" title="函数定义组件（无state和生命周期）"></a>函数定义组件（无state和生命周期）</h1><h1 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h1><pre><code>强烈建议你在渲染列表项时添加 keys 值。 
</code></pre><h1 id="JSX-基础"><a href="#JSX-基础" class="headerlink" title="JSX 基础"></a>JSX 基础</h1><pre><code>在 JSX 中使用表达式 -- 你可以任意地在 JSX 当中使用 JavaScript 表达式，在 JSX 当中的表达式要包含在大括号里。
    {formatName(user)}; // 运行方法
JSX 本身其实也是一种表达式
    在编译之后，JSX 其实会被转化为普通的 JavaScript 对象。
JSX 属性
    class &gt;&gt; className
    tableindex &gt;&gt; tableIndex
    for &gt;&gt; htmlFor
    你可以使用引号来定义以字符串为值的属性
    也可以使用大括号来定义以 JavaScript 表达式为值的属性    
JSX 嵌套
    如果 JSX 标签是闭合式的，那么你需要在结尾处用 /&gt;, 就好像 XML/HTML 一样
JSX 防注入攻击
    所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。
JSX 代表 Objects
</code></pre><h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><pre><code>将元素渲染到 DOM 中
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  element,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>

更新元素渲染
    this.setState({}); / this.setState((prevState, props) =&gt; {...});    
</code></pre><h1 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h1><pre><code>函数定义组件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Welcome(props) &#123;</div><div class="line">	return (&lt;h1&gt;Hlleo, &#123;props.name&#125;&lt;/h1&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

类定义组件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">	class Welcome extends React.Component &#123;</div><div class="line">		constructor(props) &#123;</div><div class="line">			super(props);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		render() &#123;</div><div class="line">			return (&lt;h1&gt;Hlleo, &#123;this.props.name&#125;&lt;/h1&gt;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	```	</div><div class="line">	组件渲染（使用）</div><div class="line">	&lt;Welcome name=&quot;fanerge&quot; /&gt;</div><div class="line">	组件名称必须以大写字母开头。</div><div class="line">	提取组件 -- 尽量划分为小组件，更利于复用。</div><div class="line">	Props的只读性</div><div class="line">	</div><div class="line">#	State &amp; 生命周期</div><div class="line">	state</div><div class="line">		正确地使用状态</div><div class="line">			this.setState(&#123;comment: &apos;hello&apos;&#125;);</div><div class="line">		状态更新可能是异步的,使用函数来处理。</div><div class="line">			this.setState((prevState, prop) =&gt; (&#123;</div><div class="line">				counter: prevState.counter + prop.increment</div><div class="line">			&#125;));</div><div class="line">		状态更新合并</div><div class="line">			当你调用 setState() 时，React 将你提供的对象合并到当前状态。</div><div class="line">		数据自顶向下流动（单向流动）			</div><div class="line">	生命周期方法</div><div class="line">		componentDidMount ajax、定时器</div><div class="line">		componentWillUnmount </div><div class="line">	</div><div class="line">#	事件处理		</div><div class="line">	与DOM事件区别：绑定属性的命名采用驼峰式写法。</div></pre></td></tr></table></figure>

    &lt;button onClick={activateLasers}&gt;
      Activate Lasers
    &lt;/button&gt;
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我们通常建议在构造函数中绑定或使用属性初始化器语法来避免 this 的问题。</div></pre></td></tr></table></figure>

    1.this.handleClick = this.handleClick.bind(this);
    2.handleClick = () =&gt; {
        console.log(&apos;this is:&apos;, this);
      }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#	条件渲染</div><div class="line">	操作符 if 或条件运算符</div><div class="line">	元素变量</div></pre></td></tr></table></figure>

let button = null;
button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	与运算符 &amp;&amp;（短路）</div><div class="line">	三目运算符（condition ? true : false）</div><div class="line">	阻止组件渲染</div><div class="line">		让 render 方法 return null 即可实现阻止组件渲染。</div><div class="line"></div><div class="line">#	列表 &amp; Keys（map方法）</div><div class="line">	渲染多样的组件</div><div class="line">	基础列表组件</div></pre></td></tr></table></figure>

    function NumberList(props) {
      const numbers = props.numbers;
      const listItems = numbers.map((number) =&gt;
        &lt;li key={number.toString()}&gt;{number}&lt;/li&gt;
      );
      return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
      );
    }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	keys（列表中拥有的一个独一无二的字符串）</div><div class="line">	用keys提取组件（与数组一起使用）</div><div class="line">	元素的key在他的兄弟元素之间应该唯一</div><div class="line">	在jsx中嵌入map()</div><div class="line"></div><div class="line">#	表单</div><div class="line">	&lt;input&gt;,&lt;textarea&gt;, 和 &lt;select&gt;</div><div class="line">	受控组件</div><div class="line">		可变的状态通常保存在组件的 state 中，并且只能用 setState()方法进行更新。</div><div class="line">	textarea标签 -- value属性</div><div class="line">	select标签	</div><div class="line">	多个输入的解决方法</div><div class="line">		你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。</div></pre></td></tr></table></figure>

ES6当中的计算属性名语法来更新与给定输入名称相对应的状态键
this.setState({
  [name]: value
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">	受控组件的替代方法 -- 非受控组件</div><div class="line"></div><div class="line">#	状态提升（state）</div><div class="line">	使用 react 经常会遇到几个组件需要共用状态数据的情况。</div><div class="line">	这种情况下，我们最好将这部分共享的状态提升至他们最近的父组件当中进行管理。</div><div class="line">	始终保持 -- 自上而下的数据流。</div><div class="line"></div><div class="line">#	组合 vs 继承</div><div class="line">	React 具有强大的组合模型，我们建议使用组合而不是继承来复用组件之间的代码。</div><div class="line">	包含关系</div><div class="line">		当有少量子元素时 -- 我们建议这些组件使用 children 属性将子元素直接传递到输出。</div><div class="line">		当你可能需要在组件中有多个入口，这种情况下你可以使用自己约定的属性（left、right、header等等）而不是 children</div><div class="line">	特殊实例</div><div class="line">		有时我们认为组件是其他组件的特殊实例。例如，我们会说 WelcomeDialog 是 Dialog 的特殊实例。</div><div class="line"></div><div class="line">#	React 理念</div><div class="line">	第一步：把 UI 划分出组件层级</div><div class="line">		（单一功能原则）</div><div class="line">	第二步：用 React 创建一个静态版本</div><div class="line">		静态版本 -- 码代码</div><div class="line">		交互 -- 逻辑思考</div><div class="line">	第三步：定义 UI 状态的最小(但完整)表示</div><div class="line">		定义 state</div><div class="line">	第四步：确定你的 State 应该位于哪里	</div><div class="line">		是否提升 state</div><div class="line">	第五步：添加反向数据流	</div><div class="line">		执行父级组件传递过来的事件函数</div><div class="line">	</div><div class="line">#	深入 JSX</div><div class="line">	JSX 只是为 React.createElement(component, props, ...children) 方法提供的语法糖。</div><div class="line">	指定 React 元素类型	</div><div class="line">		React 必须声明</div><div class="line">			import Dialog from &apos;./Dialog&apos;;</div><div class="line">		点表示法</div><div class="line">			MyComponents.DataPicker</div><div class="line">		首字母大写</div><div class="line">			组件名为大写，单页面组件文件也为大写。</div><div class="line">		在运行时选择类型</div><div class="line">	属性		</div><div class="line">		使用 JavaScript 表达式</div><div class="line">		字符串常量 </div><div class="line">			你可以将字符串常量作为属性值传递。</div><div class="line">		默认为 True</div><div class="line">			如果你没有给属性传值，它默认为 true。</div><div class="line">		扩展属性</div><div class="line">			使用 ... 作为扩展操作符来传递整个属性对象。</div><div class="line">	子代	</div><div class="line">		字符串常量（props.children）</div><div class="line">			&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;	</div><div class="line">		JSX</div></pre></td></tr></table></figure>

        &lt;MyContainer&gt;
          &lt;MyFirstComponent /&gt;
          &lt;MySecondComponent /&gt;
        &lt;/MyContainer&gt;
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JavsScript 表达式</div><div class="line">	&lt;MyComponent&gt;&#123;&apos;foo&apos;&#125;&lt;/MyComponent&gt;</div><div class="line">函数</div></pre></td></tr></table></figure>

        &lt;Repeat numTimes={10}&gt;
          {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list&lt;/div&gt;}
        &lt;/Repeat&gt;
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">		布尔值、Null 和 Undefined 被忽略</div><div class="line">	</div><div class="line">#	使用 PropTypes 进行类型检查</div><div class="line">	注意: React.PropTypes 自 React v15.5 起已弃用。请使用 prop-types 库代替。	</div><div class="line">	import PropTypes from &apos;prop-types&apos;;	</div><div class="line">	optionalArray: PropTypes.array</div><div class="line">	JS 原生类型（七种）</div><div class="line">		number、string、bool、symbol、object、array、func</div><div class="line">	元素和节点和类的实例	</div><div class="line">		node、element、PropTypes.instanceOf(Message)</div><div class="line">	限制你的属性值是某个特定值之一	</div><div class="line">		PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;])	</div><div class="line">	限制它为列举类型之一的对象</div></pre></td></tr></table></figure>

    optionalUnion: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number,
        PropTypes.instanceOf(Message)
    ])
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">指定元素类型的数组	</div><div class="line">	PropTypes.arrayOf(PropTypes.number)</div><div class="line">指定类型的对象	</div><div class="line">	PropTypes.objectOf(PropTypes.number)</div><div class="line">指定属性及其类型的对象</div></pre></td></tr></table></figure>

    PropTypes.shape({
        color: PropTypes.string,
        fontSize: PropTypes.number
    })
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">限制为必填（可以加载其他限制后面）	</div><div class="line">	PropTypes.func.isRequired</div><div class="line">限制单个子代</div><div class="line">	PropTypes.element.isRequired</div><div class="line">属性默认值</div></pre></td></tr></table></figure>

    Greeting.defaultProps = {
      name: &apos;Stranger&apos;
    }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">#	Refs &amp; DOM	</div><div class="line">	在典型的 React 数据流中, 属性（props）是父组件与子代交互的唯一方式。</div><div class="line">	要修改子组件，你需要通用新的 props 重新渲染它。</div><div class="line">	但是，某些情况下你需要在典型数据流外强制修改子代。</div><div class="line">	要修改的子代可以是 React 组件实例，也可以是 DOM 元素。</div><div class="line">	何时使用 Refs</div><div class="line">		1.处理焦点、文本选择或媒体控制。</div><div class="line">		2.触发强制动画。</div><div class="line">		3.集成第三方 DOM 库</div><div class="line">	为 DOM 元素添加 Ref</div><div class="line">		当给 HTML 元素添加 ref 属性时，ref 回调接收了底层的 DOM 元素作为参数。</div><div class="line">		&lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">		这里将该DOM元素赋值给this.textInput，通过其能访问到该DOM元素。</div><div class="line">	为类组件添加 Ref</div><div class="line">		当 ref 属性用于使用 class 声明的自定义组件时，ref 的回调接收的是已经加载的 React 实例。</div><div class="line">	Refs 与函数式组件</div><div class="line">		你可以在函数式组件内部使用 ref，只要它指向一个 DOM 元素或者 class 组件。</div><div class="line">	对父组件暴露 DOM 节点</div></pre></td></tr></table></figure>

    // 子组件
    function CustomTextInput(props) {
      return (
        &lt;div&gt;
          &lt;input ref={props.inputRef} /&gt;
        &lt;/div&gt;
      );
    }
    // 父组件
    class Parent extends React.Component {
      render() {
        return (
          &lt;CustomTextInput
            inputRef={el =&gt; this.inputElement = el}
          /&gt;
        );
      }
    }
    // 这时在父组件中的 this.inputElement 即可获得input DOM节点的引用。
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">	findDOMNode()</div><div class="line">		ReactDOM.findDOMNode(component); // 前提是组件已经挂载到DOM中</div><div class="line">	</div><div class="line">#	非受控组件</div><div class="line">		在大多数情况下，我们推荐使用 受控组件 来实现表单。</div><div class="line">		在受控组件中，表单数据由 React 组件处理。</div><div class="line">		如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。</div><div class="line">	默认值</div><div class="line">		&lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt; 支持 defaultChecked，</div><div class="line">		&lt;input&gt; 和 &lt;select&gt; 和 &lt;textarea&gt; 支持 defaultValue.</div><div class="line">	</div><div class="line">#	性能优化	</div><div class="line">	使用生产版本	</div><div class="line">	Create React App方式	</div><div class="line">	避免重复渲染	</div><div class="line">		shouldComponentUpdate(nextProps, nextState)</div><div class="line">		继承React.PureComponent来定义组件</div><div class="line">	不会突变的数据的力量（不可变数据）	</div><div class="line">		Array -- concat()、slice()</div><div class="line">		Object -- Object.assign(&#123;&#125;, obj)、&#123;...obj, right: &apos;blue&apos;&#125;;</div><div class="line">	使用不可突变的数据结构	</div><div class="line">		Immutable.js</div><div class="line">		seamless-immutable.js</div><div class="line">		immutability-helper.js</div><div class="line">	</div><div class="line">#	使用 ES6</div><div class="line">	声明默认属性（静态属性）</div><div class="line">		如果使用 class 关键字创建组件，可以直接把自定义属性对象写到类的 defaultProps 属性中</div><div class="line">	设置初始状态</div><div class="line">		如果使用 class 关键字创建组件，你可以通过在 constructor 中给 this.state 赋值的方式来定义组件的初始状态</div><div class="line">	自动绑定（方法）</div><div class="line">		你需要在 constructor 中为方法手动添加 .bind(this)。</div><div class="line">		Class Properties</div></pre></td></tr></table></figure>

        handleClick = () =&gt; {
            alert(this.state.message);
        }
        ```
</code></pre><h1 id="Mixin-混入"><a href="#Mixin-混入" class="headerlink" title="Mixin(混入)"></a>Mixin(混入)</h1><pre><code>多个组件需要使用同样的逻辑时使用。
</code></pre><h1 id="协调（Reconciliation）"><a href="#协调（Reconciliation）" class="headerlink" title="协调（Reconciliation）"></a>协调（Reconciliation）</h1><pre><code>对比算法
    元素的不同类型（移出旧的DOM树）
    相同类型的DOM元素（只更改部分属性）
    相同类型的组件元素（只更改部分样式）
递归子节点
    Keys（处理循环比对时性能）
</code></pre><h1 id="Context（不建议使用）"><a href="#Context（不建议使用）" class="headerlink" title="Context（不建议使用）"></a>Context（不建议使用）</h1><pre><code>在有些场景中，你不想要向下每层都手动地传递你需要的 props. 这就需要强大的 context API了。
    Redux或Mobx更好的选择。
如何使用Context
父子组件耦合
在生命周期函数中引用Context
在无状态函数组件中引用Context
</code></pre><h1 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h1><pre><code>Portals 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。
    ReactDOM.createPortal(child, container)
    第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或碎片。
    第二个参数（container）则是一个 DOM 元素。
通过 Portals 进行事件冒泡
</code></pre><h1 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h1><h1 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h1><pre><code>高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。
高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。
使用高阶组件（HOC）解决交叉问题
</code></pre><h1 id="与第三方库协同"><a href="#与第三方库协同" class="headerlink" title="与第三方库协同"></a>与第三方库协同</h1><pre><code>与 DOM 节点操作类插件结合 -- jquery
在 React 中使用其他引擎加载页面
在 React 中使用“字符串替换”类的库
在 React 中使用 Backbone 的视图
在 React 中使用其他数据层库和框架
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://doc.react-china.org/docs/hello-world.html" target="_blank" rel="external">官网文档</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/23/React-组件书写方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/23/React-组件书写方式/" itemprop="url">
                  React-组件书写方式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T20:57:29+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/23/React-组件书写方式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/23/React-组件书写方式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  665
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>即将要去做蚂蚁金服的项目了，它们使用的 React 技术。近期将整理一些 React 相关的知识。 
</code></pre><h1 id="createClass"><a href="#createClass" class="headerlink" title="createClass"></a>createClass</h1><pre><code>ES5 定义组件只能使用 createClass    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">const React = require(react);</div><div class="line">const Greeting = React.createClass(&#123;</div><div class="line"></div><div class="line">	// 属性校验 </div><div class="line">	propTypes: &#123;</div><div class="line">		name: React.PropTypes.string </div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	// 默认属性</div><div class="line">	getDefaultProps: function() &#123;</div><div class="line">		return &#123;</div><div class="line">			name: &apos;fanerge&apos; </div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	// 初始化state</div><div class="line">	getInitialState: function() &#123;</div><div class="line">		return &#123;</div><div class="line">			count: this.props.initialCount</div><div class="line">		&#125;;</div><div class="line">	&#125;, </div><div class="line">	</div><div class="line">	// 事件函数</div><div class="line">	handleClick: function() &#123;  &#125;,</div><div class="line">	</div><div class="line">	render: function() &#123;</div><div class="line">		return &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&#123;&#123;this.props.name&#125;&#125;&lt;/h1&gt;</div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = Greeting;</div></pre></td></tr></table></figure>

PS：使用createClass，React对属性中的所有函数都进行了this绑定，也就是如上面的hanleClick其实相当于handleClick.bind(this) 。
</code></pre><h1 id="component"><a href="#component" class="headerlink" title="component"></a>component</h1><pre><code>ES6 的类（语法糖）对原型继承机制进行了封装
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">class Greeting extends React.Component &#123;</div><div class="line"></div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">		// 设置初始值</div><div class="line">		this.state = &#123;count: props.initialCount&#125;;</div><div class="line">		// 为函数绑定 this</div><div class="line">		this.handleClick = this.handleClick.bind(this);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 定义props方式1</div><div class="line">	static defaultProps = &#123;</div><div class="line">		name: &apos;Mary&apos; </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// props验证方式1</div><div class="line">	static propTypes = &#123;</div><div class="line">		name: React.PropTypes.string</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 事件函数</div><div class="line">	handleClick() &#123;  &#125;</div><div class="line">	</div><div class="line">	render() &#123;</div><div class="line">		return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// props验证方式2</div><div class="line">Greeting.propTypes = &#123;</div><div class="line">	name: React.PropTypes.string</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 定义props方式2</div><div class="line">Greeting.defaultProps = &#123;</div><div class="line">	name: &apos;Mary&apos; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default Greeting;</div></pre></td></tr></table></figure>

PS：可以看到Greeting继承自React.component,在构造函数中，通过super()来调用父类的构造函数。
</code></pre><h1 id="PureComponet"><a href="#PureComponet" class="headerlink" title="PureComponet"></a>PureComponet</h1><pre><code>作用：当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class CounterButton extends React.PureComponent &#123;</div><div class="line">	</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">		this.state = &#123;count: 1&#125;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	render() &#123;</div><div class="line">		return(</div><div class="line">			&lt;button</div><div class="line">				color=&#123;this.props.color&#125;</div><div class="line">				onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</div><div class="line">				Count: &#123;this.state.count&#125;</div><div class="line">			&lt;/button&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这种情况下，PureComponent只会对this.props.words进行一次浅比较，虽然数组里面新增了元素，
    但是this.props.words与nextProps.words指向的仍是同一个数组，因此this.props.words !== nextProps.words 
    返回的便是flase，从而导致ListOfWords组件没有重新渲染。
最简单避免上述情况的方式，就是避免使用可变对象作为props和state，取而代之的是每次返回一个全新的对象,如下通过concat来返回新的数组：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">handleClick() &#123;</div><div class="line">  this.setState(prevState =&gt; (&#123;</div><div class="line">	words: prevState.words.concat([&apos;marklar&apos;])</div><div class="line">  &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>

你还可以考虑使用Immutable.js来创建不可变对象，通过它来简化对象比较，提高性能。
</code></pre><h1 id="Stateless-Functional-Component"><a href="#Stateless-Functional-Component" class="headerlink" title="Stateless Functional Component"></a>Stateless Functional Component</h1><pre><code>作用：数据都是通过props传入的时候，我们便可以使用Stateless Functional Component来快速创建组件。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">const Button = (&#123;</div><div class="line">	day, </div><div class="line">	increment</div><div class="line">&#125;) =&gt; &#123;</div><div class="line">	return (</div><div class="line">		&lt;div&gt;</div><div class="line">			&lt;button onClick=&#123;increment&#125;&gt;Today is &#123;day&#125;&lt;/button&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Button.propTypes = &#123;</div><div class="line">	day: PropTypes.string.isRequired,</div><div class="line">	increment: PropTypes.func.isRequired</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h1 id="如何选择（优先级降低）"><a href="#如何选择（优先级降低）" class="headerlink" title="如何选择（优先级降低）"></a>如何选择（优先级降低）</h1><ol>
<li>Stateless Functional Component（无状态、无生命周期）</li>
<li>PureComponent （不可变对象，最好配合Immutable.js使用）</li>
<li>Component</li>
<li>createClass</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="https://segmentfault.com/a/1190000008402834" target="_blank" rel="external">谈一谈创建React Component的几种方式</a><br>    <a href="http://www.cnblogs.com/wonyun/p/5930333.html" target="_blank" rel="external">React创建组件的三种方式及其区别</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/22/js设计模式-外观模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/22/js设计模式-外观模式/" itemprop="url">
                  js设计模式-外观模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T22:17:50+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/22/js设计模式-外观模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/22/js设计模式-外观模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  432
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="外观模式基础"><a href="#外观模式基础" class="headerlink" title="外观模式基础"></a>外观模式基础</h1><pre><code>定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。

外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。

外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。

外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。
</code></pre><h1 id="兼容浏览器事件绑定"><a href="#兼容浏览器事件绑定" class="headerlink" title="兼容浏览器事件绑定"></a>兼容浏览器事件绑定</h1><pre><code>下面是一段未优化过的代码，我们使用了外观模式通过检测浏览器特性的方式来创建一个跨浏览器的使用方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const addEvent = function(el, ev, fn) &#123;</div><div class="line">	if (el.addEventListener) &#123;</div><div class="line">		el.addEventListener(ev, fn, false);</div><div class="line">	&#125; else if (el.attachEvent) &#123;</div><div class="line">		el.attachEvent(`on$&#123;ev&#125;`, fn);</div><div class="line">	&#125; else &#123;</div><div class="line">		el.[`on$&#123;ev&#125;`] = fn;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h1 id="兼容浏览器阻止冒泡、默认事件"><a href="#兼容浏览器阻止冒泡、默认事件" class="headerlink" title="兼容浏览器阻止冒泡、默认事件"></a>兼容浏览器阻止冒泡、默认事件</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let N = window.N || &#123;&#125;;</div><div class="line">N.tools = &#123;</div><div class="line">	stopPropagation(e) &#123;</div><div class="line">		if (e.stopPropagation) &#123;</div><div class="line">			e.stopPropagation();</div><div class="line">		&#125; else &#123;</div><div class="line">			e.cancelBubble = true;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	preventDefault(e) &#123;</div><div class="line">		if (e.preventDefault) &#123;</div><div class="line">			e.preventDefault();</div><div class="line">		&#125; else &#123;</div><div class="line">			e.returnValue = false;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	stopEvent (e) &#123;</div><div class="line">		this.stopPropagation(e);</div><div class="line">		this.preventDefault(e);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/02/28/2353448.html" target="_blank" rel="external">深入理解JavaScript系列（30）：设计模式之外观模式</a><br>    <a href="http://www.cnblogs.com/linda586586/p/4237093.html" target="_blank" rel="external">javascript设计模式-外观模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/22/js设计模式-桥接模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/22/js设计模式-桥接模式/" itemprop="url">
                  js设计模式-桥接模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T08:57:14+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/22/js设计模式-桥接模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/22/js设计模式-桥接模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  745
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="桥接模式基础"><a href="#桥接模式基础" class="headerlink" title="桥接模式基础"></a>桥接模式基础</h1><pre><code>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。
使用场景：事件回调函数、请求接口之间进行桥接、用于连接公开的API代码和私用实现的代码
根据javascript语言的特点，我们将其简化成2个角色：
    （1）扩充抽象类
    （2）具体实现类
</code></pre><h1 id="最简单的桥接模式"><a href="#最简单的桥接模式" class="headerlink" title="最简单的桥接模式"></a>最简单的桥接模式</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var each = function (arr, fn) &#123;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		var val = arr[i];</div><div class="line">		if (fn.call(val, i, val, arr)) &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">var arr = [1, 2, 3, 4];</div><div class="line">each(arr, function (i, v) &#123;</div><div class="line">	arr[i] = v * 2;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

PS：在这个例子中，抽象部分是each函数，也就是上面说的扩充抽象类，实现部分是fn，即具体实现类。抽象部分和实现部分可以独立的进行变化。这个例子虽然简单，但就是一个典型的桥接模式的应用。
</code></pre><h1 id="事件监控"><a href="#事件监控" class="headerlink" title="事件监控"></a>事件监控</h1><pre><code>抽象类 click 事件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">addEvent(element, &apos;click&apos;, getBeerByIdBridge);</div><div class="line">// 提供一个桥梁 将 抽象类和实现类链接起来</div><div class="line">// 作为桥梁</div><div class="line">function getBeerByIdBridge (e) &#123;</div><div class="line">　　getBeerById(this.id, function(beer) &#123;</div><div class="line">　　　　console.log(&apos;Requested Beer: &apos;+beer);</div><div class="line">　　&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

实现类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">	// 通过ID发送请求，然后返回数据</div><div class="line">	asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</div><div class="line">		// callback response</div><div class="line">		callback(resp.responseText);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这里的getBeerByIdBridge就是我们定义的桥，用于将抽象的click事件和getBeerById连接起来，同时将事件源的ID，以及自定义的call函数（console.log输出）作为参数传入到getBeerById函数里。
</code></pre><h1 id="用于连接公开的API代码和私用实现的代码"><a href="#用于连接公开的API代码和私用实现的代码" class="headerlink" title="用于连接公开的API代码和私用实现的代码"></a>用于连接公开的API代码和私用实现的代码</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Public=function()&#123;</div><div class="line">	// 定义的私有变量</div><div class="line">	var secret = 3;</div><div class="line">	// 该函数返回了私有变量，外界可以通过该方法访问该私有变量</div><div class="line">	this.privilegedGetter = function()&#123;</div><div class="line">		 return secret;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var o = new Public();</div><div class="line">var data =o.privilegedGetter();</div></pre></td></tr></table></figure>

PS：如果一个公用的接口抽象了一些也许应该属于私用性的较复杂的任务，那么可以使用桥接模式来收集某些私用性的信息。
    可以用一些具有特殊权利的方法作为桥梁以便访问私用变量空间。这一特例中的桥接性函数又称特权函数。
</code></pre><h1 id="用桥接模式联结多个类"><a href="#用桥接模式联结多个类" class="headerlink" title="用桥接模式联结多个类"></a>用桥接模式联结多个类</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var Class1 =function(a,b,c)&#123;</div><div class="line">	this.a =a;</div><div class="line">	this.b = b;</div><div class="line">	this.c = c;</div><div class="line">&#125;</div><div class="line">var Class2 =function(d)&#123;</div><div class="line">	this.d = d;</div><div class="line">&#125;</div><div class="line">var BridgeClass =function(a,b,c,d)&#123;</div><div class="line">	   this.one = new Class1(a,b,c);</div><div class="line">	   this.two = new Class2(d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这看起来很像是----适配器，的确如此。
    但要注意到本例中实际上并没有客户系统要求提供数据。
    它只不过是用来接纳大量数据并将其发送给责任方的一种辅助性手段。
    此外，BridgeClass也不是一个客户系统已经实现的现有接口。
    引入这个类的目的只不过是要桥接一些类而已。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/pigpigpig4587/article/details/25993191" target="_blank" rel="external">深入理解JavaScript系列（44）：设计模式之桥接模式</a><br>    <a href="http://www.cnblogs.com/lrzw32/p/4957643.html" target="_blank" rel="external">Javascript设计模式理论与实战：桥接模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">123</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共155.1k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="80" height="160" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 100px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/hibiki/hibiki.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
