<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="余真帆, fanerge, web, web前端" />





  <link rel="alternate" href="/atom.xml" title="余真帆的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="前端、web">
<meta property="og:type" content="website">
<meta property="og:title" content="余真帆的博客">
<meta property="og:url" content="https://fanerge.github.io/page/3/index.html">
<meta property="og:site_name" content="余真帆的博客">
<meta property="og:description" content="前端、web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余真帆的博客">
<meta name="twitter:description" content="前端、web">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanerge.github.io/page/3/"/>





  <title>  余真帆的博客 - 前端、web  </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?947609e8bcc46de32a1dca9cc56cd8a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
	<a href="https://github.com/fanerge/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余真帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">一个专注于技术的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/07/js设计模式-享元模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/07/js设计模式-享元模式/" itemprop="url">
                  js设计模式-享元模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-07T20:59:00+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/07/js设计模式-享元模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/07/js设计模式-享元模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  986
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="享元模式的基础"><a href="#享元模式的基础" class="headerlink" title="享元模式的基础"></a>享元模式的基础</h1><pre><code>定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。
使用场景：第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；第二种是应用在DOM层上，
    享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄。
作用：Flyweight中有两个重要概念--内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，
    而外部信息可以在通过外部删除或者保存。
</code></pre><h1 id="内衣厂展示许多商品"><a href="#内衣厂展示许多商品" class="headerlink" title="内衣厂展示许多商品"></a>内衣厂展示许多商品</h1><pre><code>说明：假设有个内衣工厂，目前的产品有50种男士内衣与50种女士内衣，为了推销产品，
    工厂决定生产一些塑料模特来穿上它们的内衣拍成内衣广告。
这里很显然适合使用 &lt;span style=&quot;color: red;&quot;&gt;享元模式&lt;/span&gt; 来组织代码。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 定义塑料模特的构造函数</div><div class="line">var Model = function (sex) &#123;</div><div class="line">	this.sex = sex;</div><div class="line">&#125;</div><div class="line">// 为模特拍照</div><div class="line">Model.prototype.takePhoto = function () &#123;</div><div class="line">	console.log(&apos;sex=&apos; + this.sex + &apos;underwear=&apos; + this.underwear )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实例化一个男模特 和 一个女模特</div><div class="line">var maleModel = new Model(&apos;male&apos;),</div><div class="line">	female    = new Model(&apos;female&apos;);    </div><div class="line">for (var i = 1; i &lt;=50; i++)&#123;</div><div class="line">	// 分别为模特换上 50 件内衣 以及 照相</div><div class="line">	maleModel.underwear = &apos;underwear&apos; + i;</div><div class="line">	maleModel.takePhoto();</div><div class="line">&#125;</div><div class="line">for (var i = 1; i &lt;=50; i++)&#123;</div><div class="line">	// 分别为模特换上 50 件内衣 以及 照相</div><div class="line">	female.underwear = &apos;underwear&apos; + i;</div><div class="line">	femaleModel.takePhoto();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：很显然，这里只需要两个对象便完成这个需求。
</code></pre><h1 id="地图应用（对象池）"><a href="#地图应用（对象池）" class="headerlink" title="地图应用（对象池）"></a>地图应用（对象池）</h1><pre><code>说明：对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取对象。
    如果对象池里没有空闲对象则创建一个新的对象，当获取的对象完成他的职责之后，再进入池子等待被下次获取。
    假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip 。
    当第一次搜索A地点时假设出现了2个小气泡，第二次搜索A附近的B地点的时候页面出现了6个小气泡，
    按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。
    这样第二次搜索结果页面里，我们只需要再创建4个小气泡而不是6个。
</code></pre><h2 id="定义个气泡工厂"><a href="#定义个气泡工厂" class="headerlink" title="定义个气泡工厂"></a>定义个气泡工厂</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var toolTipFactory = (function () &#123;</div><div class="line">	var toolTipPool  = [];   // toolTip 对象池</div><div class="line">	return &#123;</div><div class="line">		create : function () &#123;</div><div class="line">			if(toolTipPool.length === 0)&#123;</div><div class="line">			   var div = document.createElement(&apos;div&apos;);</div><div class="line">			   document.body.appendChild(div);</div><div class="line">			   return div;</div><div class="line">			&#125; else&#123;</div><div class="line">			   return toolTipPool.shift(); //shift a dom</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		recover : function (tooltipDom) &#123;</div><div class="line">			return toolTipPool.push(tooltipDom);  </div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

PS：气泡工厂的对象池为数组是私有属性被包含在工厂闭包里，这个工厂又两个暴露对外的方法，
    create表示获取一个div节点，recover表示回收一个div节点。
</code></pre><h2 id="第一次搜索（2个气泡）"><a href="#第一次搜索（2个气泡）" class="headerlink" title="第一次搜索（2个气泡）"></a>第一次搜索（2个气泡）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [];</div><div class="line">for(var i = 0, str; str = [&apos;A&apos;,&apos;B&apos;][i++])&#123;  // get ary elem</div><div class="line">	var toolTip = toolTipFactory.create();</div><div class="line">	toolTip.innerHTML = str;</div><div class="line">	ary.push(toolTip)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

PS：现在重新回到第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们。
</code></pre><h2 id="现在开始回收节点"><a href="#现在开始回收节点" class="headerlink" title="现在开始回收节点"></a>现在开始回收节点</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(var i = 0 , toolTip ; toolTip = ary[i++])&#123;</div><div class="line">	toolTip.recover(toolTip)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="第二次搜索（6个气泡）"><a href="#第二次搜索（6个气泡）" class="headerlink" title="第二次搜索（6个气泡）"></a>第二次搜索（6个气泡）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i =0 , str; str = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;][i++]; )&#123;</div><div class="line">	var toolTip = toolTipFactory.create();</div><div class="line">	toolTip.innerHTML(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：现在页面中已经出现了6个节点，上一次创建好的节点被共享给了下一次操作。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.jianshu.com/p/a158478c95b5" target="_blank" rel="external">三分钟教会你JS设计模式之享元模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/09/2379774.html" target="_blank" rel="external">深入理解JavaScript系列（37）：设计模式之享元模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/07/js设计模式-状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/07/js设计模式-状态模式/" itemprop="url">
                  js设计模式-状态模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-07T20:15:23+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/07/js设计模式-状态模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/07/js设计模式-状态模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  919
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="状态模式的基础"><a href="#状态模式的基础" class="headerlink" title="状态模式的基础"></a>状态模式的基础</h1><pre><code>定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。
    状态模式是一个非常常用的设计模式，它主要有两个角色组成：
    （1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。
    （2）状态类：表示一种状态，包含其相应的处理方法
作用：状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以可以让代码更加清晰，
    提高应用程序的维护性和扩展性。
使用场景：文件下载（开始、暂停、完成、失败等）、红绿灯
</code></pre><h1 id="红绿灯（红绿黄灯）"><a href="#红绿灯（红绿黄灯）" class="headerlink" title="红绿灯（红绿黄灯）"></a>红绿灯（红绿黄灯）</h1><pre><code>说明：我们简单地通过一个红绿灯的例子来说明状态模式，红绿灯拥有一个状态：哪一种颜色的灯亮了，
每一种颜色的灯亮了之后又各自的动作，一共有红绿黄三种颜色的灯，也就是有三种状态。
</code></pre><h2 id="定义环境类（红绿灯对象）"><a href="#定义环境类（红绿灯对象）" class="headerlink" title="定义环境类（红绿灯对象）"></a>定义环境类（红绿灯对象）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var trafficLight = (function () &#123;</div><div class="line">	var currentLight = null;</div><div class="line">	return &#123;</div><div class="line">		change: function (light) &#123;</div><div class="line">			currentLight = light;</div><div class="line">			currentLight.go();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

PS：上面的代码中，trafficLight是一个红绿灯对象，它有一个局部变量currentLight表示当前亮灯的对象，
    同时返回一个方法，这个方法用来改变红绿灯的状态，并触发相应的处理程序。
</code></pre><h2 id="定义状态类（三种不同颜色的灯）"><a href="#定义状态类（三种不同颜色的灯）" class="headerlink" title="定义状态类（三种不同颜色的灯）"></a>定义状态类（三种不同颜色的灯）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 红灯</div><div class="line">function RedLight() &#123; &#125;</div><div class="line">RedLight.prototype.go = function () &#123;</div><div class="line">	console.log(&quot;this is red light&quot;);</div><div class="line">&#125;</div><div class="line">// 绿灯</div><div class="line">function GreenLight() &#123; &#125;</div><div class="line">GreenLight.prototype.go = function () &#123;</div><div class="line">	console.log(&quot;this is green light&quot;);</div><div class="line">&#125;</div><div class="line">// 黄灯</div><div class="line">function YellowLight() &#123; &#125;</div><div class="line">YellowLight.prototype.go = function () &#123;</div><div class="line">	console.log(&quot;this is yellow light&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这段代码分别定义了红绿黄三种颜色的灯对象，每一个对象都包含一个go方法作为亮灯之后的处理程序。
</code></pre><h2 id="客户端切换不同颜色的灯"><a href="#客户端切换不同颜色的灯" class="headerlink" title="客户端切换不同颜色的灯"></a>客户端切换不同颜色的灯</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">trafficLight.change(new RedLight()); // this is red light</div><div class="line">trafficLight.change(new YellowLight()); // this is yellow light</div></pre></td></tr></table></figure>

PS：通过传入灯对象到change方法中，从而改变红绿灯的状态，触发其相应的处理程序，
这就是一个典型的状态模式的应用。
</code></pre><h1 id="菜单组件（JS组件开发中的状态模式）"><a href="#菜单组件（JS组件开发中的状态模式）" class="headerlink" title="菜单组件（JS组件开发中的状态模式）"></a>菜单组件（JS组件开发中的状态模式）</h1><pre><code>说明：状态模式在开发JS组件时非常有用，我们平时开发组件时很多时候要切换组件的状态，
每种状态有不同的处理方式，这个时候就可以使用状态模式进行开发。比如我们要开发一个菜单组件，
菜单拥有最基本的两种状态：显示和隐藏，相应的显示或隐藏可能会有各自的其他操作。
</code></pre><h2 id="定义一个环境类（菜单对象）"><a href="#定义一个环境类（菜单对象）" class="headerlink" title="定义一个环境类（菜单对象）"></a>定义一个环境类（菜单对象）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Menu() &#123; &#125;</div><div class="line">Menu.prototype.toggle = function (state) &#123;</div><div class="line">	state();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

PS：这个菜单类有一个toggle方法用来切换状态，然后调用相应的处理方法。
</code></pre><h2 id="定义状态类（切换菜单）"><a href="#定义状态类（切换菜单）" class="headerlink" title="定义状态类（切换菜单）"></a>定义状态类（切换菜单）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var menuStates = &#123;</div><div class="line">	&quot;show&quot;: function () &#123;</div><div class="line">		console.log(&quot;the menu is showing&quot;);</div><div class="line">	&#125;,</div><div class="line">	&quot;hide&quot;: function () &#123;</div><div class="line">		console.log(&quot;the menu is hiding&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

PS：通过一个对象menuStates来定义menu的状态，这里有两种状态show和hide，然后拥有相应的处理方法。
</code></pre><h2 id="客户端切换菜单状态"><a href="#客户端切换菜单状态" class="headerlink" title="客户端切换菜单状态"></a>客户端切换菜单状态</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var menu = new Menu();</div><div class="line">menu.toggle(menuStates.show);</div><div class="line">menu.toggle(menuStates.hide);</div></pre></td></tr></table></figure>

PS：这段代码实例化了一个Menu对象，然后分别切换了显示和隐藏两种状态，如果有第三种状态，
我们只需要menuStates添加相应的状态和处理程序即可。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/18/2437099.html" target="_blank" rel="external">深入理解JavaScript系列（43）：设计模式之状态模式</a><br>    <a href="http://www.cnblogs.com/lrzw32/p/4994817.htm" target="_blank" rel="external">Javascript设计模式理论与实战：状态模式</a><br>    <a href="http://luopq.com/2015/11/25/design-pattern-state/" target="_blank" rel="external">Javascript设计模式理论与实战：状态模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/06/js设计模式-职责链模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/06/js设计模式-职责链模式/" itemprop="url">
                  js设计模式-职责链模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T21:11:22+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/06/js设计模式-职责链模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/06/js设计模式-职责链模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  879
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="职责链模式的基础"><a href="#职责链模式的基础" class="headerlink" title="职责链模式的基础"></a>职责链模式的基础</h1><pre><code>定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。
    将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。
    职责链模式的名字非常形象，一系列可能会处理请求的对象被该连接成一条链，请求在这些对象之间依次传递，
    直到遇到一个可以处理它的对象，我们把这些对象成为链中的节点。
优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。
使用场景：挤公交车递钱（只有售票元可以收钱）、交押金预定手机
</code></pre><h1 id="交押金预定手机"><a href="#交押金预定手机" class="headerlink" title="交押金预定手机"></a>交押金预定手机</h1><blockquote>
<p>   假设一个电视网站对于某部新上市的手机经过了2轮缴纳500元定金与200元定金的预定，现在已经到了正式购买的阶段。<br>    支付了500元定金的用户在购买阶段可以使用100元优惠券，200元定金可以使用50元优惠券，普通用户没有如果没有库存不一定能买到。<br>    约定：<br>    orderType: 表示订单类型(定金或者普通用户),code的值为1时候是500元定金用户，为2是200元定金用户，为3则是普通用户。<br>    pay : 表示用户是否支付定金，用户虽然下过500元定金的订单但是如果他一直没有支付定金，那么只能降级为普通用户。<br>    stock : 仅用户普通用户的库存数量，定金用户不受限制。</p>
</blockquote>
<pre><code>首先定义三种预定的客户的订单并且让每种客户订单有满足当前预定条件和不满足当前预定条件（需后面继续处理）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 500 元客户订单</div><div class="line">var order500 = function (orderType,pay,stock) &#123;</div><div class="line">	if(orderType === 1 &amp;&amp; pay)&#123;</div><div class="line">		 console.log(&apos;500 rmb deposit, get 100 coupon &apos;)</div><div class="line">	&#125; else &#123;</div><div class="line">		return &apos;nextSuccessor&apos;  // unknow the next node but always pass to next.</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 200 元客户订单</div><div class="line">var order200 = function (orderType,pay,stock) &#123;</div><div class="line">	if(orderType === 2 &amp;&amp; pay)&#123;</div><div class="line">		console.log(&apos;200 rmb deposit , get 50 coupon&apos;)</div><div class="line">	&#125; else&#123;</div><div class="line">		 return &apos;nextSuccessor&apos;; </div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 无预约客户订单</div><div class="line">var orderNormal = function (orderType,pay,stock) &#123;</div><div class="line">	if(stock &gt; 0)&#123;</div><div class="line">		 console.log(&apos;normal buy no coupon&apos;)</div><div class="line">	&#125; else&#123;</div><div class="line">		 console.log(&apos;the stock lack&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 定制职责链对象（作用是形成订单职责链）</div><div class="line">var Chain = function (fn) &#123;</div><div class="line">	this.fn = fn;</div><div class="line">	this.successor = null;</div><div class="line">&#125;;</div><div class="line">// 设置职责链</div><div class="line">Chain.prototype.setNextSuccessor = function (successor) &#123;</div><div class="line">	return this.successor = successor;</div><div class="line">&#125;;</div><div class="line">// 设置每个节点的调用方式</div><div class="line">Chain.prototype.passRequest = function () &#123;</div><div class="line">	var ret = this.fn.apply(this.arguments);</div><div class="line">	if(ret === &apos;nextSuccessor&apos;)&#123;</div><div class="line">		return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments)</div><div class="line">	&#125;</div><div class="line">	return ret;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 现在我们把3个订单函数分别包装成职责链的节点</div><div class="line">var chainOrder500 = new Chain(order500);</div><div class="line">var chainOrder200 = new Chain(order200);</div><div class="line">var chainOrderNormal = new Chain(orderNormal);</div><div class="line"></div><div class="line">// 这里我们把上面封装的节点连成一条线，依次判断执行</div><div class="line">chainOrder500.setNextSuccessor(chainOrder200)</div><div class="line">chainOrder200.setNextSuccessor(chainOrderNormal)</div><div class="line"></div><div class="line">// 测试代码</div><div class="line">chainOrder500.passRequest(1,true,6); // 500 rmb deposit, get 100 coupon</div><div class="line">chainOrder500.passRequest(2,true,4); // 200 rmb deposit , get 50 coupon</div></pre></td></tr></table></figure>

假如我们又想支持，300元定金购买，那我们就在改链中增加一个节点即可
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var order300 = function () &#123;</div><div class="line">// todo</div><div class="line">&#125;;</div><div class="line">chainOrder300 = new Chain(chainOrder300)</div><div class="line">chainOrder500.setNextSuccessor(chainOrder300)</div><div class="line">chainOrder300.setNextSuccessor(chainOrder200)</div></pre></td></tr></table></figure>

我们可以自由灵活的增加移除和链中的节点顺序，这样就很简单能满足瞬息万变的需求了。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.jianshu.com/p/19b0033423be" target="_blank" rel="external">三分钟教会你JS设计模式之职责链模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/10/2435381.html" target="_blank" rel="external">深入理解JavaScript系列（38）：设计模式之职责链模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/06/js设计模式-备忘录模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/06/js设计模式-备忘录模式/" itemprop="url">
                  js设计模式-备忘录模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:00:30+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/06/js设计模式-备忘录模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/06/js设计模式-备忘录模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  765
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="备忘录模式的基础"><a href="#备忘录模式的基础" class="headerlink" title="备忘录模式的基础"></a>备忘录模式的基础</h1><pre><code>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    这样就可以将该对象恢复到原先保存的状态
作用：在我们的开发中偶尔会遇到这样一种情况，需要对用户的行为进行撤销。要想实现撤销，
    首先需要保存软件系统的历史状态，当用户执行撤销时用之前的状态覆盖当前状态。
    本节介绍的备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便的回到一个特定的历史步骤。
    备忘录模式在js中经常用于数据缓存。        
使用场景：分页控件、撤销组件    
</code></pre><h1 id="分页控件"><a href="#分页控件" class="headerlink" title="分页控件"></a>分页控件</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var Page = function()&#123;</div><div class="line">	let page = 1,</div><div class="line">		cache = &#123;&#125;,</div><div class="line">		data;</div><div class="line">	return function( page )&#123;</div><div class="line">		if ( cache[ page ] )&#123;</div><div class="line">				data =  cache[ page ];</div><div class="line">				render( data );</div><div class="line">		&#125;else&#123;</div><div class="line">				Ajax.send( &apos;cgi.xx.com/xxx&apos;, function( data )&#123;</div><div class="line">				   cache[ page ] = data;</div><div class="line">				   render( data );</div><div class="line">				&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>

PS：分页控件, 从服务器获得某一页的数据后可以存入缓存。以后再翻回这一页的时候，
    可以直接使用缓存里的数据而无需再次请求服务器。
</code></pre><h1 id="撤销组件"><a href="#撤销组件" class="headerlink" title="撤销组件"></a>撤销组件</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// 备忘录构造函数</div><div class="line">var Memento = function(state)&#123;</div><div class="line">	var _state = state;</div><div class="line">	this.getState = function()&#123;</div><div class="line">		return _state;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 原法器，saveStateToMemento创建一个备忘录，存储当前状态。</div><div class="line">var Originator = function()&#123;</div><div class="line">	var _state;</div><div class="line">	this.setState = function(state)&#123;</div><div class="line">		_state = state;</div><div class="line">	&#125;</div><div class="line">	this.getState = function()&#123;</div><div class="line">		return _state;</div><div class="line">	&#125;</div><div class="line">	this.saveStateToMemento = function()&#123;</div><div class="line">		return new Memento(_state)</div><div class="line">	&#125;</div><div class="line">	this.getStateFromMemento = function(memento)&#123;</div><div class="line">		_state = memento.getState();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// CareTaker称之为负责人也可以叫管理者，它负责保存备忘录</div><div class="line">var CareTaker = function()&#123;</div><div class="line">	var _mementoList = [];</div><div class="line">	this.add = function(memento)&#123;</div><div class="line">		_mementoList.push(memento);</div><div class="line">	&#125;</div><div class="line">	this.get = function(index)&#123;</div><div class="line">		return _mementoList[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">var originator = new Originator();</div><div class="line">var careTaker = new CareTaker();</div><div class="line">originator.setState(&quot;State 1&quot;);</div><div class="line">originator.setState(&quot;State 2&quot;);</div><div class="line">careTaker.add(originator.saveStateToMemento());</div><div class="line">originator.setState(&quot;State 3&quot;);</div><div class="line">careTaker.add(originator.saveStateToMemento());</div><div class="line">originator.setState(&quot;State 4&quot;);</div><div class="line"> </div><div class="line">console.log(&quot;当前状态: &quot; + originator.getState());</div><div class="line">// 当前状态: State 4</div><div class="line">originator.getStateFromMemento(careTaker.get(0));</div><div class="line">console.log(&quot;恢复第一次保存状态: &quot; + originator.getState());</div><div class="line">// 恢复第一次保存状态: State 2</div><div class="line">originator.getStateFromMemento(careTaker.get(1));</div><div class="line">console.log(&quot;恢复第二次保存: &quot; + originator.getState());</div><div class="line">// 恢复第二次保存: State 3</div></pre></td></tr></table></figure>

PS：这个例子里面Originator称为原发器，可以通过saveStateToMemento创建一个备忘录，存储当前状态。
    Memento是一个备忘录对象，只供原发器使用，提供状态提取方法。CareTaker称之为负责人也可以叫管理者，
    它负责保存备忘录，但是不能对备忘录内容进行操作或检查。
优点：
    * 提供了一种状态恢复的时间机制，使得用户可以方便的回退到一个特定的历史步骤。
    * 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。
缺点：
    * 备忘录模式的主要缺点是资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免的需要占用大量的存储空间。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://www.isjs.cn/?p=998" target="_blank" rel="external">《javascript设计模式 – 备忘录模式》</a><br>    <a href="http://www.alloyteam.com/2012/10/commonly-javascript-design-patterns-memorandum-mode/" target="_blank" rel="external">【Javascript设计模式14】-备忘录模式</a>    </p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/05/前端同学需要了解通信知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/05/前端同学需要了解通信知识/" itemprop="url">
                  前端同学需要了解的通信知识
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T18:15:14+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/通信协议/" itemprop="url" rel="index">
                    <span itemprop="name">通信协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/05/前端同学需要了解通信知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/05/前端同学需要了解通信知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3,456
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="head、options、get、put、post、delete含义与区别"><a href="#head、options、get、put、post、delete含义与区别" class="headerlink" title="head、options、get、put、post、delete含义与区别"></a>head、options、get、put、post、delete含义与区别</h1><pre><code>了解它们的区别，这对于 RESTful架构 来说非常有意义。
</code></pre><p>如果你还不知道什么叫 <a href="https://fanerge.github.io/2017/10/13/RESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/">RESTful架构</a>？</p>
<h2 id="HEAD请求（判断资源是否存在）"><a href="#HEAD请求（判断资源是否存在）" class="headerlink" title="HEAD请求（判断资源是否存在）"></a>HEAD请求（判断资源是否存在）</h2><pre><code>HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。
有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，
我们通常使用GET，但这里用HEAD则意义更加明确。
</code></pre><h2 id="OPTIONS请求（获取当前URL支持的方法）"><a href="#OPTIONS请求（获取当前URL支持的方法）" class="headerlink" title="OPTIONS请求（获取当前URL支持的方法）"></a>OPTIONS请求（获取当前URL支持的方法）</h2><pre><code>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。
若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
</code></pre><h2 id="POST请求（相当于数据库操作–增）"><a href="#POST请求（相当于数据库操作–增）" class="headerlink" title="POST请求（相当于数据库操作–增）"></a>POST请求（相当于数据库操作–增）</h2><pre><code>POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，
就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。
</code></pre><h2 id="DELETE请求（相当于数据库操作–删）"><a href="#DELETE请求（相当于数据库操作–删）" class="headerlink" title="DELETE请求（相当于数据库操作–删）"></a>DELETE请求（相当于数据库操作–删）</h2><pre><code>DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。
</code></pre><h2 id="PUT请求（相当于数据库操作–改）"><a href="#PUT请求（相当于数据库操作–改）" class="headerlink" title="PUT请求（相当于数据库操作–改）"></a>PUT请求（相当于数据库操作–改）</h2><pre><code>PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，
用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。
</code></pre><h2 id="GET请求（相当于数据库操作–查）"><a href="#GET请求（相当于数据库操作–查）" class="headerlink" title="GET请求（相当于数据库操作–查）"></a>GET请求（相当于数据库操作–查）</h2><pre><code>GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，
只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。
无论进行多少次操作，结果都是一样的。
</code></pre><h1 id="常见的-GET-和-POST-的区别（浅比较）"><a href="#常见的-GET-和-POST-的区别（浅比较）" class="headerlink" title="常见的 GET 和 POST 的区别（浅比较）"></a>常见的 GET 和 POST 的区别（浅比较）</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/get%E5%92%8Cpost.png" alt="get和post的区别"><br>    这些都是比较常见的，我就直接借用下<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="external">杨光</a>的总结。</p>
<h1 id="也许这才是面试官想要的"><a href="#也许这才是面试官想要的" class="headerlink" title="也许这才是面试官想要的"></a>也许这才是面试官想要的</h1><p>上面我们的分析都是从<a href="https://fanerge.github.io/2017/10/14/OSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">TCP/IP五层网络架构</a>中的 <span style="color: red;">应用层</span> 和 生产使用时做了区别，<br>这里我们就进入更底层的 <span style="color: red;">传输层 </span>的分析吧！</p>
<blockquote>
<p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>这里你只需要知道这个就好了，更详细请访问<a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="external">get与post的区别</a>。    </p>
</blockquote>
<h1 id="总结一下-http-状态码"><a href="#总结一下-http-状态码" class="headerlink" title="总结一下 http 状态码"></a>总结一下 http 状态码</h1><p><img src="http://oxpnrlb4j.bkt.clouddn.com/http%E7%8A%B6%E6%80%81%E7%A0%81%E6%B1%87%E6%80%BB.png" alt="通用的http状态码"><br>    看着这些是不是有些头大，下面我为大家总结一些通用的状态码。<br>    100-199 用于指定客户端应相应的某些动作。<br>    200-299 用于表示请求成功。<br>    300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>    400-499 用于指出客户端的错误。<br>    500-599 用于支持服务器错误。</p>
<h2 id="1"><a href="#1" class="headerlink" title="1**"></a>1**</h2><h3 id="100-Continue-继续"><a href="#100-Continue-继续" class="headerlink" title="100 (Continue/继续)"></a>100 (Continue/继续)</h3><pre><code>如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。
在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端
不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 
</code></pre><h3 id="101-Switching-Protocols-转换协议"><a href="#101-Switching-Protocols-转换协议" class="headerlink" title="101 (Switching Protocols/转换协议)"></a>101 (Switching Protocols/转换协议)</h3><pre><code>指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 
</code></pre><h2 id="2"><a href="#2" class="headerlink" title="2**"></a>2**</h2><h3 id="200-OK-正常"><a href="#200-OK-正常" class="headerlink" title="200 (OK/正常)"></a>200 (OK/正常)</h3><pre><code>200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；
如果没有调用setStatus方法的话，就会得到200。 
</code></pre><h3 id="201-Created-已创建"><a href="#201-Created-已创建" class="headerlink" title="201 (Created/已创建)"></a>201 (Created/已创建)</h3><pre><code>201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。
</code></pre><h3 id="202-Accepted-接受"><a href="#202-Accepted-接受" class="headerlink" title="202 (Accepted/接受)"></a>202 (Accepted/接受)</h3><pre><code>202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。 
</code></pre><h3 id="203-Non-Authoritative-Information-非官方信息"><a href="#203-Non-Authoritative-Information-非官方信息" class="headerlink" title="203 (Non-Authoritative Information/非官方信息)"></a>203 (Non-Authoritative Information/非官方信息)</h3><pre><code>状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的
是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 
</code></pre><h3 id="204-No-Content-无内容"><a href="#204-No-Content-无内容" class="headerlink" title="204 (No Content/无内容)"></a>204 (No Content/无内容)</h3><pre><code>在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于
用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet
可能作如下操作： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int pageVersion =Integer.parseInt(request.getParameter(&quot;pageVersion&quot;));</div><div class="line">if (pageVersion &gt;;= currentVersion) &#123;</div><div class="line">   response.setStatus(response.SC_NO_CONTENT);</div><div class="line">&#125; else &#123;</div><div class="line">	   // Create regular page</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="205-Reset-Content-重置内容"><a href="#205-Reset-Content-重置内容" class="headerlink" title="205 (Reset Content/重置内容)"></a>205 (Reset Content/重置内容)</h3><pre><code>重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用
于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 
</code></pre><h3 id="206-Partial-Content-局部内容"><a href="#206-Partial-Content-局部内容" class="headerlink" title="206 (Partial Content/局部内容)"></a>206 (Partial Content/局部内容)</h3><pre><code>206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。
这是 HTTP 1.1中新加入的。 
</code></pre><h2 id="3"><a href="#3" class="headerlink" title="3**"></a>3**</h2><h3 id="300-Multiple-Choices-多重选择"><a href="#300-Multiple-Choices-多重选择" class="headerlink" title="300 (Multiple Choices/多重选择)"></a>300 (Multiple Choices/多重选择)</h3><pre><code>300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。
如果服务器有首选设置，首选项将会被列于定位响应头信息中。 
</code></pre><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 (Moved Permanently)"></a>301 (Moved Permanently)</h3><pre><code>永久性重定向。 
</code></pre><h3 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 (Move temporarily)"></a>302 (Move temporarily)</h3><pre><code>临时性重定向。
</code></pre><h3 id="303-See-Other-参见其他信息"><a href="#303-See-Other-参见其他信息" class="headerlink" title="303 (See Other/参见其他信息)"></a>303 (See Other/参见其他信息)</h3><pre><code>与301类似，使用GET和POST请求查看
</code></pre><h3 id="304-Not-Modified-未更改"><a href="#304-Not-Modified-未更改" class="headerlink" title="304 (Not Modified/未更改)"></a>304 (Not Modified/未更改)</h3><pre><code>当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后
有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被
更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这
个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程
已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化
和页面修正日期的例子)给出。 
</code></pre><h3 id="305-Use-Proxy-使用代理"><a href="#305-Use-Proxy-使用代理" class="headerlink" title="305 (Use Proxy/使用代理)"></a>305 (Use Proxy/使用代理)</h3><pre><code>305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="307-Temporary-Redirect-临时重定向"><a href="#307-Temporary-Redirect-临时重定向" class="headerlink" title="307 (Temporary Redirect/临时重定向)"></a>307 (Temporary Redirect/临时重定向)</h3><pre><code>与302类似，使用GET请求重定向。 
</code></pre><h2 id="4"><a href="#4" class="headerlink" title="4**"></a>4**</h2><h3 id="400-Bad-Request-错误请求"><a href="#400-Bad-Request-错误请求" class="headerlink" title="400 (Bad Request/错误请求)"></a>400 (Bad Request/错误请求)</h3><pre><code>400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。 
</code></pre><h3 id="401-Unauthorized-未授权"><a href="#401-Unauthorized-未授权" class="headerlink" title="401 (Unauthorized/未授权)"></a>401 (Unauthorized/未授权)</h3><pre><code>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。
这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。” 
</code></pre><h3 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 (Forbidden/禁止)"></a>403 (Forbidden/禁止)</h3><pre><code>403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于
服务器上的损坏文件或目录许可而引起。 
</code></pre><h3 id="404-Not-Found-未找到"><a href="#404-Not-Found-未找到" class="headerlink" title="404 (Not Found/未找到)"></a>404 (Not Found/未找到)</h3><pre><code>404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。
它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有
专门的方法实现它：sendError(&quot;message&quot;)。相对于setStatus使用sendError得好处是：服务器会自动
生成一个错误页来显示错误信息。
</code></pre><h3 id="405-Method-Not-Allowed-方法未允许"><a href="#405-Method-Not-Allowed-方法未允许" class="headerlink" title="405 (Method Not Allowed/方法未允许)"></a>405 (Method Not Allowed/方法未允许)</h3><pre><code>405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源
不允许使用。该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="406-Not-Acceptable-无法访问"><a href="#406-Not-Acceptable-无法访问" class="headerlink" title="406 (Not Acceptable/无法访问)"></a>406 (Not Acceptable/无法访问)</h3><pre><code>406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。
406是新加入 HTTP 1.1中的。 
</code></pre><h3 id="407-Proxy-Authentication-Required-代理服务器认证要求"><a href="#407-Proxy-Authentication-Required-代理服务器认证要求" class="headerlink" title="407 (Proxy Authentication Required/代理服务器认证要求)"></a>407 (Proxy Authentication Required/代理服务器认证要求)</h3><pre><code>407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。
该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头
信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="408-Request-Timeout-请求超时"><a href="#408-Request-Timeout-请求超时" class="headerlink" title="408 (Request Timeout/请求超时)"></a>408 (Request Timeout/请求超时)</h3><pre><code>408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="409-Conflict-冲突"><a href="#409-Conflict-冲突" class="headerlink" title="409 (Conflict/冲突)"></a>409 (Conflict/冲突)</h3><pre><code>该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="410-Gone-已经不存在"><a href="#410-Gone-已经不存在" class="headerlink" title="410 (Gone/已经不存在)"></a>410 (Gone/已经不存在)</h3><pre><code>410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。
410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。
该状态码是新加入 HTTP 1.1中的。 
</code></pre><h3 id="411-Length-Required-需要数据长度"><a href="#411-Length-Required-需要数据长度" class="headerlink" title="411 (Length Required/需要数据长度)"></a>411 (Length Required/需要数据长度)</h3><pre><code>411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端
发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="412-Precondition-Failed-先决条件错误"><a href="#412-Precondition-Failed-先决条件错误" class="headerlink" title="412 (Precondition Failed/先决条件错误)"></a>412 (Precondition Failed/先决条件错误)</h3><pre><code>412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="413-Request-Entity-Too-Large-请求实体过大"><a href="#413-Request-Entity-Too-Large-请求实体过大" class="headerlink" title="413 (Request Entity Too Large/请求实体过大)"></a>413 (Request Entity Too Large/请求实体过大)</h3><pre><code>413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。
如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="414-Request-URI-Too-Long-请求URI过长"><a href="#414-Request-URI-Too-Long-请求URI过长" class="headerlink" title="414 (Request URI Too Long/请求URI过长)"></a>414 (Request URI Too Long/请求URI过长)</h3><pre><code>414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、
域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。
该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="415-Unsupported-Media-Type-不支持的媒体格式"><a href="#415-Unsupported-Media-Type-不支持的媒体格式" class="headerlink" title="415 (Unsupported Media Type/不支持的媒体格式)"></a>415 (Unsupported Media Type/不支持的媒体格式)</h3><pre><code>415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="416-Requested-Range-Not-Satisfiable-请求范围无法满足"><a href="#416-Requested-Range-Not-Satisfiable-请求范围无法满足" class="headerlink" title="416 (Requested Range Not Satisfiable/请求范围无法满足)"></a>416 (Requested Range Not Satisfiable/请求范围无法满足)</h3><pre><code>416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。
奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。 
</code></pre><h3 id="417-Expectation-Failed-期望失败"><a href="#417-Expectation-Failed-期望失败" class="headerlink" title="417 (Expectation Failed/期望失败)"></a>417 (Expectation Failed/期望失败)</h3><pre><code>如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的
请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态
告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 
</code></pre><h2 id="5"><a href="#5" class="headerlink" title="5**"></a>5**</h2><h3 id="500-Internal-Server-Error-内部服务器错误"><a href="#500-Internal-Server-Error-内部服务器错误" class="headerlink" title="500 (Internal Server Error/内部服务器错误)"></a>500 (Internal Server Error/内部服务器错误)</h3><pre><code>500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能
（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。 
</code></pre><h3 id="501-Not-Implemented-未实现"><a href="#501-Not-Implemented-未实现" class="headerlink" title="501 (Not Implemented/未实现)"></a>501 (Not Implemented/未实现)</h3><pre><code>501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT
这样的服务器并不支持的命令。 
</code></pre><h3 id="502-Bad-Gateway-错误的网关"><a href="#502-Bad-Gateway-错误的网关" class="headerlink" title="502 (Bad Gateway/错误的网关)"></a>502 (Bad Gateway/错误的网关)</h3><pre><code>502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 
</code></pre><h3 id="503-Service-Unavailable-服务无法获得"><a href="#503-Service-Unavailable-服务无法获得" class="headerlink" title="503 (Service Unavailable/服务无法获得)"></a>503 (Service Unavailable/服务无法获得)</h3><pre><code>状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程
或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户
端什么时候可以在试一次。 
</code></pre><h3 id="504-Gateway-Timeout-网关超时"><a href="#504-Gateway-Timeout-网关超时" class="headerlink" title="504 (Gateway Timeout/网关超时)"></a>504 (Gateway Timeout/网关超时)</h3><pre><code>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。
该状态是新加入 HTTP 1.1的。 
</code></pre><h3 id="505-HTTP-Version-Not-Supported-不支持的-HTTP-版本"><a href="#505-HTTP-Version-Not-Supported-不支持的-HTTP-版本" class="headerlink" title="505 (HTTP Version Not Supported/不支持的 HTTP 版本)"></a>505 (HTTP Version Not Supported/不支持的 HTTP 版本)</h3><pre><code>505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。
该状态是新加入 HTTP 1.1的。
</code></pre><h1 id="http-缓存相关"><a href="#http-缓存相关" class="headerlink" title="http 缓存相关"></a>http 缓存相关</h1><p>这里关于前端仔 http缓存相关的知识，我就不再总结了，有兴趣的同学可以访问我<a href="https://fanerge.github.io/2017/09/01/http%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">http缓存相关的知识</a>。</p>
<blockquote>
<p>   参考文档：<br>    <a href="http://www.cnblogs.com/testcoffee/p/6295970.html" target="_blank" rel="external">get、put、post、delete含义与区别</a><br>    <a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="external">HTTP协议中GET和POST方法的区别</a><br>    <a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="external">99%的人都理解错了HTTP中GET与POST的区别</a><br>    <a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin" target="_blank" rel="external">有同学不好翻墙，就看百度的http状态码吧</a><br>    <a href="http://www.cnblogs.com/lxinxuan/archive/2009/10/22/1588053.html" target="_blank" rel="external">HTTP状态码大全</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/02/js设计模式-组合模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/02/js设计模式-组合模式/" itemprop="url">
                  js设计模式-组合模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-02T19:57:34+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/02/js设计模式-组合模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/02/js设计模式-组合模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  546
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="组合模式的基础"><a href="#组合模式的基础" class="headerlink" title="组合模式的基础"></a>组合模式的基础</h1><pre><code>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，
    组合模式使得用户对单个对象和组合对象的使用具有一致性。
作用：组合模式让你可以优化处理递归或分级数据结构。
使用场景：系统目录结构、网站导航结构、文件扫描、DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、
    删除、遍历子节点的通用功能。
该模式由两部分构成：
    1.子对象（Leaf）：组成组合对象的最基本对象。
    2.组合对象（Composite）：由子对象组合起来的复杂对象。
</code></pre><h1 id="组合模式的例子"><a href="#组合模式的例子" class="headerlink" title="组合模式的例子"></a>组合模式的例子</h1><pre><code>文件扫描
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// 定义组合对象（文件夹）</div><div class="line">let Folder = function( name )&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.files = [];</div><div class="line">&#125;;</div><div class="line">Folder.prototype.add = function( file )&#123;</div><div class="line">	this.files.push( file );</div><div class="line">&#125;;</div><div class="line">Folder.prototype.scan = function()&#123;</div><div class="line">	console.log(&apos;开始文件扫描:&apos; + this.name);</div><div class="line">	for( let i = 0, file, files = this.files; file = files[i++]; )&#123;</div><div class="line">		file.scan();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//定义叶子对象（文件）</div><div class="line">let File = function( name )&#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;;</div><div class="line">File.prototype.add = function()&#123;</div><div class="line">	throw new Error(&apos;文件下面不能再添加文件&apos;);</div><div class="line">&#125;;</div><div class="line">File.prototype.scan = function()&#123;</div><div class="line">	console.log(&apos;开始扫瞄：&apos; + this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let folder = new Folder(&apos;前端学习&apos;);</div><div class="line">let folder1 = new Folder(&apos;JS学习&apos;);</div><div class="line">let folder2 = new Folder(&apos;JQ学习&apos;);</div><div class="line"></div><div class="line">let file1 = new File(&apos;JS设计模式&apos;);</div><div class="line">let file2 = new File(&apos;JQ实战&apos;);</div><div class="line">let file3 = new File(&apos;前端性能&apos;);</div><div class="line"></div><div class="line">folder1.add(file1);</div><div class="line">folder2.add(file2);</div><div class="line">folder.add(folder1);</div><div class="line">folder.add(folder2);</div><div class="line">folder.add(file3);</div><div class="line">folder.scan();</div><div class="line"></div><div class="line">// 输出</div><div class="line">开始文件扫描：前端学习</div><div class="line">开始文件扫描：JS学习</div><div class="line">开始扫瞄：JS设计模式</div><div class="line">开始文件扫描：JQ学习</div><div class="line">开始扫瞄：JQ实战</div><div class="line">开始扫瞄：前端性能</div></pre></td></tr></table></figure>

PS：父类和子类必须具有相同的接口（方法），只不过它们相同的方法具有的功能不相同，
    例如父类的实例具有 add 方法作用是，可以添加文件夹 或者 文件。子类的实例具有 
    add 方法则不能添加文件夹 或者 文件，却抛出一个错误（子类重写父类的方法）。 
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://github.com/fanerge/Study-Notes/blob/master/2017%E5%B9%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9B%86%E5%90%88/0521%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.txt" target="_blank" rel="external">0521组合模式</a><br>    <a href="http://www.cnblogs.com/TomXu/archive/2012/04/12/2435530.html" target="_blank" rel="external">深入理解JavaScript系列（40）：设计模式之组合模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/01/js设计模式-模版方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/01/js设计模式-模版方法模式/" itemprop="url">
                  js设计模式-模版方法模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T20:48:34+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/01/js设计模式-模版方法模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/01/js设计模式-模版方法模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  554
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h1><pre><code>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，
    一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中
    所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，
    从而实现自己的业务逻辑。

使用场景：
</code></pre><ol>
<li>泡饮品（茶 和 coffee）</li>
<li>公司面试（百度面试 和 阿里面试）</li>
</ol>
<h1 id="IT公司面试"><a href="#IT公司面试" class="headerlink" title="IT公司面试"></a>IT公司面试</h1><pre><code>下面就以IT公司面试作为父类，百度面试作为子类来实现面试流程模版方法。
（1.笔试 &gt;&gt; 2.技术面试 &gt;&gt; 3.领导面试 &gt;&gt; 4.等offer）
</code></pre><h2 id="定义父类"><a href="#定义父类" class="headerlink" title="定义父类"></a>定义父类</h2><pre><code>let ITInterview = function(){};
</code></pre><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 笔试</div><div class="line">ITInterview.prototype.writtenTest = function()&#123;</div><div class="line">	console.log(&quot;某公司笔试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 技术面试</div><div class="line">ITInterview.prototype.technicalInterview = function()&#123;</div><div class="line">	console.log(&quot;某公司技术面试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="领导面试"><a href="#领导面试" class="headerlink" title="领导面试"></a>领导面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 领导面试</div><div class="line">ITInterview.prototype.leader = function()&#123;</div><div class="line">	console.log(&quot;某公司leader来面试了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="等offer"><a href="#等offer" class="headerlink" title="等offer"></a>等offer</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 等通知</div><div class="line">ITInterview.prototype.waitNotice = function()&#123;</div><div class="line">	console.log(&quot;某公司的offer到了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="定义模版方法"><a href="#定义模版方法" class="headerlink" title="定义模版方法"></a>定义模版方法</h3><pre><code>作用：封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ITInterview.init = function()&#123;</div><div class="line">	this.writtenTest();</div><div class="line">	this.technicalInterview();</div><div class="line">	this.leader();</div><div class="line">	this.waitNotice();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h2 id="定义子类（百度面试）"><a href="#定义子类（百度面试）" class="headerlink" title="定义子类（百度面试）"></a>定义子类（百度面试）</h2><pre><code>首先子类需要重父类哪里继承所有的方法
let BaiDuInterview = function(){};
BaiDuInterview.prototype = new ITInterview();
</code></pre><h3 id="百度笔试"><a href="#百度笔试" class="headerlink" title="百度笔试"></a>百度笔试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 笔试</div><div class="line">BaiDuInterview.prototype.writtenTest = function()&#123;</div><div class="line">	console.log(&quot;百度公司笔试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="百度技术面试"><a href="#百度技术面试" class="headerlink" title="百度技术面试"></a>百度技术面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 技术面试</div><div class="line">BaiDuInterview.prototype.technicalInterview = function()&#123;</div><div class="line">	console.log(&quot;百度公司技术面试测试&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="百度领导面试"><a href="#百度领导面试" class="headerlink" title="百度领导面试"></a>百度领导面试</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 领导面试</div><div class="line">BaiDuInterview.prototype.leader = function()&#123;</div><div class="line">	console.log(&quot;百度公司leader来面试了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="等offer-1"><a href="#等offer-1" class="headerlink" title="等offer"></a>等offer</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 等通知</div><div class="line">BaiDuInterview.prototype.waitNotice = function()&#123;</div><div class="line">	console.log(&quot;百度公司的offer到了&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><pre><code>let baiduInterview = new BaiDuInterview();
baiduInterview.init();
依次输出：
    百度公司笔试测试
    百度公司技术面试测试
    百度公司leader来面试了
    百度公司的offer到了
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/xu_ya_fei/article/details/51628310" target="_blank" rel="external">JS设计模式之模板方法</a><br>    <a href="https://www.2cto.com/kf/201507/420128.html" target="_blank" rel="external">JavaScript：设计模式之模板方法</a><br>    <a href="http://www.cnblogs.com/tugenhua0707/p/4780227.html" target="_blank" rel="external">javascript模板方法模式</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/11/01/js设计模式-访问者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/01/js设计模式-访问者模式/" itemprop="url">
                  js设计模式-访问者模式
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T20:11:11+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/01/js设计模式-访问者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/01/js设计模式-访问者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  645
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在访问者模式中，主要包括下面几个角色"><a href="#在访问者模式中，主要包括下面几个角色" class="headerlink" title="在访问者模式中，主要包括下面几个角色"></a>在访问者模式中，主要包括下面几个角色</h1><ol>
<li>抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</li>
<li>访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</li>
<li>抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</li>
<li>元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</li>
<li>结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 访问者  </div><div class="line">function Visitor() &#123;  </div><div class="line">  this.visit = function( concreteElement ) &#123;  </div><div class="line">    concreteElement.doSomething();  </div><div class="line">  &#125;  </div><div class="line">&#125; </div><div class="line"></div><div class="line">// 元素类  </div><div class="line">function ConceteElement() &#123;  </div><div class="line">  this.doSomething = function() &#123;  </div><div class="line">    console.log(&quot;这是一个具体元素&quot;);  </div><div class="line">  &#125;  </div><div class="line">  this.accept = function( visitor ) &#123;  </div><div class="line">    visitor.visit(this);  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">// Client  </div><div class="line">var ele = new ConceteElement();  </div><div class="line">var v = new Visitor();  </div><div class="line">ele.accept( v );</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="访问者模式的适用场景"><a href="#访问者模式的适用场景" class="headerlink" title="访问者模式的适用场景"></a>访问者模式的适用场景</h1><ol>
<li>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</li>
<li>假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</li>
</ol>
<h1 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h1><ol>
<li>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</li>
<li>扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。</li>
</ol>
<blockquote>
<p>   参考文档：<br>    <a href="http://blog.csdn.net/itpinpai/article/details/51644922" target="_blank" rel="external">【JS设计模式】访问者模式的代码示例</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/31/Redux-API整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/Redux-API整理/" itemprop="url">
                  Redux-API整理
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T17:29:04+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/31/Redux-API整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/31/Redux-API整理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,622
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redux 定义了一系列的约定（contract）来让你来实现（例如 reducers），同时提供少量辅助函数来把这些约定整合到一起。<br>Redux 只关心如何管理 state。在实际的项目中，你还需要使用 UI 绑定库如 react-redux。</p>
<h1 id="顶级暴露的方法"><a href="#顶级暴露的方法" class="headerlink" title="顶级暴露的方法"></a>顶级暴露的方法</h1><pre><code>createStore(reducer, [initialState])
combineReducers(reducers)
applyMiddleware(...middlewares)
bindActionCreators(actionCreators, dispatch)
compose(...functions)
</code></pre><h1 id="Store-API"><a href="#Store-API" class="headerlink" title="Store API"></a>Store API</h1><pre><code>getState()
dispatch(action)
subscribe(listener)
getReducer()
replaceReducer(nextReducer)
</code></pre><h1 id="createStore-reducer-initialState-enhancer"><a href="#createStore-reducer-initialState-enhancer" class="headerlink" title="createStore(reducer, [initialState], enhancer)"></a>createStore(reducer, [initialState], enhancer)</h1><pre><code>定义：
    创建一个 Redux store 来以存放应用中所有的 state。
    应用中应有且仅有一个 store。
参数：
    1.reducer (Function): 接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。
    2.[initialState] (any): 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 合
        并后传给它，或者从之前保存的用户会话中恢复一个传给它。
    3.enhancer (Function): Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过
        的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。
返回值：
    (Store): 保存了应用所有 state 的对象。改变 state 的惟一方法是 dispatch action。
    你也可以 subscribe 监听 state 的变化，然后更新 UI。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line"></div><div class="line">function todos(state = [], action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">	case &apos;ADD_TODO&apos;:</div><div class="line">	  return state.concat([ action.text ])</div><div class="line">	default:</div><div class="line">	  return state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let store = createStore(todos, [ &apos;Use Redux&apos; ])</div><div class="line"></div><div class="line">store.dispatch(&#123;</div><div class="line">  type: &apos;ADD_TODO&apos;,</div><div class="line">  text: &apos;Read the docs&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(store.getState())</div><div class="line">// [ &apos;Use Redux&apos;, &apos;Read the docs&apos; ]</div></pre></td></tr></table></figure>

注意：
1.应用中不要创建多个 store！相反，使用 combineReducers 来把多个 reducer 创建成一个根 reducer。
2.如果 state 是普通对象，永远不要修改它！
    数组：[].concat()、[].slice()
    对象：Object.assian({}, obj)、{...oldObj, ...newObj}
</code></pre><h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h1><pre><code>Store 就是用来维持应用所有的 state 树 的一个对象。
改变 store 内 state 的惟一途径是对它 dispatch 一个 action。
</code></pre><h2 id="getState"><a href="#getState" class="headerlink" title="getState()"></a>getState()</h2><pre><code>作用：
    返回应用当前的 state 树。
返回值：
    (any): 应用当前的 state 树。
</code></pre><h2 id="dispatch-action"><a href="#dispatch-action" class="headerlink" title="dispatch(action)"></a>dispatch(action)</h2><pre><code>作用：    
    分发 action。这是触发 state 变化的惟一途径。
    会使用当前 getState() 的结果和传入的 action 以同步方式的调用 store 的 reduce 函数。
    返回值会被作为下一个 state。
参数：
    1.action (Object): 描述应用变化的普通对象。
        Action 是把数据传入 store 的惟一途径，所以任何数据，无论来自 UI 事件，网络回调
        或者是其它资源如 WebSockets，最终都应该以 action 的形式被 dispatch。
        例如：{type: &apos;Add&apos;, payload: &apos;我是非必填&apos;}
返回值：
    (Object): 要 dispatch 的 action。
注意：
    同步 -- 使用 createStore 创建的 “纯正” store 只支持普通对象类型的 action，
    而且会立即传到 reducer 来执行。
    异步 -- 如果你用 applyMiddleware 来套住 createStore 时，middleware 可以修改 
    action 的执行，并支持执行 dispatch intent（意图）。
    你需要手动安装 redux-thunk 或者 redux-promise 库。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">let store = createStore(todos, [ &apos;Use Redux&apos; ])</div><div class="line"></div><div class="line">function addTodo(text) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;ADD_TODO&apos;,</div><div class="line">	text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.dispatch(addTodo(&apos;Read the docs&apos;))</div><div class="line">store.dispatch(addTodo(&apos;Read about the middleware&apos;))</div></pre></td></tr></table></figure>
</code></pre><h2 id="subscribe-listener"><a href="#subscribe-listener" class="headerlink" title="subscribe(listener)"></a>subscribe(listener)</h2><pre><code>作用：
    添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。
    你可以在回调函数里调用 getState() 来拿到当前 state。
    如果需要解绑这个变化监听器，执行 subscribe 返回的函数即可。
参数：
    1.listener (Function): 每当 dispatch action 的时候都会执行的回调。
返回值：
    (Function): 一个可以解绑变化监听器的函数。
</code></pre><h2 id="replaceReducer-nextReducer"><a href="#replaceReducer-nextReducer" class="headerlink" title="replaceReducer(nextReducer)"></a>replaceReducer(nextReducer)</h2><pre><code>作用：
    替换 store 当前用来计算 state 的 reducer。
    只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。
参数：
    1.reducer (Function) store 会使用的下一个 reducer。
</code></pre><h1 id="combineReducers-reducers"><a href="#combineReducers-reducers" class="headerlink" title="combineReducers(reducers)"></a>combineReducers(reducers)</h1><pre><code>定义：
    把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，
    然后就可以对这个 reducer 调用 createStore。
    需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分。
    合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。
    state 对象的结构由传入的多个 reducer 的 key 决定。    
    最终，state 对象的结构会是这样的：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  reducer1: ...</div><div class="line">  reducer2: ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    PS：通过为传入对象的 reducer 命名不同来控制 state key 的命名。
    例如，你可以调用 combineReducers({ todos: myTodosReducer, counter: myCounterReducer }) 
    将 state 结构变为 { todos, counter }。
参数：
    1.reducers (Object): 一个对象，它的值（value） 对应不同的 reducer 函数，这些 reducer 
    函数后面会被合并成一个。
返回值：
    (Function)：一个调用 reducers 对象里所有 reducer 的 reducer，并且构造一个与 reducers 
    对象结构相同的 state 对象。
</code></pre><h1 id="applyMiddleware-…middlewares"><a href="#applyMiddleware-…middlewares" class="headerlink" title="applyMiddleware(…middlewares)"></a>applyMiddleware(…middlewares)</h1><pre><code>Middleware 只是包装了 store 的 dispatch 方法。
使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。    
Action 发出以后，过一段时间再执行 Reducer，这就是异步。    
redux-thunk
redux-promise
redux-devtools
参数：
    1....middlewares (arguments): 遵循 Redux middleware API 的函数。
        每个 middleware 接受 Store 的 dispatch 和 getState 函数作为命名参数，并返回一个函数。
    规格：
        ({ getState, dispatch }) =&gt; next =&gt; action。
返回值：
    (Function) 一个应用了 middleware 后的 store enhancer。这个 store enhancer 就是一个函数，
    并且需要应用到 createStore。
    它会返回一个应用了 middleware 的新的 createStore。
使用 Thunk Middleware 来做异步 Action    
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore, combineReducers, applyMiddleware &#125; from &apos;redux&apos;</div><div class="line">import thunk from &apos;redux-thunk&apos;</div><div class="line">import * as reducers from &apos;./reducers&apos;</div><div class="line"></div><div class="line">// 调用 applyMiddleware，使用 middleware 增强 createStore：</div><div class="line">let createStoreWithMiddleware = applyMiddleware(thunk)(createStore)</div><div class="line"></div><div class="line">// 像原生 createStore 一样使用。</div><div class="line">let reducer = combineReducers(reducers)</div><div class="line">let store = createStoreWithMiddleware(reducer)</div><div class="line"></div><div class="line">function fetchSecretSauce() &#123;</div><div class="line">  return fetch(&apos;https://www.google.com/search?q=secret+sauce&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这些是你已熟悉的普通 action creator。</div><div class="line">// 它们返回的 action 不需要任何 middleware 就能被 dispatch。</div><div class="line">// 但是，他们只表达「事实」，并不表达「异步数据流」</div><div class="line"></div><div class="line">function makeASandwich(forPerson, secretSauce) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;MAKE_SANDWICH&apos;,</div><div class="line">	forPerson,</div><div class="line">	secretSauce</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function apologize(fromPerson, toPerson, error) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;APOLOGIZE&apos;,</div><div class="line">	fromPerson,</div><div class="line">	toPerson,</div><div class="line">	error</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function withdrawMoney(amount) &#123;</div><div class="line">  return &#123;</div><div class="line">	type: &apos;WITHDRAW&apos;,</div><div class="line">	amount</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 即使不使用 middleware，你也可以 dispatch action：</div><div class="line">store.dispatch(withdrawMoney(100))</div><div class="line"></div><div class="line">// 但是怎样处理异步 action 呢，</div><div class="line">// 比如 API 调用，或者是路由跳转？</div><div class="line"></div><div class="line">// 来看一下 thunk。</div><div class="line">// Thunk 就是一个返回函数的函数。</div><div class="line">// 下面就是一个 thunk。</div><div class="line"></div><div class="line">function makeASandwichWithSecretSauce(forPerson) &#123;</div><div class="line"></div><div class="line">  // 控制反转！</div><div class="line">  // 返回一个接收 `dispatch` 的函数。</div><div class="line">  // Thunk middleware 知道如何把异步的 thunk action 转为普通 action。</div><div class="line"></div><div class="line">  return function (dispatch) &#123;</div><div class="line">	return fetchSecretSauce().then(</div><div class="line">	  sauce =&gt; dispatch(makeASandwich(forPerson, sauce)),</div><div class="line">	  error =&gt; dispatch(apologize(&apos;The Sandwich Shop&apos;, forPerson, error))</div><div class="line">	)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="bindActionCreators-actionCreators-dispatch"><a href="#bindActionCreators-actionCreators-dispatch" class="headerlink" title="bindActionCreators(actionCreators, dispatch)"></a>bindActionCreators(actionCreators, dispatch)</h1><pre><code>定义：
    惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，
    却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。
参数：
    1.actionCreators (Function or Object): 一个 action creator，或者键值是 action creators 的对象。
    2.dispatch (Function): 一个 dispatch 函数，由 Store 实例提供。
返回值：
    (Function or Object): 一个与原对象类似的对象，只不过这个对象中的的每个函数值都可以直接 dispatch action。
    如果传入的是一个函数，返回的也是一个函数。
</code></pre><h1 id="compose-…functions"><a href="#compose-…functions" class="headerlink" title="compose(…functions)"></a>compose(…functions)</h1><pre><code>定义：
    从右到左来组合多个函数。
    这是函数式编程中的方法，为了方便，被放到了 Redux 里。 
    当需要把多个 store 增强器依次执行的时候，需要用到它。
参数：
    (arguments): 需要合成的多个函数。每个函数都接收一个函数作为参数，然后返回一个函数。
返回值：
    (Function): 从右到左把接收到的函数合成后的最终函数。
</code></pre><h1 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h1><pre><code>作用：Redux 官方提供的 React 绑定库。
本库深受 分离容器组件和展示组件 思想启发。
在应用中，只有最顶层组件是对 Redux 可知（例如路由处理）这是很好的。
所有它们的子组件都应该是“笨拙”的，并且是通过 props 获取数据。
对比 容器组件 和 展示组件
</code></pre><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">容器组件</th>
<th style="text-align:right">展示组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置</td>
<td style="text-align:center">最顶层，路由处理</td>
<td style="text-align:right">中间和子组件</td>
</tr>
<tr>
<td>使用 Redux</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>读取数据</td>
<td style="text-align:center">从 Redux 获取 state</td>
<td style="text-align:right">从 props 获取数据</td>
</tr>
<tr>
<td>修改数据</td>
<td style="text-align:center">向 Redux 发起 actions</td>
<td style="text-align:right">从 props 调用回调函数</td>
</tr>
</tbody>
</table>
<h2 id="不使用-Redux-的展示组件"><a href="#不使用-Redux-的展示组件" class="headerlink" title="不使用 Redux 的展示组件"></a>不使用 Redux 的展示组件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from &apos;react&apos;;</div><div class="line"></div><div class="line">export default class Counter extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">	return (</div><div class="line">	  &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;</div><div class="line">		&#123;this.props.value&#125;</div><div class="line">	  &lt;/button&gt;</div><div class="line">	);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="容器组件使用-connect-方法连接-Redux"><a href="#容器组件使用-connect-方法连接-Redux" class="headerlink" title="容器组件使用 connect() 方法连接 Redux"></a>容器组件使用 connect() 方法连接 Redux</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</div><div class="line"></div><div class="line">import Counter from &apos;../components/Counter&apos;;</div><div class="line">import &#123; increment &#125; from &apos;../actionsCreators&apos;;</div><div class="line"></div><div class="line">// 哪些 Redux 全局的 state 是我们组件想要通过 props 获取的？</div><div class="line">function mapStateToProps(state) &#123;</div><div class="line">  return &#123;</div><div class="line">	value: state.counter</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 哪些 action 创建函数是我们想要通过 props 获取的？</div><div class="line">function mapDispatchToProps(dispatch) &#123;</div><div class="line">  return &#123;</div><div class="line">	onIncrement: () =&gt; dispatch(increment())</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(Counter);</div></pre></td></tr></table></figure>
</code></pre><h2 id="注入-Redux-Store"><a href="#注入-Redux-Store" class="headerlink" title="注入 Redux Store"></a>注入 Redux Store</h2><pre><code>我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。
对于服务端渲染而言，你可以在处理请求中完成这个。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	import ReactDOM from &apos;react-dom&apos;;</div><div class="line">	import &#123; Component &#125; from &apos;react&apos;;</div><div class="line">	import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line"></div><div class="line">	class App extends Component &#123;</div><div class="line">	  render() &#123;</div><div class="line">		// ...</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	const targetEl = document.getElementById(&apos;root&apos;);</div><div class="line"></div><div class="line">	ReactDOM.render(</div><div class="line">	  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">		&lt;App /&gt;</div><div class="line">	  &lt;/Provider&gt;,</div><div class="line">	  targetEl</div><div class="line">);</div></pre></td></tr></table></figure>
</code></pre><h2 id="具体-API"><a href="#具体-API" class="headerlink" title="具体 API"></a>具体 API</h2><h3 id=""><a href="#" class="headerlink" title=""></a><provider store=""></provider></h3><pre><code>作用：
    &lt;Provider store&gt; 使组件层级中的 connect() 方法都能够获得 Redux store。
    正常情况下，你的根组件应该嵌套在 &lt;Provider&gt; 中才能使用 connect() 方法。
属性：
    store (Redux Store): 应用程序中唯一的 Redux store 对象
    children (ReactElement) 组件层级的根组件。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">	&lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt;</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  targetEl</div><div class="line">);</div></pre></td></tr></table></figure>
</code></pre><h3 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h3><pre><code>作用：
    连接 React 组件与 Redux store。
    连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。
参数：
    1.[mapStateToProps(state, [ownProps]): stateProps] (Function): 
        如果定义该参数，组件将会监听 Redux store 的变化。
    2.[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 
        如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，
        而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。
    3.[mergeProps(stateProps, dispatchProps, ownProps): props] (Function):
        如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的
        props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。
    4.[options] (Object) 如果指定这个参数，可以定制 connector 的行为。
返回值：
    根据配置信息，返回一个注入了 state 和 action creator 的 React 组件。
静态属性：
    WrappedComponent (Component): 传递到 connect() 函数的原始组件类。
静态方法：
    组件原来的静态方法都被提升到被包装的 React 组件。
实例方法：
    getWrappedInstance(): ReactComponent
    仅当 connect() 函数的第四个参数 options 设置了 { withRef: true } 才返回被包装的组件实例。
</code></pre><blockquote>
<p>   参考文档：<br>    <a href="https://github.com/react-guide/redux-tutorial-cn" target="_blank" rel="external">redux 官方文档</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://fanerge.github.io/2017/10/29/React-routerV4总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余真帆-fanerge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余真帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/React-routerV4总结/" itemprop="url">
                  React-routerV4总结
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T20:01:36+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/29/React-routerV4总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/29/React-routerV4总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,521
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h1><pre><code>作用：
    &lt;Router&gt; 使用 HTML5 提供的 history API (pushState, replaceState 和 popstate 事件) 来保持 UI 和 URL 的同步。
属性：
    basename: string
        当前位置的基准 URL。如果你的页面部署在服务器的二级（子）目录，你需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。
    getUserConfirmation: func
        当导航需要确认时执行的函数。默认使用 window.confirm。
    forceRefresh: bool
        当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true。
    keyLength: number
        location.key 的长度。默认是 6。
    children: node
        渲染单一子组件（元素）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;</div><div class="line"></div><div class="line">&lt;BrowserRouter</div><div class="line">  basename=&quot;/calendar&quot;</div><div class="line">  forceRefresh=&quot;false&quot;</div><div class="line">  getUserConfirmation=&#123;optionalFunc&#125;</div><div class="line">  keyLength=&quot;10&quot;</div><div class="line">&gt;</div><div class="line">  &lt;Link to=&quot;/today&quot; /&gt; // 渲染为 &lt;a href=&quot;/calendar/today&quot;&gt;</div><div class="line">&lt;/BrowserRouter&gt;</div></pre></td></tr></table></figure>
</code></pre><h1 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h1><pre><code>作用：
    HashRouter 是一种特定的 &lt;Router&gt;， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步。
属性：
    basename: string
        当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。
    getUserConfirmation: func
        当导航需要确认时执行的函数。默认使用 window.confirm。
    hashType: string
        window.location.hash 使用的 hash 类型。有如下几种：
        &quot;slash&quot; - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops
        &quot;noslash&quot; - 后面没有斜杠，例如 # 和 #sunshine/lollipops
        &quot;hashbang&quot; - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops
        默认为 &quot;slash&quot;。
    children: node
        渲染单一子组件（元素）。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import &#123; HashRouter &#125; from &apos;react-router-dom&apos;</div><div class="line"></div><div class="line">&lt;HashRouter&gt;</div><div class="line">  &lt;App/&gt;</div><div class="line">&lt;/HashRouter&gt;</div></pre></td></tr></table></figure>
</code></pre><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><pre><code>作用：
    为您的应用提供声明式的、无障碍导航。        
属性：    
    to: string/object
        需要跳转到的路径(pathname)或地址（location）。
        需要跳转到的地址（location）。
    replace: bool
        当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。
        当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。    
</code></pre><pre><code>&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;
&lt;Link to={{
  pathname: '/courses',
  search: '?sort=name',
  hash: '#the-hash',
  state: { fromDashboard: true }
}}/&gt;
</code></pre><h1 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h1><pre><code>作用：    
    为当前 URL 添加 class 和 style。
属性：
    activeClassName: string
        选中 URL 是添加的class。
    activeStyle：object
        选中 URL 是添加的style。
    exact: bool    
        如果为 true，path 为 &apos;/one&apos; 的路由将不能匹配 &apos;/one/two&apos;，反之，亦然。    
    strict: bool
        对路径末尾斜杠的匹配。如果为 true。path 为 &apos;/one/&apos; 将不能匹配 &apos;/one&apos; 但可以匹配 &apos;/one/two&apos;。
    isActive: func    
        为URL匹配添加更严谨的逻辑函数。    
</code></pre><h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><pre><code>作用：    
    当用户离开当前页面前做出一些提示。
属性：
    message: string/func
        当用户离开当前页面时，设置的提示信息。
        当用户离开当前页面时，设置的回掉函数
    when: bool
        通过设置一定条件要决定是否启用 Prompt
</code></pre><h1 id="MemoryRouter"><a href="#MemoryRouter" class="headerlink" title="MemoryRouter"></a>MemoryRouter</h1><pre><code>作用：
    无 DOM 的环境。

属性：
    initialEntries: array
        一个 history 堆栈的数组。
    initialIndex: number
        在 initialEntries 数组中的初始index。
    getUserConfirmation: func
    keyLength: number
    children: node
</code></pre><h1 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h1><pre><code>作用：
    重定向将替代当前的location 中的 history。
属性：
    to: string/object
        重定向string
        重定向object
    push: bool
        当为 true 时，替换掉整个history，而不是当前这一条。
    from: string    
        重定向的路径名。
</code></pre><h1 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h1><pre><code>作用：
    它最基本的职责就是当页面的访问地址与 Route 上的 path 匹配时，就渲染出对应的 UI 界面。
属性：
    component: func
        只有当访问地址和路由匹配时，一个 React component 才会被渲染，此时此组件接受 route props (match, location, history)。
    render: func    
        此方法适用于内联渲染，而且不会产生上文说的重复装载问题。
    children: func
        有时候你可能只想知道访问地址是否被匹配，然后改变下别的东西，而不仅仅是对应的页面。
    path: string
    exact: bool
    strict: bool
</code></pre><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><pre><code>作用：底层路由接口组件，使用封装后的组件代替。    
    &lt;BrowserRouter&gt;
    &lt;HashRouter&gt;
    &lt;MemoryRouter&gt;
    &lt;NativeRouter&gt;
    &lt;StaticRouter&gt;
属性：
    history：object
        导航的history对象
    children: node
</code></pre><h1 id="StaticRouter"><a href="#StaticRouter" class="headerlink" title="StaticRouter"></a>StaticRouter</h1><pre><code>定义：
    不会更改location的 &lt;Router&gt;，服务端渲染。
属性：
    basename: string
    location: string    
    context: object    
    children: node    
</code></pre><h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><pre><code>定义：
    只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;。
    我们只想渲染出第一个匹配的路由就可以了，于是 &lt;Switch&gt; 应运而生！
属性：
    children: node
</code></pre><h1 id="对象和方法"><a href="#对象和方法" class="headerlink" title="对象和方法"></a>对象和方法</h1><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><h3 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h3><pre><code>1.browser history -- HTML5 history API
2.hash history    -- 低版本浏览器
3.memory history  -- 无DOM环境（RN 和 Node）
</code></pre><h3 id="histoty对象详解"><a href="#histoty对象详解" class="headerlink" title="histoty对象详解"></a>histoty对象详解</h3><pre><code>length -- number 浏览历史堆栈中的条目数。        
action -- string 路由跳转到当前执行页面的动作，分为 PUSH、REPLACE、POP。
location -- object 当前访问地址信息组成的对象
    （pathname、search、hash、state）

push(path, [state]) 在历史堆栈信息里加入一个新条目。
replace(path, [state]) 在历史堆栈信息里替换掉当前的条目
go(n) 将 history 堆栈中的指针向前移动 n。
goBack() 等同于 go(-1)
goForward 等同于 go(1)
block(prompt) 阻止跳转
</code></pre><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><pre><code>location 是指你当前的位置，将要去的位置，或是之前所在的位置
在以下情境中可以获取 location 对象:
    1.在 Route component 中，以 this.props.location 获取
    2.在 Route render 中，以 ({location}) =&gt; () 方式获取
    3.在 Route children 中，以 ({location}) =&gt; () 方式获取
    4.在 withRouter 中，以 this.props.location 的方式获取
可以在不同情境中使用 location：
    1.&lt;Link to={location} /&gt;
    2.&lt;NaviveLink to={location} /&gt;
    3.&lt;Redirect to={location /&gt;
    4.history.push(location)
    5.history.replace(location)
</code></pre><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><pre><code>match 对象包含了 &lt;Route path&gt; 如何与 URL 匹配的信息，具有以下属性：
    1.params: object 路径参数，通过解析 URL 中的动态部分获得键值对
    2.isExact: bool 为 true 时，整个 URL 都需要匹配
    3.path: string 用来匹配的路径模式，用于创建嵌套的 &lt;Route&gt;
    4.url: string URL 匹配的部分，用于嵌套的 &lt;Link&gt;
在以下情境中可以获取 match 对象
    1.在 Route component 中，以 this.props.match获取
    2.在 Route render 中，以 ({match}) =&gt; () 方式获取
    3.在 Route children 中，以 ({match}) =&gt; () 方式获取
    4.在 withRouter 中，以 this.props.match的方式获取
    5.matchPath 的返回值
注：当一个 Route 没有 path 时，它会匹配一切路径。
</code></pre><h2 id="matchPath"><a href="#matchPath" class="headerlink" title="matchPath"></a>matchPath</h2><pre><code>pathname
props
</code></pre><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><blockquote>
<p>   参考文档：<br>    <a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" rel="external">MDN-history</a><br>    <a href="http://blog.csdn.net/sinat_17775997/article/details/69218382" target="_blank" rel="external">初探 React Router 4.0</a></p>
</blockquote>

          
        
      
    </div>
	<div>
	  
	</div>
    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>
	<div>
	  
	</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="余真帆-fanerge" />
          <p class="site-author-name" itemprop="name">余真帆-fanerge</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">130</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fanerge/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="twitter" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="weibo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57cede6d5bbb50005b97536a" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                  掘金
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余真帆-fanerge</span>
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共172.1k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fanerge.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="80" height="160" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 100px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/hibiki/hibiki.model.json",0.5)</script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
